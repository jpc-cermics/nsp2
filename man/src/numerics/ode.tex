% -*- mode: latex -*-

\mansection{ode}
\begin{mandesc}
  \short{ode}{ordinary differential equations solver}
\end{mandesc}

% -- Calling sequence section
\begin{calling_sequence}
\begin{verbatim}
x = ode(x0,t0,t,f)
x = ode(x0,t0,t,f, atol=ea, rtol=er, jac=Df, args=obj, type=str, odeoptions=htable)
\end{verbatim}
\end{calling_sequence}
% -- Parameters
\begin{parameters}
  \begin{varlist}
    \vname{x0}:real column vector, the initial condition
    \vname{t0}:real scalar, the initial time
    \vname{t}: real vector with increasing time instants at which the solution must be recorded
    \vname{f}: nsp function defining the second member of the differential equation
    \vname{atol=ea, rtol=er}: optional named argument, relative to the requested maximum error on a time step 
                     (default is atol=1e-9, rtol=0). atol could be a vector of same size than x0.
    \vname{jac=Df}: optional named argument. Df should be a nsp function (the Jacobian of f)
    \vname{args=obj}: optional named argument (could be any nsp object), useful to pass additional parameters needed by
    the function f (and by the function Df if it is provided).
    \vname{type=str}: optional named argument (scalar string) could be "default" (which is the default) or "discrete"
    \vname{odeoptions}: an hash table of parameters for fine tuning of the solver.
  \end{varlist}
\end{parameters}

\begin{mandescription}

When type is not "discrete", this function computes an approximate solution of the ordinary differential equation:
$$
\begin{array}{l}
   \dot{x}(t) = f(t, x(t)), \; f: R \times R^d \rightarrow  R^d \\
   x(t_0) = x_0  \in  R^d
\end{array}
$$
using the Livermore solvers odepack. Currently only lsoda is interfaced and this solver begin with the Adams
method (for nonstiff systems) but switches  automatically to bdf method if the differential equation is detected
as stiff. 

\itemdesc{form of the function {\tt f}}
The function $f$ takes as first argument a scalar $t$, then a vector $x$ of length $d$ as 2d argument and 
must output a vector of length $d$. Note that even if $f$ doesn't depend explicitly of the time $t$ (case of an autonomous differential equation)
it should nevertheless have this parameter as first argument. In brief \verb+f+ should have the
form:
\begin{quote}
{\tt function y = f(t,x) \\
      ....}
  \end{quote}

\itemdesc{optional argument {\tt args}}
Additional parameters for the function $f$ (and also for the function which computes the Jacobian 
if it is provided by the user) could be passed using \verb+args=obj+ where obj could be any nsp 
object (see examples). In this case \verb+f+ has the form:
\begin{quote}
{\tt function y = f(t,x,obj) \\
      ....}
\end{quote}

\itemdesc{the vector of time instants  {\tt t}}
The (approximate) solution is got at the time instants defined by the argument \verb+t+.
If \verb+t+ as $n$ components says  \verb+t = [t1, t2, ..., tn]+ then the output is a
$d \times n$ array and the k th column is an approximation of $x(tk)$. This output
time instants don't correspond to time step taken by the solver (see details here
after).


\itemdesc{optional atol and rtol parameters: solver accuracy control}
At each time step taken by the solver says from $\tau_{k-1}$ to  $\tau_k = \tau_{k-1} + (\Delta t)_k$
the estimated local error in the i th component $x_i(\tau_k)$ (that is the error in 
$x_i(\tau_k)$ assuming that $x(\tau_{k-1})$ is exact) is controlled so as to be less 
than $etol_k$ where:
$$
etol_k =
\left\{
\begin{array}{l}
 rtol | x_k | + atol  \mbox{ if } atol \mbox { is a scalar} \\
 rtol | x_k | + atol_k  \mbox{ if } atol \mbox { is a vector}
\end{array}
\right.
$$
 Btw note that the output time instants  of the vector \verb+t+ don't correspond 
to the time steps taken by the solver. The  time steps $(\Delta t)_k$
(and also the order of the current formula) are choosen by the solver such 
that to be both efficient and to respect the required local tolerance. Note 
also that the global error could be more larger than the local error. The 
solution at the wanted output time instants is got from an interpolary 
formula (wich is in fact natural to the multistep method used by lsoda).

\itemdesc{optional jac parameter}
The solver needs $Df$ the jacobian of $x \mapsto f(t,x)$ and this function could be provided by the user with the optional named argument 
jac. When jac is not given the solver computes an approximation using finite differences. Note that, like for \verb+f+, the formal argument
\verb+t+ should be present even if the Jacobian don't depends explicitly of the time. So the header of the nsp 
function defining the Jacobian of $f$ should be of the form:
\begin{quote}
{\tt function J = Df(t,x) \\
      ....}\\
or:\\
{\tt function J = Df(t,x,obj) \\
     ....}
\end{quote}
when {\tt obj} is provided with {\tt args=obj}.

\itemdesc{odeoptions: fine solver tuning}
odeoptions will be described in a future version of this help page.

\end{mandescription} 

\begin{examples}
  
\paragraph{example 1} the most simple example: we want to integrate:
$$
  \dot{x}(t) = - x, \; x(0) = 1, 
$$ 
the solution is known ($x(t) = exp(-t)$);
\begin{program}\HCode{function y=f1(t,x);y=-x;endfunction\Hnewline
t = linspace(0,4,10);\Hnewline
x = ode(1,0,t,f1)\Hnewline
exp(-t)}
\end{program}
  
  
\paragraph{example 2} The Brusselator. We want to solve:
$$
\left\{
\begin{array}{l}
\frac{du_1}{dt} = 2 - (6 + \epsilon) u_1 + u_1^2 u_2 \\
\frac{du_2}{dt} = (5 + \epsilon) u_1 - u_1^2 u_2
\end{array}
\right.
$$
for some initial condition $u(0) = u0$ and some parameter $\epsilon$.
\begin{program}\HCode{function [f] = Brusselator(t,u,eps)\Hnewline
   f = [ 2 - (6+eps)*u(1) + u(1)^2*u(2);...\Hnewline
         (5+eps)*u(1) - u(1)^2*u(2)]\Hnewline
endfunction\Hnewline
eps = 0.1 // parameter value\Hnewline
T = 200 ;  // final integration time\Hnewline
t = linspace(0,T,8000); // time instants to record to solution\Hnewline
u0 = [0;0];  // initial condition (starting point)\Hnewline
// solve the ode\Hnewline
u = ode(u0, 0, t, Brusselator, rtol = 1e-9, atol = 1e-10, args=eps);\Hnewline
// plot solution in the phase space\Hnewline
plot2d(u(1,:)',u(2,:)', style=2, rect=[-0.5,-0.5,6,6])\Hnewline
plot2d(u0(1),u0(2),style=-5, strf="000",leg='starting point')}
\end{program}
  
  
\paragraph{example 3} pure, damped or amplified oscillators. The second order differential
equation:
$$
  \ddot{x}(t) + 2 \alpha \dot{x}(t) + k x(t) = 0, \; x(0)=x_0, \dot{x}(0) = v_0 
$$ 
corresponds for $k > 0$ and $\alpha^2 < k$ (damping or amplification factor not too high) to 
a pure oscillator when $\alpha=0$, a damped oscillator when $\alpha>0$ and to an amplified 
oscillator for $\alpha<0$. Its is easily solved analytically:
$$
  x(t) = e^{-\alpha t}( A \cos(\omega t) + B \sin(\omega t) ) \; \mbox{with: }
\left\{ \begin{array}{l}
\omega = \sqrt{k - \alpha^2} \\
A = x_0, \; B = (v_0 + \alpha x_0)/\omega
\end{array} \right.
$$
To use {\tt ode}, one should put this equation in a system of two first order differential 
equations:
$$
u(t) =  \left[ \begin{array}{c} u_1(t) \\  u_2(t)\end{array} \right]  \equiv  \left[ \begin{array}{c} x(t) \\
    \dot{x}(t)\end{array} \right], \mbox{ and }
\dot{u}(t) =  \left[ \begin{array}{c} \dot{u}_1(t) \\ \dot{u}_2(t) \end{array} \right] =
    \left( \begin{array}{c} u_2(t) \\  -k u_1(t) - 2 \alpha u_2(t) \end{array} \right) = f(u)
$$
So the code (we choose to pass the 2 parameters with an  \manlink{hash table}{hash}):
\begin{program}\HCode{function [f] = oscillator(t,u,p)\Hnewline
   f = [ u(2); -p.k*u(1) -2*p.alpha*u(2)];\Hnewline
endfunction\Hnewline
T = 16 ;  // final integration time\Hnewline
t = linspace(0,T,1000); // time instants to record to solution\Hnewline
u0 = [1;0];  // initial condition (x(0)=1, dx/dt(0)=0)\Hnewline
// solve the ode\Hnewline
up = ode(u0, 0, t, oscillator, args=hash(2,k=1,alpha=0));\Hnewline
ud = ode(u0, 0, t, oscillator, args=hash(2,k=1,alpha=0.02));\Hnewline
ua = ode(u0, 0, t, oscillator, args=hash(2,k=1,alpha=-0.02));\Hnewline
// plot the 3 solutions\Hnewline
xbasc()\Hnewline
subplot(1,2,1)\Hnewline
plot2d([up(1,:)',ud(1,:)',ua(1,:)'],[up(2,:)',ud(2,:)',ua(2,:)'], style=[2,3,5], leg="pure@damped@amplified")\Hnewline
xtitle("trajectories in phase space","x(t)","dx/dt(t)")\Hnewline
subplot(2,2,2)\Hnewline
plot2d(t',[up(1,:)',ud(1,:)',ua(1,:)'],style=[2,3,5], leg="pure@damped@amplified")\Hnewline
xtitle("position fct of time","t","x(t)")\Hnewline
subplot(2,2,4)\Hnewline
plot2d(t',[up(2,:)',ud(2,:)',ua(2,:)'],style=[2,3,5], leg="pure@damped@amplified")\Hnewline
xtitle("velocity fct of time","t","dx/dt(t)")}
\end{program}
  

 
\end{examples}

\begin{manseealso}
  \manlink{intg}{intg}, \manlink{int2d}{int2d}  
\end{manseealso}

% -- Authors
\begin{authors}
 Linda r. Petzold, Alan C. Hindmarsh. Nsp interface: Jean-Philippe Chancelier
\end{authors}
