% -*- mode: latex -*-

\mansection{ode}
\begin{mandesc}
  \short{ode}{ordinary differential equations solver}
\end{mandesc}

% -- Calling sequence section
\begin{calling_sequence}
\begin{verbatim}
x = ode(x0,t0,t,f)
x = ode(x0,t0,t,f, atol=ea, rtol=er, jac=Df, args=obj, type=str, odeoptions=htable)
\end{verbatim}
\end{calling_sequence}
% -- Parameters
\begin{parameters}
  \begin{varlist}
    \vname{x0}: real column vector, the initial condition.
    \vname{t0}: real scalar, the initial time.
    \vname{t}: real vector with increasing time instants at which the solution must be computed and recorded.
    \vname{f}: nsp function defining the vector field of the differential equation.
    \vname{atol=ea, rtol=er}: optional named argument, relative to the requested maximum error on a time step 
    (default is \verb+atol=1e-9+ and \verb+rtol=0+). \verb+atol+ can be a vector of same size as 
    the vector \verb+x0+.
    \vname{jac=Df}: optional named argument. \verb+Df+ should be a nsp function giving the Jacobian of function \verb+f+.
    \vname{args=obj}: optional named argument used to pass additional parameters to the function \verb+f+ 
    (and to the function \verb+Df+ if it is provided). It can be any nsp object.
    \vname{type=str}: optional named argument (scalar string) could be "default" (which is the default) or "discrete"
    \vname{odeoptions}: a hash table of parameters for fine manual tuning of the ode solver.
  \end{varlist}
\end{parameters}

\begin{mandescription}

When type is not "discrete", this function computes an approximate solution of the ordinary differential equation:
$$
\begin{array}{l}
   \dot{x}(t) = f(t, x(t)), \; f: R \times R^d \rightarrow  R^d \\
   x(t_0) = x_0  \in  R^d
\end{array}
$$
using the Livermore solvers odepack. Currently only lsoda is interfaced and this solver begin with the Adams
method (for nonstiff systems) but switches  automatically to bdf method if the differential equation is detected
as being stiff. 

\itemdesc{header of the function {\tt f}}
The function $f$ takes as first argument a scalar $t$, then a vector $x$ of length $d$ as 2d argument and 
must output a vector of length $d$. Note that even if $f$ doesn't depend explicitly of the time $t$ (case of an autonomous differential equation)
it should nevertheless have this parameter as first argument. In brief \verb+f+ should have the
form:
\begin{quote}
{\tt function y = f(t,x) \\
      ....}
  \end{quote}

\itemdesc{optional argument {\tt args}}
Additional parameters for the function $f$ (and also for the function which computes the Jacobian 
if it is provided by the user) could be passed using \verb+args=obj+ where \verb+obj+ can be any nsp 
object (see examples). In this case \verb+f+ has the form:
\begin{quote}
{\tt function y = f(t,x,obj) \\
      ....}
\end{quote}

\itemdesc{the vector of time instants  {\tt t}}
The (approximate) solution is got at the time instants defined by the argument \verb+t+.
If \verb+t+ as $n$ components says  \verb+t = [t1, t2, ..., tn]+ then the output is a
$d \times n$ array and the k th column is an approximation of $x(tk)$. This output
time instants don't correspond to time step taken by the solver (see details here
after).


\itemdesc{optional {\tt atol} and {\tt rtol} parameters: solver accuracy control}
At each time step taken by the solver says from $\tau_{k-1}$ to  $\tau_k = \tau_{k-1} + (\Delta t)_k$
the estimated local error in the i th component $x_i(\tau_k)$ (that is the error in 
$x_i(\tau_k)$ assuming that $x(\tau_{k-1})$ is exact) is controlled so as to be less 
than $etol_k$ where:
$$
etol_k =
\left\{
\begin{array}{l}
 rtol | x_k | + atol  \mbox{ if } atol \mbox { is a scalar} \\
 rtol | x_k | + atol_k  \mbox{ if } atol \mbox { is a vector}
\end{array}
\right.
$$
 Btw note that the output time instants  of the vector \verb+t+ don't correspond 
to the time steps taken by the solver. The  time steps $(\Delta t)_k$
(and also the order of the current formula) are choosen by the solver such 
that to be both efficient and to respect the required local tolerance. Note 
also that the global error could be more larger than the local error. The 
solution at the wanted output time instants is got from an interpolary 
formula (wich is in fact natural to the multistep method used by lsoda).

\itemdesc{optional jac parameter} The solver needs \verb+Df+, the jacobian
of $x \mapsto f(t,x)$.  This function can be provided by the user
with the optional named argument \verb+jac+. When \verb+jac+ is not given,
the solver computes an approximation using finite differences. Note that, like
for function \verb+f+, the formal argument \verb+t+ should be present even if
the Jacobian does not explicitly depend on time. So the header of
the nsp function defining \verb+jac+, the Jacobian of \verb+f+ should be as follows:
\begin{quote}
{\tt function J = Df(t,x) \\
      ....}\\
or:\\
{\tt function J = Df(t,x,obj) \\
     ....}
\end{quote}
when {\tt obj} is provided with {\tt args=obj}.

\itemdesc{odeoptions: fine solver tuning}
odeoptions will be described in a future version of this help page.

\end{mandescription} 

\begin{examples}
  
\paragraph{example 1} A very simple example. we want to solve the system:
$$
  \dot{x}(t) = - x, \; x(0) = 1\,.
$$ 
The solution is known to be ($x(t) = exp(-t)$);
\begin{program}\HCode{function y=f1(t,x);y=-x;endfunction\Hnewline
t = linspace(0,4,10);\Hnewline
x = ode(1,0,t,f1)\Hnewline
exp(-t)}
\end{program}
  
  
\paragraph{example 2} The Brusselator. We want to solve:
$$
\left\{
\begin{array}{l}
\frac{du_1}{dt} = 2 - (6 + \epsilon) u_1 + u_1^2 u_2 \\
\frac{du_2}{dt} = (5 + \epsilon) u_1 - u_1^2 u_2
\end{array}
\right.
$$
for some initial condition $u(0) = u0$ and some parameter $\epsilon$.
\begin{program}\HCode{function [f] = Brusselator(t,u,eps)\Hnewline
    f = [ 2 - (6+eps)*u(1) + u(1)^2*u(2);...\Hnewline
         (5+eps)*u(1) - u(1)^2*u(2)]\Hnewline
endfunction\Hnewline
eps = 0.1 // parameter value\Hnewline
T = 200 ;  // final integration time\Hnewline
t = linspace(0,T,8000); // time instants to record to solution\Hnewline
u0 = [0;0];  // initial condition (starting point)\Hnewline
// solve the ode\Hnewline
u = ode(u0, 0, t, Brusselator, rtol = 1e-9, atol = 1e-10, args=eps);\Hnewline
// plot solution in the phase space\Hnewline
plot2d(u(1,:)',u(2,:)', style=2, rect=[-0.5,-0.5,6,6])\Hnewline
plot2d(u0(1),u0(2),style=-5, strf="000",leg='starting point')}
\end{program}
  
  
\paragraph{example 3} pure, damped or amplified oscillators. The second order differential
equation:
$$
  \ddot{x}(t) + 2 \alpha \dot{x}(t) + k x(t) = 0, \; x(0)=x_0, \dot{x}(0) = v_0 
$$ 
corresponds for $k > 0$ and $\alpha^2 < k$ (damping or amplification factor not too high) to 
a pure oscillator when $\alpha=0$, a damped oscillator when $\alpha>0$ and to an amplified 
oscillator for $\alpha<0$. Its is easily solved analytically:
$$
  x(t) = e^{-\alpha t}( A \cos(\omega t) + B \sin(\omega t) ) \; \mbox{with: }
\left\{ \begin{array}{l}
\omega = \sqrt{k - \alpha^2} \\
A = x_0, \; B = (v_0 + \alpha x_0)/\omega
\end{array} \right.
$$
To use {\tt ode}, one should put this equation in a system of two first order differential 
equations:
$$
u(t) =  \left[ \begin{array}{c} u_1(t) \\  u_2(t)\end{array} \right]  \equiv  \left[ \begin{array}{c} x(t) \\
    \dot{x}(t)\end{array} \right], \mbox{ and }
\dot{u}(t) =  \left[ \begin{array}{c} \dot{u}_1(t) \\ \dot{u}_2(t) \end{array} \right] =
    \left( \begin{array}{c} u_2(t) \\  -k u_1(t) - 2 \alpha u_2(t) \end{array} \right) = f(u)
$$
So the code (we choose to pass the 2 parameters with an  \manlink{hash table}{hash}):
\begin{program}\HCode{function [f] = oscillator(t,u,p)\Hnewline
   f = [ u(2); -p.k*u(1) -2*p.alpha*u(2)];\Hnewline
endfunction\Hnewline
T = 16 ;  // final integration time\Hnewline
t = linspace(0,T,1000); // time instants to record to solution\Hnewline
u0 = [1;0];  // initial condition (x(0)=1, dx/dt(0)=0)\Hnewline
// solve the ode\Hnewline
up = ode(u0, 0, t, oscillator, args=hash(2,k=1,alpha=0));\Hnewline
ud = ode(u0, 0, t, oscillator, args=hash(2,k=1,alpha=0.02));\Hnewline
ua = ode(u0, 0, t, oscillator, args=hash(2,k=1,alpha=-0.02));\Hnewline
// plot the 3 solutions\Hnewline
xbasc()\Hnewline
subplot(1,2,1)\Hnewline
plot2d([up(1,:)',ud(1,:)',ua(1,:)'],[up(2,:)',ud(2,:)',ua(2,:)'], style=[2,3,5], leg="pure@damped@amplified")\Hnewline
xtitle("trajectories in phase space","x(t)","dx/dt(t)")\Hnewline
subplot(2,2,2)\Hnewline
plot2d(t',[up(1,:)',ud(1,:)',ua(1,:)'],style=[2,3,5], leg="pure@damped@amplified")\Hnewline
xtitle("position fct of time","t","x(t)")\Hnewline
subplot(2,2,4)\Hnewline
plot2d(t',[up(2,:)',ud(2,:)',ua(2,:)'],style=[2,3,5], leg="pure@damped@amplified")\Hnewline
xtitle("velocity fct of time","t","dx/dt(t)")}
\end{program}
  

 
\end{examples}

\begin{manseealso}
  \manlink{intg}{intg}, \manlink{int2d}{int2d}  
\end{manseealso}

% -- Authors
\begin{authors}
 Linda r. Petzold, Alan C. Hindmarsh. Nsp interface: Jean-Philippe Chancelier
\end{authors}
