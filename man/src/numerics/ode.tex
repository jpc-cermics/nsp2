% -*- mode: latex -*-

\mansection{ode}
\begin{mandesc}
  \short{ode}{ordinary differential equations solver}
\end{mandesc}

% -- Calling sequence section
\begin{calling_sequence}
\begin{verbatim}
x = ode(x0,t0,t,f)
x = ode(x0,t0,t,f, atol=ea, rtol=er, jac=Df, args=obj, type=str, odeoptions=htable)
\end{verbatim}
\end{calling_sequence}
% -- Parameters
\begin{parameters}
  \begin{varlist}
    \vname{x0}:real column vector, the initial condition
    \vname{t0}:real scalar, the initial time
    \vname{t}: real vector with increasing time instants at which the solution must be recorded
    \vname{f}: nsp function defining the second member of the differential equation
    \vname{atol=ea, rtol=er}: optional named argument, relative to the requested maximum error on a time step 
                     (default is atol=1e-9, rtol=0). atol could be a vector of same size than x0.
    \vname{jac=Df}: optional named argument. Df should be a nsp function (the Jacobian of f)
    \vname{args=obj}: optional named argument (could be any nsp object), useful to pass additional parameters needed by the function f.
    \vname{type=str}: optional named argument (scalar string) could be "default" (which is the default) or "discrete"
    \vname{odeoptions}: an hash table of parameters for fine tuning of the solver.
  \end{varlist}
\end{parameters}

\begin{mandescription}

When type is not "discrete", this function computes an approximate solution of the ordinary differential equation:
$$
\begin{array}{l}
   \dot{x}(t) = f(t, x(t)), \; f: R \times R^d \rightarrow  R^d \\
   x(t_0) = x_0  \in  R^d
\end{array}
$$
using the Livermore solvers odepack. Currently only lsoda is interfaced and this solver begin with the Adams
method (for nonstiff systems) but switches  automatically to bdf method if the differential equation is detected
as stiff. 

\itemdesc{form of the function {\tt f}}

The function $f$ takes as first argument a scalar $t$, then a vector $x$ of length $d$ as 2d argument and 
must output a vector of length $d$. Note that even if $f$ doesn't depend explicitly of the time $t$ (case of an autonomous differential equation)
it should nevertheless have this parameter as first argument. In brief \verb+f+ should have the
form:
\begin{quote}
{\tt function y = f(t,x) \\
      ....}
  \end{quote}

\itemdesc{optional argument {\tt args}}

Additional parameters for the function $f$ (and also for the function which computes the Jacobian 
if it is provided by the user) could be passed using \verb+args=obj+ where obj could be any nsp 
object (see examples). In this case \verb+f+ has the form:
\begin{quote}
{\tt function y = f(t,x,obj) \\
      ....}
\end{quote}

\itemdesc{the vector of time instants  {\tt t}}

The (approximate) solution is got at the time instants defined by the argument \verb+t+.
If \verb+t+ as $n$ components says  \verb+t = [t1, t2, ..., tn]+ then the output is a
$d \times n$ array and the k th column is an approximation of $x(tk)$. This output
time instants don't correspond to time step taken by the solver (see details here
after).


\itemdesc{optional atol and rtol parameters: solver accuracy control}

At each time step taken by the solver says from $\tau_{k-1}$ to  $\tau_k = \tau_{k-1} + (\Delta t)_k$
the estimated local error in the i th component $x_i(\tau_k)$ (that is the error in 
$x_i(\tau_k)$ assuming that $x(\tau_{k-1})$ is exact) is controlled so as to be less 
than $ewt_i$ where:
$$
ewt_i =
\left\{
\begin{array}{l}
 rtol | x_i | + atol  \mbox{ if } atol \mbox { is a scalar} \\
 rtol | x_i | + atol_i  \mbox{ if } atol \mbox { is a vector}
\end{array}
\right.
$$
 Btw note that the output time instants don't correspond to the time steps of 
the vector \verb+t+ and that the solver choose the  time steps $(\Delta t)_k$
(and also the order of the current formula) such that to be both efficient and
respect the required local tolerance. Note also that the global error could
be more larger than the local error. The solution at the wanted output time 
instants is got from an interpolary formula (wich is in fact natural to the
multistep method used by lsoda).

\itemdesc{optional jac parameter}

The solver needs $Df$ the jacobian of $x \mapsto f(t,x)$ so you could provide it with the optional named argument 
jac. When jac is not given the solver uses finite differences. Note that, like for \verb+f+, the formal argument
\verb+t+ should be present even if the Jacobian don't depends explicitly of the time. So the header of the nsp 
function defining the Jacobian of $f$ should be of the form:
\begin{quote}
{\tt function J = Df(t,x) \\
      ....}\\
or:\\
{\tt function J = Df(t,x,obj) \\
     ....}
\end{quote}
when {\tt obj} is provided with {\tt args=obj}.

\itemdesc{odeoptions: fine solver tuning}

odeoptions will be described in a future version of this help page.

\end{mandescription} 

\begin{examples}
  
\paragraph{example 1} the most simple example: we want to integrate:
$$
  \dot{x}(t) = - x, \; x(0) = 1, 
$$ 
the solution is known ($x(t) = exp(-t)$);
\begin{program}\HCode{function y=f1(t,x);y=-x;endfunction\Hnewline
t = linspace(0,4,10);\Hnewline
x = ode(1,0,t,f1)\Hnewline
exp(-t)}
\end{program}
  
  
\paragraph{example 2} The Brusselator. We want to solve:
$$
\left\{
\begin{array}{l}
\frac{du_1}{dt} = 2 - (6 + \epsilon) u_1 + u_1^2 u_2 \\
\frac{du_2}{dt} = (5 + \epsilon) u_1 - u_1^2 u_2
\end{array}
\right.
$$
for some initial condition $u(0) = u0$ and some parameter $\epsilon$.
\begin{program}\HCode{function [f] = Brusselator(t,u,eps)\Hnewline
   f = [ 2 - (6+eps)*u(1) + u(1)^2*u(2);...\Hnewline
         (5+eps)*u(1) - u(1)^2*u(2)]\Hnewline
endfunction\Hnewline
eps = 0.1 // parameter value\Hnewline
T = 200 ;  // final integration time\Hnewline
t = linspace(0,T,8000); // time instants to record to solution\Hnewline
u0 = [0;0];  // initial condition (starting point)\Hnewline
// solve the ode\Hnewline
u = ode(u0, 0, t, Brusselator, rtol = 1e-9, atol = 1e-10, args=eps);\Hnewline
// plot solution in the phase space\Hnewline
plot2d(u(1,:)',u(2,:)', style=2, rect=[-0.5,-0.5,6,6])\Hnewline
plot2d(u0(1),u0(2),style=-5, strf="000",leg='starting point')}
\end{program}
  

 
\end{examples}

\begin{manseealso}
  \manlink{intg}{intg}, \manlink{int2d}{int2d}  
\end{manseealso}

% -- Authors
\begin{authors}
  uses the routine lsoda of the odepack package. Nsp interface: Jean-Philippe Chancelier
\end{authors}
