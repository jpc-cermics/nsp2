% -*- mode: latex -*-

\mansection{hash tables}
\begin{mandesc}
  \short{hash}{hash tables}
\end{mandesc}

% -- Calling sequence section
\begin{calling_sequence}
\begin{verbatim}
L = hash_create(size,var1,...,varn,name1=val1,...)
L = hash(size,var1,...,varn,name1=val1,...)
\end{verbatim}
\end{calling_sequence}
% -- Parameters
\begin{parameters}
  \begin{varlist}
    \vname{size}: an integer, giving initial expected size of the hash table.
    \vname{var1,...,varn}:  any nsp objects having a name. 
    \vname{val1}: any nsp expression which evaluates to a nsp object.
  \end{varlist}
\end{parameters}

\begin{mandescription}
The \emph{hash} data type is useful to maintain a collection of objects 
which can be accessed using their names as access key. A hash table
could be created with the \verb+hash_create+ function (you can use
either the shortly name +hash+).  
Internally nsp hash tables are implemented as hash tables with open adressing. 
They are dynamically resized according to the number of stored
objects.

\end{mandescription}

\paragraph{Operations on hashs}
\itemdesc{attributes}
  \begin{varlist}
    \vname{.__keys} return a string matrix containing all the keys present in the hash 
    table.
  \end{varlist}

\itemdesc{methods}
  \begin{varlist}
  \vname{.delete[S1,...,Sn]}: delete the entries whose keys are present in the string matrices 
  \verb+S1,...,Sn+.
  \vname{.enter[var1,...,varn,name1=val1,...]}: enter new objects in the hash table with keys 
  given by their names or by explicit naming (\verb+name=val+). Note that if some keys 
  already preexist in the hash table, their value are replaced by new ones. 
  \vname{.find[S1,...,Sn]}: returns on the calling stack for each key given by the values of 
  the string matrices \verb+S1,...,Sn+ the corresponding stored objet if present or an 
  error if one key is not present in the hash table. Thus, this method returns a variable 
  number of values. 
  \vname{.iskey[S1,...,Sn]}: returns on the calling stack for each given entry key a boolean 
  which states if the given key is present or not in the hash table.
  \vname{.merge[H]}: insert the entries of hash table \verb+H+ in the hash table object.
  \end{varlist}

\itemdesc{extraction, insertion, deletion}
\begin{itemize}
\item If ^verb+key+ is a string \verb+H(key)+ returns the element of \verb+H+ given by \verb+key+. 
  This is therefore equivalent to \verb+H.find[key]+. It is also possible to use 
  the syntax \verb+H.name+ (Note that in that case name given the key name not an expression 
  which evaluates to a string) 
\item \verb+H(:)+ puts all the elements of \verb+H+ on the calling stack but as named 
  optional arguments. Thus is can be usefull to pass a set of named options to a function. 
  (\verb+H=hash_create(color=3,size=5)+ and \verb+f(70,H(:))+ is equivalent to 
  \verb+f(70,color=3,size=5)+).
\item \verb+H(key)=e+ or \verb+H.key=e+ insert the rhs value in the hash table with key name 
  given by \verb+key+.
\end{itemize}

\itemdesc{Some functions}
\begin{itemize}
   \item \verb+length(H)+ return the number of objets stored in \verb+H+
   \item \verb+size(H)+ return \verb+[m,n]+ where \verb+m+ stands for the number 
     of objets stored in \verb+H+ and \verb+n+ is the size of internal size of 
     the hash table. 
\end{itemize}

\begin{examples}
  \begin{program}\HCode{A = rand(4,4);\Hnewline
    H = hash_create(5,A,B=34,C="foo")  \Hnewline
    // or shortly H = hash(5,A,B=34,C="foo")\Hnewline
    H.delete['A',['B','C']];\Hnewline
    H.enter[A,Z='foo',C=3.56];\Hnewline
    [a,b,c]=H.find['A',['B','C']]\Hnewline
    [a,b,c]=H.iskey['A',['B','C']]\Hnewline
    H.merge[hash_create(P=89,Q=67)];\Hnewline
    H.A = 56 \Hnewline
    str = 'A'\Hnewline
    H(str) = 45;\Hnewline
    function y=f(a=1,b=2,c=3);y=[a,b,c];endfunction \Hnewline
    H = hash_create(a=67,b=45);\Hnewline
    f(H(:));}
  \end{program}
 \end{examples}

% -- Authors
\begin{authors}
  Jean-Philippe Chancelier
\end{authors}
