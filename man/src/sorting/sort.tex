% -*- mode: latex -*-

\mansection{sort}
\begin{mandesc}
  \short{sort}{general sort function}
\end{mandesc}

% -- Calling sequence section
\begin{calling_sequence}
\begin{verbatim}
[y [,p]]  = sort(x)
[y [,p]]  = sort(x, type_of_sort)
[y [,p]]  = sort(x, type_of_sort, order)
\end{verbatim}
\end{calling_sequence}
% -- Parameters
\begin{parameters}
  \begin{varlist}
    \vname{x}:  matrix or vector of real numbers or strings.
    \vname{type_of_sort}: a string among
    \verb+"g","gb","gm","gs","c","r","ldc","ldr","lc","lr"+ (default
    is \verb+"g"+)
    \vname{order}: must be \verb+"i"+ for an increasing sort or \verb+"d"+ for a
                    decreasing sort (current default)
    \vname{y}: sorted output
    \vname{p}: vector (or matrix) of indices such that \verb+y=x(p)+
    or  \verb+y=x(:,p)+ or  \verb+y=x(p,:)+ or other meanings
    depending of the sort type.
  \end{varlist}
\end{parameters}

\begin{mandescription}
This function is an interface for various kind of sorts depending of
the input argument \verb+type_of_sort+:

\itemdesc{{\tt type\_of\_sort = "g","gb","gm","gs"}}
In this case the function sorts the vector $x$ (if $x$ is a matrix
it is considered as a big vector using the major column order) in 
decreasing order by default or when \verb+order="d"+ and in increasing
order when \verb+order="i"+. 

\begin{tabular}{|r|l|}
\hline
\verb+"g"+  &  quick sort a la Bentley, McIlroy's "Engineering a Sort Function" \\
            &  (tends to be the fastest when $x$ have many non unique elements) \\ 
\hline
\verb+"gb"+  &  quick sort a la Sedgewick \\
            &  (tends to be the fastest when $x$ have few non unique elements) \\ 
\hline
\verb+"gm"+  &  merge sort \\
             &  generally slower than the 2 first by always in  O(nlog(n)) \\
\hline
\verb+"gs"+  &  stable quick sort \\
             &  (adapted quick sort a la Sedgewick)  \\ 
\hline
\end{tabular}

Currently only \verb+"g"+ and  \verb+"gs"+ are available for string vectors.

\itemdesc{{\tt type\_of\_sort = "c"}}
In this case each row of $x$ is sorted independently of the others.
$p$ is a matrix of indices and \verb+y(i,:)+ should be equal to
\verb+x(i,p(i,:))+. 

\itemdesc{{\tt type\_of\_sort = "r"}}
In this case each column of $x$ is sorted independently of the others.
$p$ is a matrix of indices and \verb+y(:,j)+ should be equal to
\verb+x(p(:,j),j)+. 

\itemdesc{{\tt type\_of\_sort = "lc"}}
In this case the columns are sorted using lexical order (increasing 
order if \verb+order="i"+). $p$ is a vector of indices such that \verb+y+ should be equal to
\verb+x(:,p)+. {\bf Important note :} for matrix of floating point numbers a cast double 
to int is done first, so use {\tt type\_of\_sort = "ldc"} to avoid this problem.

\itemdesc{{\tt type\_of\_sort = "ldc"}}
Lexical columns sorting for matrix of floating point numbers (see option "lc")  

\itemdesc{{\tt type\_of\_sort = "lr"}}
In this case the rows are sorted using lexical order (increasing 
order if \verb+order="i"+). $p$ is a vector of indices such that \verb+y+ should be equal to
\verb+x(p,:)+.  {\bf Important note :} for matrix of floating point numbers a cast double 
to int is done first, so use {\tt type\_of\_sort = "ldr"} to avoid this problem.

\itemdesc{{\tt type\_of\_sort = "ldr"}}
Lexical rows sorting for matrix of floating point numbers (see option "lr").


\paragraph{Remarks}
\begin{itemize}
\item For matrix of floating point numbers, Nan values are considered larger
than Inf. So all nans are positionned at the end in case of an
increasing sort and at the beginning for a decreasing sort. 
\item stable sorts are not provided for other kind of sort than \verb+"g"+ ; if
you need such a feature:
  \begin{itemize}
  \item for lexical sorting of columns ("lc" or "ldc"), you can add a last
        row \verb+1:n+ to your matrix:
        \begin{verbatim}
        [B,ind] = sort([A;1:size(A,2)],"ldc", "i"); B($,:)=[];
        \end{verbatim}
  \item for lexical sorting of rows ("lr" or "ldr"), you can add a last
        column \verb+1:m+ to your matrix:
        \begin{verbatim}
        [B,ind] = sort([A,1:size(A,1)],"ldr", "i"); B(:,$)=[];
        \end{verbatim}
  \item for sorting each column independantly ("c"), do a loop with
        a stable sort ("gm" or "gs") on each column:
        \begin{verbatim}
        B = zeros(size(A)); ind = zeros(size(A));
        for j=1:size(A,2), [B(:,j),ind(:,j)] = sort(A(:,j),"gm", "i"); end
        \end{verbatim}
  \item for sorting each row independantly ("c"), do a loop with
        a stable sort ("gm" or "gs") on each row:
        \begin{verbatim}
        B = zeros(size(A)); ind = zeros(size(A));
        for i=1:size(A,1), [B(i,:),ind(i,:)] = sort(A(i,:),"gm", "i"); end
        \end{verbatim}
  \end{itemize}
\end{itemize}


\end{mandescription}

\begin{examples}

\paragraph{example 1} sort of a vector of numbers:
\begin{program}\HCode{x = [0.5, -1, 2, 2, -1, 0.5, 2, -1, 2];\Hnewline
\Hnewline
// increasing sort\Hnewline
y = sort(x,"g","i")\Hnewline
[y,p] = sort(x,"g","i")\Hnewline
y.equal[x(p)]  // must be true \Hnewline 
\Hnewline
// decreasing sort\Hnewline
y = sort(x,"g","d")\Hnewline
[y,p] = sort(x,"g","d")\Hnewline
y.equal[x(p)]  // must be true \Hnewline 
\Hnewline
// behavior with special values \Hnewline 
x(2)=}\verb+%+\HCode{nan;x(3)=}\verb+%+\HCode{inf; x(7)=}\verb+%+\HCode{nan; x(8)=-}\verb+%+\HCode{inf\Hnewline   
y = sort(x,"g","i")\Hnewline
y = sort(x,"g","d")}
\end{program}

\paragraph{example 2} sort a vector of strings:
\begin{program}\HCode{x = ["toto", "foo", "bar", "toto", "foobar", "bar", "toto", "foo", "bar"]\Hnewline
y = sort(x,"g","i")\Hnewline
y = sort(x,"g","d")\Hnewline
[y,p] = sort(x,"g","i")\Hnewline
y.equal[x(p)]  // must be true}
\end{program}

\paragraph{example 3} lexical sorts
\begin{program}\HCode{A = [0.5, -1, 2; 0.3, 4, 0.7; 0.3, -1, 2]\Hnewline
// increasing row lexical sort\Hnewline
B = sort(A,"ldr","i")\Hnewline
[B,p] = sort(A,"ldr","i")\Hnewline
B.equal[A(p,:)]  // must be true \Hnewline 
// increasing column lexical sort\Hnewline
B = sort(A,"ldc","i")\Hnewline
[B,p] = sort(A,"ldc","i")\Hnewline
B.equal[A(:,p)]  // must be true}
\end{program}

\paragraph{example 4} speed issues
\begin{program}\HCode{// a case where all or near all vector components are different\Hnewline
x = rand(1e6,1);\Hnewline
// g sort (should be slower than gb here)\Hnewline
t=cputime(); y = sort(x,"g","i"); cputime()-t\Hnewline
// gb sort (should be faster here)\Hnewline
t=cputime(); y = sort(x,"gb","i"); cputime()-t\Hnewline
// merge sort (generally slower than g and gb)\Hnewline
t=cputime(); y = sort(x,"gm","i"); cputime()-t\Hnewline
\Hnewline
// a case with many equal components\Hnewline
x = grand(1e6,1,"uin",1,100);\Hnewline
// g sort (should be faster here)\Hnewline
t=cputime(); y = sort(x,"g","i"); cputime()-t\Hnewline
// gb sort (should be slower than g)\Hnewline
t=cputime(); y = sort(x,"gb","i"); cputime()-t\Hnewline
// merge sort\Hnewline
t=cputime(); y = sort(x,"gm","i"); cputime()-t}
\end{program}

\end{examples}

\begin{manseealso}
  \manlink{unique}{unique}  
\end{manseealso}

% -- Authors
\begin{authors}
Bentley and McIlroy 's code adapted and modified by Jean-Philippe Chancelier,"gb"
and "gs" codes by Bruno Pincon.
\end{authors}
