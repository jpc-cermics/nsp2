/* Nsp
 * Copyright (C) 2007 Jean-Philippe Chancelier Enpc/Cermics
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 *
 * a version of x - ln(1 + x) approximated with Mapple 
 * 
 *
 *
 */

#include "cdf.h"

/** 
 * cdf_rlog1:
 * @x: a pointer to a double 
 * 
 * evaluation of the function x - ln(1 + x) 
 * Returns: a double 
 **/

/* 
 * Using Maple code for approximation in [-0.1,0.1] of  (f(x)-f(-x))/(2*x^3/3)
 * giving an approximation of x - log(1+x) in [-0.18,0.18].
 * 
 
  with(numapprox);
  with(orthopoly);
  f:= proc(x) x- log(1+x);end proc;
  g:=proc(x) (f(x)-f(-x))/(2*x^3/3);end proc;
  Digits:=50;
  ggp:=chebpade(g(x),x=-0.1..0.1,[8,8]);
  Digits:=17;
  gg:= convert(ggp,float);
  gg:= convert(gg,horner);
  g_cheb:= unapply(gg,x);
  f_approx:= proc(x) local u; u:= x/(2+x); 2*u^2*(1/(1-u) + u*g_cheb(u)/3); end proc;
  infnorm(f(x)-f_approx(x),x=-0.18..0.18);
  codegen[C](f_approx,optimized);
  codegen[C](g_cheb,optimized);
  codegen[C](confracform(u*subs(x=u,gg)));
  
  f_err:=proc(x) local u1,u2; u1:=evalf(f(x),70); u2:=evalf(f_approx(x),16);
    evalf((u1-u2)/u1,70);
  end proc;
  
  m_err:=proc(am,ap,b,nn) local mvm,mvp,mvd,s,serr;
    mvm:=am*nn;mvp:=ap*nn;mvd:= b*nn;
    s:=[seq(i/mvd,i=mvm..-1),seq(i/mvd,i=1..mvp)];
    serr:= map(f_err,s);
    convert(max(op(serr)),float);
  end proc;

  am:=-18;ap:=18;ad:=100;
  m_err(am,ap,ad,100);

  # in [-0.18,0.18]

  f_approx1:= proc(x,res) local u,u2,res1;  u := x/(2.0+x);u2:=u*u;
    res1 :=u*((-0.1006397968649471E1
	    +(0.6784309300435146
	      -0.187491012609664E-1*u2)*u2)
	   /(0.1006397968649471E1
	     +(-0.128226971123169E1
	       +0.3567975116629138*u2)*u2));
    res + 2*u2*( 1/(1-u) + res1/3);
  end proc;

  # in [-0.4,-0.18] 
  # better than 
  # y:= f_approx1((x + .3)/0.7,-.42857142857142857*x -.07189648463269617);

  f_approx2:=  proc(x) (0.285211335E-10+(0.107106064E-8+(0.1152628215700186E1+(
  0.224530290626052E1+(0.1355646781758151E1+0.245173096410477*x)*x)*x)*x)*x)/(
  0.2305256395750588E1+(0.6027443064646071E1+(0.557695860354239E1+(
  0.2116690842297106E1+(0.265182661285532-0.1316156876141345E-2*x)*x)*x)*x)*x); end proc;

  # full approximation in [-0.39,0.57]
  
  f_approx := proc(x) local y;
    if ( x >= - 0.39 and x <= - 0.18) then y:=f_approx2(x);
    elif ( x > -0.18 and x < 0.18 ) then  y:= f_approx1(x,0.0);
    elif ( x >= 0.18 and x <= 0.57 ) then  y:= f_approx1(0.75*x -0.25, 0.25*x -.03768207245178093);
    else y:= x -log(1+x);
    end if ;
    y ;
  end proc;

  m_err(-40,58,100,10);

*/


double cdf_rlog1(double x)
{
  /* basic test: x=linspace(-0.38,0.56,10000);max(abs(cdf_rlog1(x)-(x-log(1+x))))
   * 
   */
  double res = 0.0,u,res1,u2;
  if (x < -.18)
    {
      if ( x < -0.39 ) return x- log (1+x) ;
      /* x is in  [-0.39,-0.18] => transform to get in [-0.18,0.18]
       * x - log(1+x) = (10*x+3)/7 - log(1+ (10x+3)/7) -3*x/7 +(-3/7) + log(10/7);
       */
      res =-.42857142857142857*x+-.07189648463269617;
      x = (x + .3)/0.7;
    }
  else 
    {
      if ( x > 0.57) return x- log (1+x);
      if ( x > 0.18) 
	{
	  /* in [0.18,0.57] => transform to get in [-0.18,0.18]
	   * x- log(1+x)= (3*x-1)/4 - log(1 + (3x-1)/4) + (x+1)/4 + log(3/4);
	   */
	  res = 0.25*x -.03768207245178093;
	  x *= 0.75; x -= 0.25;
	}
    }
  /* now x is in the range [-0.18,0.18] */
  u = x/(2.0+x);
  u2 = u*u;
  /* using horner form generated by Maple */
  res1 =u*((-0.1006397968649471E1
	    +(0.6784309300435146
	      -0.187491012609664E-1*u2)*u2)
	   /(0.1006397968649471E1
	     +(-0.128226971123169E1
	       +0.3567975116629138*u2)*u2));
  return res + 2*u2*( 1/(1-u) + res1/3);
}


/* Some maxima code that can be used for testing and ploting 

   f(x):= x- log(1+x);
   g(x):= (f(x)-f(-x))/(2*x^3/3);
   h(x):= if x=0 then false else true;

   fpprec:100;
   float2bf: true;

   * rational approximation computed with Maple 

   f_approx1(x,res):= (u : x/(2.0+x),u2:u*u,
    res1 :u*((-0.1006397968649471E1
	    +(0.6784309300435146
	      -0.187491012609664E-1*u2)*u2)
	   /(0.1006397968649471E1
	     +(-0.128226971123169E1
	       +0.3567975116629138*u2)*u2)),
    res + 2*u2*( 1/(1-u) + res1/3));

   f_approx2(x):= (0.285211335E-10+(0.107106064E-8+(0.1152628215700186E1+(
  0.224530290626052E1+(0.1355646781758151E1+0.245173096410477*x)*x)*x)*x)*x)/(
  0.2305256395750588E1+(0.6027443064646071E1+(0.557695860354239E1+(
  0.2116690842297106E1+(0.265182661285532-0.1316156876141345E-2*x)*x)*x)*x)*x);

   rlog1(x):=  if ( x >= - 0.39 and x <= - 0.18) then f_approx2(x)
   else ( if ( x > -0.18 and x < 0.18 ) then  f_approx1(x,0.0)
   else (if ( x >= 0.18 and x <= 0.57 ) then  f_approx1(0.75*x -0.25, 0.25*x -.03768207245178093)
   else x-log(1+x)));

  points(xmin,xmax,xdiv,nn,xe):= ( L: makelist(x/(xdiv*nn),x,xmin*nn,xmax*nn), 
                                   L: sublist(L,lambda([x],if x=xe then false else true)))$

  testprec(L,f,fa):= (fpprec:100,bfT: bfloat(map(f,L)), ft: ev(map(fa,L),numer),
                       Lrerr:map(lambda([x,y],(x-y)/x),bfT,ft),
		       plot2d([discrete,ev(L,numer),ev(Lrerr,numer)]),
		       ev(lmax(Lrerr),numer))$

  L: points(-40,50,100,10,0)$
  print("without rational approximation")$
  testprec(L,f,f); 
  print("with rational approximation")$
  testprec(L,f,rlog1);

*/


/**
 * cdf_rlog1_old:
 * @x: a pointer to a double 
 * 
 * evaluation of the function x - ln(1 + x) 
 * 
 * Returns: a double 
 **/

/* unused ACM code just here for test comparisons. 
 *
 */

double cdf_rlog1_old (double x)
{
  /*test:  A=[-0.2:0.01:1]; norm(A-log(1+A) -cdf_rlog1(A))  */
  const double a = .0566749439387324;
  const double b = .0456512608815524;
  const double p0 = .333333333333333;
  const double p1 = -.224696413112536;
  const double p2 = .00620886815375787;
  const double q1 = -1.27408923933623;
  const double q2 = .354508718369557;
  double h, r, t, w, w1;

  if (x < -.39 || x > .57)
    {
      return  x - log (x + .5 + .5);
    }
  if (x < -.18)
    {
      h = x + .3;
      h /= .7;
      w1 = a - h * .3;
    }
  else if (x > .18)
    {
      h = x * .75 - .25;
      w1 = b + h / 3.;      
    }
  else 
    {
      /* argument reduction */
      h = x;
      w1 = 0.;
    }
  /* series expansion */
  r = h / (h + 2.);
  t = r * r;
  w = ((p2 * t + p1) * t + p0) / ((q2 * t + q1) * t + 1.);
  return  t * 2. * (1. / (1. - r) - r * w) + w1;
}
