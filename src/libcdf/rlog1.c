#include "cdf.h"

/**
 * cdf_rlog1:
 * @x: a pointer to a double 
 * 
 * evaluation of the function x - ln(1 + x) 
 * 
 * Returns: a double 
 **/

double cdf_rlog1_old (double x)
{
  /*test:  A=[-0.2:0.01:1]; norm(A-log(1+A) -cdf_rlog1(A))  */
  const double a = .0566749439387324;
  const double b = .0456512608815524;
  const double p0 = .333333333333333;
  const double p1 = -.224696413112536;
  const double p2 = .00620886815375787;
  const double q1 = -1.27408923933623;
  const double q2 = .354508718369557;
  double h, r, t, w, w1;

  if (x < -.39 || x > .57)
    {
      return  x - log (x + .5 + .5);
    }
  if (x < -.18)
    {
      h = x + .3;
      h /= .7;
      w1 = a - h * .3;
    }
  else if (x > .18)
    {
      h = x * .75 - .25;
      w1 = b + h / 3.;      
    }
  else 
    {
      /* argument reduction */
      h = x;
      w1 = 0.;
    }
  /* series expansion */
  r = h / (h + 2.);
  t = r * r;
  w = ((p2 * t + p1) * t + p0) / ((q2 * t + q1) * t + 1.);
  return  t * 2. * (1. / (1. - r) - r * w) + w1;
}

/* GPL Version, Jean-Philippe Chancelier 2007 */

/** 
 * cdf_rlog1:
 * @x: a pointer to a double 
 * 
 * evaluation of the function x - ln(1 + x) 
 * Returns: a double 
 **/


/* 
 * Using Maple code for approximation in [-0.1,0.1] of  (f(x)-f(-x))/(2*x^3/3)
 * giving an approximation of x - log(1+x) in [-0.18,0.18].
 * 
 
  with(numapprox);
  with(orthopoly);
  f:= proc(x) x- log(1+x);end proc;
  g:=proc(x) (f(x)-f(-x))/(2*x^3/3);end proc;
  Digits:=50;
  ggp:=chebpade(g(x),x=-0.1..0.1,[8,8]);
  Digits:=17;
  gg:= convert(ggp,float);
  gg:= convert(gg,horner);
  g_cheb:= unapply(gg,x);
  f_approx:= proc(x) local u; u:= x/(2+x); 2*u^2*(1/(1-u) + u*g_cheb(u)/3); end proc;
  infnorm(f(x)-f_approx(x),x=-0.18..0.18);
  codegen[C](f_approx,optimized);
  codegen[C](g_cheb,optimized);
  codegen[C](confracform(u*subs(x=u,gg)));

  f:= proc(x) f1(x-1);end proc;
  f_approx:= proc(x) f_approx1(x-1);end proc;
  
  f_err:=proc(x) local u1,u2; u1:=evalf(f(x),70); u2:=evalf(f_approx(x),17);
    evalf((u1-u2)/u1,70);
  end proc;
  
  m_err:=proc(a,b,c,nn)
    s:=[seq(i/(c*nn),i=(a*nn)..(b*nn))];
    serr:= map(f_err,s);
    convert(max(op(serr)),float);
  end proc;
  
  m_err(100-18,100+18,100,1);
  
*/


double cdf_rlog1(double x)
{
  /* basic test: x=linspace(-0.38,0.56,10000);max(abs(cdf_rlog1(x)-(x-log(1+x))))
   * 
   */
  double res = 0.0,u,res1,u2;
  if (x < -.18)
    {
      if ( x < -0.39 ) return x- log (1+x) ;
      /* x is in  [-0.39,-0.18] => transform to get in [-0.18,0.18]
       * x - log(1+x) = (10*x+3)/7 - log(1+ (10x+3)/7) -3*x/7 +(-3/7) + log(10/7);
       */
      res =-.42857142857142857*x+-.07189648463269617;
      x = (x + .3)/0.7;
    }
  else 
    {
      if ( x > 0.57) return x- log (1+x);
      if ( x > 0.18) 
	{
	  /* in [0.18,0.57] => transform to get in [-0.18,0.18]
	   * x- log(1+x)= (3*x-1)/4 - log(1 + (3x-1)/4) + (x+1)/4 + log(3/4);
	   */
	  res = 0.25*x -.03768207245178093;
	  x *= 0.75; x -= 0.25;
	}
    }
  /* now x is in the range [-0.18,0.18] */
  u = x/(2.0+x);
  u2 = u*u;
  /* using horner form generated by Maple */
  res1 =u*((-0.1006397968649471E1
	    +(0.6784309300435146
	      -0.187491012609664E-1*u2)*u2)
	   /(0.1006397968649471E1
	     +(-0.128226971123169E1
	       +0.3567975116629138*u2)*u2));
  return res + 2*u2*( 1/(1-u) + res1/3);
}


/* Some maxima code that can be used for testing  */

/* Some maxima code that can be used for testing 
 * and ploting 

   f(x):= x- log(1+x);
   g(x):= (f(x)-f(-x))/(2*x^3/3);
   h(x):= if x=0 then false else true;
   relerr(x,y):= (x-y)/y;
   nn:10;
   mv:18*nn;
   L: makelist(x/(100*nn),x,-mv,mv)$
   L: sublist(L,h)$
   fpprec:100;
   float2bf: true;

   * relative precision with naive evaluation 

   bfT: bfloat(map(g,L))$
   ft: ev(map(g,L),numer)$
   Lrerr:map(relerr,bfT,ft)$
   plot2d([discrete,ev(L,numer),ev(Lrerr,numer)])$

   * rational approximation computed with Maple 

   f1(u,u2):= u*((-0.1006397968649471E1 +(0.6784309300435146 -0.187491012609664E-1*u2)*u2)
   /(0.1006397968649471E1 +(-0.128226971123169E1 +0.3567975116629138*u2)*u2));

   f_approx(x) := ( u : x/(2.0+x), u2 : u*u, 2*u2*( 1/(1-u) + f1(u,u2)/3));
   bfT: bfloat(map(f,L))$
   ratf: ev(map(f_approx,L),numer)$
   Lrerr:map(relerr,bfT,ratf)$
   plot2d([discrete,ev(L,numer),ev(Lrerr,numer)])$
   lmax(Lrerr);
   
*/



