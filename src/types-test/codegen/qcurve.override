/* -*- Mode: C -*- */
%%
include-public Qcurve

/* inserted at the end of public part of include file */

extern NspFigure *nsp_oscillo_obj(int win,int ncurves,int style[],int bufsize,int yfree,
				  double ymin,double ymax,NspList **Lc);
extern void  nsp_oscillo_add_point(NspList *L,double t,double *y, int n);


%%
include-private Qcurve

/* inserted in the private part of include file */
static void nsp_draw_qcurve(BCG *Xgc,NspGraphic *Obj, void *data);
static void nsp_translate_qcurve(NspGraphic *o,const double *tr);
static void nsp_rotate_qcurve(NspGraphic *o,double *R);
static void nsp_scale_qcurve(NspGraphic *o,double *alpha);
static int nsp_getbounds_qcurve(NspGraphic *o,double *bounds);
static void nsp_qcurve_addPts(NspQcurve *C,NspMatrix *Pts);
static void nsp_qcurve_addpt(NspQcurve *C,double *x,double *y,int n);
static void nsp_qcurve_clear(NspQcurve *C);
static int nsp_qcurve_get_len(NspQcurve *C);
static void nsp_qcurve_get_xy(NspQcurve *C,double *cx,double *cy);
static void oscillo_test();

%%
headers
#include <nsp/figuredata.h> 
#include <nsp/figure.h>
#include <nsp/qcurve.h>
#include <nsp/axes.h> 

%%
init 

Init portion 

%%
override-type Qcurve
  /* inserted verbatim in the type definition */
  ((NspTypeGraphic *) type->surtype)->draw = nsp_draw_qcurve;
  ((NspTypeGraphic *) type->surtype)->translate =nsp_translate_qcurve ;
  ((NspTypeGraphic *) type->surtype)->rotate =nsp_rotate_qcurve  ;
  ((NspTypeGraphic *) type->surtype)->scale =nsp_scale_qcurve  ;
  ((NspTypeGraphic *) type->surtype)->bounds =nsp_getbounds_qcurve  ;
  /* next method are defined in NspGraphic and need not be chnaged here for Qqcurve */
  /* ((NspTypeGraphic *) type->surtype)->link_figure = nsp_graphic_link_figure; */ 
  /* ((NspTypeGraphic *) type->surtype)->unlink_figure = nsp_graphic_unlink_figure; */ 

%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type

%%
override-attr Qcurve.mode 
/* override set alpha */
static int _wrap_qcurve_set_mode(void *self, char *attr, NspObject *O)
{
  int mode;
  if ( IntScalar(O,&mode) == FAIL) return FAIL;
  if ( ((NspQcurve *) self)->obj->mode !=  mode)
    {
      ((NspQcurve *) self)->obj->mode =  mode;
      nsp_graphic_invalidate((NspGraphic *) self);
    }
  return OK;
}

%%
override-attr Qcurve.Pts 

/* overriden to check dimensions when changing values.
 */

static NspObject *_wrap_qcurve_get_obj_Pts(void *self,char *attr, int *copy)
{
  NspMatrix *ret;
  *copy = TRUE; 
  ret = ((NspMatrix*) ((NspQcurve *) self)->obj->Pts);
  return (NspObject *) ret;
}

static int _wrap_qcurve_set_obj_Pts(void *self,NspObject *val)
{
  NspMatrix *M= (NspMatrix *) val ; 
  NspQcurve *poly = self ;
  if ( M->rc_type != 'r' || M->n != 2 )
    {
      Scierror("Error: qcurve field Pts should be real an mx2 sized\n");
      return FAIL;
    }
  /* before replacing the field we check that dimensions are correct */
  if ( poly->obj->Pts != NULL )
    nsp_matrix_destroy(poly->obj->Pts);
  poly->obj->Pts = (NspMatrix *) val ;
  return OK;
}

%%
override nsp_extractelts_qcurve kwargs

extern function int_nspgraphic_extract;

int _wrap_nsp_extractelts_qcurve(Stack stack, int rhs, int opt, int lhs) 
{
  return int_nspgraphic_extract(stack,rhs,opt,lhs);
}

%%
override nsp_setrowscols_qcurve kwargs

extern function int_graphic_set_attribute;

int _wrap_nsp_setrowscols_qcurve(Stack stack, int rhs, int opt, int lhs) 
{
  return int_graphic_set_attribute(stack,rhs,opt,lhs);
}


%%
last

/* inserted verbatim at the end */
/* 
    '("int" "color"); curve color 
    '("int" "mark") ; mark to be used 
    '("double" "width"); line width 
    '("int" "style"); line style 
    '("int" "mode"); mode: std, step, stem, arrow.
    '("NspMatrix*" "Pts")
*/

typedef enum { qcurve_std, qcurve_stairs, qcurve_stem , qcurve_arrow} nsp_qcurve_mode ; 

static void nsp_draw_qcurve(BCG *Xgc,NspGraphic *Obj, void *data)
{
  int cmark=-1;
  int xmark[2];
  NspQcurve *P = (NspQcurve *) Obj;
  int c_width = Xgc->graphic_engine->xget_thickness(Xgc);
  int c_color = Xgc->graphic_engine->xget_pattern(Xgc);

  if (((NspGraphic *) P)->obj->hidden == FALSE ) return;
  if ( ! nsp_graphic_intersect_rectangle(Obj, data))
    {
      return ;
    }

  if ( P->obj->Pts->m == 0) return;
  if ( P->obj->start == -1) return;

  Xgc->graphic_engine->xset_thickness(Xgc,P->obj->width);
  if ( P->obj->mark >= 0 ) 
    {
      /* use a mark */
      Xgc->graphic_engine->xget_mark(Xgc,xmark); 
      cmark=xmark[0];
      Xgc->graphic_engine->xset_mark(Xgc, P->obj->mark,xmark[1]);
    }
  if ( P->obj->color != -1 ) 
    Xgc->graphic_engine->xset_pattern(Xgc, P->obj->color);

  Sciprintf("Avec color %d et mark %d\n", P->obj->color, P->obj->mark);
  /*XXX: we should not be in Rec mode here */
  switch ( P->obj->mode ) 
    {
    case qcurve_std:
    default:
      {
	int n = nsp_qcurve_get_len(P);
	double *xm=NULL,*ym=NULL;
	if ( n == 0) break;
	xm = graphic_alloc(0,n,sizeof(double));
	ym = graphic_alloc(1,n,sizeof(double));
	if ( xm == 0 || ym == 0) 
	  {
	    Sciprintf("Error: cannot allocate points for drawing\n");
	    break;
	  }
	nsp_qcurve_get_xy(P,xm,ym);
	if ( P->obj->mark >= 0 )
	  Xgc->graphic_engine->scale->drawpolymark(Xgc,xm,ym,n);
	else
	  Xgc->graphic_engine->scale->drawpolyline(Xgc,xm,ym,n,0);
	break;
      }

    }
  Xgc->graphic_engine->xset_thickness(Xgc,c_width);
  Xgc->graphic_engine->xset_pattern(Xgc,c_color);
  if ( P->obj->mark >= 0 ) 
    {
      Xgc->graphic_engine->xset_mark(Xgc,cmark,xmark[1]);
    }
}

static void nsp_translate_qcurve(NspGraphic *Obj,const double *tr)
{
  int i; 
  NspQcurve *P = (NspQcurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m;
  nsp_graphic_invalidate((NspGraphic *) Obj);
  for ( i=0; i < M->m ; i++) 
    {
      *(x++) += tr[0];
      *(y++) += tr[1];
    }
  nsp_graphic_invalidate((NspGraphic *) Obj);
}

static void nsp_rotate_qcurve(NspGraphic *Obj,double *R)
{
  int i;
  NspQcurve *P = (NspQcurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m,x1,y1;
  nsp_graphic_invalidate((NspGraphic *) Obj);
  for ( i=0; i < M->m ; i++) 
    {
      x1 = R[0]*(*x) -R[1]*(*y);
      y1 = R[1]*(*x) +R[0]*(*y);
      *(x++) =x1;
      *(y++) =y1;
    }
  nsp_graphic_invalidate((NspGraphic *) Obj);
}

static void nsp_scale_qcurve(NspGraphic *Obj,double *alpha)
{
  int i;
  NspQcurve *P = (NspQcurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m;
  nsp_graphic_invalidate((NspGraphic *) Obj);
  for ( i=0; i < M->m ; i++) 
    {
      *(x++) *= alpha[0];
      *(y++) *= alpha[1];
    }
  nsp_graphic_invalidate((NspGraphic *) Obj);
}

/* compute in bounds the enclosing rectangle of qcurve 
 *
 */

static int nsp_getbounds_qcurve(NspGraphic *Obj,double *bounds)
{
  int pos,max;
  NspQcurve *C = (NspQcurve *) Obj;
  NspMatrix *M = C->obj->Pts;
  double *x=M->R,*y= M->R+M->m, dval;

  if ( M->mn == 0) return FALSE;
  if ( C->obj->start == -1) return FALSE;
  
  pos = C->obj->start;
  
  bounds[0]=x[pos];/* xmin */
  bounds[1]=y[pos];/* ymin */
  bounds[2]=x[pos];/* xmax */
  bounds[3]=y[pos];/* ymax */
  
  if ( pos <= C->obj->last )
    max = C->obj->last;
  else 
    max = M->m -1 ;
  while ( pos <= max )
    {
      dval = x[pos];
      if ( dval > bounds[2] )
	bounds[2] = dval;
      else if ( dval < bounds[0] )
	bounds[0] = dval;
      dval = y[pos];
      if ( dval > bounds[3] )
	bounds[3] = dval;
      else if ( dval < bounds[1] )
	bounds[1] = dval;
      pos++;
    }
  if ( C->obj->last < C->obj->start )
    {
      pos = 0;
      while ( pos <= C->obj->last )
	{
	  dval = x[pos];
	  if ( dval > bounds[2] )
	    bounds[2] = dval;
	  else if ( dval < bounds[0] )
	    bounds[0] = dval;
	  dval = y[pos];
	  if ( dval > bounds[3] )
	    bounds[3] = dval;
	  else if ( dval < bounds[1] )
	    bounds[1] = dval;
	  pos++;
	}
    }
  return TRUE;
}

static void nsp_qcurve_addPts(NspQcurve *C,NspMatrix *Pts)
{
  /* XXX : check if matrix is real and with two columns 
   */
  return nsp_qcurve_addpt(C,Pts->R,Pts->R+Pts->m,Pts->m);
}

static void nsp_qcurve_addpt(NspQcurve *C,double *x,double *y,int n)
{
  NspMatrix *M = C->obj->Pts;
  double *qx=M->R,*qy= M->R+M->m;
  int i,pos;
  /* add n points to the qcurvebuffer 
   */
  if ( M->mn == 0 ) return ;
  if ( C->obj->start == -1 )
    {
      /* initialize */
      C->obj->start = 0;
    }
  for ( i = 0 ; i < n ; i++)
    {
      /* insert after last */
      if ( C->obj->last == -1 )
	{
	  C->obj->last = 0;
	}
      else
	{
	  C->obj->last++;
	  if ( C->obj->last >= M->m )C->obj->last = 0;
	  if ( C->obj->last == C->obj->start)
	    {
	      C->obj->start++;
	      if ( C->obj->start >= M->m ) C->obj->start = 0;
	    }
	}
      /* now insert at  C->obj->last */
      pos = C->obj->last;
      qx[pos]= x[i];
      qy[pos]= y[i];
    }
}

static void nsp_qcurve_clear(NspQcurve *C)
{
  C->obj->start = -1;
}

static int nsp_qcurve_get_len(NspQcurve *C)
{
  return ( C->obj->start <= C->obj->last) 
    ? C->obj->last - C->obj->start + 1
    : C->obj->Pts->m - C->obj->start + C->obj->last +1;
}

static void nsp_qcurve_get_xy(NspQcurve *C,double *cx,double *cy)
{
  int i=0 ,pos,max;
  NspMatrix *M = C->obj->Pts;
  double *x=M->R,*y= M->R+M->m;
  pos = C->obj->start;
  max =( pos <= C->obj->last )
    ? C->obj->last :  M->m -1 ;
  while ( pos <= max )
    {
      cx[i]  = x[pos];
      cy[i]  = y[pos];
      pos++;i++;
    }
  if ( C->obj->last < C->obj->start )
    {
      pos = 0;
      while ( pos <= C->obj->last )
	{
	  cx[i]  = x[pos];
	  cy[i]  = y[pos];
	  pos++;i++;
	}
    }
}

/* set up an oscillo 
 * 
 */

NspFigure *nsp_oscillo_obj(int win,int ncurves,int style[],int bufsize,int yfree,double ymin,double ymax,NspList **Lc)
{
  NspAxes *axe;
  BCG *Xgc;
  char *curve_l=NULL;
  int i,l;
  /*
   * set current window
   */
  if ((Xgc = window_list_get_first()) != NULL) 
    Xgc->graphic_engine->xset_curwin(Max(win,0),TRUE);
  else 
    Xgc= set_graphic_window_new(Max(win,0));

  /*
   * Gc of new window 
   */
  if ((Xgc = window_list_get_first())== NULL) return NULL;
  if ((axe=  nsp_check_for_axes(Xgc,NULL)) == NULL) return NULL;

  /* clean previous plots 
   */ 

  l =  nsp_list_length(axe->obj->children);
  for ( i = 0 ; i < l  ; i++)
    nsp_list_remove_first(axe->obj->children);

  /* create a set of qcurves and insert them in axe */
  for ( i = 0 ; i < ncurves ; i++) 
    {
      int mark=-1;
      NspQcurve *curve;
      NspMatrix *Pts = nsp_matrix_create("Pts",'r',Max(bufsize,0),2); 
      if ( Pts == NULL) return NULL;
      if ( style[i] <= 0 ) mark = -style[i];
      curve= nsp_qcurve_create("curve",mark,0,0,( style[i] > 0 ) ?  style[i] : -1,
			       qcurve_std,Pts,curve_l,-1,-1,NULL);
      if ( curve == NULL) return NULL;
      /* insert the new curve */
      if ( nsp_list_end_insert( axe->obj->children,(NspObject *)curve )== FAIL)
	return NULL;
    }
  nsp_list_link_figure(axe->obj->children, ((NspGraphic *) axe)->obj->Fig,((NspGraphic *) axe)->obj);
  /* updates the axes scale information */
  nsp_strf_axes(Xgc, axe , NULL, '2');
  axe->obj->iso = FALSE;
  axe->obj->fixed = FALSE;
  nsp_figure_force_redraw(((NspGraphic *) axe)->obj->Fig,NULL);
  if ( Lc != NULL) *Lc = axe->obj->children;
  return ((NspGraphic *) axe)->obj->Fig;
}

void  nsp_oscillo_add_point(NspList *L,double t,double *y, int n)
{
  int count =0;
  Cell *Loc = L->first;
  while ( Loc != NULLCELL ) 
    {
      if ( Loc->O != NULLOBJ )
	{ 
	  NspQcurve *curve =(NspQcurve *) Loc->O;
	  if ( count >= n ) return;
	  nsp_qcurve_addpt(curve,&t,&y[count],1);
	  count++;
	  return;
	}
      Loc = Loc->next;
    }
}

static void oscillo_test()
{
  int style[]={-1,2,3};
  nsp_oscillo_obj(123,3,style,100,TRUE,0,0,NULL);
}


     
