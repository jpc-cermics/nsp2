/* -*- Mode: C -*- */
%%
headers
#include <nsp/axes.h>
#include <nsp/figure.h> 
extern BCG *nsp_check_graphic_context(void);
extern void store_graphic_object(BCG *Xgc,NspObject *obj);
static void nsp_draw_vfield(BCG *Xgc,NspGraphic *Obj, void *data);
static void nsp_translate_vfield(BCG *Xgc,NspGraphic *o,double *tr);
static void nsp_rotate_vfield(BCG *Xgc,NspGraphic *o,double *R);
static void nsp_scale_vfield(BCG *Xgc,NspGraphic *o,double *alpha);
static void nsp_getbounds_vfield(BCG *Xgc,NspGraphic *o,double *bounds);

extern void nsp_figure_force_redraw(nsp_figure *F);

#ifdef  WITH_GTKGLEXT 
extern Gengine GL_gengine;
#endif 

%%
init 

Init portion 

%%
override_type NspVField
  /* inserted verbatim in the type definition */
  ((NspTypeNspGraphic *) type->surtype)->draw = nsp_draw_vfield;
  ((NspTypeNspGraphic *) type->surtype)->translate =nsp_translate_vfield ;
  ((NspTypeNspGraphic *) type->surtype)->rotate =nsp_rotate_vfield  ;
  ((NspTypeNspGraphic *) type->surtype)->scale =nsp_scale_vfield  ;
  ((NspTypeNspGraphic *) type->surtype)->bounds =nsp_getbounds_vfield  ;
  /* next method are defined in NspGraphic and need not be chnaged here for GMatrix */
  /* ((NspTypeNspGraphic *) type->surtype)->link_figure = nsp_graphic_link_figure; */ 
  /* ((NspTypeNspGraphic *) type->surtype)->unlink_figure = nsp_graphic_unlink_figure; */ 

%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type


%%
override nsp_extractelts_vfield kwargs

extern function int_nspgraphic_extract;

int _wrap_nsp_extractelts_vfield(Stack stack, int rhs, int opt, int lhs) 
{
  return int_nspgraphic_extract(stack,rhs,opt,lhs);
}

%%
override nsp_setrowscols_vfield kwargs

extern function int_graphic_set_attribute;

int _wrap_nsp_setrowscols_vfield(Stack stack, int rhs, int opt, int lhs) 
{
  return int_graphic_set_attribute(stack,rhs,opt,lhs);
}

%%
last

static void nsp_draw_vfield(BCG *Xgc,NspGraphic *Obj, void *data)
{
  double arfact = 1.0;
  NspVField *P = (NspVField *) Obj;
  double *x= P->obj->x->R; 
  double *y= P->obj->y->R; 
  double *fx= P->obj->fx->R; 
  double *fy= P->obj->fy->R; 
  int n1 = P->obj->x->mn;
  int n2 = P->obj->y->mn;
  if ( ((NspGraphic *) P)->obj->hidden == TRUE ) return;
  if ( P->obj->x->mn  == 0 || P->obj->y->mn  == 0 ) return;
  nsp_draw_vfield_generic(Xgc,"champ",P->obj->colored,x,y,fx,fy,n1,n2,TRUE,NULL,NULL,&arfact);
}


static void nsp_translate_vfield(BCG *Xgc,NspGraphic *Obj,double *tr)
{
  NspVField *P = (NspVField *) Obj;
  int i;
  for ( i = 0 ; i < P->obj->x->mn ; i++) 
    P->obj->x->R[i] += tr[0];
  for ( i = 0 ; i < P->obj->y->mn ; i++) 
    P->obj->x->R[i] += tr[1];
  nsp_figure_force_redraw(Obj->obj->Fig);
}

static void nsp_rotate_vfield(BCG *Xgc,NspGraphic *Obj,double *R)
{
  /* NspVField *P = (NspVField *) Obj; */
  Sciprintf("we should get a double here for alpha\n");
  nsp_figure_force_redraw(Obj->obj->Fig);
}

static void nsp_scale_vfield(BCG *Xgc,NspGraphic *Obj,double *alpha)
{
  int i;
  NspVField *P = (NspVField *) Obj;
  for ( i = 0 ; i < P->obj->x->mn ; i++) 
    P->obj->x->R[i] *= alpha[0];
  for ( i = 0 ; i < P->obj->y->mn ; i++) 
    P->obj->x->R[i] *= alpha[1];
  nsp_figure_force_redraw(Obj->obj->Fig);
}

/* compute in bounds the enclosing rectangle of vfield 
 *
 */

static void nsp_getbounds_vfield (BCG *Xgc,NspGraphic *Obj,double *bounds)
{
  NspVField *P = (NspVField *) Obj;
  /* get the bound in parent i.e given by wrect : upper-left w,h */
  if ( P->obj->x->mn != 0 ) 
    {
      bounds[0]=P->obj->x->R[0]; /* xmin */
      bounds[2]=P->obj->x->R[P->obj->x->mn-1];/* xmax */
    }
  if ( P->obj->y->mn != 0 ) 
    {
      bounds[1]=P->obj->y->R[0] ; /* ymin */
      bounds[3]=P->obj->y->R[P->obj->y->mn-1];/* ymax */
    }
}

