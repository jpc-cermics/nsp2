/* -*- Mode: C -*- */
%%
include-start Curve
/* inserted at the start of include file */
#include <nsp/figure.h>

%%
include-public Curve
/* inserted at the end of public part of include file */

%%
include-private Curve

/* inserted in the private part of include file */
static void nsp_draw_curve(BCG *Xgc,NspGraphic *Obj, const GdkRectangle *rect,void *data);
static void nsp_translate_curve(NspGraphic *o,const double *tr);
static void nsp_rotate_curve(NspGraphic *o,double *R);
static void nsp_scale_curve(NspGraphic *o,double *alpha);
static int nsp_getbounds_curve(NspGraphic *o,double *bounds);

%%
headers
#include <gdk/gdk.h>
#include <nsp/objects.h>
#include <nsp/curve.h>
#include <nsp/figuredata.h>
#include <nsp/figure.h>

%%
init

Init portion

%%
override-type Curve
  /* inserted verbatim in the type definition */
  type->gtk_methods = TRUE;
  /* here we override the method or its father class i.e Graphic */
  ((NspTypeGraphic *) type->surtype)->draw = nsp_draw_curve;
  ((NspTypeGraphic *) type->surtype)->translate =nsp_translate_curve ;
  ((NspTypeGraphic *) type->surtype)->rotate =nsp_rotate_curve  ;
  ((NspTypeGraphic *) type->surtype)->scale =nsp_scale_curve  ;
  ((NspTypeGraphic *) type->surtype)->bounds =nsp_getbounds_curve  ;
  /* next method are defined in NspGraphic and need not be chnaged here for Curve */
  /* ((NspTypeGraphic *) type->surtype)->link_figure = nsp_graphic_link_figure; */
  /* ((NspTypeGraphic *) type->surtype)->unlink_figure = nsp_graphic_unlink_figure; */

%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type

%%
override-attr Curve.mode
/* override set alpha */
static int _wrap_curve_set_mode(void *self, char *attr, NspObject *O)
{
  int mode;
  if ( IntScalar(O,&mode) == FAIL) return FAIL;
  if ( ((NspCurve *) self)->obj->mode !=  mode)
    {
      ((NspCurve *) self)->obj->mode =  mode;
      nsp_graphic_invalidate((NspGraphic *) self);
    }
  return OK;
}

%%
override-attr Curve.Pts

/* overriden to check dimensions when changing values.
 */

static NspObject *_wrap_curve_get_obj_Pts(void *self,char *attr, int *copy)
{
  NspMatrix *ret;
  *copy = TRUE;
  ret = ((NspMatrix*) ((NspCurve *) self)->obj->Pts);
  return (NspObject *) ret;
}

static int _wrap_curve_set_obj_Pts(void *self,NspObject *val)
{
  NspMatrix *M= (NspMatrix *) val ;
  NspCurve *poly = self ;
  if ( M->rc_type != 'r' || M->n != 2 )
    {
      Scierror("Error: curve field Pts should be real an mx2 sized\n");
      return FAIL;
    }
  /* before replacing the field we check that dimensions are correct */
  if ( poly->obj->Pts != NULL )
    nsp_matrix_destroy(poly->obj->Pts);
  poly->obj->Pts = (NspMatrix *) val ;
  return OK;
}

%%
override nsp_extractelts_curve kwargs

extern function int_nspgraphic_extract;

int _wrap_nsp_extractelts_curve(Stack stack, int rhs, int opt, int lhs)
{
  return int_nspgraphic_extract(stack,rhs,opt,lhs);
}

%%
override nsp_setrowscols_curve kwargs

extern function int_graphic_set_attribute;

int _wrap_nsp_setrowscols_curve(Stack stack, int rhs, int opt, int lhs)
{
  return int_graphic_set_attribute(stack,rhs,opt,lhs);
}


%%
last

/* inserted verbatim at the end */
/*
    '("int" "color"); curve color
    '("int" "mark") ; mark to be used
    '("double" "width"); line width
    '("int" "style"); line style
    '("int" "mode"); mode: std, step, stem, arrow.
    '("NspMatrix*" "Pts")
*/

typedef enum { curve_std, curve_stairs, curve_stem , curve_arrow} nsp_curve_mode ;

static void nsp_draw_curve(BCG *Xgc,NspGraphic *Obj, const GdkRectangle *rect,void *data)
{
  int xmark[2]={-1,-1};
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  int c_width =  Xgc->graphic_engine->xget_thickness(Xgc);
  int c_color = Xgc->graphic_engine->xget_pattern(Xgc);

  if (Obj->obj->show == FALSE ) return;

  /* check if the block is inside drawing rectangle
   */

  if ( ! nsp_graphic_intersect_rectangle(Obj, rect))
    {
      return ;
    }

  if ( P->obj->Pts->m == 0) return;
  Xgc->graphic_engine->xset_thickness(Xgc,P->obj->width);
  if ( P->obj->mark >= -1 )
    {
      /* we will use a mark */
      Xgc->graphic_engine->xget_mark(Xgc,xmark);
      if ( P->obj->mark_size >= 0 )
	Xgc->graphic_engine->xset_mark(Xgc, P->obj->mark,P->obj->mark_size);
      else
	Xgc->graphic_engine->xset_mark(Xgc, P->obj->mark,xmark[1]);
    }

  switch ( P->obj->mode )
    {
    case curve_std:
      if ( P->obj->color >= -1 )
	{
	  if ( P->obj->color >= 0 ) Xgc->graphic_engine->xset_pattern(Xgc, P->obj->color);
	  Xgc->graphic_engine->scale->drawpolyline(Xgc,M->R,M->R+M->m,M->m,0);
	  if ( P->obj->color >= 0 ) Xgc->graphic_engine->xset_pattern(Xgc, c_color);
	}
      if ( P->obj->mark >= -1 )
	{
	  if ( P->obj->mark_color >= 0) Xgc->graphic_engine->xset_pattern(Xgc, P->obj->mark_color);
	  Xgc->graphic_engine->scale->drawpolymark(Xgc,M->R,M->R+M->m,M->m);
	  if ( P->obj->mark_color >= 0) Xgc->graphic_engine->xset_pattern(Xgc, c_color);
	}
      break;
    case curve_stairs:
      {
	double *xm=NULL,*ym=NULL;
	int n= 2*M->m,i;
	xm = graphic_alloc(0,n,sizeof(double));
	ym = graphic_alloc(1,n,sizeof(double));
	if ( xm == 0 || ym == 0)
	  {
	    Sciprintf("Error: cannot allocated points for drawing\n");
	    return;
	  }
	for ( i=0 ; i < M->m -1 ; i++)
	  {
	    xm[2*i]= M->R[i];
	    ym[2*i]= M->R[i+M->m];
	    xm[2*i+1]= M->R[i+1];
	    ym[2*i+1]= ym[2*i];
	  }
	xm[2*(M->m-1)] = M->R[M->m-1];
	ym[2*(M->m-1)] = M->R[M->m-1+M->m];
	if ( P->obj->color >= -1 )
	  {
	    if ( P->obj->color >= 0 ) Xgc->graphic_engine->xset_pattern(Xgc, P->obj->color);
	    Xgc->graphic_engine->scale->drawpolyline(Xgc,xm,ym,2*M->m-1,0);
	    if ( P->obj->color >= 0 ) Xgc->graphic_engine->xset_pattern(Xgc, c_color);
	  }
	if ( P->obj->mark >= -1 )
	  {
	    if ( P->obj->mark_color >= 0) Xgc->graphic_engine->xset_pattern(Xgc, P->obj->mark_color);
	    Xgc->graphic_engine->scale->drawpolymark(Xgc,xm,ym,2*M->m-1);
	    if ( P->obj->mark_color >= 0) Xgc->graphic_engine->xset_pattern(Xgc, c_color);
	  }
      }
      break;
    case curve_stem:
      {
	int iflag=0;
	double *xm=NULL,*ym=NULL;
	int n= 2*M->m,i;
	xm = graphic_alloc(0,n,sizeof(double));
	ym = graphic_alloc(1,n,sizeof(double));
	if ( xm == 0 || ym == 0)
	  {
	    Sciprintf("Error: cannot allocated points for drawing\n");
	    return;
	  }
	for ( i=0 ; i < M->m ; i++)
	  {
	    xm[2*i]= M->R[i];
	    ym[2*i]= 0;
	    xm[2*i+1]= M->R[i];
	    ym[2*i+1]= M->R[i+M->m];
	  }
	Xgc->graphic_engine->scale->drawsegments(Xgc,xm,ym,2*M->m,&P->obj->color,iflag);
      }
      break;
    case curve_arrow:
      /* a faire */
      break;
    }
  Xgc->graphic_engine->xset_thickness(Xgc,c_width);
  Xgc->graphic_engine->xset_pattern(Xgc,c_color);
  if ( P->obj->mark >= 0)
    {
      Xgc->graphic_engine->xset_mark(Xgc,xmark[0],xmark[1]);
    }
}

static void nsp_translate_curve(NspGraphic *Obj,const double *tr)
{
  int i;
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m;
  nsp_graphic_invalidate((NspGraphic *) Obj);
  for ( i=0; i < M->m ; i++)
    {
      *(x++) += tr[0];
      *(y++) += tr[1];
    }
  nsp_graphic_invalidate((NspGraphic *) Obj);

}

static void nsp_rotate_curve(NspGraphic *Obj,double *R)
{
  int i;
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m,x1,y1;
  nsp_graphic_invalidate((NspGraphic *) Obj);
  for ( i=0; i < M->m ; i++)
    {
      x1 = R[0]*(*x) -R[1]*(*y);
      y1 = R[1]*(*x) +R[0]*(*y);
      *(x++) =x1;
      *(y++) =y1;
    }
  nsp_graphic_invalidate((NspGraphic *) Obj);
}

static void nsp_scale_curve(NspGraphic *Obj,double *alpha)
{
  int i;
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m;
  nsp_graphic_invalidate((NspGraphic *) Obj);
  for ( i=0; i < M->m ; i++)
    {
      *(x++) *= alpha[0];
      *(y++) *= alpha[1];
    }
  nsp_graphic_invalidate((NspGraphic *) Obj);
}

/* compute in bounds the enclosing rectangle of curve
 *
 */

static int nsp_getbounds_curve(NspGraphic *Obj,double *bounds)
{
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m;
  if ( M->mn == 0) return FALSE;
  bounds[0]= Mini(x,M->m);
  bounds[1]= Mini(y,M->m);
  bounds[2]= Maxi(x,M->m);
  bounds[3]= Maxi(y,M->m);
  return TRUE;
}
