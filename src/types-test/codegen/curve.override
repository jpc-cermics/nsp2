/* -*- Mode: C -*- */
%%
headers
#include "nsp/curve.h"
#include <nsp/figure.h>
extern BCG *nsp_check_graphic_context(void);
extern void store_graphic_object(BCG *Xgc,NspObject *obj);
static void nsp_draw_curve(BCG *Xgc,NspGraphic *Obj, void *data);
static void nsp_translate_curve(BCG *Xgc,NspGraphic *o,double *tr);
static void nsp_rotate_curve(BCG *Xgc,NspGraphic *o,double *R);
static void nsp_scale_curve(BCG *Xgc,NspGraphic *o,double *alpha);
static void nsp_getbounds_curve(BCG *Xgc,NspGraphic *o,double *bounds);

extern void nsp_figure_force_redraw( nsp_figure *F);
%%
init 

Init portion 

%%
override_type Curve
  /* inserted verbatim in the type definition */
  ((NspTypeGraphic *) type->surtype)->draw = nsp_draw_curve;
  ((NspTypeGraphic *) type->surtype)->translate =nsp_translate_curve ;
  ((NspTypeGraphic *) type->surtype)->rotate =nsp_rotate_curve  ;
  ((NspTypeGraphic *) type->surtype)->scale =nsp_scale_curve  ;
  ((NspTypeGraphic *) type->surtype)->bounds =nsp_getbounds_curve  ;
  /* next method are defined in NspGraphic and need not be chnaged here for Curve */
  /* ((NspTypeGraphic *) type->surtype)->link_figure = nsp_graphic_link_figure; */ 
  /* ((NspTypeGraphic *) type->surtype)->unlink_figure = nsp_graphic_unlink_figure; */ 

%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type

%%
override curve_attach kwargs
int _wrap_curve_attach(Stack stack, int rhs, int opt, int lhs)
{
  NspObject  *pl = NULL;
  BCG *Xgc;
  int_types T[] = {obj, t_end} ;
  if ( GetArgs(stack,rhs,opt,T,&pl) == FAIL) return RET_BUG;
  Xgc=nsp_check_graphic_context();
  store_graphic_object(Xgc, pl);
  return 0;
}

%%
override-attr mode 
/* override set alpha */
static int _wrap_curve_set_mode(void *self, char *attr, NspObject *O)
{
  int mode;
  if ( IntScalar(O,&mode) == FAIL) return FAIL;
  if ( ((NspCurve *) self)->obj->mode !=  mode)
    {
      ((NspCurve *) self)->obj->mode =  mode;
      nsp_figure_force_redraw(((NspGraphic *) self)->obj->Fig);
    }
  return OK;
}

%%
override-attr Pts 

/* overriden to check dimensions when changing values.
 */

static NspObject *_wrap_curve_get_obj_Pts(void *self,char *attr, int *copy)
{
  NspMatrix *ret;
  *copy = TRUE; 
  ret = ((NspMatrix*) ((NspCurve *) self)->obj->Pts);
  return (NspObject *) ret;
}

static int _wrap_curve_set_obj_Pts(void *self,NspObject *val)
{
  NspMatrix *M= (NspMatrix *) val ; 
  NspCurve *poly = self ;
  if ( M->rc_type != 'r' || M->n != 2 )
    {
      Scierror("Error: curve field Pts should be real an mx2 sized\n");
      return FAIL;
    }
  /* before replacing the field we check that dimensions are correct */
  if ( poly->obj->Pts != NULL )
    nsp_matrix_destroy(poly->obj->Pts);
  poly->obj->Pts = (NspMatrix *) val ;
  return OK;
}

%%
override nsp_extractelts_curve kwargs

extern function int_nspgraphic_extract;

int _wrap_nsp_extractelts_curve(Stack stack, int rhs, int opt, int lhs) 
{
  return int_nspgraphic_extract(stack,rhs,opt,lhs);
}

%%
override nsp_setrowscols_curve kwargs

extern function int_graphic_set_attribute;

int _wrap_nsp_setrowscols_curve(Stack stack, int rhs, int opt, int lhs) 
{
  return int_graphic_set_attribute(stack,rhs,opt,lhs);
}


%%
last

/* inserted verbatim at the end */
/* 
    '("int" "color"); curve color 
    '("int" "mark") ; mark to be used 
    '("double" "width"); line width 
    '("int" "style"); line style 
    '("int" "mode"); mode: std, step, stem, arrow.
    '("NspMatrix*" "Pts")
*/

typedef enum { curve_std, curve_stairs, curve_stem , curve_arrow} nsp_curve_mode ; 

static void nsp_draw_curve(BCG *Xgc,NspGraphic *Obj, void *data)
{
  int cmark=-1;
  int xmark[2];
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  int c_width = Xgc->graphic_engine->xget_thickness(Xgc);
  int c_color = Xgc->graphic_engine->xget_pattern(Xgc);
  if ( P->obj->Pts->m == 0) return;
  Xgc->graphic_engine->xset_thickness(Xgc,P->obj->width);
  if ( P->obj->mark != -1 ) 
    {
      Xgc->graphic_engine->xget_mark(Xgc,xmark); 
      cmark=xmark[0];
      Xgc->graphic_engine->scale->xset_mark(Xgc, P->obj->mark,xmark[1]);
    }
  if ( P->obj->color != -1 ) 
    Xgc->graphic_engine->xset_pattern(Xgc, P->obj->color);
  /*XXX: we should not be in Rec mode here */
  switch ( P->obj->mode ) 
    {
    case curve_std: 
      if ( P->obj->mark == -1 ) 
	Xgc->graphic_engine->scale->drawpolyline(Xgc,M->R,M->R+M->m,M->m,0);
      else
	Xgc->graphic_engine->scale->drawpolymark(Xgc,M->R,M->R+M->m,M->m);
      break;
    case curve_stairs:
      {
	double *xm=NULL,*ym=NULL;
	int n= 2*M->m,i;
	xm = graphic_alloc(0,n,sizeof(double));
	ym = graphic_alloc(1,n,sizeof(double));
	if ( xm == 0 || ym == 0) 
	  {
	    Sciprintf("Error: cannot allocated points for drawing\n");
	    return;
	  }
	for ( i=0 ; i < M->m -1 ; i++) 
	  {
	    xm[2*i]= M->R[i];
	    ym[2*i]= M->R[i+M->m];
	    xm[2*i+1]= M->R[i+1];
	    ym[2*i+1]= ym[2*i];
	  }
	xm[2*(M->m-1)] = M->R[M->m-1];
	ym[2*(M->m-1)] = M->R[M->m-1+M->m];
	if ( P->obj->mark == -1 ) 
	  Xgc->graphic_engine->scale->drawpolyline(Xgc,xm,ym,2*M->m-1,0); 
	else 
	  Xgc->graphic_engine->scale->drawpolymark(Xgc,xm,ym,2*M->m-1);
	  
      }
      break;
    case curve_stem:
      {
	double *xm=NULL,*ym=NULL;
	int n= 2*M->m,i;
	xm = graphic_alloc(0,n,sizeof(double));
	ym = graphic_alloc(1,n,sizeof(double));
	if ( xm == 0 || ym == 0) 
	  {
	    Sciprintf("Error: cannot allocated points for drawing\n");
	    return;
	  }
	for ( i=0 ; i < M->m ; i++) 
	  {
	    xm[2*i]= M->R[i];
	    ym[2*i]= 0;
	    xm[2*i+1]= M->R[i];
	    ym[2*i+1]= M->R[i+M->m];
	  }
	for ( i = 0 ; i < M->m ; i++)
	  {
	    int iflag=0;
	    Xgc->graphic_engine->scale->drawsegments(Xgc,xm,ym,2*M->m,&P->obj->color,iflag);
	  }
      }
      break;
    case curve_arrow: 
      /* a faire */
      break;
    }
  Xgc->graphic_engine->xset_thickness(Xgc,c_width);
  Xgc->graphic_engine->xset_pattern(Xgc,c_color);
  if ( P->obj->mark != -1 ) 
    {
      Xgc->graphic_engine->scale->xset_mark(Xgc,cmark,xmark[1]);
    }
}

static void nsp_translate_curve(BCG *Xgc,NspGraphic *Obj,double *tr)
{
  int i; 
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m;
  for ( i=0; i < M->m ; i++) 
    {
      *(x++) += tr[0];
      *(y++) += tr[1];
    }
  nsp_figure_force_redraw(Obj->obj->Fig);
}

static void nsp_rotate_curve(BCG *Xgc,NspGraphic *Obj,double *R)
{
  int i;
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m,x1,y1;
  for ( i=0; i < M->m ; i++) 
    {
      x1 = R[0]*(*x) -R[1]*(*y);
      y1 = R[1]*(*x) +R[0]*(*y);
      *(x++) =x1;
      *(y++) =y1;
    }
  nsp_figure_force_redraw(Obj->obj->Fig);
}

static void nsp_scale_curve(BCG *Xgc,NspGraphic *Obj,double *alpha)
{
  int i;
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m;
  for ( i=0; i < M->m ; i++) 
    {
      *(x++) *= alpha[0];
      *(y++) *= alpha[1];
    }
  nsp_figure_force_redraw(Obj->obj->Fig);
}

/* compute in bounds the enclosing rectangle of curve 
 *
 */

static void nsp_getbounds_curve(BCG *Xgc,NspGraphic *Obj,double *bounds)
{
  int i;
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m, dval;
  bounds[0]=*x;/* xmin */
  bounds[1]=*y;/* ymin */
  bounds[2]=*x;/* xmax */
  bounds[3]=*y;/* ymax */
  for (i = 1; i < M->m; i++)
    {
      dval = x[i];
      if ( dval > bounds[2] )
	bounds[2] = dval;
      else if ( dval < bounds[0] )
	bounds[0] = dval;
      dval = y[i];
      if ( dval > bounds[3] )
	bounds[3] = dval;
      else if ( dval < bounds[1] )
	bounds[1] = dval;
    }
}

