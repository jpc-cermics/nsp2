/* -*- Mode: C -*- */
%%
include-public Curve

/* inserted at the end of public part of include file */

%%
include-private Curve

/* inserted in the private part of include file */
static void nsp_draw_curve(BCG *Xgc,NspGraphic *Obj, GdkRectangle *rect,void *data);
static void nsp_translate_curve(NspGraphic *o,const double *tr);
static void nsp_rotate_curve(NspGraphic *o,double *R);
static void nsp_scale_curve(NspGraphic *o,double *alpha);
static int nsp_getbounds_curve(NspGraphic *o,double *bounds);

%%
headers
#include <gdk/gdk.h>
#include <nsp/object.h>
#include <nsp/curve.h>
#include <nsp/figuredata.h> 
#include <nsp/figure.h>

%%
init 

Init portion 

%%
override-type Curve
  /* inserted verbatim in the type definition */
  ((NspTypeGraphic *) type->surtype)->draw = nsp_draw_curve;
  ((NspTypeGraphic *) type->surtype)->translate =nsp_translate_curve ;
  ((NspTypeGraphic *) type->surtype)->rotate =nsp_rotate_curve  ;
  ((NspTypeGraphic *) type->surtype)->scale =nsp_scale_curve  ;
  ((NspTypeGraphic *) type->surtype)->bounds =nsp_getbounds_curve  ;
  /* next method are defined in NspGraphic and need not be chnaged here for Curve */
  /* ((NspTypeGraphic *) type->surtype)->link_figure = nsp_graphic_link_figure; */ 
  /* ((NspTypeGraphic *) type->surtype)->unlink_figure = nsp_graphic_unlink_figure; */ 

%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type

%%
override-attr Curve.mode 
/* override set alpha */
static int _wrap_curve_set_mode(void *self, char *attr, NspObject *O)
{
  int mode;
  if ( IntScalar(O,&mode) == FAIL) return FAIL;
  if ( ((NspCurve *) self)->obj->mode !=  mode)
    {
      ((NspCurve *) self)->obj->mode =  mode;
      nsp_graphic_invalidate((NspGraphic *) self);
    }
  return OK;
}

%%
override-attr Curve.Pts 

/* overriden to check dimensions when changing values.
 */

static NspObject *_wrap_curve_get_obj_Pts(void *self,char *attr, int *copy)
{
  NspMatrix *ret;
  *copy = TRUE; 
  ret = ((NspMatrix*) ((NspCurve *) self)->obj->Pts);
  return (NspObject *) ret;
}

static int _wrap_curve_set_obj_Pts(void *self,NspObject *val)
{
  NspMatrix *M= (NspMatrix *) val ; 
  NspCurve *poly = self ;
  if ( M->rc_type != 'r' || M->n != 2 )
    {
      Scierror("Error: curve field Pts should be real an mx2 sized\n");
      return FAIL;
    }
  /* before replacing the field we check that dimensions are correct */
  if ( poly->obj->Pts != NULL )
    nsp_matrix_destroy(poly->obj->Pts);
  poly->obj->Pts = (NspMatrix *) val ;
  return OK;
}

%%
override nsp_extractelts_curve kwargs

extern function int_nspgraphic_extract;

int _wrap_nsp_extractelts_curve(Stack stack, int rhs, int opt, int lhs) 
{
  return int_nspgraphic_extract(stack,rhs,opt,lhs);
}

%%
override nsp_setrowscols_curve kwargs

extern function int_graphic_set_attribute;

int _wrap_nsp_setrowscols_curve(Stack stack, int rhs, int opt, int lhs) 
{
  return int_graphic_set_attribute(stack,rhs,opt,lhs);
}


%%
last

/* inserted verbatim at the end */
/* 
    '("int" "color"); curve color 
    '("int" "mark") ; mark to be used 
    '("double" "width"); line width 
    '("int" "style"); line style 
    '("int" "mode"); mode: std, step, stem, arrow.
    '("NspMatrix*" "Pts")
*/

typedef enum { curve_std, curve_stairs, curve_stem , curve_arrow} nsp_curve_mode ; 

static void nsp_draw_curve(BCG *Xgc,NspGraphic *Obj, GdkRectangle *rect,void *data)
{
  int cmark=-1;
  int xmark[2];
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  int c_width =  Xgc->graphic_engine->xget_thickness(Xgc);
  int c_color = Xgc->graphic_engine->xget_pattern(Xgc);

  if (Obj->obj->hidden == TRUE ) return;
       
  /* check if the block is inside drawing rectangle
   */

  if ( ! nsp_graphic_intersect_rectangle(Obj, rect))
    {
      return ;
    }

  if ( P->obj->Pts->m == 0) return;
  Xgc->graphic_engine->xset_thickness(Xgc,P->obj->width);
  if ( P->obj->mark >= 0 ) 
    {
      /* use a mark */
      Xgc->graphic_engine->xget_mark(Xgc,xmark); 
      cmark=xmark[0];
      Xgc->graphic_engine->xset_mark(Xgc, P->obj->mark,xmark[1]);
    }
  if ( P->obj->color != -1 ) 
    Xgc->graphic_engine->xset_pattern(Xgc, P->obj->color);
  /*XXX: we should not be in Rec mode here */
  switch ( P->obj->mode ) 
    {
    case curve_std: 
      if ( P->obj->mark >= 0 )
	Xgc->graphic_engine->scale->drawpolymark(Xgc,M->R,M->R+M->m,M->m);
      else
	Xgc->graphic_engine->scale->drawpolyline(Xgc,M->R,M->R+M->m,M->m,0);
      break;
    case curve_stairs:
      {
	double *xm=NULL,*ym=NULL;
	int n= 2*M->m,i;
	xm = graphic_alloc(0,n,sizeof(double));
	ym = graphic_alloc(1,n,sizeof(double));
	if ( xm == 0 || ym == 0) 
	  {
	    Sciprintf("Error: cannot allocated points for drawing\n");
	    return;
	  }
	for ( i=0 ; i < M->m -1 ; i++) 
	  {
	    xm[2*i]= M->R[i];
	    ym[2*i]= M->R[i+M->m];
	    xm[2*i+1]= M->R[i+1];
	    ym[2*i+1]= ym[2*i];
	  }
	xm[2*(M->m-1)] = M->R[M->m-1];
	ym[2*(M->m-1)] = M->R[M->m-1+M->m];
	if ( P->obj->mark >= 0  ) 
	  Xgc->graphic_engine->scale->drawpolymark(Xgc,xm,ym,2*M->m-1);
	else 
	  Xgc->graphic_engine->scale->drawpolyline(Xgc,xm,ym,2*M->m-1,0); 
      }
      break;
    case curve_stem:
      {
	double *xm=NULL,*ym=NULL;
	int n= 2*M->m,i;
	xm = graphic_alloc(0,n,sizeof(double));
	ym = graphic_alloc(1,n,sizeof(double));
	if ( xm == 0 || ym == 0) 
	  {
	    Sciprintf("Error: cannot allocated points for drawing\n");
	    return;
	  }
	for ( i=0 ; i < M->m ; i++) 
	  {
	    xm[2*i]= M->R[i];
	    ym[2*i]= 0;
	    xm[2*i+1]= M->R[i];
	    ym[2*i+1]= M->R[i+M->m];
	  }
	for ( i = 0 ; i < M->m ; i++)
	  {
	    int iflag=0;
	    Xgc->graphic_engine->scale->drawsegments(Xgc,xm,ym,2*M->m,&P->obj->color,iflag);
	  }
      }
      break;
    case curve_arrow: 
      /* a faire */
      break;
    }
  Xgc->graphic_engine->xset_thickness(Xgc,c_width);
  Xgc->graphic_engine->xset_pattern(Xgc,c_color);
  if ( P->obj->mark >= 0 ) 
    {
      Xgc->graphic_engine->xset_mark(Xgc,cmark,xmark[1]);
    }
}

static void nsp_translate_curve(NspGraphic *Obj,const double *tr)
{
  int i; 
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m;
  nsp_graphic_invalidate((NspGraphic *) Obj);
  for ( i=0; i < M->m ; i++) 
    {
      *(x++) += tr[0];
      *(y++) += tr[1];
    }
  nsp_graphic_invalidate((NspGraphic *) Obj);

}

static void nsp_rotate_curve(NspGraphic *Obj,double *R)
{
  int i;
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m,x1,y1;
  nsp_graphic_invalidate((NspGraphic *) Obj);
  for ( i=0; i < M->m ; i++) 
    {
      x1 = R[0]*(*x) -R[1]*(*y);
      y1 = R[1]*(*x) +R[0]*(*y);
      *(x++) =x1;
      *(y++) =y1;
    }
  nsp_graphic_invalidate((NspGraphic *) Obj);
}

static void nsp_scale_curve(NspGraphic *Obj,double *alpha)
{
  int i;
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m;
  nsp_graphic_invalidate((NspGraphic *) Obj);
  for ( i=0; i < M->m ; i++) 
    {
      *(x++) *= alpha[0];
      *(y++) *= alpha[1];
    }
  nsp_graphic_invalidate((NspGraphic *) Obj);
}

/* compute in bounds the enclosing rectangle of curve 
 *
 */

static int nsp_getbounds_curve(NspGraphic *Obj,double *bounds)
{
  int i;
  NspCurve *P = (NspCurve *) Obj;
  NspMatrix *M = P->obj->Pts;
  double *x=M->R,*y= M->R+M->m, dval;
  if ( M->mn == 0) return FALSE;
  bounds[0]=*x;/* xmin */
  bounds[1]=*y;/* ymin */
  bounds[2]=*x;/* xmax */
  bounds[3]=*y;/* ymax */
  for (i = 1; i < M->m; i++)
    {
      dval = x[i];
      if ( dval > bounds[2] )
	bounds[2] = dval;
      else if ( dval < bounds[0] )
	bounds[0] = dval;
      dval = y[i];
      if ( dval > bounds[3] )
	bounds[3] = dval;
      else if ( dval < bounds[1] )
	bounds[1] = dval;
    }
  return TRUE;
}

