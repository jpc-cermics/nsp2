/* -*- Mode: C -*- */
%%
headers
#include <nsp/axes.h>
#include <nsp/figuredata.h> 
#include <nsp/figure.h> 
extern BCG *nsp_check_graphic_context(void);
extern void store_graphic_object(BCG *Xgc,NspObject *obj);
extern void nsp_figure_force_redraw(nsp_figure *F);
extern void PermutOfSort (const int *tab, int *perm);
extern void PaintTriangle (BCG *Xgc,const double *sx,const double *sy,const  double *fxy, 
			   const int *zxy, const double *zlevel,const int *fill);
extern void FindIntersection(const double *sx,const double *sy,const double *fxy,
			     double z,int inda, int indb,  int *xint, int *yint);

static void nsp_draw_fec(BCG *Xgc,NspGraphic *Obj, void *data);
static void nsp_translate_fec(BCG *Xgc,NspGraphic *o,double *tr);
static void nsp_rotate_fec(BCG *Xgc,NspGraphic *o,double *R);
static void nsp_scale_fec(BCG *Xgc,NspGraphic *o,double *alpha);
static void nsp_getbounds_fec(BCG *Xgc,NspGraphic *o,double *bounds);


static void draw_triangle(BCG *Xgc,const double *sx,const double *sy);

#ifdef  WITH_GTKGLEXT 
extern Gengine GL_gengine;
#endif 

%%
init 

Init portion 

%%
override-type Fec
  /* inserted verbatim in the type definition */
  ((NspTypeNspGraphic *) type->surtype)->draw = nsp_draw_fec;
  ((NspTypeNspGraphic *) type->surtype)->translate =nsp_translate_fec ;
  ((NspTypeNspGraphic *) type->surtype)->rotate =nsp_rotate_fec  ;
  ((NspTypeNspGraphic *) type->surtype)->scale =nsp_scale_fec  ;
  ((NspTypeNspGraphic *) type->surtype)->bounds =nsp_getbounds_fec  ;
  /* next method are defined in NspGraphic and need not be chnaged here for Fec */
  /* ((NspTypeNspGraphic *) type->surtype)->link_figure = nsp_graphic_link_figure; */ 
  /* ((NspTypeNspGraphic *) type->surtype)->unlink_figure = nsp_graphic_unlink_figure; */ 

%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type


%%
override nsp_extractelts_fec kwargs

extern function int_nspgraphic_extract;

int _wrap_nsp_extractelts_fec(Stack stack, int rhs, int opt, int lhs) 
{
  return int_nspgraphic_extract(stack,rhs,opt,lhs);
}

%%
override nsp_setrowscols_fec kwargs

extern function int_graphic_set_attribute;

int _wrap_nsp_setrowscols_fec(Stack stack, int rhs, int opt, int lhs) 
{
  return int_graphic_set_attribute(stack,rhs,opt,lhs);
}

%%
last

/* inserted verbatim at the end */

static void nsp_translate_fec(BCG *Xgc,NspGraphic *Obj,double *tr)
{
  int i;
  NspFec *P = (NspFec *) Obj;
  double *x=P->obj->x->R,*y= P->obj->y->R;
  for ( i=0; i < P->obj->x->mn ; i++) 
    {
      *(x++) += tr[0];
    }
  for ( i=0; i < P->obj->y->mn ; i++) 
    {
      *(y++) += tr[1];
    }
  nsp_figure_force_redraw(Obj->obj->Fig);
}

static void nsp_rotate_fec(BCG *Xgc,NspGraphic *Obj,double *R)
{
  /* nsp_figure_force_redraw(Obj->obj->Fig); */
}

static void nsp_scale_fec(BCG *Xgc,NspGraphic *Obj,double *alpha)
{
  int i;
  NspFec *P = (NspFec *) Obj;
  double *x=P->obj->x->R,*y= P->obj->y->R;
  for ( i=0; i < P->obj->x->mn ; i++) 
    {
      *(x++) *= alpha[0];
    }
  for ( i=0; i < P->obj->y->mn ; i++) 
    {
      *(y++) *= alpha[1];
    }
  nsp_figure_force_redraw(Obj->obj->Fig);
}

/* compute in bounds the enclosing rectangle of fec 
 *
 */

static void nsp_getbounds_fec (BCG *Xgc,NspGraphic *Obj,double *bounds)
{
  NspFec *P = (NspFec *) Obj;
  /* get the bound in parent i.e given by wrect : upper-left w,h */
  bounds[0]=Mini(P->obj->x->R,P->obj->x->mn);/* xmin */
  bounds[2]=Maxi(P->obj->x->R,P->obj->x->mn);/* xmax */
  bounds[1]=Mini(P->obj->y->R,P->obj->y->mn);/* ymin */
  bounds[3]=Maxi(P->obj->y->R,P->obj->y->mn);/* ymin */
  
}



static void nsp_draw_fec(BCG *Xgc,NspGraphic *Obj, void *data)
{
  double *colout = NULL ; /* XXX à rajouter */
  NspFec *P = (NspFec *) Obj;
  double *zminmax = NULL;
  double *colminmax = NULL;
  double *func= P->obj->func->R;
  double *x =  P->obj->x->R;
  double *y =  P->obj->y->R;
  double *triangles = P->obj->triangles->R;
  int Nnode = P->obj->x->mn;
  int Ntr = P->obj->triangles->m;
  int draw = P->obj->draw;
  int *xm,*ym,i,  j, k;

  if ( ((NspGraphic *) P)->obj->hidden == TRUE ) return;
  if ( P->obj->colminmax->mn == 2 ) 
    colminmax = P->obj->colminmax->R;

  if ( P->obj->zminmax->mn == 2 ) 
    zminmax = P->obj->zminmax->R;

  if ( P->obj->colout->mn == 2) 
    colout = P->obj->colout->R;

  /* Allocation */
  xm = graphic_alloc(0,Nnode,sizeof(int));
  ym = graphic_alloc(1,Nnode,sizeof(int));
  if ( xm == 0 || ym == 0) 
    {
      sciprint("Running out of memory \n");
      return;
    }      
  
  scale_f2i(Xgc,x,y,xm,ym,Nnode);

  /* Fec code */
  {
    /*
     *	 beginning of the code modified by Bruno 01/02/2001  
     */
    
    int nz, whiteid; 
    double *zlevel, dz, zmin, zmax, sx[3], sy[3];
    int *zone, *fill, zxy[3], color_min, color_max;

    /* choice between zmin and zmax given by the user or computed
     * with the min and max z values. 
     */

    if ( zminmax == NULL  ) { 
      zmin=(double) Mini(func,Nnode); 
      zmax=(double) Maxi(func,Nnode);
    } 
    else {
      zmin = Min( zminmax[0] , zminmax[1] );
      zmax = Max( zminmax[0] , zminmax[1] );
    };
      
    whiteid= Xgc->graphic_engine->xget_last(Xgc);
    nz=whiteid;
    
    /* choice for the colormap (in case of a user 's choice 
     * verify the parameter). 
     */

    if ( colminmax == NULL ) 
      {
	color_min=1; 
      }
    else 
      {
	/* we project on accepted values */
	color_min = Max(1,Min(Abs(colminmax[0]),Abs(colminmax[1])));
	color_max = Min(nz,Max(Abs(colminmax[0]),Abs(colminmax[1])));
	nz = color_max-color_min  + 1;
      }
      
    /* 
     *  1/ the purpose of the first part is to to compute the "zone" of each point :
     *    
     *    - the array zlevel are the boundaries between the differents zones :
     *
     *        zlevel[0] = zmin, zlevel[nz] = zmax 
     *     and zlevel[i] = zmin + i*(zmax-zmin)/nz
     *  
     *     - if  zlevel[j-1] <= func[i] < zlevel[j]  then zone[i] = j
     *       if func[i] > zmax  then zone[i] = nz+1
     *       if func[i] < zmin  then zone[i] = 0
     *     - the zone j is filled with color fill[j] with
     *       fill[j] = -(j-1 + color_min) if 1 <= j <= nz
     *     - if colout == NULL
     *        fill[0] = color attributed for fill[1]     ---> this behavior may be changed ...
     *        fill[nz+1] = color attributed for fill[nz] --/
     *       else 
     *        fill[0]=- colout[0];
     *        fill[1]=- colout[1];
     */
 
    /* allocations for some arrays ... */

    zone = graphic_alloc(2,(Nnode),sizeof(int));
    zlevel = graphic_alloc(3,nz+1,sizeof(double));
    fill  = graphic_alloc(4,nz+2,sizeof(int));
    if ( (zone == NULL) || (zlevel == NULL) || (fill  == NULL)) 
      {
	Scistring("fec: malloc No more Place\n");
	return;
      }
    /* compute the fill array (fill = - num color) */
    fill[1] = - color_min;
    for ( i = 2 ; i <= nz ; i++ ) fill[i] = fill[i-1] - 1;
    if ( colout == NULL) 
      {
	fill[0] =  fill[1] ; fill[nz+1] = fill[nz];
      }
    else 
      {
	fill[0] = - colout[0] ; fill[nz+1] = - colout[1];
      }

    /* compute the zlevels */
    dz = (zmax - zmin)/nz;
    for (i = 0 ; i < nz ; i++) zlevel[i] = zmin + i*dz;
    zlevel[nz] = zmax;

    /* finaly compute the zone of each point */
    for ( i = 0 ; i < (Nnode) ; i++ ) {
      if ( func[i] > zmax )
	zone[i] = nz+1;
      else if ( func[i] < zmin )
	zone[i] = 0;
      else
	zone[i] = floor( (func[i] - zmin)/dz ) + 1;
    };

    /* 
     *  2/ loop on the triangles : each triangle is finally decomposed 
     *     into its differents zones (polygons) by the function PaintTriangle   
     */
#if 0 
    if (  Xgc->graphic_engine == &GL_gengine ) 
      {
	for ( j = 0 ; j < Ntr ; j++) 
	  {
	    int ii[3],isx[3],isy[3]; 
	    /* retrieve node numbers and functions values */
	    for ( k = 0 ; k < 3 ; k++ ) {
	      ii[k] = (int) triangles[j+(Ntr)*(k+1)] - 1;
	      zxy[k] = zone[ii[k]];
	      isx[k]  = xm[ii[k]];   
	      isy[k]  = ym[ii[k]];
	      /* using ii for colors */
	      ii[k]= - fill[zxy[k]]; 
	    };
	    if (ii[0] != 0 && ii[1] != 0 && ii[2] != 0 ) 
	      {
		fillpolyline2D_shade(Xgc,isx,isy,ii,3,1); 
	      }     
	    /* call the "painting" function */
	    if ( draw == TRUE ) draw_triangle(Xgc,sx,sy);
	  };
      }
    else
#else 
      {
	for ( j = 0 ; j < Ntr ; j++) 
	  {
	    int ii[3], perm[3],kp;
	    double fxy[3];
	    
	    /* retrieve node numbers and functions values */
	    for ( k = 0 ; k < 3 ; k++ ) {
	      ii[k] = (int) triangles[j+(Ntr)*(k+1)] - 1;
	      zxy[k] = zone[ii[k]];
	    }

	    /* get the permutation perm so as zxy[perm] is sorted */
	    PermutOfSort(zxy, perm); 

	    /* apply the permutation to get the triangle 's vertices
	       in increasing zone (zxy[0] <= zxy[1] <= zxy[2]) */
	    for ( k = 0 ; k < 3 ; k++ ) {
	      kp = perm[k];
	      sx[k]  = xm[ii[kp]];   sy[k]  = ym[ii[kp]];
	      fxy[k] = func[ii[kp]]; zxy[k] = zone[ii[kp]];
	    };
	    
	    /* call the "painting" function */
	    PaintTriangle(Xgc,sx, sy, fxy, zxy, zlevel, fill);
	    
	    if ( draw == TRUE ) draw_triangle(Xgc,sx,sy);
	  }
      }
#endif 
  }

  /*
   *                     end of the modified code
   */
  
}



static void draw_triangle(BCG *Xgc,const double *sx,const double *sy)
{
  int nr, resx[3],resy[3];
  /* 
   * case of only one color for the triangle : 
   */
  resx[0]=inint(sx[0]); resx[1]=inint(sx[1]);  resx[2]=inint(sx[2]);
  resy[0]=inint(sy[0]); resy[1]=inint(sy[1]);  resy[2]=inint(sy[2]);
  nr = 3;
  Xgc->graphic_engine->drawpolyline(Xgc,resx,resy,nr,1);
}
