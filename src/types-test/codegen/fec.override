/* -*- Mode: C -*- */
%%
copyright
 * Copyright (C) 1998-2009 Jean-Philippe Chancelier Enpc/Cermics
 * Copyright (C) 2001-2009 Bruno Pinçon Enpc/Cermics
%%
include-public Fec

extern BCG *nsp_check_graphic_context(void);
extern void PermutOfSort (const int *tab, int *perm);
extern void PaintTriangle (BCG *Xgc,const double *sx,const double *sy,const  double *fxy, 
			   const int *zxy, const double *zlevel,const int *fill);
extern void FindIntersection(const double *sx,const double *sy,const double *fxy,
			     double z,int inda, int indb,  int *xint, int *yint);

/* inserted at the end of public part of include file */

%%
include-private Fec

/* inserted in the private part of include file */

static void nsp_draw_fec(BCG *Xgc,NspGraphic *Obj, const GdkRectangle *rect,void *data);
static void nsp_translate_fec(NspGraphic *o,const double *tr);
static void nsp_rotate_fec(NspGraphic *o,double *R);
static void nsp_scale_fec(NspGraphic *o,double *alpha);
static int nsp_getbounds_fec(NspGraphic *o,double *bounds);
static void draw_triangle(BCG *Xgc,const double *sx,const double *sy);

%%
headers
#include <gdk/gdk.h>
#include <nsp/figuredata.h> 
#include <nsp/figure.h> 
#include <nsp/axes.h>


#ifdef  WITH_GTKGLEXT 
extern Gengine GL_gengine;
#endif 

%%
init 

Init portion 

%%
override-type Fec
  /* inserted verbatim in the type definition */
  ((NspTypeGraphic *) type->surtype)->draw = nsp_draw_fec;
  ((NspTypeGraphic *) type->surtype)->translate =nsp_translate_fec ;
  ((NspTypeGraphic *) type->surtype)->rotate =nsp_rotate_fec  ;
  ((NspTypeGraphic *) type->surtype)->scale =nsp_scale_fec  ;
  ((NspTypeGraphic *) type->surtype)->bounds =nsp_getbounds_fec  ;
  /* next method are defined in NspGraphic and need not be chnaged here for Fec */
  /* ((NspTypeGraphic *) type->surtype)->link_figure = nsp_graphic_link_figure; */ 
  /* ((NspTypeGraphic *) type->surtype)->unlink_figure = nsp_graphic_unlink_figure; */ 

%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type

%%
override nsp_extractelts_fec kwargs

extern function int_nspgraphic_extract;

int _wrap_nsp_extractelts_fec(Stack stack, int rhs, int opt, int lhs) 
{
  return int_nspgraphic_extract(stack,rhs,opt,lhs);
}

%%
override nsp_setrowscols_fec kwargs

extern function int_graphic_set_attribute;

int _wrap_nsp_setrowscols_fec(Stack stack, int rhs, int opt, int lhs) 
{
  return int_graphic_set_attribute(stack,rhs,opt,lhs);
}

%%
last

/* inserted verbatim at the end */

static void nsp_translate_fec(NspGraphic *Obj,const double *tr)
{
  int i;
  NspFec *P = (NspFec *) Obj;
  double *x=P->obj->x->R,*y= P->obj->y->R;
  nsp_graphic_invalidate((NspGraphic *) Obj);
  for ( i=0; i < P->obj->x->mn ; i++) 
    {
      *(x++) += tr[0];
    }
  for ( i=0; i < P->obj->y->mn ; i++) 
    {
      *(y++) += tr[1];
    }
  nsp_graphic_invalidate((NspGraphic *) Obj);
}

static void nsp_rotate_fec(NspGraphic *Obj,double *R)
{
  nsp_graphic_invalidate((NspGraphic *) Obj);
}

static void nsp_scale_fec(NspGraphic *Obj,double *alpha)
{
  int i;
  NspFec *P = (NspFec *) Obj;
  double *x=P->obj->x->R,*y= P->obj->y->R;
  nsp_graphic_invalidate((NspGraphic *) Obj);
  for ( i=0; i < P->obj->x->mn ; i++) 
    {
      *(x++) *= alpha[0];
    }
  for ( i=0; i < P->obj->y->mn ; i++) 
    {
      *(y++) *= alpha[1];
    }
  nsp_graphic_invalidate((NspGraphic *) Obj);
}

/* compute in bounds the enclosing rectangle of fec 
 *
 */

static int nsp_getbounds_fec (NspGraphic *Obj,double *bounds)
{
  NspFec *P = (NspFec *) Obj;
  /* get the bound in parent i.e given by wrect : upper-left w,h */
  bounds[0]=Mini(P->obj->x->R,P->obj->x->mn);/* xmin */
  bounds[2]=Maxi(P->obj->x->R,P->obj->x->mn);/* xmax */
  bounds[1]=Mini(P->obj->y->R,P->obj->y->mn);/* ymin */
  bounds[3]=Maxi(P->obj->y->R,P->obj->y->mn);/* ymin */
  return TRUE;
}



static void nsp_draw_fec(BCG *Xgc,NspGraphic *Obj, const GdkRectangle *rect,void *data)
{
  int *colout = NULL ; 
  int *colminmax = NULL;
  NspFec *P = (NspFec *) Obj;
  double *zminmax = NULL;
  double *func= P->obj->func->R;
  double *x =  P->obj->x->R;
  double *y =  P->obj->y->R;
  double *triangles = P->obj->triangles->R;
  int Nnode = P->obj->x->mn;
  int Ntr = P->obj->triangles->m;
  int mesh = P->obj->mesh;
  int *xm,*ym,i,  j, k, nz;
  double *zlevel, dz, zmin, zmax, sx[3], sy[3];
  int *zone, *fill, zxy[3], colors_minmax[2];

  if ( Obj->obj->show == FALSE ) return ;

  /* check if the block is inside drawing rectangle
   */

  if ( ! nsp_graphic_intersect_rectangle(Obj, rect))
    {
      return ;
    }

  if ( P->obj->colminmax->mn == 2 ) 
    colminmax = P->obj->colminmax->I;

  if ( P->obj->zminmax->mn == 2 ) 
    zminmax = P->obj->zminmax->R;

  if ( P->obj->colout->mn == 2) 
    colout = P->obj->colout->I;

  /* Allocation */
  xm = graphic_alloc(0,Nnode,sizeof(int));
  ym = graphic_alloc(1,Nnode,sizeof(int));
  if ( xm == 0 || ym == 0) 
    {
      sciprint("Running out of memory \n");
      return;
    }      
  
  scale_f2i(Xgc->scales,x,y,xm,ym,Nnode);

    
  /* choice between zmin and zmax given by the user or computed
   * with the min and max z values. 
   */
    
  if ( zminmax == NULL  ) { 
    zmin=(double) Mini(func,Nnode); 
    zmax=(double) Maxi(func,Nnode);
  } 
  else {
    zmin = Min( zminmax[0] , zminmax[1] );
    zmax = Max( zminmax[0] , zminmax[1] );
  };
    
    
  /* choice for the colormap (in case of a user 's choice 
   * verify the parameter). 
   */
    
  if ( colminmax == NULL ) 
    {
      colors_minmax[0]= 1; 
      colors_minmax[1]= Xgc->graphic_engine->xget_last(Xgc);
    }
  else 
    {
      int nz= Xgc->graphic_engine->xget_last(Xgc);
      /* we project on accepted values */
      colors_minmax[0] = Max(1,Min(Abs(colminmax[0]),Abs(colminmax[1])));
      colors_minmax[1] = Min(nz,Max(Abs(colminmax[0]),Abs(colminmax[1])));
    }
  nz = colors_minmax[1]- colors_minmax[0]+ 1;
  
  /* 
   *  1/ the purpose of the first part is to to compute the "zone" of each point :
   *    
   *    - the array zlevel are the boundaries between the differents zones :
   *
   *        zlevel[0] = zmin, zlevel[nz] = zmax 
   *     and zlevel[i] = zmin + i*(zmax-zmin)/nz
   *  
   *     - if  zlevel[j-1] <= func[i] < zlevel[j]  then zone[i] = j
   *       if func[i] > zmax  then zone[i] = nz+1
   *       if func[i] < zmin  then zone[i] = 0
   *     - the zone j is filled with color fill[j] with
   *       fill[j] = -(j-1 + color_min) if 1 <= j <= nz
   *     - if colout == NULL
   *        fill[0] = color attributed for fill[1]     ---> this behavior may be changed ...
   *        fill[nz+1] = color attributed for fill[nz] --/
   *       else 
   *        fill[0]=- colout[0];
   *        fill[1]=- colout[1];
   */
 
  /* allocations for some arrays ... */

  zone = graphic_alloc(2,(Nnode),sizeof(int));
  zlevel = graphic_alloc(3,nz+1,sizeof(double));
  fill  = graphic_alloc(4,nz+2,sizeof(int));
  if ( (zone == NULL) || (zlevel == NULL) || (fill  == NULL)) 
    {
      Scistring("fec: malloc No more Place\n");
      return;
    }
  /* compute the fill array (fill = - num color) */
  fill[1] = - colors_minmax[0];
  for ( i = 2 ; i <= nz ; i++ ) fill[i] = fill[i-1] - 1;
  if ( colout == NULL) 
    {
      fill[0] =  fill[1] ; fill[nz+1] = fill[nz];
    }
  else 
    {
      fill[0] = (colout[0]==-1) ? fill[1] : - colout[0] ;
      fill[nz+1] = (colout[1]==-1) ? fill[nz]: - colout[1];
    }

  /* compute the zlevels */
  dz = (zmax - zmin)/nz;
  for (i = 0 ; i < nz ; i++) zlevel[i] = zmin + i*dz;
  zlevel[nz] = zmax;

  /* finaly compute the zone of each point */
  for ( i = 0 ; i < (Nnode) ; i++ ) {
    if ( isnan(func[i]) ||  func[i] > zmax )
      zone[i] = nz+1;
    else if ( func[i] < zmin )
      zone[i] = 0;
    else
      zone[i] = floor( (func[i] - zmin)/dz ) + 1;
  };
  
  /* 
   *  2/ loop on the triangles : each triangle is finally decomposed 
   *     into its differents zones (polygons) by the function PaintTriangle   
   */
#if 0 
  /* when using opengl we could replace the nsp paint method 
   * by gouraud shading 
   */
  if (  Xgc->graphic_engine == &GL_gengine ) 
    {
      for ( j = 0 ; j < Ntr ; j++) 
	{
	  int ii[3],isx[3],isy[3]; 
	  /* retrieve node numbers and functions values */
	  for ( k = 0 ; k < 3 ; k++ ) {
	    ii[k] = (int) triangles[j+(Ntr)*k] - 1;
	    zxy[k] = zone[ii[k]];
	    isx[k]  = xm[ii[k]];   
	    isy[k]  = ym[ii[k]];
	    /* using ii for colors */
	    ii[k]= - fill[zxy[k]]; 
	  };
	  /* call the "painting" function */
	  if (ii[0] != 0 && ii[1] != 0 && ii[2] != 0 ) 
	    {
	      if ( P->obj->paint == TRUE  ) 
		fillpolyline2D_shade(Xgc,isx,isy,ii,3,1); 
	    }     
	  if ( draw == TRUE ) draw_triangle(Xgc,sx,sy);
	};
    }
  else
#endif
    {
      for ( j = 0 ; j < Ntr ; j++) 
	{
	  int ii[3], perm[3],kp, stop = FALSE;
	  double fxy[3];
	    
	  /* retrieve node numbers and functions values */
	  for ( k = 0 ; k < 3 ; k++ ) {
	    ii[k] = (int) triangles[j+(Ntr)*k] - 1;
	    zxy[k] = zone[ii[k]];
	  }
	    
	  for ( k = 0 ; k < 3 ; k++ )
	    stop |=  ( isnan(func[ii[k]]));
	  if ( stop == TRUE ) continue;

	  /* get the permutation perm so as zxy[perm] is sorted */
	  PermutOfSort(zxy, perm); 

	  /* apply the permutation to get the triangle 's vertices
	     in increasing zone (zxy[0] <= zxy[1] <= zxy[2]) */
	  for ( k = 0 ; k < 3 ; k++ ) {
	    kp = perm[k];
	    sx[k]  = xm[ii[kp]];   sy[k]  = ym[ii[kp]];
	    fxy[k] = func[ii[kp]]; zxy[k] = zone[ii[kp]];
	  };
	    
	  /* call the "painting" function */
	  if ( P->obj->paint == TRUE ) 
	    PaintTriangle(Xgc,sx, sy, fxy, zxy, zlevel, fill);
	  if ( mesh == TRUE ) draw_triangle(Xgc,sx,sy);
	}
    }
  
  if (  P->obj->colorbar ) 
    {
      nsp_draw_colorbar(Xgc,((NspGraphic *) P)->obj->Axe,zmin ,zmax, colors_minmax);
    }
}

static void draw_triangle(BCG *Xgc,const double *sx,const double *sy)
{
  int nr, resx[3],resy[3];
  resx[0]=inint(sx[0]); resx[1]=inint(sx[1]);  resx[2]=inint(sx[2]);
  resy[0]=inint(sy[0]); resy[1]=inint(sy[1]);  resy[2]=inint(sy[2]);
  nr = 3;
  Xgc->graphic_engine->drawpolyline(Xgc,resx,resy,nr,1);
}
