/* -*- Mode: C -*- */
%%
headers
#include "nsp/compound.h"
extern BCG *nsp_check_graphic_context(void);
extern void store_graphic_object(BCG *Xgc,NspObject *obj);
static void nsp_draw_compound(BCG *Xgc,NspGraphic *Obj);

#ifdef  WITH_GTKGLEXT 
extern Gengine GL_gengine;
#endif 

%%
init 

Init portion 

%%
override_type Compound
  /* inserted verbatim in the type definition */
  ((NspTypeGraphic *) type->surtype)->draw = nsp_draw_compound;

%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type

%%
override compound_attach kwargs
int _wrap_compound_attach(Stack stack, int rhs, int opt, int lhs)
{
  NspObject  *pl = NULL;
  BCG *Xgc;
  int_types T[] = {obj, t_end} ;
  if ( GetArgs(stack,rhs,opt,T,&pl) == FAIL) return RET_BUG;
  Xgc=nsp_check_graphic_context();
  store_graphic_object(Xgc, pl);
  return 0;
}

%%
override umfpack_action_do_action

static int _wrap_kiko_action_do_action(NspKiko *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int i, ret;

  if ( GetArgs(stack,rhs,opt,T,&i) == FAIL) return RET_BUG;
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

%%
override-attr alpha 
/* override set alpha */
static int _wrap_compound_set_alpha(void *self, char *attr, NspObject *O)
{
  double alpha;
  BCG *Xgc;
  if ( DoubleScalar(O,&alpha) == FAIL) return FAIL;
  ((NspCompound *) self)->obj->alpha = alpha;
  Xgc=nsp_check_graphic_context();
  Xgc->graphic_engine->force_redraw(Xgc);
  return OK;
}


%%
last

/* inserted verbatim at the end */
static void nsp_compound_update_frame_bounds(BCG *Xgc,double *wrect,double *frect,int *aaint,int isomode,
					     int auto_axes, char *xf);

static void nsp_compound_compute_inside_bounds(BCG *Xgc,NspGraphic *Obj,double *bounds);


static void nsp_draw_compound(BCG *Xgc,NspGraphic *Obj)
{
  char xf[]="onn";
  char strflag[]="151";
  double WRect[4],WRect1[4], FRect[4], ARect[4], inside_bounds[4];
  char logscale[2];
  int aaint[4]={10,2,10,2};
  Cell *cloc;
  NspList *L;
  NspCompound *P = (NspCompound *) Obj;
  Xgc->graphic_engine->scale->drawrectangle(Xgc,P->obj->wrect->R);
  /* draw elements */
  L = P->obj->elts;
  cloc = L->first ;
  /* we change the scale according to the compound */
  getscale2d(Xgc,WRect,FRect,logscale,ARect);
  /* wrect is [left,up,w,h] */
  WRect1[0]= (P->obj->wrect->R[0]-FRect[0])/(FRect[2]-FRect[0]);
  WRect1[1]= 1- (P->obj->wrect->R[1]-FRect[1])/(FRect[3]-FRect[1]);
  WRect1[2]= (P->obj->wrect->R[2])/(FRect[2]-FRect[0]);
  WRect1[3]= (P->obj->wrect->R[3])/(FRect[3]-FRect[1]);
  Xgc->scales->cosa= cos( P->obj->alpha);
  Xgc->scales->sina= sin( P->obj->alpha);

  /* we directly change the default scale because we do not want 
   * to register all the scales that will be generated by set_scale 
   * thus we use T in flag[1].
   */
  /* set_scale(Xgc,"fTtfff",WRect1,P->obj->frect->R,NULL,NULL,NULL); */
  nsp_compound_compute_inside_bounds(Xgc,Obj,inside_bounds);
  nsp_compound_update_frame_bounds(Xgc,WRect1,
				   TRUE ? inside_bounds : P->obj->frect->R,
				   aaint,
				   TRUE,
				   TRUE,
				   xf);
  axis_draw(Xgc,strflag);
  while ( cloc != NULLCELL ) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  NspGraphic *G= (NspGraphic *) cloc->O;
	  G->type->draw(Xgc,G);
	}
      cloc = cloc->next;
    }
  /* scale back */
  set_scale(Xgc,"fTtfff",WRect,FRect,NULL,NULL,NULL);
  Xgc->scales->cosa=1.0;
  Xgc->scales->sina=0.0;
}


/* compute the bounds of the set of objects countained in the 
 * compound 
 */

static void nsp_compound_compute_inside_bounds(BCG *Xgc,NspGraphic *Obj,double *bounds)
{
  double l_bounds[4];
  Cell *cloc;
  NspList *L;
  NspCompound *P = (NspCompound *) Obj;
  L = P->obj->elts;
  cloc = L->first ;
  
  if ( cloc == NULLCELL) 
    {
      bounds[0]=bounds[1]=0;
      bounds[2]=bounds[3]=0;
      return;
    }
  
  bounds[0]=bounds[1]=LARGEST_REAL;
  bounds[2]=bounds[3]=-LARGEST_REAL;

  while ( cloc != NULLCELL ) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  NspGraphic *G= (NspGraphic *) cloc->O;
	  G->type->bounds(Xgc,G,l_bounds);
	  if ( l_bounds[0] < bounds[0] ) 
	    bounds[0]= l_bounds[0];
	  if (  l_bounds[2] > bounds[2])
	    bounds[2]= l_bounds[2];
	  if ( l_bounds[1] < bounds[1] ) 
	    bounds[1]= l_bounds[1];
	  if (  l_bounds[3] > bounds[3])
	    bounds[3]= l_bounds[3];
	}
      cloc = cloc->next;
    }
}


void nsp_compound_update_frame_bounds(BCG *Xgc,double *wrect,double *frect,int *aaint,int isomode,int auto_axes, char *xf)
{
  double FRect1[4];
  int Xdec[3],Ydec[3],i;
  double xmin=0.0,xmax=10.0,ymin= 0.0,ymax= 10.0;
  
  xmin=frect[0];ymin=frect[1];xmax=frect[2];ymax=frect[3];
  
  /*
   * modify computed min,max if isoview requested 
   */
  
  if ( isomode == TRUE ) 
    {
      /* code by S. Mottelet 11/7/2000 */
      double hx=xmax-xmin,hy=ymax-ymin,hx1,hy1, dwdim[2];
      double ARect[4]={0,0,0,0}; /* XXXX to be modified */
      int wdim[2];
      Xgc->graphic_engine->xget_windowdim(Xgc,wdim,wdim+1);
      dwdim[0]=linint((double)wdim[0] * (wrect[2]*(1.0-ARect[0]-ARect[1])));  /* add corrections for margins */
      dwdim[1]=linint((double)wdim[1] * (wrect[3]*(1.0-ARect[2]-ARect[3])));  /* add corrections for margins */
      if ( hx/dwdim[0] < hy/dwdim[1] ) 
	{
	  hx1=dwdim[0]*hy/dwdim[1];
	  xmin=xmin-(hx1-hx)/2.0;
	  xmax=xmax+(hx1-hx)/2.0;
	}
      else 
	{
	  hy1=dwdim[1]*hx/dwdim[0];
	  ymin=ymin-(hy1-hy)/2.0;
	  ymax=ymax+(hy1-hy)/2.0;
	}
    }
    
  /* Changing min,max and aaint if using log scaling X axis */
  if ((int)strlen(xf) >= 2 && xf[1]=='l' ) 
    {
      /* xaxis */
      if ( xmin >  0)
	{
	  xmax=ceil(log10(xmax));  xmin=floor(log10(xmin));
	}
      else 
	{
	  Scistring("Warning: Can't use Log on X-axis xmin is negative \n");
	  xmax= 1; xmin= 0;
	}
      aaint[0]=1;aaint[1]=inint(xmax-xmin);
    }

  /* Changing ymin,ymax and aaint if using log scaling Y axis */
  if ((int)strlen(xf) >=3  && xf[2]=='l' ) 
    {
      /* y axis */
      if ( ymin > 0 ) 
	{
	  ymax= ceil(log10(ymax)); ymin= floor(log10(ymin));
	}
      else 
	{
	  Scistring(" Can't use Log on y-axis ymin is negative \n");
	  ymax= 1; ymin= 0;
	}
      aaint[2]=1;aaint[3]=inint(ymax-ymin);
    }
  
  /* FRect1 gives the plotting boundaries xmin,ymin,xmax,ymax */
  FRect1[0]=xmin;FRect1[1]=ymin;FRect1[2]=xmax;FRect1[3]=ymax;
  /* interval too small */
  
  if ( Abs(FRect1[0]- FRect1[2]) < 1.e-8 ) 
    {
      FRect1[0] -= 1.e-8;
      FRect1[2] += 1.e-8;
    }
  if ( Abs(FRect1[1]- FRect1[3]) < 1.e-8 ) 
    {
      FRect1[1] -= 1.e-8;
      FRect1[3] += 1.e-8;
    }
  
  /* pretty axes */
  if ( auto_axes == TRUE ) 
    {
      double FRect2[4];
      int i;
      for (i=0; i< 4 ;i++) FRect2[i]=FRect1[i];
      /* change graduation */
      Gr_Rescale_new(&xf[1],FRect2,Xdec,Ydec,&(aaint[0]),&(aaint[2]));
    }
  
  /* Update the current scale */
  
  set_scale(Xgc,"tTtttf",wrect,FRect1,aaint,xf+1,NULL);
  
  /* store information about graduation in xtics */
  
  if ( auto_axes )
    {
      for (i=0; i < 3 ; i++ ) Xgc->scales->xtics[i] = Xdec[i];
      for (i=0; i < 3 ; i++ ) Xgc->scales->ytics[i] = Ydec[i];
      Xgc->scales->xtics[3] = aaint[1];
      Xgc->scales->ytics[3] = aaint[3];
    }
  else 
    {
      Xgc->scales->xtics[0] = xmin;
      Xgc->scales->xtics[1] = xmax;
      Xgc->scales->xtics[2] = 0.0;
      Xgc->scales->xtics[3] = aaint[1];

      Xgc->scales->ytics[0] = ymin;
      Xgc->scales->ytics[1] = ymax;
      Xgc->scales->ytics[2] = 0.0;
      Xgc->scales->ytics[3] = aaint[3];
    }
  
  /* Changing back min,max and aaint if using log scaling X axis */
  if ((int)strlen(xf) >= 2 && xf[1]=='l' ) 
    {
      FRect1[0]=exp10(xmin);FRect1[2]=exp10(xmax);
    }
  /* Changing ymin,ymax and aaint if using log scaling Y axis */
  if ((int)strlen(xf) >=3  && xf[2]=='l' )
    {
      FRect1[1]= exp10(ymin);FRect1[3]= exp10(ymax);
    }

#ifdef WITH_GTKGLEXT 
  /* transmit info to opengl */
  if ( Xgc->graphic_engine == &GL_gengine ) 
    {
      nsp_ogl_set_2dview(Xgc);
    }
#endif
  
}

