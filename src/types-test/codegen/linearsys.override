/* -*- Mode: C -*- */
%%
include-start LinearSys

%%
include-public LinearSys

/* inserted at the end of public part of include file
 */

%%
include-private LinearSys

/* inserted in the private part of include file
 */

%%
headers
#include <nsp/objects.h>
#include <nsp/pmatrix.h>

%%
init 

/ * init code  * /

%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type

%%
override-int-create-final LinearSys
  /* verbatim in create/load/full_copy interface use %(ret)s for returned value */
%%
override-destroy-prelim  LinearSys
  /* verbatim in destroy */

%%
override-attr LinearSys.A

static NspObject *_wrap_linearsys_get_A(void *self,const char *attr)
{
  /* O */
  NspMatrix *ret;
  ret = ((NspLinearSys *) self)->A;
  return (NspObject *) ret;
}

static int _wrap_linearsys_set_A(void *self, char *attr, NspObject *O)
{
  NspMatrix *A = (NspMatrix *) O;
  NspMatrix *As = ((NspLinearSys *) self)->A;
  if ( ! IsMat(O) ) return FAIL;
  if ( As->m != A->m || As->n != A->n)
    {
      Scierror("Error: attribute A should be a %dx%d matrix\n",As->m,As->n);
      return FAIL;
    }
  if (( A = (NspMatrix *) nsp_object_copy_and_name(attr,O)) == NULL) return FAIL;
  if ( As != NULL ) nsp_matrix_destroy(As);
  ((NspLinearSys *) self)->A= A;
  return OK;
}

%%
override-intcreate LinearSys

int int_linearsys_create(Stack stack, int rhs, int opt, int lhs)
{
  NspLinearSys *Lss;
  char *dom = "c", *dom1;
  double sample = 1;
  NspMatrix *A, *B, *C, *X0;
  NspObject *D;
  NspPMatrix *Dp=NULL;
  int_types T[] = {mat,mat,mat,obj,mat,new_opts, t_end} ;
  nsp_option opts[] ={{ "dom", string,NULLOBJ,-1},
		      { "sample",s_double,NULLOBJ,-1},
		      { NULL,t_end,NULLOBJ,-1}};
  if ( GetArgs(stack,rhs,opt,T,&A,&B,&C,&D,&X0,&opts,&dom,&sample) == FAIL)
    return RET_BUG;
  if (! ( strcmp(dom,"c") == 0 ||  strcmp(dom,"d") == 0 ||strcmp(dom,"s") == 0 ||  strcmp(dom,"u") == 0 ))
    {
      Scierror("Error: dom should be \"c\", \"d\", \"s\" or \"u\"");
      return RET_BUG;
    }
  if ( strcmp(dom,"s") == 0 && sample <= 0)
    {
      Scierror("Error: when dom is \"s\" sample must be positive");
      return RET_BUG;
    }
  
  if ( A->m != A->n )
    {
      Scierror("Error: A should be square");
      return RET_BUG;
    }
  if ( B->m != A->m)
    {
      Scierror("Error: B number of rows, %d, is incompatible with A size %dx%d",B->m,A->m,A->m);
      return RET_BUG;
      
    }
  if ( C->n != A->m)
    {
      Scierror("Error: C number of columns, %d, is incompatible with A size %dx%d",C->n,A->m,A->m);
      return RET_BUG;
    }
  if ( IsMat(D)) 
    {
      NspMatrix *Dm=(NspMatrix *) D;
      if ( C->m*B->n != 0 && ( Dm->m != C->m || Dm->n != B->n))
	{
	  Scierror("Error: D should be %dx%d", C->m,B->n);
	  return RET_BUG;
	}
      if (( Dp=nsp_matrix_to_pmatrix(Dm))== NULLPMAT) return RET_BUG;
      
      switch ( dom[0] )
	{
	case 'c': nsp_pmatrix_set_varname(Dp,"s");break;
	case 'd': nsp_pmatrix_set_varname(Dp,"z");break;
	case 's': nsp_pmatrix_set_varname(Dp,"z");break;
	case 'u': nsp_pmatrix_set_varname(Dp,"s");break;
	}
    }
  else if ( IsPMat(D))
    {
      if (( Dp =  (NspPMatrix *)nsp_object_copy_and_name("D",NSP_OBJECT(D)) )== NULL) return RET_BUG;
    }
  if ( ! (( X0->m == A->m && X0->n == 1) || (X0->mn == 0)))
    {
      Scierror("Error: X0 should be %dx%d",A->m,1);
      return RET_BUG;
    }
  if (( dom1 = nsp_string_copy(dom)) == NULL) return RET_BUG;
  if (( A = (NspMatrix *) nsp_object_copy_and_name("A",NSP_OBJECT(A))) == NULL) return RET_BUG;
  if (( B = (NspMatrix *)nsp_object_copy_and_name("B",NSP_OBJECT(B))) == NULL) return RET_BUG;
  if (( C = (NspMatrix *)nsp_object_copy_and_name("C",NSP_OBJECT(C))) == NULL) return RET_BUG;
  if (( X0 = (NspMatrix *)nsp_object_copy_and_name("X0",NSP_OBJECT(X0))) == NULL) return RET_BUG;
  Lss= nsp_linearsys_create(NVOID,A,B,C,Dp,X0,dom1,sample,NULL);
  if ( Lss == NULL) return RET_BUG;
  MoveObj(stack,1,NSP_OBJECT(Lss));
  return Max(lhs,1);
}

%%
override extractelts_linearsys

/* compatibility with scicoslab */

int _wrap_extractelts_linearsys(Stack stack, int rhs, int opt, int lhs) /* extractelts_linearsys */
{
  NspMatrix *M;
  NspLinearSys *sys;
  int ind;
  NspObject *obj;
    CheckRhs(2,2);
  if ((sys = GetLinearSys(stack,1)) == NULL) return RET_BUG;
  if (GetScalarInt (stack, 2, &ind) == FAIL) return RET_BUG;
  switch ( ind )
    {
    case 2: /* A */ if ((obj = nsp_object_copy(NSP_OBJECT(sys->A)))== NULL) return RET_BUG;break;
    case 3: /* B */ if ((obj = nsp_object_copy(NSP_OBJECT(sys->B)))== NULL) return RET_BUG;break;
    case 4: /* C */ if ((obj = nsp_object_copy(NSP_OBJECT(sys->C)))== NULL) return RET_BUG;break;
    case 5: /* D */ if ((obj = nsp_object_copy(NSP_OBJECT(sys->D)))== NULL) return RET_BUG;break;
    case 6: /* X */ if ((obj = nsp_object_copy(NSP_OBJECT(sys->X0)))== NULL) return RET_BUG;break;
    case 7: /* dom*/
      switch ( sys->dom[0] )
	{
	case 'c':
	case 'd':
	  if ( nsp_move_string(stack,1,sys->dom,-1) == FAIL) return RET_BUG; break;
	case 's':
	  if ( nsp_move_double(stack,1,sys->dt) == FAIL) return RET_BUG; break;
	case 'u':
	  if ((M= nsp_matrix_create(NVOID,'r',0,0)) == NULL) return RET_BUG;
	  MoveObj(stack,1,NSP_OBJECT(M));
	  break;
	}
      return Max(lhs,1);
    default:
      Scierror("Error: cannot extract element %d\n",ind);
      return RET_BUG;
    }
  MoveObj(stack,1,NSP_OBJECT(obj));
  return Max(lhs,1);
}



