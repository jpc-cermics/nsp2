/* -*- Mode: C -*- */
%%
include-start Bson
/* inserted at the start of include file of bson class */

%%
include-public Bson
/* inserted at the end of public part of class include file */
extern NspBson *nsp_bson_zz(NspObject *Obj,int flag);

%%
include-private Bson
/* inserted in the private part of include file of bson class */
static NspObject *nsp_bson_loop(char *str, NspObject *O, NspObject *O1, int i, int *rep);
static int nsp_bson_is_true(void *Obj);
static int nsp_bson_insert(bson_t *b,const char *name, NspObject* Obj);
static void bson_show(void *self);
static NspHash *bson_to_hash(void *self);

%%
headers
#include <nsp/objects.h>
#include <nsp/plist.h> 
#include <nsp/plistc.h> 
#include <nsp/parse.h>
#include <mongoc.h>
#include <nsp/mcollection.h>
#include <nsp/mcursor.h>

%%
init 

/ * init code  * /

%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type

%%
override-type Bson
  /* inserted verbatim in the type definition */
  top->is_true = (is_true_func  *) nsp_bson_is_true; 

%%
override-intcreate Bson

/* override the default int_create */

int int_bson_create(Stack stack, int rhs, int opt, int lhs)
{
  bson_t* b;
  NspBson *B;
  CheckStdRhs(0,1);
  /* want to be sure that type bvar is initialized */
  nsp_type_bson = new_type_bson(T_BASE);
  if (( b = bson_malloc(sizeof(bson_t))) == NULL) 
    {
      Scierror("Error: bson_malloc failed to create a bson object\n");
      return RET_BUG;
    }
  bson_init(b);

  if ( rhs == 1) 
    {
      int i;
      NspHash *H;
      NspObject *O1;
      if ((H = GetHash(stack,1)) == NULLHASH) return RET_BUG;
      i=0;
      while (1) 
	{
	  int rep =nsp_hash_get_next_object(H,&i,&O1);
	  if ( O1 != NULLOBJ )
	    { 
	      const char *name = nsp_object_get_name(O1);
	      nsp_bson_insert(b,name, O1);
	    }
	  if ( rep == FAIL) break;
	}
    }
  if(( B = nsp_bson_create(NVOID,(void *) b,(NspTypeBase *) nsp_type_bson)) == NULL)
    {
      Scierror("Error: failed to create a bson object\n");
      return RET_BUG;
    }
  MoveObj(stack,1,(NspObject  *) B);
  return 1;
} 


%%
override-int-create-final Bson
/* verbatim in create/load/full_copy interface use %(ret)s for returned value */

%%
override-destroy-prelim  Bson
  /* verbatim in destroy */
  bson_free(H->obj->b);

%%
override Bson.bson_to_hash kwargs

static int _wrap_bson_to_hash(NspBson *self,Stack stack,int rhs,int opt,int lhs)
{
  NspHash *H;
  CheckLhs(0,1);
  CheckRhs(0,0);
  if ( ( H = bson_to_hash(self)) == NULL) return RET_BUG;
  MoveObj(stack,1,NSP_OBJECT(H));
  return 1;
}

%%
override Bson.bson_get_value kwargs
/* override a method */

/*
static int _wrap_bson_get_value(NspBson *self, Stack stack, int rhs, int opt, int lhs)
{
  CheckRhs(0,0);
  CheckLhs(0,1); 
  MoveObj(stack,1, self->value);
  return Max(lhs,1);
}
*/

%%
override-path-extract Bson 
top->path_extract = (path_func *) NULL; /* path extract as for matrix type */

%%
override-loop Bson 
top->loop = (loop_func *) nsp_bson_loop; /* loop with bson type */

%%
override-info Bson 
/*
 * info overriden 
 */

int nsp_bson_info(NspBson *M, int indent,const char *name, int rec_level)
{
  return nsp_bson_print(M,indent,name,rec_level);
}

%%
override-size Bson 

/*
 * size can be overriden here
 */

static int nsp_bson_size(NspBson *Mat, int flag)
{
  /* redirect the size value to Mat->value */
  return 0;
}

%%
override-print BsonXX
/*
 * print overriden 
 */

%%
override-equal BsonXX

/*
 * A == B 
 */

/*
 * A != B 
 */

%%
override mclient_create kwargs 

static int _wrap_mclient_create(Stack stack,int rhs,int opt,int lhs)
{
  return int_mclient_create(stack,rhs,opt,lhs);
}

%%
ignore

/*------------------------------------------------------------
 *  Definitions for the mongo_client 
 *------------------------------------------------------------*/

%%
override-intcreate Mclient

int int_mclient_create(Stack stack, int rhs, int opt, int lhs)
{
  char *uristr;
  mongoc_client_t *client;
  NspMclient *B;
  CheckStdRhs(1,1);
  if ((uristr = GetString(stack,1)) == (char*)0) return RET_BUG;
  /* want to be sure that type bvar is initialized */
  nsp_type_mclient = new_type_mclient(T_BASE);
  if (( client = mongoc_client_new (uristr)) == NULL) 
    {
      Scierror("Error: failed to parse uri %s\n",uristr);
      return RET_BUG;
    }
  if(( B = nsp_mclient_create(NVOID,(void *) client,(NspTypeBase *) nsp_type_mclient)) == NULL)
    {
      Scierror("Error: failed to create a mongodb client\n");
      return RET_BUG;
    }
  MoveObj(stack,1,(NspObject  *) B);
  return 1;
} 

%%
override-destroy-prelim  Mclient
  /* verbatim in destroy */
  mongoc_client_destroy(H->obj->cl);

%%
override Mclient.mongoc_client_get_collection kwargs

static int _wrap_mongoc_client_get_collection(NspMclient *self,Stack stack,int rhs,int opt,int lhs)
{
  NspMcollection *M;
  char *collection_name, *base_name;
  mongoc_collection_t *collection;
  CheckStdRhs(2,2);
  CheckLhs(0,1);
  if ((base_name = GetString(stack,1)) == (char*)0) return RET_BUG;
  if ((collection_name = GetString(stack,2)) == (char*)0) return RET_BUG;

  if ((collection = mongoc_client_get_collection(self->obj->cl,base_name,collection_name)) == NULL) 
    {
      Scierror("Error: failed to obtain collection %s in base %s\n",collection_name,base_name);
      return RET_BUG;
    }
  nsp_type_mcollection = new_type_mcollection(T_BASE);
  if(( M = nsp_mcollection_create(NVOID,(void *) collection,(NspTypeBase *) nsp_type_mcollection)) == NULL)
    {
      Scierror("Error: failed to create a NspMcollection\n");
      return RET_BUG;
    }
  MoveObj(stack,1,(NspObject  *) M);
  return 1;
}

%%
ignore

/*------------------------------------------------------------
 *  Definitions for the mongo_collections
 *  a collection object is created when we use the method 
 *  get_collection on a mongodb client 
 *------------------------------------------------------------*/

%%
override-destroy-prelim  Mcollection
  /* verbatim in destroy */
  mongoc_collection_destroy(H->obj->co);

%%
override Mcollection.mongoc_collection_find kwargs

static int _wrap_mongoc_collection_find(NspMcollection *self,Stack stack,int rhs,int opt,int lhs)
{
  NspMcursor *M;
  bson_error_t error;
  bson_t query;
  mongoc_cursor_t *cursor;
  CheckStdRhs(0,0);
  CheckLhs(0,1);
  bson_init (&query);
  cursor = mongoc_collection_find (self->obj->co,
				   MONGOC_QUERY_NONE,
				   0,
				   0,
				   0,
				   &query,
				   NULL,  /* Fields, NULL for all. */
				   NULL); /* Read Prefs, NULL for default */

   while (!mongoc_cursor_error (cursor, &error) &&
          mongoc_cursor_more (cursor)) 
     {
       const bson_t *doc;
       Sciprintf("while\n");
       if (mongoc_cursor_next (cursor, &doc)) 
	 {
	   char *str;
	   Sciprintf("XXXXXXXXXXX\n");
	   str = bson_as_json (doc, NULL);
	   Sciprintf("%s\n", str);
	   bson_free (str);
	 }
     }
   
   if (mongoc_cursor_error (cursor, &error)) 
     {
       Scierror("Error: cursor failure\n");
       return RET_BUG;
     }
   bson_destroy (&query); /* can we kill the query here ? */
   nsp_type_mcursor = new_type_mcursor(T_BASE);
   if(( M = nsp_mcursor_create(NVOID,(void *) cursor,(NspTypeBase *) nsp_type_mcursor)) == NULL)
     {
       Scierror("Error: failed to create a NspMcursor\n");
       return RET_BUG;
    }

  MoveObj(stack,1,(NspObject  *) M);
  return 1;
}


%%
override Mcollection.mongoc_collection_insert kwargs

static int _wrap_mongoc_collection_insert(NspMcollection *self,Stack stack,int rhs,int opt,int lhs)
{
  NspBson *B;
  bson_bool_t r;
  bson_error_t error;
  CheckStdRhs(1,1);
  CheckLhs(0,1);
  if ((B= GetBson(stack,1))== NULL) return RET_BUG;

  r = mongoc_collection_insert(self->obj->co, MONGOC_INSERT_NONE, B->obj->b, NULL, &error);
  if (!r && lhs != 1) 
    {
      Scierror("Error: %s\n", error.message);
      return RET_BUG;
    }
  if ( lhs == 1) 
    {
      if ( nsp_move_boolean(stack,1,r)==FAIL) return RET_BUG;
      return 1;
    }
  else
    return 0;
}


%%
ignore

/*------------------------------------------------------------
 *  Definitions for the mongo_cursor 
 *  a cursor object is created when we use the method 
 *  get_collection on a mongodb client 
 *------------------------------------------------------------*/

%%
override-destroy-prelim  Mcursor
  /* verbatim in destroy */
  mongoc_cursor_destroy(H->obj->cu);

%%
ignore

/*------------------------------------------------------------
 *  set of definitions inserted verbatim at the end
 *------------------------------------------------------------*/

%%
last

/* loop extraction for bson variable 
 * @str: name to give to created object 
 * @O: a #NspObject pointer to use to store extracted column or a NULL pointer 
 * @O1: a #NspObject from which we must extract columns
 * @i: undice of the column to be extracted 
 * @rep: returned error value.
 */

static NspObject *nsp_bson_loop(char *str, NspObject *O, NspObject *O1, int i, int *rep)
{
  /*
  NspBson *b = (NspBson *) O1;
  if (b->sym == TRUE)
    {
      Scierror("Error: loop cannot work for symbolic values\n");
      return NULLOBJ;
    }
  if ( O != NULL) 
    {
      b->value->type->loop(str,((NspBson *) O)->value,b->value,i,rep);
      if ((*rep == RET_ENDFOR))
	return NULLOBJ;
      else
	return O;
    }
  else
    {
      char *str1;
      NspObject *Res1;
      NspObject *Res= b->value->type->loop(str,O,b->value,i,rep);
      Res1 = (NspObject *) nsp_bson(Res,FALSE);
      if ((str1 = nsp_string_copy(str)) ==NULL) return NULLOBJ;
      free(((NspBson *) Res1)->varname);
      ((NspBson *) Res1)->varname=str1;
      if (nsp_object_set_name(Res1,str) == FAIL) return NULLOBJ;
      nsp_object_destroy(&Res);
      return Res1;
    }
  */
  return NULL;
}


static int nsp_bson_is_true(void *Obj)
{
  /*
  NspBson *b = (NspBson *) Obj;
  if ( b->sym == TRUE ) 
    {
      Scierror("Error: do not use symbolic variables in conditions (if, while,case) \n");
      return FALSE;
    }
  else
    {
      return  NSP_OBJECT(b->value)->type->is_true(b->value);
    }
  */
  return FALSE;
}

static int nsp_bson_insert(bson_t *b,const char *name, NspObject* Obj)
{
  NspMatrix *M =  (NspMatrix *) Obj;
  if (IsMat(Obj) &&  M->rc_type == 'r' )
    {
      NspMatrix *M =  (NspMatrix *) Obj;
      if ( M->mn == 1)
	{
	  bson_append_double(b, name, -1, M->R[0]);
	}
      else
	{
	  
	}
    }
  else if (IsBMat(Obj) ) 
    {
      NspBMatrix *M =  (NspBMatrix *) Obj;
      if ( M->mn == 1)
	{
	  bson_append_bool(b, name, -1, M->B[0]);
	}
      else
	{
	  
	}
    }
  else if (IsSMat(Obj) ) 
    {
      NspSMatrix *S =  (NspSMatrix *) Obj;
      if ( nsp_smatrix_utf8_validate(S) == FALSE )
	{
	  /* Copy the matrix XXXXXX */
	  if ( nsp_smatrix_to_utf8(S) == FAIL) 
	    {
	      Scierror("Error: expecting utf8 strings in bson_append_string\n");
	      return FAIL;
	    }
	}
      if ( S->mn == 1)
	{
	  bson_append_utf8(b, name, -1, S->S[0],-1);
	}
      else
	{
	  
	}
    }
  return FAIL;
}


static void bson_show(void *self)
{
  const char *key;
  NspBson *B= self;
  bson_t * b = B->obj->b;
  bson_iter_t iter;
  bson_iter_init(&iter, b);
  while (1) 
    {
      if ( bson_iter_next(&iter) == FALSE ) return ;
      key =bson_iter_key(&iter);
       switch (bson_iter_type_unsafe (&iter)) {
       case BSON_TYPE_EOD: 
	 break;
       case BSON_TYPE_DOUBLE:
	 Sciprintf("Key %s=%f\n",key, bson_iter_double(&iter));
	 break;
       case BSON_TYPE_UTF8:
	 {
	   bson_uint32_t len = 0;
	   Sciprintf("Key %s=%s\n",key, bson_iter_utf8(&iter,&len));
	 }
	 break;
       case BSON_TYPE_DOCUMENT:
	 break;
       case BSON_TYPE_ARRAY:
	 break;
       case BSON_TYPE_BINARY:
	 break;
       case BSON_TYPE_UNDEFINED:
	 break;
       case BSON_TYPE_OID:
	 break;
       case BSON_TYPE_BOOL:
	 Sciprintf("Key %s=%d\n",key, bson_iter_bool(&iter));
	 break;
       case BSON_TYPE_DATE_TIME:
	 break;
       case BSON_TYPE_NULL:
	 break;
       case BSON_TYPE_REGEX:
	 break;
       case BSON_TYPE_DBPOINTER:
	 break;
       case BSON_TYPE_CODE:
	 break;
       case BSON_TYPE_SYMBOL:
	 break;
       case BSON_TYPE_CODEWSCOPE:
	 break;
       case BSON_TYPE_INT32:
	 break;
       case BSON_TYPE_TIMESTAMP:
	 break;
       case BSON_TYPE_INT64:
	 break;
       case BSON_TYPE_MAXKEY:
	 break;
       case BSON_TYPE_MINKEY:
	 break;
       default:
	 break;
       }
    }
}

static NspHash *bson_to_hash(void *self)
{
  const char *key;
  NspBson *B= self;
  bson_t * b = B->obj->b;
  bson_iter_t iter;
  NspHash *H;
  NspObject *O;
  if(( H = nsp_hash_create(NVOID,10)) == NULLHASH) return NULLHASH;
  bson_iter_init(&iter, b);
  while (1) 
    {
      if ( bson_iter_next(&iter) == FALSE ) break;

      key =bson_iter_key(&iter);
      switch (bson_iter_type_unsafe (&iter)) 
	{
	case BSON_TYPE_EOD: 
	  break;
	case BSON_TYPE_DOUBLE:
	  if (( O =  (NspObject *) nsp_create_object_from_double(key,bson_iter_double(&iter))) == NULLOBJ ) 
	    return  NULLHASH;
	  if (nsp_hash_enter(H,O) == FAIL) return NULLHASH;
	  break;
	case BSON_TYPE_UTF8:
	  {
	    bson_uint32_t len = 0;
	    NspSMatrix *Loc;
	    if ( ( Loc =nsp_smatrix_create_with_length(key,1,1,-1) ) == NULLSMAT) 
	      return NULLHASH;
	    if ((Loc->S[0] =nsp_string_copy( bson_iter_utf8(&iter,&len))) == (nsp_string) 0) 
	      return NULLHASH;
	    if (nsp_hash_enter(H,NSP_OBJECT(Loc)) == FAIL)
	      return NULLHASH;
	  }
	  break;
	case BSON_TYPE_DOCUMENT:
	  break;
	case BSON_TYPE_ARRAY:
	  break;
	case BSON_TYPE_BINARY:
	  break;
	case BSON_TYPE_UNDEFINED:
	  break;
	case BSON_TYPE_OID:
	  break;
	case BSON_TYPE_BOOL:
	  if (( O =  (NspObject *) nsp_create_boolean_object(key, bson_iter_bool(&iter))) == NULLOBJ ) 
	    return  NULLHASH;
	  if (nsp_hash_enter(H,O) == FAIL) return NULLHASH;
	  break;
	  break;
	case BSON_TYPE_DATE_TIME:
	  break;
	case BSON_TYPE_NULL:
	  break;
	case BSON_TYPE_REGEX:
	  break;
	case BSON_TYPE_DBPOINTER:
	  break;
	case BSON_TYPE_CODE:
	  break;
	case BSON_TYPE_SYMBOL:
	  break;
	case BSON_TYPE_CODEWSCOPE:
	  break;
	case BSON_TYPE_INT32:
	  break;
	case BSON_TYPE_TIMESTAMP:
	  break;
	case BSON_TYPE_INT64:
	  break;
	case BSON_TYPE_MAXKEY:
	  break;
	case BSON_TYPE_MINKEY:
	  break;
	default:
	  break;
	}
    }
  return H;
}

