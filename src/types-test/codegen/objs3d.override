/* -*- Mode: C -*- */
%%
headers
#include <nsp/figure.h>
#include <nsp/curve.h>
#include <nsp/polyhedron.h>
#include "../graphics/Plo3dObj.h"


extern BCG *nsp_check_graphic_context(void);
extern void store_graphic_object(BCG *Xgc,NspObject *obj);
static void nsp_draw_objs3d(BCG *Xgc,NspGraphic *Obj, void *data);
static void nsp_translate_objs3d(BCG *Xgc,NspGraphic *o,double *tr);
static void nsp_rotate_objs3d(BCG *Xgc,NspGraphic *o,double *R);
static void nsp_scale_objs3d(BCG *Xgc,NspGraphic *o,double *alpha);
static void nsp_getbounds_objs3d(BCG *Xgc,NspGraphic *o,double *bounds);
static void nsp_objs3d_compute_inside_bounds(BCG *Xgc,NspGraphic *Obj,double *bounds);
static void nsp_objs3d_link_figure(NspGraphic *G, void *F);
static void nsp_objs3d_unlink_figure(NspGraphic *G, void *F);
static NspList *nsp_objs3d_children(NspGraphic *Obj);

/* should be inserted in figure.h */

extern void nsp_list_link_figure(NspList *L, NspFigure *F);
extern void nsp_list_unlink_figure(NspList *L, NspFigure *F);
extern int nsp_list_check_figure(NspList *L, NspFigure *F);
extern void nsp_graphic_link_figure(NspGraphic *G, void *F);
extern void nsp_graphic_unlink_figure(NspGraphic *G, void *F);
extern void nsp_figure_force_redraw( NspFigure *F);

#ifdef  WITH_GTKGLEXT 
extern Gengine GL_gengine;
#endif 

%%
init 

Init portion 

%%
override_type Objs3d
  /* inserted verbatim in the type definition */
  ((NspTypeGraphic *) type->surtype)->draw = nsp_draw_objs3d;
  ((NspTypeGraphic *) type->surtype)->translate =nsp_translate_objs3d ;
  ((NspTypeGraphic *) type->surtype)->rotate =nsp_rotate_objs3d  ;
  ((NspTypeGraphic *) type->surtype)->scale =nsp_scale_objs3d  ;
  ((NspTypeGraphic *) type->surtype)->bounds =nsp_getbounds_objs3d  ;
  ((NspTypeGraphic *) type->surtype)->full_copy = (full_copy_func *) nsp_objs3d_full_copy ;
  ((NspTypeGraphic *) type->surtype)->link_figure = nsp_objs3d_link_figure; 
  ((NspTypeGraphic *) type->surtype)->unlink_figure = nsp_objs3d_unlink_figure; 
  ((NspTypeGraphic *) type->surtype)->children = (children_func *) nsp_objs3d_children ;
%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type

%%
override objs3d_attach kwargs
int _wrap_objs3d_attach(Stack stack, int rhs, int opt, int lhs)
{
  NspObject  *pl = NULL;
  BCG *Xgc;
  int_types T[] = {obj, t_end} ;
  if ( GetArgs(stack,rhs,opt,T,&pl) == FAIL) return RET_BUG;
  Xgc=nsp_check_graphic_context();
  store_graphic_object(Xgc, pl);
  return 0;
}

%%
override umfpack_action_do_action

static int _wrap_kiko_action_do_action(NspKiko *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int i, ret;

  if ( GetArgs(stack,rhs,opt,T,&i) == FAIL) return RET_BUG;
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

%%
override-attr alpha 
/* override set alpha */
static int _wrap_objs3d_set_alpha(void *self, char *attr, NspObject *O)
{
  double alpha;
  if ( DoubleScalar(O,&alpha) == FAIL) return FAIL;

  if ( ((NspObjs3d *) self)->obj->alpha != alpha) 
    {
      ((NspObjs3d *) self)->obj->alpha = alpha;
      nsp_figure_force_redraw(((NspGraphic *) self)->obj->Fig);
    }
  return OK;
}

%%
override-attr children

/* here we override get_obj  and set_obj 
 * we want get to be followed by a set to check that 
 * inserted value is correct thus we use copy = TRUE.
 */

static NspObject *_wrap_objs3d_get_obj_children(void *self,char *attr, int *copy)
{
  NspList *ret;
  *copy = TRUE; 
  ret = ((NspList*) ((NspObjs3d *) self)->obj->children);
  return (NspObject *) ret;
}

/* in this function we can check that val is correct before 
 * setting the field with val. return FAIL if val is incorrect.
 */

static int _wrap_objs3d_set_obj_children(void *self,NspObject *val)
{
  double inside_bounds[4];
  if ( ! IsList(val) ) return FAIL;
  if ( nsp_list_check_figure((NspList *) val, ((NspGraphic *) self)->obj->Fig) == FAIL) return FAIL;
  if (((NspObjs3d *) self)->obj->children != NULL ) 
    {
      if ( ((NspGraphic *) self)->obj->Fig != NULL) 
	nsp_list_unlink_figure(((NspObjs3d *) self)->obj->children,((NspGraphic *) self)->obj->Fig);
      nsp_list_destroy(((NspObjs3d *) self)->obj->children);
    }
  ((NspObjs3d *) self)->obj->children =  (NspList *) val;
  nsp_objs3d_compute_inside_bounds(NULL,self,inside_bounds);
  if ( ((NspGraphic *) self)->obj->Fig != NULL) 
    nsp_list_link_figure((NspList *) val,((NspGraphic *) self)->obj->Fig);
  return OK;
}

static int _wrap_objs3d_set_children(void *self, char *attr, NspObject *O)
{
  double inside_bounds[4];
  NspList *children;
  if ( ! IsList(O) ) return FAIL;
  if ((children = (NspList *) nsp_object_copy_and_name(attr,O)) == NULLLIST) return FAIL;
  if (((NspObjs3d *) self)->obj->children != NULL ) 
    {
      if ( ((NspGraphic *) self)->obj->Fig != NULL) 
	nsp_list_unlink_figure(((NspObjs3d *) self)->obj->children,((NspGraphic *) self)->obj->Fig);
      nsp_list_destroy(((NspObjs3d *) self)->obj->children);
    }
  ((NspObjs3d *) self)->obj->children= children;
  nsp_objs3d_compute_inside_bounds(NULL,self,inside_bounds);
  if ( ((NspGraphic *) self)->obj->Fig != NULL) 
    nsp_list_link_figure((NspList *) O,((NspGraphic *) self)->obj->Fig);
  return OK;
}


%%
override nsp_extractelts_objs3d kwargs

extern function int_nspgraphic_extract;

int _wrap_nsp_extractelts_objs3d(Stack stack, int rhs, int opt, int lhs) 
{
  return int_nspgraphic_extract(stack,rhs,opt,lhs);
}

%%
override nsp_setrowscols_objs3d kwargs

extern function int_graphic_set_attribute;

int _wrap_nsp_setrowscols_objs3d(Stack stack, int rhs, int opt, int lhs) 
{
  return int_graphic_set_attribute(stack,rhs,opt,lhs);
}

%%
last

/* inserted verbatim at the end */
extern void nsp_axes_update_frame_bounds(BCG *Xgc,double *wrect,double *frect,double *arect,
					 int *aaint,int isomode, int auto_axes, char *xf);
extern Plot3dBox* make_box(BCG *Xgc,double Box[], GBoolean with_ticks, BoxStyle box_style,int box_color, double lim[]);
extern void apply_transforms(BCG *Xgc,double Coord[],const double *M, VisionPos pos[],const double lim[], int ncoord);
extern void nsp_obj3d_dsortc(double x[], int *n, int p[]);
extern void nsp_obj3d_draw_box(BCG *Xgc,Plot3dBox *B);
extern void nsp_obj3d_draw_near_box_segments(BCG *Xgc,Plot3dBox *B);
extern void nsp_obj3d_free_box(Plot3dBox *B);
static void nsp_draw_objs3d_s2( BCG *Xgc,NspObjs3d *Obj,double theta,double alpha,const char *legend,
				int *flag,double *ebox,int with_mesh1,int with_box,int box_color,int box_style);

static void nsp_draw_objs3d(BCG *Xgc,NspGraphic *Obj, void *data)
{
  char xf[]="onn";
  char strflag[]="151";
  double WRect[4],*wrect1,WRect1[4], FRect[4], ARect[4], inside_bounds[4];
  char logscale[2];
  int aaint[4]={10,2,10,2};
  Cell *cloc;
  NspList *L;
  NspObjs3d *P = (NspObjs3d *) Obj;
  if ( ((NspGraphic *) P)->obj->hidden == TRUE ) return;
  /* draw elements */
  L = P->obj->children;
  cloc = L->first ;
  /* we change the scale according to the objs3d */
  getscale2d(Xgc,WRect,FRect,logscale,ARect);
  if ( P->obj->top == TRUE ) 
    {
      /* This is a top level objs3d, wrect gives the objs3d position in the 
       * enclosing graphic window. 
       */
      set_scale(Xgc,"fTffft",P->obj->wrect->R,NULL,NULL,NULL,P->obj->arect->R);
      wrect1= P->obj->wrect->R;
    }
  else 
    {
      /* This is not a top level objs3d, we draw its enclosing rectangle 
       * if alpha is non nul we should draw a rotated rectangle
       */
      Xgc->graphic_engine->scale->drawrectangle(Xgc,P->obj->wrect->R);
      /* wrect->R is [left,up,w,h] 
       * we need to compute wrect->R in term on window/proportions 
       */
      WRect1[0]= ARect[0]+(1-ARect[0]-ARect[2])*(P->obj->wrect->R[0]-FRect[0])/(FRect[2]-FRect[0]);
      WRect1[1]= ARect[1]+(1-ARect[1]-ARect[3])*(1- (P->obj->wrect->R[1]-FRect[1])/(FRect[3]-FRect[1]));
      WRect1[2]= (1-ARect[0]-ARect[2])*(P->obj->wrect->R[2])/(FRect[2]-FRect[0]);
      WRect1[3]= (1-ARect[1]-ARect[3])*(P->obj->wrect->R[3])/(FRect[3]-FRect[1]);
      wrect1 = WRect1;
      Xgc->scales->cosa= cos( P->obj->alpha);
      Xgc->scales->sina= sin( P->obj->alpha);
    }
  /* we directly change the default scale because we do not want 
   * to register all the scales that will be generated by set_scale 
   * thus we use T in flag[1].
   */
  /* set_scale(Xgc,"fTtfff",WRect1,P->obj->frect->R,NULL,NULL,NULL); */
  nsp_objs3d_compute_inside_bounds(Xgc,Obj,inside_bounds);
  nsp_axes_update_frame_bounds(Xgc,wrect1,
			       TRUE ? inside_bounds : P->obj->frect->R,
			       P->obj->arect->R,
			       aaint,
			       TRUE,
			       TRUE,
			       xf);
  axis_draw(Xgc,strflag);
  frame_clip_on(Xgc);
  {
    int flag[]={1,2,4};
    double ebox[]={0,6,0,6,-1,1};
    double theta = 35, alpha=45;
    char legend[]="X@Y@Z";
    nsp_draw_objs3d_s2(Xgc,(NspObjs3d *)Obj,theta,alpha,legend,flag,ebox,TRUE,TRUE,3,1);
  }
  /* Note that clipping is wrong when an axe is rotated 
   * since clipping only works with rectangles 
   */
  frame_clip_off(Xgc);
  /* title if present */
  if ( P->obj->title[0] != '\0') 
    Xgc->graphic_engine->scale->displaystringa(Xgc,P->obj->title,1);
  if ( P->obj->x[0] != '\0') 
    Xgc->graphic_engine->scale->displaystringa(Xgc,P->obj->x,2);
  if ( P->obj->y[0] != '\0') 
    Xgc->graphic_engine->scale->displaystringa(Xgc,P->obj->y,3);
  
  /* scale back */
  set_scale(Xgc,"fTtfft",WRect,FRect,NULL,NULL,ARect);
  if (  P->obj->top != TRUE )
    {
      Xgc->scales->cosa=1.0;
      Xgc->scales->sina=0.0;
    }
}



/* compute the bounds of the set of objects countained in the 
 * objs3d 
 */

static void nsp_objs3d_compute_inside_bounds(BCG *Xgc,NspGraphic *Obj,double *bounds)
{
  double l_bounds[4];
  Cell *cloc;
  NspList *L;
  NspObjs3d *P = (NspObjs3d *) Obj;
  L = P->obj->children;
  cloc = L->first ;
  
  if ( cloc == NULLCELL) 
    {
      bounds[0]=bounds[1]=0;
      bounds[2]=bounds[3]=0;
      return;
    }
  
  bounds[0]=bounds[1]=LARGEST_REAL;
  bounds[2]=bounds[3]=-LARGEST_REAL;

  while ( cloc != NULLCELL ) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  NspGraphic *G= (NspGraphic *) cloc->O;
	  G->type->bounds(Xgc,G,l_bounds);
	  if ( l_bounds[0] < bounds[0] ) 
	    bounds[0]= l_bounds[0];
	  if (  l_bounds[2] > bounds[2])
	    bounds[2]= l_bounds[2];
	  if ( l_bounds[1] < bounds[1] ) 
	    bounds[1]= l_bounds[1];
	  if (  l_bounds[3] > bounds[3])
	    bounds[3]= l_bounds[3];
	}
      cloc = cloc->next;
    }
}

static void nsp_translate_objs3d(BCG *Xgc,NspGraphic *Obj,double *tr)
{
  NspObjs3d *P = (NspObjs3d *) Obj;
  if ( P->obj->top == TRUE) return ;
  P->obj->wrect->R[0] += tr[0];
  P->obj->wrect->R[1] += tr[1];
  nsp_figure_force_redraw(Obj->obj->Fig);

}

static void nsp_rotate_objs3d(BCG *Xgc,NspGraphic *Obj,double *R)
{
  NspObjs3d *P = (NspObjs3d *) Obj;
  if ( P->obj->top == TRUE) return ;
  Sciprintf("we should get a double here for alpha\n");
  nsp_figure_force_redraw(Obj->obj->Fig);
}

static void nsp_scale_objs3d(BCG *Xgc,NspGraphic *Obj,double *alpha)
{
  NspObjs3d *P = (NspObjs3d *) Obj;
  if ( P->obj->top == TRUE) return ;
  P->obj->wrect->R[2] *= alpha[0];
  P->obj->wrect->R[3] *= alpha[1];
  nsp_figure_force_redraw(Obj->obj->Fig);
}

/* compute in bounds the enclosing rectangle of objs3d 
 *
 */

static void nsp_getbounds_objs3d(BCG *Xgc,NspGraphic *Obj,double *bounds)
{
  NspObjs3d *P = (NspObjs3d *) Obj;
  if ( P->obj->top == TRUE) return ;
  /* get the bound in parent i.e given by wrect : upper-left w,h */
  bounds[0]=P->obj->wrect->R[0]; /* xmin */
  bounds[1]=P->obj->wrect->R[1]-P->obj->wrect->R[3];/* ymin */
  bounds[2]=P->obj->wrect->R[0]+P->obj->wrect->R[2];/* xmax */
  bounds[3]=P->obj->wrect->R[1];/* ymax */
}




static void nsp_objs3d_link_figure(NspGraphic *G, void *F)
{
  /* link toplevel */
  nsp_graphic_link_figure(G,F);
  /* link children */
  nsp_list_link_figure(((NspObjs3d *) G)->obj->children,F);
}


static void nsp_objs3d_unlink_figure(NspGraphic *G, void *F)
{
  /* link toplevel */
  nsp_graphic_unlink_figure(G,F);
  /* link children */
  nsp_list_unlink_figure(((NspObjs3d *) G)->obj->children,F);
}

static NspList *nsp_objs3d_children(NspGraphic *Obj)
{
  return  ((NspObjs3d *) Obj)->obj->children;
}


static void nsp_draw_3d_obj_ogl( BCG *Xgc,NspObjs3d *,double theta,double alpha,const char *legend,
				 int *flag,double *ebox,int with_mesh1,int with_box,int box_color,int box_style);

static void nsp_draw_objs3d_s2( BCG *Xgc,NspObjs3d *Obj,double theta,double alpha,const char *legend,
				int *flag,double *ebox,int with_mesh1,int with_box,int box_color,int box_style)
{
  NspObject **objs_array= NULL;
  Cell *cloc;
  NspList *Children;
  nsp_box_3d box;
  double x[2],y[2],zz[2],zzmin,zzmax;
  int two=2;
  double Box[6]={ebox[0],ebox[2],ebox[4],ebox[1],ebox[3],ebox[5]};
  int nf=0,nbObj;
  int i, j, k, n, *p;
  HFstruct *HF;
  double lim[3], *z;
  Plot3dBox *B=NULL;
  int flagx;
  /* should be shared */
  int foreground_color;
  int background_color;
  int with_mesh;

#ifdef WITH_GTKGLEXT 
  if ( Xgc->graphic_engine == &GL_gengine ) 
    {
      nsp_draw_3d_obj_ogl(Xgc,Obj,theta,alpha,legend,flag,ebox,with_mesh1,with_box,box_color,box_style);
      nsp_ogl_set_2dview(Xgc);
      return; 
    }
#endif
    
  flagx = Xgc->graphic_engine->xget_last(Xgc);
  /* XXX */
  foreground_color = flagx+1;
  background_color = flagx+2;
  with_mesh = with_mesh1; 

  /* allocate a structure for drawing purpose 
   * The unchanged values are kept in Lobj
   */

  /* Obj = (Obj3d *)obj3d_from_list(SciStack,Lobj,TRUE,&err,&nf,&nbObj) ; */
  Children = nsp_objs3d_children((NspGraphic *) Obj);
  nbObj = nsp_list_length(Children);
  /* we have to loop here to collect the number of faces */
  cloc = Children->first ;
  nf = 0;
  while ( cloc != NULLCELL ) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  /* we assume here that we only have polyhedron inside */
	  if ( IsPolyhedron(cloc->O)) 
	    {
	      NspPolyhedron *P= (NspPolyhedron *) cloc->O;
	      nf += P->obj->Mface->n;
	    }
	}
      cloc = cloc->next;
    }

  x[0]= Box[0];y[0]= Box[1];zz[0]= Box[2];
  x[1]= Box[3];y[1]= Box[4];zz[1]= Box[5];
  
  nsp_plot3d_update_bounds(Xgc,"box",x,y,zz,&two,&two,&theta,&alpha,legend,&flag[1],
			   ebox,&zzmin,&zzmax,param3d_t);
  SetEch3d1(Xgc,&box,ebox,theta,alpha,(long)(flag[1]+1)/2);

#ifdef WITH_GTKGLEXT 
  /* transmit info to opengl pretending we are doing 2d !!! */
  if ( Xgc->graphic_engine == &GL_gengine ) 
    {
      nsp_ogl_set_2dview(Xgc);
    }
#endif
  
  lim[0] = 1.e+10;
  lim[1] = 1.e+10;
  lim[2] = - 1.e+10;

  /* fabrication de la boite et calcul de ses coordonnees ds le repere local */
  if ( with_box == TRUE ) B = make_box(Xgc,Box, BTRUE, box_style,box_color, lim);
  
  HF= malloc( nf * sizeof(HFstruct) );
  z = malloc( nf * sizeof(double) );
  p = malloc( nf * sizeof(int) );

  /* just to accelerate next step */
  objs_array = malloc( nbObj*sizeof(NspObject *));
  cloc = Children->first ;
  n=0;
  while ( cloc != NULLCELL ) 
    {
      if ( cloc->O != NULLOBJ && IsPolyhedron(cloc->O))
	{
	  objs_array[n++]= cloc->O; 
	}
      cloc = cloc->next;
    }
  
  /* step 1 : for each object :
   *            a/ get the coordinates in the local repair
   *               and determines the pos of each point within the pyramidal
   *               visible region (IN, OUT_XY, OUT_Z)
   *            b/ then add the visible parts (faces, segments, points) in the z 
   *               and HF arrays for the hidden face algorithm (only partial visible 
   *               parts without any OUT_Z point are included)
   */
  n = 0;k=0;
  cloc = Children->first ;
  nf = 0;
  while ( cloc != NULLCELL ) 
    {
      if ( cloc->O != NULLOBJ && IsPolyhedron(cloc->O))
	{
	  nsp_polyhedron *Q= ((NspPolyhedron *) cloc->O)->obj;
	  nsp_check_polyhedron((NspPolyhedron *) cloc->O);
	  apply_transforms(Xgc,((NspMatrix *)Q->Mcoord_l)->R,Q->Mcoord->R,Q->pos, lim, Q->Mcoord->n);
	  zmean_faces_for_Polyhedron(cloc->O, z, HF, &n, k);
	  k++;
	}
      cloc = cloc->next;
    }
  /*  step 3 : sort of all the a priori visible "faces" (faces, segments, points) */
  nsp_obj3d_dsortc(z, &n, p);

  /* step 4 : drawing of each faces */
  if ( with_box == TRUE  ) nsp_obj3d_draw_box(Xgc,B);

  for (i = n -1 ; i >= 0 ; i--)
    {
      k = HF[p[i]].num_obj;  /* numero de l'objet correspondant a cette "face" */
      j = HF[p[i]].num_in_obj; /* son numéro de face dans l'objet en question */
      /* dessin partiel de l'objet en utilisant la face j */
      /* XXX OBJ3D(Obj[k].obj)->draw_partial(Xgc,Obj[k].obj,j); */
      ((NspGraphic *) objs_array[k])->type->draw(Xgc,(NspGraphic *) objs_array[k],&j);
    }
  if ( with_box == TRUE  &&  B->box_style == SCILAB )  nsp_obj3d_draw_near_box_segments(Xgc,B);
  if ( with_box == TRUE ) nsp_obj3d_free_box(B);
  free(HF);
  free(z);
  free(p);
}

#ifdef  WITH_GTKGLEXT 

static void nsp_draw_3d_obj_ogl( BCG *Xgc,NspObjs3d *Obj,double theta,double alpha,const char *legend,
				 int *flag,double *ebox,int with_mesh1,int with_box,int box_color,int box_style)
{
  Cell *cloc;
  NspList *Children;
  /* Stack stack;*/ /* just used for messages i.e NspFname(stack) */
  nsp_box_3d box;
  double x[2],y[2],zz[2],zzmin,zzmax;
  double Box[6]={ebox[0],ebox[2],ebox[4],ebox[1],ebox[3],ebox[5]};
  int flagx, nf=0, two=2;
  double lim[3];
  Plot3dBox *B;
  /* should be shared */
  int foreground_color;
  int background_color;
  int with_mesh;

  /* NspFname(stack) ="drawobj"; */
  flagx = Xgc->graphic_engine->xget_last(Xgc);
  foreground_color = flagx+1;
  background_color = flagx+2;
  with_mesh = with_mesh1; 

  /* allocate a structure for drawing purpose 
   * The unchanged values are kept in Lobj
   */
  
  x[0]= Box[0];y[0]= Box[1];zz[0]= Box[2];
  x[1]= Box[3];y[1]= Box[4];zz[1]= Box[5];

  nsp_plot3d_update_bounds(Xgc,"box",x,y,zz,&two,&two,&theta,&alpha,legend,&flag[1],
			   ebox,&zzmin,&zzmax,param3d_t);
  SetEch3d1(Xgc,&box,ebox,theta,alpha,(long)(flag[1]+1)/2);
  
  lim[0] = 1.e+10;
  lim[1] = 1.e+10;
  lim[2] = - 1.e+10;

  /* fabrication de la boite et calcul de ses coordonnees ds le repere local */
  if ( with_box == TRUE  )
    {
      B = make_box(Xgc,Box, BTRUE, box_style,box_color,lim);
      nsp_obj3d_draw_box(Xgc,B);
      if (B->box_style == SCILAB ) nsp_obj3d_draw_near_box_segments(Xgc,B);
      nsp_obj3d_free_box(B);
    }

  Children = nsp_objs3d_children((NspGraphic *) Obj);
  cloc = Children->first ;
  nf = 0;
  while ( cloc != NULLCELL ) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  NspGraphic *G= (NspGraphic *) cloc->O;
	  G->type->draw(Xgc,G,NULL);
	}
      cloc = cloc->next;
    }
}
#endif 

