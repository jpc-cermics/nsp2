/* -*- Mode: C -*- */
%%
include-start Agraph

%%
include-public Agraph
/* inserted at the end of public part of include file
 */
#include <gvc.h> 
#include <nsp/agraph-nsp.h>

%%
include-private Agraph

/* graph methods */

static int nsp_agraph_fill_from_b(Agraph_t *g, NspBMatrix *B);

#define nsp_agnnodes(G) agnnodes((G)->obj->graph)
#define nsp_agnedges(G) agnedges((G)->obj->graph)

static NspAgraph *nsp_agparent(NspAgraph * G);
static NspAgraph *nsp_agroot(NspAgraph * G);

static int nsp_gv_write(NspAgraph * g,void *chan);
static int nsp_gv_render(NspAgraph *G, char *mode, char *filename);
static int nsp_gv_layout(NspAgraph *G, char *mode);

static NspSMatrix *nsp_gv_nodeattrs(NspAgraph * g);
static NspSMatrix *nsp_gv_edgeattrs(NspAgraph * g);
static NspSMatrix *nsp_gv_graphattrs(NspAgraph * g);

static NspAgedge *nsp_gv_agfstout(NspAgraph * g, NspAgnode *n);
static NspAgedge *nsp_gv_agnxtout(NspAgraph * g, NspAgedge *e);
static NspAgedge *nsp_gv_agfstin(NspAgraph * g, NspAgnode *n);
static NspAgedge *nsp_gv_agnxtin(NspAgraph * g, NspAgedge *e);
static NspAgedge *nsp_gv_agfstedge(NspAgraph * g, NspAgnode *n);
static NspAgedge *nsp_gv_agnxtedge(NspAgraph * g, NspAgedge *e, NspAgnode *n);
static int _wrap_nsp_gv_agset_gen(void *obj,Stack stack,int rhs,int opt,int lhs);

/* graph methods related to subgraphs */

static NspAgraph *nsp_agsubg(NspAgraph * g, char *name);
static NspAgraph *nsp_agfstsubg(NspAgraph * G);
static NspAgraph *nsp_agnxtsubg(NspAgraph * G);
static int nsp_agdelsubg(NspAgraph * G,NspAgraph * Gsub);

/* graph methods related to nodes */

static NspAgnode *nsp_agfstnode(NspAgraph * g);
static NspAgnode *nsp_aglstnode(NspAgraph * g);
static NspAgnode *nsp_agnxtnode(NspAgraph * g, NspAgnode *n);
static NspAgnode *nsp_agprvnode(NspAgraph * g, NspAgnode *n);
static int nsp_agaddnodes(NspAgraph *G, NspSMatrix *S);
static int nsp_agaddedges(NspAgraph *G, NspSMatrix *S);
static NspAgnode *nsp_agfindnode_by_name(NspAgraph * g, char *name);

/* common */

static char *nsp_agnameof_g(NspAgraph * G);
static char *nsp_agnameof_n(NspAgnode * N);
static char *nsp_agnameof_e(NspAgedge * E);

/* node methods */

static NspAgraph *nsp_agraphof(NspAgnode * N);

/* edge methods */

static NspAgnode *nsp_agtail(NspAgedge* E);
static NspAgnode *nsp_aghead(NspAgedge* E);

%%
headers
/* headers */

%%
init 
/ * init code  * /

%%
modulename atk
/* %%  import gobject.GObject as GObject */

%%
ignore-glob
  *_get_type

%%
override-intcreate Agraph

/* describing the type of graph to be created. 
 * A graph can be directed or undirected. In addition, a graph can
 * be strict, i.e., have at most one edge between any pair of nodes, 
 * or non-strict, allowing an arbitrary number
 * of edges between two nodes. 
 Agundirected: Non-strict, undirected graph
 Agstrictundirected: Strict, undirected graph
 Agdirected: Non-strict, directed graph
 Agstrictdirected: Strict, directed graph
*/

int int_agraph_create(Stack stack, int rhs, int opt, int lhs)
{
  Agraph_t *g;
  NspAgraph *H;
  char *name = "G";
  char *type = "graph";
  nsp_option opts[] ={{ "type",string,NULLOBJ,-1},
		      { "name",string,NULLOBJ,-1},
		      { NULL,t_end,NULLOBJ,-1}};
  int rep;
  Agdesc_t itype = Agundirected;
  const char *t_choices[]={ "graph", "graphstrict","digraph","digraphstrict",  NULL };
  Agdesc_t t_itype[]={ Agundirected,Agstrictundirected, Agdirected , Agstrictdirected};
  CheckStdRhs(0,1);
  /* aginit(); can be called multiple times */
  if ( get_optional_args(stack,rhs,opt,opts,&type,&name) == FAIL) 
    return RET_BUG;
  rep = is_string_in_array(type, t_choices, 1);
  if ( rep < 0 )
    {
      string_not_in_array(stack, type, t_choices, "optional argument type");
      return RET_BUG;
    }
  itype = t_itype[rep];
  if (( g = agopen(name,itype,0))== NULL) 
    {
      Scierror("Error: agopen failed to create a graph\n");
      return RET_BUG;
    }
  if ( rhs -opt == 1)
    {
      NspBMatrix *B;
      if (( B = GetBMat(stack,1)) == NULLBMAT) return RET_BUG;
      if ( B->m != B->n ) 
	{
	  Scierror("Error: first argument should be a square matrix\n");
	  return RET_BUG;
	}
      itype= Agdirected;
      if ( nsp_agraph_fill_from_b(g, B) == FAIL) 
	{
	  Scierror("Error: failed to fill graph with data\n");
	  return RET_BUG;
	}
    }

  if ((H = nsp_agraph_create(NVOID,g, NULL)) == NULL) 
    {
      Scierror("Error: failed to create a graph\n");
      return RET_BUG;
    }
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 


%%
override-destroy-prelim  Agraph
   /* verbatim in destroy */
/* agclose(H->obj->graph); */
   
%%
override nsp_gv_gattr kwargs

/* generic function used to set a graph attribute */

static int _wrap_nsp_gv_gattr_gen(NspAgraph *self,Stack stack,int rhs,int opt,int lhs,
				  int itype,const char *type)
{
  Agsym_t *a = NULL;
  int i;
  CheckStdRhs(0,0);
  CheckLhs(0,1);
  for ( i = 1 ; i <= rhs ; i++) 
    {
      char *value,*agstr;
      const char *attr;
      NspObject *O;
      if ( Ocheckname(NthObj(i),NVOID) ) 
	{
	  Scierror("Error: %s of method %s should be a named optional argument \n",
		   ArgPosition(i),NspFname(stack));
	  return RET_BUG;
	}
      /* A copy of object is added in the hash table **/
      /* GetObj takes care of Hobj pointers **/
      attr = nsp_object_get_name(NthObj(i));
      O = nsp_get_object(stack,i);
      if ( IsString(O) == FALSE )
	{
	  Scierror("Error: %s of method  %s should be a string\n",
		   ArgPosition(i),NspFname(stack));
	  return RET_BUG;
	}
      value =  ((NspSMatrix *) O)->S[0];
      agstr = nsp_string_copy(attr);
      if ( agstr == NULL) return RET_BUG;
      a = agattr( ((Agraph_t *) self->obj->graph)->root,itype, agstr,value);
      nsp_string_destroy(&agstr);
      if ( a == NULL) 
	{
	  Scierror("Error: failed to add %s attribute %s=%s\n",
		   type,  attr,((NspSMatrix *) O)->S[0]);
	  return RET_BUG;
	}
    }
  return 0;
} 

static int _wrap_nsp_gv_gattr(NspAgraph *self,Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_nsp_gv_gattr_gen(self,stack,rhs,opt,lhs,AGRAPH,"graph");
}


%%
override nsp_gv_nattr kwargs

static int _wrap_nsp_gv_nattr(NspAgraph *self,Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_nsp_gv_gattr_gen(self,stack,rhs,opt,lhs,AGNODE,"node");
}

%%
override nsp_gv_eattr kwargs

static int _wrap_nsp_gv_eattr(NspAgraph *self,Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_nsp_gv_gattr_gen(self,stack,rhs,opt,lhs,AGEDGE,"edge");
}

%%
override nsp_gv_isundirected kwargs
static int _wrap_nsp_gv_isundirected(NspAgraph *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  CheckLhs(0,1);
  ret = agisundirected(self->obj->graph);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

%%
override nsp_gv_isdirected kwargs
static int _wrap_nsp_gv_isdirected(NspAgraph *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  CheckLhs(0,1);
  ret = agisdirected(self->obj->graph);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

%%
override nsp_gv_isstrict kwargs
static int _wrap_nsp_gv_isstrict(NspAgraph *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  CheckLhs(0,1);
  ret = agisstrict(self->obj->graph);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

%%
override nsp_gv_agget kwargs

static int _wrap_nsp_gv_agget(NspAgnode *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *attr;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&attr) == FAIL) return RET_BUG;
  ret = agget(self->obj->node, attr);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}


%%
override nsp_gv_agset_g kwargs

/* fix an attribute of a node */
static int _wrap_nsp_gv_agset_g(NspAgraph *self,Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_nsp_gv_agset_gen(self->obj->graph,stack,rhs,opt,lhs);
} 

%%
override nsp_gv_agset_n kwargs

/* fix an attribute of a node */
static int _wrap_nsp_gv_agset_n(NspAgnode *self,Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_nsp_gv_agset_gen(self->obj->node,stack,rhs,opt,lhs);
} 

%%
override nsp_gv_agset_e kwargs

/* fix an attribute of a node */
static int _wrap_nsp_gv_agset_e(NspAgedge *self,Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_nsp_gv_agset_gen(self->obj->edge,stack,rhs,opt,lhs);
} 

%%
override nsp_gv_aginsert kwargs

static int _wrap_nsp_gv_aginsert(NspAgraph *self,Stack stack,int rhs,int opt,int lhs)
{
  /* 
  int_types T[] = {obj,t_end};
  NspObject *obj;
  if ( GetArgs(stack,rhs,opt,T,&obj) == FAIL) return RET_BUG;
  if ( IsAgraph(obj ) )
    {
      aginsert(self->obj->graph, ((NspAgraph *) obj)->obj->graph);
    }
  else if ( IsAgnode(obj)) 
    {
      aginsert(self->obj->graph, ((NspAgnode *) obj)->obj->node);
    }
  else if ( IsAgedge(obj))
    {
      aginsert(self->obj->graph, ((NspAgedge *) obj)->obj->edge);
    }
  else
    {
      Scierror("Error: expecting graph, node or edge in aginsert method\n");
      return RET_BUG;
    }
  */
  return 0;
}


%%
override nsp_agaddnodes kwargs

static int _wrap_nsp_agaddnodes(NspAgraph *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {smat,t_end};
  NspSMatrix *nodes;
  int ret;
  CheckLhs(0,1);
  if ( GetArgs(stack,rhs,opt,T,&nodes) == FAIL) return RET_BUG;
  ret = nsp_agaddnodes(self, nodes);
  if ( lhs == 1) 
    {
      if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
      return 1;
    }
  if ( ret != -1 ) 
    {
      Scierror("Error: failed to add node %s to the graph\n",nodes->S[ret]);
      return RET_BUG;
    }
  return 0;
}

%%
override nsp_agaddedges kwargs

static int _wrap_nsp_agaddedges(NspAgraph *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {smat,t_end};
  NspSMatrix *nodes;
  int ret;
  CheckLhs(0,1);
  if ( GetArgs(stack,rhs,opt,T,&nodes) == FAIL) return RET_BUG;
  ret = nsp_agaddedges(self, nodes);
  if ( ret == FALSE ) 
    {
      return RET_BUG;
    }
  return 0;
}


%%
last

/* set of nsp function to facilitate methods or functions for graphviz functions */

NspAgraph *nsp_agread(void *chan)
{ 
  FILE* file = fopen(chan, "r"); 
  Agraph_t *dotGraph = NULL;
  if ( file == NULL ) return NULL;
  /* aginit(); */ /* can be called multiple times */
  if ((dotGraph = agread(file,NULL))== NULL) 
    return NULL;
  return nsp_agraph_create(NVOID,dotGraph, NULL);
}

static int nsp_gv_write(NspAgraph * g,void *chan)
{ 
  FILE* file = fopen(chan, "w"); 
  if ( file == NULL ) return FALSE;
  agwrite(g->obj->graph,file);
  fclose(file);
  return TRUE;
}

void nsp_agflatten(NspAgraph * g, int flag){ };
int nsp_agisflattened(NspAgraph * g){return FAIL;}
int nsp_agisdirected(NspAgraph * g){return FAIL;}
int nsp_agisundirected(NspAgraph * g){return FAIL;}
int nsp_agisstrict(NspAgraph * g){return FAIL;}

/* nodes */
/* 
NspAgnode  *nsp_agidnode(NspAgraph * g, unsigned long id,int createflag){ return NULL;}
*/


/* edges */

NspAgedge *nsp_agidedge(NspAgnode * t, NspAgnode * h, unsigned long id, int createflag){ return NULL;}
NspAgedge *nsp_agsubedge(NspAgraph * g, NspAgedge * e, int createflag){ return NULL;}

/* generic */
/* NspAgraph *nsp_agraphof(void *){ return NULL;} */
/* char *nsp_agnameof(void *){ return NULL;} */

int nsp_agrelabel(void *obj, char *name){return FAIL;}	/* scary */
int nsp_agrelabel_node(NspAgnode * n, char *newname){return FAIL;}
int nsp_agdelete(NspAgraph * g, void *obj){return FAIL;}
int nsp_agdelnode(NspAgnode * arg_n){return FAIL;}
int nsp_agdeledge(NspAgedge * arg_e){return FAIL;}
/* int nsp_agisarootobj(void *){ return NULL;} */
/* strings */
/* char *nsp_agstrdup(NspAgraph *, char *){ return NULL;} */
/* char *nsp_agstrdup_html(NspAgraph *, char *){ return NULL;} */
/* int nsp_aghtmlstr(char *){ return NULL;} */
/* char *nsp_agstrbind(NspAgraph * g, char *){ return NULL;}*/
/*   int nsp_agstrfree(NspAgraph *, char *){ return NULL;} */
/*char *nsp_agcanonstr(char *, char *){ return NULL;}*/
/*char *nsp_agcanonStr(char*){ return NULL;}*/

NspAgsym *nsp_agattrsym(void *obj, char *name){ return NULL;}
NspAgsym *nsp_agnxtattr(NspAgraph * g, int kind, NspAgsym * attr){ return NULL;}
void *nsp_agbindrec(void *obj, char *name, unsigned int size,
		       int move_to_front){ return NULL;}
int nsp_agdelrec(void *obj, char *name){return FAIL;}
void nsp_aginit(NspAgraph * g, int kind, char *rec_name,
		int rec_size, int move_to_front){ }
void nsp_agclean(NspAgraph * g, int kind, char *rec_name){}
char *nsp_agget(void *obj, char *name){ return NULL;}
char *nsp_agxget(void *obj, NspAgsym * sym){ return NULL;}
int nsp_agset(void *obj, char *name, char *value){return FAIL;}
int nsp_agxset(void *obj, NspAgsym * sym, char *value){return FAIL;}

/* set cardinality */
int nsp_agdegree(NspAgnode * n, int in, int out){return FAIL;}


/* XXX changer l'interface de add edges 
 * a changer pour que la méthode retourne une erreur en cas de FALSE 
 */


static GVC_t *gvc=NULL;

static int nsp_gv_layout(NspAgraph *G, char *mode)
{
  if ( gvc == NULL ) 
    {
      gvc = gvContext();
    }
  gvLayout(gvc, G->obj->graph, mode);
  return TRUE;
}

static int nsp_gv_render(NspAgraph *G, char *mode, char *filename)
{
  FILE* file;
  if ( gvc == NULL ) 
    {
      Scierror("render: you should call layout first\n");
      return FALSE;
    }
  if (( file = fopen(filename, "w"))== NULL) 
    return FALSE;
  gvRender(gvc, G->obj->graph, mode, file);
  fclose(file);
  return TRUE;
}

/* list attribute names */ 

static NspSMatrix *nsp_gv_objattrs(NspAgraph * g,int tag )
{
  Agsym_t *a = NULL;
  NspSMatrix *S= nsp_smatrix_create(NVOID,0,0, NULL,0);
  while ((a = agnxtattr(g->obj->graph, tag , a))) 
    {
      if ( nsp_row_smatrix_append_string(S, a->name) == FAIL) 
	goto fail;
    }
  return S;
 fail:
  if ( S != NULL) nsp_smatrix_destroy(S);
  return NULL;
}

static NspSMatrix *nsp_gv_graphattrs(NspAgraph * g)
{
  return nsp_gv_objattrs(g,AGRAPH);
}

static NspSMatrix *nsp_gv_nodeattrs(NspAgraph * g)
{
  return nsp_gv_objattrs(g,AGNODE);
}

static NspSMatrix *nsp_gv_edgeattrs(NspAgraph * g)
{
  return nsp_gv_objattrs(g,AGEDGE);
}

static NspAgedge *nsp_gv_agfstout(NspAgraph * g, NspAgnode *n)
{
  Agedge_t *e1 ;
  if ((e1 = agfstout(g->obj->graph,n->obj->node))== NULL)
    {
      Scierror("Error: first out edge was not found\n");
      return NULL;
    }
  return nsp_agedge_create(NVOID,e1,NULL);
}

static NspAgedge *nsp_gv_agnxtout(NspAgraph * g, NspAgedge *e)
{
  Agedge_t *e1 ;
  if ((e1 = agnxtout(g->obj->graph,e->obj->edge))== NULL)
    {
      Scierror("Error: next out edge node was not found\n");
      return NULL;
    }
  return nsp_agedge_create(NVOID,e1,NULL);
}

static NspAgedge *nsp_gv_agfstin(NspAgraph * g, NspAgnode *n)
{
  Agedge_t *e1 ;
  if ((e1 = agfstin(g->obj->graph,n->obj->node))== NULL)
    {
      Scierror("Error: first in edge was not found\n");
      return NULL;
    }
  return nsp_agedge_create(NVOID,e1,NULL);
}

static NspAgedge *nsp_gv_agnxtin(NspAgraph * g, NspAgedge *e)
{
  Agedge_t *e1 ;
  if ((e1 = agnxtin(g->obj->graph,e->obj->edge))== NULL)
    {
      Scierror("Error: next in edge was not found\n");
      return NULL;
    }
  return nsp_agedge_create(NVOID,e1,NULL);
}

static NspAgedge *nsp_gv_agfstedge(NspAgraph * g, NspAgnode *n)
{
  Agedge_t *e1 ;
  if ((e1 = agfstedge(g->obj->graph,n->obj->node))== NULL)
    {
      Scierror("Error: first edge node was not found\n");
      return NULL;
    }
  return nsp_agedge_create(NVOID,e1,NULL);
}

static NspAgedge *nsp_gv_agnxtedge(NspAgraph * g, NspAgedge *e, NspAgnode *n)
{
  Agedge_t *e1 ;
  if ((e1 = agnxtedge(g->obj->graph,e->obj->edge,n->obj->node))== NULL)
    {
      Scierror("Error: next edge was not found\n");
      return NULL;
    }
  return nsp_agedge_create(NVOID,e1,NULL);
}

static int _wrap_nsp_gv_agset_gen(void *obj,Stack stack,int rhs,int opt,int lhs)
{
  /* int a; */
  int i;
  CheckStdRhs(0,0);
  CheckLhs(0,1);
  for ( i = 1 ; i <= rhs ; i++) 
    {
      char *value, *agstr;
      const char *attr;
      NspObject *O;
      if ( Ocheckname(NthObj(i),NVOID) ) 
	{
	  Scierror("Error: %s of method %s should be a named optional argument \n",
		   ArgPosition(i),NspFname(stack));
	  return RET_BUG;
	}
      attr = nsp_object_get_name(NthObj(i));
      O = nsp_get_object(stack,i);
      if ( IsString(O) == FALSE )
	{
	  Scierror("Error: %s of method  %s should be a string\n",
		   ArgPosition(i),NspFname(stack));
	  return RET_BUG;
	}
      value =  ((NspSMatrix *) O)->S[0];

      agstr = nsp_string_copy(attr);
      if ( agstr == NULL) return RET_BUG;
      /* a =*/ agsafeset(obj,agstr,value,"");
      nsp_string_destroy(&agstr);
      /*
	if ( a == FALSE) 
	{
	  Scierror("Error: failed to add a node attribute %s=%s\n",
		   attr,((NspSMatrix *) O)->S[0]);
	  return RET_BUG;
	}
      */
    }
  return 0;
} 

/*-------------------------------------------------
 *  utilities for writing graph methods
 *-------------------------------------------------*/

static NspAgraph *nsp_agparent(NspAgraph * G)
{
  Agraph_t *g = ((Agraph_t *) G->obj->graph);
  Agraph_t *p;
  NspAgraph *P;
  if (( p = agparent(g))== NULL) 
    {
      Scierror("Error: failed to obtain parent graph\n");
      return NULL;
    }
  if ((P = nsp_agraph_create(NVOID,p, NULL)) == NULL) 
    {
      Scierror("Error: failed to create a graph\n");
      return NULL;
    }
  return P;
}

static NspAgraph *nsp_agroot(NspAgraph * G)
{
  Agraph_t *g = ((Agraph_t *) G->obj->graph);
  Agraph_t *r;
  NspAgraph *R;
  if (( r = agroot(g))== NULL) 
    {
      Scierror("Error: failed to obtain parent graph\n");
      return NULL;
    }
  if (( R = nsp_agraph_create(NVOID,r, NULL)) == NULL) 
    {
      Scierror("Error: failed to create a graph\n");
      return NULL;
    }
  return R;
}


static NspAgnode *nsp_agfstnode(NspAgraph * g)
{
  Agnode_t *n ;
  if ((n = agfstnode(g->obj->graph))== NULL)
    {
      Scierror("Error: first node was not found\n");
      return NULL;
    }
  return nsp_agnode_create(NVOID,n,NULL);
}

static NspAgnode *nsp_aglstnode(NspAgraph * g)
{
  Agnode_t *n ;
  if ((n = aglstnode(g->obj->graph))== NULL)
    {
      Scierror("Error: last node was not found\n");
      return NULL;
    }
  return nsp_agnode_create(NVOID,n,NULL);
}

static NspAgnode *nsp_agnxtnode(NspAgraph * g, NspAgnode *n)
{
  Agnode_t *n1 ;
  if ((n1 = agnxtnode(g->obj->graph,n->obj->node))== NULL)
    {
      Scierror("Error: next node was not found\n");
      return NULL;
    }
  return nsp_agnode_create(NVOID,n1,NULL);
}

static NspAgnode *nsp_agprvnode(NspAgraph * g, NspAgnode *n)
{
  Agnode_t *n1 ;
  if ((n1 = agprvnode(g->obj->graph,n->obj->node))== NULL)
    {
      Scierror("Error: previous node was not found\n");
      return NULL;
    }
  return nsp_agnode_create(NVOID,n1,NULL);
}

static NspAgnode *nsp_agfindnode_by_name(NspAgraph * g, char *name)
{
  Agnode_t *n ;
  if ((n = agfindnode(g->obj->graph,name) )== NULL)
    {
      Scierror("Error: node with name=%s was not found\n",name);
      return NULL;
    }
  return nsp_agnode_create(NVOID,n,NULL);
}

/* add nodes to the graph given their names 
 */

static int nsp_agaddnodes(NspAgraph *G, NspSMatrix *S)
{
  int i;
  for ( i = 0 ; i < S->mn ; i++) 
    if ( agnode(G->obj->graph, S->S[i],1) == NULL) 
      {
	return i;
      }
  return -1; /* success */
}

/* add edges to the graph given their names 
 */

static int nsp_agaddedges(NspAgraph *G, NspSMatrix *S)
{
  int i;
  if ( S->n != 2 ) 
    {
      Scierror("add_deges: argument should have two columns\n");
      return FALSE;
    }
  for ( i = 0 ; i < S->m ; i++) 
    {
      Agnode_t *t, *h;
      if ((t = agfindnode(G->obj->graph, S->S[i]))== NULL) 
	{
	  Scierror("Error: in add_deges tail %s of arc %d is not a node name\n",S->S[i],i);
	  return FALSE;
	}
      if ((h = agfindnode(G->obj->graph, S->S[i+S->m]))== NULL) 
	{
	  Scierror("Error: in add_deges head %s of arc %d is not a node name\n",S->S[i+S->m],i);
	  return FALSE;
	}
      if ( agedge(G->obj->graph, t,h,0,1)  == NULL) 
	{
	  Scierror("add_deges: failed to add arc %s->%s\n",t,h);
	  return FALSE;
	}
    }
  return TRUE;
}


static char *nsp_agnameof_g(NspAgraph * G)
{
  char *str = agnameof(G->obj->graph);
  if ( str == NULL) return NULL;
  return nsp_new_string(str,-1);
}

static char *nsp_agnameof_n(NspAgnode * N)
{
  char *str= agnameof(N->obj->node);
  if ( str == NULL) return NULL;
  return nsp_new_string(str,-1);
}

static char *nsp_agnameof_e(NspAgedge * E)
{
  char *str=agnameof(E->obj->edge);
  if ( str == NULL) return NULL;
  return nsp_new_string(str,-1);
}

/*---------------------------------------------------------
 *  utilities for writing graph methods related to subgraph 
 *---------------------------------------------------------*/

static NspAgraph *nsp_agsubg(NspAgraph * G, char *name) 
{
  Agraph_t *g = ((Agraph_t *) G->obj->graph);
  Agraph_t *s;
  NspAgraph *S;
  if (( s = agsubg(g,name,1))== NULL) 
    {
      Scierror("Error: failed to create a subgraph\n");
      return NULL;
    }
  if (( S = nsp_agraph_create(NVOID,s, NULL)) == NULL) 
    {
      Scierror("Error: failed to create a subgraph\n");
      return NULL;
    }
  return S;
}

static NspAgraph *nsp_agfstsubg(NspAgraph * G)
{
  Agraph_t *g = ((Agraph_t *) G->obj->graph);
  Agraph_t *s;
  NspAgraph *S;
  if (( s = agfstsubg(g))== NULL) 
    {
      Scierror("Error: failed to find a subgraph\n");
      return NULL;
    }
  if (( S = nsp_agraph_create(NVOID,s, NULL)) == NULL) 
    {
      Scierror("Error: failed to create a graph\n");
      return NULL;
    }
  return S;
}

static NspAgraph *nsp_agnxtsubg(NspAgraph * G)
{
  Agraph_t *g = ((Agraph_t *) G->obj->graph);
  Agraph_t *s;
  NspAgraph *S;
  if (( s = agnxtsubg(g))== NULL) 
    {
      Scierror("Error: failed to find next subgraph\n");
      return NULL;
    }
  if (( S = nsp_agraph_create(NVOID,s, NULL)) == NULL) 
    {
      Scierror("Error: failed to create a graph\n");
      return NULL;
    }
  return S;
}

static int nsp_agdelsubg(NspAgraph * G,NspAgraph * Gsub)
{
  Agraph_t *g = ((Agraph_t *) G->obj->graph);
  Agraph_t *gsub = ((Agraph_t *) Gsub->obj->graph);
  agdelsubg(g,gsub);
  return OK;
}

/*-------------------------------------------------
 *  utilities for writing node methods
 *-------------------------------------------------*/

static NspAgraph *nsp_agraphof(NspAgnode * N)
{
  NspAgraph *G;
  Agraph_t *g = agraphof(N->obj->node);
  if ( g == NULL) return NULL;
  if ((G = nsp_agraph_create(NVOID,g, NULL)) == NULL) 
    {
      Scierror("Error: failed to create a graph\n");
      return NULL;
    }
  return G;
}

/*-------------------------------------------------
 *  utilities for writing edge methods
 *-------------------------------------------------*/

static NspAgnode *nsp_aghead(NspAgedge* E)
{
  Agnode_t *n ;
  Agedge_t *e = (Agedge_t *) E->obj->edge ;
  if ((n = aghead(e)) == NULL)
    {
      char * str = agnameof(e);
      if ( str != NULL) 
	Scierror("Error: failed to get the head of edge %s\n",agnameof(e));
      else
	Scierror("Error: failed to get the head of an edge \n");
      return NULL;
    }
  return nsp_agnode_create(NVOID,n,NULL);
}

static NspAgnode *nsp_agtail(NspAgedge* E)
{
  Agnode_t *n ;
  Agedge_t *e = (Agedge_t *) E->obj->edge ;
  if ((n = agtail(e)) == NULL)
    {
      char * str = agnameof(e);
      if ( str != NULL) 
	Scierror("Error: failed to get the tail of edge %s\n",agnameof(e));
      else
	Scierror("Error: failed to get the tail of an edge \n");
    }
  return nsp_agnode_create(NVOID,n,NULL);
}

/*-------------------------------------------------
 *  utilities for graph creation 
 *-------------------------------------------------*/

int nsp_agraph_fill_from_b(Agraph_t *g, NspBMatrix *B)
{
  int i,j;
  char buf[512];
  for ( i = 0 ; i < B->m ; i++) 
    {
      snprintf(buf,511,"N%d",i);
      if ( agnode(g, buf ,1) == NULL) 
	{
	  return FAIL;
	}
    }    
  for ( i = 0 ; i < B->m ; i++)
    {
      Agnode_t *t, *h;
      snprintf(buf,511,"N%d",i);
      if ((t = agfindnode(g, buf ))== NULL) 
	{
	  Scierror("Error: failed to create an arc, node %s not found\n",buf);
	  return FAIL;
	}
      for ( j = 0 ; j < B->n ; j++)
	{
	  if ( B->B[i+j*B->m] == 1) 
	    {
	      snprintf(buf,511,"N%d",j);
	      if ((h = agfindnode(g, buf)) == NULL)
		{
		  Scierror("Error: failed to create an arc, node %s not found\n",buf);
		  return FAIL;
		}
	      if ( agedge(g, t,h,0,1)  == NULL) 
		{
		  Scierror("add_deges: failed to add arc %s->%s\n",t,h);
		  return FAIL;
		}
	    }
	}
    }
  return OK;
}
