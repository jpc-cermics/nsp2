      SUBROUTINE TWODQ(F,N,X,Y,TOL,ICLOSE,MAXTRI,MEVALS,RESULT,
     *  ERROR,NU,ND,NEVALS,IFLAG,DATA,IWORK,vectflag,stat)
C***BEGIN PROLOGUE  TWODQ
C***DATE WRITTEN   840518   (YYMMDD)
C***REVISION DATE  840518   (YYMMDD)
C***CATEGORY NO.  D1I
C***KEYWORDS  QUADRATURE,TWO DIMENSIONAL,ADAPTIVE,CUBATURE
C***AUTHOR KAHANER,D.K.,N.B.S.
C          RECHARD,O.W.,N.B.S.
C          BARNHILL,ROBERT,UNIV. OF UTAH
C***PURPOSE  To compute the two-dimensional integral of a function
C            F over a region consisting of N triangles.
C***DESCRIPTION
C
C   This subroutine computes the two-dimensional integral of a
C   function F over a region consisting of N triangles.
C   A total error estimate is obtained and compared with a
C   tolerance - TOL - that is provided as input to the subroutine.
C   The error tolerance is treated as either relative or absolute
C   depending on the input value of IFLAG.  A 'Local Quadrature
C   Module' is applied to each input triangle and estimates of the
C   total integral and the total error are computed.  The local
C   quadrature module is either subroutine LQM0 or subroutine
C   LQM1 and the choice between them is determined by the
C   value of the input variable ICLOSE.
C
C   If the total error estimate exceeds the tolerance, the triangle
C   with the largest absolute error is divided into two triangles
C   by a median to its longest side.  The local quadrature module
C   is then applied to each of the subtriangles to obtain new
C   estimates of the integral and the error.  This process is
C   repeated until either (1) the error tolerance is satisfied,
C   (2) the number of triangles generated exceeds the input
C   parameter MAXTRI, (3) the number of integrand evaluations
C   exceeds the input parameter MEVALS, or (4) the subroutine
C   senses that roundoff error is beginning to contaminate
C   the result.
C
C   The user must specify MAXTRI, the maximum number of triangles
C   in the final triangulation of the region, and provide two
C   storage arrays - DATA and IWORK - whose sizes are at least
C   9*MAXTRI and 2*MAXTRI respectively.  The user must also
C   specify MEVALS, the maximum number of function evaluations
C   to be allowed.  This number will be effective in limiting
C   the computation only if it is less than 92*MAXTRI when LQM1
C   is specified or 56*MAXTRI when LQM0 is specified.
C
C   After the subroutine has returned to the calling program
C   with output values, it can be called again with a smaller
C   value of TOL and/or a different value of MEVALS.  The tolerance
C   can also be changed from relative to absolute
C   or vice-versa by changing IFLAG.  Unless
C   the parameters NU and ND are reset to zero the subroutine
C   will restart with the final set of triangles and output
C   values from the previous call.
C
C   ARGUMENTS:
C
C   F function subprogram defining the integrand F(u,v);
C     the actual name for F needs to be declared EXTERNAL
C     by the calling program.
C
C   N the number of input triangles.
C
C   X a 3 by N array containing the abscissae of the vertices
C     of the N triangles.
C
C   Y a 3 by N array containing the ordinates of the vertices
C     of the N triangles
C
C   TOL the desired bound on the error.  If IFLAG=0 on input,
C       TOL is interpreted as a bound on the relative error;
C       if IFLAG=1, the bound is on the absolute error.
C
C   ICLOSE an integer parameter that determines the selection
C          of LQM0 or LQM1.  If ICLOSE=1 then LQM1 is used.
C          Any other value of ICLOSE causes LQM0 to be used.
C          LQM0 uses function values only at interior points of
C          the triangle.  LQM1 is usually more accurate than LQM0
C          but involves evaluating the integrand at more points
C          including some on the boundary of the triangle.  It
C          will usually be better to use LQM1 unless the integrand
C          has singularities on the boundary of the triangle.
C
C   MAXTRI The maximum number of triangles that are allowed
C          to be generated by the computation.
C
C   MEVALS  The maximum number of function evaluations allowed.
C
C   RESULT output of the estimate of the integral.
C
C   ERROR output of the estimate of the absolute value of the
C         total error.
C
C   NU an integer variable used for both input and output.   Must
C      be set to 0 on first call of the subroutine.  Subsequent
C      calls to restart the subroutine should use the previous
C      output value.
C
C   ND an integer variable used for both input and output.  Must
C      be set to 0 on first call of the subroutine.  Subsequent
C      calls to restart the subroutine should use the previous
C      output value.
C
C   NEVALS  The actual number of function evaluations performed.
C
C   IFLAG on input:
C        IFLAG=0 means TOL is a bound on the relative error;
C        IFLAG=1 means TOL is a bound on the absolute error;
C        any other input value for IFLAG causes the subroutine
C        to return immediately with IFLAG set equal to 9.
C
C        on output:
C        IFLAG=0 means normal termination;
C        IFLAG=1 means termination for lack of space to divide
C                another triangle;
C        IFLAG=2 means termination because of roundoff noise
C        IFLAG=3 means termination with relative error <=
C                5.0* machine epsilon;
C        IFLAG=4 means termination because the number of function
C                evaluations has exceeded MEVALS.
C        IFLAG=9 means termination because of error in input flag
C
C   DATA a one dimensional array of length >= 9*MAXTRI
C        passed to the subroutine by the calling program.  It is
C        used by the subroutine to store information
C        about triangles used in the quadrature.
C
C   IWORK  a one dimensional integer array of length >= 2*MAXTRI
C          passed to the subroutine by the calling program.
C          It is used by the subroutine to store pointers
C          to the information in the DATA array.
C
C
C   The information for each triangle is contained in a nine word
C   record consisting of the error estimate, the estimate of the
C   integral, the coordinates of the three vertices, and the area.
C   These records are stored in the DATA array
C   that is passed to the subroutine.  The storage is organized
C   into two heaps of length NU and ND respectively.  The first heap
C   contains those triangles for which the error exceeds
C   epsabs*a/ATOT where epsabs is a bound on the absolute error
C   derived from the input tolerance (which may refer to relative
C   or absolute error), a is the area of the triangle, and ATOT
C   is the total area of all triangles.  The second heap contains
C   those triangles for which the error is less than or equal to
C   epsabs*a/ATOT.  At the top of each heap is the triangle with
C   the largest absolute error.
C
C   Pointers into the heaps are contained in the array IWORK.
C   Pointers to the first heap are contained
C   between IWORK(1) and IWORK(NU).  Pointers to the second
C   heap are contained between IWORK(MAXTRI+1) and
C   IWORK(MAXTRI+ND).  The user thus has access to the records
C   stored in the DATA array through the pointers in IWORK.
C   For example, the following two DO loops will print out
C   the records for each triangle in the two heaps:
C
C     DO 10 I=1,NU
C       PRINT*,(DATA(IWORK(I)+J),J=0,8)
C    10  CONTINUE
C     DO 20 I=1,ND
C       PRINT*,(DATA(IWORK(MAXTRI+I)+J),J=0,8
C    20  CONTINUE
C
C   When the total number of triangles is equal to
C   MAXTRI, the program attempts to remove a triangle from the
C   bottom of the second heap and continue.  If the second heap
C   is empty, the program returns with the current estimates of
C   the integral and the error and with IFLAG set equal to 1.
C   Note that in this case the actual number of triangles
C   processed may exceed MAXTRI and the triangles stored in
C   the DATA array may not constitute a complete triangulation
C   of the region.
C
C   The following sample program will calculate the integral of
C   cos(x+y) over the square (0.,0.),(1.,0.),(1.,1.),(0.,1.) and
C   print out the values of the estimated integral, the estimated
C   error, the number of function evaluations, and IFLAG.
C
C     Double precision X(3,2),Y(3,2),DATA(450),RES,ERR
C     INTEGER IWORK(100),NU,ND,NEVALS,IFLAG
C     EXTERNAL F
C     X(1,1)=0.
C     Y(1,1)=0.
C     X(2,1)=1.
C     Y(2,1)=0.
C     X(3,1)=1.
C     Y(3,1)=1.
C     X(1,2)=0.
C     Y(1,2)=0.
C     X(2,2)=1.
C     Y(2,2)=1.
C     X(3,2)=0.
C     Y(3,2)=1.
C     NU=0
C     ND=0
C     IFLAG=1
C     CALL TWODQ(F,2,X,Y,1.D-04,1,50,4000,RES,ERR,NU,ND,
C    *  NEVALS,IFLAG,DATA,IWORK)
C     PRINT*,RES,ERR,NEVALS,IFLAG
C     END
C     DOUBLE PRECISION FUNCTION F(X,Y)
C     DOUBLE PRECISION X,Y
C     F=COS(X+Y)
C     RETURN
C     END
C
C***REFERENCES  (NONE)
C
C***ROUTINES CALLED  HINITD,HINITU,HPACC,HPDEL,HPINS,LQM0,LQM1,
C                    TRIDV,DLAMCH
C***END PROLOGUE  TWODQ
      integer n,iflag,nevals,iclose,nu,nd,mevals,iwork(*),maxtri, stat
      double precision x(3,n),y(3,n),data(*),tol,result,error
      integer rndcnt
      logical full, vectflag
      double precision a,r,e,u(3),v(3),node(9),node1(9),node2(9),
     *  epsabs,EMACH,DLAMCH,ATOT,fadd,newres,newerr
      external f,GREATR
      save ATOT

      EMACH=DLAMCH('p')
c
c      If heaps are empty, apply LQM to each input triangle and
c      place all of the data on the second heap.
c
      if((nu+nd).eq.0) then
         call HINITU(maxtri,9,nu,iwork)
         call HINITD(maxtri,9,nd,iwork(maxtri+1))
         ATOT=0.0
         result=0.0
         error=0.0
         rndcnt=0
         nevals=0
         do i=1,n
            do j=1,3
               u(j)=x(j,i)
               v(j)=y(j,i)
            enddo
            a=0.5*abs(u(1)*v(2)+u(2)*v(3)+u(3)*v(1)
     *           -u(1)*v(3)-u(2)*v(1)-u(3)*v(2))
            ATOT=ATOT+a
            if(iclose.eq.1) then
               call LQM1VECT(f,u,v,r,e,vectflag,stat)
               if(stat.ne.0) return
               nevals=nevals+46
            else
               call LQM0VECT(f,u,v,r,e,vectflag,stat)
               if(stat.ne.0) return
               nevals=nevals+28
            endif
            result=result+r
            error=error+e
            node(1)=e
            node(2)=r
            node(3)=x(1,i)
            node(4)=y(1,i)
            node(5)=x(2,i)
            node(6)=y(2,i)
            node(7)=x(3,i)
            node(8)=y(3,i)
            node(9)=a
            call HPINS(maxtri,9,data,nd,iwork(maxtri+1),node,GREATR)
         enddo
      end if
c
c      Check that input tolerance is consistent with
c      machine epsilon.
c
      if(iflag.eq.0) then
        if(tol.le.5.0*EMACH) then
          tol=5.0*EMACH
          fadd=3
        else
          fadd=0
        end if
        epsabs=tol*abs(result)
      else if(iflag.eq.1) then
        if(tol.le.5.0*EMACH*abs(result)) then
          epsabs=5.0*EMACH*abs(result)
        else
          fadd=0
          epsabs=tol
        end if
      else
        iflag=9
        return
      end if
c
c      Adjust the second heap on the basis of the current
c      value of epsabs.
c
   2  if(nd.eq.0) go to 40
        j=nd
   3    if(j.eq.0) go to 40
          call HPACC(maxtri,9,data,nd,iwork(maxtri+1),node,j)
          if(node(1).gt.epsabs*node(9)/ATOT) then
            call HPINS(maxtri,9,data,nu,iwork,node,GREATR)
            call HPDEL(maxtri,9,data,nd,iwork(maxtri+1),GREATR,j)
            if(j.gt.nd) j=j-1
          else
            j=j-1
          endif
        go to 3
c
c      Beginning of main loop from here to end
c
  40  if(nevals.ge.mevals) then
        iflag=4
        return
      end if
      if(error.le.epsabs) then
        if(iflag.eq.0) then
          if(error.le.abs(result)*tol) then
            iflag=fadd
            return
          else
            epsabs=abs(result)*tol
            go to 2
          end if
        else
          if(error.le.tol) then
            iflag=0
            return
          else if(error.le.5.0*EMACH*abs(result)) then
            iflag=3
            return
          else
            epsabs=5.0*EMACH*abs(result)
            go to 2
          end if
        end if
      end if
c
c      If there are too many triangles and second heap
c      is not empty remove bottom triangle from second
c      heap.  If second heap is empty return with iflag
c      set to 1 or 4.
c
      if((nu+nd).ge.maxtri) then
        full=.true.
        if(nd.gt.0) then
          iwork(nu+1)=iwork(maxtri+nd)
          nd=nd-1
        else
          iflag=1
          return
        end if
      else
        full=.false.
      end if
c
c      Find triangle with largest error, divide it in
c      two, and apply LQM to each half.
c
      if(nd.eq.0) then
        call HPACC(maxtri,9,data,nu,iwork,node,1)
        call HPDEL(maxtri,9,data,nu,iwork,GREATR,1)
      else if(nu.eq.0) then
        call HPACC(maxtri,9,data,nd,iwork(maxtri+1),node,1)
        call HPDEL(maxtri,9,data,nd,iwork(maxtri+1),GREATR,1)
      else if(data(iwork(1)).ge.data(iwork(maxtri+1))) then
        if(full) iwork(maxtri+nd+2)=iwork(nu)
        call HPACC(maxtri,9,data,nu,iwork,node,1)
        call HPDEL(maxtri,9,data,nu,iwork,GREATR,1)
      else
        if(full) iwork(nu+2)=iwork(maxtri+nd)
        call HPACC(maxtri,9,data,nd,iwork(maxtri+1),node,1)
        call HPDEL(maxtri,9,data,nd,iwork(maxtri+1),GREATR,1)
      end if
      call tridv(node,node1,node2,0.5d0,1)
      do j=1,3
         u(j)=node1(2*j+1)
         v(j)=node1(2*j+2)
      enddo
      if(iclose.eq.1) then
         call LQM1VECT(f,u,v,node1(2),node1(1),vectflag,stat)
         if(stat.ne.0) return
         nevals=nevals+46
      else
         call LQM0VECT(f,u,v,node1(2),node1(1),vectflag,stat)
         if(stat.ne.0) return
         nevals=nevals+28
      end if
      do j=1,3
         u(j)=node2(2*j+1)
         v(j)=node2(2*j+2)
      enddo
      if(iclose.eq.1) then
         call LQM1VECT(f,u,v,node2(2),node2(1),vectflag,stat)
         if(stat.ne.0) return
         nevals=nevals+46
      else
         call LQM0VECT(f,u,v,node2(2),node2(1),vectflag,stat)
         if(stat.ne.0) return
         nevals=nevals+28
      end if
      newerr=node1(1)+node2(1)
      newres=node1(2)+node2(2)
      if(newerr.gt.0.99*node(1)) then
         if(abs(node(2)-newres).le.1.D-04*abs(newres)) rndcnt=rndcnt+1
      end if
      result=result-node(2)+newres
      error=error-node(1)+newerr
      if(node1(1).gt.node1(9)*epsabs/ATOT) then
         call HPINS(maxtri,9,data,nu,iwork,node1,GREATR)
      else
         call HPINS(maxtri,9,data,nd,iwork(maxtri+1),node1,GREATR)
      end if
      if(node2(1).gt.node2(9)*epsabs/ATOT) then
         call HPINS(maxtri,9,data,nu,iwork,node2,GREATR)
      else
         call HPINS(maxtri,9,data,nd,iwork(maxtri+1),node2,GREATR)
      end if
      if(rndcnt.ge.20) then
         iflag=2
         return
      end if
      if(iflag.eq.0) then
         if(epsabs.lt.0.5*tol*abs(result)) then
            epsabs=tol*abs(result)
            j=nu
 5          if(j.eq.0) go to 40
            call HPACC(maxtri,9,data,nu,iwork,node,j)
            if(node(1).le.epsabs*node(9)/ATOT) then
               call HPINS(maxtri,9,data,nd,iwork(maxtri+1),node,GREATR)
               call HPDEL(maxtri,9,data,nu,iwork,GREATR,j)
               if(j.gt.nu) j=j-1
            else
               j=j-1
            end if
            go to 5
         end if
      end if
      go to 40
      end
      LOGICAL FUNCTION GREATR(A,B,NWDS)
      INTEGER NWDS
      DOUBLE PRECISION A(NWDS), B(NWDS)
      GREATR= A(1) .GT. B(1)
      RETURN
      END
      SUBROUTINE HINITD(NMAX,NWDS,N,T)
C   PURPOSE
C         THIS ROUTINE INITIALIZES THE HEAP PROGRAMS WITH T(NMAX)
C         POINTING TO THE TOP OF THE HEAP.
C         IT IS CALLED ONCE AT THE START OF EACH NEW CALCULATION.
C   INPUT
C         NMAX=MAXIMUM NUMBER OF NODES ALLOWED BY USER
C         NWDS=NUMBER OF WORDS PER NODE
C   OUTPUT
C         N=CURRENT NUMBER OF NODES IN HEAP = 0.
C         T=INTEGER ARRAY OF POINTERS TO POTENTIAL HEAP NODES.
C
      INTEGER T(1)
      DO 1 I=1,NMAX
    1  T(I)=(NMAX-I)*NWDS+1
      N=0
      RETURN
      END
      SUBROUTINE HINITU(NMAX,NWDS,N,T)
C        H E A P  PACKAGE
C          A COLLECTION OF PROGRAMS WHICH MAINTAIN A HEAP DATA
C          STRUCTURE.  BY CALLING THESE SUBROUTINES IT IS POSSIBLE TO
C          INSERT, DELETE, AND ACCESS AN EXISTING HEAP OR TO BUILD A
C          NEW HEAP FROM AN UNORDERED COLLECTION OF NODES. THE HEAP
C          FUNCTION IS AN ARGUMENT TO THE SUBROUTINES ALLOWING VERY
C          GENERAL ORGANIZATIONS.
C            THE USER MUST DECIDE ON THE MAXIMUM NUMBER OF NODES
C          ALLOWED AND DIMENSION THE REAL ARRAY DATA AND THE INTEGER
C          ARRAY T USED INTERNALLY BY THE PACKAGE.  THESE VARIABLES ARE
C          THEN PASSED THROUGH THE CALL SEQUENCE BETWEEN THE HEAP
C          PROGRAMS BUT ARE NOT IN GENERAL ACCESSED BY THE USER.  HE
C          MUST ALSO PROVIDE A HEAP FUNCTION WHOSE NAME MUST BE INCLUD-
C          ED IN AN EXTERNAL STATEMENT IN THE USER PROGRAM WHICH CALLS
C          THE HEAP SUBROUTINES.  TWO SIMPLE HEAP FUNCTIONS ARE
C          PROVIDED WITH THE PACKAGE.
C
C
C   PURPOSE
C         THIS ROUTINE INITIALIZES THE HEAP PROGRAMS WITH T(1)
C         POINTING TO THE TOP OF THE HEAP.
C         IT IS CALLED ONCE AT THE START OF EACH NEW CALCULATION
C   INPUT
C         NMAX = MAXIMUM NUMBER OF NODES ALLOWED BY USER.
C         NWDS = NUMBER OF WORDS PER NODE
C   OUTPUT
C         N = CURRENT NUMBER OF NODES IN HEAP = 0.
C         T = INTEGER ARRAY OF POINTERS TO POTENTIAL HEAP NODES.
C
      INTEGER T(1)
      DO 1 I = 1, NMAX
    1    T(I)=(I-1)*NWDS+1
      N = 0
      RETURN
      END
      SUBROUTINE HPACC(NMAX,NWDS,DATA,N,T,XNODE,K)
C
C   PURPOSE
C          TO ACCESS THE K-TH NODE OF THE HEAP,
C          1 .LE. K .LE. N .LE. NMAX
C   INPUT
C        NMAX = MAXIMUM NUMBER OF NODES ALLOWED BY USER.
C        DATA = WORK AREA FOR STORING NODES.
C        N = CURRENT NUMBER OF NODES IN THE HEAP.
C        T = INTEGER ARRAY OF POINTERS TO HEAP NODES.
C        XNODE = A REAL ARRAY, NWDS WORDS LONG, IN WHICH NODAL IN-
C          FORMATION WILL BE INSERTED.
C        K = THE INDEX OF THE NODE TO BE FOUND AND INSERTED INTO
C                XNODE.
C
C   OUTPUT
C        XNODE =  A REAL ARRAY.    CONTAINS IN XNODE(1),...,XNODE(NWDS)
C          THE ELEMENTS OF THE K-TH NODE.
C
      DOUBLE PRECISION DATA(1), XNODE(1)
      INTEGER T(1)
      IF (K .LT. 1 .OR. K .GT. N .OR. N .GT. NMAX) RETURN
      J=T(K)-1
      DO 1 I=1,NWDS
         IPJ=I+J
    1    XNODE(I)=DATA(IPJ)
      RETURN
      END
      SUBROUTINE HPDEL(NMAX,NWDS,DATA,N,T,HPFUN,K)
C
C   PURPOSE
C          DELETE K-TH ELEMENT OF HEAP.  RESULTING TREE IS REHEAPED.
C   INPUT
C         NMAX = MAXIMUN NUMBER OF NODES ALLOWED BY USER.
C         NWDS = NUMBER OF WORDS PER NODE.
C         DATA = WORK AREA IN WHICH THE NODES ARE STORED.
C        N = CURRENT NUMBER OF NODES.
C        T = INTEGER ARRAY OF POINTERS TO NODES.
C         HPFUN = NAME OF USER WRITTEN FUNCTION TO DETERMINE TOP NODE.
C         K = INDEX OF NODE TO BE DELETED
C   OUTPUT
C         N = UPDATED NUMBER OF NODES.
C         T = UPDATED INTEGER POINTER ARRAY TO NODES.
C
      EXTERNAL HPFUN
      LOGICAL HPFUN
      DOUBLE PRECISION DATA(1)
      INTEGER T(1)
      IF(N .EQ. 0) RETURN
      IF(K.EQ.N) THEN
        N=N-1
        RETURN
      END IF
      KDEL=K
      JUNK=T(KDEL)
      T(KDEL)=T(N)
      T(N)=JUNK
      N=N-1
  10  IF(KDEL.EQ.1) THEN
        CALL HPGRO(NMAX,NWDS,DATA,N,T,HPFUN,KDEL)
        RETURN
      ELSE
        KHALVE=KDEL/2
        IL=T(KHALVE)
        IR=T(KDEL)
        IF(HPFUN(DATA(IL),DATA(IR),NWDS)) THEN
          CALL HPGRO(NMAX,NWDS,DATA,N,T,HPFUN,KDEL)
          RETURN
        ELSE
          T(KHALVE)=IR
          T(KDEL)=IL
          KDEL=KHALVE
        END IF
      END IF
      GO TO 10
      END
      SUBROUTINE HPGRO(NMAX,NWDS,DATA,N,T,HPFUN,I)
C
C   PURPOSE
C          FORMS A HEAP OUT OF A TREE. USED PRIVATELY BY HPBLD.
C          THE TOP OF THE TREE IS STORED IN LOCATION T(I).
C          FIRST SON IS IN LOCATION T(2I), NEXT SON
C          IS IN LOCATION T(2I+1).
C          THIS PROGRAM ASSUMES EACH BRANCH OF THE TREE IS A HEAP.
C
      INTEGER T(1)
      DOUBLE PRECISION DATA(1)
      LOGICAL HPFUN
      IF(N .GT. NMAX) RETURN
C
      K=I
    1 J=2*K
C
C          TEST IF ELEMENT IN J TH POSITION IS A LEAF.
C
      IF( J .GT. N ) RETURN
C
C          IF THERE IS MORE THAN ONE SON, FIND WHICH SON IS SMALLEST.
C
      IF( J .EQ. N ) GO TO 2
      IR=T(J)
      IL=T(J+1)
      IF(HPFUN(DATA(IL),DATA(IR),NWDS)) J=J+1
C
C          IF A SON IS LARGER THAN FATHER, INTERCHANGE
C          THIS DESTROYS HEAP PROPERTY, SO MUST RE-HEAP REMAINING
C          ELEMENTS
C
    2 CONTINUE
      IL=T(K)
      IR=T(J)
      IF(HPFUN(DATA(IL),DATA(IR),NWDS)) RETURN
         ITEMP=T(J)
         T(J)=T(K)
         T(K)=ITEMP
         K=J
      GO TO 1
      END
      SUBROUTINE HPINS(NMAX,NWDS,DATA,N,T,XNODE,HPFUN)
C
C   PURPOSE
C         THIS ROUTINE INSERTS A NODE INTO AN ALREADY EXISTING HEAP.
C             THE RESULTING TREE IS RE-HEAPED.
C
C   INPUT
C         NMAX = MAXIMUM NUMBER OF NODES ALLOWED BY USER.
C         NWDS = NUMBER OF WORDS PER NODE.
C         DATA = WORK AREA FOR STORING NODES.
C         N = CURRENT NUMBER OF NODES IN THE TREE.
C         T = INTEGER ARRAY OF POINTERS TO HEAP NODES.
C         XNODE = A REAL ARRAY, NWDS WORDS LONG, WHICH
C                CONTAINS THE NODAL INFORMATION TO BE INSERTED.
C         HPFUN = NAME OF USER WRITTEN FUNCTION TO DETERMINE
C                THE TOP NODE.
C   OUTPUT
C         DATA = WORK AREA WITH NEW NODE INSERTED.
C         N = UPDATED NUMBER OF NODES.
C         T = UPDATED INTEGER POINTER ARRAY.
C
      DOUBLE PRECISION XNODE(1),DATA(1)
      INTEGER T(1)
      LOGICAL HPFUN
      EXTERNAL HPFUN
      IF(N .EQ. NMAX) RETURN
      N=N+1
      J= T(N)-1
      DO 1 I= 1,NWDS
         IPJ=I+J
    1    DATA(IPJ) = XNODE(I)
      J=N
    2 CONTINUE
      IF(J .EQ. 1) RETURN
      JR=T(J)
      J2=J/2
      JL=T(J2)
      IF(HPFUN(DATA(JL),DATA(JR),NWDS)) RETURN
      T(J2)=T(J)
      T(J)=JL
      J=J2
      GO TO 2
      END


      subroutine tridv(node,node1,node2,coef,rank)
      double precision node(10),node1(10),node2(10),coef
      integer rank
      double precision s(3),coef1,temp
      integer t(3)
      coef1=1.0-coef
      s(1)=(node(3)-node(5))**2+(node(4)-node(6))**2
      s(2)=(node(5)-node(7))**2+(node(6)-node(8))**2
      s(3)=(node(3)-node(7))**2+(node(4)-node(8))**2
      t(1)=1
      t(2)=2
      t(3)=3
      do 10 i=1,2
        do 10 j=i+1,3
          if(s(i).lt.s(j)) then
            temp=t(i)
            t(i)=t(j)
            t(j)=temp
          end if
10    continue
      if(t(rank).eq.1)then
        node1(3)=coef*node(3)+coef1*node(5)
        node1(4)=coef*node(4)+coef1*node(6)
        node1(5)=node(5)
        node1(6)=node(6)
        node1(7)=node(7)
        node1(8)=node(8)
        node2(3)=node1(3)
        node2(4)=node1(4)
        node2(5)=node(7)
        node2(6)=node(8)
        node2(7)=node(3)
        node2(8)=node(4)
      else if(t(rank).eq.2) then
        node1(3)=coef*node(5)+coef1*node(7)
        node1(4)=coef*node(6)+coef1*node(8)
        node1(5)=node(7)
        node1(6)=node(8)
        node1(7)=node(3)
        node1(8)=node(4)
        node2(3)=node1(3)
        node2(4)=node1(4)
        node2(5)=node(3)
        node2(6)=node(4)
        node2(7)=node(5)
        node2(8)=node(6)
      else
        node1(3)=coef*node(3)+coef1*node(7)
        node1(4)=coef*node(4)+coef1*node(8)
        node1(5)=node(3)
        node1(6)=node(4)
        node1(7)=node(5)
        node1(8)=node(6)
        node2(3)=node1(3)
        node2(4)=node1(4)
        node2(5)=node(5)
        node2(6)=node(6)
        node2(7)=node(7)
        node2(8)=node(8)
      end if
      node1(9)=coef*node(9)
      node2(9)=coef1*node(9)
      end

      subroutine lqm0vect(f,u,v,res8,est,vectflag,stat)
*
*      PURPOSE
*           compute on approximation of I(f) = \int_T f(x,y) dx dy
*           T being the triangle with vertices (u(i),v(j)), j=1..3
*           together with an estimate the error,
*
*      PARAMETERS
*           f       - function subprogram defining the integrand.
*                     It must have the form:
*                                 func(x,y,z,n) 
*                     and should return an int. func computes 
*                     z(k) = f(x(k),y(k)) for 1<=k<=n. The returned value
*                     is used to communicate a possible failure in the
*                     computation of f (in most cases f is evaluated 
*                     by the nsp interpretor from a function written 
*                     in the nsp langage). The return value must be
*                     0 if all is OK, other value imply to return to
*                     the caller (the variable stat being used to 
*                     communicate the problem).   
*                     
*          u(1),u(2),u(3)- abscissae of vertices
*          v(1),v(2),v(3)- ordinates of vertices
*
*          res8     - approximation of I(f), obtained by the
*                     Lyness and Jespersen rule of degree 8,
*                     using 16 points
*          est      - estimate of the absolute error
*
*          vectflag - boolean TRUE if the external f could be evaluated
*                     on a vector
*
*          stat     - return 0 if the evaluation of f by the nsp interpretor
*                     is successful. Other values stop the computation and
*                     return immediatly to the caller.
* 
*
*      REMARKS
*          date of last update : 10 april 1984 o.w. rechard nbs
*
*          modified by Bruno Pincon (24 feb 2008) for nsp:
*            - add the possibility of a "vector" evaluation of f
*              (this speed-up the computation when f is evaluated
*               by the nsp interpretor).
*            - clean up the code
* 
*          subroutines or functions called :
*                   - f (user-supplied integrand function)
*                   - dlamch for machine dependent information
*
      implicit none
      integer f
      external f
      double precision u(3),v(3),res8,est
      logical vectflag
      integer stat

*     local var
      double precision r6, res6, resab6, T_area,dresc,emach,
     *                 uflow,u1,u2,u3,v1,v2,v3,w(9),w80,x(28),y(28),
     *                 fvect(28),zeta1(9),zeta2(9),z1,z2,z3
      double precision dlamch
      integer k, j, n1, n28
*
*
*     first homogeneous coordinates of points in degree-6
*     and degree-8 formula, taken with multiplicity 3
      data zeta1(1),zeta1(2),zeta1(3),zeta1(4),zeta1(5),zeta1(6),zeta1(7
     *  ),zeta1(8),zeta1(9)/0.5014265096581342d+00,
     *  0.8738219710169965d+00,0.6365024991213939d+00,
     *  0.5314504984483216d-01,0.8141482341455413d-01,
     *  0.8989055433659379d+00,0.6588613844964797d+00,
     *  0.8394777409957211d-02,0.7284923929554041d+00/
*     second homogeneous coordinates of points in degree-6
*     and degree-8 formula, taken with multiplicity 3
      data zeta2(1),zeta2(2),zeta2(3),zeta2(4),zeta2(5),zeta2(6),zeta2(7
     *  ),zeta2(8),zeta2(9)/0.2492867451709329d+00,
     *  0.6308901449150177d-01,0.5314504984483216d-01,
     *  0.6365024991213939d+00,0.4592925882927229d+00,
     *  0.5054722831703103d-01,0.1705693077517601d+00,
     *  0.7284923929554041d+00,0.8394777409957211d-02/
*     weights of mid-point of triangle in degree-6
*     resp. degree-8 formulae
      data w80/0.1443156076777862d+00/
*     weights in degree-6 and degree-8 rule
      data w(1),w(2),w(3),w(4),w(5),w(6),w(7),w(8),w(9)/
     *  0.1167862757263407d+00,0.5084490637020547d-01,
     *  0.8285107561839291d-01,0.8285107561839291d-01,
     *  0.9509163426728497d-01,0.3245849762319813d-01,
     *  0.1032173705347184d+00,0.2723031417443487d-01,
     *  0.2723031417443487d-01/
*
*           list of major variables
*           ----------------------
*          res6, resab6 and dresc are used for error estimation:
*      
*          res6     - approximation of I(f), obtained by the Lyness and 
*                     Jespersen rule of degree 6, using 12 points.
*          resab6   - approximation of I(|f|) by the rule of degree 6
*          dresc    - approximation of I(|f- I(f)/T_area|) by the rule of degree 6 
*
*          r6       - res6 / area(T) (the approximation of I(f)/T_area
*                     used to compute dresc).
*
*           x       - cartesian abscissae of the integration points
*           y       - cartesian ordinates of the integration points

*
*     various initialisation
*
      emach = dlamch('p')
      uflow = dlamch('u')
      n1 = 1
      n28 = 28
      u1=u(1)
      u2=u(2)
      u3=u(3)
      v1=v(1)
      v2=v(2)
      v3=v(3)
      T_area = 0.5d0*abs(u1*v2-u2*v1-u1*v3+v1*u3+u2*v3-v2*u3)

*
*     compute integration points for both degree-6 and degree-8 formulae
*
      k = 1
      do j=1,9
         z1 = zeta1(j)
         z2 = zeta2(j)
         z3 = 1.0d+00-z1-z2
         x(k) = z1*u1+z2*u2+z3*u3
         y(k) = z1*v1+z2*v2+z3*v3
         x(k+1) = z2*u1+z3*u2+z1*u3
         y(k+1) = z2*v1+z3*v2+z1*v3
         x(k+2) = z3*u1+z1*u2+z2*u3
         y(k+2) = z3*v1+z1*v2+z2*v3
         k = k + 3
      enddo
      x(28) = (u1+u2+u3)/3.d0
      y(28) = (v1+v2+v3)/3.d0

*
*     evaluation of the function f onto the integration points
*
      if ( vectflag) then
         stat = f(x, y, fvect, n28)
         if ( stat .ne. 0 ) return
      else
         do j = 1,28
            stat = f(x(j), y(j), fvect(j), n1)
            if ( stat .ne. 0 ) return
         enddo
      endif

*
*     compute degree-6 approximation for I(f) and I(|f|)
*
      r6 = 0.d0
      resab6 = 0.d0
      k = 1
      do j = 1, 4
         r6 = r6 + w(j)*(fvect(k) + fvect(k+1) + fvect(k+2))
         resab6 = resab6+ w(j)*(abs(fvect(k)) + abs(fvect(k+1)) + 
     *                          abs(fvect(k+2)))
         k = k + 3
      enddo
      res6 = T_area*r6
      resab6 = T_area*resab6

*
*     compute degree-8 approximation for I(f)
*
      res8 = w80*fvect(28)
      do j = 5, 9
         res8 = res8 + w(j)*(fvect(k) + fvect(k+1) + fvect(k+2))
         k = k + 3
      enddo
      res8 = T_area*res8

*
*     compute degree-6 approximation for I(|f - I(f)/T_area|)
*
      dresc = 0.d0
      k = 1
      do j = 1, 4
         dresc = dresc + w(j)*(  abs(fvect(k)-r6) 
     *                         + abs(fvect(k+1)-r6)
     *                         + abs(fvect(k+2)-r6) )
         k = k + 3
      enddo
      dresc = T_area*dresc

*
*     compute error estimate
*
      est = abs(res8-res6)
      if(dresc.ne.0.0d0) then
         est = max(est, dresc*min(1d0,(20d0*est/dresc)**1.5d0))
      endif
      if (resab6.gt.uflow) then
         est = max(emach*resab6,est)
      endif
      return
      end


      subroutine lqm1vect(f,u,v,res11,est,vectflag,stat)
*
*      PURPOSE
*           compute on approximation of I(f) = \int_T f(x,y) dx dy
*           T being the triangle with vertices (u(i),v(j)), j=1..3
*           together with an estimate the error,
*
*      PARAMETERS
*           f       - function subprogram defining the integrand.
*                     It must have the form:
*                                 func(x,y,z,n) 
*                     and should return an int. func computes 
*                     z(k) = f(x(k),y(k)) for 1<=k<=n. The returned value
*                     is used to communicate a possible failure in the
*                     computation of f (in most cases f is evaluated 
*                     by the nsp interpretor from a function written 
*                     in the nsp langage). The return value must be
*                     0 if all is OK, other value imply to return to
*                     the caller (the variable stat being used to 
*                     communicate the problem).   
*                     
*          u(1),u(2),u(3)- abscissae of vertices
*          v(1),v(2),v(3)- ordinates of vertices
*
*          res11    - approximation of I(f), obtained by the
*                     Lyness and Jespersen rule of degree 11,
*                     using 28 points
*          est      - estimate of the absolute error
*
*          vectflag - boolean TRUE if the external f could be evaluated
*                     on a vector
*
*          stat     - return 0 if the evaluation of f by the nsp interpretor
*                     is successful. Other values stop the computation and
*                     return immediatly to the caller.
* 
*
*      REMARKS
c           date of last update : 18 jan 1984 d. kahaner nbs
*
*          modified by Bruno Pincon (24 feb 2008) for nsp:
*            - add the possibility of a "vector" evaluation of f
*              (this speed-up the computation when f is evaluated
*               by the nsp interpretor).
*            - clean up the code
* 
*          subroutines or functions called :
*                   - f (user-supplied integrand function)
*                   - dlamch for machine dependent information
      implicit none
      integer f
      external f
      double precision u(3), v(3), res11, est
      logical vectflag
      integer stat

*     local var
      double precision r9, res9, resab9, T_area,dresc,emach,
     *                 uflow,u1,u2,u3,v1,v2,v3,w(15),w90,w110, 
     *                 x(46),y(46),fvect(46),zeta1(15),zeta2(15),
     *                 z1,z2,z3, f0
      double precision dlamch
      integer k, j, n1, n46
*
*     first homogeneous coordinates of points in degree-9
*     and degree-11 formula, taken with multiplicity 3
      data zeta1(1),zeta1(2),zeta1(3),zeta1(4),zeta1(5),zeta1(6),zeta1(7
     *  ),zeta1(8),zeta1(9),zeta1(10),zeta1(11),zeta1(12),zeta1(13),
     *  zeta1(14),zeta1(15)/0.2063496160252593d-01,0.1258208170141290d+
     *  00,0.6235929287619356d+00,0.9105409732110941d+00,
     *  0.3683841205473626d-01,0.7411985987844980d+00,
     *  0.9480217181434233d+00,0.8114249947041546d+00,
     *  0.1072644996557060d-01,0.5853132347709715d+00,
     *  0.1221843885990187d+00,0.4484167758913055d-01,
     *  0.6779376548825902d+00,0.0d+00,0.8588702812826364d+00/
*     second homogeneous coordinates of points in degree-9
*     and degree-11 formula, taken with munltiplicity 3
      data zeta2(1),zeta2(2),zeta2(3),zeta2(4),zeta2(5),zeta2(6),zeta2(7
     *  ),zeta2(8),zeta2(9),zeta2(10),zeta2(11),zeta2(12),zeta2(13),
     *  zeta2(14),zeta2(15)/0.4896825191987370d+00,0.4370895914929355d+
     *  00,0.1882035356190322d+00,0.4472951339445297d-01,
     *  0.7411985987844980d+00,0.3683841205473626d-01,
     *  0.2598914092828833d-01,0.9428750264792270d-01,
     *  0.4946367750172147d+00,0.2073433826145142d+00,
     *  0.4389078057004907d+00,0.6779376548825902d+00,
     *  0.4484167758913055d-01,0.8588702812826364d+00,0.0d+00/
*     weights of mid-point of triangle in degree-9
*     resp. degree-11 formulae
      data w90/0.9713579628279610d-01/
      data w110/0.8797730116222190d-01/
*     weights in degree-9 and degree-11 rule
      data w(1),w(2),w(3),w(4),w(5),w(6),w(7),w(8),w(9),w(10),w(11),w(12
     *  ),w(13),w(14),w(15)/0.3133470022713983d-01,0.7782754100477543d-
     *  01,0.7964773892720910d-01,0.2557767565869810d-01,
     *  0.4328353937728940d-01,0.4328353937728940d-01,
     *  0.8744311553736190d-02,0.3808157199393533d-01,
     *  0.1885544805613125d-01,0.7215969754474100d-01,
     *  0.6932913870553720d-01,0.4105631542928860d-01,
     *  0.4105631542928860d-01,0.7362383783300573d-02,
     *  0.7362383783300573d-02/
*
*           list of major variables
*           ----------------------
*          res9, resab9 and dresc are used for error estimation:
*      
*          res9     - approximation of I(f), obtained by the Lyness and 
*                     Jespersen rule of degree 9, using 19 points.
*          resab9   - approximation of I(|f|) by the rule of degree 9
*          dresc    - approximation of I(|f- I(f)/T_area|) by the rule of degree 9 
*
*          r9       - res9 / area(T) (the approximation of I(f)/T_area
*                     used to compute dresc).
*
*           x       - cartesian abscissae of the integration points
*           y       - cartesian ordinates of the integration points

*
*     various initialisation
*
      emach = dlamch('p')
      uflow = dlamch('u')
      n1 = 1
      n46 = 46
      u1=u(1)
      u2=u(2)
      u3=u(3)
      v1=v(1)
      v2=v(2)
      v3=v(3)
      T_area = 0.5d0*abs(u1*v2-u2*v1-u1*v3+v1*u3+u2*v3-v2*u3)

*
*     compute integration points for both degree-9 and degree-11 formulae
*
      k = 1
      do j=1,15
         z1 = zeta1(j)
         z2 = zeta2(j)
         z3 = 1.0d+00-z1-z2
         x(k) = z1*u1+z2*u2+z3*u3
         y(k) = z1*v1+z2*v2+z3*v3
         x(k+1) = z2*u1+z3*u2+z1*u3
         y(k+1) = z2*v1+z3*v2+z1*v3
         x(k+2) = z3*u1+z1*u2+z2*u3
         y(k+2) = z3*v1+z1*v2+z2*v3
         k = k + 3
      enddo
      x(46) = (u1+u2+u3)/3.d0
      y(46) = (v1+v2+v3)/3.d0

*
*     evaluation of the function f onto the integration points
*
      if ( vectflag) then
         stat = f(x, y, fvect, n46)
         if ( stat .ne. 0 ) return
      else
         do j = 1,46
            stat = f(x(j), y(j), fvect(j), n1)
            if ( stat .ne. 0 ) return
         enddo
      endif

      f0 = fvect(46)

*
*     compute degree-9 approximation for I(f) and I(|f|)
*
      r9 = w90*f0
      resab9 = w90*abs(f0)
      k = 1
      do j = 1, 6
         r9 = r9 + w(j)*(fvect(k) + fvect(k+1) + fvect(k+2))
         resab9 = resab9+ w(j)*(abs(fvect(k)) + abs(fvect(k+1)) + 
     *                          abs(fvect(k+2)))
         k = k + 3
      enddo
      res9 = T_area*r9
      resab9 = T_area*resab9

*
*     compute degree-11 approximation for I(f)
*
      res11 = w110*f0
      do j = 7, 15
         res11 = res11 + w(j)*(fvect(k) + fvect(k+1) + fvect(k+2))
         k = k + 3
      enddo
      res11 = T_area*res11

*
*     compute degree-9 approximation for I(|f - I(f)/T_area|)
*
      dresc = w90*abs(f0 - r9)
      k = 1
      do j = 1, 6
         dresc = dresc + w(j)*(  abs(fvect(k)-r9) 
     *                         + abs(fvect(k+1)-r9)
     *                         + abs(fvect(k+2)-r9) )
         k = k + 3
      enddo
      dresc = T_area*dresc

*
*     compute error estimate
*
      est = abs(res11-res9)
      if(dresc.ne.0.0d0) then
         est = max(est, dresc*min(1d0,(20d0*est/dresc)**1.5d0))
      endif
      if (resab9.gt.uflow) then
         est = max(emach*resab9,est)
      endif
      return
      end
