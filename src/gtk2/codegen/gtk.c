/* -*- Mode: C -*- */


#line 4 "gtk.override"
#include <gdk/gdk.h>
#include <gtk/gtk.h>
#include <nsp/gtk/gboxed.h>
#include <nsp/gtk/gobject.h>

#define NSP_LIST_FROM_GLIST( sel_code, free_name) \
  if (( nsp_list =nsp_list_create(NVOID,NULL) ) == NULLLIST) \
    { \
      free_name(list); \
      return RET_BUG; \
    } \
  for (tmp = list; tmp != NULL; tmp = tmp->next)  \
    { \
      NspObject *gtk_obj = (NspObject *)sel_code ;\
      if (gtk_obj == NULL) goto clean ;  \
      if ((cloc1 =nsp_cell_create("lel",gtk_obj))== NULLCELL) goto clean;  \
      cloc1->next = NULLCELL; \
      if ( cloc == NULLCELL)  \
	{ \
	  nsp_list->first = cloc1; \
	} \
      else  \
	{ \
	  cloc1->prev = cloc; cloc->next = cloc1;  \
	} \
      cloc= cloc1; \
    } \
  MoveObj(stack,1,(NspObject *)nsp_list); \
  return 1; \
  clean :  \
    { \
      free_name(list); \
      nsp_list_destroy(nsp_list); \
      return RET_BUG; \
    } 

#define NSP_OBJ_LIST_FROM_GLIST( sel_code, free_name) \
  if (( nsp_list =nsp_list_create(NVOID,NULL) ) == NULLLIST) \
    { \
      free_name(list); \
      return NULLOBJ; \
    } \
  for (tmp = list; tmp != NULL; tmp = tmp->next)  \
    { \
      NspObject *gtk_obj = (NspObject *)sel_code ;\
      if (gtk_obj == NULL) goto clean ;  \
      if ((cloc1 =nsp_cell_create("lel",gtk_obj))== NULLCELL) goto clean;  \
      cloc1->next = NULLCELL; \
      if ( cloc == NULLCELL)  \
	{ \
	  nsp_list->first = cloc1; \
	} \
      else  \
	{ \
	  cloc1->prev = cloc; cloc->next = cloc1;  \
	} \
      cloc= cloc1; \
    } \
  return (NspObject *) nsp_list; \
  clean :  \
    { \
      free_name(list); \
 nsp_list_destroy(nsp_list); \
      return NULL; \
    } 

/* Build a NspList */ 

#define NSP_LIST_DEC NspList *nsp_list; Cell * cloc = NULLCELL, *cloc1; 

#define NSP_LIST(iter_code , sel_code ) \
  if (( nsp_list =nsp_list_create(NVOID,NULL) ) == NULLLIST)  return RET_BUG; \
  iter_code \
    { NspObject *nsp_node; \
      sel_code ; \
      if ( nsp_node == NULL) goto clean ;  \
      if ((cloc1 =nsp_cell_create("lel",nsp_node))== NULLCELL) goto clean;  \
      cloc1->next = NULLCELL; \
      if ( cloc == NULLCELL)  \
	{ \
	  nsp_list->first = cloc1; \
	} \
      else  \
	{ \
	  cloc1->prev = cloc; cloc->next = cloc1;  \
	} \
      cloc= cloc1; \
    } 

#define NSP_OBJ_LIST(iter_code , sel_code ) \
  if (( nsp_list =nsp_list_create(NVOID,NULL) ) == NULLLIST)  return NULL; \
  iter_code \
    { NspObject *nsp_node; \
      sel_code ; \
      if ( nsp_node == NULL) goto clean ;  \
      if ((cloc1 =nsp_cell_create("lel",nsp_node))== NULLCELL) goto clean;  \
      cloc1->next = NULLCELL; \
      if ( cloc == NULLCELL)  \
	{ \
	  nsp_list->first = cloc1; \
	} \
      else  \
	{ \
	  cloc1->prev = cloc; cloc->next = cloc1;  \
	} \
      cloc= cloc1; \
    } 


#define NSP_LIST_CLEAN \
  clean :  \
    { \
       nsp_list_destroy(nsp_list); \
      return RET_BUG; \
    }

#define NSP_OBJ_LIST_CLEAN \
  clean :  \
    { \
      nsp_list_destroy(nsp_list); \
      return NULL; \
    }


GList *glist_from_nsp_list(Stack stack,NspList *L,NspTypeBase *type)
{
  GList *items = NULL;
  Cell *cloc = L->first ; 
  while ( cloc != NULLCELL) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  if (! nspgobject_check(cloc->O, type)) 
	    {
	      Scierror("%s:list item is not a %s",stack.fname,type_get_name(type));
	      g_list_free(items);
	      return NULL;
	    }
	  else 
	    {
	      items = g_list_append(items, nspgobject_get(cloc->O));
	    }
	}
      cloc = cloc->next;
    }
  return items ;
}

/* utility */

#define nsp_style_color_array_get_bg(x,pos)   &((x)->bg[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_fg(x,pos)   &((x)->fg[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_light(x,pos) &((x)->light[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_dark(x,pos) &((x)->dark[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_mid(x,pos) &((x)->mid[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_text(x,pos) &((x)->text[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_base(x,pos) &((x)->base[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_text_aa(x,pos) &((x)->text_aa[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_fg_gc(x,pos) ((x)->fg_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_bg_gc(x,pos) ((x)->bg_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_light_gc(x,pos) ((x)->light_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_dark_gc(x,pos) ((x)->dark_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_mid_gc(x,pos) ((x)->mid_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_text_gc(x,pos) ((x)->text_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_base_gc(x,pos) ((x)->base_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_text_aa_gc(x,pos) ((x)->text_aa_gc[Min(4,Max(0,pos))])
#define nsp_style_pixmap_array_get_bg_pixmap(x,pos) ((x)->bg_pixmap[Min(4,Max(0,pos))])

/* XXXX */

#define GtkObject_Private
#define GtkCellRenderer_Private
#define GtkTreeModel_Private 

enum {STYLE_COLOUR_ARRAY, STYLE_GC_ARRAY, STYLE_PIXMAP_ARRAY} type;

/* XXXXX a revoir */

#define PYGTK_TYPE_GENERIC_TREE_MODEL G_TYPE_INVALID
#define PYGTK_TYPE_GENERIC_CELL_RENDERER G_TYPE_INVALID
#define  GtkCellEditable_Private 
#include "nsp/gtk/gtkcelleditable.h"

/* XXXX */
extern int nsp_graphic_new(GtkWidget *win,GtkWidget *box, int v2,int *wdim,int *wpdim,double *viewport_pos,int *wpos);
extern int nsp_graphic_new_gl(GtkWidget *win,GtkWidget *box, int v2,int *wdim,int *wpdim,double *viewport_pos,int *wpos);

/* XXXXX : only implemented in 2.4 */
#define gtk_calendar_set_display_options gtk_calendar_display_options
#define gtk_calendar_get_display_options(x) 0 

#line 197 "gtk.c"


/* ---------- types from other modules ---------- */
#include "nsp/gtk/gdkatom.h"
#include "nsp/gtk/gdkpixmap.h"
#include "nsp/gtk/gdkwindow.h"
#include "nsp/gtk/gdkgc.h"
#include "nsp/gtk/gdkfont.h"
#include "nsp/gtk/gdkpixbuf.h"
#include "nsp/gtk/gdkbitmap.h"
#include "nsp/gtk/gdkpixbufanimation.h"
#include "nsp/gtk/gdkdragcontext.h"
#include "nsp/gtk/gdkcolormap.h"
#include "nsp/gtk/gdkcolor.h"
#include "nsp/gtk/gdkimage.h"
#include "nsp/gtk/gdkvisual.h"
#include "nsp/gtk/gdkrectangle.h"
#include "nsp/gtk/gdkevent.h"
#include "nsp/gtk/gdkscreen.h"
#include "nsp/gtk/gdkdisplay.h"
#include "nsp/gtk/gtktreemodel.h"
#include "nsp/gtk/pangolayout.h"
#include "nsp/gtk/pangolanguage.h"
#include "nsp/gtk/pangofontdescription.h"
#include "nsp/gtk/pangoattrlist.h"
#include "nsp/gtk/pangotabarray.h"
#include "nsp/gtk/pangocontext.h"


/* ---------- forward type declarations ---------- */
#define GtkTreePath_Private
#include "nsp/gtk/gtktreepath.h"
#define GtkRequisition_Private
#include "nsp/gtk/gtkrequisition.h"
#define GtkIconSet_Private
#include "nsp/gtk/gtkiconset.h"
#define GtkIconSource_Private
#include "nsp/gtk/gtkiconsource.h"
#define GtkSelectionData_Private
#include "nsp/gtk/gtkselectiondata.h"
#define GtkTextAttributes_Private
#include "nsp/gtk/gtktextattributes.h"
#define GtkTextIter_Private
#include "nsp/gtk/gtktextiter.h"
#define GtkTreeIter_Private
#include "nsp/gtk/gtktreeiter.h"
#define GtkAccelGroup_Private
#include "nsp/gtk/gtkaccelgroup.h"
#define GtkAccessible_Private
#include "nsp/gtk/gtkaccessible.h"
#define GtkIconFactory_Private
#include "nsp/gtk/gtkiconfactory.h"
#define GtkObject_Private
#include "nsp/gtk/gtkobject.h"
#define GtkItemFactory_Private
#include "nsp/gtk/gtkitemfactory.h"
#define GtkIMContext_Private
#include "nsp/gtk/gtkimcontext.h"
#define GtkIMContextSimple_Private
#include "nsp/gtk/gtkimcontextsimple.h"
#define GtkIMMulticontext_Private
#include "nsp/gtk/gtkimmulticontext.h"
#define GtkCellRenderer_Private
#include "nsp/gtk/gtkcellrenderer.h"
#define GtkCellRendererToggle_Private
#include "nsp/gtk/gtkcellrenderertoggle.h"
#define GtkCellRendererText_Private
#include "nsp/gtk/gtkcellrenderertext.h"
#define GtkCellRendererPixbuf_Private
#include "nsp/gtk/gtkcellrendererpixbuf.h"
#define GtkAdjustment_Private
#include "nsp/gtk/gtkadjustment.h"
#define GtkRcStyle_Private
#include "nsp/gtk/gtkrcstyle.h"
#define GtkSettings_Private
#include "nsp/gtk/gtksettings.h"
#define GtkSizeGroup_Private
#include "nsp/gtk/gtksizegroup.h"
#define GtkStyle_Private
#include "nsp/gtk/gtkstyle.h"
#define GtkTextBuffer_Private
#include "nsp/gtk/gtktextbuffer.h"
#define GtkTextChildAnchor_Private
#include "nsp/gtk/gtktextchildanchor.h"
#define GtkTextMark_Private
#include "nsp/gtk/gtktextmark.h"
#define GtkTextTag_Private
#include "nsp/gtk/gtktexttag.h"
#define GtkTextTagTable_Private
#include "nsp/gtk/gtktexttagtable.h"
#define GtkTooltips_Private
#include "nsp/gtk/gtktooltips.h"
#define GtkListStore_Private
#include "nsp/gtk/gtkliststore.h"
#define GtkTreeModelSort_Private
#include "nsp/gtk/gtktreemodelsort.h"
#define GtkTreeSelection_Private
#include "nsp/gtk/gtktreeselection.h"
#define GtkTreeStore_Private
#include "nsp/gtk/gtktreestore.h"
#define GtkTreeViewColumn_Private
#include "nsp/gtk/gtktreeviewcolumn.h"
#define GtkWidget_Private
#include "nsp/gtk/gtkwidget.h"
#define GtkSeparator_Private
#include "nsp/gtk/gtkseparator.h"
#define GtkVSeparator_Private
#include "nsp/gtk/gtkvseparator.h"
#define GtkHSeparator_Private
#include "nsp/gtk/gtkhseparator.h"
#define GtkRuler_Private
#include "nsp/gtk/gtkruler.h"
#define GtkVRuler_Private
#include "nsp/gtk/gtkvruler.h"
#define GtkHRuler_Private
#include "nsp/gtk/gtkhruler.h"
#define GtkRange_Private
#include "nsp/gtk/gtkrange.h"
#define GtkScrollbar_Private
#include "nsp/gtk/gtkscrollbar.h"
#define GtkVScrollbar_Private
#include "nsp/gtk/gtkvscrollbar.h"
#define GtkHScrollbar_Private
#include "nsp/gtk/gtkhscrollbar.h"
#define GtkScale_Private
#include "nsp/gtk/gtkscale.h"
#define GtkVScale_Private
#include "nsp/gtk/gtkvscale.h"
#define GtkHScale_Private
#include "nsp/gtk/gtkhscale.h"
#define GtkProgress_Private
#include "nsp/gtk/gtkprogress.h"
#define GtkProgressBar_Private
#include "nsp/gtk/gtkprogressbar.h"
#define GtkPreview_Private
#include "nsp/gtk/gtkpreview.h"
#define GtkOldEditable_Private
#include "nsp/gtk/gtkoldeditable.h"
#define GtkMisc_Private
#include "nsp/gtk/gtkmisc.h"
#define GtkArrow_Private
#include "nsp/gtk/gtkarrow.h"
#define GtkImage_Private
#include "nsp/gtk/gtkimage.h"
#define GtkLabel_Private
#include "nsp/gtk/gtklabel.h"
#define GtkAccelLabel_Private
#include "nsp/gtk/gtkaccellabel.h"
#define GtkInvisible_Private
#include "nsp/gtk/gtkinvisible.h"
#define GtkEntry_Private
#include "nsp/gtk/gtkentry.h"
#define GtkSpinButton_Private
#include "nsp/gtk/gtkspinbutton.h"
#define GtkDrawingArea_Private
#include "nsp/gtk/gtkdrawingarea.h"
#define GtkCurve_Private
#include "nsp/gtk/gtkcurve.h"
#define GtkContainer_Private
#include "nsp/gtk/gtkcontainer.h"
#define GtkTreeView_Private
#include "nsp/gtk/gtktreeview.h"
#define GtkToolbar_Private
#include "nsp/gtk/gtktoolbar.h"
#define GtkTextView_Private
#include "nsp/gtk/gtktextview.h"
#define GtkTable_Private
#include "nsp/gtk/gtktable.h"
#define GtkSocket_Private
#include "nsp/gtk/gtksocket.h"
#define GtkPaned_Private
#include "nsp/gtk/gtkpaned.h"
#define GtkVPaned_Private
#include "nsp/gtk/gtkvpaned.h"
#define GtkHPaned_Private
#include "nsp/gtk/gtkhpaned.h"
#define GtkNotebook_Private
#include "nsp/gtk/gtknotebook.h"
#define GtkMenuShell_Private
#include "nsp/gtk/gtkmenushell.h"
#define GtkMenu_Private
#include "nsp/gtk/gtkmenu.h"
#define GtkMenuBar_Private
#include "nsp/gtk/gtkmenubar.h"
#define GtkLayout_Private
#include "nsp/gtk/gtklayout.h"
#define GtkFixed_Private
#include "nsp/gtk/gtkfixed.h"
#define GtkBin_Private
#include "nsp/gtk/gtkbin.h"
#define GtkViewport_Private
#include "nsp/gtk/gtkviewport.h"
#define GtkScrolledWindow_Private
#include "nsp/gtk/gtkscrolledwindow.h"
#define GtkItem_Private
#include "nsp/gtk/gtkitem.h"
#define GtkMenuItem_Private
#include "nsp/gtk/gtkmenuitem.h"
#define GtkTearoffMenuItem_Private
#include "nsp/gtk/gtktearoffmenuitem.h"
#define GtkSeparatorMenuItem_Private
#include "nsp/gtk/gtkseparatormenuitem.h"
#define GtkCheckMenuItem_Private
#include "nsp/gtk/gtkcheckmenuitem.h"
#define GtkRadioMenuItem_Private
#include "nsp/gtk/gtkradiomenuitem.h"
#define GtkImageMenuItem_Private
#include "nsp/gtk/gtkimagemenuitem.h"
#define GtkHandleBox_Private
#include "nsp/gtk/gtkhandlebox.h"
#define GtkFrame_Private
#include "nsp/gtk/gtkframe.h"
#define GtkAspectFrame_Private
#include "nsp/gtk/gtkaspectframe.h"
#define GtkEventBox_Private
#include "nsp/gtk/gtkeventbox.h"
#define GtkAlignment_Private
#include "nsp/gtk/gtkalignment.h"
#define GtkButton_Private
#include "nsp/gtk/gtkbutton.h"
#define GtkToggleButton_Private
#include "nsp/gtk/gtktogglebutton.h"
#define GtkCheckButton_Private
#include "nsp/gtk/gtkcheckbutton.h"
#define GtkRadioButton_Private
#include "nsp/gtk/gtkradiobutton.h"
#define GtkOptionMenu_Private
#include "nsp/gtk/gtkoptionmenu.h"
#define GtkBox_Private
#include "nsp/gtk/gtkbox.h"
#define GtkVBox_Private
#include "nsp/gtk/gtkvbox.h"
#define GtkColorSelection_Private
#include "nsp/gtk/gtkcolorselection.h"
#define GtkFontSelection_Private
#include "nsp/gtk/gtkfontselection.h"
#define GtkGammaCurve_Private
#include "nsp/gtk/gtkgammacurve.h"
#define GtkHBox_Private
#include "nsp/gtk/gtkhbox.h"
#define GtkStatusbar_Private
#include "nsp/gtk/gtkstatusbar.h"
#define GtkCombo_Private
#include "nsp/gtk/gtkcombo.h"
#define GtkButtonBox_Private
#include "nsp/gtk/gtkbuttonbox.h"
#define GtkVButtonBox_Private
#include "nsp/gtk/gtkvbuttonbox.h"
#define GtkHButtonBox_Private
#include "nsp/gtk/gtkhbuttonbox.h"
#define GtkCalendar_Private
#include "nsp/gtk/gtkcalendar.h"
#define GtkWindow_Private
#include "nsp/gtk/gtkwindow.h"
#define GtkPlug_Private
#include "nsp/gtk/gtkplug.h"
#define GtkDialog_Private
#include "nsp/gtk/gtkdialog.h"
#define GtkMessageDialog_Private
#include "nsp/gtk/gtkmessagedialog.h"
#define GtkInputDialog_Private
#include "nsp/gtk/gtkinputdialog.h"
#define GtkFontSelectionDialog_Private
#include "nsp/gtk/gtkfontselectiondialog.h"
#define GtkFileSelection_Private
#include "nsp/gtk/gtkfileselection.h"
#define GtkColorSelectionDialog_Private
#include "nsp/gtk/gtkcolorselectiondialog.h"
#define GtkWindowGroup_Private
#include "nsp/gtk/gtkwindowgroup.h"
#define GtkWindowGroup_Private
#include "nsp/gtk/gtkwindowgroup.h"
#define GtkWindowGroup_Private
#include "nsp/gtk/gtkwindowgroup.h"
#define GtkWindowGroup_Private
#include "nsp/gtk/gtkwindowgroup.h"
#define GtkWindowGroup_Private
#include "nsp/gtk/gtkwindowgroup.h"
#define GtkWindowGroup_Private
#include "nsp/gtk/gtkwindowgroup.h"
#define GtkWindowGroup_Private
#include "nsp/gtk/gtkwindowgroup.h"


/* ----------- GtkTreePath ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTreePath_Private 
#include "nsp/gtk/gtktreepath.h"
#include "nsp/interf.h"

/* NspGtkTreePath inherits from NspGBoxed */ 

int nsp_type_gtktreepath_id=0;
NspTypeGtkTreePath *nsp_type_gtktreepath=NULL;

NspTypeGtkTreePath *new_type_gtktreepath(type_mode mode)
{
  NspTypeGtkTreePath *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreepath != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreepath;
    }
  if ((type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreepath_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktreepath_get_methods; 
  type->new = (new_func *) new_gtktreepath;

  /* specific methods for gtktreepath */
      
  type->init = (init_func *) init_gtktreepath;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktreepath */ 

  top->s_type =  (s_type_func *) gtktreepath_type_as_string;    
  top->sh_type = (sh_type_func *) gtktreepath_type_short_string;
  /* top->create = (create_func*) int_gtktreepath_create;*/ 
  
  /* specific methods for gtktreepath */
      
  type->init = (init_func *) init_gtktreepath;

  if ( nsp_type_gtktreepath_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreePath called nsp_type_gtktreepath
       */
      type->id =  nsp_type_gtktreepath_id = nsp_new_type_id();
      nsp_type_gtktreepath = type;
      if ( nsp_register_type(nsp_type_gtktreepath) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreepath, GTK_TYPE_TREE_PATH);
      return ( mode == T_BASE ) ? type : new_type_gtktreepath(mode);
    }
  else 
    {
       type->id = nsp_type_gtktreepath_id;
       return type;
    }
}

/*
 * initialize GtkTreePath instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreepath(NspGtkTreePath *o,NspTypeGtkTreePath *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTreePath 
 */

NspGtkTreePath *new_gtktreepath() 
{
  NspGtkTreePath *loc; 
  /* type must exists */
  nsp_type_gtktreepath = new_type_gtktreepath(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreePath)))== NULLGTKTREEPATH) return loc;
  /* initialize object */
  if ( init_gtktreepath(loc,nsp_type_gtktreepath) == FAIL) return NULLGTKTREEPATH;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTreePath 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktreepath_type_name[]="GtkTreePath";
static char gtktreepath_short_type_name[]="GtkTreePath";

static char *gtktreepath_type_as_string(void)
{
  return(gtktreepath_type_name);
}

static char *gtktreepath_type_short_string(void)
{
  return(gtktreepath_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTreePath objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTreePath   *gtktreepath_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktreepath_id) ) return ((NspGtkTreePath *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreepath));
  return NULL;
}

int IsGtkTreePathObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktreepath_id);
}

int IsGtkTreePath(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreepath_id);
}

NspGtkTreePath  *GetGtkTreePathCopy(Stack stack, int i)
{
  if (  GetGtkTreePath(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreePath  *GetGtkTreePath(Stack stack, int i)
{
  NspGtkTreePath *M;
  if (( M = gtktreepath_object(NthObj(i))) == NULLGTKTREEPATH)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkTreePath *gtktreepath_copy(NspGtkTreePath *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtktreepath);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreePath
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTreePath *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktreepath is initialized * /
  nsp_type_gtktreepath = new_type_gtktreepath(T_BASE);
  if(( H = gboxed_create(NVOID,(NspTypeBase *) nsp_type_gtktreepath)) == NULLGTKTREEPATH) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 238 "gtk.override"
static int
_wrap_gtktreepath_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(1,1);
  if ((ret = (GObject *)nsp_gtk_tree_path_from_nspobject(NthObj(1)))== NULL) 
    {
      Scierror("Error: enable to create a GtkTreePath\n");
      return RET_BUG;
    }
  nsp_type_gtktreepath = new_type_gtktreepath(T_BASE);
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

NspObject *nsp_gtk_tree_path_to_nspobject(GtkTreePath *path)
{
  gint len, i, *indices;
  NspObject *ret; 
  len = gtk_tree_path_get_depth(path);
  indices = gtk_tree_path_get_indices(path);
  if ((ret = (NspObject *) nsp_matrix_create(NVOID,'r',1,len))== NULL) return NULL;
  for (i = 0; i < len; i++) ((NspMatrix *) ret)->R[i]= indices[i];
  return ret;
}

GtkTreePath *nsp_gtk_tree_path_from_nspobject(NspObject *object)
{
  GtkTreePath *path;
  /** Follow pointer **/
  HOBJ_GET_OBJECT(object,NULL);
  
  if ( IsGtkTreePath(object) )
    {
      return g_boxed_copy(GTK_TYPE_TREE_PATH,nspg_boxed_get(object,GtkTreePath));
    }
  
  if ( IsString(object)) 
    {
      path = gtk_tree_path_new_from_string(((NspSMatrix *) object)->S[0]);
      return path;
    }
  else if (IsMat(object) && ((NspMatrix *) object)->rc_type == 'r')
    {
      int i;
      NspMatrix *M = (NspMatrix *) object;
      path = gtk_tree_path_new();
      for (i = 0; i < M->mn; i++)  gtk_tree_path_append_index(path,(gint) M->R[i]);
      return path;
    }
  return NULL;
}
#line 730 "gtk.c"


static int _wrap_gtk_tree_path_to_string(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;

  ret = gtk_tree_path_to_string(NSP_GBOXED_GET(self, GtkTreePath));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_tree_path_append_index(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int index;

  if ( GetArgs(stack,rhs,opt,T,&index) == FAIL) return RET_BUG;
  gtk_tree_path_append_index(NSP_GBOXED_GET(self, GtkTreePath), index);
  return 0;
}

static int _wrap_gtk_tree_path_prepend_index(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int index;

  if ( GetArgs(stack,rhs,opt,T,&index) == FAIL) return RET_BUG;
  gtk_tree_path_prepend_index(NSP_GBOXED_GET(self, GtkTreePath), index);
  return 0;
}

static int _wrap_gtk_tree_path_get_depth(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_path_get_depth(NSP_GBOXED_GET(self, GtkTreePath));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 294 "gtk.override"
static int 
_wrap_gtk_tree_path_get_indices(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreePath *path = NSP_GBOXED_GET(self, GtkTreePath);
  NspObject *ret;
  if ((ret = nsp_gtk_tree_path_to_nspobject(path))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1;
}
#line 782 "gtk.c"


static int _wrap_gtk_tree_path_compare(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_b;
  GtkTreePath *b = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_b) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_b, GTK_TYPE_TREE_PATH))
      b = nspg_boxed_get(nsp_b, GtkTreePath);
  else {
      Scierror( "b should be a GtkTreePath");
      return RET_BUG;
  }
  ret = gtk_tree_path_compare(NSP_GBOXED_GET(self, GtkTreePath), b);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_path_next(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_path_next(NSP_GBOXED_GET(self, GtkTreePath));
  return 0;
}

static int _wrap_gtk_tree_path_prev(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_path_prev(NSP_GBOXED_GET(self, GtkTreePath));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_path_up(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_path_up(NSP_GBOXED_GET(self, GtkTreePath));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_path_down(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_path_down(NSP_GBOXED_GET(self, GtkTreePath));
  return 0;
}

static int _wrap_gtk_tree_path_is_ancestor(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_descendant;
  GtkTreePath *descendant = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_descendant) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_descendant, GTK_TYPE_TREE_PATH))
      descendant = nspg_boxed_get(nsp_descendant, GtkTreePath);
  else {
      Scierror( "descendant should be a GtkTreePath");
      return RET_BUG;
  }
  ret = gtk_tree_path_is_ancestor(NSP_GBOXED_GET(self, GtkTreePath), descendant);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_path_is_descendant(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_ancestor;
  GtkTreePath *ancestor = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_ancestor) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_ancestor, GTK_TYPE_TREE_PATH))
      ancestor = nspg_boxed_get(nsp_ancestor, GtkTreePath);
  else {
      Scierror( "ancestor should be a GtkTreePath");
      return RET_BUG;
  }
  ret = gtk_tree_path_is_descendant(NSP_GBOXED_GET(self, GtkTreePath), ancestor);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktreepath_methods[] = {
  {"to_string",(nsp_method *) _wrap_gtk_tree_path_to_string},
  {"append_index",(nsp_method *) _wrap_gtk_tree_path_append_index},
  {"prepend_index",(nsp_method *) _wrap_gtk_tree_path_prepend_index},
  {"get_depth",(nsp_method *) _wrap_gtk_tree_path_get_depth},
  {"get_indices",(nsp_method *) _wrap_gtk_tree_path_get_indices},
  {"compare",(nsp_method *) _wrap_gtk_tree_path_compare},
  {"next",(nsp_method *) _wrap_gtk_tree_path_next},
  {"prev",(nsp_method *) _wrap_gtk_tree_path_prev},
  {"up",(nsp_method *) _wrap_gtk_tree_path_up},
  {"down",(nsp_method *) _wrap_gtk_tree_path_down},
  {"is_ancestor",(nsp_method *) _wrap_gtk_tree_path_is_ancestor},
  {"is_descendant",(nsp_method *) _wrap_gtk_tree_path_is_descendant},
  { NULL, NULL}
};

static NspMethods *gtktreepath_get_methods(void) { return gtktreepath_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreepath_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkRequisition ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkRequisition_Private 
#include "nsp/gtk/gtkrequisition.h"
#include "nsp/interf.h"

/* NspGtkRequisition inherits from NspGBoxed */ 

int nsp_type_gtkrequisition_id=0;
NspTypeGtkRequisition *nsp_type_gtkrequisition=NULL;

NspTypeGtkRequisition *new_type_gtkrequisition(type_mode mode)
{
  NspTypeGtkRequisition *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkrequisition != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkrequisition;
    }
  if ((type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkrequisition_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkrequisition_get_methods; 
  type->new = (new_func *) new_gtkrequisition;

  /* specific methods for gtkrequisition */
      
  type->init = (init_func *) init_gtkrequisition;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkrequisition */ 

  top->s_type =  (s_type_func *) gtkrequisition_type_as_string;    
  top->sh_type = (sh_type_func *) gtkrequisition_type_short_string;
  /* top->create = (create_func*) int_gtkrequisition_create;*/ 
  
  /* specific methods for gtkrequisition */
      
  type->init = (init_func *) init_gtkrequisition;

  if ( nsp_type_gtkrequisition_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRequisition called nsp_type_gtkrequisition
       */
      type->id =  nsp_type_gtkrequisition_id = nsp_new_type_id();
      nsp_type_gtkrequisition = type;
      if ( nsp_register_type(nsp_type_gtkrequisition) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkrequisition, GTK_TYPE_REQUISITION);
      return ( mode == T_BASE ) ? type : new_type_gtkrequisition(mode);
    }
  else 
    {
       type->id = nsp_type_gtkrequisition_id;
       return type;
    }
}

/*
 * initialize GtkRequisition instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkrequisition(NspGtkRequisition *o,NspTypeGtkRequisition *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkRequisition 
 */

NspGtkRequisition *new_gtkrequisition() 
{
  NspGtkRequisition *loc; 
  /* type must exists */
  nsp_type_gtkrequisition = new_type_gtkrequisition(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRequisition)))== NULLGTKREQUISITION) return loc;
  /* initialize object */
  if ( init_gtkrequisition(loc,nsp_type_gtkrequisition) == FAIL) return NULLGTKREQUISITION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkRequisition 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkrequisition_type_name[]="GtkRequisition";
static char gtkrequisition_short_type_name[]="GtkRequisition";

static char *gtkrequisition_type_as_string(void)
{
  return(gtkrequisition_type_name);
}

static char *gtkrequisition_type_short_string(void)
{
  return(gtkrequisition_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkRequisition objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkRequisition   *gtkrequisition_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkrequisition_id) ) return ((NspGtkRequisition *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkrequisition));
  return NULL;
}

int IsGtkRequisitionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkrequisition_id);
}

int IsGtkRequisition(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkrequisition_id);
}

NspGtkRequisition  *GetGtkRequisitionCopy(Stack stack, int i)
{
  if (  GetGtkRequisition(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRequisition  *GetGtkRequisition(Stack stack, int i)
{
  NspGtkRequisition *M;
  if (( M = gtkrequisition_object(NthObj(i))) == NULLGTKREQUISITION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkRequisition *gtkrequisition_copy(NspGtkRequisition *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtkrequisition);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRequisition
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkRequisition *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkrequisition is initialized * /
  nsp_type_gtkrequisition = new_type_gtkrequisition(T_BASE);
  if(( H = gboxed_create(NVOID,(NspTypeBase *) nsp_type_gtkrequisition)) == NULLGTKREQUISITION) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_requisition_copy(NspGtkRequisition *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkRequisition *ret;

  ret = gtk_requisition_copy(NSP_GBOXED_GET(self, GtkRequisition));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_REQUISITION, ret, FALSE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkrequisition))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_requisition_free(NspGtkRequisition *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_requisition_free(NSP_GBOXED_GET(self, GtkRequisition));
  return 0;
}

static NspMethods gtkrequisition_methods[] = {
  {"copy",(nsp_method *) _wrap_gtk_requisition_copy},
  {"free",(nsp_method *) _wrap_gtk_requisition_free},
  { NULL, NULL}
};

static NspMethods *gtkrequisition_get_methods(void) { return gtkrequisition_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

#line 4575 "gtk.override"
static int
_wrap_gtk_requisition__set_width(NspGBoxed *self, char *attr, NspObject *value)
{
  int val;/* XXXXX gint */
  if ( IntScalar(value,&val) == FAIL) return FAIL;
  nspg_boxed_get(self, GtkRequisition)->width = val;
  return OK;
}
#line 1128 "gtk.c"
static NspObject *_wrap_gtk_requisition__get_width(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkRequisition)->width;
  return nsp_new_double_obj((double) ret);
}

#line 4585 "gtk.override"
static int
_wrap_gtk_requisition__set_height(NspGBoxed *self, char *attr, NspObject *value)
{
  int val; /* XXXXX gint */
  if ( IntScalar(value,&val) == FAIL) return FAIL;
  nspg_boxed_get(self, GtkRequisition)->height = val;
  return 0;
}
#line 1146 "gtk.c"
static NspObject *_wrap_gtk_requisition__get_height(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkRequisition)->height;
  return nsp_new_double_obj((double) ret);
}

static AttrTab gtkrequisition_attrs[] = {
  { "width", (attr_get_function *)_wrap_gtk_requisition__get_width, (attr_set_function *)_wrap_gtk_requisition__set_width,(attr_get_object_function *)int_get_object_failed },
  { "height", (attr_get_function *)_wrap_gtk_requisition__get_height, (attr_set_function *)_wrap_gtk_requisition__set_height,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkIconSet ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkIconSet_Private 
#include "nsp/gtk/gtkiconset.h"
#include "nsp/interf.h"

/* NspGtkIconSet inherits from NspGBoxed */ 

int nsp_type_gtkiconset_id=0;
NspTypeGtkIconSet *nsp_type_gtkiconset=NULL;

NspTypeGtkIconSet *new_type_gtkiconset(type_mode mode)
{
  NspTypeGtkIconSet *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkiconset != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkiconset;
    }
  if ((type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkiconset_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkiconset_get_methods; 
  type->new = (new_func *) new_gtkiconset;

  /* specific methods for gtkiconset */
      
  type->init = (init_func *) init_gtkiconset;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkiconset */ 

  top->s_type =  (s_type_func *) gtkiconset_type_as_string;    
  top->sh_type = (sh_type_func *) gtkiconset_type_short_string;
  /* top->create = (create_func*) int_gtkiconset_create;*/ 
  
  /* specific methods for gtkiconset */
      
  type->init = (init_func *) init_gtkiconset;

  if ( nsp_type_gtkiconset_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIconSet called nsp_type_gtkiconset
       */
      type->id =  nsp_type_gtkiconset_id = nsp_new_type_id();
      nsp_type_gtkiconset = type;
      if ( nsp_register_type(nsp_type_gtkiconset) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkiconset, GTK_TYPE_ICON_SET);
      return ( mode == T_BASE ) ? type : new_type_gtkiconset(mode);
    }
  else 
    {
       type->id = nsp_type_gtkiconset_id;
       return type;
    }
}

/*
 * initialize GtkIconSet instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkiconset(NspGtkIconSet *o,NspTypeGtkIconSet *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkIconSet 
 */

NspGtkIconSet *new_gtkiconset() 
{
  NspGtkIconSet *loc; 
  /* type must exists */
  nsp_type_gtkiconset = new_type_gtkiconset(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIconSet)))== NULLGTKICONSET) return loc;
  /* initialize object */
  if ( init_gtkiconset(loc,nsp_type_gtkiconset) == FAIL) return NULLGTKICONSET;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkIconSet 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkiconset_type_name[]="GtkIconSet";
static char gtkiconset_short_type_name[]="GtkIconSet";

static char *gtkiconset_type_as_string(void)
{
  return(gtkiconset_type_name);
}

static char *gtkiconset_type_short_string(void)
{
  return(gtkiconset_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkIconSet objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkIconSet   *gtkiconset_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkiconset_id) ) return ((NspGtkIconSet *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkiconset));
  return NULL;
}

int IsGtkIconSetObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkiconset_id);
}

int IsGtkIconSet(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkiconset_id);
}

NspGtkIconSet  *GetGtkIconSetCopy(Stack stack, int i)
{
  if (  GetGtkIconSet(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIconSet  *GetGtkIconSet(Stack stack, int i)
{
  NspGtkIconSet *M;
  if (( M = gtkiconset_object(NthObj(i))) == NULLGTKICONSET)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkIconSet *gtkiconset_copy(NspGtkIconSet *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtkiconset);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIconSet
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkIconSet *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkiconset is initialized * /
  nsp_type_gtkiconset = new_type_gtkiconset(T_BASE);
  if(( H = gboxed_create(NVOID,(NspTypeBase *) nsp_type_gtkiconset)) == NULLGTKICONSET) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 5986 "gtk.override"
/* XXXXX ce qui suit devrait etre dans icon_set_new */ 
static int
_wrap_gtk_icon_set_new_from_pixbuf(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkIconSet *ret;
  NspGObject *pixbuf = NULL;
  CheckRhs(0,1);
  CheckLhs(1,1); 
  if ( rhs == 1) 
    {
      if ((pixbuf = GetGObject(stack,1)) == NULL) return RET_BUG; 
      if ( !nspgobject_check(pixbuf,(NspTypeBase *) nsp_type_gdkpixbuf)) { 
        Scierror("first argument should be a GdkPixbuf");
        return RET_BUG;
      }
    }
  if (pixbuf)
    ret =  gtk_icon_set_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
  else
    ret =  gtk_icon_set_new();
  if ( ret == NULL ) 
    {
      Scierror("could not create GtkIconSet object");
      return RET_BUG;
    }      
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_SET, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconset))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}


static int 
_wrap_gtkiconset_new(Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_gtk_icon_set_new_from_pixbuf(stack,rhs,opt,lhs);
}
#line 1396 "gtk.c"


static int _wrap_gtk_icon_set_copy(NspGtkIconSet *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkIconSet *ret;

  ret = gtk_icon_set_copy(NSP_GBOXED_GET(self, GtkIconSet));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_SET, ret, FALSE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconset))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_icon_set_render_icon(NspGtkIconSet *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj_check, string,t_end};
  NspObject *nsp_direction = NULL, *nsp_state = NULL, *nsp_size = NULL, *nsp_ret;
  NspGObject *style, *widget;
  GdkPixbuf *ret;
  char *detail;
  GtkIconSize size;
  GtkTextDirection direction;
  GtkStateType state;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstyle, &style, &nsp_direction, &nsp_state, &nsp_size, &nsp_type_gtkwidget, &widget, &detail) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, nsp_direction, &direction)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state, &state)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
  ret = gtk_icon_set_render_icon(NSP_GBOXED_GET(self, GtkIconSet), GTK_STYLE(style->obj), direction, state, size, GTK_WIDGET(widget->obj), detail);
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_icon_set_add_source(NspGtkIconSet *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkIconSource *source = NULL;
  NspObject *nsp_source;

  if ( GetArgs(stack,rhs,opt,T,&nsp_source) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_source, GTK_TYPE_ICON_SOURCE))
      source = nspg_boxed_get(nsp_source, GtkIconSource);
  else {
      Scierror( "source should be a GtkIconSource");
      return RET_BUG;
  }
  gtk_icon_set_add_source(NSP_GBOXED_GET(self, GtkIconSet), source);
  return 0;
}

#line 6027 "gtk.override"
static int
_wrap_gtk_icon_set_get_sizes(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkIconSize *sizes;
  int i, n_sizes;
  NspMatrix  *ret;

  gtk_icon_set_get_sizes(nspg_boxed_get(self, GtkIconSet), &sizes, &n_sizes);
  if (( ret = nsp_matrix_create(NVOID,'r',1,n_sizes))==NULLMAT) return RET_BUG;
  for (i = 0; i < n_sizes; i++)  ret->R[i]= sizes[i];
  MoveObj(stack,1,(NspObject *) ret) ; 
  return 1;
}
#line 1468 "gtk.c"


static NspMethods gtkiconset_methods[] = {
  {"copy",(nsp_method *) _wrap_gtk_icon_set_copy},
  {"render_icon",(nsp_method *) _wrap_gtk_icon_set_render_icon},
  {"add_source",(nsp_method *) _wrap_gtk_icon_set_add_source},
  {"get_sizes",(nsp_method *) _wrap_gtk_icon_set_get_sizes},
  { NULL, NULL}
};

static NspMethods *gtkiconset_get_methods(void) { return gtkiconset_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkiconset_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkIconSource ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkIconSource_Private 
#include "nsp/gtk/gtkiconsource.h"
#include "nsp/interf.h"

/* NspGtkIconSource inherits from NspGBoxed */ 

int nsp_type_gtkiconsource_id=0;
NspTypeGtkIconSource *nsp_type_gtkiconsource=NULL;

NspTypeGtkIconSource *new_type_gtkiconsource(type_mode mode)
{
  NspTypeGtkIconSource *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkiconsource != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkiconsource;
    }
  if ((type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkiconsource_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkiconsource_get_methods; 
  type->new = (new_func *) new_gtkiconsource;

  /* specific methods for gtkiconsource */
      
  type->init = (init_func *) init_gtkiconsource;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkiconsource */ 

  top->s_type =  (s_type_func *) gtkiconsource_type_as_string;    
  top->sh_type = (sh_type_func *) gtkiconsource_type_short_string;
  /* top->create = (create_func*) int_gtkiconsource_create;*/ 
  
  /* specific methods for gtkiconsource */
      
  type->init = (init_func *) init_gtkiconsource;

  if ( nsp_type_gtkiconsource_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIconSource called nsp_type_gtkiconsource
       */
      type->id =  nsp_type_gtkiconsource_id = nsp_new_type_id();
      nsp_type_gtkiconsource = type;
      if ( nsp_register_type(nsp_type_gtkiconsource) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkiconsource, GTK_TYPE_ICON_SOURCE);
      return ( mode == T_BASE ) ? type : new_type_gtkiconsource(mode);
    }
  else 
    {
       type->id = nsp_type_gtkiconsource_id;
       return type;
    }
}

/*
 * initialize GtkIconSource instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkiconsource(NspGtkIconSource *o,NspTypeGtkIconSource *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkIconSource 
 */

NspGtkIconSource *new_gtkiconsource() 
{
  NspGtkIconSource *loc; 
  /* type must exists */
  nsp_type_gtkiconsource = new_type_gtkiconsource(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIconSource)))== NULLGTKICONSOURCE) return loc;
  /* initialize object */
  if ( init_gtkiconsource(loc,nsp_type_gtkiconsource) == FAIL) return NULLGTKICONSOURCE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkIconSource 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkiconsource_type_name[]="GtkIconSource";
static char gtkiconsource_short_type_name[]="GtkIconSource";

static char *gtkiconsource_type_as_string(void)
{
  return(gtkiconsource_type_name);
}

static char *gtkiconsource_type_short_string(void)
{
  return(gtkiconsource_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkIconSource objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkIconSource   *gtkiconsource_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkiconsource_id) ) return ((NspGtkIconSource *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkiconsource));
  return NULL;
}

int IsGtkIconSourceObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkiconsource_id);
}

int IsGtkIconSource(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkiconsource_id);
}

NspGtkIconSource  *GetGtkIconSourceCopy(Stack stack, int i)
{
  if (  GetGtkIconSource(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIconSource  *GetGtkIconSource(Stack stack, int i)
{
  NspGtkIconSource *M;
  if (( M = gtkiconsource_object(NthObj(i))) == NULLGTKICONSOURCE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkIconSource *gtkiconsource_copy(NspGtkIconSource *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtkiconsource);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIconSource
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkIconSource *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkiconsource is initialized * /
  nsp_type_gtkiconsource = new_type_gtkiconsource(T_BASE);
  if(( H = gboxed_create(NVOID,(NspTypeBase *) nsp_type_gtkiconsource)) == NULLGTKICONSOURCE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkiconsource_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_icon_source_new())== NULL) return RET_BUG;

  nsp_type_gtkiconsource = new_type_gtkiconsource(T_BASE);
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_SOURCE, ret,TRUE,TRUE,(NspTypeBase *) nsp_type_gtkiconsource );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_icon_source_copy(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkIconSource *ret;
  NspObject *nsp_ret;

  ret = gtk_icon_source_copy(NSP_GBOXED_GET(self, GtkIconSource));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_SOURCE, ret, FALSE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconsource))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_icon_source_free(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_icon_source_free(NSP_GBOXED_GET(self, GtkIconSource));
  return 0;
}

static int _wrap_gtk_icon_source_set_filename(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *filename;

  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
  gtk_icon_source_set_filename(NSP_GBOXED_GET(self, GtkIconSource), filename);
  return 0;
}

static int _wrap_gtk_icon_source_set_pixbuf(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *pixbuf;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
  gtk_icon_source_set_pixbuf(NSP_GBOXED_GET(self, GtkIconSource), GDK_PIXBUF(pixbuf->obj));
  return 0;
}

static int _wrap_gtk_icon_source_get_filename(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_icon_source_get_filename(NSP_GBOXED_GET(self, GtkIconSource));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_source_get_pixbuf(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;

  ret = gtk_icon_source_get_pixbuf(NSP_GBOXED_GET(self, GtkIconSource));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_icon_source_set_direction_wildcarded(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_icon_source_set_direction_wildcarded(NSP_GBOXED_GET(self, GtkIconSource), setting);
  return 0;
}

static int _wrap_gtk_icon_source_set_state_wildcarded(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_icon_source_set_state_wildcarded(NSP_GBOXED_GET(self, GtkIconSource), setting);
  return 0;
}

static int _wrap_gtk_icon_source_set_size_wildcarded(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_icon_source_set_size_wildcarded(NSP_GBOXED_GET(self, GtkIconSource), setting);
  return 0;
}

static int _wrap_gtk_icon_source_get_size_wildcarded(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_icon_source_get_size_wildcarded(NSP_GBOXED_GET(self, GtkIconSource));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_source_get_state_wildcarded(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_icon_source_get_state_wildcarded(NSP_GBOXED_GET(self, GtkIconSource));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_source_get_direction_wildcarded(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_icon_source_get_direction_wildcarded(NSP_GBOXED_GET(self, GtkIconSource));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_source_set_direction(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTextDirection direction;
  NspObject *nsp_direction = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_direction) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, nsp_direction, &direction)== FAIL)
      return RET_BUG;
  gtk_icon_source_set_direction(NSP_GBOXED_GET(self, GtkIconSource), direction);
  return 0;
}

static int _wrap_gtk_icon_source_set_state(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkStateType state;
  NspObject *nsp_state = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_state) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state, &state)== FAIL)
      return RET_BUG;
  gtk_icon_source_set_state(NSP_GBOXED_GET(self, GtkIconSource), state);
  return 0;
}

static int _wrap_gtk_icon_source_set_size(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkIconSize size;
  NspObject *nsp_size = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
  gtk_icon_source_set_size(NSP_GBOXED_GET(self, GtkIconSource), size);
  return 0;
}

static int _wrap_gtk_icon_source_get_direction(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_icon_source_get_direction(NSP_GBOXED_GET(self, GtkIconSource));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_source_get_state(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_icon_source_get_state(NSP_GBOXED_GET(self, GtkIconSource));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_source_get_size(NspGtkIconSource *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_icon_source_get_size(NSP_GBOXED_GET(self, GtkIconSource));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkiconsource_methods[] = {
  {"copy",(nsp_method *) _wrap_gtk_icon_source_copy},
  {"free",(nsp_method *) _wrap_gtk_icon_source_free},
  {"set_filename",(nsp_method *) _wrap_gtk_icon_source_set_filename},
  {"set_pixbuf",(nsp_method *) _wrap_gtk_icon_source_set_pixbuf},
  {"get_filename",(nsp_method *) _wrap_gtk_icon_source_get_filename},
  {"get_pixbuf",(nsp_method *) _wrap_gtk_icon_source_get_pixbuf},
  {"set_direction_wildcarded",(nsp_method *) _wrap_gtk_icon_source_set_direction_wildcarded},
  {"set_state_wildcarded",(nsp_method *) _wrap_gtk_icon_source_set_state_wildcarded},
  {"set_size_wildcarded",(nsp_method *) _wrap_gtk_icon_source_set_size_wildcarded},
  {"get_size_wildcarded",(nsp_method *) _wrap_gtk_icon_source_get_size_wildcarded},
  {"get_state_wildcarded",(nsp_method *) _wrap_gtk_icon_source_get_state_wildcarded},
  {"get_direction_wildcarded",(nsp_method *) _wrap_gtk_icon_source_get_direction_wildcarded},
  {"set_direction",(nsp_method *) _wrap_gtk_icon_source_set_direction},
  {"set_state",(nsp_method *) _wrap_gtk_icon_source_set_state},
  {"set_size",(nsp_method *) _wrap_gtk_icon_source_set_size},
  {"get_direction",(nsp_method *) _wrap_gtk_icon_source_get_direction},
  {"get_state",(nsp_method *) _wrap_gtk_icon_source_get_state},
  {"get_size",(nsp_method *) _wrap_gtk_icon_source_get_size},
  { NULL, NULL}
};

static NspMethods *gtkiconsource_get_methods(void) { return gtkiconsource_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkiconsource_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkSelectionData ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkSelectionData_Private 
#include "nsp/gtk/gtkselectiondata.h"
#include "nsp/interf.h"

/* NspGtkSelectionData inherits from NspGBoxed */ 

int nsp_type_gtkselectiondata_id=0;
NspTypeGtkSelectionData *nsp_type_gtkselectiondata=NULL;

NspTypeGtkSelectionData *new_type_gtkselectiondata(type_mode mode)
{
  NspTypeGtkSelectionData *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkselectiondata != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkselectiondata;
    }
  if ((type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkselectiondata_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkselectiondata_get_methods; 
  type->new = (new_func *) new_gtkselectiondata;

  /* specific methods for gtkselectiondata */
      
  type->init = (init_func *) init_gtkselectiondata;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkselectiondata */ 

  top->s_type =  (s_type_func *) gtkselectiondata_type_as_string;    
  top->sh_type = (sh_type_func *) gtkselectiondata_type_short_string;
  /* top->create = (create_func*) int_gtkselectiondata_create;*/ 
  
  /* specific methods for gtkselectiondata */
      
  type->init = (init_func *) init_gtkselectiondata;

  if ( nsp_type_gtkselectiondata_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSelectionData called nsp_type_gtkselectiondata
       */
      type->id =  nsp_type_gtkselectiondata_id = nsp_new_type_id();
      nsp_type_gtkselectiondata = type;
      if ( nsp_register_type(nsp_type_gtkselectiondata) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkselectiondata, GTK_TYPE_SELECTION_DATA);
      return ( mode == T_BASE ) ? type : new_type_gtkselectiondata(mode);
    }
  else 
    {
       type->id = nsp_type_gtkselectiondata_id;
       return type;
    }
}

/*
 * initialize GtkSelectionData instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkselectiondata(NspGtkSelectionData *o,NspTypeGtkSelectionData *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkSelectionData 
 */

NspGtkSelectionData *new_gtkselectiondata() 
{
  NspGtkSelectionData *loc; 
  /* type must exists */
  nsp_type_gtkselectiondata = new_type_gtkselectiondata(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSelectionData)))== NULLGTKSELECTIONDATA) return loc;
  /* initialize object */
  if ( init_gtkselectiondata(loc,nsp_type_gtkselectiondata) == FAIL) return NULLGTKSELECTIONDATA;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkSelectionData 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkselectiondata_type_name[]="GtkSelectionData";
static char gtkselectiondata_short_type_name[]="GtkSelectionData";

static char *gtkselectiondata_type_as_string(void)
{
  return(gtkselectiondata_type_name);
}

static char *gtkselectiondata_type_short_string(void)
{
  return(gtkselectiondata_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkSelectionData objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkSelectionData   *gtkselectiondata_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkselectiondata_id) ) return ((NspGtkSelectionData *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkselectiondata));
  return NULL;
}

int IsGtkSelectionDataObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkselectiondata_id);
}

int IsGtkSelectionData(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkselectiondata_id);
}

NspGtkSelectionData  *GetGtkSelectionDataCopy(Stack stack, int i)
{
  if (  GetGtkSelectionData(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSelectionData  *GetGtkSelectionData(Stack stack, int i)
{
  NspGtkSelectionData *M;
  if (( M = gtkselectiondata_object(NthObj(i))) == NULLGTKSELECTIONDATA)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkSelectionData *gtkselectiondata_copy(NspGtkSelectionData *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtkselectiondata);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSelectionData
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkSelectionData *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkselectiondata is initialized * /
  nsp_type_gtkselectiondata = new_type_gtkselectiondata(T_BASE);
  if(( H = gboxed_create(NVOID,(NspTypeBase *) nsp_type_gtkselectiondata)) == NULLGTKSELECTIONDATA) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 578 "gtk.override"
static int
_wrap_gtk_selection_data_set(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,string, t_end} ;
  /* static char *kwlist[] = { "type", "format", "data", NULL };*/
  NspObject *nsp_type;
  GdkAtom type;
  int format, length;
  char *data;

  if (GetArgs(stack,rhs,opt,T,&nsp_type, &format, &data) == FAIL) return RET_BUG;
  length = strlen(data);
  if (nsp_gdk_atom_from_object(nsp_type,&type) == FAIL) return RET_BUG;
  gtk_selection_data_set(nspg_boxed_get(self, GtkSelectionData),
			 type, format,(const guchar *) data, length);
  return 0;
}
#line 2118 "gtk.c"


static int _wrap_gtk_selection_data_set_text(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, s_int,t_end};
  char *str;
  int len, ret;

  if ( GetArgs(stack,rhs,opt,T,&str, &len) == FAIL) return RET_BUG;
  ret = gtk_selection_data_set_text(NSP_GBOXED_GET(self, GtkSelectionData), str, len);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 597 "gtk.override"
static int
_wrap_gtk_selection_data_get_text(NspObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* 
  guchar *ret;
  ret = gtk_selection_data_get_text(nspg_boxed_get(self, GtkSelectionData));
  if (ret) {
    NspObject *nsp_ret = NspUnicode_DecodeUTF8(ret, strlen(ret), "strict");
    g_free(ret);
    return nsp_ret;
  }
  */
  Scierror("To be done XXXXX gtk_selection_data_get_text");
  return 0;
}
#line 2149 "gtk.c"


#line 614 "gtk.override"
static int
_wrap_gtk_selection_data_get_targets(NspObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkAtom *targets;
  gint n_atoms;
  gint i;

  NSP_LIST_DEC; 

  if ( !gtk_selection_data_get_targets(nspg_boxed_get(self, GtkSelectionData), &targets, &n_atoms)) 
    return RET_BUG; 
  NSP_LIST( for (i = 0; i < n_atoms; i++), nsp_node = (NspObject *) gdkatom_create(NVOID,NULL,targets[i],NULL)); 
  g_free(targets);
  MoveObj(stack,1,(NspObject *) nsp_list);
  return 1; 
  NSP_LIST_CLEAN; 
}
#line 2170 "gtk.c"


static int _wrap_gtk_selection_data_targets_include_text(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_selection_data_targets_include_text(NSP_GBOXED_GET(self, GtkSelectionData));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_set_row_drag_data(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj,t_end};
  int ret;
  NspGObject *tree_model;
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreemodel, &tree_model, &nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  ret = gtk_tree_set_row_drag_data(NSP_GBOXED_GET(self, GtkSelectionData), GTK_TREE_MODEL(tree_model->obj), path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 633 "gtk.override"
static int
_wrap_gtk_tree_get_row_drag_data(NspObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *tree_model;
  GtkTreePath *path;
  int_types T[] = {obj,obj, t_end} ;
  NspObject *nsp_model,*nsp_path; 
  if (gtk_tree_get_row_drag_data(nspg_boxed_get(self, GtkSelectionData), &tree_model, &path)) 
    {
      nsp_model = (NspObject *)  nspgobject_new((GObject *)tree_model);
      nsp_path =  (NspObject *)  nsp_gtk_tree_path_to_nspobject(path);
      gtk_tree_path_free(path);
      if ( nsp_model == NULL || nsp_path == NULL) return RET_BUG; 
    } 
  else 
    {
      nsp_model= (NspObject *) none_create(NVOID,NULL);
      nsp_path= (NspObject *) none_create(NVOID,NULL); 
    }
  return RetArgs(stack,lhs,T,nsp_model,nsp_path);  
}
#line 2224 "gtk.c"


static NspMethods gtkselectiondata_methods[] = {
  {"set",(nsp_method *) _wrap_gtk_selection_data_set},
  {"set_text",(nsp_method *) _wrap_gtk_selection_data_set_text},
  {"get_text",(nsp_method *) _wrap_gtk_selection_data_get_text},
  {"get_targets",(nsp_method *) _wrap_gtk_selection_data_get_targets},
  {"targets_include_text",(nsp_method *) _wrap_gtk_selection_data_targets_include_text},
  {"tree_set_row_drag_data",(nsp_method *) _wrap_gtk_tree_set_row_drag_data},
  {"tree_get_row_drag_data",(nsp_method *) _wrap_gtk_tree_get_row_drag_data},
  { NULL, NULL}
};

static NspMethods *gtkselectiondata_get_methods(void) { return gtkselectiondata_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_selection_data__get_selection(NspObject *self,char *attr)
{
  GdkAtom ret;

  ret = NSP_GBOXED_GET(self, GtkSelectionData)->selection;
  return (NspObject *) gdkatom_create(NVOID,NULL,ret,NULL);
}

static NspObject *_wrap_gtk_selection_data__get_target(NspObject *self,char *attr)
{
  GdkAtom ret;

  ret = NSP_GBOXED_GET(self, GtkSelectionData)->target;
  return (NspObject *) gdkatom_create(NVOID,NULL,ret,NULL);
}

static NspObject *_wrap_gtk_selection_data__get_type(NspObject *self,char *attr)
{
  GdkAtom ret;

  ret = NSP_GBOXED_GET(self, GtkSelectionData)->type;
  return (NspObject *) gdkatom_create(NVOID,NULL,ret,NULL);
}

static NspObject *_wrap_gtk_selection_data__get_format(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkSelectionData)->format;
  return nsp_new_double_obj((double) ret);
}

#line 563 "gtk.override"
static NspObject *
_wrap_gtk_selection_data__get_data(NspGObject *self, char *attr)
{
  if (nspg_boxed_get(self, GtkSelectionData)->length >= 0) {
    return nsp_new_string_obj(NVOID, 
			      (const char *) nspg_boxed_get(self, GtkSelectionData)->data,
			      (int) nspg_boxed_get(self, GtkSelectionData)->length);
  } else {
    return nsp_new_string_obj(NVOID,NULL,0);
  }
}
#line 2287 "gtk.c"
static AttrTab gtkselectiondata_attrs[] = {
  { "selection", (attr_get_function *)_wrap_gtk_selection_data__get_selection, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "target", (attr_get_function *)_wrap_gtk_selection_data__get_target, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "type", (attr_get_function *)_wrap_gtk_selection_data__get_type, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "format", (attr_get_function *)_wrap_gtk_selection_data__get_format, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "data", (attr_get_function *)_wrap_gtk_selection_data__get_data, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkTextAttributes ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTextAttributes_Private 
#include "nsp/gtk/gtktextattributes.h"
#include "nsp/interf.h"

/* NspGtkTextAttributes inherits from NspGBoxed */ 

int nsp_type_gtktextattributes_id=0;
NspTypeGtkTextAttributes *nsp_type_gtktextattributes=NULL;

NspTypeGtkTextAttributes *new_type_gtktextattributes(type_mode mode)
{
  NspTypeGtkTextAttributes *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextattributes != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextattributes;
    }
  if ((type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextattributes_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktextattributes_get_methods; 
  type->new = (new_func *) new_gtktextattributes;

  /* specific methods for gtktextattributes */
      
  type->init = (init_func *) init_gtktextattributes;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktextattributes */ 

  top->s_type =  (s_type_func *) gtktextattributes_type_as_string;    
  top->sh_type = (sh_type_func *) gtktextattributes_type_short_string;
  /* top->create = (create_func*) int_gtktextattributes_create;*/ 
  
  /* specific methods for gtktextattributes */
      
  type->init = (init_func *) init_gtktextattributes;

  if ( nsp_type_gtktextattributes_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextAttributes called nsp_type_gtktextattributes
       */
      type->id =  nsp_type_gtktextattributes_id = nsp_new_type_id();
      nsp_type_gtktextattributes = type;
      if ( nsp_register_type(nsp_type_gtktextattributes) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextattributes, GTK_TYPE_TEXT_ATTRIBUTES);
      return ( mode == T_BASE ) ? type : new_type_gtktextattributes(mode);
    }
  else 
    {
       type->id = nsp_type_gtktextattributes_id;
       return type;
    }
}

/*
 * initialize GtkTextAttributes instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextattributes(NspGtkTextAttributes *o,NspTypeGtkTextAttributes *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTextAttributes 
 */

NspGtkTextAttributes *new_gtktextattributes() 
{
  NspGtkTextAttributes *loc; 
  /* type must exists */
  nsp_type_gtktextattributes = new_type_gtktextattributes(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextAttributes)))== NULLGTKTEXTATTRIBUTES) return loc;
  /* initialize object */
  if ( init_gtktextattributes(loc,nsp_type_gtktextattributes) == FAIL) return NULLGTKTEXTATTRIBUTES;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTextAttributes 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktextattributes_type_name[]="GtkTextAttributes";
static char gtktextattributes_short_type_name[]="GtkTextAttributes";

static char *gtktextattributes_type_as_string(void)
{
  return(gtktextattributes_type_name);
}

static char *gtktextattributes_type_short_string(void)
{
  return(gtktextattributes_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTextAttributes objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTextAttributes   *gtktextattributes_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktextattributes_id) ) return ((NspGtkTextAttributes *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextattributes));
  return NULL;
}

int IsGtkTextAttributesObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktextattributes_id);
}

int IsGtkTextAttributes(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextattributes_id);
}

NspGtkTextAttributes  *GetGtkTextAttributesCopy(Stack stack, int i)
{
  if (  GetGtkTextAttributes(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextAttributes  *GetGtkTextAttributes(Stack stack, int i)
{
  NspGtkTextAttributes *M;
  if (( M = gtktextattributes_object(NthObj(i))) == NULLGTKTEXTATTRIBUTES)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkTextAttributes *gtktextattributes_copy(NspGtkTextAttributes *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtktextattributes);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextAttributes
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTextAttributes *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktextattributes is initialized * /
  nsp_type_gtktextattributes = new_type_gtktextattributes(T_BASE);
  if(( H = gboxed_create(NVOID,(NspTypeBase *) nsp_type_gtktextattributes)) == NULLGTKTEXTATTRIBUTES) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtktextattributes_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_text_attributes_new())== NULL) return RET_BUG;

  nsp_type_gtktextattributes = new_type_gtktextattributes(T_BASE);
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ATTRIBUTES, ret,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktextattributes );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_attributes_copy(NspGtkTextAttributes *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkTextAttributes *ret;

  ret = gtk_text_attributes_copy(NSP_GBOXED_GET(self, GtkTextAttributes));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ATTRIBUTES, ret, FALSE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktextattributes))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_attributes_copy_values(NspGtkTextAttributes *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_dest;
  GtkTextAttributes *dest = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_dest) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_dest, GTK_TYPE_TEXT_ATTRIBUTES))
      dest = nspg_boxed_get(nsp_dest, GtkTextAttributes);
  else {
      Scierror( "dest should be a GtkTextAttributes");
      return RET_BUG;
  }
  gtk_text_attributes_copy_values(NSP_GBOXED_GET(self, GtkTextAttributes), dest);
  return 0;
}

static NspMethods gtktextattributes_methods[] = {
  {"copy",(nsp_method *) _wrap_gtk_text_attributes_copy},
  {"copy_values",(nsp_method *) _wrap_gtk_text_attributes_copy_values},
  { NULL, NULL}
};

static NspMethods *gtktextattributes_get_methods(void) { return gtktextattributes_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

#line 6520 "gtk.override"
static NspObject *
_wrap_gtk_text_attributes__get_bg_color(NspObject *self, char *attr)
{
  GdkColor ret;
  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.bg_color;
  return (NspObject *)gboxed_create(NVOID,GDK_TYPE_COLOR, &ret, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor);
}
#line 2555 "gtk.c"
#line 6529 "gtk.override"
static NspObject *
_wrap_gtk_text_attributes__get_fg_color(NspObject *self, char *attr)
{
  GdkColor ret;
  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.fg_color;
  return (NspObject *)gboxed_create(NVOID,GDK_TYPE_COLOR, &ret, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor);
}
#line 2564 "gtk.c"
#line 6538 "gtk.override"
static NspObject *
_wrap_gtk_text_attributes__get_bg_stipple(NspObject *self, char *attr)
{
  GdkBitmap *ret;
  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.bg_stipple;
  /* nspgobject_new handles NULL checking */
  return (NspObject *) nspgobject_new((GObject *)ret);
}
#line 2574 "gtk.c"
#line 6548 "gtk.override"
static NspObject *
_wrap_gtk_text_attributes__get_fg_stipple(NspObject *self, char *attr)
{
  GdkBitmap *ret;

  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.fg_stipple;
  /* nspgobject_new handles NULL checking */
  return (NspObject *) nspgobject_new((GObject *)ret);
}
#line 2585 "gtk.c"
#line 6559 "gtk.override"
static NspObject *
_wrap_gtk_text_attributes__get_rise(NspObject *self, char *attr)
{
  int ret;
  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.rise;
  return nsp_new_double_obj((double) ret);
}
#line 2594 "gtk.c"
#line 6568 "gtk.override"
static NspObject *
_wrap_gtk_text_attributes__get_underline(NspObject *self, char *attr)
{
  int ret;
  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.underline;
  return nsp_new_double_obj((double) ret);
}
#line 2603 "gtk.c"
#line 6577 "gtk.override"
static NspObject *
_wrap_gtk_text_attributes__get_strikethrough(NspObject *self, char *attr)
{
  int ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.strikethrough;
  return (ret)  ? nsp_create_true_object(NVOID) : nsp_create_false_object(NVOID);
}
#line 2611 "gtk.c"
#line 6585 "gtk.override"
static NspObject *
_wrap_gtk_text_attributes__get_draw_bg(NspObject *self, char *attr)
{
  int ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.draw_bg;
  return (ret)  ? nsp_create_true_object(NVOID) : nsp_create_false_object(NVOID);
}
#line 2619 "gtk.c"
static NspObject *_wrap_gtk_text_attributes__get_justification(NspObject *self,char *attr)
{
  gint ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->justification;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_direction(NspObject *self,char *attr)
{
  gint ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->direction;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_font(NspObject *self,char *attr)
{
  PangoFontDescription *ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->font;
  /* nspg_boxed_new handles NULL checking */
  return (NspObject *) gboxed_create(NVOID,PANGO_TYPE_FONT_DESCRIPTION, ret, TRUE, TRUE,(NspTypeBase *) nsp_type_pangofontdescription);
}

static NspObject *_wrap_gtk_text_attributes__get_font_scale(NspObject *self,char *attr)
{
  double ret;
  NspObject *nsp_ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->font_scale;
  nsp_ret=nsp_create_object_from_double(NVOID,(double) ret);
  return nsp_ret;
}

static NspObject *_wrap_gtk_text_attributes__get_left_margin(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->left_margin;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_indent(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->indent;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_right_margin(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->right_margin;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_pixels_above_lines(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->pixels_above_lines;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_pixels_below_lines(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->pixels_below_lines;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_pixels_inside_wrap(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->pixels_inside_wrap;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_tabs(NspObject *self,char *attr)
{
  PangoTabArray *ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->tabs;
  /* nspg_boxed_new handles NULL checking */
  return (NspObject *) gboxed_create(NVOID,PANGO_TYPE_TAB_ARRAY, ret, TRUE, TRUE,(NspTypeBase *) nsp_type_pangotabarray);
}

static NspObject *_wrap_gtk_text_attributes__get_wrap_mode(NspObject *self,char *attr)
{
  gint ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->wrap_mode;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_language(NspObject *self,char *attr)
{
  PangoLanguage *ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->language;
  /* nspg_boxed_new handles NULL checking */
  return (NspObject *) gboxed_create(NVOID,PANGO_TYPE_LANGUAGE, ret, TRUE, TRUE,(NspTypeBase *) nsp_type_pangolanguage);
}

static NspObject *_wrap_gtk_text_attributes__get_invisible(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->invisible;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_bg_full_height(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->bg_full_height;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_editable(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->editable;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_realized(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->realized;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_pad1(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->pad1;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_pad2(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->pad2;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_pad3(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->pad3;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_text_attributes__get_pad4(NspObject *self,char *attr)
{
  int ret;

  ret = NSP_GBOXED_GET(self, GtkTextAttributes)->pad4;
  return nsp_new_double_obj((double) ret);
}

static AttrTab gtktextattributes_attrs[] = {
  { "bg_color", (attr_get_function *)_wrap_gtk_text_attributes__get_bg_color, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "fg_color", (attr_get_function *)_wrap_gtk_text_attributes__get_fg_color, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "bg_stipple", (attr_get_function *)_wrap_gtk_text_attributes__get_bg_stipple, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "fg_stipple", (attr_get_function *)_wrap_gtk_text_attributes__get_fg_stipple, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "rise", (attr_get_function *)_wrap_gtk_text_attributes__get_rise, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "underline", (attr_get_function *)_wrap_gtk_text_attributes__get_underline, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "strikethrough", (attr_get_function *)_wrap_gtk_text_attributes__get_strikethrough, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "draw_bg", (attr_get_function *)_wrap_gtk_text_attributes__get_draw_bg, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "justification", (attr_get_function *)_wrap_gtk_text_attributes__get_justification, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "direction", (attr_get_function *)_wrap_gtk_text_attributes__get_direction, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "font", (attr_get_function *)_wrap_gtk_text_attributes__get_font, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "font_scale", (attr_get_function *)_wrap_gtk_text_attributes__get_font_scale, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "left_margin", (attr_get_function *)_wrap_gtk_text_attributes__get_left_margin, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "indent", (attr_get_function *)_wrap_gtk_text_attributes__get_indent, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "right_margin", (attr_get_function *)_wrap_gtk_text_attributes__get_right_margin, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "pixels_above_lines", (attr_get_function *)_wrap_gtk_text_attributes__get_pixels_above_lines, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "pixels_below_lines", (attr_get_function *)_wrap_gtk_text_attributes__get_pixels_below_lines, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "pixels_inside_wrap", (attr_get_function *)_wrap_gtk_text_attributes__get_pixels_inside_wrap, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "tabs", (attr_get_function *)_wrap_gtk_text_attributes__get_tabs, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "wrap_mode", (attr_get_function *)_wrap_gtk_text_attributes__get_wrap_mode, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "language", (attr_get_function *)_wrap_gtk_text_attributes__get_language, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "invisible", (attr_get_function *)_wrap_gtk_text_attributes__get_invisible, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "bg_full_height", (attr_get_function *)_wrap_gtk_text_attributes__get_bg_full_height, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "editable", (attr_get_function *)_wrap_gtk_text_attributes__get_editable, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "realized", (attr_get_function *)_wrap_gtk_text_attributes__get_realized, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "pad1", (attr_get_function *)_wrap_gtk_text_attributes__get_pad1, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "pad2", (attr_get_function *)_wrap_gtk_text_attributes__get_pad2, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "pad3", (attr_get_function *)_wrap_gtk_text_attributes__get_pad3, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "pad4", (attr_get_function *)_wrap_gtk_text_attributes__get_pad4, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkTextIter ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTextIter_Private 
#include "nsp/gtk/gtktextiter.h"
#include "nsp/interf.h"

/* NspGtkTextIter inherits from NspGBoxed */ 

int nsp_type_gtktextiter_id=0;
NspTypeGtkTextIter *nsp_type_gtktextiter=NULL;

NspTypeGtkTextIter *new_type_gtktextiter(type_mode mode)
{
  NspTypeGtkTextIter *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextiter != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextiter;
    }
  if ((type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextiter_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktextiter_get_methods; 
  type->new = (new_func *) new_gtktextiter;

  /* specific methods for gtktextiter */
      
  type->init = (init_func *) init_gtktextiter;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktextiter */ 

  top->s_type =  (s_type_func *) gtktextiter_type_as_string;    
  top->sh_type = (sh_type_func *) gtktextiter_type_short_string;
  /* top->create = (create_func*) int_gtktextiter_create;*/ 
  
  /* specific methods for gtktextiter */
      
  type->init = (init_func *) init_gtktextiter;

  if ( nsp_type_gtktextiter_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextIter called nsp_type_gtktextiter
       */
      type->id =  nsp_type_gtktextiter_id = nsp_new_type_id();
      nsp_type_gtktextiter = type;
      if ( nsp_register_type(nsp_type_gtktextiter) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextiter, GTK_TYPE_TEXT_ITER);
      return ( mode == T_BASE ) ? type : new_type_gtktextiter(mode);
    }
  else 
    {
       type->id = nsp_type_gtktextiter_id;
       return type;
    }
}

/*
 * initialize GtkTextIter instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextiter(NspGtkTextIter *o,NspTypeGtkTextIter *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTextIter 
 */

NspGtkTextIter *new_gtktextiter() 
{
  NspGtkTextIter *loc; 
  /* type must exists */
  nsp_type_gtktextiter = new_type_gtktextiter(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextIter)))== NULLGTKTEXTITER) return loc;
  /* initialize object */
  if ( init_gtktextiter(loc,nsp_type_gtktextiter) == FAIL) return NULLGTKTEXTITER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTextIter 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktextiter_type_name[]="GtkTextIter";
static char gtktextiter_short_type_name[]="GtkTextIter";

static char *gtktextiter_type_as_string(void)
{
  return(gtktextiter_type_name);
}

static char *gtktextiter_type_short_string(void)
{
  return(gtktextiter_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTextIter objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTextIter   *gtktextiter_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktextiter_id) ) return ((NspGtkTextIter *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextiter));
  return NULL;
}

int IsGtkTextIterObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktextiter_id);
}

int IsGtkTextIter(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextiter_id);
}

NspGtkTextIter  *GetGtkTextIterCopy(Stack stack, int i)
{
  if (  GetGtkTextIter(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextIter  *GetGtkTextIter(Stack stack, int i)
{
  NspGtkTextIter *M;
  if (( M = gtktextiter_object(NthObj(i))) == NULLGTKTEXTITER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkTextIter *gtktextiter_copy(NspGtkTextIter *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtktextiter);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextIter
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTextIter *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktextiter is initialized * /
  nsp_type_gtktextiter = new_type_gtktextiter(T_BASE);
  if(( H = gboxed_create(NVOID,(NspTypeBase *) nsp_type_gtktextiter)) == NULLGTKTEXTITER) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_text_iter_get_buffer(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextBuffer *ret;
  NspObject *nsp_ret;

  ret = gtk_text_iter_get_buffer(NSP_GBOXED_GET(self, GtkTextIter));
  nsp_type_gtktextbuffer = new_type_gtktextbuffer(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextbuffer))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 5220 "gtk.override"
static NspObject *
_wrap_gtk_text_iter_copy(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  return (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, nspg_boxed_get(self, GtkTextIter), TRUE, TRUE,NULL);
}
#line 3039 "gtk.c"


static int _wrap_gtk_text_iter_get_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_get_offset(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_get_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_line_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_get_line_offset(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_line_index(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_get_line_index(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_visible_line_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_get_visible_line_offset(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_visible_line_index(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_get_visible_line_index(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_char(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  gunichar ret;

  ret = gtk_text_iter_get_char(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)== FAIL)return RET_BUG;
  return 1;
}

#line 5227 "gtk.override"
static int
_wrap_gtk_text_iter_get_slice(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "end", NULL };*/
  /* 
  int_types T[] = {obj, t_end} ;
  NspObject *g_end;
  gchar *text;
  NspObject *pytext;

  if (GetArgs(stack,rhs,opt,T, &g_end)  == FAIL) return RET_BUG;
  if (!nspg_boxed_check(g_end, GTK_TYPE_TEXT_ITER)) {
    Scierror( "end must be a GtkTextIter");
    return RET_BUG;
  }
  text = gtk_text_iter_get_slice(nspg_boxed_get(self, GtkTextIter),
				 nspg_boxed_get(g_end, GtkTextIter));
  pytext = NspUnicode_DecodeUTF8(text, strlen(text), "strict");
  g_free(text);
  MoveObj(stack,1,pytext);
  return 1;
  */
  Scierror("XXXX To be done gtk_text_iter_get_slice");
  return 0;
}
#line 3131 "gtk.c"


#line 5254 "gtk.override"
static int
_wrap_gtk_text_iter_get_text(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "end", NULL };*/
  /*
  int_types T[] = {obj, t_end} ;
  NspObject *end;
  gchar *text;
  NspObject *pytext;

  if (GetArgs(stack,rhs,opt,T, &end) == FAIL) return RET_BUG;;
  if (!nspg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
    Scierror( "end must be a GtkTextIter");
    return RET_BUG;
  }
  text = gtk_text_iter_get_text(nspg_boxed_get(self, GtkTextIter),
				nspg_boxed_get(end, GtkTextIter));
  pytext = NspUnicode_DecodeUTF8(text, strlen(text), "strict");
  g_free(text);
  MoveObj(stack,1,pytext);
  return 1;
  */
  Scierror("To be done gtk_text_iter_get_text");
  return 0;
}
#line 3160 "gtk.c"


#line 5281 "gtk.override"
static int
_wrap_gtk_text_iter_get_visible_slice(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "end", NULL };*/
  /*
    int_types T[] = {obj, t_end} ;
    
    NspObject *end;
    gchar *text;
    NspObject *pytext;

    if (GetArgs(stack,rhs,opt,T,&end)  == FAIL) return RET_BUG;;
    if (!nspg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
        Scierror( "end must be a GtkTextIter");
        return RET_BUG;
    }
    text = gtk_text_iter_get_visible_slice(nspg_boxed_get(self, GtkTextIter),
                                           nspg_boxed_get(end, GtkTextIter));
    pytext = NspUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    MoveObj(stack,1,pytext);
    return 1;
  */
  Scierror("To be done gtk_text_iter_get_visible_slice");
  return 0;
}
#line 3190 "gtk.c"


#line 5309 "gtk.override"
static int
_wrap_gtk_text_iter_get_visible_text(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
    /* static char *kwlist[] = { "end", NULL };*/

  /*
    int_types T[] = { t_end} ;
    NspObject *end;
    gchar *text;
    NspObject *pytext;

    if (GetArgs(stack,rhs,opt,T,&end)  == FAIL) return RET_BUG;
    if (!nspg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
        Scierror( "end must be a GtkTextIter");
        return RET_BUG;
    }
    text = gtk_text_iter_get_visible_text(nspg_boxed_get(self, GtkTextIter),
                                          nspg_boxed_get(end, GtkTextIter));
    pytext = NspUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    MoveObj(stack,1,pytext);
    return 1;
  */
  Scierror("To be done gtk_text_iter_get_visible_text");
  return 0;
}
#line 3220 "gtk.c"


static int _wrap_gtk_text_iter_get_pixbuf(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;

  ret = gtk_text_iter_get_pixbuf(NSP_GBOXED_GET(self, GtkTextIter));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 5337 "gtk.override"
static NspObject *
_wrap_gtk_text_iter_get_marks(NspGBoxed *self)
{
  GSList *list, *tmp;
  NspList *nsp_list;
  Cell *cloc = NULLCELL,*cloc1=NULLCELL; 
  list = gtk_text_iter_get_marks(nspg_boxed_get(self, GtkTextIter));
  NSP_OBJ_LIST_FROM_GLIST(nspgobject_new((GObject *)tmp->data),g_slist_free);
}
#line 3245 "gtk.c"


static int _wrap_gtk_text_iter_get_child_anchor(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextChildAnchor *ret;
  NspObject *nsp_ret;

  ret = gtk_text_iter_get_child_anchor(NSP_GBOXED_GET(self, GtkTextIter));
  nsp_type_gtktextchildanchor = new_type_gtktextchildanchor(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextchildanchor))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 5348 "gtk.override"
static int
_wrap_gtk_text_iter_get_toggled_tags(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end} ;
  /* static char *kwlist[] = { "toggled_on", NULL };*/
  int toggled_on;
  GSList *list, *tmp;
  NspList *nsp_list;
  Cell *cloc = NULLCELL,*cloc1=NULLCELL; 

  if (GetArgs(stack,rhs,opt,T,&toggled_on) == FAIL) return RET_BUG;;
  list = gtk_text_iter_get_toggled_tags(nspg_boxed_get(self, GtkTextIter), toggled_on);
    
  NSP_LIST_FROM_GLIST(gobject_gettype_and_create("lel",(GObject *)tmp->data),g_slist_free);
}
#line 3276 "gtk.c"


static int _wrap_gtk_text_iter_begins_tag(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"tag",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int ret;
  NspGObject *nsp_tag = NULL;
  GtkTextTag *tag = NULL;

  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_tag) == FAIL) return RET_BUG;
  if ( nsp_tag != NULL ) {
    if ( IsGtkTextTag((NspObject *)nsp_tag))
      tag = GTK_TEXT_TAG(nsp_tag->obj);
    else if (! IsNone((NspObject *)nsp_tag)) {
         Scierror( "tag should be a GtkTextTag or None");
         return RET_BUG;
    }
  }
  ret = gtk_text_iter_begins_tag(NSP_GBOXED_GET(self, GtkTextIter), tag);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_ends_tag(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"tag",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int ret;
  NspGObject *nsp_tag = NULL;
  GtkTextTag *tag = NULL;

  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_tag) == FAIL) return RET_BUG;
  if ( nsp_tag != NULL ) {
    if ( IsGtkTextTag((NspObject *)nsp_tag))
      tag = GTK_TEXT_TAG(nsp_tag->obj);
    else if (! IsNone((NspObject *)nsp_tag)) {
         Scierror( "tag should be a GtkTextTag or None");
         return RET_BUG;
    }
  }
  ret = gtk_text_iter_ends_tag(NSP_GBOXED_GET(self, GtkTextIter), tag);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_toggles_tag(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"tag",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int ret;
  NspGObject *nsp_tag = NULL;
  GtkTextTag *tag = NULL;

  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_tag) == FAIL) return RET_BUG;
  if ( nsp_tag != NULL ) {
    if ( IsGtkTextTag((NspObject *)nsp_tag))
      tag = GTK_TEXT_TAG(nsp_tag->obj);
    else if (! IsNone((NspObject *)nsp_tag)) {
         Scierror( "tag should be a GtkTextTag or None");
         return RET_BUG;
    }
  }
  ret = gtk_text_iter_toggles_tag(NSP_GBOXED_GET(self, GtkTextIter), tag);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_has_tag(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  int ret;
  NspGObject *tag;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktexttag, &tag) == FAIL) return RET_BUG;
  ret = gtk_text_iter_has_tag(NSP_GBOXED_GET(self, GtkTextIter), GTK_TEXT_TAG(tag->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 5365 "gtk.override"
static NspObject *
_wrap_gtk_text_iter_get_tags(NspGBoxed *self)
{
  GSList *list, *tmp;
  NspList *nsp_list;
  Cell *cloc = NULLCELL,*cloc1=NULLCELL; 
  list = gtk_text_iter_get_tags(nspg_boxed_get(self, GtkTextIter));
  NSP_OBJ_LIST_FROM_GLIST(nspgobject_new((GObject *)tmp->data),g_slist_free);
}
#line 3373 "gtk.c"


static int _wrap_gtk_text_iter_editable(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int default_setting, ret;

  if ( GetArgs(stack,rhs,opt,T,&default_setting) == FAIL) return RET_BUG;
  ret = gtk_text_iter_editable(NSP_GBOXED_GET(self, GtkTextIter), default_setting);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_can_insert(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int default_editability, ret;

  if ( GetArgs(stack,rhs,opt,T,&default_editability) == FAIL) return RET_BUG;
  ret = gtk_text_iter_can_insert(NSP_GBOXED_GET(self, GtkTextIter), default_editability);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_starts_word(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_starts_word(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_ends_word(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_ends_word(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_inside_word(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_inside_word(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_starts_sentence(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_starts_sentence(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_ends_sentence(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_ends_sentence(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_inside_sentence(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_inside_sentence(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_starts_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_starts_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_ends_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_ends_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_is_cursor_position(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_is_cursor_position(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_chars_in_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_get_chars_in_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_bytes_in_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_get_bytes_in_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_attributes(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_values;
  GtkTextAttributes *values = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_values) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_values, GTK_TYPE_TEXT_ATTRIBUTES))
      values = nspg_boxed_get(nsp_values, GtkTextAttributes);
  else {
      Scierror( "values should be a GtkTextAttributes");
      return RET_BUG;
  }
  ret = gtk_text_iter_get_attributes(NSP_GBOXED_GET(self, GtkTextIter), values);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_language(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  PangoLanguage *ret;

  ret = gtk_text_iter_get_language(NSP_GBOXED_GET(self, GtkTextIter));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,PANGO_TYPE_LANGUAGE, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_pangolanguage))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_iter_is_end(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_is_end(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_is_start(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_is_start(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_char(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_forward_char(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_char(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_backward_char(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_chars(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int count, ret;

  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret = gtk_text_iter_forward_chars(NSP_GBOXED_GET(self, GtkTextIter), count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_chars(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int count, ret;

  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret = gtk_text_iter_backward_chars(NSP_GBOXED_GET(self, GtkTextIter), count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_forward_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_backward_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_lines(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int count, ret;

  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret = gtk_text_iter_forward_lines(NSP_GBOXED_GET(self, GtkTextIter), count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_lines(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int count, ret;

  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret = gtk_text_iter_backward_lines(NSP_GBOXED_GET(self, GtkTextIter), count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_word_end(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_forward_word_end(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_word_start(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_backward_word_start(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_word_ends(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int count, ret;

  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret = gtk_text_iter_forward_word_ends(NSP_GBOXED_GET(self, GtkTextIter), count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_word_starts(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int count, ret;

  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret = gtk_text_iter_backward_word_starts(NSP_GBOXED_GET(self, GtkTextIter), count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_sentence_end(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_forward_sentence_end(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_sentence_start(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_backward_sentence_start(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_sentence_ends(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int count, ret;

  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret = gtk_text_iter_forward_sentence_ends(NSP_GBOXED_GET(self, GtkTextIter), count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_sentence_starts(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int count, ret;

  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret = gtk_text_iter_backward_sentence_starts(NSP_GBOXED_GET(self, GtkTextIter), count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_cursor_position(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_forward_cursor_position(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_cursor_position(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_backward_cursor_position(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_cursor_positions(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int count, ret;

  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret = gtk_text_iter_forward_cursor_positions(NSP_GBOXED_GET(self, GtkTextIter), count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_cursor_positions(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int count, ret;

  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret = gtk_text_iter_backward_cursor_positions(NSP_GBOXED_GET(self, GtkTextIter), count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_set_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int char_offset;

  if ( GetArgs(stack,rhs,opt,T,&char_offset) == FAIL) return RET_BUG;
  gtk_text_iter_set_offset(NSP_GBOXED_GET(self, GtkTextIter), char_offset);
  return 0;
}

static int _wrap_gtk_text_iter_set_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int line_number;

  if ( GetArgs(stack,rhs,opt,T,&line_number) == FAIL) return RET_BUG;
  gtk_text_iter_set_line(NSP_GBOXED_GET(self, GtkTextIter), line_number);
  return 0;
}

static int _wrap_gtk_text_iter_set_line_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int char_on_line;

  if ( GetArgs(stack,rhs,opt,T,&char_on_line) == FAIL) return RET_BUG;
  gtk_text_iter_set_line_offset(NSP_GBOXED_GET(self, GtkTextIter), char_on_line);
  return 0;
}

static int _wrap_gtk_text_iter_set_line_index(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int byte_on_line;

  if ( GetArgs(stack,rhs,opt,T,&byte_on_line) == FAIL) return RET_BUG;
  gtk_text_iter_set_line_index(NSP_GBOXED_GET(self, GtkTextIter), byte_on_line);
  return 0;
}

static int _wrap_gtk_text_iter_forward_to_end(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_text_iter_forward_to_end(NSP_GBOXED_GET(self, GtkTextIter));
  return 0;
}

static int _wrap_gtk_text_iter_forward_to_line_end(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_iter_forward_to_line_end(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_set_visible_line_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int char_on_line;

  if ( GetArgs(stack,rhs,opt,T,&char_on_line) == FAIL) return RET_BUG;
  gtk_text_iter_set_visible_line_offset(NSP_GBOXED_GET(self, GtkTextIter), char_on_line);
  return 0;
}

static int _wrap_gtk_text_iter_set_visible_line_index(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int byte_on_line;

  if ( GetArgs(stack,rhs,opt,T,&byte_on_line) == FAIL) return RET_BUG;
  gtk_text_iter_set_visible_line_index(NSP_GBOXED_GET(self, GtkTextIter), byte_on_line);
  return 0;
}

static int _wrap_gtk_text_iter_forward_to_tag_toggle(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspGObject *nsp_tag;
  GtkTextTag *tag = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_tag) == FAIL) return RET_BUG;
  if ( IsGtkTextTag((NspObject *)nsp_tag))
      tag = GTK_TEXT_TAG(nsp_tag->obj);
  else if ( ! IsNone((NspObject *) nsp_tag))  {
      Scierror( "tag should be a GtkTextTag or None");
      return RET_BUG;
  }
  ret = gtk_text_iter_forward_to_tag_toggle(NSP_GBOXED_GET(self, GtkTextIter), tag);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_to_tag_toggle(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspGObject *nsp_tag;
  GtkTextTag *tag = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_tag) == FAIL) return RET_BUG;
  if ( IsGtkTextTag((NspObject *)nsp_tag))
      tag = GTK_TEXT_TAG(nsp_tag->obj);
  else if ( ! IsNone((NspObject *) nsp_tag))  {
      Scierror( "tag should be a GtkTextTag or None");
      return RET_BUG;
  }
  ret = gtk_text_iter_backward_to_tag_toggle(NSP_GBOXED_GET(self, GtkTextIter), tag);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 5376 "gtk.override"
static int
_wrap_gtk_text_iter_forward_search(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "str", "flags", "limit", NULL };*/
  gchar *str;
  NspObject *nsp_limit = NULLOBJ;
  GtkTextIter match_start, match_end, *limit = NULL;
  GtkTextSearchFlags flags;

  CheckRhs(2,3);
  if ( rhs == 2 ) 
    {
      int_types T2[] = { string,s_int,obj, t_end} ;
      if (GetArgs(stack,rhs,opt,T2, &str, &flags) == FAIL) return RET_BUG;;
    }
  else 
    {
      int_types T3[] = { string,s_int, t_end} ;
      if (GetArgs(stack,rhs,opt,T3, &str, &flags, &nsp_limit)     == FAIL) return RET_BUG;;
      if (nspg_boxed_check(nsp_limit, GTK_TYPE_TEXT_ITER))
	limit = nspg_boxed_get(nsp_limit, GtkTextIter);
    }
  if (gtk_text_iter_forward_search(nspg_boxed_get(self, GtkTextIter), str,
				   flags, &match_start, &match_end, limit))
    {
      NspObject *ret; 
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_start,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_end,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,2,ret);
      return 2;
    }
  return 0;
}
#line 3895 "gtk.c"


#line 5412 "gtk.override"
static int
_wrap_gtk_text_iter_backward_search(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "str", "flags", "limit", NULL };*/
  gchar *str;
  NspObject *nsp_limit = NULL;
  GtkTextIter match_start, match_end, *limit = NULL;
  GtkTextSearchFlags flags;

  CheckRhs(2,3);
  if ( rhs == 2 ) 
    {
      int_types T2[] = { string,s_int,obj, t_end} ;
      if (GetArgs(stack,rhs,opt,T2, &str, &flags) == FAIL) return RET_BUG;;
    }
  else 
    {
      int_types T3[] = { string,s_int, t_end} ;
      if (GetArgs(stack,rhs,opt,T3, &str, &flags, &nsp_limit)     == FAIL) return RET_BUG;;
      if (nspg_boxed_check(nsp_limit, GTK_TYPE_TEXT_ITER))
	limit = nspg_boxed_get(nsp_limit, GtkTextIter);
    }
  if (gtk_text_iter_backward_search(nspg_boxed_get(self, GtkTextIter), str,
				    flags, &match_start, &match_end, limit))
    {
      NspObject *ret; 
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_start,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_end,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,2,ret);
      return 2;
    }
  return 0;
}
#line 3933 "gtk.c"


static int _wrap_gtk_text_iter_equal(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_rhs_;
  GtkTextIter *rhs_ = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_rhs_) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_rhs_, GTK_TYPE_TEXT_ITER))
      rhs_ = nspg_boxed_get(nsp_rhs_, GtkTextIter);
  else {
      Scierror( "rhs_ should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_iter_equal(NSP_GBOXED_GET(self, GtkTextIter), rhs_);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_compare(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_rhs_;
  GtkTextIter *rhs_ = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_rhs_) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_rhs_, GTK_TYPE_TEXT_ITER))
      rhs_ = nspg_boxed_get(nsp_rhs_, GtkTextIter);
  else {
      Scierror( "rhs_ should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_iter_compare(NSP_GBOXED_GET(self, GtkTextIter), rhs_);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_in_range(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  int ret;
  NspObject *nsp_start, *nsp_end;
  GtkTextIter *start = NULL, *end = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "start should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "end should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_iter_in_range(NSP_GBOXED_GET(self, GtkTextIter), start, end);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_order(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_second;
  GtkTextIter *second = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_second) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_second, GTK_TYPE_TEXT_ITER))
      second = nspg_boxed_get(nsp_second, GtkTextIter);
  else {
      Scierror( "second should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_iter_order(NSP_GBOXED_GET(self, GtkTextIter), second);
  return 0;
}

static NspMethods gtktextiter_methods[] = {
  {"get_buffer",(nsp_method *) _wrap_gtk_text_iter_get_buffer},
  {"copy",(nsp_method *) _wrap_gtk_text_iter_copy},
  {"get_offset",(nsp_method *) _wrap_gtk_text_iter_get_offset},
  {"get_line",(nsp_method *) _wrap_gtk_text_iter_get_line},
  {"get_line_offset",(nsp_method *) _wrap_gtk_text_iter_get_line_offset},
  {"get_line_index",(nsp_method *) _wrap_gtk_text_iter_get_line_index},
  {"get_visible_line_offset",(nsp_method *) _wrap_gtk_text_iter_get_visible_line_offset},
  {"get_visible_line_index",(nsp_method *) _wrap_gtk_text_iter_get_visible_line_index},
  {"get_char",(nsp_method *) _wrap_gtk_text_iter_get_char},
  {"get_slice",(nsp_method *) _wrap_gtk_text_iter_get_slice},
  {"get_text",(nsp_method *) _wrap_gtk_text_iter_get_text},
  {"get_visible_slice",(nsp_method *) _wrap_gtk_text_iter_get_visible_slice},
  {"get_visible_text",(nsp_method *) _wrap_gtk_text_iter_get_visible_text},
  {"get_pixbuf",(nsp_method *) _wrap_gtk_text_iter_get_pixbuf},
  {"get_marks",(nsp_method *) _wrap_gtk_text_iter_get_marks},
  {"get_child_anchor",(nsp_method *) _wrap_gtk_text_iter_get_child_anchor},
  {"get_toggled_tags",(nsp_method *) _wrap_gtk_text_iter_get_toggled_tags},
  {"begins_tag",(nsp_method *) _wrap_gtk_text_iter_begins_tag},
  {"ends_tag",(nsp_method *) _wrap_gtk_text_iter_ends_tag},
  {"toggles_tag",(nsp_method *) _wrap_gtk_text_iter_toggles_tag},
  {"has_tag",(nsp_method *) _wrap_gtk_text_iter_has_tag},
  {"get_tags",(nsp_method *) _wrap_gtk_text_iter_get_tags},
  {"editable",(nsp_method *) _wrap_gtk_text_iter_editable},
  {"can_insert",(nsp_method *) _wrap_gtk_text_iter_can_insert},
  {"starts_word",(nsp_method *) _wrap_gtk_text_iter_starts_word},
  {"ends_word",(nsp_method *) _wrap_gtk_text_iter_ends_word},
  {"inside_word",(nsp_method *) _wrap_gtk_text_iter_inside_word},
  {"starts_sentence",(nsp_method *) _wrap_gtk_text_iter_starts_sentence},
  {"ends_sentence",(nsp_method *) _wrap_gtk_text_iter_ends_sentence},
  {"inside_sentence",(nsp_method *) _wrap_gtk_text_iter_inside_sentence},
  {"starts_line",(nsp_method *) _wrap_gtk_text_iter_starts_line},
  {"ends_line",(nsp_method *) _wrap_gtk_text_iter_ends_line},
  {"is_cursor_position",(nsp_method *) _wrap_gtk_text_iter_is_cursor_position},
  {"get_chars_in_line",(nsp_method *) _wrap_gtk_text_iter_get_chars_in_line},
  {"get_bytes_in_line",(nsp_method *) _wrap_gtk_text_iter_get_bytes_in_line},
  {"get_attributes",(nsp_method *) _wrap_gtk_text_iter_get_attributes},
  {"get_language",(nsp_method *) _wrap_gtk_text_iter_get_language},
  {"is_end",(nsp_method *) _wrap_gtk_text_iter_is_end},
  {"is_start",(nsp_method *) _wrap_gtk_text_iter_is_start},
  {"forward_char",(nsp_method *) _wrap_gtk_text_iter_forward_char},
  {"backward_char",(nsp_method *) _wrap_gtk_text_iter_backward_char},
  {"forward_chars",(nsp_method *) _wrap_gtk_text_iter_forward_chars},
  {"backward_chars",(nsp_method *) _wrap_gtk_text_iter_backward_chars},
  {"forward_line",(nsp_method *) _wrap_gtk_text_iter_forward_line},
  {"backward_line",(nsp_method *) _wrap_gtk_text_iter_backward_line},
  {"forward_lines",(nsp_method *) _wrap_gtk_text_iter_forward_lines},
  {"backward_lines",(nsp_method *) _wrap_gtk_text_iter_backward_lines},
  {"forward_word_end",(nsp_method *) _wrap_gtk_text_iter_forward_word_end},
  {"backward_word_start",(nsp_method *) _wrap_gtk_text_iter_backward_word_start},
  {"forward_word_ends",(nsp_method *) _wrap_gtk_text_iter_forward_word_ends},
  {"backward_word_starts",(nsp_method *) _wrap_gtk_text_iter_backward_word_starts},
  {"forward_sentence_end",(nsp_method *) _wrap_gtk_text_iter_forward_sentence_end},
  {"backward_sentence_start",(nsp_method *) _wrap_gtk_text_iter_backward_sentence_start},
  {"forward_sentence_ends",(nsp_method *) _wrap_gtk_text_iter_forward_sentence_ends},
  {"backward_sentence_starts",(nsp_method *) _wrap_gtk_text_iter_backward_sentence_starts},
  {"forward_cursor_position",(nsp_method *) _wrap_gtk_text_iter_forward_cursor_position},
  {"backward_cursor_position",(nsp_method *) _wrap_gtk_text_iter_backward_cursor_position},
  {"forward_cursor_positions",(nsp_method *) _wrap_gtk_text_iter_forward_cursor_positions},
  {"backward_cursor_positions",(nsp_method *) _wrap_gtk_text_iter_backward_cursor_positions},
  {"set_offset",(nsp_method *) _wrap_gtk_text_iter_set_offset},
  {"set_line",(nsp_method *) _wrap_gtk_text_iter_set_line},
  {"set_line_offset",(nsp_method *) _wrap_gtk_text_iter_set_line_offset},
  {"set_line_index",(nsp_method *) _wrap_gtk_text_iter_set_line_index},
  {"forward_to_end",(nsp_method *) _wrap_gtk_text_iter_forward_to_end},
  {"forward_to_line_end",(nsp_method *) _wrap_gtk_text_iter_forward_to_line_end},
  {"set_visible_line_offset",(nsp_method *) _wrap_gtk_text_iter_set_visible_line_offset},
  {"set_visible_line_index",(nsp_method *) _wrap_gtk_text_iter_set_visible_line_index},
  {"forward_to_tag_toggle",(nsp_method *) _wrap_gtk_text_iter_forward_to_tag_toggle},
  {"backward_to_tag_toggle",(nsp_method *) _wrap_gtk_text_iter_backward_to_tag_toggle},
  {"forward_search",(nsp_method *) _wrap_gtk_text_iter_forward_search},
  {"backward_search",(nsp_method *) _wrap_gtk_text_iter_backward_search},
  {"equal",(nsp_method *) _wrap_gtk_text_iter_equal},
  {"compare",(nsp_method *) _wrap_gtk_text_iter_compare},
  {"in_range",(nsp_method *) _wrap_gtk_text_iter_in_range},
  {"order",(nsp_method *) _wrap_gtk_text_iter_order},
  { NULL, NULL}
};

static NspMethods *gtktextiter_get_methods(void) { return gtktextiter_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktextiter_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTreeIter ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTreeIter_Private 
#include "nsp/gtk/gtktreeiter.h"
#include "nsp/interf.h"

/* NspGtkTreeIter inherits from NspGBoxed */ 

int nsp_type_gtktreeiter_id=0;
NspTypeGtkTreeIter *nsp_type_gtktreeiter=NULL;

NspTypeGtkTreeIter *new_type_gtktreeiter(type_mode mode)
{
  NspTypeGtkTreeIter *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreeiter != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreeiter;
    }
  if ((type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreeiter_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktreeiter_get_methods; 
  type->new = (new_func *) new_gtktreeiter;

  /* specific methods for gtktreeiter */
      
  type->init = (init_func *) init_gtktreeiter;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktreeiter */ 

  top->s_type =  (s_type_func *) gtktreeiter_type_as_string;    
  top->sh_type = (sh_type_func *) gtktreeiter_type_short_string;
  /* top->create = (create_func*) int_gtktreeiter_create;*/ 
  
  /* specific methods for gtktreeiter */
      
  type->init = (init_func *) init_gtktreeiter;

  if ( nsp_type_gtktreeiter_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeIter called nsp_type_gtktreeiter
       */
      type->id =  nsp_type_gtktreeiter_id = nsp_new_type_id();
      nsp_type_gtktreeiter = type;
      if ( nsp_register_type(nsp_type_gtktreeiter) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreeiter, GTK_TYPE_TREE_ITER);
      return ( mode == T_BASE ) ? type : new_type_gtktreeiter(mode);
    }
  else 
    {
       type->id = nsp_type_gtktreeiter_id;
       return type;
    }
}

/*
 * initialize GtkTreeIter instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreeiter(NspGtkTreeIter *o,NspTypeGtkTreeIter *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTreeIter 
 */

NspGtkTreeIter *new_gtktreeiter() 
{
  NspGtkTreeIter *loc; 
  /* type must exists */
  nsp_type_gtktreeiter = new_type_gtktreeiter(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeIter)))== NULLGTKTREEITER) return loc;
  /* initialize object */
  if ( init_gtktreeiter(loc,nsp_type_gtktreeiter) == FAIL) return NULLGTKTREEITER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTreeIter 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktreeiter_type_name[]="GtkTreeIter";
static char gtktreeiter_short_type_name[]="GtkTreeIter";

static char *gtktreeiter_type_as_string(void)
{
  return(gtktreeiter_type_name);
}

static char *gtktreeiter_type_short_string(void)
{
  return(gtktreeiter_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTreeIter objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTreeIter   *gtktreeiter_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktreeiter_id) ) return ((NspGtkTreeIter *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreeiter));
  return NULL;
}

int IsGtkTreeIterObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktreeiter_id);
}

int IsGtkTreeIter(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreeiter_id);
}

NspGtkTreeIter  *GetGtkTreeIterCopy(Stack stack, int i)
{
  if (  GetGtkTreeIter(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeIter  *GetGtkTreeIter(Stack stack, int i)
{
  NspGtkTreeIter *M;
  if (( M = gtktreeiter_object(NthObj(i))) == NULLGTKTREEITER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkTreeIter *gtktreeiter_copy(NspGtkTreeIter *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtktreeiter);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeIter
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTreeIter *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktreeiter is initialized * /
  nsp_type_gtktreeiter = new_type_gtktreeiter(T_BASE);
  if(( H = gboxed_create(NVOID,(NspTypeBase *) nsp_type_gtktreeiter)) == NULLGTKTREEITER) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_tree_iter_copy(NspGtkTreeIter *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter *ret;
  NspObject *nsp_ret;

  ret = gtk_tree_iter_copy(NSP_GBOXED_GET(self, GtkTreeIter));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, ret, FALSE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreeiter))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_iter_free(NspGtkTreeIter *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_iter_free(NSP_GBOXED_GET(self, GtkTreeIter));
  return 0;
}

static NspMethods gtktreeiter_methods[] = {
  {"copy",(nsp_method *) _wrap_gtk_tree_iter_copy},
  {"free",(nsp_method *) _wrap_gtk_tree_iter_free},
  { NULL, NULL}
};

static NspMethods *gtktreeiter_get_methods(void) { return gtktreeiter_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreeiter_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkEditable ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkEditable_Private 
#include "nsp/gtk/gtkeditable.h"
#include "nsp/interf.h"

/* NspGtkEditable inherits from NspGObject */ 

int nsp_type_gtkeditable_id=0;
NspTypeGtkEditable *nsp_type_gtkeditable=NULL;

NspTypeGtkEditable *new_type_gtkeditable(type_mode mode)
{
  NspTypeGtkEditable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkeditable != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkeditable;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkeditable_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkeditable_get_methods; 
  type->new = (new_func *) new_gtkeditable;

  /* specific methods for gtkeditable */
      
  type->init = (init_func *) init_gtkeditable;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkeditable */ 

  top->s_type =  (s_type_func *) gtkeditable_type_as_string;    
  top->sh_type = (sh_type_func *) gtkeditable_type_short_string;
  /* top->create = (create_func*) int_gtkeditable_create;*/ 
  
  /* specific methods for gtkeditable */
      
  type->init = (init_func *) init_gtkeditable;

  if ( nsp_type_gtkeditable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkEditable called nsp_type_gtkeditable
       */
      type->id =  nsp_type_gtkeditable_id = nsp_new_type_id();
      nsp_type_gtkeditable = type;
      if ( nsp_register_type(nsp_type_gtkeditable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkeditable, GTK_TYPE_EDITABLE);
      return ( mode == T_BASE ) ? type : new_type_gtkeditable(mode);
    }
  else 
    {
       type->id = nsp_type_gtkeditable_id;
       return type;
    }
}

/*
 * initialize GtkEditable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkeditable(NspGtkEditable *o,NspTypeGtkEditable *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkEditable 
 */

NspGtkEditable *new_gtkeditable() 
{
  NspGtkEditable *loc; 
  /* type must exists */
  nsp_type_gtkeditable = new_type_gtkeditable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkEditable)))== NULLGTKEDITABLE) return loc;
  /* initialize object */
  if ( init_gtkeditable(loc,nsp_type_gtkeditable) == FAIL) return NULLGTKEDITABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkEditable 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkeditable_type_name[]="GtkEditable";
static char gtkeditable_short_type_name[]="GtkEditable";

static char *gtkeditable_type_as_string(void)
{
  return(gtkeditable_type_name);
}

static char *gtkeditable_type_short_string(void)
{
  return(gtkeditable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkEditable objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkEditable   *gtkeditable_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_implements (O,nsp_type_gtkeditable_id) ) return ((NspGtkEditable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkeditable));
  return NULL;
}

int IsGtkEditableObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i) , nsp_type_gtkeditable_id);
}

int IsGtkEditable(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkeditable_id);
}

NspGtkEditable  *GetGtkEditableCopy(Stack stack, int i)
{
  if (  GetGtkEditable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkEditable  *GetGtkEditable(Stack stack, int i)
{
  NspGtkEditable *M;
  if (( M = gtkeditable_object(NthObj(i))) == NULLGTKEDITABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkEditable *gtkeditable_copy(NspGtkEditable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkeditable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkeditable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkEditable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkEditable *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkeditable is initialized * /
  nsp_type_gtkeditable = new_type_gtkeditable(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtkeditable)) == NULLGTKEDITABLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_editable_select_region(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int start, end;

  if ( GetArgs(stack,rhs,opt,T,&start, &end) == FAIL) return RET_BUG;
  gtk_editable_select_region(GTK_EDITABLE(self->obj), start, end);
  return 0;
}

#line 3671 "gtk.override"
static int
_wrap_gtk_editable_get_selection_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int start, end,  n= 0;

  if (gtk_editable_get_selection_bounds(GTK_EDITABLE(self->obj), &start, &end)) n = 2;
  if ( nsp_move_doubles(stack,1,1,2,(double) start,(double) end) == FAIL) return RET_BUG; 
  return 1;
}
#line 4542 "gtk.c"


#line 3652 "gtk.override"

static int _wrap_gtk_editable_insert_text(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,new_opts,t_end};
  nsp_option opts[] = {
    {"position",s_int,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1}};
  char *new_text;
  int new_text_length;
  int position = 0;

  if ( GetArgs(stack,rhs,opt,T, &new_text, opts, &position) == FAIL) return RET_BUG;
  new_text_length= strlen(new_text);
  gtk_editable_insert_text(GTK_EDITABLE(self->obj), new_text,new_text_length , &position);
  if ( nsp_move_double(stack,1,(double)position) == FAIL) return RET_BUG; 
  return 1;
}
#line 4563 "gtk.c"


static int _wrap_gtk_editable_delete_text(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int start_pos, end_pos;

  if ( GetArgs(stack,rhs,opt,T,&start_pos, &end_pos) == FAIL) return RET_BUG;
  gtk_editable_delete_text(GTK_EDITABLE(self->obj), start_pos, end_pos);
  return 0;
}

static int _wrap_gtk_editable_get_chars(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int start_pos, end_pos;
  gchar *ret;

  if ( GetArgs(stack,rhs,opt,T,&start_pos, &end_pos) == FAIL) return RET_BUG;
  ret = gtk_editable_get_chars(GTK_EDITABLE(self->obj), start_pos, end_pos);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_editable_cut_clipboard(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_editable_cut_clipboard(GTK_EDITABLE(self->obj));
  return 0;
}

static int _wrap_gtk_editable_copy_clipboard(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_editable_copy_clipboard(GTK_EDITABLE(self->obj));
  return 0;
}

static int _wrap_gtk_editable_paste_clipboard(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_editable_paste_clipboard(GTK_EDITABLE(self->obj));
  return 0;
}

static int _wrap_gtk_editable_delete_selection(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_editable_delete_selection(GTK_EDITABLE(self->obj));
  return 0;
}

static int _wrap_gtk_editable_set_position(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int position;

  if ( GetArgs(stack,rhs,opt,T,&position) == FAIL) return RET_BUG;
  gtk_editable_set_position(GTK_EDITABLE(self->obj), position);
  return 0;
}

static int _wrap_gtk_editable_get_position(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_editable_get_position(GTK_EDITABLE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_editable_set_editable(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int is_editable;

  if ( GetArgs(stack,rhs,opt,T,&is_editable) == FAIL) return RET_BUG;
  gtk_editable_set_editable(GTK_EDITABLE(self->obj), is_editable);
  return 0;
}

static int _wrap_gtk_editable_get_editable(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_editable_get_editable(GTK_EDITABLE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkeditable_methods[] = {
  {"select_region",(nsp_method *) _wrap_gtk_editable_select_region},
  {"get_selection_bounds",(nsp_method *) _wrap_gtk_editable_get_selection_bounds},
  {"insert_text",(nsp_method *) _wrap_gtk_editable_insert_text},
  {"delete_text",(nsp_method *) _wrap_gtk_editable_delete_text},
  {"get_chars",(nsp_method *) _wrap_gtk_editable_get_chars},
  {"cut_clipboard",(nsp_method *) _wrap_gtk_editable_cut_clipboard},
  {"copy_clipboard",(nsp_method *) _wrap_gtk_editable_copy_clipboard},
  {"paste_clipboard",(nsp_method *) _wrap_gtk_editable_paste_clipboard},
  {"delete_selection",(nsp_method *) _wrap_gtk_editable_delete_selection},
  {"set_position",(nsp_method *) _wrap_gtk_editable_set_position},
  {"get_position",(nsp_method *) _wrap_gtk_editable_get_position},
  {"set_editable",(nsp_method *) _wrap_gtk_editable_set_editable},
  {"get_editable",(nsp_method *) _wrap_gtk_editable_get_editable},
  { NULL, NULL}
};

static NspMethods *gtkeditable_get_methods(void) { return gtkeditable_methods;};
static AttrTab gtkeditable_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkCellEditable ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkCellEditable_Private 
#include "nsp/gtk/gtkcelleditable.h"
#include "nsp/interf.h"

/* NspGtkCellEditable inherits from NspGObject */ 

int nsp_type_gtkcelleditable_id=0;
NspTypeGtkCellEditable *nsp_type_gtkcelleditable=NULL;

NspTypeGtkCellEditable *new_type_gtkcelleditable(type_mode mode)
{
  NspTypeGtkCellEditable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcelleditable != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcelleditable;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcelleditable_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcelleditable_get_methods; 
  type->new = (new_func *) new_gtkcelleditable;

  /* specific methods for gtkcelleditable */
      
  type->init = (init_func *) init_gtkcelleditable;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcelleditable */ 

  top->s_type =  (s_type_func *) gtkcelleditable_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcelleditable_type_short_string;
  /* top->create = (create_func*) int_gtkcelleditable_create;*/ 
  
  /* specific methods for gtkcelleditable */
      
  type->init = (init_func *) init_gtkcelleditable;

  if ( nsp_type_gtkcelleditable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellEditable called nsp_type_gtkcelleditable
       */
      type->id =  nsp_type_gtkcelleditable_id = nsp_new_type_id();
      nsp_type_gtkcelleditable = type;
      if ( nsp_register_type(nsp_type_gtkcelleditable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcelleditable, GTK_TYPE_CELL_EDITABLE);
      return ( mode == T_BASE ) ? type : new_type_gtkcelleditable(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcelleditable_id;
       return type;
    }
}

/*
 * initialize GtkCellEditable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcelleditable(NspGtkCellEditable *o,NspTypeGtkCellEditable *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkCellEditable 
 */

NspGtkCellEditable *new_gtkcelleditable() 
{
  NspGtkCellEditable *loc; 
  /* type must exists */
  nsp_type_gtkcelleditable = new_type_gtkcelleditable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellEditable)))== NULLGTKCELLEDITABLE) return loc;
  /* initialize object */
  if ( init_gtkcelleditable(loc,nsp_type_gtkcelleditable) == FAIL) return NULLGTKCELLEDITABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkCellEditable 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcelleditable_type_name[]="GtkCellEditable";
static char gtkcelleditable_short_type_name[]="GtkCellEditable";

static char *gtkcelleditable_type_as_string(void)
{
  return(gtkcelleditable_type_name);
}

static char *gtkcelleditable_type_short_string(void)
{
  return(gtkcelleditable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkCellEditable objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkCellEditable   *gtkcelleditable_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_implements (O,nsp_type_gtkcelleditable_id) ) return ((NspGtkCellEditable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcelleditable));
  return NULL;
}

int IsGtkCellEditableObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i) , nsp_type_gtkcelleditable_id);
}

int IsGtkCellEditable(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkcelleditable_id);
}

NspGtkCellEditable  *GetGtkCellEditableCopy(Stack stack, int i)
{
  if (  GetGtkCellEditable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellEditable  *GetGtkCellEditable(Stack stack, int i)
{
  NspGtkCellEditable *M;
  if (( M = gtkcelleditable_object(NthObj(i))) == NULLGTKCELLEDITABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellEditable *gtkcelleditable_copy(NspGtkCellEditable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcelleditable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcelleditable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellEditable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkCellEditable *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcelleditable is initialized * /
  nsp_type_gtkcelleditable = new_type_gtkcelleditable(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtkcelleditable)) == NULLGTKCELLEDITABLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_cell_editable_start_editing(NspGtkCellEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event;

  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "event should be a GdkEvent");
      return RET_BUG;
  }
  gtk_cell_editable_start_editing(GTK_CELL_EDITABLE(self->obj), event);
  return 0;
}

static int _wrap_gtk_cell_editable_editing_done(NspGtkCellEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_cell_editable_editing_done(GTK_CELL_EDITABLE(self->obj));
  return 0;
}

static int _wrap_gtk_cell_editable_remove_widget(NspGtkCellEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_cell_editable_remove_widget(GTK_CELL_EDITABLE(self->obj));
  return 0;
}

static NspMethods gtkcelleditable_methods[] = {
  {"start_editing",(nsp_method *) _wrap_gtk_cell_editable_start_editing},
  {"editing_done",(nsp_method *) _wrap_gtk_cell_editable_editing_done},
  {"remove_widget",(nsp_method *) _wrap_gtk_cell_editable_remove_widget},
  { NULL, NULL}
};

static NspMethods *gtkcelleditable_get_methods(void) { return gtkcelleditable_methods;};
static AttrTab gtkcelleditable_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTreeModel ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTreeModel_Private 
#include "nsp/gtk/gtktreemodel.h"
#include "nsp/interf.h"

/* NspGtkTreeModel inherits from NspGObject */ 

int nsp_type_gtktreemodel_id=0;
NspTypeGtkTreeModel *nsp_type_gtktreemodel=NULL;

NspTypeGtkTreeModel *new_type_gtktreemodel(type_mode mode)
{
  NspTypeGtkTreeModel *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreemodel != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreemodel;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreemodel_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktreemodel_get_methods; 
  type->new = (new_func *) new_gtktreemodel;

  /* specific methods for gtktreemodel */
      
  type->init = (init_func *) init_gtktreemodel;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktreemodel */ 

  top->s_type =  (s_type_func *) gtktreemodel_type_as_string;    
  top->sh_type = (sh_type_func *) gtktreemodel_type_short_string;
  /* top->create = (create_func*) int_gtktreemodel_create;*/ 
  
  /* specific methods for gtktreemodel */
      
  type->init = (init_func *) init_gtktreemodel;

  if ( nsp_type_gtktreemodel_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeModel called nsp_type_gtktreemodel
       */
      type->id =  nsp_type_gtktreemodel_id = nsp_new_type_id();
      nsp_type_gtktreemodel = type;
      if ( nsp_register_type(nsp_type_gtktreemodel) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreemodel, GTK_TYPE_TREE_MODEL);
      return ( mode == T_BASE ) ? type : new_type_gtktreemodel(mode);
    }
  else 
    {
       type->id = nsp_type_gtktreemodel_id;
       return type;
    }
}

/*
 * initialize GtkTreeModel instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreemodel(NspGtkTreeModel *o,NspTypeGtkTreeModel *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTreeModel 
 */

NspGtkTreeModel *new_gtktreemodel() 
{
  NspGtkTreeModel *loc; 
  /* type must exists */
  nsp_type_gtktreemodel = new_type_gtktreemodel(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeModel)))== NULLGTKTREEMODEL) return loc;
  /* initialize object */
  if ( init_gtktreemodel(loc,nsp_type_gtktreemodel) == FAIL) return NULLGTKTREEMODEL;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTreeModel 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktreemodel_type_name[]="GtkTreeModel";
static char gtktreemodel_short_type_name[]="GtkTreeModel";

static char *gtktreemodel_type_as_string(void)
{
  return(gtktreemodel_type_name);
}

static char *gtktreemodel_type_short_string(void)
{
  return(gtktreemodel_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTreeModel objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTreeModel   *gtktreemodel_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_implements (O,nsp_type_gtktreemodel_id) ) return ((NspGtkTreeModel *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreemodel));
  return NULL;
}

int IsGtkTreeModelObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i) , nsp_type_gtktreemodel_id);
}

int IsGtkTreeModel(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtktreemodel_id);
}

NspGtkTreeModel  *GetGtkTreeModelCopy(Stack stack, int i)
{
  if (  GetGtkTreeModel(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeModel  *GetGtkTreeModel(Stack stack, int i)
{
  NspGtkTreeModel *M;
  if (( M = gtktreemodel_object(NthObj(i))) == NULLGTKTREEMODEL)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeModel *gtktreemodel_copy(NspGtkTreeModel *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreemodel);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreemodel);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeModel
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTreeModel *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktreemodel is initialized * /
  nsp_type_gtktreemodel = new_type_gtktreemodel(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtktreemodel)) == NULLGTKTREEMODEL) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_tree_model_get_flags(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;

  ret = gtk_tree_model_get_flags(GTK_TREE_MODEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_model_get_n_columns(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 1553 "gtk.override"
/* changed so as to return a NspType */
static int _wrap_gtk_tree_model_get_column_type(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  NspTypeBase *type;
  int_types T[] = {s_int,t_end};
  int index;
  GType ret;
  if ( GetArgs(stack,rhs,opt,T,&index) == FAIL) return RET_BUG;
  ret = gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj), index);
  type = nsp_type_from_gtype(ret);
  if ( type == NULL) return RET_BUG; 
  if ((nsp_ret = (NspObject *) type_create(NVOID,type ,NULL))== NULL) return RET_BUG; 
  MoveObj(stack,1,nsp_ret);
  return 1; 
}

#line 5134 "gtk.c"


#line 1572 "gtk.override"
static int
_wrap_gtk_tree_model_get_iter(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "path", NULL };*/
  int_types T[] = {obj, t_end} ;
  NspObject *nsp_path;
  GtkTreeIter iter;
  GtkTreePath *path;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T,&nsp_path)== FAIL) return RET_BUG;

  path = nsp_gtk_tree_path_from_nspobject(nsp_path);
  if (!path) {
    Scierror( "GtkTreeModel.get_iter requires a tree path as its argument");
    return RET_BUG;
  }
  
  if (gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter, path)) {
    gtk_tree_path_free(path);
    if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL) return RET_BUG;
    MoveObj(stack,1,ret);
    return 1;
  } else {
    gtk_tree_path_free(path);
    Scierror("invalid tree path");
    return RET_BUG;
  }
}
#line 5167 "gtk.c"


#line 1603 "gtk.override"
static int
_wrap_gtk_tree_model_get_iter_from_string(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end} ;
  /* static char *kwlist[] = { "path_string", NULL };*/
  const gchar *path_string;
  GtkTreeIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &path_string)== FAIL) return RET_BUG;

  if (gtk_tree_model_get_iter_from_string(GTK_TREE_MODEL(self->obj), &iter,
					  path_string)) {
    if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
    MoveObj(stack,1,ret);
    return 1;
  } else {
    Scierror("invalid tree path");
    return RET_BUG;
  }
}
#line 5192 "gtk.c"


#line 2392 "gtk.override"
static int
_wrap_gtk_tree_model_get_iter_first(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  
  if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->obj), &iter))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
	return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  return RET_BUG;
}
#line 5211 "gtk.c"


static int _wrap_gtk_tree_model_get_path(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter, *nsp_ret;
  GtkTreePath *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  ret = gtk_tree_model_get_path(GTK_TREE_MODEL(self->obj), iter);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret, FALSE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreepath))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 1626 "gtk.override"
static int
_wrap_gtk_tree_model_get_value(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { obj_check,s_int, t_end} ;
  /* static char *kwlist[] = { "iter", "column", NULL };*/
  NspObject *iter, *ret;
  gint column;
  GValue value = { 0, };

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeiter, &iter, &column)== FAIL) return RET_BUG;
  if (column < 0 ||
      column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
    Scierror("column number is out of range");
    return RET_BUG;
  }

  gtk_tree_model_get_value(GTK_TREE_MODEL(self->obj),
			   nspg_boxed_get(iter, GtkTreeIter), column, &value);
  ret = nspg_value_as_nspobject(&value, TRUE);
  g_value_unset(&value);
  if ( ret == NULLOBJ ) 
    {
      Scierror("Error: get_value method return a NULL Object \n");
      return RET_BUG;
    }
  MoveObj(stack,1,ret);
  return 1;
}
#line 5265 "gtk.c"


#line 2409 "gtk.override"
static int
_wrap_gtk_tree_model_iter_next(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end} ;
  int rep;
  /* static char *kwlist[] = { "iter", NULL };*/
  NspObject *nsp_iter;
  GtkTreeIter *iter;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeiter, &nsp_iter)== FAIL) return RET_BUG;
  iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  if ( iter->user_data == NULL) 
    rep = FALSE;
  else
    rep =  gtk_tree_model_iter_next(GTK_TREE_MODEL(self->obj), iter); 
  if ( nsp_move_boolean(stack,1,rep)==FAIL) return RET_BUG; 
  return 1;
}
#line 5287 "gtk.c"


#line 2429 "gtk.override"
static int
_wrap_gtk_tree_model_iter_children(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "parent", NULL };*/
  NspGtkTreeIter *nsp_parent;
  GtkTreeIter iter, *parent = NULL;

  if (GetArgs(stack,rhs,opt,T, &nsp_parent) == FAIL) return RET_BUG;
  if (nspg_boxed_check((NspObject *) nsp_parent, GTK_TYPE_TREE_ITER))
    parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
  else {
    Scierror( "parent should be a GtkTreeIter");
    return RET_BUG;
  }

  if (gtk_tree_model_iter_children(GTK_TREE_MODEL(self->obj),
				   &iter, parent))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  else {
    return RET_BUG;
  }
}
#line 5319 "gtk.c"


static int _wrap_gtk_tree_model_iter_has_child(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  ret = gtk_tree_model_iter_has_child(GTK_TREE_MODEL(self->obj), iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_model_iter_n_children(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else if (! IsNone(nsp_iter)) {
      Scierror("iter should be a GtkTreeIter or None");
      return RET_BUG;
  }
  ret = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(self->obj), iter);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 2459 "gtk.override"
static int
_wrap_gtk_tree_model_iter_nth_child(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int, t_end} ;
  /* static char *kwlist[] = { "parent", "n", NULL };*/
  NspObject *nsp_parent;
  gint n;
  GtkTreeIter iter, *parent = NULL;
  if (GetArgs(stack,rhs,opt,T,&nsp_parent, &n) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_parent, GTK_TYPE_TREE_ITER))
    parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
  else if ( IsNone(nsp_parent))
    parent = NULL;
  else {
    Scierror( "parent should be a GtkTreeIter or None");
    return RET_BUG;
  }

  if (gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(self->obj),
				    &iter, parent, n))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  else 
    return RET_BUG;
}
#line 5390 "gtk.c"


#line 2490 "gtk.override"
static int
_wrap_gtk_tree_model_iter_parent(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "child", NULL };*/
  NspObject *nsp_child;
  GtkTreeIter iter, *child = NULL;

  if (GetArgs(stack,rhs,opt,T, &nsp_child)== FAIL ) return RET_BUG;
  
  if (nspg_boxed_check(nsp_child, GTK_TYPE_TREE_ITER))
    child = nspg_boxed_get(nsp_child, GtkTreeIter);
  else {
    Scierror( "child should be a GtkTreeIter");
    return RET_BUG;
  }

  if (gtk_tree_model_iter_parent(GTK_TREE_MODEL(self->obj),
				 &iter, child))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  else {
    return RET_BUG;
  }
}
#line 5423 "gtk.c"


static int _wrap_gtk_tree_model_ref_node(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_model_ref_node(GTK_TREE_MODEL(self->obj), iter);
  return 0;
}

static int _wrap_gtk_tree_model_unref_node(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_model_unref_node(GTK_TREE_MODEL(self->obj), iter);
  return 0;
}

#line 2521 "gtk.override"

static gboolean
nspgtk_tree_foreach_marshal(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter,  gpointer data)
{
  NspObject *args[4];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 1,nargs = 3;
  gboolean ret = FALSE;

  nspg_block_threads();
  /* Il faut ici proteger les args avec des noms et 
   * viter de les construire a chaque itration .... XXXXXX
   */

  args[0] = (NspObject *) gobject_create("model",(GObject *)model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[1] = (NspObject *) gboxed_create("path",GTK_TYPE_TREE_PATH,path,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
  args[2] = (NspObject *) gboxed_create("iter",GTK_TYPE_TREE_ITER, iter,TRUE, TRUE,nsp_type_gtktreeiter);
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL ) goto end;
  if (cunote->data) 
    {
      args[3]= cunote->data; 
      nargs= 4;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end;

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  goto end; 
 end:
  {
    nspg_unblock_threads();
    return ret;
  }
}

static int
_wrap_gtk_tree_model_foreach(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify cunote;

  CheckRhs(1,2); 

  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 2 ) 
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }
  cunote.func = func;
  cunote.data = arg;
  gtk_tree_model_foreach(GTK_TREE_MODEL(self->obj), nspgtk_tree_foreach_marshal, &cunote);
  /* XXXX detecter les erreurs ? */
  return 0;
}
#line 5520 "gtk.c"


static int _wrap_gtk_tree_model_row_changed(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_path, *nsp_iter;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_model_row_changed(GTK_TREE_MODEL(self->obj), path, iter);
  return 0;
}

static int _wrap_gtk_tree_model_row_inserted(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_path, *nsp_iter;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_model_row_inserted(GTK_TREE_MODEL(self->obj), path, iter);
  return 0;
}

static int _wrap_gtk_tree_model_row_has_child_toggled(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_path, *nsp_iter;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_model_row_has_child_toggled(GTK_TREE_MODEL(self->obj), path, iter);
  return 0;
}

static int _wrap_gtk_tree_model_row_deleted(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  gtk_tree_model_row_deleted(GTK_TREE_MODEL(self->obj), path);
  return 0;
}

static int _wrap_gtk_tree_model_rows_reordered(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj, s_int,t_end};
  int new_order;
  GtkTreeIter *iter = NULL;
  NspObject *nsp_path, *nsp_iter;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_iter, &new_order) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_model_rows_reordered(GTK_TREE_MODEL(self->obj), path, iter, &new_order);
  return 0;
}

static NspMethods gtktreemodel_methods[] = {
  {"get_flags",(nsp_method *) _wrap_gtk_tree_model_get_flags},
  {"get_n_columns",(nsp_method *) _wrap_gtk_tree_model_get_n_columns},
  {"get_column_type",(nsp_method *) _wrap_gtk_tree_model_get_column_type},
  {"get_iter",(nsp_method *) _wrap_gtk_tree_model_get_iter},
  {"get_iter_from_string",(nsp_method *) _wrap_gtk_tree_model_get_iter_from_string},
  {"get_iter_root",(nsp_method *) _wrap_gtk_tree_model_get_iter_first},
  {"get_iter_first",(nsp_method *) _wrap_gtk_tree_model_get_iter_first},
  {"get_path",(nsp_method *) _wrap_gtk_tree_model_get_path},
  {"get_value",(nsp_method *) _wrap_gtk_tree_model_get_value},
  {"iter_next",(nsp_method *) _wrap_gtk_tree_model_iter_next},
  {"iter_children",(nsp_method *) _wrap_gtk_tree_model_iter_children},
  {"iter_has_child",(nsp_method *) _wrap_gtk_tree_model_iter_has_child},
  {"iter_n_children",(nsp_method *) _wrap_gtk_tree_model_iter_n_children},
  {"iter_nth_child",(nsp_method *) _wrap_gtk_tree_model_iter_nth_child},
  {"iter_parent",(nsp_method *) _wrap_gtk_tree_model_iter_parent},
  {"ref_node",(nsp_method *) _wrap_gtk_tree_model_ref_node},
  {"unref_node",(nsp_method *) _wrap_gtk_tree_model_unref_node},
  {"foreach",(nsp_method *) _wrap_gtk_tree_model_foreach},
  {"row_changed",(nsp_method *) _wrap_gtk_tree_model_row_changed},
  {"row_inserted",(nsp_method *) _wrap_gtk_tree_model_row_inserted},
  {"row_has_child_toggled",(nsp_method *) _wrap_gtk_tree_model_row_has_child_toggled},
  {"row_deleted",(nsp_method *) _wrap_gtk_tree_model_row_deleted},
  {"rows_reordered",(nsp_method *) _wrap_gtk_tree_model_rows_reordered},
  { NULL, NULL}
};

static NspMethods *gtktreemodel_get_methods(void) { return gtktreemodel_methods;};
static AttrTab gtktreemodel_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTreeDragSource ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTreeDragSource_Private 
#include "nsp/gtk/gtktreedragsource.h"
#include "nsp/interf.h"

/* NspGtkTreeDragSource inherits from NspGObject */ 

int nsp_type_gtktreedragsource_id=0;
NspTypeGtkTreeDragSource *nsp_type_gtktreedragsource=NULL;

NspTypeGtkTreeDragSource *new_type_gtktreedragsource(type_mode mode)
{
  NspTypeGtkTreeDragSource *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreedragsource != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreedragsource;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreedragsource_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktreedragsource_get_methods; 
  type->new = (new_func *) new_gtktreedragsource;

  /* specific methods for gtktreedragsource */
      
  type->init = (init_func *) init_gtktreedragsource;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktreedragsource */ 

  top->s_type =  (s_type_func *) gtktreedragsource_type_as_string;    
  top->sh_type = (sh_type_func *) gtktreedragsource_type_short_string;
  /* top->create = (create_func*) int_gtktreedragsource_create;*/ 
  
  /* specific methods for gtktreedragsource */
      
  type->init = (init_func *) init_gtktreedragsource;

  if ( nsp_type_gtktreedragsource_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeDragSource called nsp_type_gtktreedragsource
       */
      type->id =  nsp_type_gtktreedragsource_id = nsp_new_type_id();
      nsp_type_gtktreedragsource = type;
      if ( nsp_register_type(nsp_type_gtktreedragsource) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreedragsource, GTK_TYPE_TREE_DRAG_SOURCE);
      return ( mode == T_BASE ) ? type : new_type_gtktreedragsource(mode);
    }
  else 
    {
       type->id = nsp_type_gtktreedragsource_id;
       return type;
    }
}

/*
 * initialize GtkTreeDragSource instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreedragsource(NspGtkTreeDragSource *o,NspTypeGtkTreeDragSource *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTreeDragSource 
 */

NspGtkTreeDragSource *new_gtktreedragsource() 
{
  NspGtkTreeDragSource *loc; 
  /* type must exists */
  nsp_type_gtktreedragsource = new_type_gtktreedragsource(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeDragSource)))== NULLGTKTREEDRAGSOURCE) return loc;
  /* initialize object */
  if ( init_gtktreedragsource(loc,nsp_type_gtktreedragsource) == FAIL) return NULLGTKTREEDRAGSOURCE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTreeDragSource 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktreedragsource_type_name[]="GtkTreeDragSource";
static char gtktreedragsource_short_type_name[]="GtkTreeDragSource";

static char *gtktreedragsource_type_as_string(void)
{
  return(gtktreedragsource_type_name);
}

static char *gtktreedragsource_type_short_string(void)
{
  return(gtktreedragsource_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTreeDragSource objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTreeDragSource   *gtktreedragsource_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_implements (O,nsp_type_gtktreedragsource_id) ) return ((NspGtkTreeDragSource *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreedragsource));
  return NULL;
}

int IsGtkTreeDragSourceObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i) , nsp_type_gtktreedragsource_id);
}

int IsGtkTreeDragSource(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtktreedragsource_id);
}

NspGtkTreeDragSource  *GetGtkTreeDragSourceCopy(Stack stack, int i)
{
  if (  GetGtkTreeDragSource(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeDragSource  *GetGtkTreeDragSource(Stack stack, int i)
{
  NspGtkTreeDragSource *M;
  if (( M = gtktreedragsource_object(NthObj(i))) == NULLGTKTREEDRAGSOURCE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeDragSource *gtktreedragsource_copy(NspGtkTreeDragSource *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreedragsource);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreedragsource);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeDragSource
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTreeDragSource *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktreedragsource is initialized * /
  nsp_type_gtktreedragsource = new_type_gtktreedragsource(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtktreedragsource)) == NULLGTKTREEDRAGSOURCE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_tree_drag_source_row_draggable(NspGtkTreeDragSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  ret = gtk_tree_drag_source_row_draggable(GTK_TREE_DRAG_SOURCE(self->obj), path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_drag_source_drag_data_delete(NspGtkTreeDragSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  ret = gtk_tree_drag_source_drag_data_delete(GTK_TREE_DRAG_SOURCE(self->obj), path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_drag_source_drag_data_get(NspGtkTreeDragSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  int ret;
  GtkSelectionData *selection_data = NULL;
  NspObject *nsp_path, *nsp_selection_data;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_selection_data) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_selection_data, GTK_TYPE_SELECTION_DATA))
      selection_data = nspg_boxed_get(nsp_selection_data, GtkSelectionData);
  else {
      Scierror( "selection_data should be a GtkSelectionData");
      return RET_BUG;
  }
  ret = gtk_tree_drag_source_drag_data_get(GTK_TREE_DRAG_SOURCE(self->obj), path, selection_data);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktreedragsource_methods[] = {
  {"row_draggable",(nsp_method *) _wrap_gtk_tree_drag_source_row_draggable},
  {"drag_data_delete",(nsp_method *) _wrap_gtk_tree_drag_source_drag_data_delete},
  {"drag_data_get",(nsp_method *) _wrap_gtk_tree_drag_source_drag_data_get},
  { NULL, NULL}
};

static NspMethods *gtktreedragsource_get_methods(void) { return gtktreedragsource_methods;};
static AttrTab gtktreedragsource_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTreeDragDest ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTreeDragDest_Private 
#include "nsp/gtk/gtktreedragdest.h"
#include "nsp/interf.h"

/* NspGtkTreeDragDest inherits from NspGObject */ 

int nsp_type_gtktreedragdest_id=0;
NspTypeGtkTreeDragDest *nsp_type_gtktreedragdest=NULL;

NspTypeGtkTreeDragDest *new_type_gtktreedragdest(type_mode mode)
{
  NspTypeGtkTreeDragDest *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreedragdest != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreedragdest;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreedragdest_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktreedragdest_get_methods; 
  type->new = (new_func *) new_gtktreedragdest;

  /* specific methods for gtktreedragdest */
      
  type->init = (init_func *) init_gtktreedragdest;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktreedragdest */ 

  top->s_type =  (s_type_func *) gtktreedragdest_type_as_string;    
  top->sh_type = (sh_type_func *) gtktreedragdest_type_short_string;
  /* top->create = (create_func*) int_gtktreedragdest_create;*/ 
  
  /* specific methods for gtktreedragdest */
      
  type->init = (init_func *) init_gtktreedragdest;

  if ( nsp_type_gtktreedragdest_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeDragDest called nsp_type_gtktreedragdest
       */
      type->id =  nsp_type_gtktreedragdest_id = nsp_new_type_id();
      nsp_type_gtktreedragdest = type;
      if ( nsp_register_type(nsp_type_gtktreedragdest) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreedragdest, GTK_TYPE_TREE_DRAG_DEST);
      return ( mode == T_BASE ) ? type : new_type_gtktreedragdest(mode);
    }
  else 
    {
       type->id = nsp_type_gtktreedragdest_id;
       return type;
    }
}

/*
 * initialize GtkTreeDragDest instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreedragdest(NspGtkTreeDragDest *o,NspTypeGtkTreeDragDest *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTreeDragDest 
 */

NspGtkTreeDragDest *new_gtktreedragdest() 
{
  NspGtkTreeDragDest *loc; 
  /* type must exists */
  nsp_type_gtktreedragdest = new_type_gtktreedragdest(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeDragDest)))== NULLGTKTREEDRAGDEST) return loc;
  /* initialize object */
  if ( init_gtktreedragdest(loc,nsp_type_gtktreedragdest) == FAIL) return NULLGTKTREEDRAGDEST;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTreeDragDest 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktreedragdest_type_name[]="GtkTreeDragDest";
static char gtktreedragdest_short_type_name[]="GtkTreeDragDest";

static char *gtktreedragdest_type_as_string(void)
{
  return(gtktreedragdest_type_name);
}

static char *gtktreedragdest_type_short_string(void)
{
  return(gtktreedragdest_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTreeDragDest objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTreeDragDest   *gtktreedragdest_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_implements (O,nsp_type_gtktreedragdest_id) ) return ((NspGtkTreeDragDest *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreedragdest));
  return NULL;
}

int IsGtkTreeDragDestObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i) , nsp_type_gtktreedragdest_id);
}

int IsGtkTreeDragDest(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtktreedragdest_id);
}

NspGtkTreeDragDest  *GetGtkTreeDragDestCopy(Stack stack, int i)
{
  if (  GetGtkTreeDragDest(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeDragDest  *GetGtkTreeDragDest(Stack stack, int i)
{
  NspGtkTreeDragDest *M;
  if (( M = gtktreedragdest_object(NthObj(i))) == NULLGTKTREEDRAGDEST)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeDragDest *gtktreedragdest_copy(NspGtkTreeDragDest *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreedragdest);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreedragdest);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeDragDest
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTreeDragDest *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktreedragdest is initialized * /
  nsp_type_gtktreedragdest = new_type_gtktreedragdest(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtktreedragdest)) == NULLGTKTREEDRAGDEST) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_tree_drag_dest_drag_data_received(NspGtkTreeDragDest *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  int ret;
  GtkSelectionData *selection_data = NULL;
  NspObject *nsp_dest, *nsp_selection_data;
  GtkTreePath *dest = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_dest, &nsp_selection_data) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_dest, GTK_TYPE_TREE_PATH))
      dest = nspg_boxed_get(nsp_dest, GtkTreePath);
  else {
      Scierror( "dest should be a GtkTreePath");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_selection_data, GTK_TYPE_SELECTION_DATA))
      selection_data = nspg_boxed_get(nsp_selection_data, GtkSelectionData);
  else {
      Scierror( "selection_data should be a GtkSelectionData");
      return RET_BUG;
  }
  ret = gtk_tree_drag_dest_drag_data_received(GTK_TREE_DRAG_DEST(self->obj), dest, selection_data);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_drag_dest_row_drop_possible(NspGtkTreeDragDest *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  int ret;
  GtkSelectionData *selection_data = NULL;
  NspObject *nsp_dest_path, *nsp_selection_data;
  GtkTreePath *dest_path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_dest_path, &nsp_selection_data) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_dest_path, GTK_TYPE_TREE_PATH))
      dest_path = nspg_boxed_get(nsp_dest_path, GtkTreePath);
  else {
      Scierror( "dest_path should be a GtkTreePath");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_selection_data, GTK_TYPE_SELECTION_DATA))
      selection_data = nspg_boxed_get(nsp_selection_data, GtkSelectionData);
  else {
      Scierror( "selection_data should be a GtkSelectionData");
      return RET_BUG;
  }
  ret = gtk_tree_drag_dest_row_drop_possible(GTK_TREE_DRAG_DEST(self->obj), dest_path, selection_data);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktreedragdest_methods[] = {
  {"drag_data_received",(nsp_method *) _wrap_gtk_tree_drag_dest_drag_data_received},
  {"row_drop_possible",(nsp_method *) _wrap_gtk_tree_drag_dest_row_drop_possible},
  { NULL, NULL}
};

static NspMethods *gtktreedragdest_get_methods(void) { return gtktreedragdest_methods;};
static AttrTab gtktreedragdest_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTreeSortable ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTreeSortable_Private 
#include "nsp/gtk/gtktreesortable.h"
#include "nsp/interf.h"

/* NspGtkTreeSortable inherits from NspGObject */ 

int nsp_type_gtktreesortable_id=0;
NspTypeGtkTreeSortable *nsp_type_gtktreesortable=NULL;

NspTypeGtkTreeSortable *new_type_gtktreesortable(type_mode mode)
{
  NspTypeGtkTreeSortable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreesortable != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreesortable;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreesortable_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktreesortable_get_methods; 
  type->new = (new_func *) new_gtktreesortable;

  /* specific methods for gtktreesortable */
      
  type->init = (init_func *) init_gtktreesortable;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktreesortable */ 

  top->s_type =  (s_type_func *) gtktreesortable_type_as_string;    
  top->sh_type = (sh_type_func *) gtktreesortable_type_short_string;
  /* top->create = (create_func*) int_gtktreesortable_create;*/ 
  
  /* specific methods for gtktreesortable */
      
  type->init = (init_func *) init_gtktreesortable;

  if ( nsp_type_gtktreesortable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeSortable called nsp_type_gtktreesortable
       */
      type->id =  nsp_type_gtktreesortable_id = nsp_new_type_id();
      nsp_type_gtktreesortable = type;
      if ( nsp_register_type(nsp_type_gtktreesortable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreesortable, GTK_TYPE_TREE_SORTABLE);
      return ( mode == T_BASE ) ? type : new_type_gtktreesortable(mode);
    }
  else 
    {
       type->id = nsp_type_gtktreesortable_id;
       return type;
    }
}

/*
 * initialize GtkTreeSortable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreesortable(NspGtkTreeSortable *o,NspTypeGtkTreeSortable *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTreeSortable 
 */

NspGtkTreeSortable *new_gtktreesortable() 
{
  NspGtkTreeSortable *loc; 
  /* type must exists */
  nsp_type_gtktreesortable = new_type_gtktreesortable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeSortable)))== NULLGTKTREESORTABLE) return loc;
  /* initialize object */
  if ( init_gtktreesortable(loc,nsp_type_gtktreesortable) == FAIL) return NULLGTKTREESORTABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTreeSortable 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktreesortable_type_name[]="GtkTreeSortable";
static char gtktreesortable_short_type_name[]="GtkTreeSortable";

static char *gtktreesortable_type_as_string(void)
{
  return(gtktreesortable_type_name);
}

static char *gtktreesortable_type_short_string(void)
{
  return(gtktreesortable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTreeSortable objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTreeSortable   *gtktreesortable_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_implements (O,nsp_type_gtktreesortable_id) ) return ((NspGtkTreeSortable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreesortable));
  return NULL;
}

int IsGtkTreeSortableObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i) , nsp_type_gtktreesortable_id);
}

int IsGtkTreeSortable(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtktreesortable_id);
}

NspGtkTreeSortable  *GetGtkTreeSortableCopy(Stack stack, int i)
{
  if (  GetGtkTreeSortable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeSortable  *GetGtkTreeSortable(Stack stack, int i)
{
  NspGtkTreeSortable *M;
  if (( M = gtktreesortable_object(NthObj(i))) == NULLGTKTREESORTABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeSortable *gtktreesortable_copy(NspGtkTreeSortable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreesortable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreesortable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeSortable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTreeSortable *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktreesortable is initialized * /
  nsp_type_gtktreesortable = new_type_gtktreesortable(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtktreesortable)) == NULLGTKTREESORTABLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_tree_sortable_sort_column_changed(NspGtkTreeSortable *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_sortable_sort_column_changed(GTK_TREE_SORTABLE(self->obj));
  return 0;
}

#line 1742 "gtk.override"
static int
_wrap_gtk_tree_sortable_get_sort_column_id(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gboolean ret;
  gint sort_column_id, n=0;
  GtkSortType order;
  
  ret = gtk_tree_sortable_get_sort_column_id(GTK_TREE_SORTABLE(self->obj),
					     &sort_column_id, &order);
  if (ret) n = 2;
  if ( nsp_move_doubles(stack,1,1,n,(double) sort_column_id,(double) order) == FAIL) return RET_BUG; 
  return 1;
}
#line 6404 "gtk.c"


static int _wrap_gtk_tree_sortable_set_sort_column_id(NspGtkTreeSortable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, obj,t_end};
  int sort_column_id;
  NspObject *nsp_order = NULL;
  GtkSortType order;

  if ( GetArgs(stack,rhs,opt,T,&sort_column_id, &nsp_order) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SORT_TYPE, nsp_order, &order)== FAIL)
      return RET_BUG;
  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->obj), sort_column_id, order);
  return 0;
}

#line 1757 "gtk.override"
static gint
nspgtk_tree_sortable_sort_cb(GtkTreeModel *model, GtkTreeIter *iter1,
			     GtkTreeIter *iter2, gpointer user_data)
{
  NspObject *args[4];
  NspGtkCustomNotify *cunote = user_data;
  NspObject *nsp_ret;
  int nret = 1,nargs = 3;
  gint ret = 0;

  nspg_block_threads();

  args[0] = (NspObject *) gobject_create("model",(GObject *)model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[1] = (NspObject *) gboxed_create("iter1",GTK_TYPE_TREE_ITER, iter1,TRUE, TRUE,nsp_type_gtktreeiter);
  args[2] = (NspObject *) gboxed_create("iter2",GTK_TYPE_TREE_ITER, iter2,TRUE, TRUE,nsp_type_gtktreeiter);
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL ) goto end;
  if (cunote->data) 
    {
      args[3]= cunote->data; 
      nargs= 4;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end;

  if (nret ==1 && IsMat(nsp_ret) && ((NspMatrix *) nsp_ret)->mn==1 && ((NspMatrix *) nsp_ret)->rc_type == 'r' )
    ret =  ((NspMatrix *) nsp_ret)->R[0];
  goto end; 
 end:
  {
    nspg_unblock_threads();
    return ret;
  }
}

static int
_wrap_gtk_tree_sortable_set_sort_func(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint column;
  NspObject *nsp_func, *nsp_arg = NULL;
  NspGtkCustomNotify *cunote; 
  CheckRhs(2,3);
  if ( GetScalarInt(stack,1,&column) == FAIL) return RET_BUG; 
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,2)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 3 ) 
    {
      if (( nsp_arg = (NspObject *) GetListCopy(stack,3)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;
  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(self->obj), column,
				  nspgtk_tree_sortable_sort_cb, cunote,
				  nspgtk_custom_destroy_notify);
  return 0;
}

#line 6481 "gtk.c"


#line 1818 "gtk.override"
static int
_wrap_gtk_tree_sortable_set_default_sort_func(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_func, *nsp_arg = NULL;
  NspGtkCustomNotify *cunote; 
  CheckRhs(1,2);
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 2 ) 
    {
      if (( nsp_arg = (NspObject *) GetListCopy(stack,2)) == NULL) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;
  gtk_tree_sortable_set_default_sort_func(GTK_TREE_SORTABLE(self->obj),
					  nspgtk_tree_sortable_sort_cb,
					  cunote,
					  nspgtk_custom_destroy_notify);
  return 0;
}
#line 6508 "gtk.c"


static int _wrap_gtk_tree_sortable_has_default_sort_func(NspGtkTreeSortable *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_sortable_has_default_sort_func(GTK_TREE_SORTABLE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktreesortable_methods[] = {
  {"sort_column_changed",(nsp_method *) _wrap_gtk_tree_sortable_sort_column_changed},
  {"get_sort_column_id",(nsp_method *) _wrap_gtk_tree_sortable_get_sort_column_id},
  {"set_sort_column_id",(nsp_method *) _wrap_gtk_tree_sortable_set_sort_column_id},
  {"set_sort_func",(nsp_method *) _wrap_gtk_tree_sortable_set_sort_func},
  {"set_default_sort_func",(nsp_method *) _wrap_gtk_tree_sortable_set_default_sort_func},
  {"has_default_sort_func",(nsp_method *) _wrap_gtk_tree_sortable_has_default_sort_func},
  { NULL, NULL}
};

static NspMethods *gtktreesortable_get_methods(void) { return gtktreesortable_methods;};
static AttrTab gtktreesortable_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkAccelGroup ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkAccelGroup_Private 
#include "nsp/gtk/gtkaccelgroup.h"
#include "nsp/interf.h"

/* NspGtkAccelGroup inherits from NspGObject */ 

int nsp_type_gtkaccelgroup_id=0;
NspTypeGtkAccelGroup *nsp_type_gtkaccelgroup=NULL;

NspTypeGtkAccelGroup *new_type_gtkaccelgroup(type_mode mode)
{
  NspTypeGtkAccelGroup *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkaccelgroup != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkaccelgroup;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkaccelgroup_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkaccelgroup_get_methods; 
  type->new = (new_func *) new_gtkaccelgroup;

  /* specific methods for gtkaccelgroup */
      
  type->init = (init_func *) init_gtkaccelgroup;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkaccelgroup */ 

  top->s_type =  (s_type_func *) gtkaccelgroup_type_as_string;    
  top->sh_type = (sh_type_func *) gtkaccelgroup_type_short_string;
  /* top->create = (create_func*) int_gtkaccelgroup_create;*/ 
  
  /* specific methods for gtkaccelgroup */
      
  type->init = (init_func *) init_gtkaccelgroup;

  if ( nsp_type_gtkaccelgroup_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAccelGroup called nsp_type_gtkaccelgroup
       */
      type->id =  nsp_type_gtkaccelgroup_id = nsp_new_type_id();
      nsp_type_gtkaccelgroup = type;
      if ( nsp_register_type(nsp_type_gtkaccelgroup) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkaccelgroup, GTK_TYPE_ACCEL_GROUP);
      return ( mode == T_BASE ) ? type : new_type_gtkaccelgroup(mode);
    }
  else 
    {
       type->id = nsp_type_gtkaccelgroup_id;
       return type;
    }
}

/*
 * initialize GtkAccelGroup instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkaccelgroup(NspGtkAccelGroup *o,NspTypeGtkAccelGroup *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkAccelGroup 
 */

NspGtkAccelGroup *new_gtkaccelgroup() 
{
  NspGtkAccelGroup *loc; 
  /* type must exists */
  nsp_type_gtkaccelgroup = new_type_gtkaccelgroup(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAccelGroup)))== NULLGTKACCELGROUP) return loc;
  /* initialize object */
  if ( init_gtkaccelgroup(loc,nsp_type_gtkaccelgroup) == FAIL) return NULLGTKACCELGROUP;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkAccelGroup 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkaccelgroup_type_name[]="GtkAccelGroup";
static char gtkaccelgroup_short_type_name[]="GtkAccelGroup";

static char *gtkaccelgroup_type_as_string(void)
{
  return(gtkaccelgroup_type_name);
}

static char *gtkaccelgroup_type_short_string(void)
{
  return(gtkaccelgroup_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkAccelGroup objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkAccelGroup   *gtkaccelgroup_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkaccelgroup_id) ) return ((NspGtkAccelGroup *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkaccelgroup));
  return NULL;
}

int IsGtkAccelGroupObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkaccelgroup_id);
}

int IsGtkAccelGroup(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkaccelgroup_id);
}

NspGtkAccelGroup  *GetGtkAccelGroupCopy(Stack stack, int i)
{
  if (  GetGtkAccelGroup(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAccelGroup  *GetGtkAccelGroup(Stack stack, int i)
{
  NspGtkAccelGroup *M;
  if (( M = gtkaccelgroup_object(NthObj(i))) == NULLGTKACCELGROUP)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAccelGroup *gtkaccelgroup_copy(NspGtkAccelGroup *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccelgroup);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccelgroup);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAccelGroup
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkAccelGroup *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkaccelgroup is initialized * /
  nsp_type_gtkaccelgroup = new_type_gtkaccelgroup(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtkaccelgroup)) == NULLGTKACCELGROUP) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkaccelgroup_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_accel_group_new())== NULL) return RET_BUG;

  nsp_type_gtkaccelgroup = new_type_gtkaccelgroup(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkaccelgroup );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_accel_group_lock(NspGtkAccelGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_accel_group_lock(GTK_ACCEL_GROUP(self->obj));
  return 0;
}

static int _wrap_gtk_accel_group_unlock(NspGtkAccelGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_accel_group_unlock(GTK_ACCEL_GROUP(self->obj));
  return 0;
}

static int _wrap_gtk_accel_group_disconnect_key(NspGtkAccelGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, obj,t_end};
  int accel_key, ret;
  NspObject *nsp_accel_mods = NULL;
  GdkModifierType accel_mods;

  if ( GetArgs(stack,rhs,opt,T,&accel_key, &nsp_accel_mods) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accel_mods, &accel_mods)==FAIL)
      return RET_BUG;
  ret = gtk_accel_group_disconnect_key(GTK_ACCEL_GROUP(self->obj), accel_key, accel_mods);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkaccelgroup_methods[] = {
  {"lock",(nsp_method *) _wrap_gtk_accel_group_lock},
  {"unlock",(nsp_method *) _wrap_gtk_accel_group_unlock},
  {"disconnect_key",(nsp_method *) _wrap_gtk_accel_group_disconnect_key},
  { NULL, NULL}
};

static NspMethods *gtkaccelgroup_get_methods(void) { return gtkaccelgroup_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkaccelgroup_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkAccessible ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkAccessible_Private 
#include "nsp/gtk/gtkaccessible.h"
#include "nsp/interf.h"

/* NspGtkAccessible inherits from NspAtkObject */ 

int nsp_type_gtkaccessible_id=0;
NspTypeGtkAccessible *nsp_type_gtkaccessible=NULL;

NspTypeGtkAccessible *new_type_gtkaccessible(type_mode mode)
{
  NspTypeGtkAccessible *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkaccessible != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkaccessible;
    }
  if ((type =  malloc(sizeof(NspTypeAtkObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_atkobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkaccessible_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkaccessible_get_methods; 
  type->new = (new_func *) new_gtkaccessible;

  /* specific methods for gtkaccessible */
      
  type->init = (init_func *) init_gtkaccessible;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkaccessible */ 

  top->s_type =  (s_type_func *) gtkaccessible_type_as_string;    
  top->sh_type = (sh_type_func *) gtkaccessible_type_short_string;
  /* top->create = (create_func*) int_gtkaccessible_create;*/ 
  
  /* specific methods for gtkaccessible */
      
  type->init = (init_func *) init_gtkaccessible;

  if ( nsp_type_gtkaccessible_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAccessible called nsp_type_gtkaccessible
       */
      type->id =  nsp_type_gtkaccessible_id = nsp_new_type_id();
      nsp_type_gtkaccessible = type;
      if ( nsp_register_type(nsp_type_gtkaccessible) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkaccessible, GTK_TYPE_ACCESSIBLE);
      return ( mode == T_BASE ) ? type : new_type_gtkaccessible(mode);
    }
  else 
    {
       type->id = nsp_type_gtkaccessible_id;
       return type;
    }
}

/*
 * initialize GtkAccessible instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkaccessible(NspGtkAccessible *o,NspTypeGtkAccessible *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkAccessible 
 */

NspGtkAccessible *new_gtkaccessible() 
{
  NspGtkAccessible *loc; 
  /* type must exists */
  nsp_type_gtkaccessible = new_type_gtkaccessible(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAccessible)))== NULLGTKACCESSIBLE) return loc;
  /* initialize object */
  if ( init_gtkaccessible(loc,nsp_type_gtkaccessible) == FAIL) return NULLGTKACCESSIBLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkAccessible 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkaccessible_type_name[]="GtkAccessible";
static char gtkaccessible_short_type_name[]="GtkAccessible";

static char *gtkaccessible_type_as_string(void)
{
  return(gtkaccessible_type_name);
}

static char *gtkaccessible_type_short_string(void)
{
  return(gtkaccessible_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkAccessible objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkAccessible   *gtkaccessible_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkaccessible_id) ) return ((NspGtkAccessible *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkaccessible));
  return NULL;
}

int IsGtkAccessibleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkaccessible_id);
}

int IsGtkAccessible(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkaccessible_id);
}

NspGtkAccessible  *GetGtkAccessibleCopy(Stack stack, int i)
{
  if (  GetGtkAccessible(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAccessible  *GetGtkAccessible(Stack stack, int i)
{
  NspGtkAccessible *M;
  if (( M = gtkaccessible_object(NthObj(i))) == NULLGTKACCESSIBLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAccessible *gtkaccessible_copy(NspGtkAccessible *self)
{
  /* return atkobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccessible);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccessible);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAccessible
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkAccessible *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkaccessible is initialized * /
  nsp_type_gtkaccessible = new_type_gtkaccessible(T_BASE);
  if(( H = atkobject_create(NVOID,(NspTypeBase *) nsp_type_gtkaccessible)) == NULLGTKACCESSIBLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_accessible_connect_widget_destroyed(NspGtkAccessible *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_accessible_connect_widget_destroyed(GTK_ACCESSIBLE(self->obj));
  return 0;
}

static NspMethods gtkaccessible_methods[] = {
  {"connect_widget_destroyed",(nsp_method *) _wrap_gtk_accessible_connect_widget_destroyed},
  { NULL, NULL}
};

static NspMethods *gtkaccessible_get_methods(void) { return gtkaccessible_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkaccessible_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkIconFactory ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkIconFactory_Private 
#include "nsp/gtk/gtkiconfactory.h"
#include "nsp/interf.h"

/* NspGtkIconFactory inherits from NspGObject */ 

int nsp_type_gtkiconfactory_id=0;
NspTypeGtkIconFactory *nsp_type_gtkiconfactory=NULL;

NspTypeGtkIconFactory *new_type_gtkiconfactory(type_mode mode)
{
  NspTypeGtkIconFactory *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkiconfactory != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkiconfactory;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkiconfactory_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkiconfactory_get_methods; 
  type->new = (new_func *) new_gtkiconfactory;

  /* specific methods for gtkiconfactory */
      
  type->init = (init_func *) init_gtkiconfactory;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkiconfactory */ 

  top->s_type =  (s_type_func *) gtkiconfactory_type_as_string;    
  top->sh_type = (sh_type_func *) gtkiconfactory_type_short_string;
  /* top->create = (create_func*) int_gtkiconfactory_create;*/ 
  
  /* specific methods for gtkiconfactory */
      
  type->init = (init_func *) init_gtkiconfactory;

  if ( nsp_type_gtkiconfactory_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIconFactory called nsp_type_gtkiconfactory
       */
      type->id =  nsp_type_gtkiconfactory_id = nsp_new_type_id();
      nsp_type_gtkiconfactory = type;
      if ( nsp_register_type(nsp_type_gtkiconfactory) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkiconfactory, GTK_TYPE_ICON_FACTORY);
      return ( mode == T_BASE ) ? type : new_type_gtkiconfactory(mode);
    }
  else 
    {
       type->id = nsp_type_gtkiconfactory_id;
       return type;
    }
}

/*
 * initialize GtkIconFactory instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkiconfactory(NspGtkIconFactory *o,NspTypeGtkIconFactory *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkIconFactory 
 */

NspGtkIconFactory *new_gtkiconfactory() 
{
  NspGtkIconFactory *loc; 
  /* type must exists */
  nsp_type_gtkiconfactory = new_type_gtkiconfactory(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIconFactory)))== NULLGTKICONFACTORY) return loc;
  /* initialize object */
  if ( init_gtkiconfactory(loc,nsp_type_gtkiconfactory) == FAIL) return NULLGTKICONFACTORY;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkIconFactory 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkiconfactory_type_name[]="GtkIconFactory";
static char gtkiconfactory_short_type_name[]="GtkIconFactory";

static char *gtkiconfactory_type_as_string(void)
{
  return(gtkiconfactory_type_name);
}

static char *gtkiconfactory_type_short_string(void)
{
  return(gtkiconfactory_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkIconFactory objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkIconFactory   *gtkiconfactory_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkiconfactory_id) ) return ((NspGtkIconFactory *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkiconfactory));
  return NULL;
}

int IsGtkIconFactoryObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkiconfactory_id);
}

int IsGtkIconFactory(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkiconfactory_id);
}

NspGtkIconFactory  *GetGtkIconFactoryCopy(Stack stack, int i)
{
  if (  GetGtkIconFactory(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIconFactory  *GetGtkIconFactory(Stack stack, int i)
{
  NspGtkIconFactory *M;
  if (( M = gtkiconfactory_object(NthObj(i))) == NULLGTKICONFACTORY)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkIconFactory *gtkiconfactory_copy(NspGtkIconFactory *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkiconfactory);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkiconfactory);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIconFactory
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkIconFactory *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkiconfactory is initialized * /
  nsp_type_gtkiconfactory = new_type_gtkiconfactory(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtkiconfactory)) == NULLGTKICONFACTORY) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkiconfactory_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_icon_factory_new())== NULL) return RET_BUG;

  nsp_type_gtkiconfactory = new_type_gtkiconfactory(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkiconfactory );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_icon_factory_add(NspGtkIconFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj,t_end};
  char *stock_id;
  NspObject *nsp_icon_set;
  GtkIconSet *icon_set = NULL;

  if ( GetArgs(stack,rhs,opt,T,&stock_id, &nsp_icon_set) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_icon_set, GTK_TYPE_ICON_SET))
      icon_set = nspg_boxed_get(nsp_icon_set, GtkIconSet);
  else {
      Scierror( "icon_set should be a GtkIconSet");
      return RET_BUG;
  }
  gtk_icon_factory_add(GTK_ICON_FACTORY(self->obj), stock_id, icon_set);
  return 0;
}

static int _wrap_gtk_icon_factory_lookup(NspGtkIconFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *stock_id;
  NspObject *nsp_ret;
  GtkIconSet *ret;

  if ( GetArgs(stack,rhs,opt,T,&stock_id) == FAIL) return RET_BUG;
  ret = gtk_icon_factory_lookup(GTK_ICON_FACTORY(self->obj), stock_id);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_SET, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconset))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_icon_factory_add_default(NspGtkIconFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_icon_factory_add_default(GTK_ICON_FACTORY(self->obj));
  return 0;
}

static int _wrap_gtk_icon_factory_remove_default(NspGtkIconFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_icon_factory_remove_default(GTK_ICON_FACTORY(self->obj));
  return 0;
}

static NspMethods gtkiconfactory_methods[] = {
  {"add",(nsp_method *) _wrap_gtk_icon_factory_add},
  {"lookup",(nsp_method *) _wrap_gtk_icon_factory_lookup},
  {"add_default",(nsp_method *) _wrap_gtk_icon_factory_add_default},
  {"remove_default",(nsp_method *) _wrap_gtk_icon_factory_remove_default},
  { NULL, NULL}
};

static NspMethods *gtkiconfactory_get_methods(void) { return gtkiconfactory_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkiconfactory_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkObject ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkObject_Private 
#include "nsp/gtk/gtkobject.h"
#include "nsp/interf.h"

/* NspGtkObject inherits from NspGObject */ 

int nsp_type_gtkobject_id=0;
NspTypeGtkObject *nsp_type_gtkobject=NULL;

NspTypeGtkObject *new_type_gtkobject(type_mode mode)
{
  NspTypeGtkObject *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkobject != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkobject;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkobject_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkobject_get_methods; 
  type->new = (new_func *) new_gtkobject;

  /* specific methods for gtkobject */
      
  type->init = (init_func *) init_gtkobject;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkobject */ 

  top->s_type =  (s_type_func *) gtkobject_type_as_string;    
  top->sh_type = (sh_type_func *) gtkobject_type_short_string;
  /* top->create = (create_func*) int_gtkobject_create;*/ 
  
  /* specific methods for gtkobject */
      
  type->init = (init_func *) init_gtkobject;

  if ( nsp_type_gtkobject_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkObject called nsp_type_gtkobject
       */
      type->id =  nsp_type_gtkobject_id = nsp_new_type_id();
      nsp_type_gtkobject = type;
      if ( nsp_register_type(nsp_type_gtkobject) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkobject, GTK_TYPE_OBJECT);
      return ( mode == T_BASE ) ? type : new_type_gtkobject(mode);
    }
  else 
    {
       type->id = nsp_type_gtkobject_id;
       return type;
    }
}

/*
 * initialize GtkObject instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkobject(NspGtkObject *o,NspTypeGtkObject *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkObject 
 */

NspGtkObject *new_gtkobject() 
{
  NspGtkObject *loc; 
  /* type must exists */
  nsp_type_gtkobject = new_type_gtkobject(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkObject)))== NULLGTKOBJECT) return loc;
  /* initialize object */
  if ( init_gtkobject(loc,nsp_type_gtkobject) == FAIL) return NULLGTKOBJECT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkObject 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkobject_type_name[]="GtkObject";
static char gtkobject_short_type_name[]="GtkObject";

static char *gtkobject_type_as_string(void)
{
  return(gtkobject_type_name);
}

static char *gtkobject_type_short_string(void)
{
  return(gtkobject_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkObject objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkObject   *gtkobject_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkobject_id) ) return ((NspGtkObject *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkobject));
  return NULL;
}

int IsGtkObjectObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkobject_id);
}

int IsGtkObject(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkobject_id);
}

NspGtkObject  *GetGtkObjectCopy(Stack stack, int i)
{
  if (  GetGtkObject(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkObject  *GetGtkObject(Stack stack, int i)
{
  NspGtkObject *M;
  if (( M = gtkobject_object(NthObj(i))) == NULLGTKOBJECT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkObject *gtkobject_copy(NspGtkObject *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkobject);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkobject);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkObject
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkObject *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkobject is initialized * /
  nsp_type_gtkobject = new_type_gtkobject(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtkobject)) == NULLGTKOBJECT) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_GTK_OBJECT_FLAGS(NspGtkObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = GTK_OBJECT_FLAGS(GTK_OBJECT(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_GTK_OBJECT_SET_FLAGS(NspGtkObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int flags;

  if ( GetArgs(stack,rhs,opt,T,&flags) == FAIL) return RET_BUG;
  GTK_OBJECT_SET_FLAGS(GTK_OBJECT(self->obj), flags);
  return 0;
}

static int _wrap_GTK_OBJECT_UNSET_FLAGS(NspGtkObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int flags;

  if ( GetArgs(stack,rhs,opt,T,&flags) == FAIL) return RET_BUG;
  GTK_OBJECT_UNSET_FLAGS(GTK_OBJECT(self->obj), flags);
  return 0;
}

static int _wrap_gtk_object_destroy(NspGtkObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_object_destroy(GTK_OBJECT(self->obj));
  return 0;
}

static NspMethods gtkobject_methods[] = {
  {"flags",(nsp_method *) _wrap_GTK_OBJECT_FLAGS},
  {"set_flags",(nsp_method *) _wrap_GTK_OBJECT_SET_FLAGS},
  {"unset_flags",(nsp_method *) _wrap_GTK_OBJECT_UNSET_FLAGS},
  {"destroy",(nsp_method *) _wrap_gtk_object_destroy},
  { NULL, NULL}
};

static NspMethods *gtkobject_get_methods(void) { return gtkobject_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkobject_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkItemFactory ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkItemFactory_Private 
#include "nsp/gtk/gtkitemfactory.h"
#include "nsp/interf.h"

/* NspGtkItemFactory inherits from NspGtkObject */ 

int nsp_type_gtkitemfactory_id=0;
NspTypeGtkItemFactory *nsp_type_gtkitemfactory=NULL;

NspTypeGtkItemFactory *new_type_gtkitemfactory(type_mode mode)
{
  NspTypeGtkItemFactory *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkitemfactory != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkitemfactory;
    }
  if ((type =  malloc(sizeof(NspTypeGtkObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkitemfactory_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkitemfactory_get_methods; 
  type->new = (new_func *) new_gtkitemfactory;

  /* specific methods for gtkitemfactory */
      
  type->init = (init_func *) init_gtkitemfactory;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkitemfactory */ 

  top->s_type =  (s_type_func *) gtkitemfactory_type_as_string;    
  top->sh_type = (sh_type_func *) gtkitemfactory_type_short_string;
  /* top->create = (create_func*) int_gtkitemfactory_create;*/ 
  
  /* specific methods for gtkitemfactory */
      
  type->init = (init_func *) init_gtkitemfactory;

  if ( nsp_type_gtkitemfactory_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkItemFactory called nsp_type_gtkitemfactory
       */
      type->id =  nsp_type_gtkitemfactory_id = nsp_new_type_id();
      nsp_type_gtkitemfactory = type;
      if ( nsp_register_type(nsp_type_gtkitemfactory) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkitemfactory, GTK_TYPE_ITEM_FACTORY);
      return ( mode == T_BASE ) ? type : new_type_gtkitemfactory(mode);
    }
  else 
    {
       type->id = nsp_type_gtkitemfactory_id;
       return type;
    }
}

/*
 * initialize GtkItemFactory instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkitemfactory(NspGtkItemFactory *o,NspTypeGtkItemFactory *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkItemFactory 
 */

NspGtkItemFactory *new_gtkitemfactory() 
{
  NspGtkItemFactory *loc; 
  /* type must exists */
  nsp_type_gtkitemfactory = new_type_gtkitemfactory(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkItemFactory)))== NULLGTKITEMFACTORY) return loc;
  /* initialize object */
  if ( init_gtkitemfactory(loc,nsp_type_gtkitemfactory) == FAIL) return NULLGTKITEMFACTORY;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkItemFactory 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkitemfactory_type_name[]="GtkItemFactory";
static char gtkitemfactory_short_type_name[]="GtkItemFactory";

static char *gtkitemfactory_type_as_string(void)
{
  return(gtkitemfactory_type_name);
}

static char *gtkitemfactory_type_short_string(void)
{
  return(gtkitemfactory_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkItemFactory objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkItemFactory   *gtkitemfactory_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkitemfactory_id) ) return ((NspGtkItemFactory *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkitemfactory));
  return NULL;
}

int IsGtkItemFactoryObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkitemfactory_id);
}

int IsGtkItemFactory(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkitemfactory_id);
}

NspGtkItemFactory  *GetGtkItemFactoryCopy(Stack stack, int i)
{
  if (  GetGtkItemFactory(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkItemFactory  *GetGtkItemFactory(Stack stack, int i)
{
  NspGtkItemFactory *M;
  if (( M = gtkitemfactory_object(NthObj(i))) == NULLGTKITEMFACTORY)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkItemFactory *gtkitemfactory_copy(NspGtkItemFactory *self)
{
  /* return gtkobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkitemfactory);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkitemfactory);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkItemFactory
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkItemFactory *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkitemfactory is initialized * /
  nsp_type_gtkitemfactory = new_type_gtkitemfactory(T_BASE);
  if(( H = gtkobject_create(NVOID,(NspTypeBase *) nsp_type_gtkitemfactory)) == NULLGTKITEMFACTORY) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 3694 "gtk.override"
static int
_wrap_gtkitemfactory_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string ,string,new_opts,t_end};
  nsp_option opts[] = {
	{"accel_group",obj_check,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  char *path;
  NspGObject *nsp_accel_group = NULL;
  GType container_type;
  char *nsp_container_type;
  GtkAccelGroup *accel_group = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_container_type, &path, opts,&nsp_type_gtkaccelgroup, &nsp_accel_group) == FAIL) return RET_BUG;
  if ( strcmp(nsp_container_type,"menu_bar") == 0) 
    container_type = GTK_TYPE_MENU_BAR; 
  else if ( strcmp(nsp_container_type,"menu") == 0) 
    container_type = GTK_TYPE_MENU; 
  else if ( strcmp(nsp_container_type,"optio_menu") == 0) 
    container_type = GTK_TYPE_OPTION_MENU; 
  else 
    {
      Scierror("%s: first argument should be \"menu_bar\", \"menu\" or \"optio_menu\"\n",stack.fname); 
      return RET_BUG;
    }
  if ( nsp_accel_group != NULL ) accel_group = GTK_ACCEL_GROUP(nsp_accel_group->obj);

  if ((ret = (GObject *)gtk_item_factory_new(container_type, path, accel_group))== NULL) return RET_BUG;
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkitemfactory))== NULL) 
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 7736 "gtk.c"


static int _wrap_gtk_item_factory_construct(NspGtkItemFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, string, obj_check,t_end};
  char *path;
  NspGObject *accel_group;
  GType container_type;
  NspObject *nsp_container_type = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_container_type, &path, &nsp_type_gtkaccelgroup, &accel_group) == FAIL) return RET_BUG;
  if ((container_type = nspg_type_from_object(nsp_container_type)) == FAIL)
      return RET_BUG;
  gtk_item_factory_construct(GTK_ITEM_FACTORY(self->obj), container_type, path, GTK_ACCEL_GROUP(accel_group->obj));
  return 0;
}

#line 3730 "gtk.override"
static int _wrap_gtk_item_factory_get_item(NspGtkItemFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  
  int_types T[] = {string,t_end};
  char *path;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
  ret = gtk_item_factory_get_item(GTK_ITEM_FACTORY(self->obj), path);
  if ((nsp_ret = (NspObject *) gobject_gettype_and_create(NVOID,(GObject *)ret))== NULL) 
    return RET_BUG;  
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 7770 "gtk.c"


#line 3747 "gtk.override"
static int _wrap_gtk_item_factory_get_widget(NspGtkItemFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *path;
  NspObject *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
  ret = gtk_item_factory_get_widget(GTK_ITEM_FACTORY(self->obj), path);
  if ((nsp_ret = (NspObject *) gobject_gettype_and_create(NVOID,(GObject *)ret))== NULL) 
    return RET_BUG;  
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 7787 "gtk.c"


static int _wrap_gtk_item_factory_get_widget_by_action(NspGtkItemFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int action;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&action) == FAIL) return RET_BUG;
  ret = gtk_item_factory_get_widget_by_action(GTK_ITEM_FACTORY(self->obj), action);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_item_factory_get_item_by_action(NspGtkItemFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int action;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&action) == FAIL) return RET_BUG;
  ret = gtk_item_factory_get_item_by_action(GTK_ITEM_FACTORY(self->obj), action);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 3762 "gtk.override"
static void
nspgtk_item_factory_cb(NspGtkCustomNotify *cunote,
		       guint action, GtkWidget *widget)
{
  NspObject *args[3];
  NspObject *nsp_ret;
  int nret = 1,nargs = 2, pos=0;
  nspg_block_threads();
  args[0] = (NspObject *) gobject_gettype_and_create("widget",(GObject *)widget);

  if (cunote->data) 
    {
      args[0]= cunote->data; 
      nargs= 3;
      pos=1;
    }
  args[pos] =  (NspObject *)nsp_create_object_from_double("action",(double) action);
  args[pos+1]= (NspObject *) gobject_gettype_and_create("widget",(GObject *)widget); 
  if (args[0]==NULL|| args[pos]== NULL || args[pos+1]== NULL) goto end; 
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end ;
  /* 
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  */
  goto end; 
 end: 
  {
    nspg_unblock_threads();
    return;
  }
}

static int
_wrap_gtk_item_factory_create_items(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "entries", "callback_data", NULL };*/
  int_types T[] = {list,list, t_end} ;
  NspList *list;
  NspObject  *cb, *cbdata = NULL;
  GtkItemFactoryEntry ent;
  NspObject *extra_data = NULL;
  GtkItemFactory *ifact;
  int i;
  Cell *cloc;

  if (GetArgs(stack,rhs,opt,T, &list, &cbdata)== FAIL) return RET_BUG;

  ifact = GTK_ITEM_FACTORY(self->obj);

  cloc = list->first; 
  i=1;
  while ( cloc != NULLCELL) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  NspGtkCustomNotify *cunote = NULL;
	  NspList *item = (NspList *) cloc->O;
	  memset(&ent, 0, sizeof(ent));
	  cb = NULL;
	  int_types kT[]={ string,string,obj,s_int,string,obj,list_end};
	  if ( !IsList(cloc->O) ) 
	    {
	      Scierror("%s: list element %d has wrong type\n",stack.fname,i);
	      return RET_BUG;
	    }

	  if ( GetListArgs(item,1,kT,&(ent.path), &(ent.accelerator),
			   &cb, &(ent.callback_action), &(ent.item_type),
			   &extra_data) == FAIL ) 
	    {
	      Scierror("%s: list element %d should be a list\n",stack.fname,i);
	      return RET_BUG;
	    }
	  if ( IsNone(cb )) 
	    {
	      ent.callback = NULL;
	    } 
	  else if (IsNspPList(cb))
	    {
	      if (( cb =nsp_object_copy( cb)) == NULLOBJ ) return RET_BUG;
	      if ((nsp_object_set_name(cb,"callback")== FAIL)) return RET_BUG;
	      /* user_data */
	      if ( cbdata != NULL ) 
		{
		  if ((cbdata =(NspObject *)nsp_list_copy((NspList *)cbdata)) == NULL ) return RET_BUG;
		  if ((nsp_object_set_name((NspObject *)cbdata,"m")== FAIL)) return RET_BUG;
		} 
	      ent.callback = (GtkItemFactoryCallback)nspgtk_item_factory_cb;
	      cunote = g_new0(NspGtkCustomNotify, 1);
	      cunote->func = cb;
	      cunote->data = cbdata;
	    }
	  else 
	    {
	      Scierror("%s: list element %d callback can be None or a function\n",stack.fname,i);
	      return RET_BUG;
	    }
	  if ( IsSMat(extra_data) && ((NspSMatrix *) extra_data)->mn == 1)
	    {
	      ent.extra_data = g_strdup(((NspSMatrix *) extra_data)->S[0]);
	    }
	  else if ( IsGdkPixbuf(extra_data)) 
	    {
	      ent.extra_data = GDK_PIXBUF(nspgobject_get(extra_data));
	    }
	  else if ( IsNone(extra_data))
	    {
	      ent.extra_data=NULL;
	    }
	  else 
	    {
	      Scierror("%s: list element %d last argument must be a GdkPixBuf or a string\n",
		       stack.fname,i);
	      return RET_BUG;
	    }
	  if (cunote != NULL) {
	    nspg_block_threads();
	    g_object_weak_ref(G_OBJECT(ifact), (GWeakNotify) nspgtk_custom_destroy_notify,  cunote);
	    nspg_unblock_threads();
	  }
	  gtk_item_factory_create_item(ifact, &ent, cunote, 1);
	}
      cloc = cloc->next;
      i++;
    }
  return 0;
}
#line 7949 "gtk.c"


static int _wrap_gtk_item_factory_delete_item(NspGtkItemFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *path;

  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
  gtk_item_factory_delete_item(GTK_ITEM_FACTORY(self->obj), path);
  return 0;
}

static int _wrap_gtk_item_factory_popup(NspGtkItemFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int, s_int,new_opts,t_end};
  nsp_option opts[] = {
	{"time",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int x, y, mouse_button;
  gulong time = GDK_CURRENT_TIME;

  if ( GetArgs(stack,rhs,opt,T,&x, &y, &mouse_button, opts, &time) == FAIL) return RET_BUG;
  gtk_item_factory_popup(GTK_ITEM_FACTORY(self->obj), x, y, mouse_button, time);
  return 0;
}

static NspMethods gtkitemfactory_methods[] = {
  {"construct",(nsp_method *) _wrap_gtk_item_factory_construct},
  {"get_item",(nsp_method *) _wrap_gtk_item_factory_get_item},
  {"get_widget",(nsp_method *) _wrap_gtk_item_factory_get_widget},
  {"get_widget_by_action",(nsp_method *) _wrap_gtk_item_factory_get_widget_by_action},
  {"get_item_by_action",(nsp_method *) _wrap_gtk_item_factory_get_item_by_action},
  {"create_items",(nsp_method *) _wrap_gtk_item_factory_create_items},
  {"delete_item",(nsp_method *) _wrap_gtk_item_factory_delete_item},
  {"popup",(nsp_method *) _wrap_gtk_item_factory_popup},
  { NULL, NULL}
};

static NspMethods *gtkitemfactory_get_methods(void) { return gtkitemfactory_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkitemfactory_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkIMContext ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkIMContext_Private 
#include "nsp/gtk/gtkimcontext.h"
#include "nsp/interf.h"

/* NspGtkIMContext inherits from NspGtkObject */ 

int nsp_type_gtkimcontext_id=0;
NspTypeGtkIMContext *nsp_type_gtkimcontext=NULL;

NspTypeGtkIMContext *new_type_gtkimcontext(type_mode mode)
{
  NspTypeGtkIMContext *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkimcontext != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkimcontext;
    }
  if ((type =  malloc(sizeof(NspTypeGtkObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkimcontext_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkimcontext_get_methods; 
  type->new = (new_func *) new_gtkimcontext;

  /* specific methods for gtkimcontext */
      
  type->init = (init_func *) init_gtkimcontext;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkimcontext */ 

  top->s_type =  (s_type_func *) gtkimcontext_type_as_string;    
  top->sh_type = (sh_type_func *) gtkimcontext_type_short_string;
  /* top->create = (create_func*) int_gtkimcontext_create;*/ 
  
  /* specific methods for gtkimcontext */
      
  type->init = (init_func *) init_gtkimcontext;

  if ( nsp_type_gtkimcontext_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIMContext called nsp_type_gtkimcontext
       */
      type->id =  nsp_type_gtkimcontext_id = nsp_new_type_id();
      nsp_type_gtkimcontext = type;
      if ( nsp_register_type(nsp_type_gtkimcontext) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkimcontext, GTK_TYPE_IM_CONTEXT);
      return ( mode == T_BASE ) ? type : new_type_gtkimcontext(mode);
    }
  else 
    {
       type->id = nsp_type_gtkimcontext_id;
       return type;
    }
}

/*
 * initialize GtkIMContext instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkimcontext(NspGtkIMContext *o,NspTypeGtkIMContext *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkIMContext 
 */

NspGtkIMContext *new_gtkimcontext() 
{
  NspGtkIMContext *loc; 
  /* type must exists */
  nsp_type_gtkimcontext = new_type_gtkimcontext(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIMContext)))== NULLGTKIMCONTEXT) return loc;
  /* initialize object */
  if ( init_gtkimcontext(loc,nsp_type_gtkimcontext) == FAIL) return NULLGTKIMCONTEXT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkIMContext 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkimcontext_type_name[]="GtkIMContext";
static char gtkimcontext_short_type_name[]="GtkIMContext";

static char *gtkimcontext_type_as_string(void)
{
  return(gtkimcontext_type_name);
}

static char *gtkimcontext_type_short_string(void)
{
  return(gtkimcontext_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkIMContext objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkIMContext   *gtkimcontext_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkimcontext_id) ) return ((NspGtkIMContext *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkimcontext));
  return NULL;
}

int IsGtkIMContextObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkimcontext_id);
}

int IsGtkIMContext(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkimcontext_id);
}

NspGtkIMContext  *GetGtkIMContextCopy(Stack stack, int i)
{
  if (  GetGtkIMContext(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIMContext  *GetGtkIMContext(Stack stack, int i)
{
  NspGtkIMContext *M;
  if (( M = gtkimcontext_object(NthObj(i))) == NULLGTKIMCONTEXT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkIMContext *gtkimcontext_copy(NspGtkIMContext *self)
{
  /* return gtkobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimcontext);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimcontext);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIMContext
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkIMContext *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkimcontext is initialized * /
  nsp_type_gtkimcontext = new_type_gtkimcontext(T_BASE);
  if(( H = gtkobject_create(NVOID,(NspTypeBase *) nsp_type_gtkimcontext)) == NULLGTKIMCONTEXT) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_im_context_set_client_window(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *window;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window) == FAIL) return RET_BUG;
  gtk_im_context_set_client_window(GTK_IM_CONTEXT(self->obj), GDK_WINDOW(window->obj));
  return 0;
}

#line 6229 "gtk.override"
static int
_wrap_gtk_im_context_get_preedit_string(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* 
  gchar *str;
  PangoAttrList *attrs;
  gint cursor_pos;
  NspObject *ret;

  gtk_im_context_get_preedit_string(GTK_IM_CONTEXT(self->obj),
				    &str, &attrs, &cursor_pos);
  
  ret = Nsp_BuildValue("(sNi)", str, (NspObject *) gboxed_create(NVOID,PANGO_TYPE_ATTR_LIST, attrs,TRUE,TRUE,NULL),
  cursor_pos);
  g_free(str);

  return ret;
  */
  Scierror(" To be done gtk_im_context_get_preedit_string");
  return 0;
}
#line 8221 "gtk.c"


#line 6252 "gtk.override"
static int
_wrap_gtk_im_context_filter_keypress(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "key", NULL };*/
  NspObject *key;
  int ret;
  
  if (GetArgs(stack,rhs,opt,T,&key)  == FAIL) return RET_BUG;;
  
  if (!nspg_boxed_check(key, GDK_TYPE_EVENT)) {
    Scierror( "key must be a GdkEvent");
    return RET_BUG;
  }

  ret = gtk_im_context_filter_keypress(GTK_IM_CONTEXT(self->obj),
				       nspg_boxed_get(key, GdkEventKey));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG; 
  return 1;
}
#line 8245 "gtk.c"


static int _wrap_gtk_im_context_focus_in(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_im_context_focus_in(GTK_IM_CONTEXT(self->obj));
  return 0;
}

static int _wrap_gtk_im_context_focus_out(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_im_context_focus_out(GTK_IM_CONTEXT(self->obj));
  return 0;
}

static int _wrap_gtk_im_context_reset(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_im_context_reset(GTK_IM_CONTEXT(self->obj));
  return 0;
}

static int _wrap_gtk_im_context_set_cursor_location(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GdkRectangle area = { 0, 0, 0, 0 };
  NspObject *nsp_area;

  if ( GetArgs(stack,rhs,opt,T,&nsp_area) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_area, &area))
      return RET_BUG;
  gtk_im_context_set_cursor_location(GTK_IM_CONTEXT(self->obj), &area);
  return 0;
}

static int _wrap_gtk_im_context_set_use_preedit(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int use_preedit;

  if ( GetArgs(stack,rhs,opt,T,&use_preedit) == FAIL) return RET_BUG;
  gtk_im_context_set_use_preedit(GTK_IM_CONTEXT(self->obj), use_preedit);
  return 0;
}

static int _wrap_gtk_im_context_set_surrounding(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, s_int, s_int,t_end};
  char *text;
  int len, cursor_index;

  if ( GetArgs(stack,rhs,opt,T,&text, &len, &cursor_index) == FAIL) return RET_BUG;
  gtk_im_context_set_surrounding(GTK_IM_CONTEXT(self->obj), text, len, cursor_index);
  return 0;
}

#line 6274 "gtk.override"
static int
_wrap_gtk_im_context_get_surrounding(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[]={string,s_int,t_end};
  gchar *text;
  gint cursor_index;
  int rep;
  if ( !gtk_im_context_get_surrounding(GTK_IM_CONTEXT(self->obj), &text, &cursor_index)) 
    {
      Scierror("%s: cannot get text\n",stack.fname);
      return RET_BUG; 
    }
  rep = RetArgs(stack,lhs,T, text, cursor_index);
  g_free(text);
  return rep;
}
#line 8317 "gtk.c"


static int _wrap_gtk_im_context_delete_surrounding(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int offset, n_chars, ret;

  if ( GetArgs(stack,rhs,opt,T,&offset, &n_chars) == FAIL) return RET_BUG;
  ret = gtk_im_context_delete_surrounding(GTK_IM_CONTEXT(self->obj), offset, n_chars);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkimcontext_methods[] = {
  {"set_client_window",(nsp_method *) _wrap_gtk_im_context_set_client_window},
  {"get_preedit_string",(nsp_method *) _wrap_gtk_im_context_get_preedit_string},
  {"filter_keypress",(nsp_method *) _wrap_gtk_im_context_filter_keypress},
  {"focus_in",(nsp_method *) _wrap_gtk_im_context_focus_in},
  {"focus_out",(nsp_method *) _wrap_gtk_im_context_focus_out},
  {"reset",(nsp_method *) _wrap_gtk_im_context_reset},
  {"set_cursor_location",(nsp_method *) _wrap_gtk_im_context_set_cursor_location},
  {"set_use_preedit",(nsp_method *) _wrap_gtk_im_context_set_use_preedit},
  {"set_surrounding",(nsp_method *) _wrap_gtk_im_context_set_surrounding},
  {"get_surrounding",(nsp_method *) _wrap_gtk_im_context_get_surrounding},
  {"delete_surrounding",(nsp_method *) _wrap_gtk_im_context_delete_surrounding},
  { NULL, NULL}
};

static NspMethods *gtkimcontext_get_methods(void) { return gtkimcontext_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkimcontext_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkIMContextSimple ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkIMContextSimple_Private 
#include "nsp/gtk/gtkimcontextsimple.h"
#include "nsp/interf.h"

/* NspGtkIMContextSimple inherits from NspGtkIMContext */ 

int nsp_type_gtkimcontextsimple_id=0;
NspTypeGtkIMContextSimple *nsp_type_gtkimcontextsimple=NULL;

NspTypeGtkIMContextSimple *new_type_gtkimcontextsimple(type_mode mode)
{
  NspTypeGtkIMContextSimple *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkimcontextsimple != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkimcontextsimple;
    }
  if ((type =  malloc(sizeof(NspTypeGtkIMContext))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkimcontext(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkimcontextsimple_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkimcontextsimple_get_methods; 
  type->new = (new_func *) new_gtkimcontextsimple;

  /* specific methods for gtkimcontextsimple */
      
  type->init = (init_func *) init_gtkimcontextsimple;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkimcontextsimple */ 

  top->s_type =  (s_type_func *) gtkimcontextsimple_type_as_string;    
  top->sh_type = (sh_type_func *) gtkimcontextsimple_type_short_string;
  /* top->create = (create_func*) int_gtkimcontextsimple_create;*/ 
  
  /* specific methods for gtkimcontextsimple */
      
  type->init = (init_func *) init_gtkimcontextsimple;

  if ( nsp_type_gtkimcontextsimple_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIMContextSimple called nsp_type_gtkimcontextsimple
       */
      type->id =  nsp_type_gtkimcontextsimple_id = nsp_new_type_id();
      nsp_type_gtkimcontextsimple = type;
      if ( nsp_register_type(nsp_type_gtkimcontextsimple) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkimcontextsimple, GTK_TYPE_IM_CONTEXT_SIMPLE);
      return ( mode == T_BASE ) ? type : new_type_gtkimcontextsimple(mode);
    }
  else 
    {
       type->id = nsp_type_gtkimcontextsimple_id;
       return type;
    }
}

/*
 * initialize GtkIMContextSimple instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkimcontextsimple(NspGtkIMContextSimple *o,NspTypeGtkIMContextSimple *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkIMContextSimple 
 */

NspGtkIMContextSimple *new_gtkimcontextsimple() 
{
  NspGtkIMContextSimple *loc; 
  /* type must exists */
  nsp_type_gtkimcontextsimple = new_type_gtkimcontextsimple(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIMContextSimple)))== NULLGTKIMCONTEXTSIMPLE) return loc;
  /* initialize object */
  if ( init_gtkimcontextsimple(loc,nsp_type_gtkimcontextsimple) == FAIL) return NULLGTKIMCONTEXTSIMPLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkIMContextSimple 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkimcontextsimple_type_name[]="GtkIMContextSimple";
static char gtkimcontextsimple_short_type_name[]="GtkIMContextSimple";

static char *gtkimcontextsimple_type_as_string(void)
{
  return(gtkimcontextsimple_type_name);
}

static char *gtkimcontextsimple_type_short_string(void)
{
  return(gtkimcontextsimple_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkIMContextSimple objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkIMContextSimple   *gtkimcontextsimple_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkimcontextsimple_id) ) return ((NspGtkIMContextSimple *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkimcontextsimple));
  return NULL;
}

int IsGtkIMContextSimpleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkimcontextsimple_id);
}

int IsGtkIMContextSimple(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkimcontextsimple_id);
}

NspGtkIMContextSimple  *GetGtkIMContextSimpleCopy(Stack stack, int i)
{
  if (  GetGtkIMContextSimple(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIMContextSimple  *GetGtkIMContextSimple(Stack stack, int i)
{
  NspGtkIMContextSimple *M;
  if (( M = gtkimcontextsimple_object(NthObj(i))) == NULLGTKIMCONTEXTSIMPLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkIMContextSimple *gtkimcontextsimple_copy(NspGtkIMContextSimple *self)
{
  /* return gtkimcontext_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimcontextsimple);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimcontextsimple);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIMContextSimple
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkIMContextSimple *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkimcontextsimple is initialized * /
  nsp_type_gtkimcontextsimple = new_type_gtkimcontextsimple(T_BASE);
  if(( H = gtkimcontext_create(NVOID,(NspTypeBase *) nsp_type_gtkimcontextsimple)) == NULLGTKIMCONTEXTSIMPLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkimcontextsimple_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_im_context_simple_new())== NULL) return RET_BUG;

  nsp_type_gtkimcontextsimple = new_type_gtkimcontextsimple(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkimcontextsimple );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkimcontextsimple_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkimcontextsimple_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkIMMulticontext ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkIMMulticontext_Private 
#include "nsp/gtk/gtkimmulticontext.h"
#include "nsp/interf.h"

/* NspGtkIMMulticontext inherits from NspGtkIMContext */ 

int nsp_type_gtkimmulticontext_id=0;
NspTypeGtkIMMulticontext *nsp_type_gtkimmulticontext=NULL;

NspTypeGtkIMMulticontext *new_type_gtkimmulticontext(type_mode mode)
{
  NspTypeGtkIMMulticontext *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkimmulticontext != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkimmulticontext;
    }
  if ((type =  malloc(sizeof(NspTypeGtkIMContext))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkimcontext(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkimmulticontext_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkimmulticontext_get_methods; 
  type->new = (new_func *) new_gtkimmulticontext;

  /* specific methods for gtkimmulticontext */
      
  type->init = (init_func *) init_gtkimmulticontext;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkimmulticontext */ 

  top->s_type =  (s_type_func *) gtkimmulticontext_type_as_string;    
  top->sh_type = (sh_type_func *) gtkimmulticontext_type_short_string;
  /* top->create = (create_func*) int_gtkimmulticontext_create;*/ 
  
  /* specific methods for gtkimmulticontext */
      
  type->init = (init_func *) init_gtkimmulticontext;

  if ( nsp_type_gtkimmulticontext_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIMMulticontext called nsp_type_gtkimmulticontext
       */
      type->id =  nsp_type_gtkimmulticontext_id = nsp_new_type_id();
      nsp_type_gtkimmulticontext = type;
      if ( nsp_register_type(nsp_type_gtkimmulticontext) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkimmulticontext, GTK_TYPE_IM_MULTICONTEXT);
      return ( mode == T_BASE ) ? type : new_type_gtkimmulticontext(mode);
    }
  else 
    {
       type->id = nsp_type_gtkimmulticontext_id;
       return type;
    }
}

/*
 * initialize GtkIMMulticontext instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkimmulticontext(NspGtkIMMulticontext *o,NspTypeGtkIMMulticontext *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkIMMulticontext 
 */

NspGtkIMMulticontext *new_gtkimmulticontext() 
{
  NspGtkIMMulticontext *loc; 
  /* type must exists */
  nsp_type_gtkimmulticontext = new_type_gtkimmulticontext(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIMMulticontext)))== NULLGTKIMMULTICONTEXT) return loc;
  /* initialize object */
  if ( init_gtkimmulticontext(loc,nsp_type_gtkimmulticontext) == FAIL) return NULLGTKIMMULTICONTEXT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkIMMulticontext 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkimmulticontext_type_name[]="GtkIMMulticontext";
static char gtkimmulticontext_short_type_name[]="GtkIMMulticontext";

static char *gtkimmulticontext_type_as_string(void)
{
  return(gtkimmulticontext_type_name);
}

static char *gtkimmulticontext_type_short_string(void)
{
  return(gtkimmulticontext_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkIMMulticontext objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkIMMulticontext   *gtkimmulticontext_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkimmulticontext_id) ) return ((NspGtkIMMulticontext *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkimmulticontext));
  return NULL;
}

int IsGtkIMMulticontextObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkimmulticontext_id);
}

int IsGtkIMMulticontext(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkimmulticontext_id);
}

NspGtkIMMulticontext  *GetGtkIMMulticontextCopy(Stack stack, int i)
{
  if (  GetGtkIMMulticontext(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIMMulticontext  *GetGtkIMMulticontext(Stack stack, int i)
{
  NspGtkIMMulticontext *M;
  if (( M = gtkimmulticontext_object(NthObj(i))) == NULLGTKIMMULTICONTEXT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkIMMulticontext *gtkimmulticontext_copy(NspGtkIMMulticontext *self)
{
  /* return gtkimcontext_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimmulticontext);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimmulticontext);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIMMulticontext
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkIMMulticontext *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkimmulticontext is initialized * /
  nsp_type_gtkimmulticontext = new_type_gtkimmulticontext(T_BASE);
  if(( H = gtkimcontext_create(NVOID,(NspTypeBase *) nsp_type_gtkimmulticontext)) == NULLGTKIMMULTICONTEXT) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkimmulticontext_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_im_multicontext_new())== NULL) return RET_BUG;

  nsp_type_gtkimmulticontext = new_type_gtkimmulticontext(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkimmulticontext );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_im_multicontext_append_menuitems(NspGtkIMMulticontext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *menushell;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkmenushell, &menushell) == FAIL) return RET_BUG;
  gtk_im_multicontext_append_menuitems(GTK_IM_MULTICONTEXT(self->obj), GTK_MENU_SHELL(menushell->obj));
  return 0;
}

static NspMethods gtkimmulticontext_methods[] = {
  {"append_menuitems",(nsp_method *) _wrap_gtk_im_multicontext_append_menuitems},
  { NULL, NULL}
};

static NspMethods *gtkimmulticontext_get_methods(void) { return gtkimmulticontext_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkimmulticontext_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkCellRenderer ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkCellRenderer_Private 
#include "nsp/gtk/gtkcellrenderer.h"
#include "nsp/interf.h"

/* NspGtkCellRenderer inherits from NspGtkObject */ 

int nsp_type_gtkcellrenderer_id=0;
NspTypeGtkCellRenderer *nsp_type_gtkcellrenderer=NULL;

NspTypeGtkCellRenderer *new_type_gtkcellrenderer(type_mode mode)
{
  NspTypeGtkCellRenderer *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrenderer != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrenderer;
    }
  if ((type =  malloc(sizeof(NspTypeGtkObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrenderer_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcellrenderer_get_methods; 
  type->new = (new_func *) new_gtkcellrenderer;

  /* specific methods for gtkcellrenderer */
      
  type->init = (init_func *) init_gtkcellrenderer;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcellrenderer */ 

  top->s_type =  (s_type_func *) gtkcellrenderer_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcellrenderer_type_short_string;
  /* top->create = (create_func*) int_gtkcellrenderer_create;*/ 
  
  /* specific methods for gtkcellrenderer */
      
  type->init = (init_func *) init_gtkcellrenderer;

  if ( nsp_type_gtkcellrenderer_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRenderer called nsp_type_gtkcellrenderer
       */
      type->id =  nsp_type_gtkcellrenderer_id = nsp_new_type_id();
      nsp_type_gtkcellrenderer = type;
      if ( nsp_register_type(nsp_type_gtkcellrenderer) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrenderer, GTK_TYPE_CELL_RENDERER);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrenderer(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcellrenderer_id;
       return type;
    }
}

/*
 * initialize GtkCellRenderer instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrenderer(NspGtkCellRenderer *o,NspTypeGtkCellRenderer *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkCellRenderer 
 */

NspGtkCellRenderer *new_gtkcellrenderer() 
{
  NspGtkCellRenderer *loc; 
  /* type must exists */
  nsp_type_gtkcellrenderer = new_type_gtkcellrenderer(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRenderer)))== NULLGTKCELLRENDERER) return loc;
  /* initialize object */
  if ( init_gtkcellrenderer(loc,nsp_type_gtkcellrenderer) == FAIL) return NULLGTKCELLRENDERER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkCellRenderer 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcellrenderer_type_name[]="GtkCellRenderer";
static char gtkcellrenderer_short_type_name[]="GtkCellRenderer";

static char *gtkcellrenderer_type_as_string(void)
{
  return(gtkcellrenderer_type_name);
}

static char *gtkcellrenderer_type_short_string(void)
{
  return(gtkcellrenderer_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkCellRenderer objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkCellRenderer   *gtkcellrenderer_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcellrenderer_id) ) return ((NspGtkCellRenderer *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrenderer));
  return NULL;
}

int IsGtkCellRendererObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcellrenderer_id);
}

int IsGtkCellRenderer(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrenderer_id);
}

NspGtkCellRenderer  *GetGtkCellRendererCopy(Stack stack, int i)
{
  if (  GetGtkCellRenderer(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRenderer  *GetGtkCellRenderer(Stack stack, int i)
{
  NspGtkCellRenderer *M;
  if (( M = gtkcellrenderer_object(NthObj(i))) == NULLGTKCELLRENDERER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRenderer *gtkcellrenderer_copy(NspGtkCellRenderer *self)
{
  /* return gtkobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderer);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderer);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRenderer
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkCellRenderer *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcellrenderer is initialized * /
  nsp_type_gtkcellrenderer = new_type_gtkcellrenderer(T_BASE);
  if(( H = gtkobject_create(NVOID,(NspTypeBase *) nsp_type_gtkcellrenderer)) == NULLGTKCELLRENDERER) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 6042 "gtk.override"
static int
_wrap_gtk_cell_renderer_get_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "widget", "cell_area", NULL };*/
  gint x_offset = 0, y_offset = 0, width = 0, height = 0;
  GdkRectangle cell_area;
  NspGObject *nsp_widget;
  NspObject *nsp_cell_area = NULL;
  
  CheckRhs(1,2); 
  if ((nsp_widget = (NspGObject *)nsp_get_object(stack,1))== NULL) return RET_BUG; 
  if ( rhs == 2 ) 
    {
      if ((nsp_cell_area =nsp_get_object(stack,2))== NULL) return RET_BUG; 
    }

  if (!nspgobject_check(nsp_widget,(NspTypeBase *) nsp_type_gtkwidget)) {
    Scierror( "widget must be a GtkWidget");
    return RET_BUG;
  }
  if (nsp_cell_area != NULL ) {
    if (!nsp_gdk_rectangle_from_object(nsp_cell_area, &cell_area))
      return RET_BUG;
  }

  gtk_cell_renderer_get_size(GTK_CELL_RENDERER(self->obj),
			     GTK_WIDGET(nspgobject_get(nsp_widget)),
			     ( IsNone(nsp_cell_area )) ? NULL : &cell_area,
			     &x_offset, &y_offset, &width, &height);
  if (  nsp_move_doubles(stack,1,1,4,(double)  x_offset,(double) y_offset, (double) width,(double) height) == FAIL) return RET_BUG; 
  return 1; 
}
#line 9025 "gtk.c"


static int _wrap_gtk_cell_renderer_render(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check, obj, obj, obj, obj,t_end};
  GtkCellRendererState flags;
  NspGObject *window, *widget;
  GdkRectangle background_area = { 0, 0, 0, 0 }, cell_area = { 0, 0, 0, 0 }, expose_area = { 0, 0, 0, 0 };
  NspObject *nsp_background_area, *nsp_cell_area, *nsp_expose_area, *nsp_flags = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_type_gtkwidget, &widget, &nsp_background_area, &nsp_cell_area, &nsp_expose_area, &nsp_flags) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_background_area, &background_area))
      return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_cell_area, &cell_area))
      return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_expose_area, &expose_area))
      return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_CELL_RENDERER_STATE, nsp_flags, &flags)==FAIL)
      return RET_BUG;
  gtk_cell_renderer_render(GTK_CELL_RENDERER(self->obj), GDK_WINDOW(window->obj), GTK_WIDGET(widget->obj), &background_area, &cell_area, &expose_area, flags);
  return 0;
}

static int _wrap_gtk_cell_renderer_activate(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj_check, string, obj, obj, obj,t_end};
  NspObject *nsp_event, *nsp_background_area, *nsp_cell_area, *nsp_flags = NULL;
  int ret;
  NspGObject *widget;
  char *path;
  GtkCellRendererState flags;
  GdkRectangle background_area = { 0, 0, 0, 0 }, cell_area = { 0, 0, 0, 0 };
  GdkEvent *event = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_event, &nsp_type_gtkwidget, &widget, &path, &nsp_background_area, &nsp_cell_area, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "event should be a GdkEvent");
      return RET_BUG;
  }
  if (!nsp_gdk_rectangle_from_object(nsp_background_area, &background_area))
      return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_cell_area, &cell_area))
      return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_CELL_RENDERER_STATE, nsp_flags, &flags)==FAIL)
      return RET_BUG;
  ret = gtk_cell_renderer_activate(GTK_CELL_RENDERER(self->obj), event, GTK_WIDGET(widget->obj), path, &background_area, &cell_area, flags);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_renderer_start_editing(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj_check, string, obj, obj, obj,t_end};
  NspObject *nsp_event, *nsp_background_area, *nsp_cell_area, *nsp_flags = NULL, *nsp_ret;
  NspGObject *widget;
  char *path;
  GtkCellRendererState flags;
  GdkRectangle background_area = { 0, 0, 0, 0 }, cell_area = { 0, 0, 0, 0 };
  GtkCellEditable *ret;
  GdkEvent *event = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_event, &nsp_type_gtkwidget, &widget, &path, &nsp_background_area, &nsp_cell_area, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "event should be a GdkEvent");
      return RET_BUG;
  }
  if (!nsp_gdk_rectangle_from_object(nsp_background_area, &background_area))
      return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_cell_area, &cell_area))
      return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_CELL_RENDERER_STATE, nsp_flags, &flags)==FAIL)
      return RET_BUG;
  ret = gtk_cell_renderer_start_editing(GTK_CELL_RENDERER(self->obj), event, GTK_WIDGET(widget->obj), path, &background_area, &cell_area, flags);
  nsp_type_gtkcelleditable = new_type_gtkcelleditable(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcelleditable))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_renderer_set_fixed_size(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int width, height;

  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
  gtk_cell_renderer_set_fixed_size(GTK_CELL_RENDERER(self->obj), width, height);
  return 0;
}

#line 6076 "gtk.override"
static int
_wrap_gtk_cell_renderer_get_fixed_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint width, height;

  gtk_cell_renderer_get_fixed_size(GTK_CELL_RENDERER(self->obj),
				   &width, &height);

  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL) 
    return RET_BUG; 
  return 1; 
}
#line 9132 "gtk.c"


static NspMethods gtkcellrenderer_methods[] = {
  {"get_size",(nsp_method *) _wrap_gtk_cell_renderer_get_size},
  {"render",(nsp_method *) _wrap_gtk_cell_renderer_render},
  {"activate",(nsp_method *) _wrap_gtk_cell_renderer_activate},
  {"start_editing",(nsp_method *) _wrap_gtk_cell_renderer_start_editing},
  {"set_fixed_size",(nsp_method *) _wrap_gtk_cell_renderer_set_fixed_size},
  {"get_fixed_size",(nsp_method *) _wrap_gtk_cell_renderer_get_fixed_size},
  { NULL, NULL}
};

static NspMethods *gtkcellrenderer_get_methods(void) { return gtkcellrenderer_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrenderer_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkCellRendererToggle ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkCellRendererToggle_Private 
#include "nsp/gtk/gtkcellrenderertoggle.h"
#include "nsp/interf.h"

/* NspGtkCellRendererToggle inherits from NspGtkCellRenderer */ 

int nsp_type_gtkcellrenderertoggle_id=0;
NspTypeGtkCellRendererToggle *nsp_type_gtkcellrenderertoggle=NULL;

NspTypeGtkCellRendererToggle *new_type_gtkcellrenderertoggle(type_mode mode)
{
  NspTypeGtkCellRendererToggle *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrenderertoggle != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrenderertoggle;
    }
  if ((type =  malloc(sizeof(NspTypeGtkCellRenderer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellrenderer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrenderertoggle_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcellrenderertoggle_get_methods; 
  type->new = (new_func *) new_gtkcellrenderertoggle;

  /* specific methods for gtkcellrenderertoggle */
      
  type->init = (init_func *) init_gtkcellrenderertoggle;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcellrenderertoggle */ 

  top->s_type =  (s_type_func *) gtkcellrenderertoggle_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcellrenderertoggle_type_short_string;
  /* top->create = (create_func*) int_gtkcellrenderertoggle_create;*/ 
  
  /* specific methods for gtkcellrenderertoggle */
      
  type->init = (init_func *) init_gtkcellrenderertoggle;

  if ( nsp_type_gtkcellrenderertoggle_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRendererToggle called nsp_type_gtkcellrenderertoggle
       */
      type->id =  nsp_type_gtkcellrenderertoggle_id = nsp_new_type_id();
      nsp_type_gtkcellrenderertoggle = type;
      if ( nsp_register_type(nsp_type_gtkcellrenderertoggle) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrenderertoggle, GTK_TYPE_CELL_RENDERER_TOGGLE);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrenderertoggle(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcellrenderertoggle_id;
       return type;
    }
}

/*
 * initialize GtkCellRendererToggle instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrenderertoggle(NspGtkCellRendererToggle *o,NspTypeGtkCellRendererToggle *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkCellRendererToggle 
 */

NspGtkCellRendererToggle *new_gtkcellrenderertoggle() 
{
  NspGtkCellRendererToggle *loc; 
  /* type must exists */
  nsp_type_gtkcellrenderertoggle = new_type_gtkcellrenderertoggle(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRendererToggle)))== NULLGTKCELLRENDERERTOGGLE) return loc;
  /* initialize object */
  if ( init_gtkcellrenderertoggle(loc,nsp_type_gtkcellrenderertoggle) == FAIL) return NULLGTKCELLRENDERERTOGGLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkCellRendererToggle 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcellrenderertoggle_type_name[]="GtkCellRendererToggle";
static char gtkcellrenderertoggle_short_type_name[]="GtkCellRendererToggle";

static char *gtkcellrenderertoggle_type_as_string(void)
{
  return(gtkcellrenderertoggle_type_name);
}

static char *gtkcellrenderertoggle_type_short_string(void)
{
  return(gtkcellrenderertoggle_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkCellRendererToggle objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkCellRendererToggle   *gtkcellrenderertoggle_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcellrenderertoggle_id) ) return ((NspGtkCellRendererToggle *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrenderertoggle));
  return NULL;
}

int IsGtkCellRendererToggleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcellrenderertoggle_id);
}

int IsGtkCellRendererToggle(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrenderertoggle_id);
}

NspGtkCellRendererToggle  *GetGtkCellRendererToggleCopy(Stack stack, int i)
{
  if (  GetGtkCellRendererToggle(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRendererToggle  *GetGtkCellRendererToggle(Stack stack, int i)
{
  NspGtkCellRendererToggle *M;
  if (( M = gtkcellrenderertoggle_object(NthObj(i))) == NULLGTKCELLRENDERERTOGGLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRendererToggle *gtkcellrenderertoggle_copy(NspGtkCellRendererToggle *self)
{
  /* return gtkcellrenderer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderertoggle);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderertoggle);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRendererToggle
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkCellRendererToggle *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcellrenderertoggle is initialized * /
  nsp_type_gtkcellrenderertoggle = new_type_gtkcellrenderertoggle(T_BASE);
  if(( H = gtkcellrenderer_create(NVOID,(NspTypeBase *) nsp_type_gtkcellrenderertoggle)) == NULLGTKCELLRENDERERTOGGLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkcellrenderertoggle_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_renderer_toggle_new())== NULL) return RET_BUG;

  nsp_type_gtkcellrenderertoggle = new_type_gtkcellrenderertoggle(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcellrenderertoggle );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_renderer_toggle_get_radio(NspGtkCellRendererToggle *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_cell_renderer_toggle_get_radio(GTK_CELL_RENDERER_TOGGLE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_renderer_toggle_set_radio(NspGtkCellRendererToggle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int radio;

  if ( GetArgs(stack,rhs,opt,T,&radio) == FAIL) return RET_BUG;
  gtk_cell_renderer_toggle_set_radio(GTK_CELL_RENDERER_TOGGLE(self->obj), radio);
  return 0;
}

static int _wrap_gtk_cell_renderer_toggle_get_active(NspGtkCellRendererToggle *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_cell_renderer_toggle_get_active(GTK_CELL_RENDERER_TOGGLE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_renderer_toggle_set_active(NspGtkCellRendererToggle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_cell_renderer_toggle_set_active(GTK_CELL_RENDERER_TOGGLE(self->obj), setting);
  return 0;
}

static NspMethods gtkcellrenderertoggle_methods[] = {
  {"get_radio",(nsp_method *) _wrap_gtk_cell_renderer_toggle_get_radio},
  {"set_radio",(nsp_method *) _wrap_gtk_cell_renderer_toggle_set_radio},
  {"get_active",(nsp_method *) _wrap_gtk_cell_renderer_toggle_get_active},
  {"set_active",(nsp_method *) _wrap_gtk_cell_renderer_toggle_set_active},
  { NULL, NULL}
};

static NspMethods *gtkcellrenderertoggle_get_methods(void) { return gtkcellrenderertoggle_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrenderertoggle_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkCellRendererText ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkCellRendererText_Private 
#include "nsp/gtk/gtkcellrenderertext.h"
#include "nsp/interf.h"

/* NspGtkCellRendererText inherits from NspGtkCellRenderer */ 

int nsp_type_gtkcellrenderertext_id=0;
NspTypeGtkCellRendererText *nsp_type_gtkcellrenderertext=NULL;

NspTypeGtkCellRendererText *new_type_gtkcellrenderertext(type_mode mode)
{
  NspTypeGtkCellRendererText *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrenderertext != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrenderertext;
    }
  if ((type =  malloc(sizeof(NspTypeGtkCellRenderer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellrenderer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrenderertext_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcellrenderertext_get_methods; 
  type->new = (new_func *) new_gtkcellrenderertext;

  /* specific methods for gtkcellrenderertext */
      
  type->init = (init_func *) init_gtkcellrenderertext;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcellrenderertext */ 

  top->s_type =  (s_type_func *) gtkcellrenderertext_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcellrenderertext_type_short_string;
  /* top->create = (create_func*) int_gtkcellrenderertext_create;*/ 
  
  /* specific methods for gtkcellrenderertext */
      
  type->init = (init_func *) init_gtkcellrenderertext;

  if ( nsp_type_gtkcellrenderertext_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRendererText called nsp_type_gtkcellrenderertext
       */
      type->id =  nsp_type_gtkcellrenderertext_id = nsp_new_type_id();
      nsp_type_gtkcellrenderertext = type;
      if ( nsp_register_type(nsp_type_gtkcellrenderertext) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrenderertext, GTK_TYPE_CELL_RENDERER_TEXT);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrenderertext(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcellrenderertext_id;
       return type;
    }
}

/*
 * initialize GtkCellRendererText instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrenderertext(NspGtkCellRendererText *o,NspTypeGtkCellRendererText *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkCellRendererText 
 */

NspGtkCellRendererText *new_gtkcellrenderertext() 
{
  NspGtkCellRendererText *loc; 
  /* type must exists */
  nsp_type_gtkcellrenderertext = new_type_gtkcellrenderertext(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRendererText)))== NULLGTKCELLRENDERERTEXT) return loc;
  /* initialize object */
  if ( init_gtkcellrenderertext(loc,nsp_type_gtkcellrenderertext) == FAIL) return NULLGTKCELLRENDERERTEXT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkCellRendererText 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcellrenderertext_type_name[]="GtkCellRendererText";
static char gtkcellrenderertext_short_type_name[]="GtkCellRendererText";

static char *gtkcellrenderertext_type_as_string(void)
{
  return(gtkcellrenderertext_type_name);
}

static char *gtkcellrenderertext_type_short_string(void)
{
  return(gtkcellrenderertext_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkCellRendererText objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkCellRendererText   *gtkcellrenderertext_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcellrenderertext_id) ) return ((NspGtkCellRendererText *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrenderertext));
  return NULL;
}

int IsGtkCellRendererTextObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcellrenderertext_id);
}

int IsGtkCellRendererText(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrenderertext_id);
}

NspGtkCellRendererText  *GetGtkCellRendererTextCopy(Stack stack, int i)
{
  if (  GetGtkCellRendererText(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRendererText  *GetGtkCellRendererText(Stack stack, int i)
{
  NspGtkCellRendererText *M;
  if (( M = gtkcellrenderertext_object(NthObj(i))) == NULLGTKCELLRENDERERTEXT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRendererText *gtkcellrenderertext_copy(NspGtkCellRendererText *self)
{
  /* return gtkcellrenderer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderertext);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderertext);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRendererText
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkCellRendererText *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcellrenderertext is initialized * /
  nsp_type_gtkcellrenderertext = new_type_gtkcellrenderertext(T_BASE);
  if(( H = gtkcellrenderer_create(NVOID,(NspTypeBase *) nsp_type_gtkcellrenderertext)) == NULLGTKCELLRENDERERTEXT) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkcellrenderertext_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_renderer_text_new())== NULL) return RET_BUG;

  nsp_type_gtkcellrenderertext = new_type_gtkcellrenderertext(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcellrenderertext );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_renderer_text_set_fixed_height_from_font(NspGtkCellRendererText *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int number_of_rows;

  if ( GetArgs(stack,rhs,opt,T,&number_of_rows) == FAIL) return RET_BUG;
  gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(self->obj), number_of_rows);
  return 0;
}

static NspMethods gtkcellrenderertext_methods[] = {
  {"set_fixed_height_from_font",(nsp_method *) _wrap_gtk_cell_renderer_text_set_fixed_height_from_font},
  { NULL, NULL}
};

static NspMethods *gtkcellrenderertext_get_methods(void) { return gtkcellrenderertext_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrenderertext_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkCellRendererPixbuf ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkCellRendererPixbuf_Private 
#include "nsp/gtk/gtkcellrendererpixbuf.h"
#include "nsp/interf.h"

/* NspGtkCellRendererPixbuf inherits from NspGtkCellRenderer */ 

int nsp_type_gtkcellrendererpixbuf_id=0;
NspTypeGtkCellRendererPixbuf *nsp_type_gtkcellrendererpixbuf=NULL;

NspTypeGtkCellRendererPixbuf *new_type_gtkcellrendererpixbuf(type_mode mode)
{
  NspTypeGtkCellRendererPixbuf *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrendererpixbuf != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrendererpixbuf;
    }
  if ((type =  malloc(sizeof(NspTypeGtkCellRenderer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellrenderer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrendererpixbuf_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcellrendererpixbuf_get_methods; 
  type->new = (new_func *) new_gtkcellrendererpixbuf;

  /* specific methods for gtkcellrendererpixbuf */
      
  type->init = (init_func *) init_gtkcellrendererpixbuf;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcellrendererpixbuf */ 

  top->s_type =  (s_type_func *) gtkcellrendererpixbuf_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcellrendererpixbuf_type_short_string;
  /* top->create = (create_func*) int_gtkcellrendererpixbuf_create;*/ 
  
  /* specific methods for gtkcellrendererpixbuf */
      
  type->init = (init_func *) init_gtkcellrendererpixbuf;

  if ( nsp_type_gtkcellrendererpixbuf_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRendererPixbuf called nsp_type_gtkcellrendererpixbuf
       */
      type->id =  nsp_type_gtkcellrendererpixbuf_id = nsp_new_type_id();
      nsp_type_gtkcellrendererpixbuf = type;
      if ( nsp_register_type(nsp_type_gtkcellrendererpixbuf) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrendererpixbuf, GTK_TYPE_CELL_RENDERER_PIXBUF);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrendererpixbuf(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcellrendererpixbuf_id;
       return type;
    }
}

/*
 * initialize GtkCellRendererPixbuf instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrendererpixbuf(NspGtkCellRendererPixbuf *o,NspTypeGtkCellRendererPixbuf *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkCellRendererPixbuf 
 */

NspGtkCellRendererPixbuf *new_gtkcellrendererpixbuf() 
{
  NspGtkCellRendererPixbuf *loc; 
  /* type must exists */
  nsp_type_gtkcellrendererpixbuf = new_type_gtkcellrendererpixbuf(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRendererPixbuf)))== NULLGTKCELLRENDERERPIXBUF) return loc;
  /* initialize object */
  if ( init_gtkcellrendererpixbuf(loc,nsp_type_gtkcellrendererpixbuf) == FAIL) return NULLGTKCELLRENDERERPIXBUF;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkCellRendererPixbuf 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcellrendererpixbuf_type_name[]="GtkCellRendererPixbuf";
static char gtkcellrendererpixbuf_short_type_name[]="GtkCellRendererPixbuf";

static char *gtkcellrendererpixbuf_type_as_string(void)
{
  return(gtkcellrendererpixbuf_type_name);
}

static char *gtkcellrendererpixbuf_type_short_string(void)
{
  return(gtkcellrendererpixbuf_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkCellRendererPixbuf objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkCellRendererPixbuf   *gtkcellrendererpixbuf_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcellrendererpixbuf_id) ) return ((NspGtkCellRendererPixbuf *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrendererpixbuf));
  return NULL;
}

int IsGtkCellRendererPixbufObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcellrendererpixbuf_id);
}

int IsGtkCellRendererPixbuf(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrendererpixbuf_id);
}

NspGtkCellRendererPixbuf  *GetGtkCellRendererPixbufCopy(Stack stack, int i)
{
  if (  GetGtkCellRendererPixbuf(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRendererPixbuf  *GetGtkCellRendererPixbuf(Stack stack, int i)
{
  NspGtkCellRendererPixbuf *M;
  if (( M = gtkcellrendererpixbuf_object(NthObj(i))) == NULLGTKCELLRENDERERPIXBUF)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRendererPixbuf *gtkcellrendererpixbuf_copy(NspGtkCellRendererPixbuf *self)
{
  /* return gtkcellrenderer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendererpixbuf);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendererpixbuf);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRendererPixbuf
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkCellRendererPixbuf *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcellrendererpixbuf is initialized * /
  nsp_type_gtkcellrendererpixbuf = new_type_gtkcellrendererpixbuf(T_BASE);
  if(( H = gtkcellrenderer_create(NVOID,(NspTypeBase *) nsp_type_gtkcellrendererpixbuf)) == NULLGTKCELLRENDERERPIXBUF) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkcellrendererpixbuf_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_renderer_pixbuf_new())== NULL) return RET_BUG;

  nsp_type_gtkcellrendererpixbuf = new_type_gtkcellrendererpixbuf(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcellrendererpixbuf );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkcellrendererpixbuf_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrendererpixbuf_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkAdjustment ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkAdjustment_Private 
#include "nsp/gtk/gtkadjustment.h"
#include "nsp/interf.h"

/* NspGtkAdjustment inherits from NspGtkObject */ 

int nsp_type_gtkadjustment_id=0;
NspTypeGtkAdjustment *nsp_type_gtkadjustment=NULL;

NspTypeGtkAdjustment *new_type_gtkadjustment(type_mode mode)
{
  NspTypeGtkAdjustment *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkadjustment != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkadjustment;
    }
  if ((type =  malloc(sizeof(NspTypeGtkObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkadjustment_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkadjustment_get_methods; 
  type->new = (new_func *) new_gtkadjustment;

  /* specific methods for gtkadjustment */
      
  type->init = (init_func *) init_gtkadjustment;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkadjustment */ 

  top->s_type =  (s_type_func *) gtkadjustment_type_as_string;    
  top->sh_type = (sh_type_func *) gtkadjustment_type_short_string;
  /* top->create = (create_func*) int_gtkadjustment_create;*/ 
  
  /* specific methods for gtkadjustment */
      
  type->init = (init_func *) init_gtkadjustment;

  if ( nsp_type_gtkadjustment_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAdjustment called nsp_type_gtkadjustment
       */
      type->id =  nsp_type_gtkadjustment_id = nsp_new_type_id();
      nsp_type_gtkadjustment = type;
      if ( nsp_register_type(nsp_type_gtkadjustment) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkadjustment, GTK_TYPE_ADJUSTMENT);
      return ( mode == T_BASE ) ? type : new_type_gtkadjustment(mode);
    }
  else 
    {
       type->id = nsp_type_gtkadjustment_id;
       return type;
    }
}

/*
 * initialize GtkAdjustment instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkadjustment(NspGtkAdjustment *o,NspTypeGtkAdjustment *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkAdjustment 
 */

NspGtkAdjustment *new_gtkadjustment() 
{
  NspGtkAdjustment *loc; 
  /* type must exists */
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAdjustment)))== NULLGTKADJUSTMENT) return loc;
  /* initialize object */
  if ( init_gtkadjustment(loc,nsp_type_gtkadjustment) == FAIL) return NULLGTKADJUSTMENT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkAdjustment 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkadjustment_type_name[]="GtkAdjustment";
static char gtkadjustment_short_type_name[]="GtkAdjustment";

static char *gtkadjustment_type_as_string(void)
{
  return(gtkadjustment_type_name);
}

static char *gtkadjustment_type_short_string(void)
{
  return(gtkadjustment_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkAdjustment objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkAdjustment   *gtkadjustment_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkadjustment_id) ) return ((NspGtkAdjustment *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkadjustment));
  return NULL;
}

int IsGtkAdjustmentObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkadjustment_id);
}

int IsGtkAdjustment(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkadjustment_id);
}

NspGtkAdjustment  *GetGtkAdjustmentCopy(Stack stack, int i)
{
  if (  GetGtkAdjustment(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAdjustment  *GetGtkAdjustment(Stack stack, int i)
{
  NspGtkAdjustment *M;
  if (( M = gtkadjustment_object(NthObj(i))) == NULLGTKADJUSTMENT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAdjustment *gtkadjustment_copy(NspGtkAdjustment *self)
{
  /* return gtkobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkadjustment);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkadjustment);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAdjustment
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkAdjustment *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkadjustment is initialized * /
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if(( H = gtkobject_create(NVOID,(NspTypeBase *) nsp_type_gtkadjustment)) == NULLGTKADJUSTMENT) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkadjustment_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"value",s_double,NULLOBJ,-1}, 
	{"lower",s_double,NULLOBJ,-1}, 
	{"upper",s_double,NULLOBJ,-1}, 
	{"step_incr",s_double,NULLOBJ,-1}, 
	{"page_incr",s_double,NULLOBJ,-1}, 
	{"page_size",s_double,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  double value = 0, lower = 0, upper = 0, step_incr = 0, page_incr = 0, page_size = 0;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &value, &lower, &upper, &step_incr, &page_incr, &page_size) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_adjustment_new(value, lower, upper, step_incr, page_incr, page_size))== NULL) return RET_BUG;

  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkadjustment );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 6407 "gtk.override"
static int
_wrap_gtk_adjustment_set_all(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  Scierror("deprecated: use individual setters");
  return RET_BUG;
}
#line 10084 "gtk.c"


static int _wrap_gtk_adjustment_changed(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_adjustment_changed(GTK_ADJUSTMENT(self->obj));
  return 0;
}

static int _wrap_gtk_adjustment_value_changed(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_adjustment_value_changed(GTK_ADJUSTMENT(self->obj));
  return 0;
}

static int _wrap_gtk_adjustment_clamp_page(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, s_double,t_end};
  double lower, upper;

  if ( GetArgs(stack,rhs,opt,T,&lower, &upper) == FAIL) return RET_BUG;
  gtk_adjustment_clamp_page(GTK_ADJUSTMENT(self->obj), lower, upper);
  return 0;
}

static int _wrap_gtk_adjustment_get_value(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;

  ret = gtk_adjustment_get_value(GTK_ADJUSTMENT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_adjustment_set_value(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,t_end};
  double value;

  if ( GetArgs(stack,rhs,opt,T,&value) == FAIL) return RET_BUG;
  gtk_adjustment_set_value(GTK_ADJUSTMENT(self->obj), value);
  return 0;
}

static NspMethods gtkadjustment_methods[] = {
  {"set_all",(nsp_method *) _wrap_gtk_adjustment_set_all},
  {"changed",(nsp_method *) _wrap_gtk_adjustment_changed},
  {"value_changed",(nsp_method *) _wrap_gtk_adjustment_value_changed},
  {"clamp_page",(nsp_method *) _wrap_gtk_adjustment_clamp_page},
  {"get_value",(nsp_method *) _wrap_gtk_adjustment_get_value},
  {"set_value",(nsp_method *) _wrap_gtk_adjustment_set_value},
  { NULL, NULL}
};

static NspMethods *gtkadjustment_get_methods(void) { return gtkadjustment_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

#line 6335 "gtk.override"
static int
_wrap_gtk_adjustment__set_value(NspGObject *self, char *attr, NspObject *value)
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->value = val;
  gtk_adjustment_value_changed(adjustment);
  return 0;
}
#line 10154 "gtk.c"
static NspObject *_wrap_gtk_adjustment__get_value(NspObject *self,char *attr)
{
  double ret;
  NspObject *nsp_ret;

  ret = (gfloat) GTK_ADJUSTMENT(NSP_GOBJECT_GET(self))->value;
  nsp_ret=nsp_create_object_from_double(NVOID,(double) ret);
  return nsp_ret;
}

#line 6347 "gtk.override"
static int
_wrap_gtk_adjustment__set_lower(NspGObject *self, char *attr, NspObject *value)
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->lower = val;
  gtk_adjustment_changed(adjustment);
  return 0;
}
#line 10176 "gtk.c"
static NspObject *_wrap_gtk_adjustment__get_lower(NspObject *self,char *attr)
{
  double ret;
  NspObject *nsp_ret;

  ret = (gfloat) GTK_ADJUSTMENT(NSP_GOBJECT_GET(self))->lower;
  nsp_ret=nsp_create_object_from_double(NVOID,(double) ret);
  return nsp_ret;
}

#line 6359 "gtk.override"
static int
_wrap_gtk_adjustment__set_upper(NspGObject *self, char *attr, NspObject *value)
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->upper = val;
  gtk_adjustment_changed(adjustment);
  return 0;
}
#line 10198 "gtk.c"
static NspObject *_wrap_gtk_adjustment__get_upper(NspObject *self,char *attr)
{
  double ret;
  NspObject *nsp_ret;

  ret = (gfloat) GTK_ADJUSTMENT(NSP_GOBJECT_GET(self))->upper;
  nsp_ret=nsp_create_object_from_double(NVOID,(double) ret);
  return nsp_ret;
}

#line 6371 "gtk.override"
static int
_wrap_gtk_adjustment__set_step_increment(NspGObject *self, char *attr, NspObject *value)
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->step_increment = val;
  gtk_adjustment_changed(adjustment);
  return 0;
}
#line 10220 "gtk.c"
static NspObject *_wrap_gtk_adjustment__get_step_increment(NspObject *self,char *attr)
{
  double ret;
  NspObject *nsp_ret;

  ret = (gfloat) GTK_ADJUSTMENT(NSP_GOBJECT_GET(self))->step_increment;
  nsp_ret=nsp_create_object_from_double(NVOID,(double) ret);
  return nsp_ret;
}

#line 6383 "gtk.override"
static int
_wrap_gtk_adjustment__set_page_increment(NspGObject *self, char *attr, NspObject *value)
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->page_increment = val;
  gtk_adjustment_changed(adjustment);
  return 0;
}
#line 10242 "gtk.c"
static NspObject *_wrap_gtk_adjustment__get_page_increment(NspObject *self,char *attr)
{
  double ret;
  NspObject *nsp_ret;

  ret = (gfloat) GTK_ADJUSTMENT(NSP_GOBJECT_GET(self))->page_increment;
  nsp_ret=nsp_create_object_from_double(NVOID,(double) ret);
  return nsp_ret;
}

#line 6395 "gtk.override"
static int
_wrap_gtk_adjustment__set_page_size(NspGObject *self, char *attr, NspObject *value) 
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->page_size = val;
  gtk_adjustment_changed(adjustment);
  return 0;
}
#line 10264 "gtk.c"
static NspObject *_wrap_gtk_adjustment__get_page_size(NspObject *self,char *attr)
{
  double ret;
  NspObject *nsp_ret;

  ret = (gfloat) GTK_ADJUSTMENT(NSP_GOBJECT_GET(self))->page_size;
  nsp_ret=nsp_create_object_from_double(NVOID,(double) ret);
  return nsp_ret;
}

static AttrTab gtkadjustment_attrs[] = {
  { "value", (attr_get_function *)_wrap_gtk_adjustment__get_value, (attr_set_function *)_wrap_gtk_adjustment__set_value,(attr_get_object_function *)int_get_object_failed },
  { "lower", (attr_get_function *)_wrap_gtk_adjustment__get_lower, (attr_set_function *)_wrap_gtk_adjustment__set_lower,(attr_get_object_function *)int_get_object_failed },
  { "upper", (attr_get_function *)_wrap_gtk_adjustment__get_upper, (attr_set_function *)_wrap_gtk_adjustment__set_upper,(attr_get_object_function *)int_get_object_failed },
  { "step_increment", (attr_get_function *)_wrap_gtk_adjustment__get_step_increment, (attr_set_function *)_wrap_gtk_adjustment__set_step_increment,(attr_get_object_function *)int_get_object_failed },
  { "page_increment", (attr_get_function *)_wrap_gtk_adjustment__get_page_increment, (attr_set_function *)_wrap_gtk_adjustment__set_page_increment,(attr_get_object_function *)int_get_object_failed },
  { "page_size", (attr_get_function *)_wrap_gtk_adjustment__get_page_size, (attr_set_function *)_wrap_gtk_adjustment__set_page_size,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkRcStyle ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkRcStyle_Private 
#include "nsp/gtk/gtkrcstyle.h"
#include "nsp/interf.h"

/* NspGtkRcStyle inherits from NspGObject */ 

int nsp_type_gtkrcstyle_id=0;
NspTypeGtkRcStyle *nsp_type_gtkrcstyle=NULL;

NspTypeGtkRcStyle *new_type_gtkrcstyle(type_mode mode)
{
  NspTypeGtkRcStyle *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkrcstyle != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkrcstyle;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkrcstyle_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkrcstyle_get_methods; 
  type->new = (new_func *) new_gtkrcstyle;

  /* specific methods for gtkrcstyle */
      
  type->init = (init_func *) init_gtkrcstyle;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkrcstyle */ 

  top->s_type =  (s_type_func *) gtkrcstyle_type_as_string;    
  top->sh_type = (sh_type_func *) gtkrcstyle_type_short_string;
  /* top->create = (create_func*) int_gtkrcstyle_create;*/ 
  
  /* specific methods for gtkrcstyle */
      
  type->init = (init_func *) init_gtkrcstyle;

  if ( nsp_type_gtkrcstyle_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRcStyle called nsp_type_gtkrcstyle
       */
      type->id =  nsp_type_gtkrcstyle_id = nsp_new_type_id();
      nsp_type_gtkrcstyle = type;
      if ( nsp_register_type(nsp_type_gtkrcstyle) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkrcstyle, GTK_TYPE_RC_STYLE);
      return ( mode == T_BASE ) ? type : new_type_gtkrcstyle(mode);
    }
  else 
    {
       type->id = nsp_type_gtkrcstyle_id;
       return type;
    }
}

/*
 * initialize GtkRcStyle instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkrcstyle(NspGtkRcStyle *o,NspTypeGtkRcStyle *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkRcStyle 
 */

NspGtkRcStyle *new_gtkrcstyle() 
{
  NspGtkRcStyle *loc; 
  /* type must exists */
  nsp_type_gtkrcstyle = new_type_gtkrcstyle(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRcStyle)))== NULLGTKRCSTYLE) return loc;
  /* initialize object */
  if ( init_gtkrcstyle(loc,nsp_type_gtkrcstyle) == FAIL) return NULLGTKRCSTYLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkRcStyle 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkrcstyle_type_name[]="GtkRcStyle";
static char gtkrcstyle_short_type_name[]="GtkRcStyle";

static char *gtkrcstyle_type_as_string(void)
{
  return(gtkrcstyle_type_name);
}

static char *gtkrcstyle_type_short_string(void)
{
  return(gtkrcstyle_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkRcStyle objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkRcStyle   *gtkrcstyle_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkrcstyle_id) ) return ((NspGtkRcStyle *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkrcstyle));
  return NULL;
}

int IsGtkRcStyleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkrcstyle_id);
}

int IsGtkRcStyle(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkrcstyle_id);
}

NspGtkRcStyle  *GetGtkRcStyleCopy(Stack stack, int i)
{
  if (  GetGtkRcStyle(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRcStyle  *GetGtkRcStyle(Stack stack, int i)
{
  NspGtkRcStyle *M;
  if (( M = gtkrcstyle_object(NthObj(i))) == NULLGTKRCSTYLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRcStyle *gtkrcstyle_copy(NspGtkRcStyle *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrcstyle);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrcstyle);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRcStyle
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkRcStyle *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkrcstyle is initialized * /
  nsp_type_gtkrcstyle = new_type_gtkrcstyle(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtkrcstyle)) == NULLGTKRCSTYLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_rc_add_widget_name_style(NspGtkRcStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *pattern;

  if ( GetArgs(stack,rhs,opt,T,&pattern) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_rc_add_widget_name_style(GTK_RC_STYLE(self->obj), pattern);
  return 0;
}

static int _wrap_gtk_rc_add_widget_class_style(NspGtkRcStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *pattern;

  if ( GetArgs(stack,rhs,opt,T,&pattern) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_rc_add_widget_class_style(GTK_RC_STYLE(self->obj), pattern);
  return 0;
}

static int _wrap_gtk_rc_add_class_style(NspGtkRcStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *pattern;

  if ( GetArgs(stack,rhs,opt,T,&pattern) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_rc_add_class_style(GTK_RC_STYLE(self->obj), pattern);
  return 0;
}

static int _wrap_gtk_rc_style_copy(NspGtkRcStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkRcStyle *ret;
  NspObject *nsp_ret;

  ret = gtk_rc_style_copy(GTK_RC_STYLE(self->obj));
  nsp_type_gtkrcstyle = new_type_gtkrcstyle(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkrcstyle))== NULL) return RET_BUG;
  g_object_unref(ret);
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkrcstyle_methods[] = {
  {"rc_add_widget_name_style",(nsp_method *) _wrap_gtk_rc_add_widget_name_style},
  {"rc_add_widget_class_style",(nsp_method *) _wrap_gtk_rc_add_widget_class_style},
  {"rc_add_class_style",(nsp_method *) _wrap_gtk_rc_add_class_style},
  {"copy",(nsp_method *) _wrap_gtk_rc_style_copy},
  { NULL, NULL}
};

static NspMethods *gtkrcstyle_get_methods(void) { return gtkrcstyle_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkrcstyle_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkSettings ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkSettings_Private 
#include "nsp/gtk/gtksettings.h"
#include "nsp/interf.h"

/* NspGtkSettings inherits from NspGObject */ 

int nsp_type_gtksettings_id=0;
NspTypeGtkSettings *nsp_type_gtksettings=NULL;

NspTypeGtkSettings *new_type_gtksettings(type_mode mode)
{
  NspTypeGtkSettings *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtksettings != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtksettings;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtksettings_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtksettings_get_methods; 
  type->new = (new_func *) new_gtksettings;

  /* specific methods for gtksettings */
      
  type->init = (init_func *) init_gtksettings;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtksettings */ 

  top->s_type =  (s_type_func *) gtksettings_type_as_string;    
  top->sh_type = (sh_type_func *) gtksettings_type_short_string;
  /* top->create = (create_func*) int_gtksettings_create;*/ 
  
  /* specific methods for gtksettings */
      
  type->init = (init_func *) init_gtksettings;

  if ( nsp_type_gtksettings_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSettings called nsp_type_gtksettings
       */
      type->id =  nsp_type_gtksettings_id = nsp_new_type_id();
      nsp_type_gtksettings = type;
      if ( nsp_register_type(nsp_type_gtksettings) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtksettings, GTK_TYPE_SETTINGS);
      return ( mode == T_BASE ) ? type : new_type_gtksettings(mode);
    }
  else 
    {
       type->id = nsp_type_gtksettings_id;
       return type;
    }
}

/*
 * initialize GtkSettings instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtksettings(NspGtkSettings *o,NspTypeGtkSettings *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkSettings 
 */

NspGtkSettings *new_gtksettings() 
{
  NspGtkSettings *loc; 
  /* type must exists */
  nsp_type_gtksettings = new_type_gtksettings(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSettings)))== NULLGTKSETTINGS) return loc;
  /* initialize object */
  if ( init_gtksettings(loc,nsp_type_gtksettings) == FAIL) return NULLGTKSETTINGS;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkSettings 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtksettings_type_name[]="GtkSettings";
static char gtksettings_short_type_name[]="GtkSettings";

static char *gtksettings_type_as_string(void)
{
  return(gtksettings_type_name);
}

static char *gtksettings_type_short_string(void)
{
  return(gtksettings_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkSettings objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkSettings   *gtksettings_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtksettings_id) ) return ((NspGtkSettings *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtksettings));
  return NULL;
}

int IsGtkSettingsObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtksettings_id);
}

int IsGtkSettings(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtksettings_id);
}

NspGtkSettings  *GetGtkSettingsCopy(Stack stack, int i)
{
  if (  GetGtkSettings(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSettings  *GetGtkSettings(Stack stack, int i)
{
  NspGtkSettings *M;
  if (( M = gtksettings_object(NthObj(i))) == NULLGTKSETTINGS)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSettings *gtksettings_copy(NspGtkSettings *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksettings);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksettings);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSettings
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkSettings *H;
  CheckRhs(0,0);
  / * want to be sure that type gtksettings is initialized * /
  nsp_type_gtksettings = new_type_gtksettings(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtksettings)) == NULLGTKSETTINGS) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_settings_set_string_property(NspGtkSettings *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, string, string,t_end};
  char *name, *v_string, *origin;

  if ( GetArgs(stack,rhs,opt,T,&name, &v_string, &origin) == FAIL) return RET_BUG;
  gtk_settings_set_string_property(GTK_SETTINGS(self->obj), name, v_string, origin);
  return 0;
}

static int _wrap_gtk_settings_set_long_property(NspGtkSettings *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, s_int, string,t_end};
  char *name, *origin;
  int v_long;

  if ( GetArgs(stack,rhs,opt,T,&name, &v_long, &origin) == FAIL) return RET_BUG;
  gtk_settings_set_long_property(GTK_SETTINGS(self->obj), name, v_long, origin);
  return 0;
}

static int _wrap_gtk_settings_set_double_property(NspGtkSettings *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, s_double, string,t_end};
  char *name, *origin;
  double v_double;

  if ( GetArgs(stack,rhs,opt,T,&name, &v_double, &origin) == FAIL) return RET_BUG;
  gtk_settings_set_double_property(GTK_SETTINGS(self->obj), name, v_double, origin);
  return 0;
}

static NspMethods gtksettings_methods[] = {
  {"set_string_property",(nsp_method *) _wrap_gtk_settings_set_string_property},
  {"set_long_property",(nsp_method *) _wrap_gtk_settings_set_long_property},
  {"set_double_property",(nsp_method *) _wrap_gtk_settings_set_double_property},
  { NULL, NULL}
};

static NspMethods *gtksettings_get_methods(void) { return gtksettings_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtksettings_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkSizeGroup ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkSizeGroup_Private 
#include "nsp/gtk/gtksizegroup.h"
#include "nsp/interf.h"

/* NspGtkSizeGroup inherits from NspGObject */ 

int nsp_type_gtksizegroup_id=0;
NspTypeGtkSizeGroup *nsp_type_gtksizegroup=NULL;

NspTypeGtkSizeGroup *new_type_gtksizegroup(type_mode mode)
{
  NspTypeGtkSizeGroup *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtksizegroup != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtksizegroup;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtksizegroup_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtksizegroup_get_methods; 
  type->new = (new_func *) new_gtksizegroup;

  /* specific methods for gtksizegroup */
      
  type->init = (init_func *) init_gtksizegroup;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtksizegroup */ 

  top->s_type =  (s_type_func *) gtksizegroup_type_as_string;    
  top->sh_type = (sh_type_func *) gtksizegroup_type_short_string;
  /* top->create = (create_func*) int_gtksizegroup_create;*/ 
  
  /* specific methods for gtksizegroup */
      
  type->init = (init_func *) init_gtksizegroup;

  if ( nsp_type_gtksizegroup_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSizeGroup called nsp_type_gtksizegroup
       */
      type->id =  nsp_type_gtksizegroup_id = nsp_new_type_id();
      nsp_type_gtksizegroup = type;
      if ( nsp_register_type(nsp_type_gtksizegroup) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtksizegroup, GTK_TYPE_SIZE_GROUP);
      return ( mode == T_BASE ) ? type : new_type_gtksizegroup(mode);
    }
  else 
    {
       type->id = nsp_type_gtksizegroup_id;
       return type;
    }
}

/*
 * initialize GtkSizeGroup instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtksizegroup(NspGtkSizeGroup *o,NspTypeGtkSizeGroup *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkSizeGroup 
 */

NspGtkSizeGroup *new_gtksizegroup() 
{
  NspGtkSizeGroup *loc; 
  /* type must exists */
  nsp_type_gtksizegroup = new_type_gtksizegroup(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSizeGroup)))== NULLGTKSIZEGROUP) return loc;
  /* initialize object */
  if ( init_gtksizegroup(loc,nsp_type_gtksizegroup) == FAIL) return NULLGTKSIZEGROUP;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkSizeGroup 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtksizegroup_type_name[]="GtkSizeGroup";
static char gtksizegroup_short_type_name[]="GtkSizeGroup";

static char *gtksizegroup_type_as_string(void)
{
  return(gtksizegroup_type_name);
}

static char *gtksizegroup_type_short_string(void)
{
  return(gtksizegroup_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkSizeGroup objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkSizeGroup   *gtksizegroup_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtksizegroup_id) ) return ((NspGtkSizeGroup *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtksizegroup));
  return NULL;
}

int IsGtkSizeGroupObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtksizegroup_id);
}

int IsGtkSizeGroup(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtksizegroup_id);
}

NspGtkSizeGroup  *GetGtkSizeGroupCopy(Stack stack, int i)
{
  if (  GetGtkSizeGroup(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSizeGroup  *GetGtkSizeGroup(Stack stack, int i)
{
  NspGtkSizeGroup *M;
  if (( M = gtksizegroup_object(NthObj(i))) == NULLGTKSIZEGROUP)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSizeGroup *gtksizegroup_copy(NspGtkSizeGroup *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksizegroup);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksizegroup);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSizeGroup
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkSizeGroup *H;
  CheckRhs(0,0);
  / * want to be sure that type gtksizegroup is initialized * /
  nsp_type_gtksizegroup = new_type_gtksizegroup(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtksizegroup)) == NULLGTKSIZEGROUP) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtksizegroup_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,t_end};
  GtkSizeGroupMode mode;
  NspObject *nsp_mode = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SIZE_GROUP_MODE, nsp_mode, &mode)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_size_group_new(mode))== NULL) return RET_BUG;

  nsp_type_gtksizegroup = new_type_gtksizegroup(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtksizegroup );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_size_group_set_mode(NspGtkSizeGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkSizeGroupMode mode;
  NspObject *nsp_mode = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SIZE_GROUP_MODE, nsp_mode, &mode)== FAIL)
      return RET_BUG;
  gtk_size_group_set_mode(GTK_SIZE_GROUP(self->obj), mode);
  return 0;
}

static int _wrap_gtk_size_group_get_mode(NspGtkSizeGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_size_group_get_mode(GTK_SIZE_GROUP(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_size_group_add_widget(NspGtkSizeGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
  gtk_size_group_add_widget(GTK_SIZE_GROUP(self->obj), GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_size_group_remove_widget(NspGtkSizeGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
  gtk_size_group_remove_widget(GTK_SIZE_GROUP(self->obj), GTK_WIDGET(widget->obj));
  return 0;
}

static NspMethods gtksizegroup_methods[] = {
  {"set_mode",(nsp_method *) _wrap_gtk_size_group_set_mode},
  {"get_mode",(nsp_method *) _wrap_gtk_size_group_get_mode},
  {"add_widget",(nsp_method *) _wrap_gtk_size_group_add_widget},
  {"remove_widget",(nsp_method *) _wrap_gtk_size_group_remove_widget},
  { NULL, NULL}
};

static NspMethods *gtksizegroup_get_methods(void) { return gtksizegroup_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtksizegroup_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkStyle ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkStyle_Private 
#include "nsp/gtk/gtkstyle.h"
#include "nsp/interf.h"

/* NspGtkStyle inherits from NspGObject */ 

int nsp_type_gtkstyle_id=0;
NspTypeGtkStyle *nsp_type_gtkstyle=NULL;

NspTypeGtkStyle *new_type_gtkstyle(type_mode mode)
{
  NspTypeGtkStyle *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkstyle != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkstyle;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkstyle_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkstyle_get_methods; 
  type->new = (new_func *) new_gtkstyle;

  /* specific methods for gtkstyle */
      
  type->init = (init_func *) init_gtkstyle;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkstyle */ 

  top->s_type =  (s_type_func *) gtkstyle_type_as_string;    
  top->sh_type = (sh_type_func *) gtkstyle_type_short_string;
  /* top->create = (create_func*) int_gtkstyle_create;*/ 
  
  /* specific methods for gtkstyle */
      
  type->init = (init_func *) init_gtkstyle;

  if ( nsp_type_gtkstyle_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkStyle called nsp_type_gtkstyle
       */
      type->id =  nsp_type_gtkstyle_id = nsp_new_type_id();
      nsp_type_gtkstyle = type;
      if ( nsp_register_type(nsp_type_gtkstyle) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkstyle, GTK_TYPE_STYLE);
      return ( mode == T_BASE ) ? type : new_type_gtkstyle(mode);
    }
  else 
    {
       type->id = nsp_type_gtkstyle_id;
       return type;
    }
}

/*
 * initialize GtkStyle instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkstyle(NspGtkStyle *o,NspTypeGtkStyle *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkStyle 
 */

NspGtkStyle *new_gtkstyle() 
{
  NspGtkStyle *loc; 
  /* type must exists */
  nsp_type_gtkstyle = new_type_gtkstyle(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkStyle)))== NULLGTKSTYLE) return loc;
  /* initialize object */
  if ( init_gtkstyle(loc,nsp_type_gtkstyle) == FAIL) return NULLGTKSTYLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkStyle 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkstyle_type_name[]="GtkStyle";
static char gtkstyle_short_type_name[]="GtkStyle";

static char *gtkstyle_type_as_string(void)
{
  return(gtkstyle_type_name);
}

static char *gtkstyle_type_short_string(void)
{
  return(gtkstyle_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkStyle objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkStyle   *gtkstyle_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkstyle_id) ) return ((NspGtkStyle *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkstyle));
  return NULL;
}

int IsGtkStyleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkstyle_id);
}

int IsGtkStyle(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkstyle_id);
}

NspGtkStyle  *GetGtkStyleCopy(Stack stack, int i)
{
  if (  GetGtkStyle(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkStyle  *GetGtkStyle(Stack stack, int i)
{
  NspGtkStyle *M;
  if (( M = gtkstyle_object(NthObj(i))) == NULLGTKSTYLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkStyle *gtkstyle_copy(NspGtkStyle *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstyle);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstyle);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkStyle
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkStyle *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkstyle is initialized * /
  nsp_type_gtkstyle = new_type_gtkstyle(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtkstyle)) == NULLGTKSTYLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkstyle_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_style_new())== NULL) return RET_BUG;

  nsp_type_gtkstyle = new_type_gtkstyle(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkstyle );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_color_array_get_fg(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  NspObject *nsp_ret;
  GdkColor *ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_color_array_get_fg(GTK_STYLE(self->obj), pos);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkcolor))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_color_array_get_bg(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  NspObject *nsp_ret;
  GdkColor *ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_color_array_get_bg(GTK_STYLE(self->obj), pos);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkcolor))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_color_array_get_light(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  NspObject *nsp_ret;
  GdkColor *ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_color_array_get_light(GTK_STYLE(self->obj), pos);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkcolor))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_color_array_get_dark(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  NspObject *nsp_ret;
  GdkColor *ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_color_array_get_dark(GTK_STYLE(self->obj), pos);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkcolor))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_color_array_get_mid(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  NspObject *nsp_ret;
  GdkColor *ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_color_array_get_mid(GTK_STYLE(self->obj), pos);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkcolor))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_color_array_get_text(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  NspObject *nsp_ret;
  GdkColor *ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_color_array_get_text(GTK_STYLE(self->obj), pos);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkcolor))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_color_array_get_base(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  NspObject *nsp_ret;
  GdkColor *ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_color_array_get_base(GTK_STYLE(self->obj), pos);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkcolor))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_color_array_get_text_aa(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  NspObject *nsp_ret;
  GdkColor *ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_color_array_get_text_aa(GTK_STYLE(self->obj), pos);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkcolor))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_gc_array_get_fg_gc(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  GdkGC *ret;
  NspObject *nsp_ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_gc_array_get_fg_gc(GTK_STYLE(self->obj), pos);
  nsp_type_gdkgc = new_type_gdkgc(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkgc))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_gc_array_get_bg_gc(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  GdkGC *ret;
  NspObject *nsp_ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_gc_array_get_bg_gc(GTK_STYLE(self->obj), pos);
  nsp_type_gdkgc = new_type_gdkgc(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkgc))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_gc_array_get_light_gc(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  GdkGC *ret;
  NspObject *nsp_ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_gc_array_get_light_gc(GTK_STYLE(self->obj), pos);
  nsp_type_gdkgc = new_type_gdkgc(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkgc))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_gc_array_get_dark_gc(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  GdkGC *ret;
  NspObject *nsp_ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_gc_array_get_dark_gc(GTK_STYLE(self->obj), pos);
  nsp_type_gdkgc = new_type_gdkgc(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkgc))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_gc_array_get_mid_gc(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  GdkGC *ret;
  NspObject *nsp_ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_gc_array_get_mid_gc(GTK_STYLE(self->obj), pos);
  nsp_type_gdkgc = new_type_gdkgc(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkgc))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_gc_array_get_text_gc(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  GdkGC *ret;
  NspObject *nsp_ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_gc_array_get_text_gc(GTK_STYLE(self->obj), pos);
  nsp_type_gdkgc = new_type_gdkgc(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkgc))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_gc_array_get_base_gc(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  GdkGC *ret;
  NspObject *nsp_ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_gc_array_get_base_gc(GTK_STYLE(self->obj), pos);
  nsp_type_gdkgc = new_type_gdkgc(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkgc))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_gc_array_get_text_aa_gc(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  GdkGC *ret;
  NspObject *nsp_ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_gc_array_get_text_aa_gc(GTK_STYLE(self->obj), pos);
  nsp_type_gdkgc = new_type_gdkgc(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkgc))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_nsp_style_pixmap_array_get_bg_pixmap(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pos;
  NspObject *nsp_ret;
  GdkPixmap *ret;

  if ( GetArgs(stack,rhs,opt,T,&pos) == FAIL) return RET_BUG;
  ret = nsp_style_pixmap_array_get_bg_pixmap(GTK_STYLE(self->obj), pos);
  nsp_type_gdkpixmap = new_type_gdkpixmap(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixmap))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_style_copy(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkStyle *ret;

  ret = gtk_style_copy(GTK_STYLE(self->obj));
  nsp_type_gtkstyle = new_type_gtkstyle(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstyle))== NULL) return RET_BUG;
  g_object_unref(ret);
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_style_attach(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *window;
  NspObject *nsp_ret;
  GtkStyle *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window) == FAIL) return RET_BUG;
  ret = gtk_style_attach(GTK_STYLE(self->obj), GDK_WINDOW(window->obj));
  nsp_type_gtkstyle = new_type_gtkstyle(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstyle))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_style_detach(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_style_detach(GTK_STYLE(self->obj));
  return 0;
}

static int _wrap_gtk_style_get_font(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkFont *ret;
  NspObject *nsp_ret;

  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  ret = gtk_style_get_font(GTK_STYLE(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_FONT, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkfont))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_style_set_font(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GdkFont *font = NULL;
  NspObject *nsp_font;

  if ( GetArgs(stack,rhs,opt,T,&nsp_font) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  if (nspg_boxed_check(nsp_font, GDK_TYPE_FONT))
      font = nspg_boxed_get(nsp_font, GdkFont);
  else {
      Scierror( "font should be a GdkFont");
      return RET_BUG;
  }
  gtk_style_set_font(GTK_STYLE(self->obj), font);
  return 0;
}

static int _wrap_gtk_style_set_background(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj,t_end};
  NspGObject *window;
  GtkStateType state_type;
  NspObject *nsp_state_type = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  gtk_style_set_background(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type);
  return 0;
}

static int _wrap_gtk_style_apply_default_background(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_bool, obj, obj, s_int, s_int, s_int, s_int,t_end};
  int set_bg, x, y, width, height;
  NspGObject *window;
  GtkStateType state_type;
  NspObject *nsp_state_type = NULL, *nsp_area = NULL;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &set_bg, &nsp_state_type, &nsp_area, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  gtk_style_apply_default_background(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), set_bg, state_type, area, x, y, width, height);
  return 0;
}

static int _wrap_gtk_style_lookup_icon_set(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *stock_id;
  NspObject *nsp_ret;
  GtkIconSet *ret;

  if ( GetArgs(stack,rhs,opt,T,&stock_id) == FAIL) return RET_BUG;
  ret = gtk_style_lookup_icon_set(GTK_STYLE(self->obj), stock_id);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_SET, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconset))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_style_render_icon(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj, obj, obj, obj_check, string,t_end};
  GtkIconSource *source = NULL;
  NspObject *nsp_source, *nsp_direction = NULL, *nsp_state = NULL, *nsp_size = NULL, *nsp_ret;
  NspGObject *widget;
  GdkPixbuf *ret;
  char *detail;
  GtkIconSize size;
  GtkTextDirection direction;
  GtkStateType state;

  if ( GetArgs(stack,rhs,opt,T,&nsp_source, &nsp_direction, &nsp_state, &nsp_size, &nsp_type_gtkwidget, &widget, &detail) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_source, GTK_TYPE_ICON_SOURCE))
      source = nspg_boxed_get(nsp_source, GtkIconSource);
  else {
      Scierror( "source should be a GtkIconSource");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, nsp_direction, &direction)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state, &state)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
  ret = gtk_style_render_icon(GTK_STYLE(self->obj), source, direction, state, size, GTK_WIDGET(widget->obj), detail);
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_paint_hline(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, string, s_int, s_int, s_int,t_end};
  NspObject *nsp_state_type = NULL, *nsp_area = NULL;
  int x1, x2, y;
  NspGObject *window, *nsp_widget;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_area, &nsp_widget, &detail, &x1, &x2, &y) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_hline(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, widget, detail, x1, x2, y);
  return 0;
}

static int _wrap_gtk_paint_vline(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, string, s_int, s_int, s_int,t_end};
  NspObject *nsp_state_type = NULL, *nsp_area = NULL;
  int y1, y2, x;
  NspGObject *window, *nsp_widget;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_area, &nsp_widget, &detail, &y1, &y2, &x) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_vline(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, widget, detail, y1, y2, x);
  return 0;
}

static int _wrap_gtk_paint_shadow(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_shadow(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height);
  return 0;
}

#line 517 "gtk.override"
static int
_wrap_gtk_paint_polygon(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,obj,obj,obj_check,string,realmat,s_bool, t_end} ;
  /*  static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "points", "fill", NULL }; */
  NspObject *window, *nsp_state_type, *nsp_shadow_type, *nsp_area;
  GtkStateType state_type;
  GtkShadowType shadow_type;
  GdkRectangle area;
  NspObject *widget;
  const gchar *detail;
  NspMatrix *nsp_points;
  gint npoints, i;
  GdkPoint *points;
  gboolean fill;
  
  if (GetArgs(stack,rhs,opt,T,
	      &nsp_type_gdkwindow, &window,
	      &nsp_state_type, &nsp_shadow_type, &nsp_area,
	      &nsp_type_gtkwidget, &widget, &detail,
	      &nsp_points, &fill) == FAIL) return RET_BUG;

  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type,&state_type)== FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type,&shadow_type) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_area, &area)) return RET_BUG;
  
  if ( nsp_points->n != 2) { 
    Scierror("%s: third argument should have two columns\n");
    return RET_BUG;
  } 
  
  npoints = nsp_points->m;
  points = g_new(GdkPoint, npoints);
  for (i = 0; i < npoints ; i++) {
    points[i].x = nsp_points->R[i] ; 
    points[i].y = nsp_points->R[i +nsp_points->m ];
    }
  gtk_paint_polygon(GTK_STYLE(self->obj), GDK_WINDOW(nspgobject_get(window)),
		    state_type, shadow_type, &area,
		    GTK_WIDGET(nspgobject_get(widget)), detail,
		    points, npoints, fill);
  g_free(points);
  return 0;
}
#line 11811 "gtk.c"


static int _wrap_gtk_paint_arrow(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, obj, s_bool, s_int, s_int, s_int, s_int,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL, *nsp_arrow_type = NULL;
  int fill, x, y, width, height;
  NspGObject *window, *nsp_widget;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;
  GtkArrowType arrow_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &nsp_arrow_type, &fill, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_ARROW_TYPE, nsp_arrow_type, &arrow_type)== FAIL)
      return RET_BUG;
  gtk_paint_arrow(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, arrow_type, fill, x, y, width, height);
  return 0;
}

static int _wrap_gtk_paint_diamond(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_diamond(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height);
  return 0;
}

static int _wrap_gtk_paint_box(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_box(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height);
  return 0;
}

static int _wrap_gtk_paint_flat_box(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_flat_box(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height);
  return 0;
}

static int _wrap_gtk_paint_check(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_check(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height);
  return 0;
}

static int _wrap_gtk_paint_option(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_option(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height);
  return 0;
}

static int _wrap_gtk_paint_tab(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_tab(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height);
  return 0;
}

static int _wrap_gtk_paint_shadow_gap(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int, obj, s_int, s_int,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL, *nsp_gap_side = NULL;
  int x, y, width, height, gap_x, gap_width;
  NspGObject *window, *nsp_widget;
  GtkPositionType gap_side;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height, &nsp_gap_side, &gap_x, &gap_width) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_gap_side, &gap_side)== FAIL)
      return RET_BUG;
  gtk_paint_shadow_gap(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height, gap_side, gap_x, gap_width);
  return 0;
}

static int _wrap_gtk_paint_box_gap(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int, obj, s_int, s_int,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL, *nsp_gap_side = NULL;
  int x, y, width, height, gap_x, gap_width;
  NspGObject *window, *nsp_widget;
  GtkPositionType gap_side;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height, &nsp_gap_side, &gap_x, &gap_width) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_gap_side, &gap_side)== FAIL)
      return RET_BUG;
  gtk_paint_box_gap(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height, gap_side, gap_x, gap_width);
  return 0;
}

static int _wrap_gtk_paint_extension(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int, obj,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL, *nsp_gap_side = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  GtkPositionType gap_side;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height, &nsp_gap_side) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_gap_side, &gap_side)== FAIL)
      return RET_BUG;
  gtk_paint_extension(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height, gap_side);
  return 0;
}

static int _wrap_gtk_paint_focus(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, string, s_int, s_int, s_int, s_int,t_end};
  NspObject *nsp_state_type = NULL, *nsp_area = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_focus(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, widget, detail, x, y, width, height);
  return 0;
}

static int _wrap_gtk_paint_slider(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int, obj,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL, *nsp_orientation = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  char *detail;
  GtkOrientation orientation;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height, &nsp_orientation) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  gtk_paint_slider(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height, orientation);
  return 0;
}

static int _wrap_gtk_paint_handle(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, obj, string, s_int, s_int, s_int, s_int, obj,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_state_type = NULL, *nsp_shadow_type = NULL, *nsp_area = NULL, *nsp_orientation = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  char *detail;
  GtkOrientation orientation;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_shadow_type, &nsp_area, &nsp_widget, &detail, &x, &y, &width, &height, &nsp_orientation) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  gtk_paint_handle(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, shadow_type, area, widget, detail, x, y, width, height, orientation);
  return 0;
}

static int _wrap_gtk_paint_expander(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, string, s_int, s_int, obj,t_end};
  NspObject *nsp_state_type = NULL, *nsp_area = NULL, *nsp_expander_style = NULL;
  int x, y;
  NspGObject *window, *nsp_widget;
  char *detail;
  GtkExpanderStyle expander_style;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_area, &nsp_widget, &detail, &x, &y, &nsp_expander_style) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_EXPANDER_STYLE, nsp_expander_style, &expander_style)== FAIL)
      return RET_BUG;
  gtk_paint_expander(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, widget, detail, x, y, expander_style);
  return 0;
}

static int _wrap_gtk_paint_layout(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, s_bool, obj, obj, string, s_int, s_int, obj_check,t_end};
  NspObject *nsp_state_type = NULL, *nsp_area = NULL;
  int use_text, x, y;
  NspGObject *window, *nsp_widget, *layout;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &use_text, &nsp_area, &nsp_widget, &detail, &x, &y, &nsp_type_pangolayout, &layout) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_layout(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, use_text, area, widget, detail, x, y, PANGO_LAYOUT(layout->obj));
  return 0;
}

static int _wrap_gtk_paint_resize_grip(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, string, obj, s_int, s_int, s_int, s_int,t_end};
  NspObject *nsp_state_type = NULL, *nsp_area = NULL, *nsp_edge = NULL;
  int x, y, width, height;
  NspGObject *window, *nsp_widget;
  GdkWindowEdge edge;
  char *detail;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_area, &nsp_widget, &detail, &nsp_edge, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GDK_TYPE_WINDOW_EDGE, nsp_edge, &edge)== FAIL)
      return RET_BUG;
  gtk_paint_resize_grip(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, widget, detail, edge, x, y, width, height);
  return 0;
}

static int _wrap_gtk_style_apply_default_pixmap(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_bool, obj, s_int, s_int, s_int, s_int,t_end};
  int set_bg, x, y, width, height;
  NspGObject *window;
  GdkRectangle area = { 0, 0, 0, 0 };
  NspObject *nsp_area;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &set_bg, &nsp_area, &x, &y, &width, &height) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkStyle.apply_default_background",stack.fname); return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_area, &area))
      return RET_BUG;
  gtk_style_apply_default_pixmap(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), set_bg, &area, x, y, width, height);
  return 0;
}

static int _wrap_gtk_paint_string(NspGtkStyle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj, obj, string, s_int, s_int, string,t_end};
  NspObject *nsp_state_type = NULL, *nsp_area = NULL;
  int x, y;
  NspGObject *window, *nsp_widget;
  char *detail, *string;
  GdkRectangle area_rect = { 0, 0, 0, 0 }, *area;
  GtkWidget *widget = NULL;
  GtkStateType state_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_state_type, &nsp_area, &nsp_widget, &detail, &x, &y, &string) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type, &state_type)== FAIL)
      return RET_BUG;
  if (nsp_area == NULL)
      area = NULL;
  else if (nsp_gdk_rectangle_from_object(nsp_area, &area_rect))
      area = &area_rect;
  else
          return RET_BUG;
  if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
  else if ( ! IsNone((NspObject *) nsp_widget))  {
      Scierror( "widget should be a GtkWidget or None");
      return RET_BUG;
  }
  gtk_paint_string(GTK_STYLE(self->obj), GDK_WINDOW(window->obj), state_type, area, widget, detail, x, y, string);
  return 0;
}

static NspMethods gtkstyle_methods[] = {
  {"get_fg",(nsp_method *) _wrap_nsp_style_color_array_get_fg},
  {"get_bg",(nsp_method *) _wrap_nsp_style_color_array_get_bg},
  {"get_light",(nsp_method *) _wrap_nsp_style_color_array_get_light},
  {"get_dark",(nsp_method *) _wrap_nsp_style_color_array_get_dark},
  {"get_mid",(nsp_method *) _wrap_nsp_style_color_array_get_mid},
  {"get_text",(nsp_method *) _wrap_nsp_style_color_array_get_text},
  {"get_base",(nsp_method *) _wrap_nsp_style_color_array_get_base},
  {"get_text_aa",(nsp_method *) _wrap_nsp_style_color_array_get_text_aa},
  {"get_fg_gc",(nsp_method *) _wrap_nsp_style_gc_array_get_fg_gc},
  {"get_bg_gc",(nsp_method *) _wrap_nsp_style_gc_array_get_bg_gc},
  {"get_light_gc",(nsp_method *) _wrap_nsp_style_gc_array_get_light_gc},
  {"get_dark_gc",(nsp_method *) _wrap_nsp_style_gc_array_get_dark_gc},
  {"get_mid_gc",(nsp_method *) _wrap_nsp_style_gc_array_get_mid_gc},
  {"get_text_gc",(nsp_method *) _wrap_nsp_style_gc_array_get_text_gc},
  {"get_base_gc",(nsp_method *) _wrap_nsp_style_gc_array_get_base_gc},
  {"get_text_aa_gc",(nsp_method *) _wrap_nsp_style_gc_array_get_text_aa_gc},
  {"get_bg_pixmap",(nsp_method *) _wrap_nsp_style_pixmap_array_get_bg_pixmap},
  {"copy",(nsp_method *) _wrap_gtk_style_copy},
  {"attach",(nsp_method *) _wrap_gtk_style_attach},
  {"detach",(nsp_method *) _wrap_gtk_style_detach},
  {"get_font",(nsp_method *) _wrap_gtk_style_get_font},
  {"set_font",(nsp_method *) _wrap_gtk_style_set_font},
  {"set_background",(nsp_method *) _wrap_gtk_style_set_background},
  {"apply_default_background",(nsp_method *) _wrap_gtk_style_apply_default_background},
  {"lookup_icon_set",(nsp_method *) _wrap_gtk_style_lookup_icon_set},
  {"render_icon",(nsp_method *) _wrap_gtk_style_render_icon},
  {"paint_hline",(nsp_method *) _wrap_gtk_paint_hline},
  {"paint_vline",(nsp_method *) _wrap_gtk_paint_vline},
  {"paint_shadow",(nsp_method *) _wrap_gtk_paint_shadow},
  {"paint_polygon",(nsp_method *) _wrap_gtk_paint_polygon},
  {"paint_arrow",(nsp_method *) _wrap_gtk_paint_arrow},
  {"paint_diamond",(nsp_method *) _wrap_gtk_paint_diamond},
  {"paint_box",(nsp_method *) _wrap_gtk_paint_box},
  {"paint_flat_box",(nsp_method *) _wrap_gtk_paint_flat_box},
  {"paint_check",(nsp_method *) _wrap_gtk_paint_check},
  {"paint_option",(nsp_method *) _wrap_gtk_paint_option},
  {"paint_tab",(nsp_method *) _wrap_gtk_paint_tab},
  {"paint_shadow_gap",(nsp_method *) _wrap_gtk_paint_shadow_gap},
  {"paint_box_gap",(nsp_method *) _wrap_gtk_paint_box_gap},
  {"paint_extension",(nsp_method *) _wrap_gtk_paint_extension},
  {"paint_focus",(nsp_method *) _wrap_gtk_paint_focus},
  {"paint_slider",(nsp_method *) _wrap_gtk_paint_slider},
  {"paint_handle",(nsp_method *) _wrap_gtk_paint_handle},
  {"paint_expander",(nsp_method *) _wrap_gtk_paint_expander},
  {"paint_layout",(nsp_method *) _wrap_gtk_paint_layout},
  {"paint_resize_grip",(nsp_method *) _wrap_gtk_paint_resize_grip},
  {"apply_default_pixmap",(nsp_method *) _wrap_gtk_style_apply_default_pixmap},
  {"paint_string",(nsp_method *) _wrap_gtk_paint_string},
  { NULL, NULL}
};

static NspMethods *gtkstyle_get_methods(void) { return gtkstyle_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

#line 305 "gtk.override"
static NspObject *
_wrap_gtk_style__get_fg(NspGObject *self, char *attr)
{
  Scierror("Use method .get_fg[pos]\n");
  return NULL;
}
#line 12465 "gtk.c"
#line 313 "gtk.override"
static NspObject *
_wrap_gtk_style__get_bg(NspGObject *self, char *attr)
{
  Scierror("Use method .get_bg[pos]\n");
  return NULL;
}
#line 12473 "gtk.c"
#line 321 "gtk.override"
static NspObject *
_wrap_gtk_style__get_light(NspGObject *self, char *attr)
{
  Scierror("Use method .get_light[pos]\n");
  return NULL;
}
#line 12481 "gtk.c"
#line 329 "gtk.override"
static NspObject *
_wrap_gtk_style__get_dark(NspGObject *self, char *attr)
{
  Scierror("Use method .get_dark[pos]\n");
  return NULL;
}
#line 12489 "gtk.c"
#line 337 "gtk.override"
static NspObject *
_wrap_gtk_style__get_mid(NspGObject *self, char *attr)
{
  Scierror("Use method .get_mid[pos]\n");
  return NULL;
}
#line 12497 "gtk.c"
#line 345 "gtk.override"
static NspObject *
_wrap_gtk_style__get_text(NspGObject *self, char *attr)
{
  Scierror("Use method .get_text[pos]\n");
  return NULL;
}
#line 12505 "gtk.c"
#line 353 "gtk.override"
static NspObject *
_wrap_gtk_style__get_base(NspGObject *self, char *attr)
{
  Scierror("Use method .get_base[pos]\n");
  return NULL;
}
#line 12513 "gtk.c"
#line 361 "gtk.override"
static NspObject *
_wrap_gtk_style__get_text_aa(NspGObject *self, char *attr)
{
  Scierror("Use method .get_text_aa[pos]\n");
  return NULL;
}
#line 12521 "gtk.c"
#line 369 "gtk.override"
static NspObject *
_wrap_gtk_style__get_white(NspGObject *self, char *attr)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  return (NspObject *)gboxed_create(NVOID,GDK_TYPE_COLOR, &style->white, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor);
}
static int
_wrap_gtk_style__set_white(NspGObject *self, char *attr, NspObject *value)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  if (!nspg_boxed_check(value, GDK_TYPE_COLOR)) {
    Scierror("can only assign a GdkColor");
    return RET_BUG;
  }
  style->white = *nspg_boxed_get(value, GdkColor);
  return 0;
}
#line 12540 "gtk.c"
#line 388 "gtk.override"
static NspObject *
_wrap_gtk_style__get_black(NspGObject *self, char *attr)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  return (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, &style->black, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor);
}
static int
_wrap_gtk_style__set_black(NspGObject *self, char *attr, NspObject *value)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  if (!nspg_boxed_check(value, GDK_TYPE_COLOR)) {
    Scierror( "can only assign a GdkColor");
    return RET_BUG;
  }
  style->black = *nspg_boxed_get(value, GdkColor);
  return 0;
}
#line 12559 "gtk.c"
static NspObject *_wrap_gtk_style__get_font_desc(NspObject *self,char *attr)
{
  PangoFontDescription *ret;

  ret = (PangoFontDescription*) GTK_STYLE(NSP_GOBJECT_GET(self))->font_desc;
  /* nspg_boxed_new handles NULL checking */
  return (NspObject *) gboxed_create(NVOID,PANGO_TYPE_FONT_DESCRIPTION, ret, TRUE, TRUE,(NspTypeBase *) nsp_type_pangofontdescription);
}

static NspObject *_wrap_gtk_style__get_xthickness(NspObject *self,char *attr)
{
  int ret;

  ret = (gint) GTK_STYLE(NSP_GOBJECT_GET(self))->xthickness;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_style__get_ythickness(NspObject *self,char *attr)
{
  int ret;

  ret = (gint) GTK_STYLE(NSP_GOBJECT_GET(self))->ythickness;
  return nsp_new_double_obj((double) ret);
}

#line 407 "gtk.override"
static NspObject *
_wrap_gtk_style__get_fg_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_fg_gc[pos]\n");
  return NULL;
}
#line 12592 "gtk.c"
#line 415 "gtk.override"
static NspObject *
_wrap_gtk_style__get_bg_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_bg_gc[pos]\n");
  return NULL;
}
#line 12600 "gtk.c"
#line 423 "gtk.override"
static NspObject *
_wrap_gtk_style__get_light_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_light_gc[pos]\n");
  return NULL;
}
#line 12608 "gtk.c"
#line 431 "gtk.override"
static NspObject *
_wrap_gtk_style__get_dark_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_dark_gc[pos]\n");
  return NULL;
}
#line 12616 "gtk.c"
#line 439 "gtk.override"
static NspObject *
_wrap_gtk_style__get_mid_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_mid_gc[pos]\n");
  return NULL;
}
#line 12624 "gtk.c"
#line 447 "gtk.override"
static NspObject *
_wrap_gtk_style__get_text_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_text_gc[pos]\n");
  return NULL;
}
#line 12632 "gtk.c"
#line 455 "gtk.override"
static NspObject *
_wrap_gtk_style__get_base_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_base_gc[pos]\n");
  return NULL;
}
#line 12640 "gtk.c"
#line 463 "gtk.override"
static NspObject *
_wrap_gtk_style__get_text_aa_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_text_aa_gc[pos]\n");
  return NULL;
}
#line 12648 "gtk.c"
#line 471 "gtk.override"
static NspObject *
_wrap_gtk_style__get_white_gc(NspGObject *self, char *attr)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  return (NspObject *) gobject_create(NVOID,(GObject *)style->white_gc,(NspTypeBase *) nsp_type_gdkgc );
}
static int
_wrap_gtk_style__set_white_gc(NspGObject *self, char *attr, NspObject *value)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  if (!nspgobject_check((NspGObject *) value,(NspTypeBase *) nsp_type_gdkgc)) {
    Scierror( "can only assign a GdkGC");
    return RET_BUG;
  }
  style->white_gc = GDK_GC(nspgobject_get(value));
  return 0;
}
#line 12667 "gtk.c"
#line 490 "gtk.override"
static NspObject *
_wrap_gtk_style__get_black_gc(NspGObject *self, char *attr)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  return (NspObject *) gobject_create(NVOID,(GObject *)style->black_gc,(NspTypeBase *) nsp_type_gdkgc );
}
static int
_wrap_gtk_style__set_black_gc(NspGObject *self, char *attr, NspObject *value)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  if (!nspgobject_check((NspGObject *) value,(NspTypeBase *) nsp_type_gdkgc)) {
    Scierror( "can only assign a GdkGC");
    return RET_BUG;
  }
  style->black_gc = GDK_GC(nspgobject_get(value));
  return 0;
}
#line 12686 "gtk.c"
#line 509 "gtk.override"
static NspObject *
_wrap_gtk_style__get_bg_pixmap(NspGObject *self, char *attr)
{
  Scierror("Use method .get_bg_pixmap[pos]\n");
  return NULL;
}
#line 12694 "gtk.c"
static AttrTab gtkstyle_attrs[] = {
  { "fg", (attr_get_function *)_wrap_gtk_style__get_fg, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "bg", (attr_get_function *)_wrap_gtk_style__get_bg, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "light", (attr_get_function *)_wrap_gtk_style__get_light, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "dark", (attr_get_function *)_wrap_gtk_style__get_dark, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "mid", (attr_get_function *)_wrap_gtk_style__get_mid, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "text", (attr_get_function *)_wrap_gtk_style__get_text, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "base", (attr_get_function *)_wrap_gtk_style__get_base, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "text_aa", (attr_get_function *)_wrap_gtk_style__get_text_aa, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "white", (attr_get_function *)_wrap_gtk_style__get_white, (attr_set_function *)_wrap_gtk_style__set_white,(attr_get_object_function *)int_get_object_failed },
  { "black", (attr_get_function *)_wrap_gtk_style__get_black, (attr_set_function *)_wrap_gtk_style__set_black,(attr_get_object_function *)int_get_object_failed },
  { "font_desc", (attr_get_function *)_wrap_gtk_style__get_font_desc, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "xthickness", (attr_get_function *)_wrap_gtk_style__get_xthickness, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "ythickness", (attr_get_function *)_wrap_gtk_style__get_ythickness, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "fg_gc", (attr_get_function *)_wrap_gtk_style__get_fg_gc, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "bg_gc", (attr_get_function *)_wrap_gtk_style__get_bg_gc, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "light_gc", (attr_get_function *)_wrap_gtk_style__get_light_gc, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "dark_gc", (attr_get_function *)_wrap_gtk_style__get_dark_gc, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "mid_gc", (attr_get_function *)_wrap_gtk_style__get_mid_gc, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "text_gc", (attr_get_function *)_wrap_gtk_style__get_text_gc, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "base_gc", (attr_get_function *)_wrap_gtk_style__get_base_gc, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "text_aa_gc", (attr_get_function *)_wrap_gtk_style__get_text_aa_gc, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "white_gc", (attr_get_function *)_wrap_gtk_style__get_white_gc, (attr_set_function *)_wrap_gtk_style__set_white_gc,(attr_get_object_function *)int_get_object_failed },
  { "black_gc", (attr_get_function *)_wrap_gtk_style__get_black_gc, (attr_set_function *)_wrap_gtk_style__set_black_gc,(attr_get_object_function *)int_get_object_failed },
  { "bg_pixmap", (attr_get_function *)_wrap_gtk_style__get_bg_pixmap, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkTextBuffer ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTextBuffer_Private 
#include "nsp/gtk/gtktextbuffer.h"
#include "nsp/interf.h"

/* NspGtkTextBuffer inherits from NspGObject */ 

int nsp_type_gtktextbuffer_id=0;
NspTypeGtkTextBuffer *nsp_type_gtktextbuffer=NULL;

NspTypeGtkTextBuffer *new_type_gtktextbuffer(type_mode mode)
{
  NspTypeGtkTextBuffer *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextbuffer != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextbuffer;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextbuffer_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktextbuffer_get_methods; 
  type->new = (new_func *) new_gtktextbuffer;

  /* specific methods for gtktextbuffer */
      
  type->init = (init_func *) init_gtktextbuffer;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktextbuffer */ 

  top->s_type =  (s_type_func *) gtktextbuffer_type_as_string;    
  top->sh_type = (sh_type_func *) gtktextbuffer_type_short_string;
  /* top->create = (create_func*) int_gtktextbuffer_create;*/ 
  
  /* specific methods for gtktextbuffer */
      
  type->init = (init_func *) init_gtktextbuffer;

  if ( nsp_type_gtktextbuffer_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextBuffer called nsp_type_gtktextbuffer
       */
      type->id =  nsp_type_gtktextbuffer_id = nsp_new_type_id();
      nsp_type_gtktextbuffer = type;
      if ( nsp_register_type(nsp_type_gtktextbuffer) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextbuffer, GTK_TYPE_TEXT_BUFFER);
      return ( mode == T_BASE ) ? type : new_type_gtktextbuffer(mode);
    }
  else 
    {
       type->id = nsp_type_gtktextbuffer_id;
       return type;
    }
}

/*
 * initialize GtkTextBuffer instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextbuffer(NspGtkTextBuffer *o,NspTypeGtkTextBuffer *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTextBuffer 
 */

NspGtkTextBuffer *new_gtktextbuffer() 
{
  NspGtkTextBuffer *loc; 
  /* type must exists */
  nsp_type_gtktextbuffer = new_type_gtktextbuffer(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextBuffer)))== NULLGTKTEXTBUFFER) return loc;
  /* initialize object */
  if ( init_gtktextbuffer(loc,nsp_type_gtktextbuffer) == FAIL) return NULLGTKTEXTBUFFER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTextBuffer 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktextbuffer_type_name[]="GtkTextBuffer";
static char gtktextbuffer_short_type_name[]="GtkTextBuffer";

static char *gtktextbuffer_type_as_string(void)
{
  return(gtktextbuffer_type_name);
}

static char *gtktextbuffer_type_short_string(void)
{
  return(gtktextbuffer_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTextBuffer objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTextBuffer   *gtktextbuffer_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktextbuffer_id) ) return ((NspGtkTextBuffer *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextbuffer));
  return NULL;
}

int IsGtkTextBufferObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktextbuffer_id);
}

int IsGtkTextBuffer(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextbuffer_id);
}

NspGtkTextBuffer  *GetGtkTextBufferCopy(Stack stack, int i)
{
  if (  GetGtkTextBuffer(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextBuffer  *GetGtkTextBuffer(Stack stack, int i)
{
  NspGtkTextBuffer *M;
  if (( M = gtktextbuffer_object(NthObj(i))) == NULLGTKTEXTBUFFER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextBuffer *gtktextbuffer_copy(NspGtkTextBuffer *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextbuffer);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextbuffer);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextBuffer
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTextBuffer *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktextbuffer is initialized * /
  nsp_type_gtktextbuffer = new_type_gtktextbuffer(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtktextbuffer)) == NULLGTKTEXTBUFFER) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtktextbuffer_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"table",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *nsp_table = NULL;
  GtkTextTagTable *table = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_table) == FAIL) return RET_BUG;
  if ( nsp_table != NULL ) {
    if ( IsGtkTextTagTable((NspObject *)nsp_table))
      table = GTK_TEXT_TAG_TABLE(nsp_table->obj);
    else if (! IsNone((NspObject *)nsp_table)) {
         Scierror( "table should be a GtkTextTagTable or None");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_text_buffer_new(table))== NULL) return RET_BUG;

  nsp_type_gtktextbuffer = new_type_gtktextbuffer(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktextbuffer );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_get_line_count(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_buffer_get_line_count(GTK_TEXT_BUFFER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_get_char_count(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_buffer_get_char_count(GTK_TEXT_BUFFER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_get_tag_table(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextTagTable *ret;
  NspObject *nsp_ret;

  ret = gtk_text_buffer_get_tag_table(GTK_TEXT_BUFFER(self->obj));
  nsp_type_gtktexttagtable = new_type_gtktexttagtable(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktexttagtable))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 5695 "gtk.override"
static int
_wrap_gtk_text_buffer_set_text(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  char *text;
  int_types T[] = { string, t_end} ;
  if (GetArgs(stack,rhs,opt,T, &text) == FAIL) return RET_BUG;
  gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->obj), text, strlen(text));
  return 0;
}
#line 12987 "gtk.c"


#line 5725 "gtk.override"
static int
_wrap_gtk_text_buffer_insert(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check , string, t_end} ;
  NspObject *nsp_iter;
  char *text;
  GtkTextIter *iter = NULL;
  
  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter,  &nsp_iter, &text)  == FAIL) return RET_BUG;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text));
  return 0;
}
#line 13004 "gtk.c"


#line 5740 "gtk.override"
static int
_wrap_gtk_text_buffer_insert_at_cursor(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { string, t_end} ;
  char *text;

  if (GetArgs(stack,rhs,opt,T, &text)  == FAIL) return RET_BUG;
  gtk_text_buffer_insert_at_cursor(GTK_TEXT_BUFFER(self->obj), text,strlen(text));
  return 0;
}
#line 13018 "gtk.c"


#line 5752 "gtk.override"
static int
_wrap_gtk_text_buffer_insert_interactive(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check ,string,s_bool, t_end} ;
  /* static char *kwlist[] = { "iter", "text", "default_editable", NULL };*/
  NspObject *nsp_iter;
  char *text;
  int len, default_editable, ret;
  GtkTextIter *iter = NULL;
  
  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter,&nsp_iter, &text, &default_editable) == FAIL) return RET_BUG;;
  len = strlen(text);
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  ret = gtk_text_buffer_insert_interactive(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text), default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG; 
  return 1;
}
#line 13039 "gtk.c"


#line 5771 "gtk.override"
static int
_wrap_gtk_text_buffer_insert_interactive_at_cursor(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_bool, t_end} ;
  char *text;
  int  default_editable, ret;
  if (GetArgs(stack,rhs,opt,T, &text, &default_editable) ==  FAIL) return RET_BUG;;
  ret = gtk_text_buffer_insert_interactive_at_cursor(GTK_TEXT_BUFFER(self->obj), text,strlen(text), default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG; 
  return 1;
}
#line 13054 "gtk.c"


static int _wrap_gtk_text_buffer_insert_range(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj, obj,t_end};
  NspObject *nsp_iter, *nsp_start, *nsp_end;
  GtkTextIter *iter = NULL, *start = NULL, *end = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "start should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "end should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_insert_range(GTK_TEXT_BUFFER(self->obj), iter, start, end);
  return 0;
}

static int _wrap_gtk_text_buffer_insert_range_interactive(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj, obj, s_bool,t_end};
  int default_editable, ret;
  NspObject *nsp_iter, *nsp_start, *nsp_end;
  GtkTextIter *iter = NULL, *start = NULL, *end = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_start, &nsp_end, &default_editable) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "start should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "end should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_buffer_insert_range_interactive(GTK_TEXT_BUFFER(self->obj), iter, start, end, default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 5448 "gtk.override"
static int
_wrap_gtk_text_buffer_insert_with_tags(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject  *nsp_iter;
  gint i,  start_offset;
  gchar *text;
  GtkTextIter *iter, start;

  if (rhs-opt < 1) {
    Scierror("GtkTextBuffer.insert_with_tags_by_name requires at least 1 meth. argument");
    return RET_BUG;
  }

  if (( nsp_iter = (NspObject *) GetGtkTextIter(stack,1)) == NULL) return RET_BUG; 
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);

  if ( rhs >= 2) 
    {
      if (( text = GetString(stack,2))== NULL) return RET_BUG; 
      start_offset = gtk_text_iter_get_offset(iter);
      gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text));
      gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj), &start, start_offset);
    }
  for (i = 3; i <= rhs ; i++) 
    {
      GtkTextTag *tag;
      if (( tag = (GtkTextTag *) GetGtkTextTag(stack,i))== NULL) return RET_BUG; 
      gtk_text_buffer_apply_tag(GTK_TEXT_BUFFER(self->obj),tag, &start, iter);
    }
  return 0;
}
#line 13149 "gtk.c"


#line 5481 "gtk.override"
static int
_wrap_gtk_text_buffer_insert_with_tags_by_name(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject  *nsp_iter;
  gint  i, start_offset;
  gchar *text;
  GtkTextIter *iter, start;

  if (rhs-opt < 1) {
    Scierror("GtkTextBuffer.insert_with_tags_by_name requires at least 1 meth. argument");
    return RET_BUG;
  }

  if (( nsp_iter =(NspObject *)  GetGtkTextIter(stack,1)) == NULL) return RET_BUG; 
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);

  if ( rhs >= 2) 
    {
      if (( text = GetString(stack,2))== NULL) return RET_BUG; 
      start_offset = gtk_text_iter_get_offset(iter);
      gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text));
      gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj), &start, start_offset);
    }
  for (i = 3; i <= rhs ; i++) 
    {
      char *tagname;
      if (( tagname = GetString(stack,i))== NULL) return RET_BUG; 
      gtk_text_buffer_apply_tag_by_name(GTK_TEXT_BUFFER(self->obj),tagname, &start, iter);
    }
  return 0;
}
#line 13184 "gtk.c"


static int _wrap_gtk_text_buffer_delete(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  NspObject *nsp_start, *nsp_end;
  GtkTextIter *start = NULL, *end = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "start should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "end should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_delete(GTK_TEXT_BUFFER(self->obj), start, end);
  return 0;
}

static int _wrap_gtk_text_buffer_delete_interactive(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj, s_bool,t_end};
  int default_editable, ret;
  NspObject *nsp_start_iter, *nsp_end_iter;
  GtkTextIter *start_iter = NULL, *end_iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_start_iter, &nsp_end_iter, &default_editable) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start_iter, GTK_TYPE_TEXT_ITER))
      start_iter = nspg_boxed_get(nsp_start_iter, GtkTextIter);
  else {
      Scierror( "start_iter should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end_iter, GTK_TYPE_TEXT_ITER))
      end_iter = nspg_boxed_get(nsp_end_iter, GtkTextIter);
  else {
      Scierror( "end_iter should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_buffer_delete_interactive(GTK_TEXT_BUFFER(self->obj), start_iter, end_iter, default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_get_text(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,new_opts,t_end};
  nsp_option opts[] = {
	{"include_hidden_chars",s_bool,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int include_hidden_chars = TRUE;
  gchar *ret;
  NspObject *nsp_start, *nsp_end;
  GtkTextIter *start = NULL, *end = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_start, &nsp_end, opts, &include_hidden_chars) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "start should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "end should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_buffer_get_text(GTK_TEXT_BUFFER(self->obj), start, end, include_hidden_chars);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_text_buffer_get_slice(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,new_opts,t_end};
  nsp_option opts[] = {
	{"include_hidden_chars",s_bool,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int include_hidden_chars = TRUE;
  gchar *ret;
  NspObject *nsp_start, *nsp_end;
  GtkTextIter *start = NULL, *end = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_start, &nsp_end, opts, &include_hidden_chars) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "start should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "end should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_buffer_get_slice(GTK_TEXT_BUFFER(self->obj), start, end, include_hidden_chars);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_text_buffer_insert_pixbuf(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj_check,t_end};
  NspGObject *pixbuf;
  NspObject *nsp_iter;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_insert_pixbuf(GTK_TEXT_BUFFER(self->obj), iter, GDK_PIXBUF(pixbuf->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_insert_child_anchor(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj_check,t_end};
  NspGObject *anchor;
  NspObject *nsp_iter;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_type_gtktextchildanchor, &anchor) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_insert_child_anchor(GTK_TEXT_BUFFER(self->obj), iter, GTK_TEXT_CHILD_ANCHOR(anchor->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_create_child_anchor(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTextChildAnchor *ret;
  NspObject *nsp_iter, *nsp_ret;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_buffer_create_child_anchor(GTK_TEXT_BUFFER(self->obj), iter);
  nsp_type_gtktextchildanchor = new_type_gtktextchildanchor(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextchildanchor))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_create_mark(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj,new_opts,t_end};
  nsp_option opts[] = {
	{"left_gravity",s_bool,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  char *mark_name;
  int left_gravity = FALSE;
  NspObject *nsp_where, *nsp_ret;
  GtkTextIter *where = NULL;
  GtkTextMark *ret;

  if ( GetArgs(stack,rhs,opt,T,&mark_name, &nsp_where, opts, &left_gravity) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_where, GTK_TYPE_TEXT_ITER))
      where = nspg_boxed_get(nsp_where, GtkTextIter);
  else {
      Scierror( "where should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_buffer_create_mark(GTK_TEXT_BUFFER(self->obj), mark_name, where, left_gravity);
  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextmark))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_move_mark(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj,t_end};
  NspGObject *mark;
  NspObject *nsp_where;
  GtkTextIter *where = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark, &nsp_where) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_where, GTK_TYPE_TEXT_ITER))
      where = nspg_boxed_get(nsp_where, GtkTextIter);
  else {
      Scierror( "where should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_move_mark(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_MARK(mark->obj), where);
  return 0;
}

static int _wrap_gtk_text_buffer_delete_mark(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *mark;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark) == FAIL) return RET_BUG;
  gtk_text_buffer_delete_mark(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_MARK(mark->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_get_mark(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *name;
  NspObject *nsp_ret;
  GtkTextMark *ret;

  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
  ret = gtk_text_buffer_get_mark(GTK_TEXT_BUFFER(self->obj), name);
  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextmark))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_move_mark_by_name(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj,t_end};
  char *name;
  NspObject *nsp_where;
  GtkTextIter *where = NULL;

  if ( GetArgs(stack,rhs,opt,T,&name, &nsp_where) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_where, GTK_TYPE_TEXT_ITER))
      where = nspg_boxed_get(nsp_where, GtkTextIter);
  else {
      Scierror( "where should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_move_mark_by_name(GTK_TEXT_BUFFER(self->obj), name, where);
  return 0;
}

static int _wrap_gtk_text_buffer_delete_mark_by_name(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *name;

  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
  gtk_text_buffer_delete_mark_by_name(GTK_TEXT_BUFFER(self->obj), name);
  return 0;
}

static int _wrap_gtk_text_buffer_get_insert(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkTextMark *ret;

  ret = gtk_text_buffer_get_insert(GTK_TEXT_BUFFER(self->obj));
  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextmark))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_get_selection_bound(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkTextMark *ret;

  ret = gtk_text_buffer_get_selection_bound(GTK_TEXT_BUFFER(self->obj));
  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextmark))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_place_cursor(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_where;
  GtkTextIter *where = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_where) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_where, GTK_TYPE_TEXT_ITER))
      where = nspg_boxed_get(nsp_where, GtkTextIter);
  else {
      Scierror( "where should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_place_cursor(GTK_TEXT_BUFFER(self->obj), where);
  return 0;
}

static int _wrap_gtk_text_buffer_apply_tag(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj,t_end};
  NspGObject *tag;
  NspObject *nsp_start, *nsp_end;
  GtkTextIter *start = NULL, *end = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktexttag, &tag, &nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "start should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "end should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_apply_tag(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_TAG(tag->obj), start, end);
  return 0;
}

static int _wrap_gtk_text_buffer_remove_tag(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj,t_end};
  NspGObject *tag;
  NspObject *nsp_start, *nsp_end;
  GtkTextIter *start = NULL, *end = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktexttag, &tag, &nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "start should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "end should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_remove_tag(GTK_TEXT_BUFFER(self->obj), GTK_TEXT_TAG(tag->obj), start, end);
  return 0;
}

static int _wrap_gtk_text_buffer_apply_tag_by_name(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj, obj,t_end};
  char *name;
  NspObject *nsp_start, *nsp_end;
  GtkTextIter *start = NULL, *end = NULL;

  if ( GetArgs(stack,rhs,opt,T,&name, &nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "start should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "end should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_apply_tag_by_name(GTK_TEXT_BUFFER(self->obj), name, start, end);
  return 0;
}

static int _wrap_gtk_text_buffer_remove_tag_by_name(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj, obj,t_end};
  char *name;
  NspObject *nsp_start, *nsp_end;
  GtkTextIter *start = NULL, *end = NULL;

  if ( GetArgs(stack,rhs,opt,T,&name, &nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "start should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "end should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_remove_tag_by_name(GTK_TEXT_BUFFER(self->obj), name, start, end);
  return 0;
}

static int _wrap_gtk_text_buffer_remove_all_tags(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  NspObject *nsp_start, *nsp_end;
  GtkTextIter *start = NULL, *end = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "start should be a GtkTextIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "end should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_remove_all_tags(GTK_TEXT_BUFFER(self->obj), start, end);
  return 0;
}

#line 5514 "gtk.override"
static int
_wrap_gtk_text_buffer_create_tag(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int i;
  gchar *tag_name = NULL;
  GtkTextTag *tag;
  GtkTextTagTable *table;
  NspObject *ret;

  if ( rhs -opt != 1 ) 
    {
      Scierror("Expecting a tag name followed by optional named arguments\n");
      return RET_BUG;
    }

  if (( tag_name = GetString(stack,1))== NULL) return RET_BUG;
  table = GTK_TEXT_TAG_TABLE(GTK_TEXT_BUFFER(self->obj)->tag_table);
  if ( table && g_hash_table_lookup(table->hash, tag_name)) {
    Scierror("A tag named '%s' is already in the tag table", tag_name);
    return RET_BUG;
  }
  
  tag = gtk_text_buffer_create_tag(GTK_TEXT_BUFFER(self->obj), tag_name, NULL);

  for ( i = rhs -opt + 1; i <= rhs ; i++) 
    {
      /* set tag properties if any */
      NspObject *prop = NthObj(i) ;
      GParamSpec *pspec;
      GValue value = { 0, };
      gchar *prop_str =nsp_object_get_name(NthObj(i)); 
      
      pspec = g_object_class_find_property (G_OBJECT_GET_CLASS(tag),  prop_str);
      if (!pspec) {
	Scierror( "unsupported tag property `%s'", prop_str);
	/* XXX: Free tag? */
	return RET_BUG;
      }
      g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
      if (nspg_value_from_nspobject(&value, prop) < 0) {
	Scierror( "could not convert tag property '%s' to correct type",  prop_str);
	/* XXX: Free tag? */
	return RET_BUG;
      }
      g_object_set_property((GObject *)tag, prop_str, &value);
      g_value_unset(&value);
    }
  if ((ret = (NspObject *) gobject_create(NVOID,(GObject *)tag,(NspTypeBase *) nsp_type_gtktexttag))== NULL) 
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 13662 "gtk.c"


#line 5568 "gtk.override"
static int
_wrap_gtk_text_buffer_get_iter_at_line_offset(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "line_number", "char_offset", NULL };*/
  GtkTextIter iter;
  int line_number, char_offset;
  NspObject *ret;
  
  if (GetArgs(stack,rhs,opt,T, &line_number, &char_offset) == FAIL) return RET_BUG;;

  gtk_text_buffer_get_iter_at_line_offset(GTK_TEXT_BUFFER(self->obj), &iter, line_number, char_offset);
  if ((ret =(NspObject *)  gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 13682 "gtk.c"


#line 5586 "gtk.override"
static int
_wrap_gtk_text_buffer_get_iter_at_line_index(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "line_number", "byte_offset", NULL };*/
  GtkTextIter iter;
  int line_number, byte_offset;
  NspObject *ret;
  
  if (GetArgs(stack,rhs,opt,T,&line_number, &byte_offset)  == FAIL) return RET_BUG;;
  
  gtk_text_buffer_get_iter_at_line_index(GTK_TEXT_BUFFER(self->obj), &iter, line_number, byte_offset);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 13702 "gtk.c"


#line 5604 "gtk.override"
static int
_wrap_gtk_text_buffer_get_iter_at_offset(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int char_offset;
  int_types T[] = {s_int, t_end} ;
  GtkTextIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &char_offset) == FAIL) return RET_BUG;;
  gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),  &iter, char_offset);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) 
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 13721 "gtk.c"


#line 5621 "gtk.override"
static int
_wrap_gtk_text_buffer_get_iter_at_line(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int line_number;
  int_types T[] = {s_int, t_end} ;
  GtkTextIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &line_number) == FAIL) return RET_BUG;;
  gtk_text_buffer_get_iter_at_line(GTK_TEXT_BUFFER(self->obj), &iter, line_number);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 13739 "gtk.c"


#line 5637 "gtk.override"
static int
_wrap_gtk_text_buffer_get_start_iter(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextIter iter;
  NspObject *ret;
  gtk_text_buffer_get_start_iter(GTK_TEXT_BUFFER(self->obj), &iter);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 13753 "gtk.c"


#line 5649 "gtk.override"
static int
_wrap_gtk_text_buffer_get_end_iter(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextIter iter;
  NspObject *ret;
  gtk_text_buffer_get_end_iter(GTK_TEXT_BUFFER(self->obj), &iter);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 13767 "gtk.c"


#line 5661 "gtk.override"
static int
_wrap_gtk_text_buffer_get_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret1,*ret2; 
  GtkTextIter start, end;
  CheckRhs(1,1);
  CheckLhs(2,2);
  gtk_text_buffer_get_bounds(GTK_TEXT_BUFFER(self->obj), &start, &end);
  if ((ret1 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &start,TRUE, TRUE,nsp_type_gtktextiter))== NULL) 
    return RET_BUG; 
  MoveObj(stack,1,ret1);
  if ((ret2 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &end,TRUE, TRUE,nsp_type_gtktextiter))==NULL) 
    return RET_BUG; 
  MoveObj(stack,2,ret2);
  return 2;
}
#line 13787 "gtk.c"


#line 5679 "gtk.override"
static int
_wrap_gtk_text_buffer_get_iter_at_mark(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *mark;
  int_types T[] = {obj_check, t_end} ;
  GtkTextIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark) == FAIL) return RET_BUG;;
  gtk_text_buffer_get_iter_at_mark(GTK_TEXT_BUFFER(self->obj), &iter, GTK_TEXT_MARK(mark->obj));
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 13805 "gtk.c"


static int _wrap_gtk_text_buffer_get_iter_at_child_anchor(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj_check,t_end};
  NspGObject *anchor;
  NspObject *nsp_iter;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_type_gtktextchildanchor, &anchor) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  gtk_text_buffer_get_iter_at_child_anchor(GTK_TEXT_BUFFER(self->obj), iter, GTK_TEXT_CHILD_ANCHOR(anchor->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_get_modified(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_buffer_get_modified(GTK_TEXT_BUFFER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_set_modified(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_text_buffer_set_modified(GTK_TEXT_BUFFER(self->obj), setting);
  return 0;
}

#line 5706 "gtk.override"
static int
_wrap_gtk_text_buffer_get_selection_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret1,*ret2; 
  GtkTextIter start, end;
  CheckRhs(1,1);
  CheckLhs(2,2);
  if (!gtk_text_buffer_get_selection_bounds(GTK_TEXT_BUFFER(self->obj),&start, &end)) 
    return RET_BUG; 
  if ((ret1 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &start,TRUE, TRUE,nsp_type_gtktextiter))== NULL) 
    return RET_BUG; 
  MoveObj(stack,1,ret1);
  if ((ret2 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &end,TRUE, TRUE,nsp_type_gtktextiter))==NULL) 
    return RET_BUG; 
  MoveObj(stack,1,ret2);
  return 2;
}
#line 13863 "gtk.c"


static int _wrap_gtk_text_buffer_delete_selection(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, s_bool,t_end};
  int interactive, default_editable, ret;

  if ( GetArgs(stack,rhs,opt,T,&interactive, &default_editable) == FAIL) return RET_BUG;
  ret = gtk_text_buffer_delete_selection(GTK_TEXT_BUFFER(self->obj), interactive, default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_begin_user_action(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_text_buffer_begin_user_action(GTK_TEXT_BUFFER(self->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_end_user_action(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_text_buffer_end_user_action(GTK_TEXT_BUFFER(self->obj));
  return 0;
}

static NspMethods gtktextbuffer_methods[] = {
  {"get_line_count",(nsp_method *) _wrap_gtk_text_buffer_get_line_count},
  {"get_char_count",(nsp_method *) _wrap_gtk_text_buffer_get_char_count},
  {"get_tag_table",(nsp_method *) _wrap_gtk_text_buffer_get_tag_table},
  {"set_text",(nsp_method *) _wrap_gtk_text_buffer_set_text},
  {"insert",(nsp_method *) _wrap_gtk_text_buffer_insert},
  {"insert_at_cursor",(nsp_method *) _wrap_gtk_text_buffer_insert_at_cursor},
  {"insert_interactive",(nsp_method *) _wrap_gtk_text_buffer_insert_interactive},
  {"insert_interactive_at_cursor",(nsp_method *) _wrap_gtk_text_buffer_insert_interactive_at_cursor},
  {"insert_range",(nsp_method *) _wrap_gtk_text_buffer_insert_range},
  {"insert_range_interactive",(nsp_method *) _wrap_gtk_text_buffer_insert_range_interactive},
  {"insert_with_tags",(nsp_method *) _wrap_gtk_text_buffer_insert_with_tags},
  {"insert_with_tags_by_name",(nsp_method *) _wrap_gtk_text_buffer_insert_with_tags_by_name},
  {"delete",(nsp_method *) _wrap_gtk_text_buffer_delete},
  {"delete_interactive",(nsp_method *) _wrap_gtk_text_buffer_delete_interactive},
  {"get_text",(nsp_method *) _wrap_gtk_text_buffer_get_text},
  {"get_slice",(nsp_method *) _wrap_gtk_text_buffer_get_slice},
  {"insert_pixbuf",(nsp_method *) _wrap_gtk_text_buffer_insert_pixbuf},
  {"insert_child_anchor",(nsp_method *) _wrap_gtk_text_buffer_insert_child_anchor},
  {"create_child_anchor",(nsp_method *) _wrap_gtk_text_buffer_create_child_anchor},
  {"create_mark",(nsp_method *) _wrap_gtk_text_buffer_create_mark},
  {"move_mark",(nsp_method *) _wrap_gtk_text_buffer_move_mark},
  {"delete_mark",(nsp_method *) _wrap_gtk_text_buffer_delete_mark},
  {"get_mark",(nsp_method *) _wrap_gtk_text_buffer_get_mark},
  {"move_mark_by_name",(nsp_method *) _wrap_gtk_text_buffer_move_mark_by_name},
  {"delete_mark_by_name",(nsp_method *) _wrap_gtk_text_buffer_delete_mark_by_name},
  {"get_insert",(nsp_method *) _wrap_gtk_text_buffer_get_insert},
  {"get_selection_bound",(nsp_method *) _wrap_gtk_text_buffer_get_selection_bound},
  {"place_cursor",(nsp_method *) _wrap_gtk_text_buffer_place_cursor},
  {"apply_tag",(nsp_method *) _wrap_gtk_text_buffer_apply_tag},
  {"remove_tag",(nsp_method *) _wrap_gtk_text_buffer_remove_tag},
  {"apply_tag_by_name",(nsp_method *) _wrap_gtk_text_buffer_apply_tag_by_name},
  {"remove_tag_by_name",(nsp_method *) _wrap_gtk_text_buffer_remove_tag_by_name},
  {"remove_all_tags",(nsp_method *) _wrap_gtk_text_buffer_remove_all_tags},
  {"create_tag",(nsp_method *) _wrap_gtk_text_buffer_create_tag},
  {"get_iter_at_line_offset",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_line_offset},
  {"get_iter_at_line_index",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_line_index},
  {"get_iter_at_offset",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_offset},
  {"get_iter_at_line",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_line},
  {"get_start_iter",(nsp_method *) _wrap_gtk_text_buffer_get_start_iter},
  {"get_end_iter",(nsp_method *) _wrap_gtk_text_buffer_get_end_iter},
  {"get_bounds",(nsp_method *) _wrap_gtk_text_buffer_get_bounds},
  {"get_iter_at_mark",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_mark},
  {"get_iter_at_child_anchor",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_child_anchor},
  {"get_modified",(nsp_method *) _wrap_gtk_text_buffer_get_modified},
  {"set_modified",(nsp_method *) _wrap_gtk_text_buffer_set_modified},
  {"get_selection_bounds",(nsp_method *) _wrap_gtk_text_buffer_get_selection_bounds},
  {"delete_selection",(nsp_method *) _wrap_gtk_text_buffer_delete_selection},
  {"begin_user_action",(nsp_method *) _wrap_gtk_text_buffer_begin_user_action},
  {"end_user_action",(nsp_method *) _wrap_gtk_text_buffer_end_user_action},
  { NULL, NULL}
};

static NspMethods *gtktextbuffer_get_methods(void) { return gtktextbuffer_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_text_buffer__get_tag_table(NspObject *self,char *attr)
{
  GtkTextTagTable *ret;

  ret = (GtkTextTagTable*) GTK_TEXT_BUFFER(NSP_GOBJECT_GET(self))->tag_table;
  nsp_type_gtktexttagtable = new_type_gtktexttagtable(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktexttagtable);
}

static AttrTab gtktextbuffer_attrs[] = {
  { "tag_table", (attr_get_function *)_wrap_gtk_text_buffer__get_tag_table, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkTextChildAnchor ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTextChildAnchor_Private 
#include "nsp/gtk/gtktextchildanchor.h"
#include "nsp/interf.h"

/* NspGtkTextChildAnchor inherits from NspGObject */ 

int nsp_type_gtktextchildanchor_id=0;
NspTypeGtkTextChildAnchor *nsp_type_gtktextchildanchor=NULL;

NspTypeGtkTextChildAnchor *new_type_gtktextchildanchor(type_mode mode)
{
  NspTypeGtkTextChildAnchor *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextchildanchor != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextchildanchor;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextchildanchor_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktextchildanchor_get_methods; 
  type->new = (new_func *) new_gtktextchildanchor;

  /* specific methods for gtktextchildanchor */
      
  type->init = (init_func *) init_gtktextchildanchor;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktextchildanchor */ 

  top->s_type =  (s_type_func *) gtktextchildanchor_type_as_string;    
  top->sh_type = (sh_type_func *) gtktextchildanchor_type_short_string;
  /* top->create = (create_func*) int_gtktextchildanchor_create;*/ 
  
  /* specific methods for gtktextchildanchor */
      
  type->init = (init_func *) init_gtktextchildanchor;

  if ( nsp_type_gtktextchildanchor_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextChildAnchor called nsp_type_gtktextchildanchor
       */
      type->id =  nsp_type_gtktextchildanchor_id = nsp_new_type_id();
      nsp_type_gtktextchildanchor = type;
      if ( nsp_register_type(nsp_type_gtktextchildanchor) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextchildanchor, GTK_TYPE_TEXT_CHILD_ANCHOR);
      return ( mode == T_BASE ) ? type : new_type_gtktextchildanchor(mode);
    }
  else 
    {
       type->id = nsp_type_gtktextchildanchor_id;
       return type;
    }
}

/*
 * initialize GtkTextChildAnchor instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextchildanchor(NspGtkTextChildAnchor *o,NspTypeGtkTextChildAnchor *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTextChildAnchor 
 */

NspGtkTextChildAnchor *new_gtktextchildanchor() 
{
  NspGtkTextChildAnchor *loc; 
  /* type must exists */
  nsp_type_gtktextchildanchor = new_type_gtktextchildanchor(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextChildAnchor)))== NULLGTKTEXTCHILDANCHOR) return loc;
  /* initialize object */
  if ( init_gtktextchildanchor(loc,nsp_type_gtktextchildanchor) == FAIL) return NULLGTKTEXTCHILDANCHOR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTextChildAnchor 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktextchildanchor_type_name[]="GtkTextChildAnchor";
static char gtktextchildanchor_short_type_name[]="GtkTextChildAnchor";

static char *gtktextchildanchor_type_as_string(void)
{
  return(gtktextchildanchor_type_name);
}

static char *gtktextchildanchor_type_short_string(void)
{
  return(gtktextchildanchor_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTextChildAnchor objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTextChildAnchor   *gtktextchildanchor_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktextchildanchor_id) ) return ((NspGtkTextChildAnchor *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextchildanchor));
  return NULL;
}

int IsGtkTextChildAnchorObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktextchildanchor_id);
}

int IsGtkTextChildAnchor(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextchildanchor_id);
}

NspGtkTextChildAnchor  *GetGtkTextChildAnchorCopy(Stack stack, int i)
{
  if (  GetGtkTextChildAnchor(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextChildAnchor  *GetGtkTextChildAnchor(Stack stack, int i)
{
  NspGtkTextChildAnchor *M;
  if (( M = gtktextchildanchor_object(NthObj(i))) == NULLGTKTEXTCHILDANCHOR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextChildAnchor *gtktextchildanchor_copy(NspGtkTextChildAnchor *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextchildanchor);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextchildanchor);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextChildAnchor
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTextChildAnchor *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktextchildanchor is initialized * /
  nsp_type_gtktextchildanchor = new_type_gtktextchildanchor(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtktextchildanchor)) == NULLGTKTEXTCHILDANCHOR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtktextchildanchor_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_text_child_anchor_new())== NULL) return RET_BUG;

  nsp_type_gtktextchildanchor = new_type_gtktextchildanchor(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktextchildanchor );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 5784 "gtk.override"
static int
_wrap_gtk_text_child_anchor_get_widgets(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  Cell *cloc = NULLCELL,*cloc1=NULLCELL; 
  list = gtk_text_child_anchor_get_widgets(GTK_TEXT_CHILD_ANCHOR(self->obj));
  NSP_LIST_FROM_GLIST(gobject_gettype_and_create("lel",(GObject *)tmp->data),g_list_free);
}
#line 14180 "gtk.c"


static int _wrap_gtk_text_child_anchor_get_deleted(NspGtkTextChildAnchor *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_child_anchor_get_deleted(GTK_TEXT_CHILD_ANCHOR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktextchildanchor_methods[] = {
  {"get_widgets",(nsp_method *) _wrap_gtk_text_child_anchor_get_widgets},
  {"get_deleted",(nsp_method *) _wrap_gtk_text_child_anchor_get_deleted},
  { NULL, NULL}
};

static NspMethods *gtktextchildanchor_get_methods(void) { return gtktextchildanchor_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktextchildanchor_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTextMark ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTextMark_Private 
#include "nsp/gtk/gtktextmark.h"
#include "nsp/interf.h"

/* NspGtkTextMark inherits from NspGObject */ 

int nsp_type_gtktextmark_id=0;
NspTypeGtkTextMark *nsp_type_gtktextmark=NULL;

NspTypeGtkTextMark *new_type_gtktextmark(type_mode mode)
{
  NspTypeGtkTextMark *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextmark != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextmark;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextmark_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktextmark_get_methods; 
  type->new = (new_func *) new_gtktextmark;

  /* specific methods for gtktextmark */
      
  type->init = (init_func *) init_gtktextmark;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktextmark */ 

  top->s_type =  (s_type_func *) gtktextmark_type_as_string;    
  top->sh_type = (sh_type_func *) gtktextmark_type_short_string;
  /* top->create = (create_func*) int_gtktextmark_create;*/ 
  
  /* specific methods for gtktextmark */
      
  type->init = (init_func *) init_gtktextmark;

  if ( nsp_type_gtktextmark_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextMark called nsp_type_gtktextmark
       */
      type->id =  nsp_type_gtktextmark_id = nsp_new_type_id();
      nsp_type_gtktextmark = type;
      if ( nsp_register_type(nsp_type_gtktextmark) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextmark, GTK_TYPE_TEXT_MARK);
      return ( mode == T_BASE ) ? type : new_type_gtktextmark(mode);
    }
  else 
    {
       type->id = nsp_type_gtktextmark_id;
       return type;
    }
}

/*
 * initialize GtkTextMark instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextmark(NspGtkTextMark *o,NspTypeGtkTextMark *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTextMark 
 */

NspGtkTextMark *new_gtktextmark() 
{
  NspGtkTextMark *loc; 
  /* type must exists */
  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextMark)))== NULLGTKTEXTMARK) return loc;
  /* initialize object */
  if ( init_gtktextmark(loc,nsp_type_gtktextmark) == FAIL) return NULLGTKTEXTMARK;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTextMark 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktextmark_type_name[]="GtkTextMark";
static char gtktextmark_short_type_name[]="GtkTextMark";

static char *gtktextmark_type_as_string(void)
{
  return(gtktextmark_type_name);
}

static char *gtktextmark_type_short_string(void)
{
  return(gtktextmark_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTextMark objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTextMark   *gtktextmark_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktextmark_id) ) return ((NspGtkTextMark *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextmark));
  return NULL;
}

int IsGtkTextMarkObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktextmark_id);
}

int IsGtkTextMark(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextmark_id);
}

NspGtkTextMark  *GetGtkTextMarkCopy(Stack stack, int i)
{
  if (  GetGtkTextMark(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextMark  *GetGtkTextMark(Stack stack, int i)
{
  NspGtkTextMark *M;
  if (( M = gtktextmark_object(NthObj(i))) == NULLGTKTEXTMARK)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextMark *gtktextmark_copy(NspGtkTextMark *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextmark);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextmark);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextMark
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTextMark *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktextmark is initialized * /
  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtktextmark)) == NULLGTKTEXTMARK) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_text_mark_set_visible(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_text_mark_set_visible(GTK_TEXT_MARK(self->obj), setting);
  return 0;
}

static int _wrap_gtk_text_mark_get_visible(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_mark_get_visible(GTK_TEXT_MARK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_mark_get_name(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_text_mark_get_name(GTK_TEXT_MARK(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_mark_get_deleted(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_mark_get_deleted(GTK_TEXT_MARK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_mark_get_buffer(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextBuffer *ret;
  NspObject *nsp_ret;

  ret = gtk_text_mark_get_buffer(GTK_TEXT_MARK(self->obj));
  nsp_type_gtktextbuffer = new_type_gtktextbuffer(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextbuffer))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_mark_get_left_gravity(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_mark_get_left_gravity(GTK_TEXT_MARK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktextmark_methods[] = {
  {"set_visible",(nsp_method *) _wrap_gtk_text_mark_set_visible},
  {"get_visible",(nsp_method *) _wrap_gtk_text_mark_get_visible},
  {"get_name",(nsp_method *) _wrap_gtk_text_mark_get_name},
  {"get_deleted",(nsp_method *) _wrap_gtk_text_mark_get_deleted},
  {"get_buffer",(nsp_method *) _wrap_gtk_text_mark_get_buffer},
  {"get_left_gravity",(nsp_method *) _wrap_gtk_text_mark_get_left_gravity},
  { NULL, NULL}
};

static NspMethods *gtktextmark_get_methods(void) { return gtktextmark_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktextmark_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTextTag ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTextTag_Private 
#include "nsp/gtk/gtktexttag.h"
#include "nsp/interf.h"

/* NspGtkTextTag inherits from NspGObject */ 

int nsp_type_gtktexttag_id=0;
NspTypeGtkTextTag *nsp_type_gtktexttag=NULL;

NspTypeGtkTextTag *new_type_gtktexttag(type_mode mode)
{
  NspTypeGtkTextTag *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktexttag != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktexttag;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktexttag_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktexttag_get_methods; 
  type->new = (new_func *) new_gtktexttag;

  /* specific methods for gtktexttag */
      
  type->init = (init_func *) init_gtktexttag;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktexttag */ 

  top->s_type =  (s_type_func *) gtktexttag_type_as_string;    
  top->sh_type = (sh_type_func *) gtktexttag_type_short_string;
  /* top->create = (create_func*) int_gtktexttag_create;*/ 
  
  /* specific methods for gtktexttag */
      
  type->init = (init_func *) init_gtktexttag;

  if ( nsp_type_gtktexttag_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextTag called nsp_type_gtktexttag
       */
      type->id =  nsp_type_gtktexttag_id = nsp_new_type_id();
      nsp_type_gtktexttag = type;
      if ( nsp_register_type(nsp_type_gtktexttag) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktexttag, GTK_TYPE_TEXT_TAG);
      return ( mode == T_BASE ) ? type : new_type_gtktexttag(mode);
    }
  else 
    {
       type->id = nsp_type_gtktexttag_id;
       return type;
    }
}

/*
 * initialize GtkTextTag instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktexttag(NspGtkTextTag *o,NspTypeGtkTextTag *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTextTag 
 */

NspGtkTextTag *new_gtktexttag() 
{
  NspGtkTextTag *loc; 
  /* type must exists */
  nsp_type_gtktexttag = new_type_gtktexttag(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextTag)))== NULLGTKTEXTTAG) return loc;
  /* initialize object */
  if ( init_gtktexttag(loc,nsp_type_gtktexttag) == FAIL) return NULLGTKTEXTTAG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTextTag 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktexttag_type_name[]="GtkTextTag";
static char gtktexttag_short_type_name[]="GtkTextTag";

static char *gtktexttag_type_as_string(void)
{
  return(gtktexttag_type_name);
}

static char *gtktexttag_type_short_string(void)
{
  return(gtktexttag_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTextTag objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTextTag   *gtktexttag_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktexttag_id) ) return ((NspGtkTextTag *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktexttag));
  return NULL;
}

int IsGtkTextTagObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktexttag_id);
}

int IsGtkTextTag(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktexttag_id);
}

NspGtkTextTag  *GetGtkTextTagCopy(Stack stack, int i)
{
  if (  GetGtkTextTag(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextTag  *GetGtkTextTag(Stack stack, int i)
{
  NspGtkTextTag *M;
  if (( M = gtktexttag_object(NthObj(i))) == NULLGTKTEXTTAG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextTag *gtktexttag_copy(NspGtkTextTag *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktexttag);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktexttag);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextTag
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTextTag *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktexttag is initialized * /
  nsp_type_gtktexttag = new_type_gtktexttag(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtktexttag)) == NULLGTKTEXTTAG) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtktexttag_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"name",string,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  char *name = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &name) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_text_tag_new(name))== NULL) return RET_BUG;

  nsp_type_gtktexttag = new_type_gtktexttag(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktexttag );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_tag_get_priority(NspGtkTextTag *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_tag_get_priority(GTK_TEXT_TAG(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_tag_set_priority(NspGtkTextTag *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int priority;

  if ( GetArgs(stack,rhs,opt,T,&priority) == FAIL) return RET_BUG;
  gtk_text_tag_set_priority(GTK_TEXT_TAG(self->obj), priority);
  return 0;
}

static int _wrap_gtk_text_tag_event(NspGtkTextTag *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, obj,t_end};
  GdkEvent *event = NULL;
  NspGObject *event_object;
  int ret;
  NspObject *nsp_event, *nsp_iter;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gobject, &event_object, &nsp_event, &nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "event should be a GdkEvent");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_tag_event(GTK_TEXT_TAG(self->obj), G_OBJECT(event_object->obj), event, iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktexttag_methods[] = {
  {"get_priority",(nsp_method *) _wrap_gtk_text_tag_get_priority},
  {"set_priority",(nsp_method *) _wrap_gtk_text_tag_set_priority},
  {"event",(nsp_method *) _wrap_gtk_text_tag_event},
  { NULL, NULL}
};

static NspMethods *gtktexttag_get_methods(void) { return gtktexttag_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktexttag_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTextTagTable ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTextTagTable_Private 
#include "nsp/gtk/gtktexttagtable.h"
#include "nsp/interf.h"

/* NspGtkTextTagTable inherits from NspGObject */ 

int nsp_type_gtktexttagtable_id=0;
NspTypeGtkTextTagTable *nsp_type_gtktexttagtable=NULL;

NspTypeGtkTextTagTable *new_type_gtktexttagtable(type_mode mode)
{
  NspTypeGtkTextTagTable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktexttagtable != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktexttagtable;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktexttagtable_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktexttagtable_get_methods; 
  type->new = (new_func *) new_gtktexttagtable;

  /* specific methods for gtktexttagtable */
      
  type->init = (init_func *) init_gtktexttagtable;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktexttagtable */ 

  top->s_type =  (s_type_func *) gtktexttagtable_type_as_string;    
  top->sh_type = (sh_type_func *) gtktexttagtable_type_short_string;
  /* top->create = (create_func*) int_gtktexttagtable_create;*/ 
  
  /* specific methods for gtktexttagtable */
      
  type->init = (init_func *) init_gtktexttagtable;

  if ( nsp_type_gtktexttagtable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextTagTable called nsp_type_gtktexttagtable
       */
      type->id =  nsp_type_gtktexttagtable_id = nsp_new_type_id();
      nsp_type_gtktexttagtable = type;
      if ( nsp_register_type(nsp_type_gtktexttagtable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktexttagtable, GTK_TYPE_TEXT_TAG_TABLE);
      return ( mode == T_BASE ) ? type : new_type_gtktexttagtable(mode);
    }
  else 
    {
       type->id = nsp_type_gtktexttagtable_id;
       return type;
    }
}

/*
 * initialize GtkTextTagTable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktexttagtable(NspGtkTextTagTable *o,NspTypeGtkTextTagTable *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTextTagTable 
 */

NspGtkTextTagTable *new_gtktexttagtable() 
{
  NspGtkTextTagTable *loc; 
  /* type must exists */
  nsp_type_gtktexttagtable = new_type_gtktexttagtable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextTagTable)))== NULLGTKTEXTTAGTABLE) return loc;
  /* initialize object */
  if ( init_gtktexttagtable(loc,nsp_type_gtktexttagtable) == FAIL) return NULLGTKTEXTTAGTABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTextTagTable 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktexttagtable_type_name[]="GtkTextTagTable";
static char gtktexttagtable_short_type_name[]="GtkTextTagTable";

static char *gtktexttagtable_type_as_string(void)
{
  return(gtktexttagtable_type_name);
}

static char *gtktexttagtable_type_short_string(void)
{
  return(gtktexttagtable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTextTagTable objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTextTagTable   *gtktexttagtable_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktexttagtable_id) ) return ((NspGtkTextTagTable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktexttagtable));
  return NULL;
}

int IsGtkTextTagTableObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktexttagtable_id);
}

int IsGtkTextTagTable(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktexttagtable_id);
}

NspGtkTextTagTable  *GetGtkTextTagTableCopy(Stack stack, int i)
{
  if (  GetGtkTextTagTable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextTagTable  *GetGtkTextTagTable(Stack stack, int i)
{
  NspGtkTextTagTable *M;
  if (( M = gtktexttagtable_object(NthObj(i))) == NULLGTKTEXTTAGTABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextTagTable *gtktexttagtable_copy(NspGtkTextTagTable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktexttagtable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktexttagtable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextTagTable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTextTagTable *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktexttagtable is initialized * /
  nsp_type_gtktexttagtable = new_type_gtktexttagtable(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtktexttagtable)) == NULLGTKTEXTTAGTABLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtktexttagtable_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_text_tag_table_new())== NULL) return RET_BUG;

  nsp_type_gtktexttagtable = new_type_gtktexttagtable(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktexttagtable );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_tag_table_add(NspGtkTextTagTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *tag;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktexttag, &tag) == FAIL) return RET_BUG;
  gtk_text_tag_table_add(GTK_TEXT_TAG_TABLE(self->obj), GTK_TEXT_TAG(tag->obj));
  return 0;
}

static int _wrap_gtk_text_tag_table_remove(NspGtkTextTagTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *tag;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktexttag, &tag) == FAIL) return RET_BUG;
  gtk_text_tag_table_remove(GTK_TEXT_TAG_TABLE(self->obj), GTK_TEXT_TAG(tag->obj));
  return 0;
}

static int _wrap_gtk_text_tag_table_lookup(NspGtkTextTagTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *name;
  NspObject *nsp_ret;
  GtkTextTag *ret;

  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
  ret = gtk_text_tag_table_lookup(GTK_TEXT_TAG_TABLE(self->obj), name);
  nsp_type_gtktexttag = new_type_gtktexttag(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktexttag))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_tag_table_get_size(NspGtkTextTagTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_tag_table_get_size(GTK_TEXT_TAG_TABLE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktexttagtable_methods[] = {
  {"add",(nsp_method *) _wrap_gtk_text_tag_table_add},
  {"remove",(nsp_method *) _wrap_gtk_text_tag_table_remove},
  {"lookup",(nsp_method *) _wrap_gtk_text_tag_table_lookup},
  {"get_size",(nsp_method *) _wrap_gtk_text_tag_table_get_size},
  { NULL, NULL}
};

static NspMethods *gtktexttagtable_get_methods(void) { return gtktexttagtable_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktexttagtable_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTooltips ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTooltips_Private 
#include "nsp/gtk/gtktooltips.h"
#include "nsp/interf.h"

/* NspGtkTooltips inherits from NspGtkObject */ 

int nsp_type_gtktooltips_id=0;
NspTypeGtkTooltips *nsp_type_gtktooltips=NULL;

NspTypeGtkTooltips *new_type_gtktooltips(type_mode mode)
{
  NspTypeGtkTooltips *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktooltips != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktooltips;
    }
  if ((type =  malloc(sizeof(NspTypeGtkObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktooltips_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktooltips_get_methods; 
  type->new = (new_func *) new_gtktooltips;

  /* specific methods for gtktooltips */
      
  type->init = (init_func *) init_gtktooltips;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktooltips */ 

  top->s_type =  (s_type_func *) gtktooltips_type_as_string;    
  top->sh_type = (sh_type_func *) gtktooltips_type_short_string;
  /* top->create = (create_func*) int_gtktooltips_create;*/ 
  
  /* specific methods for gtktooltips */
      
  type->init = (init_func *) init_gtktooltips;

  if ( nsp_type_gtktooltips_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTooltips called nsp_type_gtktooltips
       */
      type->id =  nsp_type_gtktooltips_id = nsp_new_type_id();
      nsp_type_gtktooltips = type;
      if ( nsp_register_type(nsp_type_gtktooltips) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktooltips, GTK_TYPE_TOOLTIPS);
      return ( mode == T_BASE ) ? type : new_type_gtktooltips(mode);
    }
  else 
    {
       type->id = nsp_type_gtktooltips_id;
       return type;
    }
}

/*
 * initialize GtkTooltips instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktooltips(NspGtkTooltips *o,NspTypeGtkTooltips *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTooltips 
 */

NspGtkTooltips *new_gtktooltips() 
{
  NspGtkTooltips *loc; 
  /* type must exists */
  nsp_type_gtktooltips = new_type_gtktooltips(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTooltips)))== NULLGTKTOOLTIPS) return loc;
  /* initialize object */
  if ( init_gtktooltips(loc,nsp_type_gtktooltips) == FAIL) return NULLGTKTOOLTIPS;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTooltips 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktooltips_type_name[]="GtkTooltips";
static char gtktooltips_short_type_name[]="GtkTooltips";

static char *gtktooltips_type_as_string(void)
{
  return(gtktooltips_type_name);
}

static char *gtktooltips_type_short_string(void)
{
  return(gtktooltips_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTooltips objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTooltips   *gtktooltips_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktooltips_id) ) return ((NspGtkTooltips *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktooltips));
  return NULL;
}

int IsGtkTooltipsObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktooltips_id);
}

int IsGtkTooltips(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktooltips_id);
}

NspGtkTooltips  *GetGtkTooltipsCopy(Stack stack, int i)
{
  if (  GetGtkTooltips(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTooltips  *GetGtkTooltips(Stack stack, int i)
{
  NspGtkTooltips *M;
  if (( M = gtktooltips_object(NthObj(i))) == NULLGTKTOOLTIPS)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTooltips *gtktooltips_copy(NspGtkTooltips *self)
{
  /* return gtkobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktooltips);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktooltips);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTooltips
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTooltips *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktooltips is initialized * /
  nsp_type_gtktooltips = new_type_gtktooltips(T_BASE);
  if(( H = gtkobject_create(NVOID,(NspTypeBase *) nsp_type_gtktooltips)) == NULLGTKTOOLTIPS) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtktooltips_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_tooltips_new())== NULL) return RET_BUG;

  nsp_type_gtktooltips = new_type_gtktooltips(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktooltips );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tooltips_enable(NspGtkTooltips *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tooltips_enable(GTK_TOOLTIPS(self->obj));
  return 0;
}

static int _wrap_gtk_tooltips_disable(NspGtkTooltips *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tooltips_disable(GTK_TOOLTIPS(self->obj));
  return 0;
}

static int _wrap_gtk_tooltips_set_delay(NspGtkTooltips *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int delay;

  if ( GetArgs(stack,rhs,opt,T,&delay) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_tooltips_set_delay(GTK_TOOLTIPS(self->obj), delay);
  return 0;
}

static int _wrap_gtk_tooltips_set_tip(NspGtkTooltips *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, string,new_opts,t_end};
  nsp_option opts[] = {
	{"tip_private",string,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  char *tip_text, *tip_private = NULL;
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &tip_text, opts, &tip_private) == FAIL) return RET_BUG;
  gtk_tooltips_set_tip(GTK_TOOLTIPS(self->obj), GTK_WIDGET(widget->obj), tip_text, tip_private);
  return 0;
}

static int _wrap_gtk_tooltips_force_window(NspGtkTooltips *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tooltips_force_window(GTK_TOOLTIPS(self->obj));
  return 0;
}

static NspMethods gtktooltips_methods[] = {
  {"enable",(nsp_method *) _wrap_gtk_tooltips_enable},
  {"disable",(nsp_method *) _wrap_gtk_tooltips_disable},
  {"set_delay",(nsp_method *) _wrap_gtk_tooltips_set_delay},
  {"set_tip",(nsp_method *) _wrap_gtk_tooltips_set_tip},
  {"force_window",(nsp_method *) _wrap_gtk_tooltips_force_window},
  { NULL, NULL}
};

static NspMethods *gtktooltips_get_methods(void) { return gtktooltips_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_tooltips__get_tip_window(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_TOOLTIPS(NSP_GOBJECT_GET(self))->tip_window;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_tooltips__get_tip_label(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_TOOLTIPS(NSP_GOBJECT_GET(self))->tip_label;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

#line 6292 "gtk.override"
static NspObject *
_wrap_gtk_tooltips__get_active_tips_data(NspGObject *self, char *attr)
{
  int_types T[] = {obj,obj,string,string, t_end} ;
  GtkTooltips *tips = GTK_TOOLTIPS(self->obj);
  GtkTooltipsData *data = tips->active_tips_data;
  if (data == NULL) return NULL;
  return (NspObject *)BuildListFromArgs(T, nspgobject_new((GObject *)data->tooltips),
			   nspgobject_new((GObject *)data->widget),
			   data->tip_text, data->tip_private);
}
#line 15310 "gtk.c"
#line 6305 "gtk.override"
static NspObject *
_wrap_gtk_tooltips__get_tips_data_list(NspGObject *self, char *attr)
{
  /* 
  GList *list = GTK_TOOLTIPS(self->obj)->tips_data_list;
  gint         i, length;
  NspObject    *pylist;
  GList *iter;

  length = g_list_length(list);
  pylist = NspList_New(length);

  i = 0;
  for (iter = list; iter; iter = iter->next) {
    GtkTooltipsData *data = (GtkTooltipsData*)iter->data;
    NspObject *item = Nsp_BuildValue("OOss",
				     nspgobject_new((GObject *)data->tooltips),
				     nspgobject_new((GObject *)data->widget),
				     data->tip_text,
				     data->tip_private);
    NspList_SetItem(pylist, i, item);
    Nsp_INCREF(item);
  }
  return pylist;
  */ 
  Scierror("XXXX To be done gtk_tooltips__get_tips_data_list");
  return 0;
}
#line 15340 "gtk.c"
static NspObject *_wrap_gtk_tooltips__get_delay(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_TOOLTIPS(NSP_GOBJECT_GET(self))->delay;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_tooltips__get_enabled(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_TOOLTIPS(NSP_GOBJECT_GET(self))->enabled;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_tooltips__get_use_sticky_delay(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_TOOLTIPS(NSP_GOBJECT_GET(self))->use_sticky_delay;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_tooltips__get_timer_tag(NspObject *self,char *attr)
{
  int ret;

  ret = (gint) GTK_TOOLTIPS(NSP_GOBJECT_GET(self))->timer_tag;
  return nsp_new_double_obj((double) ret);
}

static AttrTab gtktooltips_attrs[] = {
  { "tip_window", (attr_get_function *)_wrap_gtk_tooltips__get_tip_window, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "tip_label", (attr_get_function *)_wrap_gtk_tooltips__get_tip_label, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "active_tips_data", (attr_get_function *)_wrap_gtk_tooltips__get_active_tips_data, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "tips_data_list", (attr_get_function *)_wrap_gtk_tooltips__get_tips_data_list, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "delay", (attr_get_function *)_wrap_gtk_tooltips__get_delay, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "enabled", (attr_get_function *)_wrap_gtk_tooltips__get_enabled, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "use_sticky_delay", (attr_get_function *)_wrap_gtk_tooltips__get_use_sticky_delay, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "timer_tag", (attr_get_function *)_wrap_gtk_tooltips__get_timer_tag, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkListStore ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkListStore_Private 
#include "nsp/gtk/gtkliststore.h"
#include "nsp/interf.h"

/* NspGtkListStore inherits from NspGObject */ 

int nsp_type_gtkliststore_id=0;
NspTypeGtkListStore *nsp_type_gtkliststore=NULL;

NspTypeGtkListStore *new_type_gtkliststore(type_mode mode)
{
  NspTypeGtkListStore *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkliststore != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkliststore;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkliststore_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkliststore_get_methods; 
  type->new = (new_func *) new_gtkliststore;

  /* specific methods for gtkliststore */
      
  type->init = (init_func *) init_gtkliststore;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkliststore */ 

  top->s_type =  (s_type_func *) gtkliststore_type_as_string;    
  top->sh_type = (sh_type_func *) gtkliststore_type_short_string;
  /* top->create = (create_func*) int_gtkliststore_create;*/ 
  
  /* specific methods for gtkliststore */
      
  type->init = (init_func *) init_gtkliststore;

  type->interface =  (NspTypeBase *) new_type_gtktreemodel(T_DERIVED);
  type->interface->interface =  (NspTypeBase *) new_type_gtktreedragsource(T_DERIVED);
  type->interface->interface->interface =  (NspTypeBase *) new_type_gtktreedragdest(T_DERIVED);
  type->interface->interface->interface->interface =  (NspTypeBase *) new_type_gtktreesortable(T_DERIVED);
  if ( nsp_type_gtkliststore_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkListStore called nsp_type_gtkliststore
       */
      type->id =  nsp_type_gtkliststore_id = nsp_new_type_id();
      nsp_type_gtkliststore = type;
      if ( nsp_register_type(nsp_type_gtkliststore) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkliststore, GTK_TYPE_LIST_STORE);
      return ( mode == T_BASE ) ? type : new_type_gtkliststore(mode);
    }
  else 
    {
       type->id = nsp_type_gtkliststore_id;
       return type;
    }
}

/*
 * initialize GtkListStore instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkliststore(NspGtkListStore *o,NspTypeGtkListStore *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkListStore 
 */

NspGtkListStore *new_gtkliststore() 
{
  NspGtkListStore *loc; 
  /* type must exists */
  nsp_type_gtkliststore = new_type_gtkliststore(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkListStore)))== NULLGTKLISTSTORE) return loc;
  /* initialize object */
  if ( init_gtkliststore(loc,nsp_type_gtkliststore) == FAIL) return NULLGTKLISTSTORE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkListStore 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkliststore_type_name[]="GtkListStore";
static char gtkliststore_short_type_name[]="GtkListStore";

static char *gtkliststore_type_as_string(void)
{
  return(gtkliststore_type_name);
}

static char *gtkliststore_type_short_string(void)
{
  return(gtkliststore_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkListStore objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkListStore   *gtkliststore_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkliststore_id) ) return ((NspGtkListStore *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkliststore));
  return NULL;
}

int IsGtkListStoreObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkliststore_id);
}

int IsGtkListStore(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkliststore_id);
}

NspGtkListStore  *GetGtkListStoreCopy(Stack stack, int i)
{
  if (  GetGtkListStore(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkListStore  *GetGtkListStore(Stack stack, int i)
{
  NspGtkListStore *M;
  if (( M = gtkliststore_object(NthObj(i))) == NULLGTKLISTSTORE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkListStore *gtkliststore_copy(NspGtkListStore *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkliststore);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkliststore);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkListStore
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkListStore *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkliststore is initialized * /
  nsp_type_gtkliststore = new_type_gtkliststore(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtkliststore)) == NULLGTKLISTSTORE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 1845 "gtk.override"

static int
_wrap_gtkliststore_new(Stack stack,int rhs,int opt,int lhs)
{
  int flag = TRUE;
  NspObject *ret;
  GObject *gobj;
  CheckRhs(1,2); 
  if ( opt != 0 ) {
    Scierror("GtkListStore do not accept optional named arguments");
    return RET_BUG;
  }

  if (rhs == 2) 
    {
      if ( GetScalarBool(stack,2,&flag) == FAIL) { return FAIL;}
    }

  if ( IsMatObj(stack,1)) 
    {
      /* building a liststore from a Matrix */
      NspMatrix *M;
      if ((M = GetRealMat(stack,1)) == NULLMAT) return RET_BUG;
      /* we build a list store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_list_store_from_mat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsSMatObj(stack,1)) 
    {
      /* building a liststore from a string matrix  */
      NspSMatrix *M;
      if ((M = GetSMat(stack,1)) == NULLSMAT) return RET_BUG;
      /* we build a list store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_list_store_from_smat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsBMatObj(stack,1)) 
    {
      /* building a liststore from a boolean matrix  */
      NspBMatrix *M;
      if ((M = GetBMat(stack,1)) == NULLBMAT) return RET_BUG;
      /* we build a list store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_list_store_from_bmat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsListObj(stack,1)) 
    {
      /* building a liststore from a list */
      NspList *l;
      if ((l = GetList(stack,1)) == NULL) return RET_BUG;
      if ((gobj = (GObject *) nsp_gtk_list_store_from_list(l,flag))== NULL) 
	return RET_BUG;
    }
  else 
    {
      Scierror("%s: firts argument has a wrong type \n",stack.fname);
      return RET_BUG;
    }
  if (( ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkliststore))== NULL) 
    return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
#line 15648 "gtk.c"


#line 1912 "gtk.override"
/* Usage: 
 *   set[iter,col,value] 
 *   set[iter,list(...)] 
 *   if list gives mores than one row then the list store is extented 
 *   the iterator if given is not changed 
 */
static int
_wrap_gtk_list_store_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_iter=NULL;GtkTreeIter *p_iter;
  gint column;
  GValue value = { 0 }; NspObject *nsp_value;
  NspList *list;
  CheckRhs(2,3);  
  if (( nsp_iter = (NspObject *) GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
  p_iter = nspg_boxed_get(nsp_iter,GtkTreeIter);
  if ( rhs == 2 ) 
    {
      if ((list = GetList(stack,2))== NULL) return RET_BUG; 
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj),p_iter,NULL,list)== FAIL)
	return RET_BUG;
    }
  else 
    {
      int n_cols = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
      if (GetScalarInt(stack,2,&column) == FAIL) return RET_BUG;
      if ((nsp_value =nsp_get_object(stack,3))== NULLOBJ) return RET_BUG;
      if (column < 0 || column >= n_cols) 
	{
	  Scierror("column number is out of range [0,%d]",n_cols);
	  return RET_BUG; 
	}
      g_value_init(&value,gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),column));
      if (nspg_value_from_nspobject(&value, nsp_value)) {
	Scierror("value (%s) is of the wrong type for column %d\n",nsp_value->type->s_type(),column);
	return RET_BUG;
      }
      gtk_list_store_set_value(GTK_LIST_STORE(self->obj),p_iter,column, &value);
      g_value_unset(&value);
    }
  return 0;
}
#line 15694 "gtk.c"


static int _wrap_gtk_list_store_remove(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_list_store_remove(GTK_LIST_STORE(self->obj), iter);
  return 0;
}

#line 1958 "gtk.override"
static int
_wrap_gtk_list_store_insert(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  gint position;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(1,2);
  if ( GetScalarInt(stack,1,&position)== FAIL) return RET_BUG;
  gtk_list_store_insert(GTK_LIST_STORE(self->obj), &iter, position);

  if ( rhs == 2 ) 
    { 
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if (  nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row)== FAIL) return RET_BUG;
    }

  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL) 
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 15738 "gtk.c"


#line 1983 "gtk.override"
static int
_wrap_gtk_list_store_insert_before(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGtkTreeIter  *sibling;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(1,2);
  if (( sibling = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
  gtk_list_store_insert_before(GTK_LIST_STORE(self->obj), &iter,
			       nspg_boxed_get(sibling, GtkTreeIter));
  if ( rhs == 2) 
    { 
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) ==FAIL) 
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 15765 "gtk.c"


#line 2008 "gtk.override"
static int
_wrap_gtk_list_store_insert_after(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGtkTreeIter  *sibling;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(1,2);
  if (( sibling = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
  gtk_list_store_insert_after(GTK_LIST_STORE(self->obj), &iter,
			       nspg_boxed_get(sibling, GtkTreeIter));
  if ( rhs == 2) 
    { 
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) ==FAIL) 
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 15792 "gtk.c"


#line 2033 "gtk.override"
static int
_wrap_gtk_list_store_prepend(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(0,1);
  gtk_list_store_prepend(GTK_LIST_STORE(self->obj), &iter);

  if ( rhs == 1 ) 
    {
      if (( row = GetList(stack,1)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) == FAIL) 
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL) 
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 15817 "gtk.c"


#line 2056 "gtk.override"
static int
_wrap_gtk_list_store_append(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(0,1);
  gtk_list_store_append(GTK_LIST_STORE(self->obj), &iter);
 
  if ( rhs == 1 ) 
    {
      if (( row = GetList(stack,1)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) == FAIL) 
	return RET_BUG;
    }

  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 15843 "gtk.c"


static int _wrap_gtk_list_store_clear(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_list_store_clear(GTK_LIST_STORE(self->obj));
  return 0;
}

static NspMethods gtkliststore_methods[] = {
  {"set",(nsp_method *) _wrap_gtk_list_store_set},
  {"remove",(nsp_method *) _wrap_gtk_list_store_remove},
  {"insert",(nsp_method *) _wrap_gtk_list_store_insert},
  {"insert_before",(nsp_method *) _wrap_gtk_list_store_insert_before},
  {"insert_after",(nsp_method *) _wrap_gtk_list_store_insert_after},
  {"prepend",(nsp_method *) _wrap_gtk_list_store_prepend},
  {"append",(nsp_method *) _wrap_gtk_list_store_append},
  {"clear",(nsp_method *) _wrap_gtk_list_store_clear},
  { NULL, NULL}
};

static NspMethods *gtkliststore_get_methods(void) { return gtkliststore_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkliststore_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTreeModelSort ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTreeModelSort_Private 
#include "nsp/gtk/gtktreemodelsort.h"
#include "nsp/interf.h"

/* NspGtkTreeModelSort inherits from NspGObject */ 

int nsp_type_gtktreemodelsort_id=0;
NspTypeGtkTreeModelSort *nsp_type_gtktreemodelsort=NULL;

NspTypeGtkTreeModelSort *new_type_gtktreemodelsort(type_mode mode)
{
  NspTypeGtkTreeModelSort *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreemodelsort != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreemodelsort;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreemodelsort_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktreemodelsort_get_methods; 
  type->new = (new_func *) new_gtktreemodelsort;

  /* specific methods for gtktreemodelsort */
      
  type->init = (init_func *) init_gtktreemodelsort;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktreemodelsort */ 

  top->s_type =  (s_type_func *) gtktreemodelsort_type_as_string;    
  top->sh_type = (sh_type_func *) gtktreemodelsort_type_short_string;
  /* top->create = (create_func*) int_gtktreemodelsort_create;*/ 
  
  /* specific methods for gtktreemodelsort */
      
  type->init = (init_func *) init_gtktreemodelsort;

  type->interface =  (NspTypeBase *) new_type_gtktreemodel(T_DERIVED);
  type->interface->interface =  (NspTypeBase *) new_type_gtktreesortable(T_DERIVED);
  if ( nsp_type_gtktreemodelsort_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeModelSort called nsp_type_gtktreemodelsort
       */
      type->id =  nsp_type_gtktreemodelsort_id = nsp_new_type_id();
      nsp_type_gtktreemodelsort = type;
      if ( nsp_register_type(nsp_type_gtktreemodelsort) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreemodelsort, GTK_TYPE_TREE_MODEL_SORT);
      return ( mode == T_BASE ) ? type : new_type_gtktreemodelsort(mode);
    }
  else 
    {
       type->id = nsp_type_gtktreemodelsort_id;
       return type;
    }
}

/*
 * initialize GtkTreeModelSort instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreemodelsort(NspGtkTreeModelSort *o,NspTypeGtkTreeModelSort *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTreeModelSort 
 */

NspGtkTreeModelSort *new_gtktreemodelsort() 
{
  NspGtkTreeModelSort *loc; 
  /* type must exists */
  nsp_type_gtktreemodelsort = new_type_gtktreemodelsort(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeModelSort)))== NULLGTKTREEMODELSORT) return loc;
  /* initialize object */
  if ( init_gtktreemodelsort(loc,nsp_type_gtktreemodelsort) == FAIL) return NULLGTKTREEMODELSORT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTreeModelSort 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktreemodelsort_type_name[]="GtkTreeModelSort";
static char gtktreemodelsort_short_type_name[]="GtkTreeModelSort";

static char *gtktreemodelsort_type_as_string(void)
{
  return(gtktreemodelsort_type_name);
}

static char *gtktreemodelsort_type_short_string(void)
{
  return(gtktreemodelsort_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTreeModelSort objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTreeModelSort   *gtktreemodelsort_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktreemodelsort_id) ) return ((NspGtkTreeModelSort *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreemodelsort));
  return NULL;
}

int IsGtkTreeModelSortObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktreemodelsort_id);
}

int IsGtkTreeModelSort(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreemodelsort_id);
}

NspGtkTreeModelSort  *GetGtkTreeModelSortCopy(Stack stack, int i)
{
  if (  GetGtkTreeModelSort(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeModelSort  *GetGtkTreeModelSort(Stack stack, int i)
{
  NspGtkTreeModelSort *M;
  if (( M = gtktreemodelsort_object(NthObj(i))) == NULLGTKTREEMODELSORT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeModelSort *gtktreemodelsort_copy(NspGtkTreeModelSort *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreemodelsort);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreemodelsort);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeModelSort
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTreeModelSort *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktreemodelsort is initialized * /
  nsp_type_gtktreemodelsort = new_type_gtktreemodelsort(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtktreemodelsort)) == NULLGTKTREEMODELSORT) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtktreemodelsort_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *child_model;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreemodel, &child_model) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_tree_model_sort_new_with_model(GTK_TREE_MODEL(child_model->obj)))== NULL) return RET_BUG;

  nsp_type_gtktreemodelsort = new_type_gtktreemodelsort(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktreemodelsort );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_sort_get_model(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *ret;
  NspObject *nsp_ret;

  ret = gtk_tree_model_sort_get_model(GTK_TREE_MODEL_SORT(self->obj));
  nsp_type_gtktreemodel = new_type_gtktreemodel(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreemodel))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_sort_convert_child_path_to_path(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_child_path, *nsp_ret;
  GtkTreePath *child_path = NULL, *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_child_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_child_path, GTK_TYPE_TREE_PATH))
      child_path = nspg_boxed_get(nsp_child_path, GtkTreePath);
  else {
      Scierror( "child_path should be a GtkTreePath");
      return RET_BUG;
  }
  ret = gtk_tree_model_sort_convert_child_path_to_path(GTK_TREE_MODEL_SORT(self->obj), child_path);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret, FALSE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreepath))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_sort_convert_child_iter_to_iter(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkTreeIter *sort_iter = NULL, *child_iter = NULL;
  NspObject *nsp_sort_iter, *nsp_child_iter;

  if ( GetArgs(stack,rhs,opt,T,&nsp_sort_iter, &nsp_child_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_sort_iter, GTK_TYPE_TREE_ITER))
      sort_iter = nspg_boxed_get(nsp_sort_iter, GtkTreeIter);
  else {
      Scierror( "sort_iter should be a GtkTreeIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_child_iter, GTK_TYPE_TREE_ITER))
      child_iter = nspg_boxed_get(nsp_child_iter, GtkTreeIter);
  else {
      Scierror( "child_iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_model_sort_convert_child_iter_to_iter(GTK_TREE_MODEL_SORT(self->obj), sort_iter, child_iter);
  return 0;
}

static int _wrap_gtk_tree_model_sort_convert_path_to_child_path(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_child_path, *nsp_ret;
  GtkTreePath *child_path = NULL, *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_child_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_child_path, GTK_TYPE_TREE_PATH))
      child_path = nspg_boxed_get(nsp_child_path, GtkTreePath);
  else {
      Scierror( "child_path should be a GtkTreePath");
      return RET_BUG;
  }
  ret = gtk_tree_model_sort_convert_path_to_child_path(GTK_TREE_MODEL_SORT(self->obj), child_path);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret, FALSE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreepath))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_sort_convert_iter_to_child_iter(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkTreeIter *child_iter = NULL, *sorted_iter = NULL;
  NspObject *nsp_child_iter, *nsp_sorted_iter;

  if ( GetArgs(stack,rhs,opt,T,&nsp_child_iter, &nsp_sorted_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_child_iter, GTK_TYPE_TREE_ITER))
      child_iter = nspg_boxed_get(nsp_child_iter, GtkTreeIter);
  else {
      Scierror( "child_iter should be a GtkTreeIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_sorted_iter, GTK_TYPE_TREE_ITER))
      sorted_iter = nspg_boxed_get(nsp_sorted_iter, GtkTreeIter);
  else {
      Scierror( "sorted_iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_model_sort_convert_iter_to_child_iter(GTK_TREE_MODEL_SORT(self->obj), child_iter, sorted_iter);
  return 0;
}

static int _wrap_gtk_tree_model_sort_reset_default_sort_func(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_model_sort_reset_default_sort_func(GTK_TREE_MODEL_SORT(self->obj));
  return 0;
}

static int _wrap_gtk_tree_model_sort_clear_cache(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_model_sort_clear_cache(GTK_TREE_MODEL_SORT(self->obj));
  return 0;
}

static NspMethods gtktreemodelsort_methods[] = {
  {"get_model",(nsp_method *) _wrap_gtk_tree_model_sort_get_model},
  {"convert_child_path_to_path",(nsp_method *) _wrap_gtk_tree_model_sort_convert_child_path_to_path},
  {"convert_child_iter_to_iter",(nsp_method *) _wrap_gtk_tree_model_sort_convert_child_iter_to_iter},
  {"convert_path_to_child_path",(nsp_method *) _wrap_gtk_tree_model_sort_convert_path_to_child_path},
  {"convert_iter_to_child_iter",(nsp_method *) _wrap_gtk_tree_model_sort_convert_iter_to_child_iter},
  {"reset_default_sort_func",(nsp_method *) _wrap_gtk_tree_model_sort_reset_default_sort_func},
  {"clear_cache",(nsp_method *) _wrap_gtk_tree_model_sort_clear_cache},
  { NULL, NULL}
};

static NspMethods *gtktreemodelsort_get_methods(void) { return gtktreemodelsort_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreemodelsort_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTreeSelection ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTreeSelection_Private 
#include "nsp/gtk/gtktreeselection.h"
#include "nsp/interf.h"

/* NspGtkTreeSelection inherits from NspGtkObject */ 

int nsp_type_gtktreeselection_id=0;
NspTypeGtkTreeSelection *nsp_type_gtktreeselection=NULL;

NspTypeGtkTreeSelection *new_type_gtktreeselection(type_mode mode)
{
  NspTypeGtkTreeSelection *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreeselection != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreeselection;
    }
  if ((type =  malloc(sizeof(NspTypeGtkObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreeselection_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktreeselection_get_methods; 
  type->new = (new_func *) new_gtktreeselection;

  /* specific methods for gtktreeselection */
      
  type->init = (init_func *) init_gtktreeselection;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktreeselection */ 

  top->s_type =  (s_type_func *) gtktreeselection_type_as_string;    
  top->sh_type = (sh_type_func *) gtktreeselection_type_short_string;
  /* top->create = (create_func*) int_gtktreeselection_create;*/ 
  
  /* specific methods for gtktreeselection */
      
  type->init = (init_func *) init_gtktreeselection;

  if ( nsp_type_gtktreeselection_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeSelection called nsp_type_gtktreeselection
       */
      type->id =  nsp_type_gtktreeselection_id = nsp_new_type_id();
      nsp_type_gtktreeselection = type;
      if ( nsp_register_type(nsp_type_gtktreeselection) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreeselection, GTK_TYPE_TREE_SELECTION);
      return ( mode == T_BASE ) ? type : new_type_gtktreeselection(mode);
    }
  else 
    {
       type->id = nsp_type_gtktreeselection_id;
       return type;
    }
}

/*
 * initialize GtkTreeSelection instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreeselection(NspGtkTreeSelection *o,NspTypeGtkTreeSelection *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTreeSelection 
 */

NspGtkTreeSelection *new_gtktreeselection() 
{
  NspGtkTreeSelection *loc; 
  /* type must exists */
  nsp_type_gtktreeselection = new_type_gtktreeselection(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeSelection)))== NULLGTKTREESELECTION) return loc;
  /* initialize object */
  if ( init_gtktreeselection(loc,nsp_type_gtktreeselection) == FAIL) return NULLGTKTREESELECTION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTreeSelection 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktreeselection_type_name[]="GtkTreeSelection";
static char gtktreeselection_short_type_name[]="GtkTreeSelection";

static char *gtktreeselection_type_as_string(void)
{
  return(gtktreeselection_type_name);
}

static char *gtktreeselection_type_short_string(void)
{
  return(gtktreeselection_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTreeSelection objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTreeSelection   *gtktreeselection_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktreeselection_id) ) return ((NspGtkTreeSelection *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreeselection));
  return NULL;
}

int IsGtkTreeSelectionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktreeselection_id);
}

int IsGtkTreeSelection(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreeselection_id);
}

NspGtkTreeSelection  *GetGtkTreeSelectionCopy(Stack stack, int i)
{
  if (  GetGtkTreeSelection(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeSelection  *GetGtkTreeSelection(Stack stack, int i)
{
  NspGtkTreeSelection *M;
  if (( M = gtktreeselection_object(NthObj(i))) == NULLGTKTREESELECTION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeSelection *gtktreeselection_copy(NspGtkTreeSelection *self)
{
  /* return gtkobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeselection);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeselection);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeSelection
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTreeSelection *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktreeselection is initialized * /
  nsp_type_gtktreeselection = new_type_gtktreeselection(T_BASE);
  if(( H = gtkobject_create(NVOID,(NspTypeBase *) nsp_type_gtktreeselection)) == NULLGTKTREESELECTION) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_tree_selection_set_mode(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_type = NULL;
  GtkSelectionMode type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SELECTION_MODE, nsp_type, &type)== FAIL)
      return RET_BUG;
  gtk_tree_selection_set_mode(GTK_TREE_SELECTION(self->obj), type);
  return 0;
}

static int _wrap_gtk_tree_selection_get_mode(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_tree_selection_get_mode(GTK_TREE_SELECTION(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 3216 "gtk.override"

static gboolean
nspgtk_tree_selection_marshal(GtkTreeSelection *selection,
			      GtkTreeModel *model,
			      GtkTreePath *path,
			      gboolean path_currently_selected,
			      gpointer data)
{
  NspObject *args[2];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 1,nargs = 1;
  gboolean ret = FALSE;

  nspg_block_threads();

  args[0] = (NspObject *) gboxed_create("path",GTK_TYPE_TREE_PATH,path,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
  if ( args[0]== NULL ) goto end;
  if (cunote->data) 
    {
      args[1]= cunote->data; 
      nargs= 2;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end;

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  goto end; 
 end:
  {
    nspg_unblock_threads();
    return ret;
  }
}

static int
_wrap_gtk_tree_selection_set_select_function(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify *cunote;

  CheckRhs(1,2); 

  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 2 ) 
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }

  cunote = g_new0(NspGtkCustomNotify, 1);
  cunote->func = func;
  cunote->data = arg;
  gtk_tree_selection_set_select_function(GTK_TREE_SELECTION(self->obj),
					 nspgtk_tree_selection_marshal,
					 cunote,
					 nspgtk_custom_destroy_notify);
  return 0;
}

#line 16494 "gtk.c"


static int _wrap_gtk_tree_selection_get_tree_view(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeView *ret;
  NspObject *nsp_ret;

  ret = gtk_tree_selection_get_tree_view(GTK_TREE_SELECTION(self->obj));
  nsp_type_gtktreeview = new_type_gtktreeview(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeview))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 3111 "gtk.override"
static int
_wrap_gtk_tree_selection_get_selected(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *model;
  GtkTreeIter iter;
  GtkSelectionMode mode;
  NspObject *nsp_ret1,*nsp_ret2=NULL;
  int rep;
  mode = gtk_tree_selection_get_mode(GTK_TREE_SELECTION(self->obj));
  if (mode == GTK_SELECTION_MULTIPLE) {
    Scierror("GtkTreeSelection.get_selected can not be used when selection mode is gtk.SELECTION_MULTIPLE\n");
    return RET_BUG;
  }
  rep = gtk_tree_selection_get_selected(GTK_TREE_SELECTION(self->obj),&model, &iter); 
  if ( rep ) 
    {
      if ((nsp_ret1 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter,TRUE, TRUE,(NspTypeBase *) 
						 nsp_type_gtktreeiter ))==NULL) 
	return RET_BUG; 
      if ( lhs == 2) 
	{
	  if ((nsp_ret2 = (NspObject *) gobject_create(NVOID,(GObject *)model,(NspTypeBase *) nsp_type_gtktreemodel )) 
	      == NULL) 
	    return RET_BUG; 
	}
    }
  else 
    {
      if ((nsp_ret1 = (NspObject *)none_create(NVOID,NULL)) == NULL) 
	return RET_BUG;
      if ( lhs == 2) 
	{
	  if ((nsp_ret2 = (NspObject *) none_create(NVOID,NULL)) == NULL) 
	    return RET_BUG; 
	}
    }
  MoveObj(stack,1,nsp_ret1);
  if ( lhs == 2 ) MoveObj(stack,2,nsp_ret2);
  return Max(lhs,1);
}
#line 16550 "gtk.c"


#line 3153 "gtk.override"
static void
nspgtk_tree_selection_foreach_marshal(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter,  gpointer data)
{
  NspObject *args[4];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 1,nargs = 3;
  /* gboolean ret = FALSE;*/

  nspg_block_threads();
  /* Il faut ici proteger les args avec des noms et 
   * viter de les construire a chaque itration .... XXXXXX
   */

  args[0] = (NspObject *) gobject_create("model",(GObject *)model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[1] = (NspObject *) gboxed_create("path",GTK_TYPE_TREE_PATH,path,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
  args[2] = (NspObject *) gboxed_create("iter",GTK_TYPE_TREE_ITER, iter,TRUE, TRUE,nsp_type_gtktreeiter);
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL ) goto end;
  if (cunote->data) 
    {
      args[3]= cunote->data; 
      nargs= 4;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end;
  /* 
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  */
  goto end; 
 end:
  {
    nspg_unblock_threads();
    /*return ret;*/
  }
}

static int
_wrap_gtk_tree_selection_selected_foreach(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify cunote;

  CheckRhs(1,2); 

  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 2 ) 
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }
  cunote.func = func;
  cunote.data = arg;
  gtk_tree_selection_selected_foreach(GTK_TREE_SELECTION(self->obj),
				      nspgtk_tree_selection_foreach_marshal,
				      &cunote);
  return 0;
}

#line 16615 "gtk.c"


static int _wrap_gtk_tree_selection_select_path(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  gtk_tree_selection_select_path(GTK_TREE_SELECTION(self->obj), path);
  return 0;
}

static int _wrap_gtk_tree_selection_unselect_path(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  gtk_tree_selection_unselect_path(GTK_TREE_SELECTION(self->obj), path);
  return 0;
}

static int _wrap_gtk_tree_selection_select_iter(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_selection_select_iter(GTK_TREE_SELECTION(self->obj), iter);
  return 0;
}

static int _wrap_gtk_tree_selection_unselect_iter(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_selection_unselect_iter(GTK_TREE_SELECTION(self->obj), iter);
  return 0;
}

static int _wrap_gtk_tree_selection_path_is_selected(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  ret = gtk_tree_selection_path_is_selected(GTK_TREE_SELECTION(self->obj), path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_selection_iter_is_selected(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  ret = gtk_tree_selection_iter_is_selected(GTK_TREE_SELECTION(self->obj), iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_selection_select_all(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_selection_select_all(GTK_TREE_SELECTION(self->obj));
  return 0;
}

static int _wrap_gtk_tree_selection_unselect_all(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_selection_unselect_all(GTK_TREE_SELECTION(self->obj));
  return 0;
}

static int _wrap_gtk_tree_selection_select_range(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  NspObject *nsp_start_path, *nsp_end_path;
  GtkTreePath *start_path = NULL, *end_path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_start_path, &nsp_end_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start_path, GTK_TYPE_TREE_PATH))
      start_path = nspg_boxed_get(nsp_start_path, GtkTreePath);
  else {
      Scierror( "start_path should be a GtkTreePath");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end_path, GTK_TYPE_TREE_PATH))
      end_path = nspg_boxed_get(nsp_end_path, GtkTreePath);
  else {
      Scierror( "end_path should be a GtkTreePath");
      return RET_BUG;
  }
  gtk_tree_selection_select_range(GTK_TREE_SELECTION(self->obj), start_path, end_path);
  return 0;
}

static NspMethods gtktreeselection_methods[] = {
  {"set_mode",(nsp_method *) _wrap_gtk_tree_selection_set_mode},
  {"get_mode",(nsp_method *) _wrap_gtk_tree_selection_get_mode},
  {"set_select_function",(nsp_method *) _wrap_gtk_tree_selection_set_select_function},
  {"get_tree_view",(nsp_method *) _wrap_gtk_tree_selection_get_tree_view},
  {"get_selected",(nsp_method *) _wrap_gtk_tree_selection_get_selected},
  {"selected_foreach",(nsp_method *) _wrap_gtk_tree_selection_selected_foreach},
  {"select_path",(nsp_method *) _wrap_gtk_tree_selection_select_path},
  {"unselect_path",(nsp_method *) _wrap_gtk_tree_selection_unselect_path},
  {"select_iter",(nsp_method *) _wrap_gtk_tree_selection_select_iter},
  {"unselect_iter",(nsp_method *) _wrap_gtk_tree_selection_unselect_iter},
  {"path_is_selected",(nsp_method *) _wrap_gtk_tree_selection_path_is_selected},
  {"iter_is_selected",(nsp_method *) _wrap_gtk_tree_selection_iter_is_selected},
  {"select_all",(nsp_method *) _wrap_gtk_tree_selection_select_all},
  {"unselect_all",(nsp_method *) _wrap_gtk_tree_selection_unselect_all},
  {"select_range",(nsp_method *) _wrap_gtk_tree_selection_select_range},
  { NULL, NULL}
};

static NspMethods *gtktreeselection_get_methods(void) { return gtktreeselection_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreeselection_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTreeStore ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTreeStore_Private 
#include "nsp/gtk/gtktreestore.h"
#include "nsp/interf.h"

/* NspGtkTreeStore inherits from NspGObject */ 

int nsp_type_gtktreestore_id=0;
NspTypeGtkTreeStore *nsp_type_gtktreestore=NULL;

NspTypeGtkTreeStore *new_type_gtktreestore(type_mode mode)
{
  NspTypeGtkTreeStore *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreestore != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreestore;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreestore_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktreestore_get_methods; 
  type->new = (new_func *) new_gtktreestore;

  /* specific methods for gtktreestore */
      
  type->init = (init_func *) init_gtktreestore;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktreestore */ 

  top->s_type =  (s_type_func *) gtktreestore_type_as_string;    
  top->sh_type = (sh_type_func *) gtktreestore_type_short_string;
  /* top->create = (create_func*) int_gtktreestore_create;*/ 
  
  /* specific methods for gtktreestore */
      
  type->init = (init_func *) init_gtktreestore;

  type->interface =  (NspTypeBase *) new_type_gtktreemodel(T_DERIVED);
  type->interface->interface =  (NspTypeBase *) new_type_gtktreedragsource(T_DERIVED);
  type->interface->interface->interface =  (NspTypeBase *) new_type_gtktreedragdest(T_DERIVED);
  type->interface->interface->interface->interface =  (NspTypeBase *) new_type_gtktreesortable(T_DERIVED);
  if ( nsp_type_gtktreestore_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeStore called nsp_type_gtktreestore
       */
      type->id =  nsp_type_gtktreestore_id = nsp_new_type_id();
      nsp_type_gtktreestore = type;
      if ( nsp_register_type(nsp_type_gtktreestore) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreestore, GTK_TYPE_TREE_STORE);
      return ( mode == T_BASE ) ? type : new_type_gtktreestore(mode);
    }
  else 
    {
       type->id = nsp_type_gtktreestore_id;
       return type;
    }
}

/*
 * initialize GtkTreeStore instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreestore(NspGtkTreeStore *o,NspTypeGtkTreeStore *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTreeStore 
 */

NspGtkTreeStore *new_gtktreestore() 
{
  NspGtkTreeStore *loc; 
  /* type must exists */
  nsp_type_gtktreestore = new_type_gtktreestore(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeStore)))== NULLGTKTREESTORE) return loc;
  /* initialize object */
  if ( init_gtktreestore(loc,nsp_type_gtktreestore) == FAIL) return NULLGTKTREESTORE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTreeStore 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktreestore_type_name[]="GtkTreeStore";
static char gtktreestore_short_type_name[]="GtkTreeStore";

static char *gtktreestore_type_as_string(void)
{
  return(gtktreestore_type_name);
}

static char *gtktreestore_type_short_string(void)
{
  return(gtktreestore_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTreeStore objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTreeStore   *gtktreestore_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktreestore_id) ) return ((NspGtkTreeStore *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreestore));
  return NULL;
}

int IsGtkTreeStoreObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktreestore_id);
}

int IsGtkTreeStore(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreestore_id);
}

NspGtkTreeStore  *GetGtkTreeStoreCopy(Stack stack, int i)
{
  if (  GetGtkTreeStore(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeStore  *GetGtkTreeStore(Stack stack, int i)
{
  NspGtkTreeStore *M;
  if (( M = gtktreestore_object(NthObj(i))) == NULLGTKTREESTORE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeStore *gtktreestore_copy(NspGtkTreeStore *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreestore);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreestore);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeStore
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTreeStore *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktreestore is initialized * /
  nsp_type_gtktreestore = new_type_gtktreestore(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtktreestore)) == NULLGTKTREESTORE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 2082 "gtk.override"
/* very similar to liststore : 
 * we build the first level here 
 */
static int
_wrap_gtktreestore_new(Stack stack,int rhs,int opt,int lhs)
{
  int flag = TRUE;
  NspObject *ret;
  GObject *gobj;
  CheckRhs(1,2); 
  if ( opt != 0 ) {
    Scierror("GtkListStore do not accept optional named arguments");
    return RET_BUG;
  }

  if (rhs == 2) 
    {
      if (  GetScalarBool(stack,2,&flag) == FAIL) {return FAIL;}
    }
  if ( IsMatObj(stack,1)) 
    {
      /* building a treestore from a Matrix */
      NspMatrix *M;
      if ((M = GetRealMat(stack,1)) == NULLMAT) return RET_BUG;
      /* we build a tree store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_mat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsSMatObj(stack,1)) 
    {
      /* building a treestore from a string matrix  */
      NspSMatrix *M;
      if ((M = GetSMat(stack,1)) == NULLSMAT) return RET_BUG;
      /* we build a tree store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_smat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsBMatObj(stack,1)) 
    {
      /* building a treestore from a boolean matrix  */
      NspBMatrix *M;
      if ((M = GetBMat(stack,1)) == NULLBMAT) return RET_BUG;
      /* we build a tree store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_bmat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsListObj(stack,1)) 
    {
      /* building a treestore from a list */
      NspList *l;
      if ((l = GetList(stack,1)) == NULL) return RET_BUG;
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_list(l,flag))== NULL) 
	return RET_BUG;
    }
  else 
    {
      Scierror("%s: firts argument has a wrong type \n",stack.fname);
      return RET_BUG;
    }
  if (( ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtktreestore))== NULL) 
    return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
#line 17048 "gtk.c"


#line 2150 "gtk.override"

/* Usage: 
 *   set[iter,col,value] 
 *   set[iter,list(...)] 
 *   if list gives mores than one row then the list store is extented 
 *   the iterator if given is not changed 
 */
static int
_wrap_gtk_tree_store_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGtkTreeIter *nsp_iter=NULL;GtkTreeIter *p_iter;
  gint column;
  GValue value = { 0 }; NspObject *nsp_value;
  NspList *list;
  CheckRhs(2,3);  
  if (( nsp_iter = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
  p_iter = nspg_boxed_get(nsp_iter,GtkTreeIter);
  if ( rhs == 2 ) 
    {
      if ((list = GetList(stack,2))== NULL) return RET_BUG; 
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj),p_iter,NULL,list)== FAIL)
	return RET_BUG;
    }
  else 
    {
      int n_cols = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
      if (GetScalarInt(stack,2,&column) == FAIL) return RET_BUG;
      if ((nsp_value =nsp_get_object(stack,3))== NULLOBJ) return RET_BUG;
      if (column < 0 || column >= n_cols) 
	{
	  Scierror("column number is out of range [0,%d]",n_cols);
	  return RET_BUG; 
	}
      g_value_init(&value,gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),column));
      if (nspg_value_from_nspobject(&value, nsp_value)) {
	Scierror("value (%s) is of the wrong type for column %d\n",nsp_value->type->s_type(),column);
	return RET_BUG;
      }
      gtk_tree_store_set_value(GTK_TREE_STORE(self->obj),p_iter,column, &value);
      g_value_unset(&value);
    }
  return 0;
}
#line 17095 "gtk.c"


static int _wrap_gtk_tree_store_remove(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_store_remove(GTK_TREE_STORE(self->obj), iter);
  return 0;
}

#line 2195 "gtk.override"
static int
_wrap_gtk_tree_store_insert(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter, *parent = NULL;
  gint position;
  NspList *row = NULL;
  NspObject *ret;
  NspGtkTreeIter  *nsp_parent;
  int pos= 0; 
  CheckRhs(1,3);
  if ( IsGtkTreeIterObj(stack,1) ) 
    {
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      pos = 1; 
    }
  CheckRhs(1+pos,2+pos);
  if ( GetScalarInt(stack,pos+1,&position)== FAIL) return RET_BUG;
  gtk_tree_store_insert(GTK_TREE_STORE(self->obj), &iter, parent, position);
  if ( rhs == 2+pos ) 
    { 
      if (( row = GetList(stack,2+pos)) == NULL) return RET_BUG;
      if (  nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row)== FAIL) return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL) 
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 17145 "gtk.c"


#line 2226 "gtk.override"
static int
_wrap_gtk_tree_store_insert_before(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter  *sibling=NULL,*parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;
  NspGtkTreeIter *nsp_parent,*nsp_sibling;
  int pos=0;

  CheckRhs(1,3);
  if ( IsGtkTreeIterObj(stack,1) ) 
    {
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      pos = 1; 
    }
  CheckRhs(1+pos,2+pos);
  if (( nsp_sibling = GetGtkTreeIter(stack,1+pos))== NULL) return RET_BUG; 
  sibling = nspg_boxed_get(sibling, GtkTreeIter);
  gtk_tree_store_insert_before(GTK_TREE_STORE(self->obj),&iter,parent,sibling);
  if ( rhs == pos+2) 
    { 
      if (( row = GetList(stack,pos+2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL) 
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 17181 "gtk.c"


#line 2260 "gtk.override"
static int
_wrap_gtk_tree_store_insert_after(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter  *sibling=NULL,*parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret; 
  NspGtkTreeIter *nsp_parent,*nsp_sibling;
  int pos=0;
  CheckRhs(1,3);
  if ( IsGtkTreeIterObj(stack,1) ) 
    {
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      pos = 1; 
    }
  CheckRhs(1+pos,2+pos);
  if (( nsp_sibling = GetGtkTreeIter(stack,1+pos))== NULL) return RET_BUG; 
  sibling = nspg_boxed_get(sibling, GtkTreeIter);
  gtk_tree_store_insert_after(GTK_TREE_STORE(self->obj),&iter,parent,sibling);
  if ( rhs == pos+2) 
    { 
      if (( row = GetList(stack,pos+2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL) 
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 17216 "gtk.c"


#line 2293 "gtk.override"
static int
_wrap_gtk_tree_store_prepend(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter *parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;
  NspGtkTreeIter *nsp_parent;
  
  CheckRhs(0,2);
  switch (rhs) 
    {
    case 0: gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
      break;
    case 1: 
      if ( IsGtkTreeIterObj(stack,1) ) 
	{
	  /* prepend[parent] */
	  if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
	  parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
	  gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
	}
      else 
	{
	  /* prepend[row] */
	  gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
	  if (( row = GetList(stack,1)) == NULL) return RET_BUG;
	  if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL) 
	    return RET_BUG;
	}
      break;
    case 2: 
      /* prepend[parent,row] */
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL) 
	return RET_BUG;
      break;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 17266 "gtk.c"


#line 2341 "gtk.override"
static int
_wrap_gtk_tree_store_append(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter  *parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret; 
  NspGtkTreeIter *nsp_parent;
  
  CheckRhs(0,2);
  switch (rhs) 
    {
    case 0: gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
      break;
    case 1: 
      if ( IsGtkTreeIterObj(stack,1) ) 
	{
	  /* append a row (tree titer gives the parent position) */
	  if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
	  parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
	  gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
	}
      else 
	{
	  /* append a row at top level  */
	  gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
	  if (( row = GetList(stack,1)) == NULL) return RET_BUG;
	  /* fill the row (or the rows if more than one row data is given) */
	  if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL) 
	    return RET_BUG;
	}
      break;
    case 2: 
      /* append a row (tree iter gives the parent position ) */
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
	  /* fill the row (or the rows if more than one row data is given) */
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent,row) ==FAIL) 
	return RET_BUG;
      break;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;

}
#line 17319 "gtk.c"


static int _wrap_gtk_tree_store_is_ancestor(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  int ret;
  GtkTreeIter *iter = NULL, *descendant = NULL;
  NspObject *nsp_iter, *nsp_descendant;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_descendant) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_descendant, GTK_TYPE_TREE_ITER))
      descendant = nspg_boxed_get(nsp_descendant, GtkTreeIter);
  else {
      Scierror( "descendant should be a GtkTreeIter");
      return RET_BUG;
  }
  ret = gtk_tree_store_is_ancestor(GTK_TREE_STORE(self->obj), iter, descendant);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_store_iter_depth(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  ret = gtk_tree_store_iter_depth(GTK_TREE_STORE(self->obj), iter);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_store_clear(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_store_clear(GTK_TREE_STORE(self->obj));
  return 0;
}

static NspMethods gtktreestore_methods[] = {
  {"set",(nsp_method *) _wrap_gtk_tree_store_set},
  {"remove",(nsp_method *) _wrap_gtk_tree_store_remove},
  {"insert",(nsp_method *) _wrap_gtk_tree_store_insert},
  {"insert_before",(nsp_method *) _wrap_gtk_tree_store_insert_before},
  {"insert_after",(nsp_method *) _wrap_gtk_tree_store_insert_after},
  {"prepend",(nsp_method *) _wrap_gtk_tree_store_prepend},
  {"append",(nsp_method *) _wrap_gtk_tree_store_append},
  {"is_ancestor",(nsp_method *) _wrap_gtk_tree_store_is_ancestor},
  {"iter_depth",(nsp_method *) _wrap_gtk_tree_store_iter_depth},
  {"clear",(nsp_method *) _wrap_gtk_tree_store_clear},
  { NULL, NULL}
};

static NspMethods *gtktreestore_get_methods(void) { return gtktreestore_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreestore_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTreeViewColumn ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTreeViewColumn_Private 
#include "nsp/gtk/gtktreeviewcolumn.h"
#include "nsp/interf.h"

/* NspGtkTreeViewColumn inherits from NspGtkObject */ 

int nsp_type_gtktreeviewcolumn_id=0;
NspTypeGtkTreeViewColumn *nsp_type_gtktreeviewcolumn=NULL;

NspTypeGtkTreeViewColumn *new_type_gtktreeviewcolumn(type_mode mode)
{
  NspTypeGtkTreeViewColumn *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreeviewcolumn != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreeviewcolumn;
    }
  if ((type =  malloc(sizeof(NspTypeGtkObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreeviewcolumn_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktreeviewcolumn_get_methods; 
  type->new = (new_func *) new_gtktreeviewcolumn;

  /* specific methods for gtktreeviewcolumn */
      
  type->init = (init_func *) init_gtktreeviewcolumn;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktreeviewcolumn */ 

  top->s_type =  (s_type_func *) gtktreeviewcolumn_type_as_string;    
  top->sh_type = (sh_type_func *) gtktreeviewcolumn_type_short_string;
  /* top->create = (create_func*) int_gtktreeviewcolumn_create;*/ 
  
  /* specific methods for gtktreeviewcolumn */
      
  type->init = (init_func *) init_gtktreeviewcolumn;

  if ( nsp_type_gtktreeviewcolumn_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeViewColumn called nsp_type_gtktreeviewcolumn
       */
      type->id =  nsp_type_gtktreeviewcolumn_id = nsp_new_type_id();
      nsp_type_gtktreeviewcolumn = type;
      if ( nsp_register_type(nsp_type_gtktreeviewcolumn) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreeviewcolumn, GTK_TYPE_TREE_VIEW_COLUMN);
      return ( mode == T_BASE ) ? type : new_type_gtktreeviewcolumn(mode);
    }
  else 
    {
       type->id = nsp_type_gtktreeviewcolumn_id;
       return type;
    }
}

/*
 * initialize GtkTreeViewColumn instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreeviewcolumn(NspGtkTreeViewColumn *o,NspTypeGtkTreeViewColumn *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTreeViewColumn 
 */

NspGtkTreeViewColumn *new_gtktreeviewcolumn() 
{
  NspGtkTreeViewColumn *loc; 
  /* type must exists */
  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeViewColumn)))== NULLGTKTREEVIEWCOLUMN) return loc;
  /* initialize object */
  if ( init_gtktreeviewcolumn(loc,nsp_type_gtktreeviewcolumn) == FAIL) return NULLGTKTREEVIEWCOLUMN;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTreeViewColumn 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktreeviewcolumn_type_name[]="GtkTreeViewColumn";
static char gtktreeviewcolumn_short_type_name[]="GtkTreeViewColumn";

static char *gtktreeviewcolumn_type_as_string(void)
{
  return(gtktreeviewcolumn_type_name);
}

static char *gtktreeviewcolumn_type_short_string(void)
{
  return(gtktreeviewcolumn_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTreeViewColumn objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTreeViewColumn   *gtktreeviewcolumn_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktreeviewcolumn_id) ) return ((NspGtkTreeViewColumn *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreeviewcolumn));
  return NULL;
}

int IsGtkTreeViewColumnObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktreeviewcolumn_id);
}

int IsGtkTreeViewColumn(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreeviewcolumn_id);
}

NspGtkTreeViewColumn  *GetGtkTreeViewColumnCopy(Stack stack, int i)
{
  if (  GetGtkTreeViewColumn(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeViewColumn  *GetGtkTreeViewColumn(Stack stack, int i)
{
  NspGtkTreeViewColumn *M;
  if (( M = gtktreeviewcolumn_object(NthObj(i))) == NULLGTKTREEVIEWCOLUMN)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeViewColumn *gtktreeviewcolumn_copy(NspGtkTreeViewColumn *self)
{
  /* return gtkobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeviewcolumn);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeviewcolumn);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeViewColumn
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTreeViewColumn *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktreeviewcolumn is initialized * /
  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  if(( H = gtkobject_create(NVOID,(NspTypeBase *) nsp_type_gtktreeviewcolumn)) == NULLGTKTREEVIEWCOLUMN) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 2645 "gtk.override"
/* gtktreeviewcolumn_new(title="...",renderer=nsp_type_gtkcellrenderer,options= hash)
 * options a hash table of int values 
 */
static int
_wrap_gtktreeviewcolumn_new(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_cell = NULL,*nsp_ret; 
  NspHash *h =NULL;
  GtkTreeViewColumn *tvc;
  gchar *title = NULL; 
  GtkCellRenderer *cell = NULL;

  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"title",string,NULLOBJ,-1}, 
	{"renderer",obj_check,NULLOBJ,-1}, 
	{"attrs",hash,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };

  if (GetArgs(stack,rhs,opt,T, &opts, &title,&nsp_type_gtkcellrenderer,&nsp_cell, &h)== FAIL) 
    return RET_BUG;
  if ( nsp_cell != NULL) cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));
  
  tvc = gtk_tree_view_column_new();
  if (title != NULL )  gtk_tree_view_column_set_title(tvc, title);
  if (cell != NULL )   gtk_tree_view_column_pack_start(tvc, cell, TRUE);
  if (h != NULL) 
    {
      int i;
      for ( i =0 ; i < h->hsize ; i++) 
	{
	  Hash_Entry *loc = ((Hash_Entry *) h->htable) + i;
	  if ( loc->used )
	    {
	      if ( IsMat(loc->data) 
		   && (((NspMatrix *) loc->data)->mn == 1) 
		   && (((NspMatrix *) loc->data)->rc_type == 'r' ))
		gtk_tree_view_column_add_attribute(tvc, cell,nsp_object_get_name(loc->data),
						   ((NspMatrix *) loc->data)->R[0]);
	      else 
		{
		  Scierror("%s: attribute %s should be a real scalar\n",stack.fname,nsp_object_get_name(loc->data));
		  return RET_BUG;
		}
	    }
	}
    }

  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *) tvc,(NspTypeBase *) nsp_type_gtktreeviewcolumn );
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 17642 "gtk.c"


static int _wrap_gtk_tree_view_column_pack_start(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_bool,t_end};
  int expand;
  NspGObject *cell;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell, &expand) == FAIL) return RET_BUG;
  gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(self->obj), GTK_CELL_RENDERER(cell->obj), expand);
  return 0;
}

static int _wrap_gtk_tree_view_column_pack_end(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_bool,t_end};
  int expand;
  NspGObject *cell;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell, &expand) == FAIL) return RET_BUG;
  gtk_tree_view_column_pack_end(GTK_TREE_VIEW_COLUMN(self->obj), GTK_CELL_RENDERER(cell->obj), expand);
  return 0;
}

static int _wrap_gtk_tree_view_column_clear(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_view_column_clear(GTK_TREE_VIEW_COLUMN(self->obj));
  return 0;
}

#line 2719 "gtk.override"
static int
_wrap_gtk_tree_view_column_get_cell_renderers(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  Cell *cloc = NULLCELL,*cloc1=NULLCELL; 
  list = gtk_tree_view_column_get_cell_renderers(GTK_TREE_VIEW_COLUMN(self->obj));
  
  NSP_LIST_FROM_GLIST( gobject_gettype_and_create("lel",(GObject *) tmp->data),g_list_free); /* XXXX */
}
#line 17684 "gtk.c"


static int _wrap_gtk_tree_view_column_add_attribute(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, string, s_int,t_end};
  char *attribute;
  NspGObject *cell_renderer;
  int column;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell_renderer, &attribute, &column) == FAIL) return RET_BUG;
  gtk_tree_view_column_add_attribute(GTK_TREE_VIEW_COLUMN(self->obj), GTK_CELL_RENDERER(cell_renderer->obj), attribute, column);
  return 0;
}

#line 2850 "gtk.override"
static int
_wrap_gtk_tree_view_column_set_attributes(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspHash *h =NULL;
  GtkCellRenderer *cell;
  NspGtkCellRenderer *nsp_cell;
  gint i = 0;
  
  CheckRhs(2,2) ;
  if ((nsp_cell = GetGtkCellRenderer(stack,1)) == NULL) return RET_BUG; 
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));
  if ((h = GetHash(stack,2)) == NULL) return RET_BUG; 
  gtk_tree_view_column_clear_attributes(GTK_TREE_VIEW_COLUMN(self->obj),cell);

  for ( i =0 ; i < h->hsize ; i++) 
    {
      Hash_Entry *loc = ((Hash_Entry *) h->htable) + i;
      if ( loc->used )
	{
	  if ( IsMat(loc->data) 
	       && (((NspMatrix *) loc->data)->mn == 1) 
	       && (((NspMatrix *) loc->data)->rc_type == 'r' ))
	    gtk_tree_view_column_add_attribute(GTK_TREE_VIEW_COLUMN(self->obj), cell,nsp_object_get_name(loc->data),
					       ((NspMatrix *) loc->data)->R[0]);
	  else 
	    {
	      Scierror("%s: attribute %s should be a real scalar\n",stack.fname,nsp_object_get_name(loc->data));
	      return RET_BUG;
	    }
	}
    }
  return 0;
}
#line 17733 "gtk.c"


#line 2731 "gtk.override"
static void
nspgtk_cell_data_func_marshal (GtkTreeViewColumn *tree_column,
			       GtkCellRenderer *cell,
			       GtkTreeModel *tree_model,
			       GtkTreeIter *iter, gpointer data)
{
  NspObject *args[5], *nsp_ret;
  NspGtkCustomNotify *cunote = data;
  int nret = 1,nargs = 4;
  gboolean ret = FALSE;

  g_assert (cunote->func);

  nspg_block_threads();

  args[0] =  (NspObject *) gobject_create("tree_column",(GObject *)tree_column,(NspTypeBase *) nsp_type_gtktreeviewcolumn );
  args[1] = (NspObject *) gobject_create("cell",(GObject *) cell, (NspTypeBase *) nsp_type_gtkcellrenderer);
  args[2] =  (NspObject *) gobject_create("model",(GObject *)tree_model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[3] =  (NspObject *) gboxed_create("iter",GTK_TYPE_TREE_ITER, iter,TRUE, TRUE,(NspTypeBase *)nsp_type_gtktreeiter);
  
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL||args[3]== NULL ) goto end;
  if (cunote->data) 
    {
      args[4]= cunote->data; 
      nargs= 5;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end; 

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  nspg_unblock_threads();
 end: 
  {
    nspg_unblock_threads();
  }
}

static int
_wrap_gtk_tree_view_column_set_cell_data_func (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_func, *nsp_arg = NULL;
  GtkCellRenderer *cell;
  NspGtkCellRenderer *nsp_cell;
  NspGtkCustomNotify *cunote; 
  CheckRhs(2,3);
  if ((nsp_cell = GetGtkCellRenderer(stack,1)) == NULL) return RET_BUG; 
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,2)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 3 ) 
    {
      if (( nsp_arg = (NspObject *) GetListCopy(stack,3)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;

  gtk_tree_view_column_set_cell_data_func (GTK_TREE_VIEW_COLUMN (self->obj), cell,
					   nspgtk_cell_data_func_marshal,
					   cunote,
					   nspgtk_custom_destroy_notify);

  return 0;
}
#line 17804 "gtk.c"


static int _wrap_gtk_tree_view_column_clear_attributes(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *cell_renderer;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell_renderer) == FAIL) return RET_BUG;
  gtk_tree_view_column_clear_attributes(GTK_TREE_VIEW_COLUMN(self->obj), GTK_CELL_RENDERER(cell_renderer->obj));
  return 0;
}

static int _wrap_gtk_tree_view_column_set_spacing(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int spacing;

  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_spacing(GTK_TREE_VIEW_COLUMN(self->obj), spacing);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_spacing(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_spacing(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_visible(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int visible;

  if ( GetArgs(stack,rhs,opt,T,&visible) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_visible(GTK_TREE_VIEW_COLUMN(self->obj), visible);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_visible(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_visible(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_resizable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int resizable;

  if ( GetArgs(stack,rhs,opt,T,&resizable) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_resizable(GTK_TREE_VIEW_COLUMN(self->obj), resizable);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_resizable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_resizable(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_sizing(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTreeViewColumnSizing type;
  NspObject *nsp_type = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TREE_VIEW_COLUMN_SIZING, nsp_type, &type)== FAIL)
      return RET_BUG;
  gtk_tree_view_column_set_sizing(GTK_TREE_VIEW_COLUMN(self->obj), type);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_sizing(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_sizing(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_get_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_width(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_get_fixed_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_fixed_width(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_fixed_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int fixed_width;

  if ( GetArgs(stack,rhs,opt,T,&fixed_width) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_fixed_width(GTK_TREE_VIEW_COLUMN(self->obj), fixed_width);
  return 0;
}

static int _wrap_gtk_tree_view_column_set_min_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int min_width;

  if ( GetArgs(stack,rhs,opt,T,&min_width) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_min_width(GTK_TREE_VIEW_COLUMN(self->obj), min_width);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_min_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_min_width(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_max_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int max_width;

  if ( GetArgs(stack,rhs,opt,T,&max_width) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_max_width(GTK_TREE_VIEW_COLUMN(self->obj), max_width);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_max_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_max_width(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_clicked(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_view_column_clicked(GTK_TREE_VIEW_COLUMN(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_column_set_title(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *title;

  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_title(GTK_TREE_VIEW_COLUMN(self->obj), title);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_title(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_tree_view_column_get_title(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_clickable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int active;

  if ( GetArgs(stack,rhs,opt,T,&active) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_clickable(GTK_TREE_VIEW_COLUMN(self->obj), active);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_clickable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_clickable(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_widget(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_widget(GTK_TREE_VIEW_COLUMN(self->obj), GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_tree_view_column_get_widget(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

  ret = gtk_tree_view_column_get_widget(GTK_TREE_VIEW_COLUMN(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_column_set_alignment(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,t_end};
  double xalign;

  if ( GetArgs(stack,rhs,opt,T,&xalign) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_alignment(GTK_TREE_VIEW_COLUMN(self->obj), xalign);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_alignment(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;

  ret = gtk_tree_view_column_get_alignment(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_reorderable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int reorderable;

  if ( GetArgs(stack,rhs,opt,T,&reorderable) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_reorderable(GTK_TREE_VIEW_COLUMN(self->obj), reorderable);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_reorderable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_reorderable(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_sort_column_id(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int sort_column_id;

  if ( GetArgs(stack,rhs,opt,T,&sort_column_id) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_sort_column_id(GTK_TREE_VIEW_COLUMN(self->obj), sort_column_id);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_sort_column_id(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_sort_column_id(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_sort_indicator(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_tree_view_column_set_sort_indicator(GTK_TREE_VIEW_COLUMN(self->obj), setting);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_sort_indicator(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_get_sort_indicator(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_sort_order(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_order = NULL;
  GtkSortType order;

  if ( GetArgs(stack,rhs,opt,T,&nsp_order) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SORT_TYPE, nsp_order, &order)== FAIL)
      return RET_BUG;
  gtk_tree_view_column_set_sort_order(GTK_TREE_VIEW_COLUMN(self->obj), order);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_sort_order(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_tree_view_column_get_sort_order(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_cell_set_cell_data(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, s_bool, s_bool,t_end};
  int is_expander, is_expanded;
  NspGObject *tree_model;
  NspObject *nsp_iter;
  GtkTreeIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreemodel, &tree_model, &nsp_iter, &is_expander, &is_expanded) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
  gtk_tree_view_column_cell_set_cell_data(GTK_TREE_VIEW_COLUMN(self->obj), GTK_TREE_MODEL(tree_model->obj), iter, is_expander, is_expanded);
  return 0;
}

#line 2701 "gtk.override"
static int
_wrap_gtk_tree_view_column_cell_get_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int,s_int,s_int,t_end};
  GdkRectangle cell_area;
  gint x_offset, y_offset, width, height;

  gtk_tree_view_column_cell_get_size(GTK_TREE_VIEW_COLUMN(self->obj),
				     &cell_area,
				     &x_offset, &y_offset, &width, &height);

  return RetArgs(stack,lhs,T,
		 (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE,
					     &cell_area,TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle),
		 x_offset, y_offset, width, height);
}
#line 18162 "gtk.c"


static int _wrap_gtk_tree_view_column_cell_is_visible(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_column_cell_is_visible(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktreeviewcolumn_methods[] = {
  {"pack_start",(nsp_method *) _wrap_gtk_tree_view_column_pack_start},
  {"pack_end",(nsp_method *) _wrap_gtk_tree_view_column_pack_end},
  {"clear",(nsp_method *) _wrap_gtk_tree_view_column_clear},
  {"get_cell_renderers",(nsp_method *) _wrap_gtk_tree_view_column_get_cell_renderers},
  {"add_attribute",(nsp_method *) _wrap_gtk_tree_view_column_add_attribute},
  {"set_attributes",(nsp_method *) _wrap_gtk_tree_view_column_set_attributes},
  {"set_cell_data_func",(nsp_method *) _wrap_gtk_tree_view_column_set_cell_data_func},
  {"clear_attributes",(nsp_method *) _wrap_gtk_tree_view_column_clear_attributes},
  {"set_spacing",(nsp_method *) _wrap_gtk_tree_view_column_set_spacing},
  {"get_spacing",(nsp_method *) _wrap_gtk_tree_view_column_get_spacing},
  {"set_visible",(nsp_method *) _wrap_gtk_tree_view_column_set_visible},
  {"get_visible",(nsp_method *) _wrap_gtk_tree_view_column_get_visible},
  {"set_resizable",(nsp_method *) _wrap_gtk_tree_view_column_set_resizable},
  {"get_resizable",(nsp_method *) _wrap_gtk_tree_view_column_get_resizable},
  {"set_sizing",(nsp_method *) _wrap_gtk_tree_view_column_set_sizing},
  {"get_sizing",(nsp_method *) _wrap_gtk_tree_view_column_get_sizing},
  {"get_width",(nsp_method *) _wrap_gtk_tree_view_column_get_width},
  {"get_fixed_width",(nsp_method *) _wrap_gtk_tree_view_column_get_fixed_width},
  {"set_fixed_width",(nsp_method *) _wrap_gtk_tree_view_column_set_fixed_width},
  {"set_min_width",(nsp_method *) _wrap_gtk_tree_view_column_set_min_width},
  {"get_min_width",(nsp_method *) _wrap_gtk_tree_view_column_get_min_width},
  {"set_max_width",(nsp_method *) _wrap_gtk_tree_view_column_set_max_width},
  {"get_max_width",(nsp_method *) _wrap_gtk_tree_view_column_get_max_width},
  {"clicked",(nsp_method *) _wrap_gtk_tree_view_column_clicked},
  {"set_title",(nsp_method *) _wrap_gtk_tree_view_column_set_title},
  {"get_title",(nsp_method *) _wrap_gtk_tree_view_column_get_title},
  {"set_clickable",(nsp_method *) _wrap_gtk_tree_view_column_set_clickable},
  {"get_clickable",(nsp_method *) _wrap_gtk_tree_view_column_get_clickable},
  {"set_widget",(nsp_method *) _wrap_gtk_tree_view_column_set_widget},
  {"get_widget",(nsp_method *) _wrap_gtk_tree_view_column_get_widget},
  {"set_alignment",(nsp_method *) _wrap_gtk_tree_view_column_set_alignment},
  {"get_alignment",(nsp_method *) _wrap_gtk_tree_view_column_get_alignment},
  {"set_reorderable",(nsp_method *) _wrap_gtk_tree_view_column_set_reorderable},
  {"get_reorderable",(nsp_method *) _wrap_gtk_tree_view_column_get_reorderable},
  {"set_sort_column_id",(nsp_method *) _wrap_gtk_tree_view_column_set_sort_column_id},
  {"get_sort_column_id",(nsp_method *) _wrap_gtk_tree_view_column_get_sort_column_id},
  {"set_sort_indicator",(nsp_method *) _wrap_gtk_tree_view_column_set_sort_indicator},
  {"get_sort_indicator",(nsp_method *) _wrap_gtk_tree_view_column_get_sort_indicator},
  {"set_sort_order",(nsp_method *) _wrap_gtk_tree_view_column_set_sort_order},
  {"get_sort_order",(nsp_method *) _wrap_gtk_tree_view_column_get_sort_order},
  {"cell_set_cell_data",(nsp_method *) _wrap_gtk_tree_view_column_cell_set_cell_data},
  {"cell_get_size",(nsp_method *) _wrap_gtk_tree_view_column_cell_get_size},
  {"cell_is_visible",(nsp_method *) _wrap_gtk_tree_view_column_cell_is_visible},
  { NULL, NULL}
};

static NspMethods *gtktreeviewcolumn_get_methods(void) { return gtktreeviewcolumn_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreeviewcolumn_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkWidget ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkWidget_Private 
#include "nsp/gtk/gtkwidget.h"
#include "nsp/interf.h"

/* NspGtkWidget inherits from NspGtkObject */ 

int nsp_type_gtkwidget_id=0;
NspTypeGtkWidget *nsp_type_gtkwidget=NULL;

NspTypeGtkWidget *new_type_gtkwidget(type_mode mode)
{
  NspTypeGtkWidget *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkwidget != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkwidget;
    }
  if ((type =  malloc(sizeof(NspTypeGtkObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkwidget_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkwidget_get_methods; 
  type->new = (new_func *) new_gtkwidget;

  /* specific methods for gtkwidget */
      
  type->init = (init_func *) init_gtkwidget;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkwidget */ 

  top->s_type =  (s_type_func *) gtkwidget_type_as_string;    
  top->sh_type = (sh_type_func *) gtkwidget_type_short_string;
  /* top->create = (create_func*) int_gtkwidget_create;*/ 
  
  /* specific methods for gtkwidget */
      
  type->init = (init_func *) init_gtkwidget;

  if ( nsp_type_gtkwidget_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkWidget called nsp_type_gtkwidget
       */
      type->id =  nsp_type_gtkwidget_id = nsp_new_type_id();
      nsp_type_gtkwidget = type;
      if ( nsp_register_type(nsp_type_gtkwidget) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkwidget, GTK_TYPE_WIDGET);
      return ( mode == T_BASE ) ? type : new_type_gtkwidget(mode);
    }
  else 
    {
       type->id = nsp_type_gtkwidget_id;
       return type;
    }
}

/*
 * initialize GtkWidget instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkwidget(NspGtkWidget *o,NspTypeGtkWidget *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkWidget 
 */

NspGtkWidget *new_gtkwidget() 
{
  NspGtkWidget *loc; 
  /* type must exists */
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkWidget)))== NULLGTKWIDGET) return loc;
  /* initialize object */
  if ( init_gtkwidget(loc,nsp_type_gtkwidget) == FAIL) return NULLGTKWIDGET;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkWidget 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkwidget_type_name[]="GtkWidget";
static char gtkwidget_short_type_name[]="GtkWidget";

static char *gtkwidget_type_as_string(void)
{
  return(gtkwidget_type_name);
}

static char *gtkwidget_type_short_string(void)
{
  return(gtkwidget_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkWidget objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkWidget   *gtkwidget_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkwidget_id) ) return ((NspGtkWidget *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkwidget));
  return NULL;
}

int IsGtkWidgetObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkwidget_id);
}

int IsGtkWidget(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkwidget_id);
}

NspGtkWidget  *GetGtkWidgetCopy(Stack stack, int i)
{
  if (  GetGtkWidget(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkWidget  *GetGtkWidget(Stack stack, int i)
{
  NspGtkWidget *M;
  if (( M = gtkwidget_object(NthObj(i))) == NULLGTKWIDGET)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkWidget *gtkwidget_copy(NspGtkWidget *self)
{
  /* return gtkobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwidget);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwidget);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkWidget
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkWidget *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkwidget is initialized * /
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if(( H = gtkobject_create(NVOID,(NspTypeBase *) nsp_type_gtkwidget)) == NULLGTKWIDGET) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 658 "gtk.override"
extern int int_gobj_create(Stack stack,int rhs,int opt,int lhs);
static int
_wrap_gtkwidget_new(Stack stack, int rhs, int opt, int lhs)
{
  return int_gobj_create( stack, rhs, opt, lhs) ;
}

#line 18430 "gtk.c"


#line 720 "gtk.override"
static int
_wrap_gtk_widget_get_allocation(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAllocation allocation;
  NspObject *ret;
  allocation = GTK_WIDGET(self->obj)->allocation;
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &allocation, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL)
     return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 18445 "gtk.c"


static int _wrap_gtk_drag_check_threshold(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int, s_int, s_int,t_end};
  int start_x, start_y, current_x, current_y, ret;

  if ( GetArgs(stack,rhs,opt,T,&start_x, &start_y, &current_x, &current_y) == FAIL) return RET_BUG;
  ret = gtk_drag_check_threshold(GTK_WIDGET(self->obj), start_x, start_y, current_x, current_y);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_drag_get_data(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj,new_opts,t_end};
  nsp_option opts[] = {
	{"time",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *context;
  NspObject *nsp_target = NULL;
  GdkAtom target;
  gulong time = GDK_CURRENT_TIME;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdragcontext, &context, &nsp_target, opts, &time) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_target,&target)==FAIL) return RET_BUG;
  gtk_drag_get_data(GTK_WIDGET(self->obj), GDK_DRAG_CONTEXT(context->obj), target, time);
  return 0;
}

static int _wrap_gtk_drag_highlight(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_drag_highlight(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_drag_unhighlight(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_drag_unhighlight(GTK_WIDGET(self->obj));
  return 0;
}

#line 4991 "gtk.override"

static GtkTargetEntry * nsp_gtk_target_entry_from_list(Stack stack,NspList *list,int *n_targets) 
{
  int i=0;
  GtkTargetEntry *targets;
  Cell *cloc = list->first ; 

  while ( cloc != NULLCELL) {
    if ( cloc->O != NULLOBJ ) i++;
    cloc = cloc->next;
  }
  *n_targets = i; 

  if (( targets = g_new(GtkTargetEntry, *n_targets))== NULL) return targets; 
  i=0;
  cloc = list->first ; 
  while ( cloc != NULLCELL) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  if (! IsList(cloc->O) )
	    {
	      Scierror("%s: list item %d is not a list \n",stack.fname,i+1);
	      g_free(targets);
	      return NULL;
	    }
	  else 
	    {
	      NspList *loc = (NspList *)cloc->O; 
	      int_types T[] = { string,s_int,s_int, t_end} ;
	      if ( GetListArgs(loc,i+1,T, &targets[i].target,&targets[i].flags, &targets[i].info)== FAIL) 
		{
		  g_free(targets);
		  return NULL;
		}
	    }
	}
      cloc = cloc->next;
      i++;
    }
  
  return targets; 
}


static int
_wrap_gtk_drag_dest_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,list,obj, t_end} ;
  NspObject *nsp_flags, *nsp_actions;
  NspList *nsp_targets;
  GtkDestDefaults flags;
  GtkTargetEntry *targets;
  GdkDragAction actions;
  gint n_targets;

  if (GetArgs(stack,rhs,opt,T, &nsp_flags, &nsp_targets, &nsp_actions)   == FAIL) return RET_BUG;;
  if (nspg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, nsp_flags, &flags))
        return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION, nsp_actions, &actions))
    return RET_BUG;

  if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets))==NULL) return RET_BUG; 
  gtk_drag_dest_set(GTK_WIDGET(self->obj), flags, targets, n_targets,  actions);
  g_free(targets);
  return 0;
}
#line 18556 "gtk.c"


static int _wrap_gtk_drag_dest_set_proxy(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, s_bool,t_end};
  int use_coordinates;
  NspGObject *proxy_window;
  NspObject *nsp_protocol = NULL;
  GdkDragProtocol protocol;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &proxy_window, &nsp_protocol, &use_coordinates) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GDK_TYPE_DRAG_PROTOCOL, nsp_protocol, &protocol)== FAIL)
      return RET_BUG;
  gtk_drag_dest_set_proxy(GTK_WIDGET(self->obj), GDK_WINDOW(proxy_window->obj), protocol, use_coordinates);
  return 0;
}

static int _wrap_gtk_drag_dest_unset(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_drag_dest_unset(GTK_WIDGET(self->obj));
  return 0;
}

#line 5060 "gtk.override"
static int
_wrap_gtk_drag_dest_find_target(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,list, t_end} ;
  NspObject *context,*nsp_ret;
  NspList *nsp_target_list;
  gint  n_targets;
  GtkTargetEntry *targets;
  GtkTargetList *target_list;
  GdkAtom atom;

  if (GetArgs(stack,rhs,opt,T, &nsp_type_gdkdragcontext, &context, &nsp_target_list)  == FAIL) 
    return RET_BUG;;

  if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_target_list, &n_targets))==NULL) return RET_BUG; 
  target_list = gtk_target_list_new(targets, n_targets);
  g_free(targets);

  atom = gtk_drag_dest_find_target(GTK_WIDGET(self->obj),
				   GDK_DRAG_CONTEXT(nspgobject_get(context)),
				   target_list);
  gtk_target_list_unref(target_list);
  if ((nsp_ret = (NspObject *) gdkatom_create(NVOID,NULL,atom,NULL))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 18607 "gtk.c"


#line 5088 "gtk.override"
static int
_wrap_gtk_drag_dest_get_target_list(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTargetList *target_list;
  /* NspObject *ret;
  GList *tmp;
  */

  target_list = gtk_drag_dest_get_target_list(GTK_WIDGET(self->obj));

  if (!target_list) {
    return RET_BUG; 
  }
  /*
  ret = NspList_New(0);
  for (tmp = target_list->list; tmp != NULL; tmp = tmp->next) {
    GtkTargetPair *pair = tmp->data;
    NspObject *item;
    item = Nsp_BuildValue("(Nii)", (NspObject *) gdkatom_create(NVOID,NULL,pair->target,NULL),
			  pair->flags, pair->info);
    NspList_Append(ret, item);
    Nsp_DECREF(item);
  }
  gtk_target_list_unref(target_list);
  return ret;
  */
  Scierror("XXXX To be done gtk_drag_dest_get_target_list");
  return 0;
}
#line 18640 "gtk.c"


#line 5119 "gtk.override"
static int
_wrap_gtk_drag_dest_set_target_list(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "target_list", NULL };*/
  int_types T[] = {list, t_end} ;
  NspList *nsp_target_list;
  gint  n_targets;
  GtkTargetEntry *targets;
  GtkTargetList *target_list;

  if (GetArgs(stack,rhs,opt,T, &nsp_target_list) == FAIL) return RET_BUG;;

  if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_target_list, &n_targets))==NULL) return RET_BUG; 
  target_list = gtk_target_list_new(targets, n_targets);
  g_free(targets);
  gtk_drag_dest_set_target_list(GTK_WIDGET(self->obj), target_list);
  gtk_target_list_unref(target_list);
  return 0;
}
#line 18663 "gtk.c"


#line 5140 "gtk.override"
static int
_wrap_gtk_drag_source_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,list,obj, t_end} ;
  NspList  *nsp_targets;
  NspObject *nsp_sbmask, *nsp_actions;
  GdkModifierType sbmask;
  GtkTargetEntry *targets;
  GdkDragAction actions;
  gint n_targets;
  
  if (GetArgs(stack,rhs,opt,T,&nsp_sbmask, &nsp_targets, &nsp_actions) == FAIL) return RET_BUG;;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,  nsp_sbmask,&sbmask))
    return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION,  nsp_actions, &actions))
    return RET_BUG;

  if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets))==NULL) return RET_BUG; 
  gtk_drag_source_set(GTK_WIDGET(self->obj), sbmask, targets, n_targets, actions);
  g_free(targets);
  return 0;
}
#line 18689 "gtk.c"


static int _wrap_gtk_drag_source_unset(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_drag_source_unset(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_drag_source_set_icon(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check,new_opts,t_end};
  nsp_option opts[] = {
	{"mask",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  GdkBitmap *mask = NULL;
  NspGObject *colormap, *pixmap, *nsp_mask = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkcolormap, &colormap, &nsp_type_gdkpixmap, &pixmap, opts, &nsp_mask) == FAIL) return RET_BUG;
  if ( nsp_mask != NULL ) {
    if ( IsGdkBitmap((NspObject *)nsp_mask))
      mask = GDK_DRAWABLE(nsp_mask->obj);
    else if (! IsNone((NspObject *)nsp_mask)) {
         Scierror( "mask should be a GdkBitmap or None");
         return RET_BUG;
    }
  }
  gtk_drag_source_set_icon(GTK_WIDGET(self->obj), GDK_COLORMAP(colormap->obj), GDK_PIXMAP(pixmap->obj), mask);
  return 0;
}

static int _wrap_gtk_drag_source_set_icon_pixbuf(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *pixbuf;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
  gtk_drag_source_set_icon_pixbuf(GTK_WIDGET(self->obj), GDK_PIXBUF(pixbuf->obj));
  return 0;
}

static int _wrap_gtk_drag_source_set_icon_stock(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *stock_id;

  if ( GetArgs(stack,rhs,opt,T,&stock_id) == FAIL) return RET_BUG;
  gtk_drag_source_set_icon_stock(GTK_WIDGET(self->obj), stock_id);
  return 0;
}

#line 5164 "gtk.override"
static int
_wrap_gtk_drag_begin(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list,obj,s_int, obj_check, t_end} ;
  NspObject  *nsp_actions, *event,*nsp_ret;
  NspList *nsp_targets;
  GtkTargetEntry *tents;
  GtkTargetList *targets;
  GdkDragAction actions;
  gint button, n_targets;
  GdkDragContext *context;

  if (GetArgs(stack,rhs,opt,T,&nsp_targets, &nsp_actions, &button,&nsp_type_gdkevent, &event) == FAIL) return RET_BUG;;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION, nsp_actions,&actions))
    return RET_BUG;
  
  if ((tents = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets))==NULL) return RET_BUG; 
  targets = gtk_target_list_new(tents, n_targets);
  g_free(tents);
  context = gtk_drag_begin(GTK_WIDGET(self->obj), targets, actions, button,
			   nspg_boxed_get(event, GdkEvent));
  gtk_target_list_unref(targets);
  if ((nsp_ret = (NspObject *) nspgobject_new((GObject *)context))==NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 18767 "gtk.c"


static int _wrap_gtk_grab_add(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_grab_add(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_grab_remove(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_grab_remove(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_rc_get_style(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkStyle *ret;

  ret = gtk_rc_get_style(GTK_WIDGET(self->obj));
  nsp_type_gtkstyle = new_type_gtkstyle(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstyle))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_selection_owner_set(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,new_opts,t_end};
  nsp_option opts[] = {
	{"time",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int ret;
  gulong time = GDK_CURRENT_TIME;
  NspObject *nsp_selection = NULL;
  GdkAtom selection;

  if ( GetArgs(stack,rhs,opt,T,&nsp_selection, opts, &time) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection,&selection)==FAIL) return RET_BUG;
  ret = gtk_selection_owner_set(GTK_WIDGET(self->obj), selection, time);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_selection_add_target(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj, s_int,t_end};
  int info;
  NspObject *nsp_selection = NULL, *nsp_target = NULL;
  GdkAtom selection, target;

  if ( GetArgs(stack,rhs,opt,T,&nsp_selection, &nsp_target, &info) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection,&selection)==FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_target,&target)==FAIL) return RET_BUG;
  gtk_selection_add_target(GTK_WIDGET(self->obj), selection, target, info);
  return 0;
}

#line 5198 "gtk.override"
static int
_wrap_gtk_selection_add_targets(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,list, t_end} ;
  NspObject  *nsp_selection;
  NspList *nsp_targets;
  GtkTargetEntry *targets;
  GdkAtom selection;
  int n_targets;

  if (GetArgs(stack,rhs,opt,T, &nsp_selection, &nsp_targets) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection, &selection)  == FAIL) return RET_BUG;;

  if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets))==NULL) return RET_BUG; 
  gtk_selection_add_targets(GTK_WIDGET(self->obj), selection,  targets, n_targets);
  g_free(targets);
  return 0;
}
#line 18845 "gtk.c"


static int _wrap_gtk_selection_clear_targets(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_selection = NULL;
  GdkAtom selection;

  if ( GetArgs(stack,rhs,opt,T,&nsp_selection) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection,&selection)==FAIL) return RET_BUG;
  gtk_selection_clear_targets(GTK_WIDGET(self->obj), selection);
  return 0;
}

static int _wrap_gtk_selection_convert(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,new_opts,t_end};
  nsp_option opts[] = {
	{"time",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int ret;
  gulong time = GDK_CURRENT_TIME;
  NspObject *nsp_selection = NULL, *nsp_target = NULL;
  GdkAtom selection, target;

  if ( GetArgs(stack,rhs,opt,T,&nsp_selection, &nsp_target, opts, &time) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection,&selection)==FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_target,&target)==FAIL) return RET_BUG;
  ret = gtk_selection_convert(GTK_WIDGET(self->obj), selection, target, time);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_selection_remove_all(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_selection_remove_all(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_destroy(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_destroy(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_unparent(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_unparent(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_show(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_show(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_show_now(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_show_now(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_hide(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_hide(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_show_all(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_show_all(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_hide_all(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_hide_all(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_map(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_map(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_unmap(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_unmap(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_realize(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_realize(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_unrealize(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_unrealize(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_queue_draw(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_queue_draw(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_queue_draw_area(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int, s_int, s_int,t_end};
  int x, y, width, height;

  if ( GetArgs(stack,rhs,opt,T,&x, &y, &width, &height) == FAIL) return RET_BUG;
  gtk_widget_queue_draw_area(GTK_WIDGET(self->obj), x, y, width, height);
  return 0;
}

static int _wrap_gtk_widget_queue_clear(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  Scierror("%s: deprecated use GtkWidget.queue_draw",stack.fname); return RET_BUG;
  gtk_widget_queue_clear(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_queue_clear_area(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int, s_int, s_int,t_end};
  int x, y, width, height;

  if ( GetArgs(stack,rhs,opt,T,&x, &y, &width, &height) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkWidget.queue_draw_area",stack.fname); return RET_BUG;
  gtk_widget_queue_clear_area(GTK_WIDGET(self->obj), x, y, width, height);
  return 0;
}

static int _wrap_gtk_widget_queue_resize(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_queue_resize(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_draw(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GdkRectangle area = { 0, 0, 0, 0 };
  NspObject *nsp_area;

  if ( GetArgs(stack,rhs,opt,T,&nsp_area) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkWidget.queue_draw_area",stack.fname); return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_area, &area))
      return RET_BUG;
  gtk_widget_draw(GTK_WIDGET(self->obj), &area);
  return 0;
}

#line 698 "gtk.override"
static int
_wrap_gtk_widget_size_request(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkRequisition requisition;
  gtk_widget_size_request(GTK_WIDGET(self->obj), &requisition);
  if (  nsp_move_doubles(stack,1,1,2,(double) requisition.width,
			 (double) requisition.height) == FAIL) return RET_BUG; 
  return 1;
}
#line 19015 "gtk.c"


static int _wrap_gtk_widget_size_allocate(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GdkRectangle allocation = { 0, 0, 0, 0 };
  NspObject *nsp_allocation;

  if ( GetArgs(stack,rhs,opt,T,&nsp_allocation) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_allocation, &allocation))
      return RET_BUG;
  gtk_widget_size_allocate(GTK_WIDGET(self->obj), &allocation);
  return 0;
}

#line 709 "gtk.override"
static int
_wrap_gtk_widget_get_child_requisition(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkRequisition requisition;
  gtk_widget_get_child_requisition(GTK_WIDGET(self->obj), &requisition);
  if (  nsp_move_doubles(stack,1,1,2,(double) requisition.width,
			 (double) requisition.height) == FAIL) return RET_BUG; 
  return 1;
}
#line 19041 "gtk.c"


static int _wrap_gtk_widget_add_accelerator(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj_check, s_int, obj, obj,t_end};
  NspObject *nsp_accel_mods = NULL, *nsp_accel_flags = NULL;
  int accel_key;
  NspGObject *accel_group;
  GdkModifierType accel_mods;
  GtkAccelFlags accel_flags;
  char *accel_signal;

  if ( GetArgs(stack,rhs,opt,T,&accel_signal, &nsp_type_gtkaccelgroup, &accel_group, &accel_key, &nsp_accel_mods, &nsp_accel_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accel_mods, &accel_mods)==FAIL)
      return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ACCEL_FLAGS, nsp_accel_flags, &accel_flags)==FAIL)
      return RET_BUG;
  gtk_widget_add_accelerator(GTK_WIDGET(self->obj), accel_signal, GTK_ACCEL_GROUP(accel_group->obj), accel_key, accel_mods, accel_flags);
  return 0;
}

static int _wrap_gtk_widget_remove_accelerator(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int, obj,t_end};
  int accel_key, ret;
  NspGObject *accel_group;
  NspObject *nsp_accel_mods = NULL;
  GdkModifierType accel_mods;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaccelgroup, &accel_group, &accel_key, &nsp_accel_mods) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accel_mods, &accel_mods)==FAIL)
      return RET_BUG;
  ret = gtk_widget_remove_accelerator(GTK_WIDGET(self->obj), GTK_ACCEL_GROUP(accel_group->obj), accel_key, accel_mods);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_accel_path(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj_check,t_end};
  char *accel_path;
  NspGObject *accel_group;

  if ( GetArgs(stack,rhs,opt,T,&accel_path, &nsp_type_gtkaccelgroup, &accel_group) == FAIL) return RET_BUG;
  gtk_widget_set_accel_path(GTK_WIDGET(self->obj), accel_path, GTK_ACCEL_GROUP(accel_group->obj));
  return 0;
}

static int _wrap_gtk_widget_mnemonic_activate(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int group_cycling, ret;

  if ( GetArgs(stack,rhs,opt,T,&group_cycling) == FAIL) return RET_BUG;
  ret = gtk_widget_mnemonic_activate(GTK_WIDGET(self->obj), group_cycling);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_event(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GdkEvent *event = NULL;
  int ret;
  NspObject *nsp_event;

  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "event should be a GdkEvent");
      return RET_BUG;
  }
  ret = gtk_widget_event(GTK_WIDGET(self->obj), event);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_send_expose(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GdkEvent *event = NULL;
  int ret;
  NspObject *nsp_event;

  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "event should be a GdkEvent");
      return RET_BUG;
  }
  ret = gtk_widget_send_expose(GTK_WIDGET(self->obj), event);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_activate(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_widget_activate(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_scroll_adjustments(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  int ret;
  NspGObject *nsp_hadjustment, *nsp_vadjustment;
  GtkAdjustment *hadjustment = NULL, *vadjustment = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_hadjustment, &nsp_vadjustment) == FAIL) return RET_BUG;
  if ( IsGtkAdjustment((NspObject *)nsp_hadjustment))
      hadjustment = GTK_ADJUSTMENT(nsp_hadjustment->obj);
  else if ( ! IsNone((NspObject *) nsp_hadjustment))  {
      Scierror( "hadjustment should be a GtkAdjustment or None");
      return RET_BUG;
  }
  if ( IsGtkAdjustment((NspObject *)nsp_vadjustment))
      vadjustment = GTK_ADJUSTMENT(nsp_vadjustment->obj);
  else if ( ! IsNone((NspObject *) nsp_vadjustment))  {
      Scierror( "vadjustment should be a GtkAdjustment or None");
      return RET_BUG;
  }
  ret = gtk_widget_set_scroll_adjustments(GTK_WIDGET(self->obj), hadjustment, vadjustment);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_reparent(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *new_parent;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &new_parent) == FAIL) return RET_BUG;
  gtk_widget_reparent(GTK_WIDGET(self->obj), GTK_WIDGET(new_parent->obj));
  return 0;
}

#line 733 "gtk.override"
static int
_wrap_gtk_widget_intersect(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "area", NULL };*/
  NspObject *nsp_area, * ret;
  GdkRectangle area, intersect;

  if(GetArgs(stack,rhs,opt,T, &nsp_area) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_area, &area))  return RET_BUG;
  if (gtk_widget_intersect(GTK_WIDGET(self->obj), &area, &intersect))
    {
      if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &intersect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL) 
	return RET_BUG;
      MoveObj(stack,1,ret);
      return 1; 
    }
  else 
    return RET_BUG;
}
#line 19204 "gtk.c"


static int _wrap_gtk_widget_freeze_child_notify(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_freeze_child_notify(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_child_notify(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *child_property;

  if ( GetArgs(stack,rhs,opt,T,&child_property) == FAIL) return RET_BUG;
  gtk_widget_child_notify(GTK_WIDGET(self->obj), child_property);
  return 0;
}

static int _wrap_gtk_widget_thaw_child_notify(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_thaw_child_notify(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_is_focus(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_widget_is_focus(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_grab_focus(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_grab_focus(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_grab_default(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_grab_default(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_set_name(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *name;

  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
  gtk_widget_set_name(GTK_WIDGET(self->obj), name);
  return 0;
}

static int _wrap_gtk_widget_get_name(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_widget_get_name(GTK_WIDGET(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_state(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkStateType state;
  NspObject *nsp_state = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_state) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state, &state)== FAIL)
      return RET_BUG;
  gtk_widget_set_state(GTK_WIDGET(self->obj), state);
  return 0;
}

static int _wrap_gtk_widget_set_sensitive(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int sensitive;

  if ( GetArgs(stack,rhs,opt,T,&sensitive) == FAIL) return RET_BUG;
  gtk_widget_set_sensitive(GTK_WIDGET(self->obj), sensitive);
  return 0;
}

static int _wrap_gtk_widget_set_app_paintable(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int app_paintable;

  if ( GetArgs(stack,rhs,opt,T,&app_paintable) == FAIL) return RET_BUG;
  gtk_widget_set_app_paintable(GTK_WIDGET(self->obj), app_paintable);
  return 0;
}

static int _wrap_gtk_widget_set_double_buffered(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int double_buffered;

  if ( GetArgs(stack,rhs,opt,T,&double_buffered) == FAIL) return RET_BUG;
  gtk_widget_set_double_buffered(GTK_WIDGET(self->obj), double_buffered);
  return 0;
}

static int _wrap_gtk_widget_set_redraw_on_allocate(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int redraw_on_allocate;

  if ( GetArgs(stack,rhs,opt,T,&redraw_on_allocate) == FAIL) return RET_BUG;
  gtk_widget_set_redraw_on_allocate(GTK_WIDGET(self->obj), redraw_on_allocate);
  return 0;
}

static int _wrap_gtk_widget_set_parent(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *parent;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &parent) == FAIL) return RET_BUG;
  gtk_widget_set_parent(GTK_WIDGET(self->obj), GTK_WIDGET(parent->obj));
  return 0;
}

static int _wrap_gtk_widget_set_parent_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *parent_window;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &parent_window) == FAIL) return RET_BUG;
  gtk_widget_set_parent_window(GTK_WIDGET(self->obj), GDK_WINDOW(parent_window->obj));
  return 0;
}

static int _wrap_gtk_widget_set_child_visible(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int is_visible;

  if ( GetArgs(stack,rhs,opt,T,&is_visible) == FAIL) return RET_BUG;
  gtk_widget_set_child_visible(GTK_WIDGET(self->obj), is_visible);
  return 0;
}

static int _wrap_gtk_widget_get_child_visible(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_widget_get_child_visible(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 769 "gtk.override"
/* the returned value is more specific than nsp_type_gtkwidget */
static int 
_wrap_gtk_widget_get_parent(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject * ob;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&ob) == FAIL) return RET_BUG;
  ret = gtk_widget_get_parent(GTK_WIDGET(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_gettype_and_create(NVOID,(GObject *)ret))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 19379 "gtk.c"


static int _wrap_gtk_widget_get_parent_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GdkWindow *ret;

  ret = gtk_widget_get_parent_window(GTK_WIDGET(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_child_focus(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  GtkDirectionType direction;
  NspObject *nsp_direction = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_direction) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_DIRECTION_TYPE, nsp_direction, &direction)== FAIL)
      return RET_BUG;
  ret = gtk_widget_child_focus(GTK_WIDGET(self->obj), direction);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_size_request(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int width, height;

  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
  gtk_widget_set_size_request(GTK_WIDGET(self->obj), width, height);
  return 0;
}

static int _wrap_gtk_widget_get_size_request(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int width, height;

  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
  gtk_widget_get_size_request(GTK_WIDGET(self->obj), &width, &height);
  return 0;
}

static int _wrap_gtk_widget_set_uposition(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int x, y;

  if ( GetArgs(stack,rhs,opt,T,&x, &y) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_widget_set_uposition(GTK_WIDGET(self->obj), x, y);
  return 0;
}

static int _wrap_gtk_widget_set_usize(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int width, height;

  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkWidget.set_size_request",stack.fname); return RET_BUG;
  gtk_widget_set_usize(GTK_WIDGET(self->obj), width, height);
  return 0;
}

static int _wrap_gtk_widget_set_events(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int events;

  if ( GetArgs(stack,rhs,opt,T,&events) == FAIL) return RET_BUG;
  gtk_widget_set_events(GTK_WIDGET(self->obj), events);
  return 0;
}

static int _wrap_gtk_widget_add_events(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int events;

  if ( GetArgs(stack,rhs,opt,T,&events) == FAIL) return RET_BUG;
  gtk_widget_add_events(GTK_WIDGET(self->obj), events);
  return 0;
}

static int _wrap_gtk_widget_set_extension_events(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_mode = NULL;
  GdkExtensionMode mode;

  if ( GetArgs(stack,rhs,opt,T,&nsp_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GDK_TYPE_EXTENSION_MODE, nsp_mode, &mode)== FAIL)
      return RET_BUG;
  gtk_widget_set_extension_events(GTK_WIDGET(self->obj), mode);
  return 0;
}

static int _wrap_gtk_widget_get_extension_events(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_widget_get_extension_events(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 755 "gtk.override"
static int _wrap_gtk_widget_get_toplevel(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWindow *ret;

  ret = (GtkWindow *) gtk_widget_get_toplevel(GTK_WIDGET(self->obj));
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 19506 "gtk.c"


static int _wrap_gtk_widget_get_ancestor(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GType widget_type;
  NspObject *nsp_widget_type = NULL, *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_widget_type) == FAIL) return RET_BUG;
  if ((widget_type = nspg_type_from_object(nsp_widget_type)) == FAIL)
      return RET_BUG;
  ret = gtk_widget_get_ancestor(GTK_WIDGET(self->obj), widget_type);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_colormap(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GdkColormap *ret;

  ret = gtk_widget_get_colormap(GTK_WIDGET(self->obj));
  nsp_type_gdkcolormap = new_type_gdkcolormap(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkcolormap))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_visual(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GdkVisual *ret;

  ret = gtk_widget_get_visual(GTK_WIDGET(self->obj));
  nsp_type_gdkvisual = new_type_gdkvisual(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkvisual))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_screen(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GdkScreen *ret;

  ret = gtk_widget_get_screen(GTK_WIDGET(self->obj));
  nsp_type_gdkscreen = new_type_gdkscreen(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkscreen))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_has_screen(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_widget_has_screen(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_get_display(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkDisplay *ret;
  NspObject *nsp_ret;

  ret = gtk_widget_get_display(GTK_WIDGET(self->obj));
  nsp_type_gdkdisplay = new_type_gdkdisplay(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkdisplay))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_root_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GdkWindow *ret;

  ret = gtk_widget_get_root_window(GTK_WIDGET(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_settings(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkSettings *ret;

  ret = gtk_widget_get_settings(GTK_WIDGET(self->obj));
  nsp_type_gtksettings = new_type_gtksettings(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtksettings))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_accessible(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  AtkObject *ret;
  NspObject *nsp_ret;

  ret = gtk_widget_get_accessible(GTK_WIDGET(self->obj));
  nsp_type_atkobject = new_type_atkobject(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_atkobject))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_set_colormap(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *colormap;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkcolormap, &colormap) == FAIL) return RET_BUG;
  gtk_widget_set_colormap(GTK_WIDGET(self->obj), GDK_COLORMAP(colormap->obj));
  return 0;
}

static int _wrap_gtk_widget_get_events(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_widget_get_events(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 788 "gtk.override"
static int
_wrap_gtk_widget_get_pointer(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int x, y;
  gtk_widget_get_pointer(GTK_WIDGET(self->obj), &x, &y);
  if (  nsp_move_doubles(stack,1,1,2,(double) x, (double) y) == FAIL) return RET_BUG; 
  return 1;
}
#line 19647 "gtk.c"


static int _wrap_gtk_widget_is_ancestor(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  int ret;
  NspGObject *ancestor;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &ancestor) == FAIL) return RET_BUG;
  ret = gtk_widget_is_ancestor(GTK_WIDGET(self->obj), GTK_WIDGET(ancestor->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 667 "gtk.override"
static int
_wrap_gtk_widget_translate_coordinates(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "dest_widget", "src_x", "src_y", NULL };*/
  NspGObject *nsp_dest_widget;
  int src_x, src_y;
  GtkWidget *dest_widget = NULL;
  int dest_x, dest_y;

  if (GetArgs(stack,rhs,opt,T, &nsp_dest_widget, &src_x, &src_y) == FAIL) return RET_BUG;
    
  if (nspgobject_check( nsp_dest_widget, (NspTypeBase *) nsp_type_gtkwidget)) {
    dest_widget = GTK_WIDGET(nspgobject_get(nsp_dest_widget));
  } else if ( ! IsNone((NspObject *)nsp_dest_widget)) {
    Scierror("dest_widget must be a GtkWidget or None");
    return RET_BUG;
  }

  if (!gtk_widget_translate_coordinates(GTK_WIDGET(self->obj),dest_widget,src_x,src_y,&dest_x,&dest_y)) 
    {
      if ( nsp_move_doubles(stack,1,0,0) == FAIL) return RET_BUG; 
    }
  else 
    {
      if ( nsp_move_doubles(stack,1,1,2,(double) dest_x,(double) dest_y) == FAIL) return RET_BUG; 
    }
  return 1;
}
#line 19692 "gtk.c"


static int _wrap_gtk_widget_hide_on_delete(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_widget_hide_on_delete(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_style(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspGObject *nsp_style;
  GtkStyle *style = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_style) == FAIL) return RET_BUG;
  if ( IsGtkStyle((NspObject *)nsp_style))
      style = GTK_STYLE(nsp_style->obj);
  else if ( ! IsNone((NspObject *) nsp_style))  {
      Scierror( "style should be a GtkStyle or None");
      return RET_BUG;
  }
  gtk_widget_set_style(GTK_WIDGET(self->obj), style);
  return 0;
}

static int _wrap_gtk_widget_ensure_style(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_ensure_style(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_get_style(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkStyle *ret;

  ret = gtk_widget_get_style(GTK_WIDGET(self->obj));
  nsp_type_gtkstyle = new_type_gtkstyle(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstyle))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_modify_style(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *style;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkrcstyle, &style) == FAIL) return RET_BUG;
  gtk_widget_modify_style(GTK_WIDGET(self->obj), GTK_RC_STYLE(style->obj));
  return 0;
}

static int _wrap_gtk_widget_get_modifier_style(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkRcStyle *ret;
  NspObject *nsp_ret;

  ret = gtk_widget_get_modifier_style(GTK_WIDGET(self->obj));
  nsp_type_gtkrcstyle = new_type_gtkrcstyle(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkrcstyle))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_modify_fg(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkStateType state;
  NspObject *nsp_state = NULL, *nsp_color;
  GdkColor *color = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_state, &nsp_color) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state, &state)== FAIL)
      return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_COLOR))
      color = nspg_boxed_get(nsp_color, GdkColor);
  else {
      Scierror( "color should be a GdkColor");
      return RET_BUG;
  }
  gtk_widget_modify_fg(GTK_WIDGET(self->obj), state, color);
  return 0;
}

static int _wrap_gtk_widget_modify_bg(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkStateType state;
  NspObject *nsp_state = NULL, *nsp_color;
  GdkColor *color = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_state, &nsp_color) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state, &state)== FAIL)
      return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_COLOR))
      color = nspg_boxed_get(nsp_color, GdkColor);
  else {
      Scierror( "color should be a GdkColor");
      return RET_BUG;
  }
  gtk_widget_modify_bg(GTK_WIDGET(self->obj), state, color);
  return 0;
}

static int _wrap_gtk_widget_modify_text(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkStateType state;
  NspObject *nsp_state = NULL, *nsp_color;
  GdkColor *color = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_state, &nsp_color) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state, &state)== FAIL)
      return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_COLOR))
      color = nspg_boxed_get(nsp_color, GdkColor);
  else {
      Scierror( "color should be a GdkColor");
      return RET_BUG;
  }
  gtk_widget_modify_text(GTK_WIDGET(self->obj), state, color);
  return 0;
}

static int _wrap_gtk_widget_modify_base(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkStateType state;
  NspObject *nsp_state = NULL, *nsp_color;
  GdkColor *color = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_state, &nsp_color) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state, &state)== FAIL)
      return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_COLOR))
      color = nspg_boxed_get(nsp_color, GdkColor);
  else {
      Scierror( "color should be a GdkColor");
      return RET_BUG;
  }
  gtk_widget_modify_base(GTK_WIDGET(self->obj), state, color);
  return 0;
}

static int _wrap_gtk_widget_modify_font(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  PangoFontDescription *font_desc = NULL;
  NspObject *nsp_font_desc;

  if ( GetArgs(stack,rhs,opt,T,&nsp_font_desc) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_font_desc, PANGO_TYPE_FONT_DESCRIPTION))
      font_desc = nspg_boxed_get(nsp_font_desc, PangoFontDescription);
  else {
      Scierror( "font_desc should be a PangoFontDescription");
      return RET_BUG;
  }
  gtk_widget_modify_font(GTK_WIDGET(self->obj), font_desc);
  return 0;
}

static int _wrap_gtk_widget_create_pango_context(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoContext *ret;
  NspObject *nsp_ret;

  ret = gtk_widget_create_pango_context(GTK_WIDGET(self->obj));
  nsp_type_pangocontext = new_type_pangocontext(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangocontext))== NULL) return RET_BUG;
  g_object_unref(ret);
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_pango_context(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoContext *ret;
  NspObject *nsp_ret;

  ret = gtk_widget_get_pango_context(GTK_WIDGET(self->obj));
  nsp_type_pangocontext = new_type_pangocontext(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangocontext))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_create_pango_layout(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *text;
  NspObject *nsp_ret;
  PangoLayout *ret;

  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
  ret = gtk_widget_create_pango_layout(GTK_WIDGET(self->obj), text);
  nsp_type_pangolayout = new_type_pangolayout(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangolayout))== NULL) return RET_BUG;
  g_object_unref(ret);
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_render_icon(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj,new_opts,t_end};
  nsp_option opts[] = {
	{"detail",string,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  char *stock_id, *detail = NULL;
  GdkPixbuf *ret;
  GtkIconSize size;
  NspObject *nsp_size = NULL, *nsp_ret;

  if ( GetArgs(stack,rhs,opt,T,&stock_id, &nsp_size, opts, &detail) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
  ret = gtk_widget_render_icon(GTK_WIDGET(self->obj), stock_id, size, detail);
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_set_composite_name(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *name;

  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
  gtk_widget_set_composite_name(GTK_WIDGET(self->obj), name);
  return 0;
}

static int _wrap_gtk_widget_get_composite_name(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;

  ret = gtk_widget_get_composite_name(GTK_WIDGET(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_widget_reset_rc_styles(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_reset_rc_styles(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_set_direction(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTextDirection dir;
  NspObject *nsp_dir = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_dir) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, nsp_dir, &dir)== FAIL)
      return RET_BUG;
  gtk_widget_set_direction(GTK_WIDGET(self->obj), dir);
  return 0;
}

static int _wrap_gtk_widget_get_direction(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_widget_get_direction(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_shape_combine_mask(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int, s_int,t_end};
  int offset_x, offset_y;
  NspGObject *shape_mask;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkbitmap, &shape_mask, &offset_x, &offset_y) == FAIL) return RET_BUG;
  gtk_widget_shape_combine_mask(GTK_WIDGET(self->obj), GDK_DRAWABLE(shape_mask->obj), offset_x, offset_y);
  return 0;
}

static int _wrap_gtk_widget_reset_shapes(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_widget_reset_shapes(GTK_WIDGET(self->obj));
  return 0;
}

#line 798 "gtk.override"
static int
_wrap_gtk_widget_path(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  guint length;
  gchar *path;
  gchar *path_reversed;
  NspObject *result;

  gtk_widget_path(GTK_WIDGET(self->obj), &length, &path, &path_reversed);
  result = nsp_new_string_obj(NVOID,path,-1);
  g_free(path);
  g_free(path_reversed);
  MoveObj(stack,1, result);
  return 1;
}
#line 20001 "gtk.c"


#line 815 "gtk.override"
static int
_wrap_gtk_widget_class_path(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  guint length;
  gchar *path;
  gchar *path_reversed;
  NspObject *result;

  gtk_widget_class_path(GTK_WIDGET(self->obj), &length, &path,	&path_reversed);
  result = nsp_new_string_obj(NVOID,path,-1);
  g_free(path);
  g_free(path_reversed);
  MoveObj(stack,1,result);
  return 1;
}
#line 20020 "gtk.c"


static NspMethods gtkwidget_methods[] = {
  {"get_allocation",(nsp_method *) _wrap_gtk_widget_get_allocation},
  {"drag_check_threshold",(nsp_method *) _wrap_gtk_drag_check_threshold},
  {"drag_get_data",(nsp_method *) _wrap_gtk_drag_get_data},
  {"drag_highlight",(nsp_method *) _wrap_gtk_drag_highlight},
  {"drag_unhighlight",(nsp_method *) _wrap_gtk_drag_unhighlight},
  {"drag_dest_set",(nsp_method *) _wrap_gtk_drag_dest_set},
  {"drag_dest_set_proxy",(nsp_method *) _wrap_gtk_drag_dest_set_proxy},
  {"drag_dest_unset",(nsp_method *) _wrap_gtk_drag_dest_unset},
  {"drag_dest_find_target",(nsp_method *) _wrap_gtk_drag_dest_find_target},
  {"drag_dest_get_target_list",(nsp_method *) _wrap_gtk_drag_dest_get_target_list},
  {"drag_dest_set_target_list",(nsp_method *) _wrap_gtk_drag_dest_set_target_list},
  {"drag_source_set",(nsp_method *) _wrap_gtk_drag_source_set},
  {"drag_source_unset",(nsp_method *) _wrap_gtk_drag_source_unset},
  {"drag_source_set_icon",(nsp_method *) _wrap_gtk_drag_source_set_icon},
  {"drag_source_set_icon_pixbuf",(nsp_method *) _wrap_gtk_drag_source_set_icon_pixbuf},
  {"drag_source_set_icon_stock",(nsp_method *) _wrap_gtk_drag_source_set_icon_stock},
  {"drag_begin",(nsp_method *) _wrap_gtk_drag_begin},
  {"grab_add",(nsp_method *) _wrap_gtk_grab_add},
  {"grab_remove",(nsp_method *) _wrap_gtk_grab_remove},
  {"rc_get_style",(nsp_method *) _wrap_gtk_rc_get_style},
  {"selection_owner_set",(nsp_method *) _wrap_gtk_selection_owner_set},
  {"selection_add_target",(nsp_method *) _wrap_gtk_selection_add_target},
  {"selection_add_targets",(nsp_method *) _wrap_gtk_selection_add_targets},
  {"selection_clear_targets",(nsp_method *) _wrap_gtk_selection_clear_targets},
  {"selection_convert",(nsp_method *) _wrap_gtk_selection_convert},
  {"selection_remove_all",(nsp_method *) _wrap_gtk_selection_remove_all},
  {"destroy",(nsp_method *) _wrap_gtk_widget_destroy},
  {"unparent",(nsp_method *) _wrap_gtk_widget_unparent},
  {"show",(nsp_method *) _wrap_gtk_widget_show},
  {"show_now",(nsp_method *) _wrap_gtk_widget_show_now},
  {"hide",(nsp_method *) _wrap_gtk_widget_hide},
  {"show_all",(nsp_method *) _wrap_gtk_widget_show_all},
  {"hide_all",(nsp_method *) _wrap_gtk_widget_hide_all},
  {"map",(nsp_method *) _wrap_gtk_widget_map},
  {"unmap",(nsp_method *) _wrap_gtk_widget_unmap},
  {"realize",(nsp_method *) _wrap_gtk_widget_realize},
  {"unrealize",(nsp_method *) _wrap_gtk_widget_unrealize},
  {"queue_draw",(nsp_method *) _wrap_gtk_widget_queue_draw},
  {"queue_draw_area",(nsp_method *) _wrap_gtk_widget_queue_draw_area},
  {"queue_clear",(nsp_method *) _wrap_gtk_widget_queue_clear},
  {"queue_clear_area",(nsp_method *) _wrap_gtk_widget_queue_clear_area},
  {"queue_resize",(nsp_method *) _wrap_gtk_widget_queue_resize},
  {"draw",(nsp_method *) _wrap_gtk_widget_draw},
  {"size_request",(nsp_method *) _wrap_gtk_widget_size_request},
  {"size_allocate",(nsp_method *) _wrap_gtk_widget_size_allocate},
  {"get_child_requisition",(nsp_method *) _wrap_gtk_widget_get_child_requisition},
  {"add_accelerator",(nsp_method *) _wrap_gtk_widget_add_accelerator},
  {"remove_accelerator",(nsp_method *) _wrap_gtk_widget_remove_accelerator},
  {"set_accel_path",(nsp_method *) _wrap_gtk_widget_set_accel_path},
  {"mnemonic_activate",(nsp_method *) _wrap_gtk_widget_mnemonic_activate},
  {"event",(nsp_method *) _wrap_gtk_widget_event},
  {"send_expose",(nsp_method *) _wrap_gtk_widget_send_expose},
  {"activate",(nsp_method *) _wrap_gtk_widget_activate},
  {"set_scroll_adjustments",(nsp_method *) _wrap_gtk_widget_set_scroll_adjustments},
  {"reparent",(nsp_method *) _wrap_gtk_widget_reparent},
  {"intersect",(nsp_method *) _wrap_gtk_widget_intersect},
  {"freeze_child_notify",(nsp_method *) _wrap_gtk_widget_freeze_child_notify},
  {"child_notify",(nsp_method *) _wrap_gtk_widget_child_notify},
  {"thaw_child_notify",(nsp_method *) _wrap_gtk_widget_thaw_child_notify},
  {"is_focus",(nsp_method *) _wrap_gtk_widget_is_focus},
  {"grab_focus",(nsp_method *) _wrap_gtk_widget_grab_focus},
  {"grab_default",(nsp_method *) _wrap_gtk_widget_grab_default},
  {"set_name",(nsp_method *) _wrap_gtk_widget_set_name},
  {"get_name",(nsp_method *) _wrap_gtk_widget_get_name},
  {"set_state",(nsp_method *) _wrap_gtk_widget_set_state},
  {"set_sensitive",(nsp_method *) _wrap_gtk_widget_set_sensitive},
  {"set_app_paintable",(nsp_method *) _wrap_gtk_widget_set_app_paintable},
  {"set_double_buffered",(nsp_method *) _wrap_gtk_widget_set_double_buffered},
  {"set_redraw_on_allocate",(nsp_method *) _wrap_gtk_widget_set_redraw_on_allocate},
  {"set_parent",(nsp_method *) _wrap_gtk_widget_set_parent},
  {"set_parent_window",(nsp_method *) _wrap_gtk_widget_set_parent_window},
  {"set_child_visible",(nsp_method *) _wrap_gtk_widget_set_child_visible},
  {"get_child_visible",(nsp_method *) _wrap_gtk_widget_get_child_visible},
  {"get_parent",(nsp_method *) _wrap_gtk_widget_get_parent},
  {"get_parent_window",(nsp_method *) _wrap_gtk_widget_get_parent_window},
  {"child_focus",(nsp_method *) _wrap_gtk_widget_child_focus},
  {"set_size_request",(nsp_method *) _wrap_gtk_widget_set_size_request},
  {"get_size_request",(nsp_method *) _wrap_gtk_widget_get_size_request},
  {"set_uposition",(nsp_method *) _wrap_gtk_widget_set_uposition},
  {"set_usize",(nsp_method *) _wrap_gtk_widget_set_usize},
  {"set_events",(nsp_method *) _wrap_gtk_widget_set_events},
  {"add_events",(nsp_method *) _wrap_gtk_widget_add_events},
  {"set_extension_events",(nsp_method *) _wrap_gtk_widget_set_extension_events},
  {"get_extension_events",(nsp_method *) _wrap_gtk_widget_get_extension_events},
  {"get_toplevel",(nsp_method *) _wrap_gtk_widget_get_toplevel},
  {"get_ancestor",(nsp_method *) _wrap_gtk_widget_get_ancestor},
  {"get_colormap",(nsp_method *) _wrap_gtk_widget_get_colormap},
  {"get_visual",(nsp_method *) _wrap_gtk_widget_get_visual},
  {"get_screen",(nsp_method *) _wrap_gtk_widget_get_screen},
  {"has_screen",(nsp_method *) _wrap_gtk_widget_has_screen},
  {"get_display",(nsp_method *) _wrap_gtk_widget_get_display},
  {"get_root_window",(nsp_method *) _wrap_gtk_widget_get_root_window},
  {"get_settings",(nsp_method *) _wrap_gtk_widget_get_settings},
  {"get_accessible",(nsp_method *) _wrap_gtk_widget_get_accessible},
  {"set_colormap",(nsp_method *) _wrap_gtk_widget_set_colormap},
  {"get_events",(nsp_method *) _wrap_gtk_widget_get_events},
  {"get_pointer",(nsp_method *) _wrap_gtk_widget_get_pointer},
  {"is_ancestor",(nsp_method *) _wrap_gtk_widget_is_ancestor},
  {"translate_coordinates",(nsp_method *) _wrap_gtk_widget_translate_coordinates},
  {"hide_on_delete",(nsp_method *) _wrap_gtk_widget_hide_on_delete},
  {"set_style",(nsp_method *) _wrap_gtk_widget_set_style},
  {"ensure_style",(nsp_method *) _wrap_gtk_widget_ensure_style},
  {"get_style",(nsp_method *) _wrap_gtk_widget_get_style},
  {"modify_style",(nsp_method *) _wrap_gtk_widget_modify_style},
  {"get_modifier_style",(nsp_method *) _wrap_gtk_widget_get_modifier_style},
  {"modify_fg",(nsp_method *) _wrap_gtk_widget_modify_fg},
  {"modify_bg",(nsp_method *) _wrap_gtk_widget_modify_bg},
  {"modify_text",(nsp_method *) _wrap_gtk_widget_modify_text},
  {"modify_base",(nsp_method *) _wrap_gtk_widget_modify_base},
  {"modify_font",(nsp_method *) _wrap_gtk_widget_modify_font},
  {"create_pango_context",(nsp_method *) _wrap_gtk_widget_create_pango_context},
  {"get_pango_context",(nsp_method *) _wrap_gtk_widget_get_pango_context},
  {"create_pango_layout",(nsp_method *) _wrap_gtk_widget_create_pango_layout},
  {"render_icon",(nsp_method *) _wrap_gtk_widget_render_icon},
  {"set_composite_name",(nsp_method *) _wrap_gtk_widget_set_composite_name},
  {"get_composite_name",(nsp_method *) _wrap_gtk_widget_get_composite_name},
  {"reset_rc_styles",(nsp_method *) _wrap_gtk_widget_reset_rc_styles},
  {"set_direction",(nsp_method *) _wrap_gtk_widget_set_direction},
  {"get_direction",(nsp_method *) _wrap_gtk_widget_get_direction},
  {"shape_combine_mask",(nsp_method *) _wrap_gtk_widget_shape_combine_mask},
  {"reset_shapes",(nsp_method *) _wrap_gtk_widget_reset_shapes},
  {"path",(nsp_method *) _wrap_gtk_widget_path},
  {"class_path",(nsp_method *) _wrap_gtk_widget_class_path},
  { NULL, NULL}
};

static NspMethods *gtkwidget_get_methods(void) { return gtkwidget_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_widget__get_state(NspObject *self,char *attr)
{
  int ret;

  ret = (guint8) GTK_WIDGET(NSP_GOBJECT_GET(self))->state;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_widget__get_saved_state(NspObject *self,char *attr)
{
  int ret;

  ret = (guint8) GTK_WIDGET(NSP_GOBJECT_GET(self))->saved_state;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_widget__get_name(NspObject *self,char *attr)
{
  const gchar *ret;
  NspObject *nsp_ret;

  ret = (gchar*) GTK_WIDGET(NSP_GOBJECT_GET(self))->name;
  nsp_ret = nsp_new_string_obj(NVOID,ret,-1);
  return nsp_ret;
}

static NspObject *_wrap_gtk_widget__get_style(NspObject *self,char *attr)
{
  GtkStyle *ret;

  ret = (GtkStyle*) GTK_WIDGET(NSP_GOBJECT_GET(self))->style;
  nsp_type_gtkstyle = new_type_gtkstyle(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstyle);
}

static NspObject *_wrap_gtk_widget__get_allocation(NspObject *self,char *attr)
{
  GdkRectangle ret;

  ret = (GdkRectangle) GTK_WIDGET(NSP_GOBJECT_GET(self))->allocation;
  return (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &ret, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle);
}

static NspObject *_wrap_gtk_widget__get_window(NspObject *self,char *attr)
{
  GdkWindow *ret;

  ret = (GdkWindow*) GTK_WIDGET(NSP_GOBJECT_GET(self))->window;
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow);
}

static NspObject *_wrap_gtk_widget__get_parent(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_WIDGET(NSP_GOBJECT_GET(self))->parent;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static AttrTab gtkwidget_attrs[] = {
  { "state", (attr_get_function *)_wrap_gtk_widget__get_state, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "saved_state", (attr_get_function *)_wrap_gtk_widget__get_saved_state, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "name", (attr_get_function *)_wrap_gtk_widget__get_name, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "style", (attr_get_function *)_wrap_gtk_widget__get_style, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "allocation", (attr_get_function *)_wrap_gtk_widget__get_allocation, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "window", (attr_get_function *)_wrap_gtk_widget__get_window, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "parent", (attr_get_function *)_wrap_gtk_widget__get_parent, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkSeparator ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkSeparator_Private 
#include "nsp/gtk/gtkseparator.h"
#include "nsp/interf.h"

/* NspGtkSeparator inherits from NspGtkWidget */ 

int nsp_type_gtkseparator_id=0;
NspTypeGtkSeparator *nsp_type_gtkseparator=NULL;

NspTypeGtkSeparator *new_type_gtkseparator(type_mode mode)
{
  NspTypeGtkSeparator *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkseparator != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkseparator;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkseparator_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkseparator_get_methods; 
  type->new = (new_func *) new_gtkseparator;

  /* specific methods for gtkseparator */
      
  type->init = (init_func *) init_gtkseparator;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkseparator */ 

  top->s_type =  (s_type_func *) gtkseparator_type_as_string;    
  top->sh_type = (sh_type_func *) gtkseparator_type_short_string;
  /* top->create = (create_func*) int_gtkseparator_create;*/ 
  
  /* specific methods for gtkseparator */
      
  type->init = (init_func *) init_gtkseparator;

  if ( nsp_type_gtkseparator_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSeparator called nsp_type_gtkseparator
       */
      type->id =  nsp_type_gtkseparator_id = nsp_new_type_id();
      nsp_type_gtkseparator = type;
      if ( nsp_register_type(nsp_type_gtkseparator) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkseparator, GTK_TYPE_SEPARATOR);
      return ( mode == T_BASE ) ? type : new_type_gtkseparator(mode);
    }
  else 
    {
       type->id = nsp_type_gtkseparator_id;
       return type;
    }
}

/*
 * initialize GtkSeparator instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkseparator(NspGtkSeparator *o,NspTypeGtkSeparator *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkSeparator 
 */

NspGtkSeparator *new_gtkseparator() 
{
  NspGtkSeparator *loc; 
  /* type must exists */
  nsp_type_gtkseparator = new_type_gtkseparator(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSeparator)))== NULLGTKSEPARATOR) return loc;
  /* initialize object */
  if ( init_gtkseparator(loc,nsp_type_gtkseparator) == FAIL) return NULLGTKSEPARATOR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkSeparator 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkseparator_type_name[]="GtkSeparator";
static char gtkseparator_short_type_name[]="GtkSeparator";

static char *gtkseparator_type_as_string(void)
{
  return(gtkseparator_type_name);
}

static char *gtkseparator_type_short_string(void)
{
  return(gtkseparator_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkSeparator objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkSeparator   *gtkseparator_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkseparator_id) ) return ((NspGtkSeparator *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkseparator));
  return NULL;
}

int IsGtkSeparatorObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkseparator_id);
}

int IsGtkSeparator(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkseparator_id);
}

NspGtkSeparator  *GetGtkSeparatorCopy(Stack stack, int i)
{
  if (  GetGtkSeparator(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSeparator  *GetGtkSeparator(Stack stack, int i)
{
  NspGtkSeparator *M;
  if (( M = gtkseparator_object(NthObj(i))) == NULLGTKSEPARATOR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSeparator *gtkseparator_copy(NspGtkSeparator *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkseparator);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkseparator);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSeparator
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkSeparator *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkseparator is initialized * /
  nsp_type_gtkseparator = new_type_gtkseparator(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkseparator)) == NULLGTKSEPARATOR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static NspMethods *gtkseparator_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkseparator_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkVSeparator ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkVSeparator_Private 
#include "nsp/gtk/gtkvseparator.h"
#include "nsp/interf.h"

/* NspGtkVSeparator inherits from NspGtkSeparator */ 

int nsp_type_gtkvseparator_id=0;
NspTypeGtkVSeparator *nsp_type_gtkvseparator=NULL;

NspTypeGtkVSeparator *new_type_gtkvseparator(type_mode mode)
{
  NspTypeGtkVSeparator *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkvseparator != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkvseparator;
    }
  if ((type =  malloc(sizeof(NspTypeGtkSeparator))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkseparator(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkvseparator_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkvseparator_get_methods; 
  type->new = (new_func *) new_gtkvseparator;

  /* specific methods for gtkvseparator */
      
  type->init = (init_func *) init_gtkvseparator;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkvseparator */ 

  top->s_type =  (s_type_func *) gtkvseparator_type_as_string;    
  top->sh_type = (sh_type_func *) gtkvseparator_type_short_string;
  /* top->create = (create_func*) int_gtkvseparator_create;*/ 
  
  /* specific methods for gtkvseparator */
      
  type->init = (init_func *) init_gtkvseparator;

  if ( nsp_type_gtkvseparator_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkVSeparator called nsp_type_gtkvseparator
       */
      type->id =  nsp_type_gtkvseparator_id = nsp_new_type_id();
      nsp_type_gtkvseparator = type;
      if ( nsp_register_type(nsp_type_gtkvseparator) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkvseparator, GTK_TYPE_VSEPARATOR);
      return ( mode == T_BASE ) ? type : new_type_gtkvseparator(mode);
    }
  else 
    {
       type->id = nsp_type_gtkvseparator_id;
       return type;
    }
}

/*
 * initialize GtkVSeparator instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkvseparator(NspGtkVSeparator *o,NspTypeGtkVSeparator *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkVSeparator 
 */

NspGtkVSeparator *new_gtkvseparator() 
{
  NspGtkVSeparator *loc; 
  /* type must exists */
  nsp_type_gtkvseparator = new_type_gtkvseparator(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkVSeparator)))== NULLGTKVSEPARATOR) return loc;
  /* initialize object */
  if ( init_gtkvseparator(loc,nsp_type_gtkvseparator) == FAIL) return NULLGTKVSEPARATOR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkVSeparator 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkvseparator_type_name[]="GtkVSeparator";
static char gtkvseparator_short_type_name[]="GtkVSeparator";

static char *gtkvseparator_type_as_string(void)
{
  return(gtkvseparator_type_name);
}

static char *gtkvseparator_type_short_string(void)
{
  return(gtkvseparator_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkVSeparator objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkVSeparator   *gtkvseparator_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkvseparator_id) ) return ((NspGtkVSeparator *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkvseparator));
  return NULL;
}

int IsGtkVSeparatorObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkvseparator_id);
}

int IsGtkVSeparator(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkvseparator_id);
}

NspGtkVSeparator  *GetGtkVSeparatorCopy(Stack stack, int i)
{
  if (  GetGtkVSeparator(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkVSeparator  *GetGtkVSeparator(Stack stack, int i)
{
  NspGtkVSeparator *M;
  if (( M = gtkvseparator_object(NthObj(i))) == NULLGTKVSEPARATOR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkVSeparator *gtkvseparator_copy(NspGtkVSeparator *self)
{
  /* return gtkseparator_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvseparator);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvseparator);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkVSeparator
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkVSeparator *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkvseparator is initialized * /
  nsp_type_gtkvseparator = new_type_gtkvseparator(T_BASE);
  if(( H = gtkseparator_create(NVOID,(NspTypeBase *) nsp_type_gtkvseparator)) == NULLGTKVSEPARATOR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkvseparator_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_vseparator_new())== NULL) return RET_BUG;

  nsp_type_gtkvseparator = new_type_gtkvseparator(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkvseparator );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkvseparator_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkvseparator_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkHSeparator ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkHSeparator_Private 
#include "nsp/gtk/gtkhseparator.h"
#include "nsp/interf.h"

/* NspGtkHSeparator inherits from NspGtkSeparator */ 

int nsp_type_gtkhseparator_id=0;
NspTypeGtkHSeparator *nsp_type_gtkhseparator=NULL;

NspTypeGtkHSeparator *new_type_gtkhseparator(type_mode mode)
{
  NspTypeGtkHSeparator *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkhseparator != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkhseparator;
    }
  if ((type =  malloc(sizeof(NspTypeGtkSeparator))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkseparator(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkhseparator_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkhseparator_get_methods; 
  type->new = (new_func *) new_gtkhseparator;

  /* specific methods for gtkhseparator */
      
  type->init = (init_func *) init_gtkhseparator;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkhseparator */ 

  top->s_type =  (s_type_func *) gtkhseparator_type_as_string;    
  top->sh_type = (sh_type_func *) gtkhseparator_type_short_string;
  /* top->create = (create_func*) int_gtkhseparator_create;*/ 
  
  /* specific methods for gtkhseparator */
      
  type->init = (init_func *) init_gtkhseparator;

  if ( nsp_type_gtkhseparator_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkHSeparator called nsp_type_gtkhseparator
       */
      type->id =  nsp_type_gtkhseparator_id = nsp_new_type_id();
      nsp_type_gtkhseparator = type;
      if ( nsp_register_type(nsp_type_gtkhseparator) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkhseparator, GTK_TYPE_HSEPARATOR);
      return ( mode == T_BASE ) ? type : new_type_gtkhseparator(mode);
    }
  else 
    {
       type->id = nsp_type_gtkhseparator_id;
       return type;
    }
}

/*
 * initialize GtkHSeparator instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkhseparator(NspGtkHSeparator *o,NspTypeGtkHSeparator *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkHSeparator 
 */

NspGtkHSeparator *new_gtkhseparator() 
{
  NspGtkHSeparator *loc; 
  /* type must exists */
  nsp_type_gtkhseparator = new_type_gtkhseparator(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkHSeparator)))== NULLGTKHSEPARATOR) return loc;
  /* initialize object */
  if ( init_gtkhseparator(loc,nsp_type_gtkhseparator) == FAIL) return NULLGTKHSEPARATOR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkHSeparator 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkhseparator_type_name[]="GtkHSeparator";
static char gtkhseparator_short_type_name[]="GtkHSeparator";

static char *gtkhseparator_type_as_string(void)
{
  return(gtkhseparator_type_name);
}

static char *gtkhseparator_type_short_string(void)
{
  return(gtkhseparator_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkHSeparator objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkHSeparator   *gtkhseparator_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkhseparator_id) ) return ((NspGtkHSeparator *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkhseparator));
  return NULL;
}

int IsGtkHSeparatorObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkhseparator_id);
}

int IsGtkHSeparator(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkhseparator_id);
}

NspGtkHSeparator  *GetGtkHSeparatorCopy(Stack stack, int i)
{
  if (  GetGtkHSeparator(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkHSeparator  *GetGtkHSeparator(Stack stack, int i)
{
  NspGtkHSeparator *M;
  if (( M = gtkhseparator_object(NthObj(i))) == NULLGTKHSEPARATOR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkHSeparator *gtkhseparator_copy(NspGtkHSeparator *self)
{
  /* return gtkseparator_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhseparator);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhseparator);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkHSeparator
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkHSeparator *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkhseparator is initialized * /
  nsp_type_gtkhseparator = new_type_gtkhseparator(T_BASE);
  if(( H = gtkseparator_create(NVOID,(NspTypeBase *) nsp_type_gtkhseparator)) == NULLGTKHSEPARATOR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkhseparator_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_hseparator_new())== NULL) return RET_BUG;

  nsp_type_gtkhseparator = new_type_gtkhseparator(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkhseparator );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkhseparator_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkhseparator_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkRuler ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkRuler_Private 
#include "nsp/gtk/gtkruler.h"
#include "nsp/interf.h"

/* NspGtkRuler inherits from NspGtkWidget */ 

int nsp_type_gtkruler_id=0;
NspTypeGtkRuler *nsp_type_gtkruler=NULL;

NspTypeGtkRuler *new_type_gtkruler(type_mode mode)
{
  NspTypeGtkRuler *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkruler != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkruler;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkruler_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkruler_get_methods; 
  type->new = (new_func *) new_gtkruler;

  /* specific methods for gtkruler */
      
  type->init = (init_func *) init_gtkruler;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkruler */ 

  top->s_type =  (s_type_func *) gtkruler_type_as_string;    
  top->sh_type = (sh_type_func *) gtkruler_type_short_string;
  /* top->create = (create_func*) int_gtkruler_create;*/ 
  
  /* specific methods for gtkruler */
      
  type->init = (init_func *) init_gtkruler;

  if ( nsp_type_gtkruler_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRuler called nsp_type_gtkruler
       */
      type->id =  nsp_type_gtkruler_id = nsp_new_type_id();
      nsp_type_gtkruler = type;
      if ( nsp_register_type(nsp_type_gtkruler) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkruler, GTK_TYPE_RULER);
      return ( mode == T_BASE ) ? type : new_type_gtkruler(mode);
    }
  else 
    {
       type->id = nsp_type_gtkruler_id;
       return type;
    }
}

/*
 * initialize GtkRuler instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkruler(NspGtkRuler *o,NspTypeGtkRuler *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkRuler 
 */

NspGtkRuler *new_gtkruler() 
{
  NspGtkRuler *loc; 
  /* type must exists */
  nsp_type_gtkruler = new_type_gtkruler(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRuler)))== NULLGTKRULER) return loc;
  /* initialize object */
  if ( init_gtkruler(loc,nsp_type_gtkruler) == FAIL) return NULLGTKRULER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkRuler 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkruler_type_name[]="GtkRuler";
static char gtkruler_short_type_name[]="GtkRuler";

static char *gtkruler_type_as_string(void)
{
  return(gtkruler_type_name);
}

static char *gtkruler_type_short_string(void)
{
  return(gtkruler_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkRuler objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkRuler   *gtkruler_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkruler_id) ) return ((NspGtkRuler *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkruler));
  return NULL;
}

int IsGtkRulerObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkruler_id);
}

int IsGtkRuler(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkruler_id);
}

NspGtkRuler  *GetGtkRulerCopy(Stack stack, int i)
{
  if (  GetGtkRuler(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRuler  *GetGtkRuler(Stack stack, int i)
{
  NspGtkRuler *M;
  if (( M = gtkruler_object(NthObj(i))) == NULLGTKRULER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRuler *gtkruler_copy(NspGtkRuler *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkruler);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkruler);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRuler
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkRuler *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkruler is initialized * /
  nsp_type_gtkruler = new_type_gtkruler(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkruler)) == NULLGTKRULER) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_ruler_set_metric(NspGtkRuler *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkMetricType metric;
  NspObject *nsp_metric = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_metric) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_METRIC_TYPE, nsp_metric, &metric)== FAIL)
      return RET_BUG;
  gtk_ruler_set_metric(GTK_RULER(self->obj), metric);
  return 0;
}

static int _wrap_gtk_ruler_set_range(NspGtkRuler *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, s_double, s_double, s_double,t_end};
  double lower, upper, position, max_size;

  if ( GetArgs(stack,rhs,opt,T,&lower, &upper, &position, &max_size) == FAIL) return RET_BUG;
  gtk_ruler_set_range(GTK_RULER(self->obj), lower, upper, position, max_size);
  return 0;
}

static int _wrap_gtk_ruler_draw_ticks(NspGtkRuler *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_ruler_draw_ticks(GTK_RULER(self->obj));
  return 0;
}

static int _wrap_gtk_ruler_draw_pos(NspGtkRuler *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_ruler_draw_pos(GTK_RULER(self->obj));
  return 0;
}

static int _wrap_gtk_ruler_get_metric(NspGtkRuler *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_ruler_get_metric(GTK_RULER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 6217 "gtk.override"
static int
_wrap_gtk_ruler_get_range(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gdouble lower, upper, position, max_size;

  gtk_ruler_get_range(GTK_RULER(self->obj), &lower, &upper, &position,
		      &max_size);
  if ( nsp_move_doubles(stack,1,1,4,(double) lower,(double) upper,(double) position,(double) max_size ) == FAIL) return RET_BUG; 
  return 1;
}
#line 21108 "gtk.c"


static NspMethods gtkruler_methods[] = {
  {"set_metric",(nsp_method *) _wrap_gtk_ruler_set_metric},
  {"set_range",(nsp_method *) _wrap_gtk_ruler_set_range},
  {"draw_ticks",(nsp_method *) _wrap_gtk_ruler_draw_ticks},
  {"draw_pos",(nsp_method *) _wrap_gtk_ruler_draw_pos},
  {"get_metric",(nsp_method *) _wrap_gtk_ruler_get_metric},
  {"get_range",(nsp_method *) _wrap_gtk_ruler_get_range},
  { NULL, NULL}
};

static NspMethods *gtkruler_get_methods(void) { return gtkruler_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkruler_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkVRuler ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkVRuler_Private 
#include "nsp/gtk/gtkvruler.h"
#include "nsp/interf.h"

/* NspGtkVRuler inherits from NspGtkRuler */ 

int nsp_type_gtkvruler_id=0;
NspTypeGtkVRuler *nsp_type_gtkvruler=NULL;

NspTypeGtkVRuler *new_type_gtkvruler(type_mode mode)
{
  NspTypeGtkVRuler *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkvruler != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkvruler;
    }
  if ((type =  malloc(sizeof(NspTypeGtkRuler))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkruler(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkvruler_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkvruler_get_methods; 
  type->new = (new_func *) new_gtkvruler;

  /* specific methods for gtkvruler */
      
  type->init = (init_func *) init_gtkvruler;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkvruler */ 

  top->s_type =  (s_type_func *) gtkvruler_type_as_string;    
  top->sh_type = (sh_type_func *) gtkvruler_type_short_string;
  /* top->create = (create_func*) int_gtkvruler_create;*/ 
  
  /* specific methods for gtkvruler */
      
  type->init = (init_func *) init_gtkvruler;

  if ( nsp_type_gtkvruler_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkVRuler called nsp_type_gtkvruler
       */
      type->id =  nsp_type_gtkvruler_id = nsp_new_type_id();
      nsp_type_gtkvruler = type;
      if ( nsp_register_type(nsp_type_gtkvruler) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkvruler, GTK_TYPE_VRULER);
      return ( mode == T_BASE ) ? type : new_type_gtkvruler(mode);
    }
  else 
    {
       type->id = nsp_type_gtkvruler_id;
       return type;
    }
}

/*
 * initialize GtkVRuler instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkvruler(NspGtkVRuler *o,NspTypeGtkVRuler *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkVRuler 
 */

NspGtkVRuler *new_gtkvruler() 
{
  NspGtkVRuler *loc; 
  /* type must exists */
  nsp_type_gtkvruler = new_type_gtkvruler(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkVRuler)))== NULLGTKVRULER) return loc;
  /* initialize object */
  if ( init_gtkvruler(loc,nsp_type_gtkvruler) == FAIL) return NULLGTKVRULER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkVRuler 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkvruler_type_name[]="GtkVRuler";
static char gtkvruler_short_type_name[]="GtkVRuler";

static char *gtkvruler_type_as_string(void)
{
  return(gtkvruler_type_name);
}

static char *gtkvruler_type_short_string(void)
{
  return(gtkvruler_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkVRuler objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkVRuler   *gtkvruler_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkvruler_id) ) return ((NspGtkVRuler *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkvruler));
  return NULL;
}

int IsGtkVRulerObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkvruler_id);
}

int IsGtkVRuler(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkvruler_id);
}

NspGtkVRuler  *GetGtkVRulerCopy(Stack stack, int i)
{
  if (  GetGtkVRuler(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkVRuler  *GetGtkVRuler(Stack stack, int i)
{
  NspGtkVRuler *M;
  if (( M = gtkvruler_object(NthObj(i))) == NULLGTKVRULER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkVRuler *gtkvruler_copy(NspGtkVRuler *self)
{
  /* return gtkruler_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvruler);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvruler);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkVRuler
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkVRuler *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkvruler is initialized * /
  nsp_type_gtkvruler = new_type_gtkvruler(T_BASE);
  if(( H = gtkruler_create(NVOID,(NspTypeBase *) nsp_type_gtkvruler)) == NULLGTKVRULER) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkvruler_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_vruler_new())== NULL) return RET_BUG;

  nsp_type_gtkvruler = new_type_gtkvruler(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkvruler );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkvruler_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkvruler_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkHRuler ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkHRuler_Private 
#include "nsp/gtk/gtkhruler.h"
#include "nsp/interf.h"

/* NspGtkHRuler inherits from NspGtkRuler */ 

int nsp_type_gtkhruler_id=0;
NspTypeGtkHRuler *nsp_type_gtkhruler=NULL;

NspTypeGtkHRuler *new_type_gtkhruler(type_mode mode)
{
  NspTypeGtkHRuler *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkhruler != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkhruler;
    }
  if ((type =  malloc(sizeof(NspTypeGtkRuler))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkruler(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkhruler_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkhruler_get_methods; 
  type->new = (new_func *) new_gtkhruler;

  /* specific methods for gtkhruler */
      
  type->init = (init_func *) init_gtkhruler;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkhruler */ 

  top->s_type =  (s_type_func *) gtkhruler_type_as_string;    
  top->sh_type = (sh_type_func *) gtkhruler_type_short_string;
  /* top->create = (create_func*) int_gtkhruler_create;*/ 
  
  /* specific methods for gtkhruler */
      
  type->init = (init_func *) init_gtkhruler;

  if ( nsp_type_gtkhruler_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkHRuler called nsp_type_gtkhruler
       */
      type->id =  nsp_type_gtkhruler_id = nsp_new_type_id();
      nsp_type_gtkhruler = type;
      if ( nsp_register_type(nsp_type_gtkhruler) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkhruler, GTK_TYPE_HRULER);
      return ( mode == T_BASE ) ? type : new_type_gtkhruler(mode);
    }
  else 
    {
       type->id = nsp_type_gtkhruler_id;
       return type;
    }
}

/*
 * initialize GtkHRuler instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkhruler(NspGtkHRuler *o,NspTypeGtkHRuler *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkHRuler 
 */

NspGtkHRuler *new_gtkhruler() 
{
  NspGtkHRuler *loc; 
  /* type must exists */
  nsp_type_gtkhruler = new_type_gtkhruler(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkHRuler)))== NULLGTKHRULER) return loc;
  /* initialize object */
  if ( init_gtkhruler(loc,nsp_type_gtkhruler) == FAIL) return NULLGTKHRULER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkHRuler 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkhruler_type_name[]="GtkHRuler";
static char gtkhruler_short_type_name[]="GtkHRuler";

static char *gtkhruler_type_as_string(void)
{
  return(gtkhruler_type_name);
}

static char *gtkhruler_type_short_string(void)
{
  return(gtkhruler_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkHRuler objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkHRuler   *gtkhruler_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkhruler_id) ) return ((NspGtkHRuler *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkhruler));
  return NULL;
}

int IsGtkHRulerObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkhruler_id);
}

int IsGtkHRuler(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkhruler_id);
}

NspGtkHRuler  *GetGtkHRulerCopy(Stack stack, int i)
{
  if (  GetGtkHRuler(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkHRuler  *GetGtkHRuler(Stack stack, int i)
{
  NspGtkHRuler *M;
  if (( M = gtkhruler_object(NthObj(i))) == NULLGTKHRULER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkHRuler *gtkhruler_copy(NspGtkHRuler *self)
{
  /* return gtkruler_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhruler);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhruler);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkHRuler
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkHRuler *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkhruler is initialized * /
  nsp_type_gtkhruler = new_type_gtkhruler(T_BASE);
  if(( H = gtkruler_create(NVOID,(NspTypeBase *) nsp_type_gtkhruler)) == NULLGTKHRULER) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkhruler_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_hruler_new())== NULL) return RET_BUG;

  nsp_type_gtkhruler = new_type_gtkhruler(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkhruler );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkhruler_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkhruler_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkRange ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkRange_Private 
#include "nsp/gtk/gtkrange.h"
#include "nsp/interf.h"

/* NspGtkRange inherits from NspGtkWidget */ 

int nsp_type_gtkrange_id=0;
NspTypeGtkRange *nsp_type_gtkrange=NULL;

NspTypeGtkRange *new_type_gtkrange(type_mode mode)
{
  NspTypeGtkRange *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkrange != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkrange;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkrange_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkrange_get_methods; 
  type->new = (new_func *) new_gtkrange;

  /* specific methods for gtkrange */
      
  type->init = (init_func *) init_gtkrange;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkrange */ 

  top->s_type =  (s_type_func *) gtkrange_type_as_string;    
  top->sh_type = (sh_type_func *) gtkrange_type_short_string;
  /* top->create = (create_func*) int_gtkrange_create;*/ 
  
  /* specific methods for gtkrange */
      
  type->init = (init_func *) init_gtkrange;

  if ( nsp_type_gtkrange_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRange called nsp_type_gtkrange
       */
      type->id =  nsp_type_gtkrange_id = nsp_new_type_id();
      nsp_type_gtkrange = type;
      if ( nsp_register_type(nsp_type_gtkrange) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkrange, GTK_TYPE_RANGE);
      return ( mode == T_BASE ) ? type : new_type_gtkrange(mode);
    }
  else 
    {
       type->id = nsp_type_gtkrange_id;
       return type;
    }
}

/*
 * initialize GtkRange instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkrange(NspGtkRange *o,NspTypeGtkRange *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkRange 
 */

NspGtkRange *new_gtkrange() 
{
  NspGtkRange *loc; 
  /* type must exists */
  nsp_type_gtkrange = new_type_gtkrange(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRange)))== NULLGTKRANGE) return loc;
  /* initialize object */
  if ( init_gtkrange(loc,nsp_type_gtkrange) == FAIL) return NULLGTKRANGE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkRange 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkrange_type_name[]="GtkRange";
static char gtkrange_short_type_name[]="GtkRange";

static char *gtkrange_type_as_string(void)
{
  return(gtkrange_type_name);
}

static char *gtkrange_type_short_string(void)
{
  return(gtkrange_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkRange objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkRange   *gtkrange_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkrange_id) ) return ((NspGtkRange *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkrange));
  return NULL;
}

int IsGtkRangeObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkrange_id);
}

int IsGtkRange(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkrange_id);
}

NspGtkRange  *GetGtkRangeCopy(Stack stack, int i)
{
  if (  GetGtkRange(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRange  *GetGtkRange(Stack stack, int i)
{
  NspGtkRange *M;
  if (( M = gtkrange_object(NthObj(i))) == NULLGTKRANGE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRange *gtkrange_copy(NspGtkRange *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrange);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrange);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRange
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkRange *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkrange is initialized * /
  nsp_type_gtkrange = new_type_gtkrange(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkrange)) == NULLGTKRANGE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_range_set_update_policy(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_policy = NULL;
  GtkUpdateType policy;

  if ( GetArgs(stack,rhs,opt,T,&nsp_policy) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_UPDATE_TYPE, nsp_policy, &policy)== FAIL)
      return RET_BUG;
  gtk_range_set_update_policy(GTK_RANGE(self->obj), policy);
  return 0;
}

static int _wrap_gtk_range_get_update_policy(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_range_get_update_policy(GTK_RANGE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_set_adjustment(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *adjustment;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
  gtk_range_set_adjustment(GTK_RANGE(self->obj), GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_range_get_adjustment(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_range_get_adjustment(GTK_RANGE(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_range_set_inverted(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_range_set_inverted(GTK_RANGE(self->obj), setting);
  return 0;
}

static int _wrap_gtk_range_get_inverted(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_range_get_inverted(GTK_RANGE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_set_increments(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, s_double,t_end};
  double step, page;

  if ( GetArgs(stack,rhs,opt,T,&step, &page) == FAIL) return RET_BUG;
  gtk_range_set_increments(GTK_RANGE(self->obj), step, page);
  return 0;
}

static int _wrap_gtk_range_set_range(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, s_double,t_end};
  double min, max;

  if ( GetArgs(stack,rhs,opt,T,&min, &max) == FAIL) return RET_BUG;
  gtk_range_set_range(GTK_RANGE(self->obj), min, max);
  return 0;
}

static int _wrap_gtk_range_set_value(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,t_end};
  double value;

  if ( GetArgs(stack,rhs,opt,T,&value) == FAIL) return RET_BUG;
  gtk_range_set_value(GTK_RANGE(self->obj), value);
  return 0;
}

static int _wrap_gtk_range_get_value(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;

  ret = gtk_range_get_value(GTK_RANGE(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkrange_methods[] = {
  {"set_update_policy",(nsp_method *) _wrap_gtk_range_set_update_policy},
  {"get_update_policy",(nsp_method *) _wrap_gtk_range_get_update_policy},
  {"set_adjustment",(nsp_method *) _wrap_gtk_range_set_adjustment},
  {"get_adjustment",(nsp_method *) _wrap_gtk_range_get_adjustment},
  {"set_inverted",(nsp_method *) _wrap_gtk_range_set_inverted},
  {"get_inverted",(nsp_method *) _wrap_gtk_range_get_inverted},
  {"set_increments",(nsp_method *) _wrap_gtk_range_set_increments},
  {"set_range",(nsp_method *) _wrap_gtk_range_set_range},
  {"set_value",(nsp_method *) _wrap_gtk_range_set_value},
  {"get_value",(nsp_method *) _wrap_gtk_range_get_value},
  { NULL, NULL}
};

static NspMethods *gtkrange_get_methods(void) { return gtkrange_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkrange_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkScrollbar ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkScrollbar_Private 
#include "nsp/gtk/gtkscrollbar.h"
#include "nsp/interf.h"

/* NspGtkScrollbar inherits from NspGtkRange */ 

int nsp_type_gtkscrollbar_id=0;
NspTypeGtkScrollbar *nsp_type_gtkscrollbar=NULL;

NspTypeGtkScrollbar *new_type_gtkscrollbar(type_mode mode)
{
  NspTypeGtkScrollbar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkscrollbar != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkscrollbar;
    }
  if ((type =  malloc(sizeof(NspTypeGtkRange))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkrange(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkscrollbar_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkscrollbar_get_methods; 
  type->new = (new_func *) new_gtkscrollbar;

  /* specific methods for gtkscrollbar */
      
  type->init = (init_func *) init_gtkscrollbar;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkscrollbar */ 

  top->s_type =  (s_type_func *) gtkscrollbar_type_as_string;    
  top->sh_type = (sh_type_func *) gtkscrollbar_type_short_string;
  /* top->create = (create_func*) int_gtkscrollbar_create;*/ 
  
  /* specific methods for gtkscrollbar */
      
  type->init = (init_func *) init_gtkscrollbar;

  if ( nsp_type_gtkscrollbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkScrollbar called nsp_type_gtkscrollbar
       */
      type->id =  nsp_type_gtkscrollbar_id = nsp_new_type_id();
      nsp_type_gtkscrollbar = type;
      if ( nsp_register_type(nsp_type_gtkscrollbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkscrollbar, GTK_TYPE_SCROLLBAR);
      return ( mode == T_BASE ) ? type : new_type_gtkscrollbar(mode);
    }
  else 
    {
       type->id = nsp_type_gtkscrollbar_id;
       return type;
    }
}

/*
 * initialize GtkScrollbar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkscrollbar(NspGtkScrollbar *o,NspTypeGtkScrollbar *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkScrollbar 
 */

NspGtkScrollbar *new_gtkscrollbar() 
{
  NspGtkScrollbar *loc; 
  /* type must exists */
  nsp_type_gtkscrollbar = new_type_gtkscrollbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkScrollbar)))== NULLGTKSCROLLBAR) return loc;
  /* initialize object */
  if ( init_gtkscrollbar(loc,nsp_type_gtkscrollbar) == FAIL) return NULLGTKSCROLLBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkScrollbar 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkscrollbar_type_name[]="GtkScrollbar";
static char gtkscrollbar_short_type_name[]="GtkScrollbar";

static char *gtkscrollbar_type_as_string(void)
{
  return(gtkscrollbar_type_name);
}

static char *gtkscrollbar_type_short_string(void)
{
  return(gtkscrollbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkScrollbar objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkScrollbar   *gtkscrollbar_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkscrollbar_id) ) return ((NspGtkScrollbar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkscrollbar));
  return NULL;
}

int IsGtkScrollbarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkscrollbar_id);
}

int IsGtkScrollbar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkscrollbar_id);
}

NspGtkScrollbar  *GetGtkScrollbarCopy(Stack stack, int i)
{
  if (  GetGtkScrollbar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkScrollbar  *GetGtkScrollbar(Stack stack, int i)
{
  NspGtkScrollbar *M;
  if (( M = gtkscrollbar_object(NthObj(i))) == NULLGTKSCROLLBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkScrollbar *gtkscrollbar_copy(NspGtkScrollbar *self)
{
  /* return gtkrange_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscrollbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscrollbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkScrollbar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkScrollbar *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkscrollbar is initialized * /
  nsp_type_gtkscrollbar = new_type_gtkscrollbar(T_BASE);
  if(( H = gtkrange_create(NVOID,(NspTypeBase *) nsp_type_gtkscrollbar)) == NULLGTKSCROLLBAR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static NspMethods *gtkscrollbar_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkscrollbar_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkVScrollbar ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkVScrollbar_Private 
#include "nsp/gtk/gtkvscrollbar.h"
#include "nsp/interf.h"

/* NspGtkVScrollbar inherits from NspGtkScrollbar */ 

int nsp_type_gtkvscrollbar_id=0;
NspTypeGtkVScrollbar *nsp_type_gtkvscrollbar=NULL;

NspTypeGtkVScrollbar *new_type_gtkvscrollbar(type_mode mode)
{
  NspTypeGtkVScrollbar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkvscrollbar != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkvscrollbar;
    }
  if ((type =  malloc(sizeof(NspTypeGtkScrollbar))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkscrollbar(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkvscrollbar_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkvscrollbar_get_methods; 
  type->new = (new_func *) new_gtkvscrollbar;

  /* specific methods for gtkvscrollbar */
      
  type->init = (init_func *) init_gtkvscrollbar;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkvscrollbar */ 

  top->s_type =  (s_type_func *) gtkvscrollbar_type_as_string;    
  top->sh_type = (sh_type_func *) gtkvscrollbar_type_short_string;
  /* top->create = (create_func*) int_gtkvscrollbar_create;*/ 
  
  /* specific methods for gtkvscrollbar */
      
  type->init = (init_func *) init_gtkvscrollbar;

  if ( nsp_type_gtkvscrollbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkVScrollbar called nsp_type_gtkvscrollbar
       */
      type->id =  nsp_type_gtkvscrollbar_id = nsp_new_type_id();
      nsp_type_gtkvscrollbar = type;
      if ( nsp_register_type(nsp_type_gtkvscrollbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkvscrollbar, GTK_TYPE_VSCROLLBAR);
      return ( mode == T_BASE ) ? type : new_type_gtkvscrollbar(mode);
    }
  else 
    {
       type->id = nsp_type_gtkvscrollbar_id;
       return type;
    }
}

/*
 * initialize GtkVScrollbar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkvscrollbar(NspGtkVScrollbar *o,NspTypeGtkVScrollbar *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkVScrollbar 
 */

NspGtkVScrollbar *new_gtkvscrollbar() 
{
  NspGtkVScrollbar *loc; 
  /* type must exists */
  nsp_type_gtkvscrollbar = new_type_gtkvscrollbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkVScrollbar)))== NULLGTKVSCROLLBAR) return loc;
  /* initialize object */
  if ( init_gtkvscrollbar(loc,nsp_type_gtkvscrollbar) == FAIL) return NULLGTKVSCROLLBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkVScrollbar 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkvscrollbar_type_name[]="GtkVScrollbar";
static char gtkvscrollbar_short_type_name[]="GtkVScrollbar";

static char *gtkvscrollbar_type_as_string(void)
{
  return(gtkvscrollbar_type_name);
}

static char *gtkvscrollbar_type_short_string(void)
{
  return(gtkvscrollbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkVScrollbar objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkVScrollbar   *gtkvscrollbar_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkvscrollbar_id) ) return ((NspGtkVScrollbar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkvscrollbar));
  return NULL;
}

int IsGtkVScrollbarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkvscrollbar_id);
}

int IsGtkVScrollbar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkvscrollbar_id);
}

NspGtkVScrollbar  *GetGtkVScrollbarCopy(Stack stack, int i)
{
  if (  GetGtkVScrollbar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkVScrollbar  *GetGtkVScrollbar(Stack stack, int i)
{
  NspGtkVScrollbar *M;
  if (( M = gtkvscrollbar_object(NthObj(i))) == NULLGTKVSCROLLBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkVScrollbar *gtkvscrollbar_copy(NspGtkVScrollbar *self)
{
  /* return gtkscrollbar_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvscrollbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvscrollbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkVScrollbar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkVScrollbar *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkvscrollbar is initialized * /
  nsp_type_gtkvscrollbar = new_type_gtkvscrollbar(T_BASE);
  if(( H = gtkscrollbar_create(NVOID,(NspTypeBase *) nsp_type_gtkvscrollbar)) == NULLGTKVSCROLLBAR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkvscrollbar_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"adjustment",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *nsp_adjustment = NULL;
  GtkAdjustment *adjustment = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_adjustment) == FAIL) return RET_BUG;
  if ( nsp_adjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
    else if (! IsNone((NspObject *)nsp_adjustment)) {
         Scierror( "adjustment should be a GtkAdjustment or None");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_vscrollbar_new(adjustment))== NULL) return RET_BUG;

  nsp_type_gtkvscrollbar = new_type_gtkvscrollbar(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkvscrollbar );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkvscrollbar_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkvscrollbar_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkHScrollbar ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkHScrollbar_Private 
#include "nsp/gtk/gtkhscrollbar.h"
#include "nsp/interf.h"

/* NspGtkHScrollbar inherits from NspGtkScrollbar */ 

int nsp_type_gtkhscrollbar_id=0;
NspTypeGtkHScrollbar *nsp_type_gtkhscrollbar=NULL;

NspTypeGtkHScrollbar *new_type_gtkhscrollbar(type_mode mode)
{
  NspTypeGtkHScrollbar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkhscrollbar != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkhscrollbar;
    }
  if ((type =  malloc(sizeof(NspTypeGtkScrollbar))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkscrollbar(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkhscrollbar_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkhscrollbar_get_methods; 
  type->new = (new_func *) new_gtkhscrollbar;

  /* specific methods for gtkhscrollbar */
      
  type->init = (init_func *) init_gtkhscrollbar;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkhscrollbar */ 

  top->s_type =  (s_type_func *) gtkhscrollbar_type_as_string;    
  top->sh_type = (sh_type_func *) gtkhscrollbar_type_short_string;
  /* top->create = (create_func*) int_gtkhscrollbar_create;*/ 
  
  /* specific methods for gtkhscrollbar */
      
  type->init = (init_func *) init_gtkhscrollbar;

  if ( nsp_type_gtkhscrollbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkHScrollbar called nsp_type_gtkhscrollbar
       */
      type->id =  nsp_type_gtkhscrollbar_id = nsp_new_type_id();
      nsp_type_gtkhscrollbar = type;
      if ( nsp_register_type(nsp_type_gtkhscrollbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkhscrollbar, GTK_TYPE_HSCROLLBAR);
      return ( mode == T_BASE ) ? type : new_type_gtkhscrollbar(mode);
    }
  else 
    {
       type->id = nsp_type_gtkhscrollbar_id;
       return type;
    }
}

/*
 * initialize GtkHScrollbar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkhscrollbar(NspGtkHScrollbar *o,NspTypeGtkHScrollbar *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkHScrollbar 
 */

NspGtkHScrollbar *new_gtkhscrollbar() 
{
  NspGtkHScrollbar *loc; 
  /* type must exists */
  nsp_type_gtkhscrollbar = new_type_gtkhscrollbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkHScrollbar)))== NULLGTKHSCROLLBAR) return loc;
  /* initialize object */
  if ( init_gtkhscrollbar(loc,nsp_type_gtkhscrollbar) == FAIL) return NULLGTKHSCROLLBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkHScrollbar 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkhscrollbar_type_name[]="GtkHScrollbar";
static char gtkhscrollbar_short_type_name[]="GtkHScrollbar";

static char *gtkhscrollbar_type_as_string(void)
{
  return(gtkhscrollbar_type_name);
}

static char *gtkhscrollbar_type_short_string(void)
{
  return(gtkhscrollbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkHScrollbar objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkHScrollbar   *gtkhscrollbar_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkhscrollbar_id) ) return ((NspGtkHScrollbar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkhscrollbar));
  return NULL;
}

int IsGtkHScrollbarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkhscrollbar_id);
}

int IsGtkHScrollbar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkhscrollbar_id);
}

NspGtkHScrollbar  *GetGtkHScrollbarCopy(Stack stack, int i)
{
  if (  GetGtkHScrollbar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkHScrollbar  *GetGtkHScrollbar(Stack stack, int i)
{
  NspGtkHScrollbar *M;
  if (( M = gtkhscrollbar_object(NthObj(i))) == NULLGTKHSCROLLBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkHScrollbar *gtkhscrollbar_copy(NspGtkHScrollbar *self)
{
  /* return gtkscrollbar_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhscrollbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhscrollbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkHScrollbar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkHScrollbar *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkhscrollbar is initialized * /
  nsp_type_gtkhscrollbar = new_type_gtkhscrollbar(T_BASE);
  if(( H = gtkscrollbar_create(NVOID,(NspTypeBase *) nsp_type_gtkhscrollbar)) == NULLGTKHSCROLLBAR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkhscrollbar_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"adjustment",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *nsp_adjustment = NULL;
  GtkAdjustment *adjustment = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_adjustment) == FAIL) return RET_BUG;
  if ( nsp_adjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
    else if (! IsNone((NspObject *)nsp_adjustment)) {
         Scierror( "adjustment should be a GtkAdjustment or None");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_hscrollbar_new(adjustment))== NULL) return RET_BUG;

  nsp_type_gtkhscrollbar = new_type_gtkhscrollbar(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkhscrollbar );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkhscrollbar_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkhscrollbar_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkScale ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkScale_Private 
#include "nsp/gtk/gtkscale.h"
#include "nsp/interf.h"

/* NspGtkScale inherits from NspGtkRange */ 

int nsp_type_gtkscale_id=0;
NspTypeGtkScale *nsp_type_gtkscale=NULL;

NspTypeGtkScale *new_type_gtkscale(type_mode mode)
{
  NspTypeGtkScale *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkscale != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkscale;
    }
  if ((type =  malloc(sizeof(NspTypeGtkRange))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkrange(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkscale_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkscale_get_methods; 
  type->new = (new_func *) new_gtkscale;

  /* specific methods for gtkscale */
      
  type->init = (init_func *) init_gtkscale;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkscale */ 

  top->s_type =  (s_type_func *) gtkscale_type_as_string;    
  top->sh_type = (sh_type_func *) gtkscale_type_short_string;
  /* top->create = (create_func*) int_gtkscale_create;*/ 
  
  /* specific methods for gtkscale */
      
  type->init = (init_func *) init_gtkscale;

  if ( nsp_type_gtkscale_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkScale called nsp_type_gtkscale
       */
      type->id =  nsp_type_gtkscale_id = nsp_new_type_id();
      nsp_type_gtkscale = type;
      if ( nsp_register_type(nsp_type_gtkscale) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkscale, GTK_TYPE_SCALE);
      return ( mode == T_BASE ) ? type : new_type_gtkscale(mode);
    }
  else 
    {
       type->id = nsp_type_gtkscale_id;
       return type;
    }
}

/*
 * initialize GtkScale instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkscale(NspGtkScale *o,NspTypeGtkScale *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkScale 
 */

NspGtkScale *new_gtkscale() 
{
  NspGtkScale *loc; 
  /* type must exists */
  nsp_type_gtkscale = new_type_gtkscale(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkScale)))== NULLGTKSCALE) return loc;
  /* initialize object */
  if ( init_gtkscale(loc,nsp_type_gtkscale) == FAIL) return NULLGTKSCALE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkScale 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkscale_type_name[]="GtkScale";
static char gtkscale_short_type_name[]="GtkScale";

static char *gtkscale_type_as_string(void)
{
  return(gtkscale_type_name);
}

static char *gtkscale_type_short_string(void)
{
  return(gtkscale_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkScale objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkScale   *gtkscale_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkscale_id) ) return ((NspGtkScale *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkscale));
  return NULL;
}

int IsGtkScaleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkscale_id);
}

int IsGtkScale(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkscale_id);
}

NspGtkScale  *GetGtkScaleCopy(Stack stack, int i)
{
  if (  GetGtkScale(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkScale  *GetGtkScale(Stack stack, int i)
{
  NspGtkScale *M;
  if (( M = gtkscale_object(NthObj(i))) == NULLGTKSCALE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkScale *gtkscale_copy(NspGtkScale *self)
{
  /* return gtkrange_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscale);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscale);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkScale
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkScale *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkscale is initialized * /
  nsp_type_gtkscale = new_type_gtkscale(T_BASE);
  if(( H = gtkrange_create(NVOID,(NspTypeBase *) nsp_type_gtkscale)) == NULLGTKSCALE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_scale_set_digits(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int digits;

  if ( GetArgs(stack,rhs,opt,T,&digits) == FAIL) return RET_BUG;
  gtk_scale_set_digits(GTK_SCALE(self->obj), digits);
  return 0;
}

static int _wrap_gtk_scale_get_digits(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_scale_get_digits(GTK_SCALE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scale_set_draw_value(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int draw_value;

  if ( GetArgs(stack,rhs,opt,T,&draw_value) == FAIL) return RET_BUG;
  gtk_scale_set_draw_value(GTK_SCALE(self->obj), draw_value);
  return 0;
}

static int _wrap_gtk_scale_get_draw_value(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_scale_get_draw_value(GTK_SCALE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scale_set_value_pos(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_pos = NULL;
  GtkPositionType pos;

  if ( GetArgs(stack,rhs,opt,T,&nsp_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_pos, &pos)== FAIL)
      return RET_BUG;
  gtk_scale_set_value_pos(GTK_SCALE(self->obj), pos);
  return 0;
}

static int _wrap_gtk_scale_get_value_pos(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_scale_get_value_pos(GTK_SCALE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkscale_methods[] = {
  {"set_digits",(nsp_method *) _wrap_gtk_scale_set_digits},
  {"get_digits",(nsp_method *) _wrap_gtk_scale_get_digits},
  {"set_draw_value",(nsp_method *) _wrap_gtk_scale_set_draw_value},
  {"get_draw_value",(nsp_method *) _wrap_gtk_scale_get_draw_value},
  {"set_value_pos",(nsp_method *) _wrap_gtk_scale_set_value_pos},
  {"get_value_pos",(nsp_method *) _wrap_gtk_scale_get_value_pos},
  { NULL, NULL}
};

static NspMethods *gtkscale_get_methods(void) { return gtkscale_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkscale_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkVScale ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkVScale_Private 
#include "nsp/gtk/gtkvscale.h"
#include "nsp/interf.h"

/* NspGtkVScale inherits from NspGtkScale */ 

int nsp_type_gtkvscale_id=0;
NspTypeGtkVScale *nsp_type_gtkvscale=NULL;

NspTypeGtkVScale *new_type_gtkvscale(type_mode mode)
{
  NspTypeGtkVScale *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkvscale != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkvscale;
    }
  if ((type =  malloc(sizeof(NspTypeGtkScale))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkscale(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkvscale_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkvscale_get_methods; 
  type->new = (new_func *) new_gtkvscale;

  /* specific methods for gtkvscale */
      
  type->init = (init_func *) init_gtkvscale;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkvscale */ 

  top->s_type =  (s_type_func *) gtkvscale_type_as_string;    
  top->sh_type = (sh_type_func *) gtkvscale_type_short_string;
  /* top->create = (create_func*) int_gtkvscale_create;*/ 
  
  /* specific methods for gtkvscale */
      
  type->init = (init_func *) init_gtkvscale;

  if ( nsp_type_gtkvscale_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkVScale called nsp_type_gtkvscale
       */
      type->id =  nsp_type_gtkvscale_id = nsp_new_type_id();
      nsp_type_gtkvscale = type;
      if ( nsp_register_type(nsp_type_gtkvscale) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkvscale, GTK_TYPE_VSCALE);
      return ( mode == T_BASE ) ? type : new_type_gtkvscale(mode);
    }
  else 
    {
       type->id = nsp_type_gtkvscale_id;
       return type;
    }
}

/*
 * initialize GtkVScale instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkvscale(NspGtkVScale *o,NspTypeGtkVScale *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkVScale 
 */

NspGtkVScale *new_gtkvscale() 
{
  NspGtkVScale *loc; 
  /* type must exists */
  nsp_type_gtkvscale = new_type_gtkvscale(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkVScale)))== NULLGTKVSCALE) return loc;
  /* initialize object */
  if ( init_gtkvscale(loc,nsp_type_gtkvscale) == FAIL) return NULLGTKVSCALE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkVScale 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkvscale_type_name[]="GtkVScale";
static char gtkvscale_short_type_name[]="GtkVScale";

static char *gtkvscale_type_as_string(void)
{
  return(gtkvscale_type_name);
}

static char *gtkvscale_type_short_string(void)
{
  return(gtkvscale_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkVScale objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkVScale   *gtkvscale_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkvscale_id) ) return ((NspGtkVScale *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkvscale));
  return NULL;
}

int IsGtkVScaleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkvscale_id);
}

int IsGtkVScale(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkvscale_id);
}

NspGtkVScale  *GetGtkVScaleCopy(Stack stack, int i)
{
  if (  GetGtkVScale(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkVScale  *GetGtkVScale(Stack stack, int i)
{
  NspGtkVScale *M;
  if (( M = gtkvscale_object(NthObj(i))) == NULLGTKVSCALE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkVScale *gtkvscale_copy(NspGtkVScale *self)
{
  /* return gtkscale_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvscale);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvscale);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkVScale
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkVScale *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkvscale is initialized * /
  nsp_type_gtkvscale = new_type_gtkvscale(T_BASE);
  if(( H = gtkscale_create(NVOID,(NspTypeBase *) nsp_type_gtkvscale)) == NULLGTKVSCALE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkvscale_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"adjustment",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *nsp_adjustment = NULL;
  GtkAdjustment *adjustment = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_adjustment) == FAIL) return RET_BUG;
  if ( nsp_adjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
    else if (! IsNone((NspObject *)nsp_adjustment)) {
         Scierror( "adjustment should be a GtkAdjustment or None");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_vscale_new(adjustment))== NULL) return RET_BUG;

  nsp_type_gtkvscale = new_type_gtkvscale(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkvscale );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkvscale_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkvscale_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkHScale ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkHScale_Private 
#include "nsp/gtk/gtkhscale.h"
#include "nsp/interf.h"

/* NspGtkHScale inherits from NspGtkScale */ 

int nsp_type_gtkhscale_id=0;
NspTypeGtkHScale *nsp_type_gtkhscale=NULL;

NspTypeGtkHScale *new_type_gtkhscale(type_mode mode)
{
  NspTypeGtkHScale *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkhscale != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkhscale;
    }
  if ((type =  malloc(sizeof(NspTypeGtkScale))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkscale(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkhscale_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkhscale_get_methods; 
  type->new = (new_func *) new_gtkhscale;

  /* specific methods for gtkhscale */
      
  type->init = (init_func *) init_gtkhscale;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkhscale */ 

  top->s_type =  (s_type_func *) gtkhscale_type_as_string;    
  top->sh_type = (sh_type_func *) gtkhscale_type_short_string;
  /* top->create = (create_func*) int_gtkhscale_create;*/ 
  
  /* specific methods for gtkhscale */
      
  type->init = (init_func *) init_gtkhscale;

  if ( nsp_type_gtkhscale_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkHScale called nsp_type_gtkhscale
       */
      type->id =  nsp_type_gtkhscale_id = nsp_new_type_id();
      nsp_type_gtkhscale = type;
      if ( nsp_register_type(nsp_type_gtkhscale) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkhscale, GTK_TYPE_HSCALE);
      return ( mode == T_BASE ) ? type : new_type_gtkhscale(mode);
    }
  else 
    {
       type->id = nsp_type_gtkhscale_id;
       return type;
    }
}

/*
 * initialize GtkHScale instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkhscale(NspGtkHScale *o,NspTypeGtkHScale *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkHScale 
 */

NspGtkHScale *new_gtkhscale() 
{
  NspGtkHScale *loc; 
  /* type must exists */
  nsp_type_gtkhscale = new_type_gtkhscale(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkHScale)))== NULLGTKHSCALE) return loc;
  /* initialize object */
  if ( init_gtkhscale(loc,nsp_type_gtkhscale) == FAIL) return NULLGTKHSCALE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkHScale 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkhscale_type_name[]="GtkHScale";
static char gtkhscale_short_type_name[]="GtkHScale";

static char *gtkhscale_type_as_string(void)
{
  return(gtkhscale_type_name);
}

static char *gtkhscale_type_short_string(void)
{
  return(gtkhscale_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkHScale objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkHScale   *gtkhscale_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkhscale_id) ) return ((NspGtkHScale *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkhscale));
  return NULL;
}

int IsGtkHScaleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkhscale_id);
}

int IsGtkHScale(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkhscale_id);
}

NspGtkHScale  *GetGtkHScaleCopy(Stack stack, int i)
{
  if (  GetGtkHScale(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkHScale  *GetGtkHScale(Stack stack, int i)
{
  NspGtkHScale *M;
  if (( M = gtkhscale_object(NthObj(i))) == NULLGTKHSCALE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkHScale *gtkhscale_copy(NspGtkHScale *self)
{
  /* return gtkscale_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhscale);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhscale);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkHScale
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkHScale *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkhscale is initialized * /
  nsp_type_gtkhscale = new_type_gtkhscale(T_BASE);
  if(( H = gtkscale_create(NVOID,(NspTypeBase *) nsp_type_gtkhscale)) == NULLGTKHSCALE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkhscale_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"adjustment",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *nsp_adjustment = NULL;
  GtkAdjustment *adjustment = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_adjustment) == FAIL) return RET_BUG;
  if ( nsp_adjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
    else if (! IsNone((NspObject *)nsp_adjustment)) {
         Scierror( "adjustment should be a GtkAdjustment or None");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_hscale_new(adjustment))== NULL) return RET_BUG;

  nsp_type_gtkhscale = new_type_gtkhscale(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkhscale );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkhscale_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkhscale_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkProgress ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkProgress_Private 
#include "nsp/gtk/gtkprogress.h"
#include "nsp/interf.h"

/* NspGtkProgress inherits from NspGtkWidget */ 

int nsp_type_gtkprogress_id=0;
NspTypeGtkProgress *nsp_type_gtkprogress=NULL;

NspTypeGtkProgress *new_type_gtkprogress(type_mode mode)
{
  NspTypeGtkProgress *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkprogress != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkprogress;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkprogress_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkprogress_get_methods; 
  type->new = (new_func *) new_gtkprogress;

  /* specific methods for gtkprogress */
      
  type->init = (init_func *) init_gtkprogress;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkprogress */ 

  top->s_type =  (s_type_func *) gtkprogress_type_as_string;    
  top->sh_type = (sh_type_func *) gtkprogress_type_short_string;
  /* top->create = (create_func*) int_gtkprogress_create;*/ 
  
  /* specific methods for gtkprogress */
      
  type->init = (init_func *) init_gtkprogress;

  if ( nsp_type_gtkprogress_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkProgress called nsp_type_gtkprogress
       */
      type->id =  nsp_type_gtkprogress_id = nsp_new_type_id();
      nsp_type_gtkprogress = type;
      if ( nsp_register_type(nsp_type_gtkprogress) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkprogress, GTK_TYPE_PROGRESS);
      return ( mode == T_BASE ) ? type : new_type_gtkprogress(mode);
    }
  else 
    {
       type->id = nsp_type_gtkprogress_id;
       return type;
    }
}

/*
 * initialize GtkProgress instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkprogress(NspGtkProgress *o,NspTypeGtkProgress *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkProgress 
 */

NspGtkProgress *new_gtkprogress() 
{
  NspGtkProgress *loc; 
  /* type must exists */
  nsp_type_gtkprogress = new_type_gtkprogress(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkProgress)))== NULLGTKPROGRESS) return loc;
  /* initialize object */
  if ( init_gtkprogress(loc,nsp_type_gtkprogress) == FAIL) return NULLGTKPROGRESS;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkProgress 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkprogress_type_name[]="GtkProgress";
static char gtkprogress_short_type_name[]="GtkProgress";

static char *gtkprogress_type_as_string(void)
{
  return(gtkprogress_type_name);
}

static char *gtkprogress_type_short_string(void)
{
  return(gtkprogress_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkProgress objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkProgress   *gtkprogress_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkprogress_id) ) return ((NspGtkProgress *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkprogress));
  return NULL;
}

int IsGtkProgressObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkprogress_id);
}

int IsGtkProgress(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkprogress_id);
}

NspGtkProgress  *GetGtkProgressCopy(Stack stack, int i)
{
  if (  GetGtkProgress(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkProgress  *GetGtkProgress(Stack stack, int i)
{
  NspGtkProgress *M;
  if (( M = gtkprogress_object(NthObj(i))) == NULLGTKPROGRESS)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkProgress *gtkprogress_copy(NspGtkProgress *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprogress);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprogress);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkProgress
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkProgress *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkprogress is initialized * /
  nsp_type_gtkprogress = new_type_gtkprogress(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkprogress)) == NULLGTKPROGRESS) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static NspMethods *gtkprogress_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkprogress_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkProgressBar ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkProgressBar_Private 
#include "nsp/gtk/gtkprogressbar.h"
#include "nsp/interf.h"

/* NspGtkProgressBar inherits from NspGtkProgress */ 

int nsp_type_gtkprogressbar_id=0;
NspTypeGtkProgressBar *nsp_type_gtkprogressbar=NULL;

NspTypeGtkProgressBar *new_type_gtkprogressbar(type_mode mode)
{
  NspTypeGtkProgressBar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkprogressbar != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkprogressbar;
    }
  if ((type =  malloc(sizeof(NspTypeGtkProgress))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkprogress(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkprogressbar_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkprogressbar_get_methods; 
  type->new = (new_func *) new_gtkprogressbar;

  /* specific methods for gtkprogressbar */
      
  type->init = (init_func *) init_gtkprogressbar;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkprogressbar */ 

  top->s_type =  (s_type_func *) gtkprogressbar_type_as_string;    
  top->sh_type = (sh_type_func *) gtkprogressbar_type_short_string;
  /* top->create = (create_func*) int_gtkprogressbar_create;*/ 
  
  /* specific methods for gtkprogressbar */
      
  type->init = (init_func *) init_gtkprogressbar;

  if ( nsp_type_gtkprogressbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkProgressBar called nsp_type_gtkprogressbar
       */
      type->id =  nsp_type_gtkprogressbar_id = nsp_new_type_id();
      nsp_type_gtkprogressbar = type;
      if ( nsp_register_type(nsp_type_gtkprogressbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkprogressbar, GTK_TYPE_PROGRESS_BAR);
      return ( mode == T_BASE ) ? type : new_type_gtkprogressbar(mode);
    }
  else 
    {
       type->id = nsp_type_gtkprogressbar_id;
       return type;
    }
}

/*
 * initialize GtkProgressBar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkprogressbar(NspGtkProgressBar *o,NspTypeGtkProgressBar *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkProgressBar 
 */

NspGtkProgressBar *new_gtkprogressbar() 
{
  NspGtkProgressBar *loc; 
  /* type must exists */
  nsp_type_gtkprogressbar = new_type_gtkprogressbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkProgressBar)))== NULLGTKPROGRESSBAR) return loc;
  /* initialize object */
  if ( init_gtkprogressbar(loc,nsp_type_gtkprogressbar) == FAIL) return NULLGTKPROGRESSBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkProgressBar 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkprogressbar_type_name[]="GtkProgressBar";
static char gtkprogressbar_short_type_name[]="GtkProgressBar";

static char *gtkprogressbar_type_as_string(void)
{
  return(gtkprogressbar_type_name);
}

static char *gtkprogressbar_type_short_string(void)
{
  return(gtkprogressbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkProgressBar objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkProgressBar   *gtkprogressbar_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkprogressbar_id) ) return ((NspGtkProgressBar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkprogressbar));
  return NULL;
}

int IsGtkProgressBarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkprogressbar_id);
}

int IsGtkProgressBar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkprogressbar_id);
}

NspGtkProgressBar  *GetGtkProgressBarCopy(Stack stack, int i)
{
  if (  GetGtkProgressBar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkProgressBar  *GetGtkProgressBar(Stack stack, int i)
{
  NspGtkProgressBar *M;
  if (( M = gtkprogressbar_object(NthObj(i))) == NULLGTKPROGRESSBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkProgressBar *gtkprogressbar_copy(NspGtkProgressBar *self)
{
  /* return gtkprogress_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprogressbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprogressbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkProgressBar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkProgressBar *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkprogressbar is initialized * /
  nsp_type_gtkprogressbar = new_type_gtkprogressbar(T_BASE);
  if(( H = gtkprogress_create(NVOID,(NspTypeBase *) nsp_type_gtkprogressbar)) == NULLGTKPROGRESSBAR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkprogressbar_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_progress_bar_new())== NULL) return RET_BUG;

  nsp_type_gtkprogressbar = new_type_gtkprogressbar(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkprogressbar );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_progress_bar_pulse(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_progress_bar_pulse(GTK_PROGRESS_BAR(self->obj));
  return 0;
}

static int _wrap_gtk_progress_bar_set_text(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *text;

  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
  gtk_progress_bar_set_text(GTK_PROGRESS_BAR(self->obj), text);
  return 0;
}

static int _wrap_gtk_progress_bar_set_fraction(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,t_end};
  double fraction;

  if ( GetArgs(stack,rhs,opt,T,&fraction) == FAIL) return RET_BUG;
  gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(self->obj), fraction);
  return 0;
}

static int _wrap_gtk_progress_bar_set_pulse_step(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,t_end};
  double fraction;

  if ( GetArgs(stack,rhs,opt,T,&fraction) == FAIL) return RET_BUG;
  gtk_progress_bar_set_pulse_step(GTK_PROGRESS_BAR(self->obj), fraction);
  return 0;
}

static int _wrap_gtk_progress_bar_set_orientation(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkProgressBarOrientation orientation;
  NspObject *nsp_orientation = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_PROGRESS_BAR_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  gtk_progress_bar_set_orientation(GTK_PROGRESS_BAR(self->obj), orientation);
  return 0;
}

static int _wrap_gtk_progress_bar_get_text(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_progress_bar_get_text(GTK_PROGRESS_BAR(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_progress_bar_get_fraction(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;

  ret = gtk_progress_bar_get_fraction(GTK_PROGRESS_BAR(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_progress_bar_get_pulse_step(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;

  ret = gtk_progress_bar_get_pulse_step(GTK_PROGRESS_BAR(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_progress_bar_get_orientation(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_progress_bar_get_orientation(GTK_PROGRESS_BAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkprogressbar_methods[] = {
  {"pulse",(nsp_method *) _wrap_gtk_progress_bar_pulse},
  {"set_text",(nsp_method *) _wrap_gtk_progress_bar_set_text},
  {"set_fraction",(nsp_method *) _wrap_gtk_progress_bar_set_fraction},
  {"set_pulse_step",(nsp_method *) _wrap_gtk_progress_bar_set_pulse_step},
  {"set_orientation",(nsp_method *) _wrap_gtk_progress_bar_set_orientation},
  {"get_text",(nsp_method *) _wrap_gtk_progress_bar_get_text},
  {"get_fraction",(nsp_method *) _wrap_gtk_progress_bar_get_fraction},
  {"get_pulse_step",(nsp_method *) _wrap_gtk_progress_bar_get_pulse_step},
  {"get_orientation",(nsp_method *) _wrap_gtk_progress_bar_get_orientation},
  { NULL, NULL}
};

static NspMethods *gtkprogressbar_get_methods(void) { return gtkprogressbar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkprogressbar_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkPreview ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkPreview_Private 
#include "nsp/gtk/gtkpreview.h"
#include "nsp/interf.h"

/* NspGtkPreview inherits from NspGtkWidget */ 

int nsp_type_gtkpreview_id=0;
NspTypeGtkPreview *nsp_type_gtkpreview=NULL;

NspTypeGtkPreview *new_type_gtkpreview(type_mode mode)
{
  NspTypeGtkPreview *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkpreview != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkpreview;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkpreview_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkpreview_get_methods; 
  type->new = (new_func *) new_gtkpreview;

  /* specific methods for gtkpreview */
      
  type->init = (init_func *) init_gtkpreview;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkpreview */ 

  top->s_type =  (s_type_func *) gtkpreview_type_as_string;    
  top->sh_type = (sh_type_func *) gtkpreview_type_short_string;
  /* top->create = (create_func*) int_gtkpreview_create;*/ 
  
  /* specific methods for gtkpreview */
      
  type->init = (init_func *) init_gtkpreview;

  if ( nsp_type_gtkpreview_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkPreview called nsp_type_gtkpreview
       */
      type->id =  nsp_type_gtkpreview_id = nsp_new_type_id();
      nsp_type_gtkpreview = type;
      if ( nsp_register_type(nsp_type_gtkpreview) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkpreview, GTK_TYPE_PREVIEW);
      return ( mode == T_BASE ) ? type : new_type_gtkpreview(mode);
    }
  else 
    {
       type->id = nsp_type_gtkpreview_id;
       return type;
    }
}

/*
 * initialize GtkPreview instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkpreview(NspGtkPreview *o,NspTypeGtkPreview *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkPreview 
 */

NspGtkPreview *new_gtkpreview() 
{
  NspGtkPreview *loc; 
  /* type must exists */
  nsp_type_gtkpreview = new_type_gtkpreview(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkPreview)))== NULLGTKPREVIEW) return loc;
  /* initialize object */
  if ( init_gtkpreview(loc,nsp_type_gtkpreview) == FAIL) return NULLGTKPREVIEW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkPreview 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkpreview_type_name[]="GtkPreview";
static char gtkpreview_short_type_name[]="GtkPreview";

static char *gtkpreview_type_as_string(void)
{
  return(gtkpreview_type_name);
}

static char *gtkpreview_type_short_string(void)
{
  return(gtkpreview_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkPreview objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkPreview   *gtkpreview_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkpreview_id) ) return ((NspGtkPreview *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkpreview));
  return NULL;
}

int IsGtkPreviewObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkpreview_id);
}

int IsGtkPreview(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkpreview_id);
}

NspGtkPreview  *GetGtkPreviewCopy(Stack stack, int i)
{
  if (  GetGtkPreview(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkPreview  *GetGtkPreview(Stack stack, int i)
{
  NspGtkPreview *M;
  if (( M = gtkpreview_object(NthObj(i))) == NULLGTKPREVIEW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkPreview *gtkpreview_copy(NspGtkPreview *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkpreview);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkpreview);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkPreview
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkPreview *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkpreview is initialized * /
  nsp_type_gtkpreview = new_type_gtkpreview(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkpreview)) == NULLGTKPREVIEW) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkpreview_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,t_end};
  GtkPreviewType type;
  NspObject *nsp_type = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkDrawingArea",stack.fname); return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_PREVIEW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_preview_new(type))== NULL) return RET_BUG;

  nsp_type_gtkpreview = new_type_gtkpreview(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkpreview );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_preview_size(NspGtkPreview *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int width, height;

  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
  gtk_preview_size(GTK_PREVIEW(self->obj), width, height);
  return 0;
}

static int _wrap_gtk_preview_put(NspGtkPreview *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check, s_int, s_int, s_int, s_int, s_int, s_int,t_end};
  int srcx, srcy, destx, desty, width, height;
  NspGObject *window, *gc;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &nsp_type_gdkgc, &gc, &srcx, &srcy, &destx, &desty, &width, &height) == FAIL) return RET_BUG;
  gtk_preview_put(GTK_PREVIEW(self->obj), GDK_WINDOW(window->obj), GDK_GC(gc->obj), srcx, srcy, destx, desty, width, height);
  return 0;
}

static int _wrap_gtk_preview_draw_row(NspGtkPreview *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, s_int, s_int, s_int,t_end};
  int x, y, w;
  guchar *data;

  if ( GetArgs(stack,rhs,opt,T,&data, &x, &y, &w) == FAIL) return RET_BUG;
  gtk_preview_draw_row(GTK_PREVIEW(self->obj), data, x, y, w);
  return 0;
}

static int _wrap_gtk_preview_set_expand(NspGtkPreview *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int expand;

  if ( GetArgs(stack,rhs,opt,T,&expand) == FAIL) return RET_BUG;
  gtk_preview_set_expand(GTK_PREVIEW(self->obj), expand);
  return 0;
}

static int _wrap_gtk_preview_set_dither(NspGtkPreview *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GdkRgbDither dither;
  NspObject *nsp_dither = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_dither) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkPixbuf",stack.fname); return RET_BUG;
  if (nspg_enum_get_value(GDK_TYPE_RGB_DITHER, nsp_dither, &dither)== FAIL)
      return RET_BUG;
  gtk_preview_set_dither(GTK_PREVIEW(self->obj), dither);
  return 0;
}

static NspMethods gtkpreview_methods[] = {
  {"size",(nsp_method *) _wrap_gtk_preview_size},
  {"put",(nsp_method *) _wrap_gtk_preview_put},
  {"draw_row",(nsp_method *) _wrap_gtk_preview_draw_row},
  {"set_expand",(nsp_method *) _wrap_gtk_preview_set_expand},
  {"set_dither",(nsp_method *) _wrap_gtk_preview_set_dither},
  { NULL, NULL}
};

static NspMethods *gtkpreview_get_methods(void) { return gtkpreview_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkpreview_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkOldEditable ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkOldEditable_Private 
#include "nsp/gtk/gtkoldeditable.h"
#include "nsp/interf.h"

/* NspGtkOldEditable inherits from NspGtkWidget */ 

int nsp_type_gtkoldeditable_id=0;
NspTypeGtkOldEditable *nsp_type_gtkoldeditable=NULL;

NspTypeGtkOldEditable *new_type_gtkoldeditable(type_mode mode)
{
  NspTypeGtkOldEditable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkoldeditable != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkoldeditable;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkoldeditable_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkoldeditable_get_methods; 
  type->new = (new_func *) new_gtkoldeditable;

  /* specific methods for gtkoldeditable */
      
  type->init = (init_func *) init_gtkoldeditable;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkoldeditable */ 

  top->s_type =  (s_type_func *) gtkoldeditable_type_as_string;    
  top->sh_type = (sh_type_func *) gtkoldeditable_type_short_string;
  /* top->create = (create_func*) int_gtkoldeditable_create;*/ 
  
  /* specific methods for gtkoldeditable */
      
  type->init = (init_func *) init_gtkoldeditable;

  type->interface =  (NspTypeBase *) new_type_gtkeditable(T_DERIVED);
  if ( nsp_type_gtkoldeditable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkOldEditable called nsp_type_gtkoldeditable
       */
      type->id =  nsp_type_gtkoldeditable_id = nsp_new_type_id();
      nsp_type_gtkoldeditable = type;
      if ( nsp_register_type(nsp_type_gtkoldeditable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkoldeditable, GTK_TYPE_OLD_EDITABLE);
      return ( mode == T_BASE ) ? type : new_type_gtkoldeditable(mode);
    }
  else 
    {
       type->id = nsp_type_gtkoldeditable_id;
       return type;
    }
}

/*
 * initialize GtkOldEditable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkoldeditable(NspGtkOldEditable *o,NspTypeGtkOldEditable *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkOldEditable 
 */

NspGtkOldEditable *new_gtkoldeditable() 
{
  NspGtkOldEditable *loc; 
  /* type must exists */
  nsp_type_gtkoldeditable = new_type_gtkoldeditable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkOldEditable)))== NULLGTKOLDEDITABLE) return loc;
  /* initialize object */
  if ( init_gtkoldeditable(loc,nsp_type_gtkoldeditable) == FAIL) return NULLGTKOLDEDITABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkOldEditable 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkoldeditable_type_name[]="GtkOldEditable";
static char gtkoldeditable_short_type_name[]="GtkOldEditable";

static char *gtkoldeditable_type_as_string(void)
{
  return(gtkoldeditable_type_name);
}

static char *gtkoldeditable_type_short_string(void)
{
  return(gtkoldeditable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkOldEditable objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkOldEditable   *gtkoldeditable_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkoldeditable_id) ) return ((NspGtkOldEditable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkoldeditable));
  return NULL;
}

int IsGtkOldEditableObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkoldeditable_id);
}

int IsGtkOldEditable(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkoldeditable_id);
}

NspGtkOldEditable  *GetGtkOldEditableCopy(Stack stack, int i)
{
  if (  GetGtkOldEditable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkOldEditable  *GetGtkOldEditable(Stack stack, int i)
{
  NspGtkOldEditable *M;
  if (( M = gtkoldeditable_object(NthObj(i))) == NULLGTKOLDEDITABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkOldEditable *gtkoldeditable_copy(NspGtkOldEditable *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkoldeditable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkoldeditable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkOldEditable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkOldEditable *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkoldeditable is initialized * /
  nsp_type_gtkoldeditable = new_type_gtkoldeditable(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkoldeditable)) == NULLGTKOLDEDITABLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_old_editable_claim_selection(NspGtkOldEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,new_opts,t_end};
  nsp_option opts[] = {
	{"time",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int claim;
  gulong time = GDK_CURRENT_TIME;

  if ( GetArgs(stack,rhs,opt,T,&claim, opts, &time) == FAIL) return RET_BUG;
  gtk_old_editable_claim_selection(GTK_OLD_EDITABLE(self->obj), claim, time);
  return 0;
}

static int _wrap_gtk_old_editable_changed(NspGtkOldEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_old_editable_changed(GTK_OLD_EDITABLE(self->obj));
  return 0;
}

static NspMethods gtkoldeditable_methods[] = {
  {"claim_selection",(nsp_method *) _wrap_gtk_old_editable_claim_selection},
  {"changed",(nsp_method *) _wrap_gtk_old_editable_changed},
  { NULL, NULL}
};

static NspMethods *gtkoldeditable_get_methods(void) { return gtkoldeditable_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkoldeditable_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkMisc ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkMisc_Private 
#include "nsp/gtk/gtkmisc.h"
#include "nsp/interf.h"

/* NspGtkMisc inherits from NspGtkWidget */ 

int nsp_type_gtkmisc_id=0;
NspTypeGtkMisc *nsp_type_gtkmisc=NULL;

NspTypeGtkMisc *new_type_gtkmisc(type_mode mode)
{
  NspTypeGtkMisc *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmisc != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmisc;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmisc_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkmisc_get_methods; 
  type->new = (new_func *) new_gtkmisc;

  /* specific methods for gtkmisc */
      
  type->init = (init_func *) init_gtkmisc;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkmisc */ 

  top->s_type =  (s_type_func *) gtkmisc_type_as_string;    
  top->sh_type = (sh_type_func *) gtkmisc_type_short_string;
  /* top->create = (create_func*) int_gtkmisc_create;*/ 
  
  /* specific methods for gtkmisc */
      
  type->init = (init_func *) init_gtkmisc;

  if ( nsp_type_gtkmisc_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMisc called nsp_type_gtkmisc
       */
      type->id =  nsp_type_gtkmisc_id = nsp_new_type_id();
      nsp_type_gtkmisc = type;
      if ( nsp_register_type(nsp_type_gtkmisc) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmisc, GTK_TYPE_MISC);
      return ( mode == T_BASE ) ? type : new_type_gtkmisc(mode);
    }
  else 
    {
       type->id = nsp_type_gtkmisc_id;
       return type;
    }
}

/*
 * initialize GtkMisc instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmisc(NspGtkMisc *o,NspTypeGtkMisc *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkMisc 
 */

NspGtkMisc *new_gtkmisc() 
{
  NspGtkMisc *loc; 
  /* type must exists */
  nsp_type_gtkmisc = new_type_gtkmisc(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMisc)))== NULLGTKMISC) return loc;
  /* initialize object */
  if ( init_gtkmisc(loc,nsp_type_gtkmisc) == FAIL) return NULLGTKMISC;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkMisc 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkmisc_type_name[]="GtkMisc";
static char gtkmisc_short_type_name[]="GtkMisc";

static char *gtkmisc_type_as_string(void)
{
  return(gtkmisc_type_name);
}

static char *gtkmisc_type_short_string(void)
{
  return(gtkmisc_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkMisc objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkMisc   *gtkmisc_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkmisc_id) ) return ((NspGtkMisc *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmisc));
  return NULL;
}

int IsGtkMiscObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkmisc_id);
}

int IsGtkMisc(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmisc_id);
}

NspGtkMisc  *GetGtkMiscCopy(Stack stack, int i)
{
  if (  GetGtkMisc(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMisc  *GetGtkMisc(Stack stack, int i)
{
  NspGtkMisc *M;
  if (( M = gtkmisc_object(NthObj(i))) == NULLGTKMISC)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMisc *gtkmisc_copy(NspGtkMisc *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmisc);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmisc);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMisc
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkMisc *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkmisc is initialized * /
  nsp_type_gtkmisc = new_type_gtkmisc(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkmisc)) == NULLGTKMISC) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_misc_set_alignment(NspGtkMisc *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, s_double,t_end};
  double xalign, yalign;

  if ( GetArgs(stack,rhs,opt,T,&xalign, &yalign) == FAIL) return RET_BUG;
  gtk_misc_set_alignment(GTK_MISC(self->obj), xalign, yalign);
  return 0;
}

#line 6195 "gtk.override"
static int
_wrap_gtk_misc_get_alignment(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gfloat xalign, yalign;
  
  gtk_misc_get_alignment(GTK_MISC(self->obj), &xalign, &yalign);
  if ( nsp_move_doubles(stack,1,1,2,(double) xalign,(double) yalign) == FAIL) return RET_BUG; 
  return 1;
}
#line 24510 "gtk.c"


static int _wrap_gtk_misc_set_padding(NspGtkMisc *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int xpad, ypad;

  if ( GetArgs(stack,rhs,opt,T,&xpad, &ypad) == FAIL) return RET_BUG;
  gtk_misc_set_padding(GTK_MISC(self->obj), xpad, ypad);
  return 0;
}

#line 6206 "gtk.override"
static int
_wrap_gtk_misc_get_padding(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint xpad, ypad;

  gtk_misc_get_padding(GTK_MISC(self->obj), &xpad, &ypad);
  if ( nsp_move_doubles(stack,1,1,2,(double) xpad,(double) ypad) == FAIL) return RET_BUG; 
  return 1;
}
#line 24533 "gtk.c"


static NspMethods gtkmisc_methods[] = {
  {"set_alignment",(nsp_method *) _wrap_gtk_misc_set_alignment},
  {"get_alignment",(nsp_method *) _wrap_gtk_misc_get_alignment},
  {"set_padding",(nsp_method *) _wrap_gtk_misc_set_padding},
  {"get_padding",(nsp_method *) _wrap_gtk_misc_get_padding},
  { NULL, NULL}
};

static NspMethods *gtkmisc_get_methods(void) { return gtkmisc_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmisc_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkArrow ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkArrow_Private 
#include "nsp/gtk/gtkarrow.h"
#include "nsp/interf.h"

/* NspGtkArrow inherits from NspGtkMisc */ 

int nsp_type_gtkarrow_id=0;
NspTypeGtkArrow *nsp_type_gtkarrow=NULL;

NspTypeGtkArrow *new_type_gtkarrow(type_mode mode)
{
  NspTypeGtkArrow *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkarrow != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkarrow;
    }
  if ((type =  malloc(sizeof(NspTypeGtkMisc))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmisc(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkarrow_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkarrow_get_methods; 
  type->new = (new_func *) new_gtkarrow;

  /* specific methods for gtkarrow */
      
  type->init = (init_func *) init_gtkarrow;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkarrow */ 

  top->s_type =  (s_type_func *) gtkarrow_type_as_string;    
  top->sh_type = (sh_type_func *) gtkarrow_type_short_string;
  /* top->create = (create_func*) int_gtkarrow_create;*/ 
  
  /* specific methods for gtkarrow */
      
  type->init = (init_func *) init_gtkarrow;

  if ( nsp_type_gtkarrow_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkArrow called nsp_type_gtkarrow
       */
      type->id =  nsp_type_gtkarrow_id = nsp_new_type_id();
      nsp_type_gtkarrow = type;
      if ( nsp_register_type(nsp_type_gtkarrow) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkarrow, GTK_TYPE_ARROW);
      return ( mode == T_BASE ) ? type : new_type_gtkarrow(mode);
    }
  else 
    {
       type->id = nsp_type_gtkarrow_id;
       return type;
    }
}

/*
 * initialize GtkArrow instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkarrow(NspGtkArrow *o,NspTypeGtkArrow *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkArrow 
 */

NspGtkArrow *new_gtkarrow() 
{
  NspGtkArrow *loc; 
  /* type must exists */
  nsp_type_gtkarrow = new_type_gtkarrow(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkArrow)))== NULLGTKARROW) return loc;
  /* initialize object */
  if ( init_gtkarrow(loc,nsp_type_gtkarrow) == FAIL) return NULLGTKARROW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkArrow 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkarrow_type_name[]="GtkArrow";
static char gtkarrow_short_type_name[]="GtkArrow";

static char *gtkarrow_type_as_string(void)
{
  return(gtkarrow_type_name);
}

static char *gtkarrow_type_short_string(void)
{
  return(gtkarrow_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkArrow objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkArrow   *gtkarrow_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkarrow_id) ) return ((NspGtkArrow *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkarrow));
  return NULL;
}

int IsGtkArrowObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkarrow_id);
}

int IsGtkArrow(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkarrow_id);
}

NspGtkArrow  *GetGtkArrowCopy(Stack stack, int i)
{
  if (  GetGtkArrow(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkArrow  *GetGtkArrow(Stack stack, int i)
{
  NspGtkArrow *M;
  if (( M = gtkarrow_object(NthObj(i))) == NULLGTKARROW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkArrow *gtkarrow_copy(NspGtkArrow *self)
{
  /* return gtkmisc_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkarrow);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkarrow);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkArrow
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkArrow *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkarrow is initialized * /
  nsp_type_gtkarrow = new_type_gtkarrow(T_BASE);
  if(( H = gtkmisc_create(NVOID,(NspTypeBase *) nsp_type_gtkarrow)) == NULLGTKARROW) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkarrow_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_arrow_type = NULL, *nsp_shadow_type = NULL;
  GtkArrowType arrow_type;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_arrow_type, &nsp_shadow_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ARROW_TYPE, nsp_arrow_type, &arrow_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_arrow_new(arrow_type, shadow_type))== NULL) return RET_BUG;

  nsp_type_gtkarrow = new_type_gtkarrow(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkarrow );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_arrow_set(NspGtkArrow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkShadowType shadow_type;
  NspObject *nsp_arrow_type = NULL, *nsp_shadow_type = NULL;
  GtkArrowType arrow_type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_arrow_type, &nsp_shadow_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ARROW_TYPE, nsp_arrow_type, &arrow_type)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type, &shadow_type)== FAIL)
      return RET_BUG;
  gtk_arrow_set(GTK_ARROW(self->obj), arrow_type, shadow_type);
  return 0;
}

static NspMethods gtkarrow_methods[] = {
  {"set",(nsp_method *) _wrap_gtk_arrow_set},
  { NULL, NULL}
};

static NspMethods *gtkarrow_get_methods(void) { return gtkarrow_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkarrow_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkImage ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkImage_Private 
#include "nsp/gtk/gtkimage.h"
#include "nsp/interf.h"

/* NspGtkImage inherits from NspGtkMisc */ 

int nsp_type_gtkimage_id=0;
NspTypeGtkImage *nsp_type_gtkimage=NULL;

NspTypeGtkImage *new_type_gtkimage(type_mode mode)
{
  NspTypeGtkImage *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkimage != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkimage;
    }
  if ((type =  malloc(sizeof(NspTypeGtkMisc))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmisc(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkimage_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkimage_get_methods; 
  type->new = (new_func *) new_gtkimage;

  /* specific methods for gtkimage */
      
  type->init = (init_func *) init_gtkimage;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkimage */ 

  top->s_type =  (s_type_func *) gtkimage_type_as_string;    
  top->sh_type = (sh_type_func *) gtkimage_type_short_string;
  /* top->create = (create_func*) int_gtkimage_create;*/ 
  
  /* specific methods for gtkimage */
      
  type->init = (init_func *) init_gtkimage;

  if ( nsp_type_gtkimage_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkImage called nsp_type_gtkimage
       */
      type->id =  nsp_type_gtkimage_id = nsp_new_type_id();
      nsp_type_gtkimage = type;
      if ( nsp_register_type(nsp_type_gtkimage) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkimage, GTK_TYPE_IMAGE);
      return ( mode == T_BASE ) ? type : new_type_gtkimage(mode);
    }
  else 
    {
       type->id = nsp_type_gtkimage_id;
       return type;
    }
}

/*
 * initialize GtkImage instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkimage(NspGtkImage *o,NspTypeGtkImage *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkImage 
 */

NspGtkImage *new_gtkimage() 
{
  NspGtkImage *loc; 
  /* type must exists */
  nsp_type_gtkimage = new_type_gtkimage(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkImage)))== NULLGTKIMAGE) return loc;
  /* initialize object */
  if ( init_gtkimage(loc,nsp_type_gtkimage) == FAIL) return NULLGTKIMAGE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkImage 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkimage_type_name[]="GtkImage";
static char gtkimage_short_type_name[]="GtkImage";

static char *gtkimage_type_as_string(void)
{
  return(gtkimage_type_name);
}

static char *gtkimage_type_short_string(void)
{
  return(gtkimage_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkImage objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkImage   *gtkimage_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkimage_id) ) return ((NspGtkImage *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkimage));
  return NULL;
}

int IsGtkImageObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkimage_id);
}

int IsGtkImage(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkimage_id);
}

NspGtkImage  *GetGtkImageCopy(Stack stack, int i)
{
  if (  GetGtkImage(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkImage  *GetGtkImage(Stack stack, int i)
{
  NspGtkImage *M;
  if (( M = gtkimage_object(NthObj(i))) == NULLGTKIMAGE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkImage *gtkimage_copy(NspGtkImage *self)
{
  /* return gtkmisc_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimage);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimage);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkImage
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkImage *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkimage is initialized * /
  nsp_type_gtkimage = new_type_gtkimage(T_BASE);
  if(( H = gtkmisc_create(NVOID,(NspTypeBase *) nsp_type_gtkimage)) == NULLGTKIMAGE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 3999 "gtk.override"

static char *image_table[] = {  "pixmap", "image", "file",  "pixbuf",  "stock",  "icon_set","animation",NULL};
typedef enum { FROM_pixmap, FROM_image, FROM_file,  FROM_pixbuf,  FROM_stock,  FROM_icon_set,FROM_animation} image_from;

static int _wrap_gtk_image_new_from_pixmap(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string, obj_check, obj_check,t_end};
  NspGObject *pixmap, *mask;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&str,&nsp_type_gdkpixmap, &pixmap, &nsp_type_gdkpixmap, &mask) == FAIL) return RET_BUG;
    ret = gtk_image_new_from_pixmap(GDK_PIXMAP(pixmap->obj), GDK_PIXMAP(mask->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_image(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,obj_check, obj_check,t_end};
  NspGObject *image, *mask;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&str,&nsp_type_gdkimage, &image, &nsp_type_gdkpixmap, &mask) == FAIL) return RET_BUG;
    ret = gtk_image_new_from_image(GDK_IMAGE(image->obj), GDK_PIXMAP(mask->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_file(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,string,t_end};
  char *filename;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&str,&filename) == FAIL) return RET_BUG;
    ret = gtk_image_new_from_file(filename);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_pixbuf(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,obj_check,t_end};
  NspGObject *pixbuf;
  NspObject *nsp_ret;
  GtkWidget *ret;
  if ( rhs == 1 )
    {
      ret = gtk_image_new_from_pixbuf(NULL);
    }
  else 
    {
      if ( GetArgs(stack,rhs,opt,T,&str,&nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
      ret = gtk_image_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
    }
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_stock(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,string, objcopy,t_end};
  char *stock_id;
  GtkIconSize size;
  NspObject *nsp_size = NULL, *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&str,&stock_id, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
    ret = gtk_image_new_from_stock(stock_id, size);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_icon_set(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,obj, objcopy,t_end};
  NspObject *nsp_icon_set, *nsp_size = NULL, *nsp_ret;
  GtkIconSize size;
  GtkWidget *ret;
  GtkIconSet *icon_set = NULL;

  if ( GetArgs(stack,rhs,opt,T,&str,&nsp_icon_set, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_icon_set, GTK_TYPE_ICON_SET))
      icon_set = nspg_boxed_get(nsp_icon_set, GtkIconSet);
  else {
      Scierror( "icon_set should be a GtkIconSet");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
    ret = gtk_image_new_from_icon_set(icon_set, size);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_animation(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,obj_check,t_end};
  NspGObject *animation;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&str,&nsp_type_gdkpixbufanimation, &animation) == FAIL) return RET_BUG;
    ret = gtk_image_new_from_animation(GDK_PIXBUF_ANIMATION(animation->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtkimage_new(Stack stack, int rhs, int opt, int lhs)
{
  int rep;
  GObject *ret; NspObject *nsp_ret;

  if ( rhs == 0 ) 
    {
      if ((ret = (GObject *)gtk_image_new())== NULL) return RET_BUG;
      nsp_type_gtkimage = new_type_gtkimage(T_BASE);
      nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkimage );
      if ( nsp_ret == NULL) return RET_BUG;
      MoveObj(stack,1,nsp_ret);
      return 1;  
    }
  else 
    {
      if ((rep= GetStringInArray(stack,1,image_table,1)) == -1) return RET_BUG; 
      switch (rep) {
      case FROM_pixmap: return _wrap_gtk_image_new_from_pixmap(stack,rhs,opt,lhs);
      case FROM_image: return _wrap_gtk_image_new_from_image(stack,rhs,opt,lhs);
      case FROM_file:  return _wrap_gtk_image_new_from_file(stack,rhs,opt,lhs);
      case FROM_pixbuf:  return _wrap_gtk_image_new_from_pixbuf(stack,rhs,opt,lhs);
      case FROM_stock:  return _wrap_gtk_image_new_from_stock(stack,rhs,opt,lhs);
      case FROM_icon_set:return _wrap_gtk_image_new_from_icon_set(stack,rhs,opt,lhs);
      case FROM_animation: return _wrap_gtk_image_new_from_animation(stack,rhs,opt,lhs);
      }
    }
  return RET_BUG;;
}

#line 25156 "gtk.c"


static int _wrap_gtk_image_set_from_pixmap(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj,t_end};
  GdkBitmap *mask = NULL;
  NspGObject *pixmap, *nsp_mask;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixmap, &pixmap, &nsp_mask) == FAIL) return RET_BUG;
  if ( IsGdkBitmap((NspObject *)nsp_mask))
      mask = GDK_DRAWABLE(nsp_mask->obj);
  else if ( ! IsNone((NspObject *) nsp_mask))  {
      Scierror( "mask should be a GdkBitmap or None");
      return RET_BUG;
  }
  gtk_image_set_from_pixmap(GTK_IMAGE(self->obj), GDK_PIXMAP(pixmap->obj), mask);
  return 0;
}

static int _wrap_gtk_image_set_from_image(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GdkBitmap *mask = NULL;
  NspGObject *nsp_gdk_image, *nsp_mask;
  GdkImage *gdk_image = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_gdk_image, &nsp_mask) == FAIL) return RET_BUG;
  if ( IsGdkImage((NspObject *)nsp_gdk_image))
      gdk_image = GDK_IMAGE(nsp_gdk_image->obj);
  else if ( ! IsNone((NspObject *) nsp_gdk_image))  {
      Scierror( "gdk_image should be a GdkImage or None");
      return RET_BUG;
  }
  if ( IsGdkBitmap((NspObject *)nsp_mask))
      mask = GDK_DRAWABLE(nsp_mask->obj);
  else if ( ! IsNone((NspObject *) nsp_mask))  {
      Scierror( "mask should be a GdkBitmap or None");
      return RET_BUG;
  }
  gtk_image_set_from_image(GTK_IMAGE(self->obj), gdk_image, mask);
  return 0;
}

static int _wrap_gtk_image_set_from_file(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *filename;

  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
  gtk_image_set_from_file(GTK_IMAGE(self->obj), filename);
  return 0;
}

static int _wrap_gtk_image_set_from_pixbuf(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspGObject *nsp_pixbuf;
  GdkPixbuf *pixbuf = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_pixbuf) == FAIL) return RET_BUG;
  if ( IsGdkPixbuf((NspObject *)nsp_pixbuf))
      pixbuf = GDK_PIXBUF(nsp_pixbuf->obj);
  else if ( ! IsNone((NspObject *) nsp_pixbuf))  {
      Scierror( "pixbuf should be a GdkPixbuf or None");
      return RET_BUG;
  }
  gtk_image_set_from_pixbuf(GTK_IMAGE(self->obj), pixbuf);
  return 0;
}

static int _wrap_gtk_image_set_from_stock(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj,t_end};
  char *stock_id;
  GtkIconSize size;
  NspObject *nsp_size = NULL;

  if ( GetArgs(stack,rhs,opt,T,&stock_id, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
  gtk_image_set_from_stock(GTK_IMAGE(self->obj), stock_id, size);
  return 0;
}

static int _wrap_gtk_image_set_from_icon_set(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  NspObject *nsp_icon_set, *nsp_size = NULL;
  GtkIconSize size;
  GtkIconSet *icon_set = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_set, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_icon_set, GTK_TYPE_ICON_SET))
      icon_set = nspg_boxed_get(nsp_icon_set, GtkIconSet);
  else {
      Scierror( "icon_set should be a GtkIconSet");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
  gtk_image_set_from_icon_set(GTK_IMAGE(self->obj), icon_set, size);
  return 0;
}

static int _wrap_gtk_image_set_from_animation(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *animation;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbufanimation, &animation) == FAIL) return RET_BUG;
  gtk_image_set_from_animation(GTK_IMAGE(self->obj), GDK_PIXBUF_ANIMATION(animation->obj));
  return 0;
}

static int _wrap_gtk_image_get_storage_type(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_image_get_pixbuf(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;

  ret = gtk_image_get_pixbuf(GTK_IMAGE(self->obj));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_get_animation(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GdkPixbufAnimation *ret;

  ret = gtk_image_get_animation(GTK_IMAGE(self->obj));
  nsp_type_gdkpixbufanimation = new_type_gdkpixbufanimation(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbufanimation))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_set(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check,t_end};
  NspGObject *val, *mask;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkimage, &val, &nsp_type_gdkbitmap, &mask) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_image_set(GTK_IMAGE(self->obj), GDK_IMAGE(val->obj), GDK_DRAWABLE(mask->obj));
  return 0;
}

static NspMethods gtkimage_methods[] = {
  {"set_from_pixmap",(nsp_method *) _wrap_gtk_image_set_from_pixmap},
  {"set_from_image",(nsp_method *) _wrap_gtk_image_set_from_image},
  {"set_from_file",(nsp_method *) _wrap_gtk_image_set_from_file},
  {"set_from_pixbuf",(nsp_method *) _wrap_gtk_image_set_from_pixbuf},
  {"set_from_stock",(nsp_method *) _wrap_gtk_image_set_from_stock},
  {"set_from_icon_set",(nsp_method *) _wrap_gtk_image_set_from_icon_set},
  {"set_from_animation",(nsp_method *) _wrap_gtk_image_set_from_animation},
  {"get_storage_type",(nsp_method *) _wrap_gtk_image_get_storage_type},
  {"get_pixbuf",(nsp_method *) _wrap_gtk_image_get_pixbuf},
  {"get_animation",(nsp_method *) _wrap_gtk_image_get_animation},
  {"set",(nsp_method *) _wrap_gtk_image_set},
  { NULL, NULL}
};

static NspMethods *gtkimage_get_methods(void) { return gtkimage_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkimage_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkLabel ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkLabel_Private 
#include "nsp/gtk/gtklabel.h"
#include "nsp/interf.h"

/* NspGtkLabel inherits from NspGtkMisc */ 

int nsp_type_gtklabel_id=0;
NspTypeGtkLabel *nsp_type_gtklabel=NULL;

NspTypeGtkLabel *new_type_gtklabel(type_mode mode)
{
  NspTypeGtkLabel *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtklabel != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtklabel;
    }
  if ((type =  malloc(sizeof(NspTypeGtkMisc))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmisc(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtklabel_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtklabel_get_methods; 
  type->new = (new_func *) new_gtklabel;

  /* specific methods for gtklabel */
      
  type->init = (init_func *) init_gtklabel;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtklabel */ 

  top->s_type =  (s_type_func *) gtklabel_type_as_string;    
  top->sh_type = (sh_type_func *) gtklabel_type_short_string;
  /* top->create = (create_func*) int_gtklabel_create;*/ 
  
  /* specific methods for gtklabel */
      
  type->init = (init_func *) init_gtklabel;

  if ( nsp_type_gtklabel_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkLabel called nsp_type_gtklabel
       */
      type->id =  nsp_type_gtklabel_id = nsp_new_type_id();
      nsp_type_gtklabel = type;
      if ( nsp_register_type(nsp_type_gtklabel) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtklabel, GTK_TYPE_LABEL);
      return ( mode == T_BASE ) ? type : new_type_gtklabel(mode);
    }
  else 
    {
       type->id = nsp_type_gtklabel_id;
       return type;
    }
}

/*
 * initialize GtkLabel instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtklabel(NspGtkLabel *o,NspTypeGtkLabel *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkLabel 
 */

NspGtkLabel *new_gtklabel() 
{
  NspGtkLabel *loc; 
  /* type must exists */
  nsp_type_gtklabel = new_type_gtklabel(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkLabel)))== NULLGTKLABEL) return loc;
  /* initialize object */
  if ( init_gtklabel(loc,nsp_type_gtklabel) == FAIL) return NULLGTKLABEL;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkLabel 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtklabel_type_name[]="GtkLabel";
static char gtklabel_short_type_name[]="GtkLabel";

static char *gtklabel_type_as_string(void)
{
  return(gtklabel_type_name);
}

static char *gtklabel_type_short_string(void)
{
  return(gtklabel_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkLabel objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkLabel   *gtklabel_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtklabel_id) ) return ((NspGtkLabel *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtklabel));
  return NULL;
}

int IsGtkLabelObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtklabel_id);
}

int IsGtkLabel(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtklabel_id);
}

NspGtkLabel  *GetGtkLabelCopy(Stack stack, int i)
{
  if (  GetGtkLabel(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkLabel  *GetGtkLabel(Stack stack, int i)
{
  NspGtkLabel *M;
  if (( M = gtklabel_object(NthObj(i))) == NULLGTKLABEL)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkLabel *gtklabel_copy(NspGtkLabel *self)
{
  /* return gtkmisc_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklabel);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklabel);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkLabel
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkLabel *H;
  CheckRhs(0,0);
  / * want to be sure that type gtklabel is initialized * /
  nsp_type_gtklabel = new_type_gtklabel(T_BASE);
  if(( H = gtkmisc_create(NVOID,(NspTypeBase *) nsp_type_gtklabel)) == NULLGTKLABEL) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 1245 "gtk.override"
static int
_wrap_gtklabel_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"str",string,NULLOBJ,-1}, 
	{"mnemonic",string,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };

  char *str = NULL,  * mnemonic= NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &str,&mnemonic) == FAIL) return RET_BUG;
  if ( mnemonic != NULL) 
    {
      if ((ret = (GObject *)gtk_label_new_with_mnemonic(mnemonic))== NULL) return RET_BUG;
    }
  else 
    {
      if ((ret = (GObject *)gtk_label_new(str))== NULL) return RET_BUG;
    }
  nsp_type_gtklabel = new_type_gtklabel(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtklabel );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 25560 "gtk.c"


static int _wrap_gtk_label_set_text(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *str;

  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
  gtk_label_set_text(GTK_LABEL(self->obj), str);
  return 0;
}

static int _wrap_gtk_label_get_text(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_label_get_text(GTK_LABEL(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_attributes(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_attrs;
  PangoAttrList *attrs = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_attrs) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_attrs, PANGO_TYPE_ATTR_LIST))
      attrs = nspg_boxed_get(nsp_attrs, PangoAttrList);
  else {
      Scierror( "attrs should be a PangoAttrList");
      return RET_BUG;
  }
  gtk_label_set_attributes(GTK_LABEL(self->obj), attrs);
  return 0;
}

static int _wrap_gtk_label_get_attributes(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  PangoAttrList *ret;

  ret = gtk_label_get_attributes(GTK_LABEL(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,PANGO_TYPE_ATTR_LIST, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_pangoattrlist))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_label_set_label(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *str;

  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
  gtk_label_set_label(GTK_LABEL(self->obj), str);
  return 0;
}

static int _wrap_gtk_label_get_label(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_label_get_label(GTK_LABEL(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_markup(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *str;

  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
  gtk_label_set_markup(GTK_LABEL(self->obj), str);
  return 0;
}

static int _wrap_gtk_label_set_use_markup(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_label_set_use_markup(GTK_LABEL(self->obj), setting);
  return 0;
}

static int _wrap_gtk_label_get_use_markup(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_label_get_use_markup(GTK_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_use_underline(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_label_set_use_underline(GTK_LABEL(self->obj), setting);
  return 0;
}

static int _wrap_gtk_label_get_use_underline(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_label_get_use_underline(GTK_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_markup_with_mnemonic(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *str;

  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
  gtk_label_set_markup_with_mnemonic(GTK_LABEL(self->obj), str);
  return 0;
}

static int _wrap_gtk_label_get_mnemonic_keyval(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_label_get_mnemonic_keyval(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_mnemonic_widget(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
  gtk_label_set_mnemonic_widget(GTK_LABEL(self->obj), GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_label_get_mnemonic_widget(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

  ret = gtk_label_get_mnemonic_widget(GTK_LABEL(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_label_set_text_with_mnemonic(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *str;

  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
  gtk_label_set_text_with_mnemonic(GTK_LABEL(self->obj), str);
  return 0;
}

static int _wrap_gtk_label_set_justify(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_jtype = NULL;
  GtkJustification jtype;

  if ( GetArgs(stack,rhs,opt,T,&nsp_jtype) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_JUSTIFICATION, nsp_jtype, &jtype)== FAIL)
      return RET_BUG;
  gtk_label_set_justify(GTK_LABEL(self->obj), jtype);
  return 0;
}

static int _wrap_gtk_label_get_justify(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_label_get_justify(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_pattern(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *pattern;

  if ( GetArgs(stack,rhs,opt,T,&pattern) == FAIL) return RET_BUG;
  gtk_label_set_pattern(GTK_LABEL(self->obj), pattern);
  return 0;
}

static int _wrap_gtk_label_set_line_wrap(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int wrap;

  if ( GetArgs(stack,rhs,opt,T,&wrap) == FAIL) return RET_BUG;
  gtk_label_set_line_wrap(GTK_LABEL(self->obj), wrap);
  return 0;
}

static int _wrap_gtk_label_get_line_wrap(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_label_get_line_wrap(GTK_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_selectable(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_label_set_selectable(GTK_LABEL(self->obj), setting);
  return 0;
}

static int _wrap_gtk_label_get_selectable(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_label_get_selectable(GTK_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_select_region(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int start_offset, end_offset;

  if ( GetArgs(stack,rhs,opt,T,&start_offset, &end_offset) == FAIL) return RET_BUG;
  gtk_label_select_region(GTK_LABEL(self->obj), start_offset, end_offset);
  return 0;
}

#line 1291 "gtk.override"
static int
_wrap_gtk_label_get_selection_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int start, end;

  if (!gtk_label_get_selection_bounds(GTK_LABEL(self->obj), &start, &end)) 
    {
      if (  nsp_move_doubles(stack,1,0,0) == FAIL) 
	return RET_BUG; 
    }
  else 
    {
      if (  nsp_move_doubles(stack,1,1,2,(double) start, (double) end) == FAIL) 
	return RET_BUG; 
    }
  return 1; 
}
#line 25828 "gtk.c"


static int _wrap_gtk_label_get_layout(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  PangoLayout *ret;

  ret = gtk_label_get_layout(GTK_LABEL(self->obj));
  nsp_type_pangolayout = new_type_pangolayout(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangolayout))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 1310 "gtk.override"
static int
_wrap_gtk_label_get_layout_offsets(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint x, y; 
  gtk_label_get_layout_offsets(GTK_LABEL(self->obj), &x, &y);
  if (  nsp_move_doubles(stack,1,1,2,(double) x,(double) y) == FAIL) 
    return RET_BUG; 
  return 1; 
}
#line 25853 "gtk.c"


static int _wrap_gtk_label_set(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *str;

  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkLabel.set_text",stack.fname); return RET_BUG;
  gtk_label_set(GTK_LABEL(self->obj), str);
  return 0;
}

#line 1275 "gtk.override"
static int
_wrap_gtk_label_get(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  gchar *text = NULL;
  gtk_label_get(GTK_LABEL(self->obj), &text);
  if (text)
    ret = nsp_new_string_obj(NVOID,text,-1);
  else 
    ret = nsp_new_string_obj(NVOID,"",0);
  if (ret == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 25882 "gtk.c"


static int _wrap_gtk_label_parse_uline(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *string;
  int ret;

  if ( GetArgs(stack,rhs,opt,T,&string) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  ret = gtk_label_parse_uline(GTK_LABEL(self->obj), string);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtklabel_methods[] = {
  {"set_text",(nsp_method *) _wrap_gtk_label_set_text},
  {"get_text",(nsp_method *) _wrap_gtk_label_get_text},
  {"set_attributes",(nsp_method *) _wrap_gtk_label_set_attributes},
  {"get_attributes",(nsp_method *) _wrap_gtk_label_get_attributes},
  {"set_label",(nsp_method *) _wrap_gtk_label_set_label},
  {"get_label",(nsp_method *) _wrap_gtk_label_get_label},
  {"set_markup",(nsp_method *) _wrap_gtk_label_set_markup},
  {"set_use_markup",(nsp_method *) _wrap_gtk_label_set_use_markup},
  {"get_use_markup",(nsp_method *) _wrap_gtk_label_get_use_markup},
  {"set_use_underline",(nsp_method *) _wrap_gtk_label_set_use_underline},
  {"get_use_underline",(nsp_method *) _wrap_gtk_label_get_use_underline},
  {"set_markup_with_mnemonic",(nsp_method *) _wrap_gtk_label_set_markup_with_mnemonic},
  {"get_mnemonic_keyval",(nsp_method *) _wrap_gtk_label_get_mnemonic_keyval},
  {"set_mnemonic_widget",(nsp_method *) _wrap_gtk_label_set_mnemonic_widget},
  {"get_mnemonic_widget",(nsp_method *) _wrap_gtk_label_get_mnemonic_widget},
  {"set_text_with_mnemonic",(nsp_method *) _wrap_gtk_label_set_text_with_mnemonic},
  {"set_justify",(nsp_method *) _wrap_gtk_label_set_justify},
  {"get_justify",(nsp_method *) _wrap_gtk_label_get_justify},
  {"set_pattern",(nsp_method *) _wrap_gtk_label_set_pattern},
  {"set_line_wrap",(nsp_method *) _wrap_gtk_label_set_line_wrap},
  {"get_line_wrap",(nsp_method *) _wrap_gtk_label_get_line_wrap},
  {"set_selectable",(nsp_method *) _wrap_gtk_label_set_selectable},
  {"get_selectable",(nsp_method *) _wrap_gtk_label_get_selectable},
  {"select_region",(nsp_method *) _wrap_gtk_label_select_region},
  {"get_selection_bounds",(nsp_method *) _wrap_gtk_label_get_selection_bounds},
  {"get_layout",(nsp_method *) _wrap_gtk_label_get_layout},
  {"get_layout_offsets",(nsp_method *) _wrap_gtk_label_get_layout_offsets},
  {"set",(nsp_method *) _wrap_gtk_label_set},
  {"get",(nsp_method *) _wrap_gtk_label_get},
  {"parse_uline",(nsp_method *) _wrap_gtk_label_parse_uline},
  { NULL, NULL}
};

static NspMethods *gtklabel_get_methods(void) { return gtklabel_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtklabel_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkAccelLabel ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkAccelLabel_Private 
#include "nsp/gtk/gtkaccellabel.h"
#include "nsp/interf.h"

/* NspGtkAccelLabel inherits from NspGtkLabel */ 

int nsp_type_gtkaccellabel_id=0;
NspTypeGtkAccelLabel *nsp_type_gtkaccellabel=NULL;

NspTypeGtkAccelLabel *new_type_gtkaccellabel(type_mode mode)
{
  NspTypeGtkAccelLabel *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkaccellabel != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkaccellabel;
    }
  if ((type =  malloc(sizeof(NspTypeGtkLabel))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtklabel(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkaccellabel_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkaccellabel_get_methods; 
  type->new = (new_func *) new_gtkaccellabel;

  /* specific methods for gtkaccellabel */
      
  type->init = (init_func *) init_gtkaccellabel;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkaccellabel */ 

  top->s_type =  (s_type_func *) gtkaccellabel_type_as_string;    
  top->sh_type = (sh_type_func *) gtkaccellabel_type_short_string;
  /* top->create = (create_func*) int_gtkaccellabel_create;*/ 
  
  /* specific methods for gtkaccellabel */
      
  type->init = (init_func *) init_gtkaccellabel;

  if ( nsp_type_gtkaccellabel_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAccelLabel called nsp_type_gtkaccellabel
       */
      type->id =  nsp_type_gtkaccellabel_id = nsp_new_type_id();
      nsp_type_gtkaccellabel = type;
      if ( nsp_register_type(nsp_type_gtkaccellabel) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkaccellabel, GTK_TYPE_ACCEL_LABEL);
      return ( mode == T_BASE ) ? type : new_type_gtkaccellabel(mode);
    }
  else 
    {
       type->id = nsp_type_gtkaccellabel_id;
       return type;
    }
}

/*
 * initialize GtkAccelLabel instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkaccellabel(NspGtkAccelLabel *o,NspTypeGtkAccelLabel *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkAccelLabel 
 */

NspGtkAccelLabel *new_gtkaccellabel() 
{
  NspGtkAccelLabel *loc; 
  /* type must exists */
  nsp_type_gtkaccellabel = new_type_gtkaccellabel(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAccelLabel)))== NULLGTKACCELLABEL) return loc;
  /* initialize object */
  if ( init_gtkaccellabel(loc,nsp_type_gtkaccellabel) == FAIL) return NULLGTKACCELLABEL;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkAccelLabel 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkaccellabel_type_name[]="GtkAccelLabel";
static char gtkaccellabel_short_type_name[]="GtkAccelLabel";

static char *gtkaccellabel_type_as_string(void)
{
  return(gtkaccellabel_type_name);
}

static char *gtkaccellabel_type_short_string(void)
{
  return(gtkaccellabel_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkAccelLabel objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkAccelLabel   *gtkaccellabel_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkaccellabel_id) ) return ((NspGtkAccelLabel *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkaccellabel));
  return NULL;
}

int IsGtkAccelLabelObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkaccellabel_id);
}

int IsGtkAccelLabel(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkaccellabel_id);
}

NspGtkAccelLabel  *GetGtkAccelLabelCopy(Stack stack, int i)
{
  if (  GetGtkAccelLabel(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAccelLabel  *GetGtkAccelLabel(Stack stack, int i)
{
  NspGtkAccelLabel *M;
  if (( M = gtkaccellabel_object(NthObj(i))) == NULLGTKACCELLABEL)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAccelLabel *gtkaccellabel_copy(NspGtkAccelLabel *self)
{
  /* return gtklabel_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccellabel);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccellabel);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAccelLabel
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkAccelLabel *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkaccellabel is initialized * /
  nsp_type_gtkaccellabel = new_type_gtkaccellabel(T_BASE);
  if(( H = gtklabel_create(NVOID,(NspTypeBase *) nsp_type_gtkaccellabel)) == NULLGTKACCELLABEL) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkaccellabel_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *string;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&string) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_accel_label_new(string))== NULL) return RET_BUG;

  nsp_type_gtkaccellabel = new_type_gtkaccellabel(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkaccellabel );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_accel_label_accelerator_width(NspGtkAccelLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  Scierror("%s: deprecated use GtkAccelLabel.get_accel_width",stack.fname); return RET_BUG;
  ret = gtk_accel_label_accelerator_width(GTK_ACCEL_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_accel_label_get_accel_widget(NspGtkAccelLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

  ret = gtk_accel_label_get_accel_widget(GTK_ACCEL_LABEL(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_accel_label_get_accel_width(NspGtkAccelLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_accel_label_get_accel_width(GTK_ACCEL_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_accel_label_set_accel_widget(NspGtkAccelLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *accel_widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &accel_widget) == FAIL) return RET_BUG;
  gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(self->obj), GTK_WIDGET(accel_widget->obj));
  return 0;
}

static int _wrap_gtk_accel_label_refetch(NspGtkAccelLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_accel_label_refetch(GTK_ACCEL_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkaccellabel_methods[] = {
  {"accelerator_width",(nsp_method *) _wrap_gtk_accel_label_accelerator_width},
  {"get_accel_widget",(nsp_method *) _wrap_gtk_accel_label_get_accel_widget},
  {"get_accel_width",(nsp_method *) _wrap_gtk_accel_label_get_accel_width},
  {"set_accel_widget",(nsp_method *) _wrap_gtk_accel_label_set_accel_widget},
  {"refetch",(nsp_method *) _wrap_gtk_accel_label_refetch},
  { NULL, NULL}
};

static NspMethods *gtkaccellabel_get_methods(void) { return gtkaccellabel_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkaccellabel_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkInvisible ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkInvisible_Private 
#include "nsp/gtk/gtkinvisible.h"
#include "nsp/interf.h"

/* NspGtkInvisible inherits from NspGtkWidget */ 

int nsp_type_gtkinvisible_id=0;
NspTypeGtkInvisible *nsp_type_gtkinvisible=NULL;

NspTypeGtkInvisible *new_type_gtkinvisible(type_mode mode)
{
  NspTypeGtkInvisible *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkinvisible != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkinvisible;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkinvisible_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkinvisible_get_methods; 
  type->new = (new_func *) new_gtkinvisible;

  /* specific methods for gtkinvisible */
      
  type->init = (init_func *) init_gtkinvisible;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkinvisible */ 

  top->s_type =  (s_type_func *) gtkinvisible_type_as_string;    
  top->sh_type = (sh_type_func *) gtkinvisible_type_short_string;
  /* top->create = (create_func*) int_gtkinvisible_create;*/ 
  
  /* specific methods for gtkinvisible */
      
  type->init = (init_func *) init_gtkinvisible;

  if ( nsp_type_gtkinvisible_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkInvisible called nsp_type_gtkinvisible
       */
      type->id =  nsp_type_gtkinvisible_id = nsp_new_type_id();
      nsp_type_gtkinvisible = type;
      if ( nsp_register_type(nsp_type_gtkinvisible) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkinvisible, GTK_TYPE_INVISIBLE);
      return ( mode == T_BASE ) ? type : new_type_gtkinvisible(mode);
    }
  else 
    {
       type->id = nsp_type_gtkinvisible_id;
       return type;
    }
}

/*
 * initialize GtkInvisible instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkinvisible(NspGtkInvisible *o,NspTypeGtkInvisible *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkInvisible 
 */

NspGtkInvisible *new_gtkinvisible() 
{
  NspGtkInvisible *loc; 
  /* type must exists */
  nsp_type_gtkinvisible = new_type_gtkinvisible(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkInvisible)))== NULLGTKINVISIBLE) return loc;
  /* initialize object */
  if ( init_gtkinvisible(loc,nsp_type_gtkinvisible) == FAIL) return NULLGTKINVISIBLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkInvisible 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkinvisible_type_name[]="GtkInvisible";
static char gtkinvisible_short_type_name[]="GtkInvisible";

static char *gtkinvisible_type_as_string(void)
{
  return(gtkinvisible_type_name);
}

static char *gtkinvisible_type_short_string(void)
{
  return(gtkinvisible_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkInvisible objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkInvisible   *gtkinvisible_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkinvisible_id) ) return ((NspGtkInvisible *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkinvisible));
  return NULL;
}

int IsGtkInvisibleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkinvisible_id);
}

int IsGtkInvisible(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkinvisible_id);
}

NspGtkInvisible  *GetGtkInvisibleCopy(Stack stack, int i)
{
  if (  GetGtkInvisible(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkInvisible  *GetGtkInvisible(Stack stack, int i)
{
  NspGtkInvisible *M;
  if (( M = gtkinvisible_object(NthObj(i))) == NULLGTKINVISIBLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkInvisible *gtkinvisible_copy(NspGtkInvisible *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkinvisible);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkinvisible);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkInvisible
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkInvisible *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkinvisible is initialized * /
  nsp_type_gtkinvisible = new_type_gtkinvisible(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkinvisible)) == NULLGTKINVISIBLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkinvisible_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_invisible_new())== NULL) return RET_BUG;

  nsp_type_gtkinvisible = new_type_gtkinvisible(T_BASE);
    /* g_xxxx_object_ref(ret); XXXwe don't own the first reference of invisibles */
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkinvisible );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkinvisible_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkinvisible_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkEntry ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkEntry_Private 
#include "nsp/gtk/gtkentry.h"
#include "nsp/interf.h"

/* NspGtkEntry inherits from NspGtkWidget */ 

int nsp_type_gtkentry_id=0;
NspTypeGtkEntry *nsp_type_gtkentry=NULL;

NspTypeGtkEntry *new_type_gtkentry(type_mode mode)
{
  NspTypeGtkEntry *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkentry != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkentry;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkentry_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkentry_get_methods; 
  type->new = (new_func *) new_gtkentry;

  /* specific methods for gtkentry */
      
  type->init = (init_func *) init_gtkentry;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkentry */ 

  top->s_type =  (s_type_func *) gtkentry_type_as_string;    
  top->sh_type = (sh_type_func *) gtkentry_type_short_string;
  /* top->create = (create_func*) int_gtkentry_create;*/ 
  
  /* specific methods for gtkentry */
      
  type->init = (init_func *) init_gtkentry;

  type->interface =  (NspTypeBase *) new_type_gtkeditable(T_DERIVED);
  type->interface->interface =  (NspTypeBase *) new_type_gtkcelleditable(T_DERIVED);
  if ( nsp_type_gtkentry_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkEntry called nsp_type_gtkentry
       */
      type->id =  nsp_type_gtkentry_id = nsp_new_type_id();
      nsp_type_gtkentry = type;
      if ( nsp_register_type(nsp_type_gtkentry) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkentry, GTK_TYPE_ENTRY);
      return ( mode == T_BASE ) ? type : new_type_gtkentry(mode);
    }
  else 
    {
       type->id = nsp_type_gtkentry_id;
       return type;
    }
}

/*
 * initialize GtkEntry instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkentry(NspGtkEntry *o,NspTypeGtkEntry *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkEntry 
 */

NspGtkEntry *new_gtkentry() 
{
  NspGtkEntry *loc; 
  /* type must exists */
  nsp_type_gtkentry = new_type_gtkentry(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkEntry)))== NULLGTKENTRY) return loc;
  /* initialize object */
  if ( init_gtkentry(loc,nsp_type_gtkentry) == FAIL) return NULLGTKENTRY;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkEntry 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkentry_type_name[]="GtkEntry";
static char gtkentry_short_type_name[]="GtkEntry";

static char *gtkentry_type_as_string(void)
{
  return(gtkentry_type_name);
}

static char *gtkentry_type_short_string(void)
{
  return(gtkentry_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkEntry objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkEntry   *gtkentry_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkentry_id) ) return ((NspGtkEntry *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkentry));
  return NULL;
}

int IsGtkEntryObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkentry_id);
}

int IsGtkEntry(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkentry_id);
}

NspGtkEntry  *GetGtkEntryCopy(Stack stack, int i)
{
  if (  GetGtkEntry(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkEntry  *GetGtkEntry(Stack stack, int i)
{
  NspGtkEntry *M;
  if (( M = gtkentry_object(NthObj(i))) == NULLGTKENTRY)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkEntry *gtkentry_copy(NspGtkEntry *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkentry);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkentry);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkEntry
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkEntry *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkentry is initialized * /
  nsp_type_gtkentry = new_type_gtkentry(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkentry)) == NULLGTKENTRY) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkentry_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"max",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int max = 0;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &max) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_entry_new_with_max_length(max))== NULL) return RET_BUG;

  nsp_type_gtkentry = new_type_gtkentry(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkentry );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_entry_set_visibility(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int visible;

  if ( GetArgs(stack,rhs,opt,T,&visible) == FAIL) return RET_BUG;
  gtk_entry_set_visibility(GTK_ENTRY(self->obj), visible);
  return 0;
}

static int _wrap_gtk_entry_get_visibility(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_entry_get_visibility(GTK_ENTRY(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_invisible_char(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int nsp_ch = 0;
  gunichar ch;

  if ( GetArgs(stack,rhs,opt,T,&nsp_ch) == FAIL) return RET_BUG;
  ch = (gunichar)nsp_ch;
  gtk_entry_set_invisible_char(GTK_ENTRY(self->obj), ch);
  return 0;
}

static int _wrap_gtk_entry_get_invisible_char(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  gunichar ret;

  ret = gtk_entry_get_invisible_char(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)== FAIL)return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_has_frame(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_entry_set_has_frame(GTK_ENTRY(self->obj), setting);
  return 0;
}

static int _wrap_gtk_entry_get_has_frame(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_entry_get_has_frame(GTK_ENTRY(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_max_length(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int max;

  if ( GetArgs(stack,rhs,opt,T,&max) == FAIL) return RET_BUG;
  gtk_entry_set_max_length(GTK_ENTRY(self->obj), max);
  return 0;
}

static int _wrap_gtk_entry_get_max_length(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_entry_get_max_length(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_activates_default(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_entry_set_activates_default(GTK_ENTRY(self->obj), setting);
  return 0;
}

static int _wrap_gtk_entry_get_activates_default(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_entry_get_activates_default(GTK_ENTRY(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_width_chars(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int n_chars;

  if ( GetArgs(stack,rhs,opt,T,&n_chars) == FAIL) return RET_BUG;
  gtk_entry_set_width_chars(GTK_ENTRY(self->obj), n_chars);
  return 0;
}

static int _wrap_gtk_entry_get_width_chars(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_entry_get_width_chars(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_text(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *text;

  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
  gtk_entry_set_text(GTK_ENTRY(self->obj), text);
  return 0;
}

static int _wrap_gtk_entry_get_text(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_entry_get_text(GTK_ENTRY(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_get_layout(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  PangoLayout *ret;

  ret = gtk_entry_get_layout(GTK_ENTRY(self->obj));
  nsp_type_pangolayout = new_type_pangolayout(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangolayout))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 3682 "gtk.override"
static int
_wrap_gtk_entry_get_layout_offsets(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int x, y;

  gtk_entry_get_layout_offsets(GTK_ENTRY(self->obj), &x, &y);
  if (  nsp_move_doubles(stack,1,1,2,(double) x,(double) y) == FAIL) 
    return RET_BUG; 
  return 1; 
}
#line 26806 "gtk.c"


static int _wrap_gtk_entry_append_text(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *text;

  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkEditable.insert_text",stack.fname); return RET_BUG;
  gtk_entry_append_text(GTK_ENTRY(self->obj), text);
  return 0;
}

static int _wrap_gtk_entry_prepend_text(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *text;

  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkEditable.insert_text",stack.fname); return RET_BUG;
  gtk_entry_prepend_text(GTK_ENTRY(self->obj), text);
  return 0;
}

static NspMethods gtkentry_methods[] = {
  {"set_visibility",(nsp_method *) _wrap_gtk_entry_set_visibility},
  {"get_visibility",(nsp_method *) _wrap_gtk_entry_get_visibility},
  {"set_invisible_char",(nsp_method *) _wrap_gtk_entry_set_invisible_char},
  {"get_invisible_char",(nsp_method *) _wrap_gtk_entry_get_invisible_char},
  {"set_has_frame",(nsp_method *) _wrap_gtk_entry_set_has_frame},
  {"get_has_frame",(nsp_method *) _wrap_gtk_entry_get_has_frame},
  {"set_max_length",(nsp_method *) _wrap_gtk_entry_set_max_length},
  {"get_max_length",(nsp_method *) _wrap_gtk_entry_get_max_length},
  {"set_activates_default",(nsp_method *) _wrap_gtk_entry_set_activates_default},
  {"get_activates_default",(nsp_method *) _wrap_gtk_entry_get_activates_default},
  {"set_width_chars",(nsp_method *) _wrap_gtk_entry_set_width_chars},
  {"get_width_chars",(nsp_method *) _wrap_gtk_entry_get_width_chars},
  {"set_text",(nsp_method *) _wrap_gtk_entry_set_text},
  {"get_text",(nsp_method *) _wrap_gtk_entry_get_text},
  {"get_layout",(nsp_method *) _wrap_gtk_entry_get_layout},
  {"get_layout_offsets",(nsp_method *) _wrap_gtk_entry_get_layout_offsets},
  {"append_text",(nsp_method *) _wrap_gtk_entry_append_text},
  {"prepend_text",(nsp_method *) _wrap_gtk_entry_prepend_text},
  { NULL, NULL}
};

static NspMethods *gtkentry_get_methods(void) { return gtkentry_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkentry_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkSpinButton ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkSpinButton_Private 
#include "nsp/gtk/gtkspinbutton.h"
#include "nsp/interf.h"

/* NspGtkSpinButton inherits from NspGtkEntry */ 

int nsp_type_gtkspinbutton_id=0;
NspTypeGtkSpinButton *nsp_type_gtkspinbutton=NULL;

NspTypeGtkSpinButton *new_type_gtkspinbutton(type_mode mode)
{
  NspTypeGtkSpinButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkspinbutton != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkspinbutton;
    }
  if ((type =  malloc(sizeof(NspTypeGtkEntry))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkentry(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkspinbutton_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkspinbutton_get_methods; 
  type->new = (new_func *) new_gtkspinbutton;

  /* specific methods for gtkspinbutton */
      
  type->init = (init_func *) init_gtkspinbutton;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkspinbutton */ 

  top->s_type =  (s_type_func *) gtkspinbutton_type_as_string;    
  top->sh_type = (sh_type_func *) gtkspinbutton_type_short_string;
  /* top->create = (create_func*) int_gtkspinbutton_create;*/ 
  
  /* specific methods for gtkspinbutton */
      
  type->init = (init_func *) init_gtkspinbutton;

  if ( nsp_type_gtkspinbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSpinButton called nsp_type_gtkspinbutton
       */
      type->id =  nsp_type_gtkspinbutton_id = nsp_new_type_id();
      nsp_type_gtkspinbutton = type;
      if ( nsp_register_type(nsp_type_gtkspinbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkspinbutton, GTK_TYPE_SPIN_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkspinbutton(mode);
    }
  else 
    {
       type->id = nsp_type_gtkspinbutton_id;
       return type;
    }
}

/*
 * initialize GtkSpinButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkspinbutton(NspGtkSpinButton *o,NspTypeGtkSpinButton *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkSpinButton 
 */

NspGtkSpinButton *new_gtkspinbutton() 
{
  NspGtkSpinButton *loc; 
  /* type must exists */
  nsp_type_gtkspinbutton = new_type_gtkspinbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSpinButton)))== NULLGTKSPINBUTTON) return loc;
  /* initialize object */
  if ( init_gtkspinbutton(loc,nsp_type_gtkspinbutton) == FAIL) return NULLGTKSPINBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkSpinButton 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkspinbutton_type_name[]="GtkSpinButton";
static char gtkspinbutton_short_type_name[]="GtkSpinButton";

static char *gtkspinbutton_type_as_string(void)
{
  return(gtkspinbutton_type_name);
}

static char *gtkspinbutton_type_short_string(void)
{
  return(gtkspinbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkSpinButton objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkSpinButton   *gtkspinbutton_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkspinbutton_id) ) return ((NspGtkSpinButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkspinbutton));
  return NULL;
}

int IsGtkSpinButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkspinbutton_id);
}

int IsGtkSpinButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkspinbutton_id);
}

NspGtkSpinButton  *GetGtkSpinButtonCopy(Stack stack, int i)
{
  if (  GetGtkSpinButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSpinButton  *GetGtkSpinButton(Stack stack, int i)
{
  NspGtkSpinButton *M;
  if (( M = gtkspinbutton_object(NthObj(i))) == NULLGTKSPINBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSpinButton *gtkspinbutton_copy(NspGtkSpinButton *self)
{
  /* return gtkentry_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkspinbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkspinbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSpinButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkSpinButton *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkspinbutton is initialized * /
  nsp_type_gtkspinbutton = new_type_gtkspinbutton(T_BASE);
  if(( H = gtkentry_create(NVOID,(NspTypeBase *) nsp_type_gtkspinbutton)) == NULLGTKSPINBUTTON) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkspinbutton_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"adjustment",obj,NULLOBJ,-1}, 
	{"climb_rate",s_double,NULLOBJ,-1}, 
	{"digits",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int digits = 0;
  NspGObject *nsp_adjustment = NULL;
  GtkAdjustment *adjustment = NULL;
  double climb_rate = 0.0;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_adjustment, &climb_rate, &digits) == FAIL) return RET_BUG;
  if ( nsp_adjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
    else if (! IsNone((NspObject *)nsp_adjustment)) {
         Scierror( "adjustment should be a GtkAdjustment or None");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_spin_button_new(adjustment, climb_rate, digits))== NULL) return RET_BUG;

  nsp_type_gtkspinbutton = new_type_gtkspinbutton(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkspinbutton );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_spin_button_configure(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, s_double, s_int,t_end};
  int digits;
  NspGObject *nsp_adjustment;
  GtkAdjustment *adjustment = NULL;
  double climb_rate;

  if ( GetArgs(stack,rhs,opt,T,&nsp_adjustment, &climb_rate, &digits) == FAIL) return RET_BUG;
  if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
  else if ( ! IsNone((NspObject *) nsp_adjustment))  {
      Scierror( "adjustment should be a GtkAdjustment or None");
      return RET_BUG;
  }
  gtk_spin_button_configure(GTK_SPIN_BUTTON(self->obj), adjustment, climb_rate, digits);
  return 0;
}

static int _wrap_gtk_spin_button_set_adjustment(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *adjustment;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
  gtk_spin_button_set_adjustment(GTK_SPIN_BUTTON(self->obj), GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_spin_button_get_adjustment(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_spin_button_get_adjustment(GTK_SPIN_BUTTON(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_spin_button_set_digits(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int digits;

  if ( GetArgs(stack,rhs,opt,T,&digits) == FAIL) return RET_BUG;
  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(self->obj), digits);
  return 0;
}

static int _wrap_gtk_spin_button_get_digits(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_spin_button_get_digits(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_set_increments(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, s_double,t_end};
  double step, page;

  if ( GetArgs(stack,rhs,opt,T,&step, &page) == FAIL) return RET_BUG;
  gtk_spin_button_set_increments(GTK_SPIN_BUTTON(self->obj), step, page);
  return 0;
}

#line 1321 "gtk.override"
static int
_wrap_gtk_spin_button_get_increments(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gdouble step;
  gdouble page;

  gtk_spin_button_get_increments(GTK_SPIN_BUTTON(self->obj), &step, &page);
  if (  nsp_move_doubles(stack,1,1,2,(double) step,(double) page) == FAIL) 
    return RET_BUG; 
  return 1; 

}
#line 27170 "gtk.c"


static int _wrap_gtk_spin_button_set_range(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, s_double,t_end};
  double min, max;

  if ( GetArgs(stack,rhs,opt,T,&min, &max) == FAIL) return RET_BUG;
  gtk_spin_button_set_range(GTK_SPIN_BUTTON(self->obj), min, max);
  return 0;
}

#line 1335 "gtk.override"
static int
_wrap_gtk_spin_button_get_range(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gdouble min;
  gdouble max;

  gtk_spin_button_get_range(GTK_SPIN_BUTTON(self->obj), &min, &max);
  if (  nsp_move_doubles(stack,1,1,2,(double) min,(double) max) == FAIL) 
    return RET_BUG; 
  return 1; 
}
#line 27195 "gtk.c"


static int _wrap_gtk_spin_button_get_value(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;

  ret = gtk_spin_button_get_value(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_get_value_as_int(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_set_value(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,t_end};
  double value;

  if ( GetArgs(stack,rhs,opt,T,&value) == FAIL) return RET_BUG;
  gtk_spin_button_set_value(GTK_SPIN_BUTTON(self->obj), value);
  return 0;
}

static int _wrap_gtk_spin_button_set_update_policy(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_policy = NULL;
  GtkSpinButtonUpdatePolicy policy;

  if ( GetArgs(stack,rhs,opt,T,&nsp_policy) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SPIN_BUTTON_UPDATE_POLICY, nsp_policy, &policy)== FAIL)
      return RET_BUG;
  gtk_spin_button_set_update_policy(GTK_SPIN_BUTTON(self->obj), policy);
  return 0;
}

static int _wrap_gtk_spin_button_get_update_policy(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_spin_button_get_update_policy(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_set_numeric(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int numeric;

  if ( GetArgs(stack,rhs,opt,T,&numeric) == FAIL) return RET_BUG;
  gtk_spin_button_set_numeric(GTK_SPIN_BUTTON(self->obj), numeric);
  return 0;
}

static int _wrap_gtk_spin_button_get_numeric(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_spin_button_get_numeric(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_spin(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, s_double,t_end};
  double increment;
  GtkSpinType direction;
  NspObject *nsp_direction = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_direction, &increment) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SPIN_TYPE, nsp_direction, &direction)== FAIL)
      return RET_BUG;
  gtk_spin_button_spin(GTK_SPIN_BUTTON(self->obj), direction, increment);
  return 0;
}

static int _wrap_gtk_spin_button_set_wrap(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int wrap;

  if ( GetArgs(stack,rhs,opt,T,&wrap) == FAIL) return RET_BUG;
  gtk_spin_button_set_wrap(GTK_SPIN_BUTTON(self->obj), wrap);
  return 0;
}

static int _wrap_gtk_spin_button_get_wrap(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_spin_button_get_wrap(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_set_snap_to_ticks(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int snap_to_ticks;

  if ( GetArgs(stack,rhs,opt,T,&snap_to_ticks) == FAIL) return RET_BUG;
  gtk_spin_button_set_snap_to_ticks(GTK_SPIN_BUTTON(self->obj), snap_to_ticks);
  return 0;
}

static int _wrap_gtk_spin_button_get_snap_to_ticks(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_spin_button_get_snap_to_ticks(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_update(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_spin_button_update(GTK_SPIN_BUTTON(self->obj));
  return 0;
}

static NspMethods gtkspinbutton_methods[] = {
  {"configure",(nsp_method *) _wrap_gtk_spin_button_configure},
  {"set_adjustment",(nsp_method *) _wrap_gtk_spin_button_set_adjustment},
  {"get_adjustment",(nsp_method *) _wrap_gtk_spin_button_get_adjustment},
  {"set_digits",(nsp_method *) _wrap_gtk_spin_button_set_digits},
  {"get_digits",(nsp_method *) _wrap_gtk_spin_button_get_digits},
  {"set_increments",(nsp_method *) _wrap_gtk_spin_button_set_increments},
  {"get_increments",(nsp_method *) _wrap_gtk_spin_button_get_increments},
  {"set_range",(nsp_method *) _wrap_gtk_spin_button_set_range},
  {"get_range",(nsp_method *) _wrap_gtk_spin_button_get_range},
  {"get_value",(nsp_method *) _wrap_gtk_spin_button_get_value},
  {"get_value_as_int",(nsp_method *) _wrap_gtk_spin_button_get_value_as_int},
  {"set_value",(nsp_method *) _wrap_gtk_spin_button_set_value},
  {"set_update_policy",(nsp_method *) _wrap_gtk_spin_button_set_update_policy},
  {"get_update_policy",(nsp_method *) _wrap_gtk_spin_button_get_update_policy},
  {"set_numeric",(nsp_method *) _wrap_gtk_spin_button_set_numeric},
  {"get_numeric",(nsp_method *) _wrap_gtk_spin_button_get_numeric},
  {"spin",(nsp_method *) _wrap_gtk_spin_button_spin},
  {"set_wrap",(nsp_method *) _wrap_gtk_spin_button_set_wrap},
  {"get_wrap",(nsp_method *) _wrap_gtk_spin_button_get_wrap},
  {"set_snap_to_ticks",(nsp_method *) _wrap_gtk_spin_button_set_snap_to_ticks},
  {"get_snap_to_ticks",(nsp_method *) _wrap_gtk_spin_button_get_snap_to_ticks},
  {"update",(nsp_method *) _wrap_gtk_spin_button_update},
  { NULL, NULL}
};

static NspMethods *gtkspinbutton_get_methods(void) { return gtkspinbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkspinbutton_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkDrawingArea ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkDrawingArea_Private 
#include "nsp/gtk/gtkdrawingarea.h"
#include "nsp/interf.h"

/* NspGtkDrawingArea inherits from NspGtkWidget */ 

int nsp_type_gtkdrawingarea_id=0;
NspTypeGtkDrawingArea *nsp_type_gtkdrawingarea=NULL;

NspTypeGtkDrawingArea *new_type_gtkdrawingarea(type_mode mode)
{
  NspTypeGtkDrawingArea *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkdrawingarea != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkdrawingarea;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkdrawingarea_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkdrawingarea_get_methods; 
  type->new = (new_func *) new_gtkdrawingarea;

  /* specific methods for gtkdrawingarea */
      
  type->init = (init_func *) init_gtkdrawingarea;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkdrawingarea */ 

  top->s_type =  (s_type_func *) gtkdrawingarea_type_as_string;    
  top->sh_type = (sh_type_func *) gtkdrawingarea_type_short_string;
  /* top->create = (create_func*) int_gtkdrawingarea_create;*/ 
  
  /* specific methods for gtkdrawingarea */
      
  type->init = (init_func *) init_gtkdrawingarea;

  if ( nsp_type_gtkdrawingarea_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkDrawingArea called nsp_type_gtkdrawingarea
       */
      type->id =  nsp_type_gtkdrawingarea_id = nsp_new_type_id();
      nsp_type_gtkdrawingarea = type;
      if ( nsp_register_type(nsp_type_gtkdrawingarea) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkdrawingarea, GTK_TYPE_DRAWING_AREA);
      return ( mode == T_BASE ) ? type : new_type_gtkdrawingarea(mode);
    }
  else 
    {
       type->id = nsp_type_gtkdrawingarea_id;
       return type;
    }
}

/*
 * initialize GtkDrawingArea instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkdrawingarea(NspGtkDrawingArea *o,NspTypeGtkDrawingArea *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkDrawingArea 
 */

NspGtkDrawingArea *new_gtkdrawingarea() 
{
  NspGtkDrawingArea *loc; 
  /* type must exists */
  nsp_type_gtkdrawingarea = new_type_gtkdrawingarea(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkDrawingArea)))== NULLGTKDRAWINGAREA) return loc;
  /* initialize object */
  if ( init_gtkdrawingarea(loc,nsp_type_gtkdrawingarea) == FAIL) return NULLGTKDRAWINGAREA;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkDrawingArea 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkdrawingarea_type_name[]="GtkDrawingArea";
static char gtkdrawingarea_short_type_name[]="GtkDrawingArea";

static char *gtkdrawingarea_type_as_string(void)
{
  return(gtkdrawingarea_type_name);
}

static char *gtkdrawingarea_type_short_string(void)
{
  return(gtkdrawingarea_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkDrawingArea objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkDrawingArea   *gtkdrawingarea_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkdrawingarea_id) ) return ((NspGtkDrawingArea *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkdrawingarea));
  return NULL;
}

int IsGtkDrawingAreaObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkdrawingarea_id);
}

int IsGtkDrawingArea(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkdrawingarea_id);
}

NspGtkDrawingArea  *GetGtkDrawingAreaCopy(Stack stack, int i)
{
  if (  GetGtkDrawingArea(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkDrawingArea  *GetGtkDrawingArea(Stack stack, int i)
{
  NspGtkDrawingArea *M;
  if (( M = gtkdrawingarea_object(NthObj(i))) == NULLGTKDRAWINGAREA)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkDrawingArea *gtkdrawingarea_copy(NspGtkDrawingArea *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkdrawingarea);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkdrawingarea);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkDrawingArea
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkDrawingArea *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkdrawingarea is initialized * /
  nsp_type_gtkdrawingarea = new_type_gtkdrawingarea(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkdrawingarea)) == NULLGTKDRAWINGAREA) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkdrawingarea_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_drawing_area_new())== NULL) return RET_BUG;

  nsp_type_gtkdrawingarea = new_type_gtkdrawingarea(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkdrawingarea );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_drawing_area_size(NspGtkDrawingArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int width, height;

  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkWidget.set_size_request",stack.fname); return RET_BUG;
  gtk_drawing_area_size(GTK_DRAWING_AREA(self->obj), width, height);
  return 0;
}

static NspMethods gtkdrawingarea_methods[] = {
  {"size",(nsp_method *) _wrap_gtk_drawing_area_size},
  { NULL, NULL}
};

static NspMethods *gtkdrawingarea_get_methods(void) { return gtkdrawingarea_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkdrawingarea_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkCurve ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkCurve_Private 
#include "nsp/gtk/gtkcurve.h"
#include "nsp/interf.h"

/* NspGtkCurve inherits from NspGtkDrawingArea */ 

int nsp_type_gtkcurve_id=0;
NspTypeGtkCurve *nsp_type_gtkcurve=NULL;

NspTypeGtkCurve *new_type_gtkcurve(type_mode mode)
{
  NspTypeGtkCurve *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcurve != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcurve;
    }
  if ((type =  malloc(sizeof(NspTypeGtkDrawingArea))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdrawingarea(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcurve_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcurve_get_methods; 
  type->new = (new_func *) new_gtkcurve;

  /* specific methods for gtkcurve */
      
  type->init = (init_func *) init_gtkcurve;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcurve */ 

  top->s_type =  (s_type_func *) gtkcurve_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcurve_type_short_string;
  /* top->create = (create_func*) int_gtkcurve_create;*/ 
  
  /* specific methods for gtkcurve */
      
  type->init = (init_func *) init_gtkcurve;

  if ( nsp_type_gtkcurve_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCurve called nsp_type_gtkcurve
       */
      type->id =  nsp_type_gtkcurve_id = nsp_new_type_id();
      nsp_type_gtkcurve = type;
      if ( nsp_register_type(nsp_type_gtkcurve) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcurve, GTK_TYPE_CURVE);
      return ( mode == T_BASE ) ? type : new_type_gtkcurve(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcurve_id;
       return type;
    }
}

/*
 * initialize GtkCurve instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcurve(NspGtkCurve *o,NspTypeGtkCurve *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkCurve 
 */

NspGtkCurve *new_gtkcurve() 
{
  NspGtkCurve *loc; 
  /* type must exists */
  nsp_type_gtkcurve = new_type_gtkcurve(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCurve)))== NULLGTKCURVE) return loc;
  /* initialize object */
  if ( init_gtkcurve(loc,nsp_type_gtkcurve) == FAIL) return NULLGTKCURVE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkCurve 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcurve_type_name[]="GtkCurve";
static char gtkcurve_short_type_name[]="GtkCurve";

static char *gtkcurve_type_as_string(void)
{
  return(gtkcurve_type_name);
}

static char *gtkcurve_type_short_string(void)
{
  return(gtkcurve_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkCurve objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkCurve   *gtkcurve_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcurve_id) ) return ((NspGtkCurve *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcurve));
  return NULL;
}

int IsGtkCurveObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcurve_id);
}

int IsGtkCurve(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcurve_id);
}

NspGtkCurve  *GetGtkCurveCopy(Stack stack, int i)
{
  if (  GetGtkCurve(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCurve  *GetGtkCurve(Stack stack, int i)
{
  NspGtkCurve *M;
  if (( M = gtkcurve_object(NthObj(i))) == NULLGTKCURVE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCurve *gtkcurve_copy(NspGtkCurve *self)
{
  /* return gtkdrawingarea_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcurve);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcurve);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCurve
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkCurve *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcurve is initialized * /
  nsp_type_gtkcurve = new_type_gtkcurve(T_BASE);
  if(( H = gtkdrawingarea_create(NVOID,(NspTypeBase *) nsp_type_gtkcurve)) == NULLGTKCURVE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkcurve_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_curve_new())== NULL) return RET_BUG;

  nsp_type_gtkcurve = new_type_gtkcurve(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcurve );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_curve_reset(NspGtkCurve *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_curve_reset(GTK_CURVE(self->obj));
  return 0;
}

static int _wrap_gtk_curve_set_gamma(NspGtkCurve *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,t_end};
  double gamma;

  if ( GetArgs(stack,rhs,opt,T,&gamma) == FAIL) return RET_BUG;
  gtk_curve_set_gamma(GTK_CURVE(self->obj), gamma);
  return 0;
}

static int _wrap_gtk_curve_set_range(NspGtkCurve *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, s_double, s_double, s_double,t_end};
  double min_x, max_x, min_y, max_y;

  if ( GetArgs(stack,rhs,opt,T,&min_x, &max_x, &min_y, &max_y) == FAIL) return RET_BUG;
  gtk_curve_set_range(GTK_CURVE(self->obj), min_x, max_x, min_y, max_y);
  return 0;
}

#line 1515 "gtk.override"
static int
_wrap_gtk_curve_get_vector(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "size", NULL };*/
  int size = -1; 
  NspMatrix  *ret;
  CheckRhs(0,1);
  if (rhs == 1) 
    {
      if ( GetScalarInt(stack,1,&size) == FAIL) return RET_BUG; 
    }
  if (size < 0) size = GTK_CURVE(self->obj)->num_points;
  if (( ret= nsp_matrix_create(NVOID,'r',1,size))== NULLMAT) return RET_BUG;
  gtk_curve_get_vector(GTK_CURVE(self->obj), size,(float *) ret->R);
  ret->convert = 'f';
  ret = Mat2double(ret);
  MoveObj(stack,1,(NspObject *) ret);
  return 1;
}
#line 27843 "gtk.c"


#line 1536 "gtk.override"
static int
_wrap_gtk_curve_set_vector(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {realmat, t_end} ;
  /* static char *kwlist[] = { "vector", NULL };*/
  NspMatrix *v;
  int size=0;
  if (GetArgs(stack,rhs,opt,T, &v) == FAIL) return RET_BUG;
  /* convert v to float XXXXX */
  v = Mat2float(v);
  gtk_curve_set_vector(GTK_CURVE(self->obj), size,(float *) v->R);
  /* back to double */
  v = Mat2double(v);
  return 0;
}
#line 27862 "gtk.c"


static int _wrap_gtk_curve_set_curve_type(NspGtkCurve *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_type = NULL;
  GtkCurveType type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_CURVE_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
  gtk_curve_set_curve_type(GTK_CURVE(self->obj), type);
  return 0;
}

static NspMethods gtkcurve_methods[] = {
  {"reset",(nsp_method *) _wrap_gtk_curve_reset},
  {"set_gamma",(nsp_method *) _wrap_gtk_curve_set_gamma},
  {"set_range",(nsp_method *) _wrap_gtk_curve_set_range},
  {"get_vector",(nsp_method *) _wrap_gtk_curve_get_vector},
  {"set_vector",(nsp_method *) _wrap_gtk_curve_set_vector},
  {"set_curve_type",(nsp_method *) _wrap_gtk_curve_set_curve_type},
  { NULL, NULL}
};

static NspMethods *gtkcurve_get_methods(void) { return gtkcurve_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcurve_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkContainer ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkContainer_Private 
#include "nsp/gtk/gtkcontainer.h"
#include "nsp/interf.h"

/* NspGtkContainer inherits from NspGtkWidget */ 

int nsp_type_gtkcontainer_id=0;
NspTypeGtkContainer *nsp_type_gtkcontainer=NULL;

NspTypeGtkContainer *new_type_gtkcontainer(type_mode mode)
{
  NspTypeGtkContainer *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcontainer != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcontainer;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcontainer_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcontainer_get_methods; 
  type->new = (new_func *) new_gtkcontainer;

  /* specific methods for gtkcontainer */
      
  type->init = (init_func *) init_gtkcontainer;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcontainer */ 

  top->s_type =  (s_type_func *) gtkcontainer_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcontainer_type_short_string;
  /* top->create = (create_func*) int_gtkcontainer_create;*/ 
  
  /* specific methods for gtkcontainer */
      
  type->init = (init_func *) init_gtkcontainer;

  if ( nsp_type_gtkcontainer_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkContainer called nsp_type_gtkcontainer
       */
      type->id =  nsp_type_gtkcontainer_id = nsp_new_type_id();
      nsp_type_gtkcontainer = type;
      if ( nsp_register_type(nsp_type_gtkcontainer) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcontainer, GTK_TYPE_CONTAINER);
      return ( mode == T_BASE ) ? type : new_type_gtkcontainer(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcontainer_id;
       return type;
    }
}

/*
 * initialize GtkContainer instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcontainer(NspGtkContainer *o,NspTypeGtkContainer *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkContainer 
 */

NspGtkContainer *new_gtkcontainer() 
{
  NspGtkContainer *loc; 
  /* type must exists */
  nsp_type_gtkcontainer = new_type_gtkcontainer(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkContainer)))== NULLGTKCONTAINER) return loc;
  /* initialize object */
  if ( init_gtkcontainer(loc,nsp_type_gtkcontainer) == FAIL) return NULLGTKCONTAINER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkContainer 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcontainer_type_name[]="GtkContainer";
static char gtkcontainer_short_type_name[]="GtkContainer";

static char *gtkcontainer_type_as_string(void)
{
  return(gtkcontainer_type_name);
}

static char *gtkcontainer_type_short_string(void)
{
  return(gtkcontainer_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkContainer objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkContainer   *gtkcontainer_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcontainer_id) ) return ((NspGtkContainer *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcontainer));
  return NULL;
}

int IsGtkContainerObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcontainer_id);
}

int IsGtkContainer(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcontainer_id);
}

NspGtkContainer  *GetGtkContainerCopy(Stack stack, int i)
{
  if (  GetGtkContainer(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkContainer  *GetGtkContainer(Stack stack, int i)
{
  NspGtkContainer *M;
  if (( M = gtkcontainer_object(NthObj(i))) == NULLGTKCONTAINER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkContainer *gtkcontainer_copy(NspGtkContainer *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcontainer);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcontainer);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkContainer
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkContainer *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcontainer is initialized * /
  nsp_type_gtkcontainer = new_type_gtkcontainer(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkcontainer)) == NULLGTKCONTAINER) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_container_set_border_width(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int border_width;

  if ( GetArgs(stack,rhs,opt,T,&border_width) == FAIL) return RET_BUG;
  gtk_container_set_border_width(GTK_CONTAINER(self->obj), border_width);
  return 0;
}

static int _wrap_gtk_container_get_border_width(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_container_get_border_width(GTK_CONTAINER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_container_add(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
  gtk_container_add(GTK_CONTAINER(self->obj), GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_container_remove(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
  gtk_container_remove(GTK_CONTAINER(self->obj), GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_container_set_resize_mode(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_resize_mode = NULL;
  GtkResizeMode resize_mode;

  if ( GetArgs(stack,rhs,opt,T,&nsp_resize_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_RESIZE_MODE, nsp_resize_mode, &resize_mode)== FAIL)
      return RET_BUG;
  gtk_container_set_resize_mode(GTK_CONTAINER(self->obj), resize_mode);
  return 0;
}

static int _wrap_gtk_container_get_resize_mode(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_container_get_resize_mode(GTK_CONTAINER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_container_check_resize(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_container_check_resize(GTK_CONTAINER(self->obj));
  return 0;
}

#line 1190 "gtk.override"
static void
nspgtk_container_foreach_marshal(GtkWidget *widget, gpointer data)
{
  NspObject *args[2];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 1,nargs = 1;
  nspg_block_threads();

  args[0] = (NspObject *)gobject_gettype_and_create("widget",(GObject *)widget);
  if ( args[0]== NULL ) goto end;
  if (cunote->data) 
    {
      args[1]= cunote->data; 
      nargs= 2;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end ;
  /* 
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  */
  goto end; 
 end: 
  {
    nspg_unblock_threads();
    return;
  }
}

static int
_wrap_gtk_container_foreach(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify cunote;

  CheckRhs(1,2); 
  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 2 ) 
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }
  cunote.func = func;
  cunote.data = arg;
  gtk_container_foreach(GTK_CONTAINER(self->obj), nspgtk_container_foreach_marshal, &cunote);
  return 0;
}

#line 28208 "gtk.c"


#line 856 "gtk.override"

static int
_wrap_gtk_container_get_children(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  Cell *cloc = NULLCELL,*cloc1=NULLCELL; 

  list = gtk_container_get_children(GTK_CONTAINER(self->obj));
  NSP_LIST_FROM_GLIST( gobject_gettype_and_create("lel",G_OBJECT(tmp->data)), g_list_free);
}
#line 28223 "gtk.c"


#line 848 "gtk.override"
static int
_wrap_gtk_container_children(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  Scierror("Deprecated: use GtkContainer.get_children");
  return RET_BUG;
}
#line 28233 "gtk.c"


static int _wrap_gtk_container_propagate_expose(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj,t_end};
  GdkEvent *event = NULL;
  NspGObject *child;
  NspObject *nsp_event;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "event should be a GdkEvent");
      return RET_BUG;
  }
  gtk_container_propagate_expose(GTK_CONTAINER(self->obj), GTK_WIDGET(child->obj), (GdkEventExpose *)event);
  return 0;
}

#line 869 "gtk.override"
static int
_wrap_gtk_container_set_focus_chain(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list , t_end} ;
  /* static char *kwlist[] = { "focusable_widgets", NULL };*/
  NspList *nsp_focusable_widgets;
  GList *focusable_widgets = NULL;
  Cell *C;

  if (GetArgs(stack,rhs,opt,T,&nsp_focusable_widgets)== FAIL) return RET_BUG;
    
  C= nsp_focusable_widgets->first;
  while ( C != NULLCELL) 
    {
      if ( C->O != NULLOBJ )
	{
	  if (!nspgobject_check((NspGObject *) C->O,nsp_type_gtkwidget)) 
	    {
	      Scierror("focusable_widgets members must be GtkWidgets");
	      return RET_BUG;
	    }
	  focusable_widgets = g_list_prepend(focusable_widgets,
					     nspgobject_get(C->O));
	}
      C = C->next ;
    }
  focusable_widgets = g_list_reverse(focusable_widgets);
  gtk_container_set_focus_chain(GTK_CONTAINER(self->obj), focusable_widgets);
  g_list_free(focusable_widgets);
  return 0;
}
#line 28286 "gtk.c"


#line 902 "gtk.override"
static int
_wrap_gtk_container_get_focus_chain(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  Cell *cloc = NULLCELL,*cloc1=NULLCELL; 

  if (! gtk_container_get_focus_chain(GTK_CONTAINER(self->obj), &list)) return 0;
  
  NSP_LIST_FROM_GLIST( gobject_gettype_and_create("lel",G_OBJECT(tmp->data)),g_list_free); 
  
}
#line 28302 "gtk.c"


static int _wrap_gtk_container_unset_focus_chain(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_container_unset_focus_chain(GTK_CONTAINER(self->obj));
  return 0;
}

static int _wrap_gtk_container_set_reallocate_redraws(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int needs_redraws;

  if ( GetArgs(stack,rhs,opt,T,&needs_redraws) == FAIL) return RET_BUG;
  gtk_container_set_reallocate_redraws(GTK_CONTAINER(self->obj), needs_redraws);
  return 0;
}

static int _wrap_gtk_container_set_focus_child(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
  gtk_container_set_focus_child(GTK_CONTAINER(self->obj), GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_container_set_focus_vadjustment(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *adjustment;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
  gtk_container_set_focus_vadjustment(GTK_CONTAINER(self->obj), GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_container_get_focus_vadjustment(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_container_get_focus_vadjustment(GTK_CONTAINER(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_container_set_focus_hadjustment(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *adjustment;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
  gtk_container_set_focus_hadjustment(GTK_CONTAINER(self->obj), GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_container_get_focus_hadjustment(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_container_get_focus_hadjustment(GTK_CONTAINER(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_container_resize_children(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_container_resize_children(GTK_CONTAINER(self->obj));
  return 0;
}

#line 832 "gtk.override"
static int _wrap_gtk_container_child_type(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  NspTypeBase *type;
  GType ret;
  CheckRhs(0,0);
  ret = gtk_container_child_type(GTK_CONTAINER(self->obj));
  type = nsp_type_from_gtype(ret);
  if ( type == NULL) return RET_BUG; 
  if ((nsp_ret = (NspObject *) type_create(NVOID,type ,NULL))== NULL) return RET_BUG; 
  MoveObj(stack,1,nsp_ret);
  return 1; 
}

#line 28396 "gtk.c"


#line 1139 "gtk.override"
static int
_wrap_gtk_container_add_with_properties(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *pychild;
  GtkContainer *container;
  GtkWidget *child;
  GObjectClass *class;
  int i;
    
  CheckRhs(1,100);
  if ((pychild = GetGtkWidget(stack,1)) == NULL) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  gtk_widget_freeze_child_notify(child);
  gtk_container_add(container, child);
  class = G_OBJECT_GET_CLASS(self->obj);

  for ( i = 2 ; i <= rhs ; i++) 
    {
      gchar *property_name;
      NspObject *nsp_value;
      GParamSpec *pspec;
      GValue value = { 0 };
      if ( Ocheckname(NthObj(i),NVOID) ) 
	{
	  Scierror("Error: properties must have names \n");
	  Scierror("\t%s of function %s\n",ArgPosition(rhs),stack.fname);
	  return RET_BUG;
	}
      /** A copy of object is entered as an object property **/
      /** GetObj takes care of Hobj pointers **/
      if (( nsp_value =nsp_get_object(stack,i)) == NULLOBJ ) return RET_BUG;
      property_name =nsp_object_get_name(nsp_value);
      pspec = gtk_container_class_find_child_property(class, property_name);
      if (!pspec) {
	Scierror("container does not support property `%s'",property_name);
	/* clean .....*/
	return RET_BUG;
      }
      g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
      nspg_value_from_nspobject(&value, (NspObject*)nsp_value);
      gtk_container_child_set_property(container, child, property_name, &value);
      g_value_unset(&value);
    }
  gtk_widget_thaw_child_notify(child);
  return 0;
}
#line 28449 "gtk.c"


#line 1009 "gtk.override"
static int
_wrap_gtk_container_child_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *pychild;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  GObjectClass *class;
  int i;
    
  CheckRhs(1,1000);
  if ((pychild = GetGtkWidget(stack,1)) == NULL) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("first argument must be a child");
    return RET_BUG;
  }

  class = G_OBJECT_GET_CLASS(self->obj);

  for ( i = 2 ; i <= rhs ; i++) 
    {
      gchar *property_name;
      NspObject *nsp_value;
      GParamSpec *pspec;
      GValue value = { 0 };
      if ( Ocheckname(NthObj(i),NVOID) ) 
	{
	  Scierror("Error: properties mus have names \n");
	  Scierror("\t%s of function %s\n",ArgPosition(rhs),stack.fname);
	  return RET_BUG;
	}
      /** A copy of object is entered as an object property **/
      /** GetObj takes care of Hobj pointers **/
      if (( nsp_value =nsp_get_object(stack,i)) == NULLOBJ ) return RET_BUG;
      property_name =nsp_object_get_name(nsp_value);
      pspec = gtk_container_class_find_child_property(class, property_name);
      if (!pspec) {
	Scierror("container does not support property `%s'",property_name);
	/* clean .....*/
	return RET_BUG;
      }
      g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
      nspg_value_from_nspobject(&value, (NspObject*)nsp_value);
      gtk_container_child_set_property(container, child, property_name, &value);
      g_value_unset(&value);
    }
  return 0;
}
#line 28506 "gtk.c"


#line 1064 "gtk.override"
static int
_wrap_gtk_container_child_get(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspSMatrix *props;
  NspGObject *pychild;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  GObjectClass *class;
  int  i;
  NspList *nsp_list; 
  Cell *cloc= NULLCELL,*cloc1;

  CheckRhs(2,2);
  if ((pychild = GetGtkWidget(stack,1)) == NULL) return RET_BUG;
  if (( props = GetSMat(stack,2)) == NULLSMAT) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("first argument is not a child of given container\n");
    return RET_BUG;
  }
    
  class = G_OBJECT_GET_CLASS(self->obj);

  if (( nsp_list =nsp_list_create(NVOID,NULL) ) == NULLLIST) return RET_BUG; 
  
  for ( i = 0 ; i < props->mn ; i++) {
    gchar *property_name = props->S[i];
    GParamSpec *pspec;
    GValue value = { 0 };
    NspObject *item;
    pspec = gtk_container_class_find_child_property(class, property_name);
    if (!pspec) {
      Scierror("container does not support property `%s'",property_name);
      goto clean; 
    }

    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

    gtk_container_child_get_property(container, child, property_name, &value);

    item = nspg_value_as_nspobject(&value, TRUE);

    if ((cloc1 =nsp_cell_create("lel",item))== NULLCELL) 
      {
	g_value_unset(&value);
	goto clean;
      }

    cloc1->next = NULLCELL; 
    if ( cloc == NULLCELL)  
      { 
	nsp_list->first = cloc1; 
      } 
    else  
      { 
	cloc1->prev = cloc; cloc->next = cloc1;  
      } 
    cloc= cloc1; 
    g_value_unset(&value);
  }
  return 1;
 clean: 
  {
 nsp_list_destroy(nsp_list);
    return RET_BUG; 
  }

}
#line 28583 "gtk.c"


#line 963 "gtk.override"
static int
_wrap_gtk_container_child_set_property(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *property_name;
  NspGObject *pychild;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  NspGObject *pyvalue;
  GObjectClass *class;
  GParamSpec *pspec;
  GValue value = { 0, } ;

  int_types T[] = {obj_check,string,obj, t_end} ;
  
  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget,&pychild,&property_name,&pyvalue)== FAIL) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("%s: first argument must be a child",stack.fname);
    return RET_BUG;
  }

  class = G_OBJECT_GET_CLASS(self->obj);
  pspec = gtk_container_class_find_child_property(class, property_name);

  if (!pspec) {
    Scierror("container does not support property `%s'", property_name);
    return RET_BUG;
  }
  g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

  nspg_value_from_nspobject(&value, (NspObject*)pyvalue);

  gtk_container_child_set_property(container,
				   child,
				   property_name,
				   &value);
  g_value_unset(&value);
  return 0;
}
#line 28631 "gtk.c"


#line 916 "gtk.override"
static int
_wrap_gtk_container_child_get_property(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *pychild;
  gchar *property_name;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  GObjectClass *class;
  GParamSpec *pspec;
  GValue value = { 0, } ;
  NspObject *ret;
  
  int_types T[] = {obj_check,string, t_end} ;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &pychild,&property_name)== FAIL) return RET_BUG;
  
  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("%s: first argument must be a child",stack.fname);
    return RET_BUG;
  }
  
  class = G_OBJECT_GET_CLASS(container);
  pspec = gtk_container_class_find_child_property(class, property_name);
  if (!pspec) {
    Scierror("container does not support property `%s'", property_name);
    return RET_BUG;
  }
  
  g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
  
  gtk_container_child_get_property(container,
				   child,
				   property_name,
				   &value);
  
  ret = nspg_value_as_nspobject(&value, TRUE);
  g_value_unset(&value);
  MoveObj(stack,1,ret);
  return 1;
}
#line 28680 "gtk.c"


static NspMethods gtkcontainer_methods[] = {
  {"set_border_width",(nsp_method *) _wrap_gtk_container_set_border_width},
  {"get_border_width",(nsp_method *) _wrap_gtk_container_get_border_width},
  {"add",(nsp_method *) _wrap_gtk_container_add},
  {"remove",(nsp_method *) _wrap_gtk_container_remove},
  {"set_resize_mode",(nsp_method *) _wrap_gtk_container_set_resize_mode},
  {"get_resize_mode",(nsp_method *) _wrap_gtk_container_get_resize_mode},
  {"check_resize",(nsp_method *) _wrap_gtk_container_check_resize},
  {"foreach",(nsp_method *) _wrap_gtk_container_foreach},
  {"get_children",(nsp_method *) _wrap_gtk_container_get_children},
  {"children",(nsp_method *) _wrap_gtk_container_children},
  {"propagate_expose",(nsp_method *) _wrap_gtk_container_propagate_expose},
  {"set_focus_chain",(nsp_method *) _wrap_gtk_container_set_focus_chain},
  {"get_focus_chain",(nsp_method *) _wrap_gtk_container_get_focus_chain},
  {"unset_focus_chain",(nsp_method *) _wrap_gtk_container_unset_focus_chain},
  {"set_reallocate_redraws",(nsp_method *) _wrap_gtk_container_set_reallocate_redraws},
  {"set_focus_child",(nsp_method *) _wrap_gtk_container_set_focus_child},
  {"set_focus_vadjustment",(nsp_method *) _wrap_gtk_container_set_focus_vadjustment},
  {"get_focus_vadjustment",(nsp_method *) _wrap_gtk_container_get_focus_vadjustment},
  {"set_focus_hadjustment",(nsp_method *) _wrap_gtk_container_set_focus_hadjustment},
  {"get_focus_hadjustment",(nsp_method *) _wrap_gtk_container_get_focus_hadjustment},
  {"resize_children",(nsp_method *) _wrap_gtk_container_resize_children},
  {"child_type",(nsp_method *) _wrap_gtk_container_child_type},
  {"add_with_properties",(nsp_method *) _wrap_gtk_container_add_with_properties},
  {"child_set",(nsp_method *) _wrap_gtk_container_child_set},
  {"child_get",(nsp_method *) _wrap_gtk_container_child_get},
  {"child_set_property",(nsp_method *) _wrap_gtk_container_child_set_property},
  {"child_get_property",(nsp_method *) _wrap_gtk_container_child_get_property},
  { NULL, NULL}
};

static NspMethods *gtkcontainer_get_methods(void) { return gtkcontainer_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_container__get_focus_child(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_CONTAINER(NSP_GOBJECT_GET(self))->focus_child;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_container__get_border_width(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_CONTAINER(NSP_GOBJECT_GET(self))->border_width;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_container__get_need_resize(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_CONTAINER(NSP_GOBJECT_GET(self))->need_resize;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_container__get_resize_mode(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_CONTAINER(NSP_GOBJECT_GET(self))->resize_mode;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_container__get_reallocate_redraws(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_CONTAINER(NSP_GOBJECT_GET(self))->reallocate_redraws;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_container__get_has_focus_chain(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_CONTAINER(NSP_GOBJECT_GET(self))->has_focus_chain;
  return nsp_new_double_obj((double) ret);
}

static AttrTab gtkcontainer_attrs[] = {
  { "focus_child", (attr_get_function *)_wrap_gtk_container__get_focus_child, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "border_width", (attr_get_function *)_wrap_gtk_container__get_border_width, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "need_resize", (attr_get_function *)_wrap_gtk_container__get_need_resize, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "resize_mode", (attr_get_function *)_wrap_gtk_container__get_resize_mode, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "reallocate_redraws", (attr_get_function *)_wrap_gtk_container__get_reallocate_redraws, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "has_focus_chain", (attr_get_function *)_wrap_gtk_container__get_has_focus_chain, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkTreeView ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTreeView_Private 
#include "nsp/gtk/gtktreeview.h"
#include "nsp/interf.h"

/* NspGtkTreeView inherits from NspGtkContainer */ 

int nsp_type_gtktreeview_id=0;
NspTypeGtkTreeView *nsp_type_gtktreeview=NULL;

NspTypeGtkTreeView *new_type_gtktreeview(type_mode mode)
{
  NspTypeGtkTreeView *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreeview != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreeview;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreeview_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktreeview_get_methods; 
  type->new = (new_func *) new_gtktreeview;

  /* specific methods for gtktreeview */
      
  type->init = (init_func *) init_gtktreeview;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktreeview */ 

  top->s_type =  (s_type_func *) gtktreeview_type_as_string;    
  top->sh_type = (sh_type_func *) gtktreeview_type_short_string;
  /* top->create = (create_func*) int_gtktreeview_create;*/ 
  
  /* specific methods for gtktreeview */
      
  type->init = (init_func *) init_gtktreeview;

  if ( nsp_type_gtktreeview_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeView called nsp_type_gtktreeview
       */
      type->id =  nsp_type_gtktreeview_id = nsp_new_type_id();
      nsp_type_gtktreeview = type;
      if ( nsp_register_type(nsp_type_gtktreeview) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreeview, GTK_TYPE_TREE_VIEW);
      return ( mode == T_BASE ) ? type : new_type_gtktreeview(mode);
    }
  else 
    {
       type->id = nsp_type_gtktreeview_id;
       return type;
    }
}

/*
 * initialize GtkTreeView instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreeview(NspGtkTreeView *o,NspTypeGtkTreeView *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTreeView 
 */

NspGtkTreeView *new_gtktreeview() 
{
  NspGtkTreeView *loc; 
  /* type must exists */
  nsp_type_gtktreeview = new_type_gtktreeview(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeView)))== NULLGTKTREEVIEW) return loc;
  /* initialize object */
  if ( init_gtktreeview(loc,nsp_type_gtktreeview) == FAIL) return NULLGTKTREEVIEW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTreeView 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktreeview_type_name[]="GtkTreeView";
static char gtktreeview_short_type_name[]="GtkTreeView";

static char *gtktreeview_type_as_string(void)
{
  return(gtktreeview_type_name);
}

static char *gtktreeview_type_short_string(void)
{
  return(gtktreeview_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTreeView objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTreeView   *gtktreeview_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktreeview_id) ) return ((NspGtkTreeView *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreeview));
  return NULL;
}

int IsGtkTreeViewObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktreeview_id);
}

int IsGtkTreeView(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreeview_id);
}

NspGtkTreeView  *GetGtkTreeViewCopy(Stack stack, int i)
{
  if (  GetGtkTreeView(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeView  *GetGtkTreeView(Stack stack, int i)
{
  NspGtkTreeView *M;
  if (( M = gtktreeview_object(NthObj(i))) == NULLGTKTREEVIEW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeView *gtktreeview_copy(NspGtkTreeView *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeview);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeview);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeView
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTreeView *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktreeview is initialized * /
  nsp_type_gtktreeview = new_type_gtktreeview(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtktreeview)) == NULLGTKTREEVIEW) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 2584 "gtk.override"
static int
_wrap_gtktreeview_new(Stack stack, int rhs, int opt, int lhs)
{
  NspGObject *nsp_model = NULL;
  GtkTreeModel *model = NULL;
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,1);
  if (rhs == 1) 
    {
      if (( nsp_model = (NspGObject *) GetGtkTreeModel(stack,1)) == NULL) 
	return RET_BUG;
      model = GTK_TREE_MODEL(nsp_model->obj);
      ret = (GObject *)gtk_tree_view_new_with_model(model);
    }
  else 
    {
      ret = (GObject *)gtk_tree_view_new();
    }
  if (ret == NULL) 
    {
      Scierror( "Can't create GtkTreeView");
      return RET_BUG;	
    }

  nsp_type_gtktreeview = new_type_gtktreeview(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktreeview );
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 29004 "gtk.c"


#line 2616 "gtk.override"
/* I do not want gtk_tree_view_get_model to return a tree model 
 * but a more specific object i.e a liststore or treestore 
 */

static int _wrap_gtk_tree_view_get_model(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *ret;
  NspObject *nsp_ret;
  ret = gtk_tree_view_get_model(GTK_TREE_VIEW(self->obj));
  if ((nsp_ret =(NspObject *) gobject_gettype_and_create(NVOID,(GObject *) ret))==NULLOBJ) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 29022 "gtk.c"


static int _wrap_gtk_tree_view_set_model(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"model",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *nsp_model = NULL;
  GtkTreeModel *model = NULL;

  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_model) == FAIL) return RET_BUG;
  if ( nsp_model != NULL ) {
    if ( IsGtkTreeModel((NspObject *)nsp_model))
      model = GTK_TREE_MODEL(nsp_model->obj);
    else if (! IsNone((NspObject *)nsp_model)) {
         Scierror( "model should be a GtkTreeModel or None");
         return RET_BUG;
    }
  }
  gtk_tree_view_set_model(GTK_TREE_VIEW(self->obj), model);
  return 0;
}

static int _wrap_gtk_tree_view_get_selection(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeSelection *ret;
  NspObject *nsp_ret;

  ret = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->obj));
  nsp_type_gtktreeselection = new_type_gtktreeselection(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeselection))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_get_hadjustment(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_tree_view_get_hadjustment(GTK_TREE_VIEW(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_set_hadjustment(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *adjustment;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
  gtk_tree_view_set_hadjustment(GTK_TREE_VIEW(self->obj), GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_tree_view_get_vadjustment(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_tree_view_get_vadjustment(GTK_TREE_VIEW(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_set_vadjustment(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *adjustment;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
  gtk_tree_view_set_vadjustment(GTK_TREE_VIEW(self->obj), GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_tree_view_get_headers_visible(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_get_headers_visible(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_headers_visible(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int headers_visible;

  if ( GetArgs(stack,rhs,opt,T,&headers_visible) == FAIL) return RET_BUG;
  gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(self->obj), headers_visible);
  return 0;
}

static int _wrap_gtk_tree_view_columns_autosize(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_view_columns_autosize(GTK_TREE_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_set_headers_clickable(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int active;

  if ( GetArgs(stack,rhs,opt,T,&active) == FAIL) return RET_BUG;
  gtk_tree_view_set_headers_clickable(GTK_TREE_VIEW(self->obj), active);
  return 0;
}

static int _wrap_gtk_tree_view_set_rules_hint(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_tree_view_set_rules_hint(GTK_TREE_VIEW(self->obj), setting);
  return 0;
}

static int _wrap_gtk_tree_view_get_rules_hint(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_get_rules_hint(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_append_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  int ret;
  NspGObject *column;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeviewcolumn, &column) == FAIL) return RET_BUG;
  ret = gtk_tree_view_append_column(GTK_TREE_VIEW(self->obj), GTK_TREE_VIEW_COLUMN(column->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_remove_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  int ret;
  NspGObject *column;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeviewcolumn, &column) == FAIL) return RET_BUG;
  ret = gtk_tree_view_remove_column(GTK_TREE_VIEW(self->obj), GTK_TREE_VIEW_COLUMN(column->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_insert_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int,t_end};
  int position, ret;
  NspGObject *column;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeviewcolumn, &column, &position) == FAIL) return RET_BUG;
  ret = gtk_tree_view_insert_column(GTK_TREE_VIEW(self->obj), GTK_TREE_VIEW_COLUMN(column->obj), position);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 2914 "gtk.override"
/* could it be merged with insert column ? XXXX  */ 
static int
_wrap_gtk_tree_view_insert_column_with_attributes(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { s_int,string, obj_check, new_opts,t_end};
  nsp_option opts[] = {
    {"attrs",hash,NULLOBJ,-1},  
    {NULL,t_end,NULLOBJ,-1} };
  
  gint position, columns, real_position;
  GtkTreeViewColumn *column;
  GtkCellRenderer *cell;
  NspObject *nsp_cell,*nsp_ret;
  NspHash *h;
  const char *title;

  if (GetArgs(stack,rhs,opt,T, &position, &title, &nsp_type_gtkcellrenderer,&nsp_cell,&opts,&h) == FAIL)
    return RET_BUG;

  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));

  columns =  gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW(self->obj),
							  position, title, cell,
							  NULL);
  if (position == -1) {
    real_position = columns - 1;
  } else {
    real_position = position;
  }

  column = gtk_tree_view_get_column (GTK_TREE_VIEW(self->obj),  real_position);

  if (h != NULL) 
    {
      int i;
      for ( i =0 ; i < h->hsize ; i++) 
	{
	  Hash_Entry *loc = ((Hash_Entry *) h->htable) + i;
	  if ( loc->used )
	    {
	      if ( IsMat(loc->data) 
		   && (((NspMatrix *) loc->data)->mn == 1) 
		   && (((NspMatrix *) loc->data)->rc_type == 'r' ))
		gtk_tree_view_column_add_attribute(column, cell,nsp_object_get_name(loc->data),
						   ((NspMatrix *) loc->data)->R[0]);
	      else 
		{
		  Scierror("%s: attribute %s should be a real scalar\n",stack.fname,nsp_object_get_name(loc->data));
		  return RET_BUG;
		}
	    }
	}
    }
  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)column,(NspTypeBase *) nsp_type_gtktreeviewcolumn );
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 29253 "gtk.c"


#line 2800 "gtk.override"
static int
_wrap_gtk_tree_view_insert_column_with_data_func (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int position;
  gchar *title;
  NspObject *nsp_cell,*nsp_func, *nsp_arg = NULL;
  GtkCellRenderer *cell;
  NspGtkCustomNotify *cunote;
  gint retval;

  int_types T4[] = {s_int,string,obj_check,obj_check, t_end} ;
  int_types T5[] = {s_int,string,obj_check,obj_check,obj_check,t_end} ;
  
  CheckRhs(4,5) ;
  if ( rhs == 4 ) 
    {
      if (GetArgs(stack,rhs,opt,T4, &position, &title,&nsp_type_gtkcellrenderer,&nsp_cell,&nsp_type_plist, &nsp_func)== FAIL)
	return RET_BUG;
    }
  else
    {
      if (GetArgs(stack,rhs,opt,T5, &position, &title,&nsp_type_gtkcellrenderer,&nsp_cell,&nsp_type_plist, &nsp_func,&nsp_type_list, &nsp_arg)== FAIL)
	return RET_BUG;
    }
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));

  if (( nsp_func =nsp_object_copy(nsp_func)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"func")== FAIL)) return RET_BUG;
  if ( nsp_arg != NULL) 
    {
      if (( nsp_arg =nsp_object_copy(nsp_arg)) == NULL) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"arg")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;

  retval = gtk_tree_view_insert_column_with_data_func (
						       GTK_TREE_VIEW (self->obj),
						       position,
						       title,
						       cell,
						       nspgtk_cell_data_func_marshal,
						       cunote,
						       nspgtk_custom_destroy_notify);
  if ( nsp_move_double(stack,1,(double)retval) == FAIL) return RET_BUG; 
  return 1;
}
#line 29305 "gtk.c"


static int _wrap_gtk_tree_view_get_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int n;
  GtkTreeViewColumn *ret;
  NspObject *nsp_ret;

  if ( GetArgs(stack,rhs,opt,T,&n) == FAIL) return RET_BUG;
  ret = gtk_tree_view_get_column(GTK_TREE_VIEW(self->obj), n);
  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeviewcolumn))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 3100 "gtk.override"
static int
_wrap_gtk_tree_view_get_columns(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  Cell *cloc = NULLCELL,*cloc1=NULLCELL; 
  list = gtk_tree_view_get_columns(GTK_TREE_VIEW(self->obj));
  NSP_LIST_FROM_GLIST(gobject_gettype_and_create("lel",G_OBJECT(tmp->data)),g_list_free);
}
#line 29333 "gtk.c"


static int _wrap_gtk_tree_view_move_column_after(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check,t_end};
  NspGObject *column, *base_column;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeviewcolumn, &column, &nsp_type_gtktreeviewcolumn, &base_column) == FAIL) return RET_BUG;
  gtk_tree_view_move_column_after(GTK_TREE_VIEW(self->obj), GTK_TREE_VIEW_COLUMN(column->obj), GTK_TREE_VIEW_COLUMN(base_column->obj));
  return 0;
}

static int _wrap_gtk_tree_view_set_expander_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *column;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeviewcolumn, &column) == FAIL) return RET_BUG;
  gtk_tree_view_set_expander_column(GTK_TREE_VIEW(self->obj), GTK_TREE_VIEW_COLUMN(column->obj));
  return 0;
}

static int _wrap_gtk_tree_view_get_expander_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeViewColumn *ret;
  NspObject *nsp_ret;

  ret = gtk_tree_view_get_expander_column(GTK_TREE_VIEW(self->obj));
  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeviewcolumn))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_scroll_to_point(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int tree_x, tree_y;

  if ( GetArgs(stack,rhs,opt,T,&tree_x, &tree_y) == FAIL) return RET_BUG;
  gtk_tree_view_scroll_to_point(GTK_TREE_VIEW(self->obj), tree_x, tree_y);
  return 0;
}

static int _wrap_gtk_tree_view_scroll_to_cell(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,new_opts,t_end};
  nsp_option opts[] = {
	{"column",obj,NULLOBJ,-1}, 
	{"use_align",s_bool,NULLOBJ,-1}, 
	{"row_align",s_double,NULLOBJ,-1}, 
	{"col_align",s_double,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspObject *nsp_path;
  GtkTreePath *path = NULL;
  GtkTreeViewColumn *column = NULL;
  NspGObject *nsp_column = NULL;
  int use_align = FALSE;
  double row_align = 0.0, col_align = 0.0;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path, opts, &nsp_column, &use_align, &row_align, &col_align) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  if ( nsp_column != NULL ) {
    if ( IsGtkTreeViewColumn((NspObject *)nsp_column))
      column = GTK_TREE_VIEW_COLUMN(nsp_column->obj);
    else if (! IsNone((NspObject *)nsp_column)) {
         Scierror( "column should be a GtkTreeViewColumn or None");
         return RET_BUG;
    }
  }
  gtk_tree_view_scroll_to_cell(GTK_TREE_VIEW(self->obj), path, column, use_align, row_align, col_align);
  return 0;
}

static int _wrap_gtk_tree_view_row_activated(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj_check,t_end};
  NspGObject *column;
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_type_gtktreeviewcolumn, &column) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  gtk_tree_view_row_activated(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj));
  return 0;
}

static int _wrap_gtk_tree_view_expand_all(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_view_expand_all(GTK_TREE_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_collapse_all(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_view_collapse_all(GTK_TREE_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_expand_row(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, s_bool,t_end};
  int open_all;
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &open_all) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  gtk_tree_view_expand_row(GTK_TREE_VIEW(self->obj), path, open_all);
  return 0;
}

static int _wrap_gtk_tree_view_collapse_row(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  gtk_tree_view_collapse_row(GTK_TREE_VIEW(self->obj), path);
  return 0;
}

static int _wrap_gtk_tree_view_row_expanded(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  ret = gtk_tree_view_row_expanded(GTK_TREE_VIEW(self->obj), path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_reorderable(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int reorderable;

  if ( GetArgs(stack,rhs,opt,T,&reorderable) == FAIL) return RET_BUG;
  gtk_tree_view_set_reorderable(GTK_TREE_VIEW(self->obj), reorderable);
  return 0;
}

static int _wrap_gtk_tree_view_get_reorderable(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_get_reorderable(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_cursor(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,new_opts,t_end};
  nsp_option opts[] = {
	{"focus_column",obj,NULLOBJ,-1}, 
	{"start_editing",s_bool,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreeViewColumn *focus_column = NULL;
  NspGObject *nsp_focus_column = NULL;
  int start_editing = FALSE;
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path, opts, &nsp_focus_column, &start_editing) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  if ( nsp_focus_column != NULL ) {
    if ( IsGtkTreeViewColumn((NspObject *)nsp_focus_column))
      focus_column = GTK_TREE_VIEW_COLUMN(nsp_focus_column->obj);
    else if (! IsNone((NspObject *)nsp_focus_column)) {
         Scierror( "focus_column should be a GtkTreeViewColumn or None");
         return RET_BUG;
    }
  }
  gtk_tree_view_set_cursor(GTK_TREE_VIEW(self->obj), path, focus_column, start_editing);
  return 0;
}

#line 3073 "gtk.override"
static int
_wrap_gtk_tree_view_get_cursor(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list_begin,obj,obj,list_end, t_end} ;
  NspObject *nsp_path;
  NspObject *nsp_column=NULL;
  GtkTreePath *path;
  GtkTreeViewColumn *column;

  gtk_tree_view_get_cursor(GTK_TREE_VIEW(self->obj), &path, &column);

  if (path != NULL) { 
    nsp_path = (NspObject *)nsp_gtk_tree_path_to_nspobject(path);
  } else {
    nsp_path = (NspObject *)none_create(NVOID,NULL);
  }

  if (column != NULL) {
    nsp_column =(NspObject *) nspgobject_new((GObject*)column);
  } else {
    nsp_path =(NspObject *) none_create(NVOID,NULL);
  }
  
  return RetArgs(stack,lhs,T,nsp_path,nsp_column);
}
#line 29574 "gtk.c"


static int _wrap_gtk_tree_view_get_bin_window(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GdkWindow *ret;

  ret = gtk_tree_view_get_bin_window(GTK_TREE_VIEW(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 2885 "gtk.override"
static int
_wrap_gtk_tree_view_get_path_at_pos(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  int_types ret_T[] = {obj,obj,s_int,s_int, t_end} ;
  gint x, y;
  GtkTreePath *path;
  GtkTreeViewColumn *column;
  gint cell_x, cell_y;
  NspObject *nsp_path,*nsp_column;
  if (GetArgs(stack,rhs,opt,T, &x, &y) == FAIL) return RET_BUG;

  if (gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(self->obj), x, y,
				    &path, &column, &cell_x, &cell_y)) 
    {
      if (path != NULL) 
	nsp_path = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH,path,TRUE,TRUE,
					       (NspTypeBase *) nsp_type_gtktreepath );
      else 
	nsp_path =(NspObject *) none_create(NVOID,NULL);
      if ( nsp_path == NULL) return RET_BUG; 
      if ((nsp_column =(NspObject *) nspgobject_new((GObject *)column)) == NULL) return RET_BUG; 
      return RetArgs(stack,lhs,ret_T, nsp_path,nsp_column,cell_x,cell_y);
    }
  Scierror("%s: failed to get path\n",stack.fname);
  return RET_BUG ;
}
#line 29617 "gtk.c"


#line 2990 "gtk.override"
static int
_wrap_gtk_tree_view_get_cell_area(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end} ;
  /* static char *kwlist[] = { "path", "column", NULL };*/
  NspObject *nsp_path, *ret;
  NspGObject *column;
  GdkRectangle rect;
  GtkTreePath *path;
  
  if (GetArgs(stack,rhs,opt,T, &nsp_path, &nsp_type_gtktreeviewcolumn, &column) == FAIL) return RET_BUG;

  path = nsp_gtk_tree_path_from_nspobject(nsp_path);
  if (!path) {
    Scierror( "could not convert path to a GtkTreePath");
    return RET_BUG;
  }
  gtk_tree_view_get_cell_area(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj), &rect);
  if (path)
    gtk_tree_path_free(path);
    if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle))
	== NULL) 
     return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 29647 "gtk.c"


#line 3018 "gtk.override"
static int
_wrap_gtk_tree_view_get_background_area(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end} ;
  /* static char *kwlist[] = { "path", "column", NULL };*/
  NspObject *nsp_path, *ret;
  NspGObject *column;
  GdkRectangle rect;
  GtkTreePath *path;

  if (GetArgs(stack,rhs,opt,T, &nsp_path, &nsp_type_gtktreeviewcolumn, &column)== FAIL) return RET_BUG;

  path = nsp_gtk_tree_path_from_nspobject(nsp_path);
  if (!path) {
    Scierror( "could not convert path to a GtkTreePath");
    return RET_BUG;
  }
  gtk_tree_view_get_background_area(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj), &rect);
  if (path)
    gtk_tree_path_free(path);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL)
     return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 29676 "gtk.c"


#line 2975 "gtk.override"
static int
_wrap_gtk_tree_view_get_visible_rect(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkRectangle visible_rect;
  NspObject *ret;
  CheckRhs(1,1);
  gtk_tree_view_get_visible_rect(GTK_TREE_VIEW(self->obj), &visible_rect);

  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &visible_rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle))
      == NULL)  return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 29693 "gtk.c"


#line 3045 "gtk.override"
static int
_wrap_gtk_tree_view_widget_to_tree_coords(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  gint wx, wy, tx, ty;

  if (GetArgs(stack,rhs,opt,T, &wx, &wy)==  FAIL)
    return RET_BUG;
  gtk_tree_view_widget_to_tree_coords(GTK_TREE_VIEW(self->obj), wx, wy, &tx, &ty);
  if ( nsp_move_doubles(stack,1,1,2,(double) tx,(double) ty) == FAIL) return RET_BUG; 
  return 1;
}
#line 29709 "gtk.c"


#line 3059 "gtk.override"
static int
_wrap_gtk_tree_view_tree_to_widget_coords(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  gint tx, ty, wx, wy;

  if (GetArgs(stack,rhs,opt,T, &tx, &ty)== FAIL)
    return RET_BUG;
  gtk_tree_view_tree_to_widget_coords(GTK_TREE_VIEW(self->obj), tx, ty, &wx, &wy);
  if ( nsp_move_doubles(stack,1,1,2,(double) wx,(double) wy) == FAIL) return RET_BUG; 
  return 1;
}
#line 29725 "gtk.c"


static int _wrap_gtk_tree_view_unset_rows_drag_source(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_view_unset_rows_drag_source(GTK_TREE_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_unset_rows_drag_dest(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_tree_view_unset_rows_drag_dest(GTK_TREE_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_set_drag_dest_row(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  NspObject *nsp_path, *nsp_pos = NULL;
  GtkTreeViewDropPosition pos;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_pos) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_TREE_VIEW_DROP_POSITION, nsp_pos, &pos)== FAIL)
      return RET_BUG;
  gtk_tree_view_set_drag_dest_row(GTK_TREE_VIEW(self->obj), path, pos);
  return 0;
}

static int _wrap_gtk_tree_view_create_row_drag_icon(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_path, *nsp_ret;
  GdkPixmap *ret;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  ret = gtk_tree_view_create_row_drag_icon(GTK_TREE_VIEW(self->obj), path);
  nsp_type_gdkpixmap = new_type_gdkpixmap(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixmap))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_set_enable_search(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int enable_search;

  if ( GetArgs(stack,rhs,opt,T,&enable_search) == FAIL) return RET_BUG;
  gtk_tree_view_set_enable_search(GTK_TREE_VIEW(self->obj), enable_search);
  return 0;
}

static int _wrap_gtk_tree_view_get_enable_search(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_get_enable_search(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_get_search_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_tree_view_get_search_column(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_search_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int column;

  if ( GetArgs(stack,rhs,opt,T,&column) == FAIL) return RET_BUG;
  gtk_tree_view_set_search_column(GTK_TREE_VIEW(self->obj), column);
  return 0;
}

static NspMethods gtktreeview_methods[] = {
  {"get_model",(nsp_method *) _wrap_gtk_tree_view_get_model},
  {"set_model",(nsp_method *) _wrap_gtk_tree_view_set_model},
  {"get_selection",(nsp_method *) _wrap_gtk_tree_view_get_selection},
  {"get_hadjustment",(nsp_method *) _wrap_gtk_tree_view_get_hadjustment},
  {"set_hadjustment",(nsp_method *) _wrap_gtk_tree_view_set_hadjustment},
  {"get_vadjustment",(nsp_method *) _wrap_gtk_tree_view_get_vadjustment},
  {"set_vadjustment",(nsp_method *) _wrap_gtk_tree_view_set_vadjustment},
  {"get_headers_visible",(nsp_method *) _wrap_gtk_tree_view_get_headers_visible},
  {"set_headers_visible",(nsp_method *) _wrap_gtk_tree_view_set_headers_visible},
  {"columns_autosize",(nsp_method *) _wrap_gtk_tree_view_columns_autosize},
  {"set_headers_clickable",(nsp_method *) _wrap_gtk_tree_view_set_headers_clickable},
  {"set_rules_hint",(nsp_method *) _wrap_gtk_tree_view_set_rules_hint},
  {"get_rules_hint",(nsp_method *) _wrap_gtk_tree_view_get_rules_hint},
  {"append_column",(nsp_method *) _wrap_gtk_tree_view_append_column},
  {"remove_column",(nsp_method *) _wrap_gtk_tree_view_remove_column},
  {"insert_column",(nsp_method *) _wrap_gtk_tree_view_insert_column},
  {"insert_column_with_attributes",(nsp_method *) _wrap_gtk_tree_view_insert_column_with_attributes},
  {"insert_column_with_data_func",(nsp_method *) _wrap_gtk_tree_view_insert_column_with_data_func},
  {"get_column",(nsp_method *) _wrap_gtk_tree_view_get_column},
  {"get_columns",(nsp_method *) _wrap_gtk_tree_view_get_columns},
  {"move_column_after",(nsp_method *) _wrap_gtk_tree_view_move_column_after},
  {"set_expander_column",(nsp_method *) _wrap_gtk_tree_view_set_expander_column},
  {"get_expander_column",(nsp_method *) _wrap_gtk_tree_view_get_expander_column},
  {"scroll_to_point",(nsp_method *) _wrap_gtk_tree_view_scroll_to_point},
  {"scroll_to_cell",(nsp_method *) _wrap_gtk_tree_view_scroll_to_cell},
  {"row_activated",(nsp_method *) _wrap_gtk_tree_view_row_activated},
  {"expand_all",(nsp_method *) _wrap_gtk_tree_view_expand_all},
  {"collapse_all",(nsp_method *) _wrap_gtk_tree_view_collapse_all},
  {"expand_row",(nsp_method *) _wrap_gtk_tree_view_expand_row},
  {"collapse_row",(nsp_method *) _wrap_gtk_tree_view_collapse_row},
  {"row_expanded",(nsp_method *) _wrap_gtk_tree_view_row_expanded},
  {"set_reorderable",(nsp_method *) _wrap_gtk_tree_view_set_reorderable},
  {"get_reorderable",(nsp_method *) _wrap_gtk_tree_view_get_reorderable},
  {"set_cursor",(nsp_method *) _wrap_gtk_tree_view_set_cursor},
  {"get_cursor",(nsp_method *) _wrap_gtk_tree_view_get_cursor},
  {"get_bin_window",(nsp_method *) _wrap_gtk_tree_view_get_bin_window},
  {"get_path_at_pos",(nsp_method *) _wrap_gtk_tree_view_get_path_at_pos},
  {"get_cell_area",(nsp_method *) _wrap_gtk_tree_view_get_cell_area},
  {"get_background_area",(nsp_method *) _wrap_gtk_tree_view_get_background_area},
  {"get_visible_rect",(nsp_method *) _wrap_gtk_tree_view_get_visible_rect},
  {"widget_to_tree_coords",(nsp_method *) _wrap_gtk_tree_view_widget_to_tree_coords},
  {"tree_to_widget_coords",(nsp_method *) _wrap_gtk_tree_view_tree_to_widget_coords},
  {"unset_rows_drag_source",(nsp_method *) _wrap_gtk_tree_view_unset_rows_drag_source},
  {"unset_rows_drag_dest",(nsp_method *) _wrap_gtk_tree_view_unset_rows_drag_dest},
  {"set_drag_dest_row",(nsp_method *) _wrap_gtk_tree_view_set_drag_dest_row},
  {"create_row_drag_icon",(nsp_method *) _wrap_gtk_tree_view_create_row_drag_icon},
  {"set_enable_search",(nsp_method *) _wrap_gtk_tree_view_set_enable_search},
  {"get_enable_search",(nsp_method *) _wrap_gtk_tree_view_get_enable_search},
  {"get_search_column",(nsp_method *) _wrap_gtk_tree_view_get_search_column},
  {"set_search_column",(nsp_method *) _wrap_gtk_tree_view_set_search_column},
  { NULL, NULL}
};

static NspMethods *gtktreeview_get_methods(void) { return gtktreeview_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreeview_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkToolbar ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkToolbar_Private 
#include "nsp/gtk/gtktoolbar.h"
#include "nsp/interf.h"

/* NspGtkToolbar inherits from NspGtkContainer */ 

int nsp_type_gtktoolbar_id=0;
NspTypeGtkToolbar *nsp_type_gtktoolbar=NULL;

NspTypeGtkToolbar *new_type_gtktoolbar(type_mode mode)
{
  NspTypeGtkToolbar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktoolbar != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktoolbar;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktoolbar_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktoolbar_get_methods; 
  type->new = (new_func *) new_gtktoolbar;

  /* specific methods for gtktoolbar */
      
  type->init = (init_func *) init_gtktoolbar;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktoolbar */ 

  top->s_type =  (s_type_func *) gtktoolbar_type_as_string;    
  top->sh_type = (sh_type_func *) gtktoolbar_type_short_string;
  /* top->create = (create_func*) int_gtktoolbar_create;*/ 
  
  /* specific methods for gtktoolbar */
      
  type->init = (init_func *) init_gtktoolbar;

  if ( nsp_type_gtktoolbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkToolbar called nsp_type_gtktoolbar
       */
      type->id =  nsp_type_gtktoolbar_id = nsp_new_type_id();
      nsp_type_gtktoolbar = type;
      if ( nsp_register_type(nsp_type_gtktoolbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktoolbar, GTK_TYPE_TOOLBAR);
      return ( mode == T_BASE ) ? type : new_type_gtktoolbar(mode);
    }
  else 
    {
       type->id = nsp_type_gtktoolbar_id;
       return type;
    }
}

/*
 * initialize GtkToolbar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktoolbar(NspGtkToolbar *o,NspTypeGtkToolbar *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkToolbar 
 */

NspGtkToolbar *new_gtktoolbar() 
{
  NspGtkToolbar *loc; 
  /* type must exists */
  nsp_type_gtktoolbar = new_type_gtktoolbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkToolbar)))== NULLGTKTOOLBAR) return loc;
  /* initialize object */
  if ( init_gtktoolbar(loc,nsp_type_gtktoolbar) == FAIL) return NULLGTKTOOLBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkToolbar 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktoolbar_type_name[]="GtkToolbar";
static char gtktoolbar_short_type_name[]="GtkToolbar";

static char *gtktoolbar_type_as_string(void)
{
  return(gtktoolbar_type_name);
}

static char *gtktoolbar_type_short_string(void)
{
  return(gtktoolbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkToolbar objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkToolbar   *gtktoolbar_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktoolbar_id) ) return ((NspGtkToolbar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktoolbar));
  return NULL;
}

int IsGtkToolbarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktoolbar_id);
}

int IsGtkToolbar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktoolbar_id);
}

NspGtkToolbar  *GetGtkToolbarCopy(Stack stack, int i)
{
  if (  GetGtkToolbar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkToolbar  *GetGtkToolbar(Stack stack, int i)
{
  NspGtkToolbar *M;
  if (( M = gtktoolbar_object(NthObj(i))) == NULLGTKTOOLBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkToolbar *gtktoolbar_copy(NspGtkToolbar *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkToolbar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkToolbar *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktoolbar is initialized * /
  nsp_type_gtktoolbar = new_type_gtktoolbar(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtktoolbar)) == NULLGTKTOOLBAR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtktoolbar_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_toolbar_new())== NULL) return RET_BUG;

  nsp_type_gtktoolbar = new_type_gtktoolbar(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktoolbar );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 4597 "gtk.override"

typedef GtkWidget*  (*gtk_toolbar_f) (GtkToolbar *toolbar,
				      const char *text,
				      const char *tooltip_text,
				      const char *tooltip_private_text,
				      GtkWidget *icon,
				      GtkSignalFunc callback,
				      gpointer user_data);

static int
nsp_gtk_toolbar_item_add_callback_and_return(Stack stack,int flag,GtkWidget *ret,NspPList *callback,NspList *params)
{
  NspObject *nsp_ret=NULL;
  GClosure *closure;
  if ( ret == NULL) 
    {
      Scierror("%s: cannot create iem\n",stack.fname);
      return RET_BUG;
    }
  if ( callback != NULL && flag ) 
    {
      /* callback */
      if (( callback =(NspPList *)nsp_object_copy((NspObject *) callback)) == NULLP_PLIST) return RET_BUG;
      if ((nsp_object_set_name((NspObject *) callback,"callback")== FAIL)) return RET_BUG;
      /* user_data */
      if ( params != NULL ) 
	{
	  if (( params =nsp_list_copy(params)) == NULLLIST ) return RET_BUG;
	  if ((nsp_object_set_name((NspObject *)params,"m")== FAIL)) return RET_BUG;
	} 
      closure = nspg_closure_new(callback,params, NULL);
      g_signal_connect_closure(ret, "clicked", closure, FALSE);
      nspgobject_watch_closure(nsp_ret, closure);
    }
  if ((nsp_ret = (NspObject *) gobject_gettype_and_create(NVOID,(GObject *)ret))== NULL) return RET_BUG; 
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_toolbar_prepend_or_append_item(NspGObject *self,Stack stack,int rhs,int opt,int lhs,gtk_toolbar_f func)
{
  /* "text", "tooltip_text", "tooltip_private_text", "icon", "callback", "user_data" */
  nsp_option opts[] = {
    {"text",string,NULLOBJ,-1}, 
    {"tooltip_text",string,NULLOBJ,-1}, 
    {"tooltip_private_text",string,NULLOBJ,-1}, 
    {"icon",obj_check,NULLOBJ,-1}, 
    {"callback",obj_check,NULLOBJ,-1}, 
    {"params",list,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} 
  };
  int_types T[] = {new_opts, t_end} ;

  char *text=NULL, *tooltip_text=NULL, *tooltip_private_text=NULL;
  NspObject *nsp_icon= NULL;
  NspPList *callback=NULL;
  NspList *params=NULL;
  GtkWidget *icon = NULL;
  GtkWidget *ret ;
  
  if (GetArgs(stack,rhs,opt,T,&opts, &text, &tooltip_text, &tooltip_private_text, 
	      &nsp_type_gtkwidget,&nsp_icon,&nsp_type_plist,&callback, &params)  == FAIL) 
    return RET_BUG;;
  if ( nsp_icon != NULL)  icon = GTK_WIDGET(((NspGObject *)nsp_icon)->obj);

  ret = (*func)(GTK_TOOLBAR(self->obj), text, tooltip_text,
		tooltip_private_text, icon, NULL, NULL);
  
  return nsp_gtk_toolbar_item_add_callback_and_return(stack,TRUE,ret,callback,params);
}

static int
_wrap_gtk_toolbar_append_item(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_gtk_toolbar_prepend_or_append_item(self,stack,rhs,opt,lhs,gtk_toolbar_append_item);
}

#line 30167 "gtk.c"


#line 4677 "gtk.override"

static int
_wrap_gtk_toolbar_prepend_item(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_gtk_toolbar_prepend_or_append_item(self,stack,rhs,opt,lhs,gtk_toolbar_prepend_item);
}
#line 30177 "gtk.c"


#line 4685 "gtk.override"
static int
_wrap_gtk_toolbar_insert_stock(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* "stock_id", "tooltip_text", "tooltip_private_text", "callback", "user_data", "position" */
  nsp_option opts[] = {
    {"stock_id",string,NULLOBJ,-1}, 
    {"tooltip_text",string,NULLOBJ,-1}, 
    {"tooltip_private_text",string,NULLOBJ,-1}, 
    {"callback",obj_check,NULLOBJ,-1}, 
    {"params",list,NULLOBJ,-1}, 
    {"position",s_int,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} 
  };
  int_types T[] = { new_opts, t_end} ;

  char *stock_id= NULL,*tooltip_text=NULL, *tooltip_private_text=NULL;
  NspPList *callback=NULL;
  NspList *params=NULL;
  GtkWidget *ret;
  int position = -1;
  
  if (GetArgs(stack,rhs,opt,T,&opts, &stock_id, &tooltip_text, &tooltip_private_text, 
	      &nsp_type_plist,&callback, &params,&position)  == FAIL) 
    return RET_BUG;;

  ret = gtk_toolbar_insert_stock(GTK_TOOLBAR(self->obj), stock_id, tooltip_text,
				 tooltip_private_text, NULL, NULL,
				 position);

  return nsp_gtk_toolbar_item_add_callback_and_return(stack,TRUE,ret,callback,params);
}
#line 30212 "gtk.c"


static int _wrap_gtk_toolbar_append_space(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_toolbar_append_space(GTK_TOOLBAR(self->obj));
  return 0;
}

static int _wrap_gtk_toolbar_prepend_space(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_toolbar_prepend_space(GTK_TOOLBAR(self->obj));
  return 0;
}

static int _wrap_gtk_toolbar_insert_space(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int position;

  if ( GetArgs(stack,rhs,opt,T,&position) == FAIL) return RET_BUG;
  gtk_toolbar_insert_space(GTK_TOOLBAR(self->obj), position);
  return 0;
}

static int _wrap_gtk_toolbar_remove_space(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int position;

  if ( GetArgs(stack,rhs,opt,T,&position) == FAIL) return RET_BUG;
  gtk_toolbar_remove_space(GTK_TOOLBAR(self->obj), position);
  return 0;
}

#line 4718 "gtk.override"
static int
_wrap_gtk_toolbar_append_element(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* "type", "widget", "text", "tooltip_text","tooltip_private_text", "icon", "callback", "user_data" */

  nsp_option opts[] = {
    {"type",obj,NULLOBJ,-1}, 
    {"widget",obj_check,NULLOBJ,-1}, 
    {"text",string,NULLOBJ,-1}, 
    {"tooltip_text",string,NULLOBJ,-1}, 
    {"tooltip_private_text",string,NULLOBJ,-1}, 
    {"icon",obj_check,NULLOBJ,-1}, 
    {"callback",obj_check,NULLOBJ,-1}, 
    {"params",list,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} 
  };
  int_types T[] = { new_opts, t_end} ;
  int flag;
  char *text=NULL, *tooltip_text=NULL, *tooltip_private_text=NULL;
  NspObject *nsp_icon= NULL,*nsp_type=NULL,*nsp_widget=NULL;
  NspPList *callback=NULL;
  NspList *params=NULL;
  GtkWidget *icon = NULL, *widget=NULL,*ret;
  GtkToolbarChildType type;
  
  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type,&nsp_type_gtkwidget,&nsp_widget, &text, &tooltip_text, &tooltip_private_text, 
	      &nsp_type_gtkwidget,&nsp_icon,&nsp_type_plist,&callback, &params)  == FAIL) 
    return RET_BUG;;

  if ( nsp_icon != NULL)  icon = GTK_WIDGET(((NspGObject *)nsp_icon)->obj);

  if (nspg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,nsp_type,&type))   return RET_BUG;
  widget = GTK_WIDGET(((NspGObject *)nsp_widget)->obj);

  ret = gtk_toolbar_append_element(GTK_TOOLBAR(self->obj), type, widget,
				   text, tooltip_text, tooltip_private_text,
				   icon, NULL, NULL);
  
  flag = (type == GTK_TOOLBAR_CHILD_BUTTON ||
	  type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	  type == GTK_TOOLBAR_CHILD_RADIOBUTTON);

  return nsp_gtk_toolbar_item_add_callback_and_return(stack,flag,ret,callback,params);
}
#line 30292 "gtk.c"


#line 4764 "gtk.override"
static int
_wrap_gtk_toolbar_prepend_element(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* "type", "widget", "text", "tooltip_text","tooltip_private_text", "icon", "callback", "user_data" */

  nsp_option opts[] = {
    {"type",obj,NULLOBJ,-1}, 
    {"widget",obj_check,NULLOBJ,-1}, 
    {"text",string,NULLOBJ,-1}, 
    {"tooltip_text",string,NULLOBJ,-1}, 
    {"tooltip_private_text",string,NULLOBJ,-1}, 
    {"icon",obj_check,NULLOBJ,-1}, 
    {"callback",obj_check,NULLOBJ,-1}, 
    {"params",list,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} 
  };
  int_types T[] = { new_opts, t_end} ;
  int flag;
  char *text=NULL, *tooltip_text=NULL, *tooltip_private_text=NULL;
  NspObject *nsp_icon= NULL,*nsp_type=NULL,*nsp_widget=NULL;
  NspPList *callback=NULL;
  NspList *params=NULL;
  GtkWidget *icon = NULL, *widget=NULL,*ret;
  GtkToolbarChildType type;
  
  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type,&nsp_type_gtkwidget,&nsp_widget, &text, &tooltip_text, &tooltip_private_text, 
	      &nsp_type_gtkwidget,&nsp_icon,&nsp_type_plist,&callback, &params)  == FAIL) 
    return RET_BUG;;
  
  if ( nsp_icon != NULL)  icon = GTK_WIDGET(((NspGObject *)nsp_icon)->obj);

  if (nspg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,nsp_type, &type))   return RET_BUG;
  widget = GTK_WIDGET(((NspGObject *)nsp_widget)->obj);

  ret = gtk_toolbar_prepend_element(GTK_TOOLBAR(self->obj), type, widget,
				   text, tooltip_text, tooltip_private_text,
				   icon, NULL, NULL);
  
  flag = (type == GTK_TOOLBAR_CHILD_BUTTON ||
	  type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	  type == GTK_TOOLBAR_CHILD_RADIOBUTTON); 

  return nsp_gtk_toolbar_item_add_callback_and_return(stack,flag,ret,callback,params);
}
#line 30340 "gtk.c"


#line 4810 "gtk.override"
static int
_wrap_gtk_toolbar_insert_element(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{

  /* "type", "widget", "text", "tooltip_text", "tooltip_private_text", "icon", "callback","user_data", "position", NULL };*/

  nsp_option opts[] = {
    {"type",obj,NULLOBJ,-1}, 
    {"widget",obj_check,NULLOBJ,-1}, 
    {"text",string,NULLOBJ,-1}, 
    {"tooltip_text",string,NULLOBJ,-1}, 
    {"tooltip_private_text",string,NULLOBJ,-1}, 
    {"icon",obj_check,NULLOBJ,-1}, 
    {"callback",obj_check,NULLOBJ,-1}, 
    {"params",list,NULLOBJ,-1}, 
    {"position",s_int,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} 
  };
  int_types T[] = { new_opts, t_end} ;
  int position =-1;
  int flag;
  char *text=NULL, *tooltip_text=NULL, *tooltip_private_text=NULL;
  NspObject *nsp_icon= NULL,*nsp_type=NULL,*nsp_widget=NULL;
  NspPList *callback=NULL;
  NspList *params=NULL;
  GtkWidget *icon = NULL, *widget=NULL,*ret;
  GtkToolbarChildType type;

  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type,&nsp_type_gtkwidget,&nsp_widget, &text, &tooltip_text, &tooltip_private_text, 
	      &nsp_type_gtkwidget,&nsp_icon,&nsp_type_plist,&callback, &params,&position)  == FAIL) 
    return RET_BUG;;
  
  if ( nsp_icon != NULL)  icon =GTK_WIDGET(((NspGObject *)nsp_icon)->obj);

  if (nspg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,nsp_type, &type))   return RET_BUG;
  widget = GTK_WIDGET(((NspGObject *)nsp_widget)->obj);


  ret = gtk_toolbar_insert_element(GTK_TOOLBAR(self->obj), type, widget,
				   text, tooltip_text, tooltip_private_text,
				   icon, NULL, NULL, position);

  flag = (type == GTK_TOOLBAR_CHILD_BUTTON ||
	  type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	  type == GTK_TOOLBAR_CHILD_RADIOBUTTON); 

  return nsp_gtk_toolbar_item_add_callback_and_return(stack,flag,ret,callback,params);
}
#line 30392 "gtk.c"


static int _wrap_gtk_toolbar_append_widget(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, string, string,t_end};
  char *tooltip_text, *tooltip_private_text;
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &tooltip_text, &tooltip_private_text) == FAIL) return RET_BUG;
  gtk_toolbar_append_widget(GTK_TOOLBAR(self->obj), GTK_WIDGET(widget->obj), tooltip_text, tooltip_private_text);
  return 0;
}

static int _wrap_gtk_toolbar_prepend_widget(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, string, string,t_end};
  char *tooltip_text, *tooltip_private_text;
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &tooltip_text, &tooltip_private_text) == FAIL) return RET_BUG;
  gtk_toolbar_prepend_widget(GTK_TOOLBAR(self->obj), GTK_WIDGET(widget->obj), tooltip_text, tooltip_private_text);
  return 0;
}

static int _wrap_gtk_toolbar_insert_widget(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, string, string, s_int,t_end};
  char *tooltip_text, *tooltip_private_text;
  NspGObject *widget;
  int position;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &tooltip_text, &tooltip_private_text, &position) == FAIL) return RET_BUG;
  gtk_toolbar_insert_widget(GTK_TOOLBAR(self->obj), GTK_WIDGET(widget->obj), tooltip_text, tooltip_private_text, position);
  return 0;
}

static int _wrap_gtk_toolbar_set_orientation(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  gtk_toolbar_set_orientation(GTK_TOOLBAR(self->obj), orientation);
  return 0;
}

static int _wrap_gtk_toolbar_set_style(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkToolbarStyle style;
  NspObject *nsp_style = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_style) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TOOLBAR_STYLE, nsp_style, &style)== FAIL)
      return RET_BUG;
  gtk_toolbar_set_style(GTK_TOOLBAR(self->obj), style);
  return 0;
}

static int _wrap_gtk_toolbar_set_icon_size(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkIconSize icon_size;
  NspObject *nsp_icon_size = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_icon_size, &icon_size)== FAIL)
      return RET_BUG;
  gtk_toolbar_set_icon_size(GTK_TOOLBAR(self->obj), icon_size);
  return 0;
}

static int _wrap_gtk_toolbar_set_tooltips(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int enable;

  if ( GetArgs(stack,rhs,opt,T,&enable) == FAIL) return RET_BUG;
  gtk_toolbar_set_tooltips(GTK_TOOLBAR(self->obj), enable);
  return 0;
}

static int _wrap_gtk_toolbar_unset_style(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_toolbar_unset_style(GTK_TOOLBAR(self->obj));
  return 0;
}

static int _wrap_gtk_toolbar_unset_icon_size(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_toolbar_unset_icon_size(GTK_TOOLBAR(self->obj));
  return 0;
}

static int _wrap_gtk_toolbar_get_orientation(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_toolbar_get_orientation(GTK_TOOLBAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toolbar_get_style(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_toolbar_get_style(GTK_TOOLBAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toolbar_get_icon_size(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_toolbar_get_icon_size(GTK_TOOLBAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toolbar_get_tooltips(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_toolbar_get_tooltips(GTK_TOOLBAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktoolbar_methods[] = {
  {"append_item",(nsp_method *) _wrap_gtk_toolbar_append_item},
  {"prepend_item",(nsp_method *) _wrap_gtk_toolbar_prepend_item},
  {"insert_stock",(nsp_method *) _wrap_gtk_toolbar_insert_stock},
  {"append_space",(nsp_method *) _wrap_gtk_toolbar_append_space},
  {"prepend_space",(nsp_method *) _wrap_gtk_toolbar_prepend_space},
  {"insert_space",(nsp_method *) _wrap_gtk_toolbar_insert_space},
  {"remove_space",(nsp_method *) _wrap_gtk_toolbar_remove_space},
  {"append_element",(nsp_method *) _wrap_gtk_toolbar_append_element},
  {"prepend_element",(nsp_method *) _wrap_gtk_toolbar_prepend_element},
  {"insert_element",(nsp_method *) _wrap_gtk_toolbar_insert_element},
  {"append_widget",(nsp_method *) _wrap_gtk_toolbar_append_widget},
  {"prepend_widget",(nsp_method *) _wrap_gtk_toolbar_prepend_widget},
  {"insert_widget",(nsp_method *) _wrap_gtk_toolbar_insert_widget},
  {"set_orientation",(nsp_method *) _wrap_gtk_toolbar_set_orientation},
  {"set_style",(nsp_method *) _wrap_gtk_toolbar_set_style},
  {"set_icon_size",(nsp_method *) _wrap_gtk_toolbar_set_icon_size},
  {"set_tooltips",(nsp_method *) _wrap_gtk_toolbar_set_tooltips},
  {"unset_style",(nsp_method *) _wrap_gtk_toolbar_unset_style},
  {"unset_icon_size",(nsp_method *) _wrap_gtk_toolbar_unset_icon_size},
  {"get_orientation",(nsp_method *) _wrap_gtk_toolbar_get_orientation},
  {"get_style",(nsp_method *) _wrap_gtk_toolbar_get_style},
  {"get_icon_size",(nsp_method *) _wrap_gtk_toolbar_get_icon_size},
  {"get_tooltips",(nsp_method *) _wrap_gtk_toolbar_get_tooltips},
  { NULL, NULL}
};

static NspMethods *gtktoolbar_get_methods(void) { return gtktoolbar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktoolbar_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTextView ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTextView_Private 
#include "nsp/gtk/gtktextview.h"
#include "nsp/interf.h"

/* NspGtkTextView inherits from NspGtkContainer */ 

int nsp_type_gtktextview_id=0;
NspTypeGtkTextView *nsp_type_gtktextview=NULL;

NspTypeGtkTextView *new_type_gtktextview(type_mode mode)
{
  NspTypeGtkTextView *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextview != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextview;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextview_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktextview_get_methods; 
  type->new = (new_func *) new_gtktextview;

  /* specific methods for gtktextview */
      
  type->init = (init_func *) init_gtktextview;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktextview */ 

  top->s_type =  (s_type_func *) gtktextview_type_as_string;    
  top->sh_type = (sh_type_func *) gtktextview_type_short_string;
  /* top->create = (create_func*) int_gtktextview_create;*/ 
  
  /* specific methods for gtktextview */
      
  type->init = (init_func *) init_gtktextview;

  if ( nsp_type_gtktextview_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextView called nsp_type_gtktextview
       */
      type->id =  nsp_type_gtktextview_id = nsp_new_type_id();
      nsp_type_gtktextview = type;
      if ( nsp_register_type(nsp_type_gtktextview) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextview, GTK_TYPE_TEXT_VIEW);
      return ( mode == T_BASE ) ? type : new_type_gtktextview(mode);
    }
  else 
    {
       type->id = nsp_type_gtktextview_id;
       return type;
    }
}

/*
 * initialize GtkTextView instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextview(NspGtkTextView *o,NspTypeGtkTextView *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTextView 
 */

NspGtkTextView *new_gtktextview() 
{
  NspGtkTextView *loc; 
  /* type must exists */
  nsp_type_gtktextview = new_type_gtktextview(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextView)))== NULLGTKTEXTVIEW) return loc;
  /* initialize object */
  if ( init_gtktextview(loc,nsp_type_gtktextview) == FAIL) return NULLGTKTEXTVIEW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTextView 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktextview_type_name[]="GtkTextView";
static char gtktextview_short_type_name[]="GtkTextView";

static char *gtktextview_type_as_string(void)
{
  return(gtktextview_type_name);
}

static char *gtktextview_type_short_string(void)
{
  return(gtktextview_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTextView objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTextView   *gtktextview_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktextview_id) ) return ((NspGtkTextView *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextview));
  return NULL;
}

int IsGtkTextViewObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktextview_id);
}

int IsGtkTextView(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextview_id);
}

NspGtkTextView  *GetGtkTextViewCopy(Stack stack, int i)
{
  if (  GetGtkTextView(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextView  *GetGtkTextView(Stack stack, int i)
{
  NspGtkTextView *M;
  if (( M = gtktextview_object(NthObj(i))) == NULLGTKTEXTVIEW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextView *gtktextview_copy(NspGtkTextView *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextview);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextview);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextView
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTextView *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktextview is initialized * /
  nsp_type_gtktextview = new_type_gtktextview(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtktextview)) == NULLGTKTEXTVIEW) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtktextview_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"buffer",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *nsp_buffer = NULL;
  GtkTextBuffer *buffer = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_buffer) == FAIL) return RET_BUG;
  if ( nsp_buffer != NULL ) {
    if ( IsGtkTextBuffer((NspObject *)nsp_buffer))
      buffer = GTK_TEXT_BUFFER(nsp_buffer->obj);
    else if (! IsNone((NspObject *)nsp_buffer)) {
         Scierror( "buffer should be a GtkTextBuffer or None");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_text_view_new_with_buffer(buffer))== NULL) return RET_BUG;

  nsp_type_gtktextview = new_type_gtktextview(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktextview );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_view_set_buffer(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *buffer;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextbuffer, &buffer) == FAIL) return RET_BUG;
  gtk_text_view_set_buffer(GTK_TEXT_VIEW(self->obj), GTK_TEXT_BUFFER(buffer->obj));
  return 0;
}

static int _wrap_gtk_text_view_get_buffer(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextBuffer *ret;
  NspObject *nsp_ret;

  ret = gtk_text_view_get_buffer(GTK_TEXT_VIEW(self->obj));
  nsp_type_gtktextbuffer = new_type_gtktextbuffer(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextbuffer))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_view_scroll_to_iter(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, s_double,new_opts,t_end};
  nsp_option opts[] = {
	{"use_align",s_bool,NULLOBJ,-1}, 
	{"xalign",s_double,NULLOBJ,-1}, 
	{"yalign",s_double,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int use_align = FALSE, ret;
  double within_margin, xalign = 0.5, yalign = 0.5;
  NspObject *nsp_iter;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &within_margin, opts, &use_align, &xalign, &yalign) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_view_scroll_to_iter(GTK_TEXT_VIEW(self->obj), iter, within_margin, use_align, xalign, yalign);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_scroll_to_mark(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_double,new_opts,t_end};
  nsp_option opts[] = {
	{"use_align",s_bool,NULLOBJ,-1}, 
	{"xalign",s_double,NULLOBJ,-1}, 
	{"yalign",s_double,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int use_align = FALSE;
  NspGObject *mark;
  double within_margin, xalign = 0.5, yalign = 0.5;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark, &within_margin, opts, &use_align, &xalign, &yalign) == FAIL) return RET_BUG;
  gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(self->obj), GTK_TEXT_MARK(mark->obj), within_margin, use_align, xalign, yalign);
  return 0;
}

static int _wrap_gtk_text_view_scroll_mark_onscreen(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *mark;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark) == FAIL) return RET_BUG;
  gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(self->obj), GTK_TEXT_MARK(mark->obj));
  return 0;
}

static int _wrap_gtk_text_view_move_mark_onscreen(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  int ret;
  NspGObject *mark;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark) == FAIL) return RET_BUG;
  ret = gtk_text_view_move_mark_onscreen(GTK_TEXT_VIEW(self->obj), GTK_TEXT_MARK(mark->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_place_cursor_onscreen(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_view_place_cursor_onscreen(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 5795 "gtk.override"
static int
_wrap_gtk_text_view_get_visible_rect(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkRectangle visible_rect;
  NspObject *ret;

  gtk_text_view_get_visible_rect(GTK_TEXT_VIEW(self->obj), &visible_rect);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &visible_rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 30890 "gtk.c"


static int _wrap_gtk_text_view_set_cursor_visible(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(self->obj), setting);
  return 0;
}

static int _wrap_gtk_text_view_get_cursor_visible(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_view_get_cursor_visible(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 6415 "gtk.override"
static int
_wrap_gtk_text_view_get_iter_location(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end} ;
  /* static char *kwlist[] = { "iter", NULL };*/
  NspObject *nsp_iter;
  GdkRectangle location;
  GtkTextIter *iter = NULL;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter, &nsp_iter)  == FAIL) return RET_BUG;;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  gtk_text_view_get_iter_location(GTK_TEXT_VIEW(self->obj), iter, &location);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &location, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 30931 "gtk.c"


#line 6471 "gtk.override"
static int
_wrap_gtk_text_view_get_iter_at_location(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,t_end} ;
  /* static char *kwlist[] = { "x", "y", NULL };*/
  GtkTextIter iter;
  gint x, y;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &x, &y)  == FAIL) return RET_BUG;;
  gtk_text_view_get_iter_at_location(GTK_TEXT_VIEW(self->obj),  &iter, x, y);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 30950 "gtk.c"


#line 6452 "gtk.override"
static int
_wrap_gtk_text_view_get_line_yrange(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end} ;
  /* static char *kwlist[] = { "iter", NULL };*/
  GtkTextIter *iter = NULL;
  gint y = -1, height = -1;
  NspObject *nsp_iter;
  
  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter, &nsp_iter)  == FAIL) return RET_BUG;;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  gtk_text_view_get_line_yrange(GTK_TEXT_VIEW(self->obj),
				iter, &y, &height);
  if (  nsp_move_doubles(stack,1,1,2,(double) y,(double) height) == FAIL) 
    return RET_BUG; 
  return 1; 
}
#line 30971 "gtk.c"


#line 6435 "gtk.override"
static int
_wrap_gtk_text_view_get_line_at_y(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end} ;
  int_types ret_T[] = {obj,s_int, t_end} ;
  /* static char *kwlist[] = { "y", NULL };*/
  GtkTextIter iter;
  gint y, line_top;
  
  if (GetArgs(stack,rhs,opt,T, &y)   == FAIL) return RET_BUG;;
  gtk_text_view_get_line_at_y(GTK_TEXT_VIEW(self->obj),  &iter, y, &line_top);
  return RetArgs(stack,lhs,ret_T,
		 (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter,TRUE, TRUE, NULL),
		 line_top);
}
#line 30990 "gtk.c"


#line 5808 "gtk.override"
static int
_wrap_gtk_text_view_buffer_to_window_coords(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "win", "buffer_x", "buffer_y", NULL };*/
  GtkTextWindowType win;
  gint buffer_x, buffer_y, window_x = 0, window_y = 0;
  NspObject *nsp_win;
  
  if (GetArgs(stack,rhs,opt,T, &nsp_win, &buffer_x, &buffer_y) == FAIL) return RET_BUG;;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_win,&win))
    return RET_BUG;
  gtk_text_view_buffer_to_window_coords(GTK_TEXT_VIEW(self->obj), win,
					buffer_x, buffer_y,
					&window_x, &window_y);
  if ( nsp_move_doubles(stack,1,1,2,(double) window_x,(double) window_y) == FAIL) return RET_BUG; 
  return 1;
}
#line 31012 "gtk.c"


#line 5828 "gtk.override"
static int
_wrap_gtk_text_view_window_to_buffer_coords(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "win", "window_x", "window_y", NULL };*/
  GtkTextWindowType win;
  gint window_x, window_y, buffer_x = 0, buffer_y = 0;
  NspObject *nsp_win;
    
  if (GetArgs(stack,rhs,opt,T, &nsp_win, &window_x, &window_y) == FAIL) return RET_BUG;;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_win,&win))
    return RET_BUG;
  gtk_text_view_window_to_buffer_coords(GTK_TEXT_VIEW(self->obj), win,
					window_x, window_y,
					&buffer_x, &buffer_y);
  if ( nsp_move_doubles(stack,1,1,2,(double) buffer_x,(double) buffer_y) == FAIL) return RET_BUG; 
  return 1;
}
#line 31034 "gtk.c"


static int _wrap_gtk_text_view_get_window(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_win = NULL, *nsp_ret;
  GtkTextWindowType win;
  GdkWindow *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_win) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_win, &win)== FAIL)
      return RET_BUG;
  ret = gtk_text_view_get_window(GTK_TEXT_VIEW(self->obj), win);
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_view_get_window_type(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *window;
  gint ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window) == FAIL) return RET_BUG;
  ret = gtk_text_view_get_window_type(GTK_TEXT_VIEW(self->obj), GDK_WINDOW(window->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_border_window_size(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, s_int,t_end};
  int size;
  NspObject *nsp_type = NULL;
  GtkTextWindowType type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type, &size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
  gtk_text_view_set_border_window_size(GTK_TEXT_VIEW(self->obj), type, size);
  return 0;
}

static int _wrap_gtk_text_view_get_border_window_size(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_type = NULL;
  GtkTextWindowType type;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
  ret = gtk_text_view_get_border_window_size(GTK_TEXT_VIEW(self->obj), type);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_forward_display_line(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_iter;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_view_forward_display_line(GTK_TEXT_VIEW(self->obj), iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_backward_display_line(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_iter;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_view_backward_display_line(GTK_TEXT_VIEW(self->obj), iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_forward_display_line_end(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_iter;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_view_forward_display_line_end(GTK_TEXT_VIEW(self->obj), iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_backward_display_line_start(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_iter;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_view_backward_display_line_start(GTK_TEXT_VIEW(self->obj), iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_starts_display_line(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  int ret;
  NspObject *nsp_iter;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_view_starts_display_line(GTK_TEXT_VIEW(self->obj), iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_move_visually(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, s_int,t_end};
  int count, ret;
  NspObject *nsp_iter;
  GtkTextIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &count) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "iter should be a GtkTextIter");
      return RET_BUG;
  }
  ret = gtk_text_view_move_visually(GTK_TEXT_VIEW(self->obj), iter, count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_add_child_at_anchor(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check,t_end};
  NspGObject *child, *anchor;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtktextchildanchor, &anchor) == FAIL) return RET_BUG;
  gtk_text_view_add_child_at_anchor(GTK_TEXT_VIEW(self->obj), GTK_WIDGET(child->obj), GTK_TEXT_CHILD_ANCHOR(anchor->obj));
  return 0;
}

static int _wrap_gtk_text_view_add_child_in_window(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj, s_int, s_int,t_end};
  int xpos, ypos;
  NspGObject *child;
  NspObject *nsp_which_window = NULL;
  GtkTextWindowType which_window;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_which_window, &xpos, &ypos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_which_window, &which_window)== FAIL)
      return RET_BUG;
  gtk_text_view_add_child_in_window(GTK_TEXT_VIEW(self->obj), GTK_WIDGET(child->obj), which_window, xpos, ypos);
  return 0;
}

static int _wrap_gtk_text_view_move_child(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int, s_int,t_end};
  int xpos, ypos;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &xpos, &ypos) == FAIL) return RET_BUG;
  gtk_text_view_move_child(GTK_TEXT_VIEW(self->obj), GTK_WIDGET(child->obj), xpos, ypos);
  return 0;
}

static int _wrap_gtk_text_view_set_wrap_mode(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_wrap_mode = NULL;
  GtkWrapMode wrap_mode;

  if ( GetArgs(stack,rhs,opt,T,&nsp_wrap_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_WRAP_MODE, nsp_wrap_mode, &wrap_mode)== FAIL)
      return RET_BUG;
  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(self->obj), wrap_mode);
  return 0;
}

static int _wrap_gtk_text_view_get_wrap_mode(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_text_view_get_wrap_mode(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_editable(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_text_view_set_editable(GTK_TEXT_VIEW(self->obj), setting);
  return 0;
}

static int _wrap_gtk_text_view_get_editable(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_view_get_editable(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_pixels_above_lines(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pixels_above_lines;

  if ( GetArgs(stack,rhs,opt,T,&pixels_above_lines) == FAIL) return RET_BUG;
  gtk_text_view_set_pixels_above_lines(GTK_TEXT_VIEW(self->obj), pixels_above_lines);
  return 0;
}

static int _wrap_gtk_text_view_get_pixels_above_lines(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_view_get_pixels_above_lines(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_pixels_below_lines(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pixels_below_lines;

  if ( GetArgs(stack,rhs,opt,T,&pixels_below_lines) == FAIL) return RET_BUG;
  gtk_text_view_set_pixels_below_lines(GTK_TEXT_VIEW(self->obj), pixels_below_lines);
  return 0;
}

static int _wrap_gtk_text_view_get_pixels_below_lines(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_view_get_pixels_below_lines(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_pixels_inside_wrap(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int pixels_inside_wrap;

  if ( GetArgs(stack,rhs,opt,T,&pixels_inside_wrap) == FAIL) return RET_BUG;
  gtk_text_view_set_pixels_inside_wrap(GTK_TEXT_VIEW(self->obj), pixels_inside_wrap);
  return 0;
}

static int _wrap_gtk_text_view_get_pixels_inside_wrap(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_view_get_pixels_inside_wrap(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_justification(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_justification = NULL;
  GtkJustification justification;

  if ( GetArgs(stack,rhs,opt,T,&nsp_justification) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_JUSTIFICATION, nsp_justification, &justification)== FAIL)
      return RET_BUG;
  gtk_text_view_set_justification(GTK_TEXT_VIEW(self->obj), justification);
  return 0;
}

static int _wrap_gtk_text_view_get_justification(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_text_view_get_justification(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_left_margin(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int left_margin;

  if ( GetArgs(stack,rhs,opt,T,&left_margin) == FAIL) return RET_BUG;
  gtk_text_view_set_left_margin(GTK_TEXT_VIEW(self->obj), left_margin);
  return 0;
}

static int _wrap_gtk_text_view_get_left_margin(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_view_get_left_margin(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_right_margin(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int right_margin;

  if ( GetArgs(stack,rhs,opt,T,&right_margin) == FAIL) return RET_BUG;
  gtk_text_view_set_right_margin(GTK_TEXT_VIEW(self->obj), right_margin);
  return 0;
}

static int _wrap_gtk_text_view_get_right_margin(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_view_get_right_margin(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_indent(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int indent;

  if ( GetArgs(stack,rhs,opt,T,&indent) == FAIL) return RET_BUG;
  gtk_text_view_set_indent(GTK_TEXT_VIEW(self->obj), indent);
  return 0;
}

static int _wrap_gtk_text_view_get_indent(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_text_view_get_indent(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_tabs(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_tabs;
  PangoTabArray *tabs = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_tabs) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_tabs, PANGO_TYPE_TAB_ARRAY))
      tabs = nspg_boxed_get(nsp_tabs, PangoTabArray);
  else {
      Scierror( "tabs should be a PangoTabArray");
      return RET_BUG;
  }
  gtk_text_view_set_tabs(GTK_TEXT_VIEW(self->obj), tabs);
  return 0;
}

static int _wrap_gtk_text_view_get_tabs(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  PangoTabArray *ret;

  ret = gtk_text_view_get_tabs(GTK_TEXT_VIEW(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,PANGO_TYPE_TAB_ARRAY, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_pangotabarray))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_view_get_default_attributes(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkTextAttributes *ret;

  ret = gtk_text_view_get_default_attributes(GTK_TEXT_VIEW(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ATTRIBUTES, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktextattributes))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtktextview_methods[] = {
  {"set_buffer",(nsp_method *) _wrap_gtk_text_view_set_buffer},
  {"get_buffer",(nsp_method *) _wrap_gtk_text_view_get_buffer},
  {"scroll_to_iter",(nsp_method *) _wrap_gtk_text_view_scroll_to_iter},
  {"scroll_to_mark",(nsp_method *) _wrap_gtk_text_view_scroll_to_mark},
  {"scroll_mark_onscreen",(nsp_method *) _wrap_gtk_text_view_scroll_mark_onscreen},
  {"move_mark_onscreen",(nsp_method *) _wrap_gtk_text_view_move_mark_onscreen},
  {"place_cursor_onscreen",(nsp_method *) _wrap_gtk_text_view_place_cursor_onscreen},
  {"get_visible_rect",(nsp_method *) _wrap_gtk_text_view_get_visible_rect},
  {"set_cursor_visible",(nsp_method *) _wrap_gtk_text_view_set_cursor_visible},
  {"get_cursor_visible",(nsp_method *) _wrap_gtk_text_view_get_cursor_visible},
  {"get_iter_location",(nsp_method *) _wrap_gtk_text_view_get_iter_location},
  {"get_iter_at_location",(nsp_method *) _wrap_gtk_text_view_get_iter_at_location},
  {"get_line_yrange",(nsp_method *) _wrap_gtk_text_view_get_line_yrange},
  {"get_line_at_y",(nsp_method *) _wrap_gtk_text_view_get_line_at_y},
  {"buffer_to_window_coords",(nsp_method *) _wrap_gtk_text_view_buffer_to_window_coords},
  {"window_to_buffer_coords",(nsp_method *) _wrap_gtk_text_view_window_to_buffer_coords},
  {"get_window",(nsp_method *) _wrap_gtk_text_view_get_window},
  {"get_window_type",(nsp_method *) _wrap_gtk_text_view_get_window_type},
  {"set_border_window_size",(nsp_method *) _wrap_gtk_text_view_set_border_window_size},
  {"get_border_window_size",(nsp_method *) _wrap_gtk_text_view_get_border_window_size},
  {"forward_display_line",(nsp_method *) _wrap_gtk_text_view_forward_display_line},
  {"backward_display_line",(nsp_method *) _wrap_gtk_text_view_backward_display_line},
  {"forward_display_line_end",(nsp_method *) _wrap_gtk_text_view_forward_display_line_end},
  {"backward_display_line_start",(nsp_method *) _wrap_gtk_text_view_backward_display_line_start},
  {"starts_display_line",(nsp_method *) _wrap_gtk_text_view_starts_display_line},
  {"move_visually",(nsp_method *) _wrap_gtk_text_view_move_visually},
  {"add_child_at_anchor",(nsp_method *) _wrap_gtk_text_view_add_child_at_anchor},
  {"add_child_in_window",(nsp_method *) _wrap_gtk_text_view_add_child_in_window},
  {"move_child",(nsp_method *) _wrap_gtk_text_view_move_child},
  {"set_wrap_mode",(nsp_method *) _wrap_gtk_text_view_set_wrap_mode},
  {"get_wrap_mode",(nsp_method *) _wrap_gtk_text_view_get_wrap_mode},
  {"set_editable",(nsp_method *) _wrap_gtk_text_view_set_editable},
  {"get_editable",(nsp_method *) _wrap_gtk_text_view_get_editable},
  {"set_pixels_above_lines",(nsp_method *) _wrap_gtk_text_view_set_pixels_above_lines},
  {"get_pixels_above_lines",(nsp_method *) _wrap_gtk_text_view_get_pixels_above_lines},
  {"set_pixels_below_lines",(nsp_method *) _wrap_gtk_text_view_set_pixels_below_lines},
  {"get_pixels_below_lines",(nsp_method *) _wrap_gtk_text_view_get_pixels_below_lines},
  {"set_pixels_inside_wrap",(nsp_method *) _wrap_gtk_text_view_set_pixels_inside_wrap},
  {"get_pixels_inside_wrap",(nsp_method *) _wrap_gtk_text_view_get_pixels_inside_wrap},
  {"set_justification",(nsp_method *) _wrap_gtk_text_view_set_justification},
  {"get_justification",(nsp_method *) _wrap_gtk_text_view_get_justification},
  {"set_left_margin",(nsp_method *) _wrap_gtk_text_view_set_left_margin},
  {"get_left_margin",(nsp_method *) _wrap_gtk_text_view_get_left_margin},
  {"set_right_margin",(nsp_method *) _wrap_gtk_text_view_set_right_margin},
  {"get_right_margin",(nsp_method *) _wrap_gtk_text_view_get_right_margin},
  {"set_indent",(nsp_method *) _wrap_gtk_text_view_set_indent},
  {"get_indent",(nsp_method *) _wrap_gtk_text_view_get_indent},
  {"set_tabs",(nsp_method *) _wrap_gtk_text_view_set_tabs},
  {"get_tabs",(nsp_method *) _wrap_gtk_text_view_get_tabs},
  {"get_default_attributes",(nsp_method *) _wrap_gtk_text_view_get_default_attributes},
  { NULL, NULL}
};

static NspMethods *gtktextview_get_methods(void) { return gtktextview_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktextview_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTable ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTable_Private 
#include "nsp/gtk/gtktable.h"
#include "nsp/interf.h"

/* NspGtkTable inherits from NspGtkContainer */ 

int nsp_type_gtktable_id=0;
NspTypeGtkTable *nsp_type_gtktable=NULL;

NspTypeGtkTable *new_type_gtktable(type_mode mode)
{
  NspTypeGtkTable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktable != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktable;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktable_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktable_get_methods; 
  type->new = (new_func *) new_gtktable;

  /* specific methods for gtktable */
      
  type->init = (init_func *) init_gtktable;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktable */ 

  top->s_type =  (s_type_func *) gtktable_type_as_string;    
  top->sh_type = (sh_type_func *) gtktable_type_short_string;
  /* top->create = (create_func*) int_gtktable_create;*/ 
  
  /* specific methods for gtktable */
      
  type->init = (init_func *) init_gtktable;

  if ( nsp_type_gtktable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTable called nsp_type_gtktable
       */
      type->id =  nsp_type_gtktable_id = nsp_new_type_id();
      nsp_type_gtktable = type;
      if ( nsp_register_type(nsp_type_gtktable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktable, GTK_TYPE_TABLE);
      return ( mode == T_BASE ) ? type : new_type_gtktable(mode);
    }
  else 
    {
       type->id = nsp_type_gtktable_id;
       return type;
    }
}

/*
 * initialize GtkTable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktable(NspGtkTable *o,NspTypeGtkTable *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTable 
 */

NspGtkTable *new_gtktable() 
{
  NspGtkTable *loc; 
  /* type must exists */
  nsp_type_gtktable = new_type_gtktable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTable)))== NULLGTKTABLE) return loc;
  /* initialize object */
  if ( init_gtktable(loc,nsp_type_gtktable) == FAIL) return NULLGTKTABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTable 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktable_type_name[]="GtkTable";
static char gtktable_short_type_name[]="GtkTable";

static char *gtktable_type_as_string(void)
{
  return(gtktable_type_name);
}

static char *gtktable_type_short_string(void)
{
  return(gtktable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTable objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTable   *gtktable_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktable_id) ) return ((NspGtkTable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktable));
  return NULL;
}

int IsGtkTableObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktable_id);
}

int IsGtkTable(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktable_id);
}

NspGtkTable  *GetGtkTableCopy(Stack stack, int i)
{
  if (  GetGtkTable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTable  *GetGtkTable(Stack stack, int i)
{
  NspGtkTable *M;
  if (( M = gtktable_object(NthObj(i))) == NULLGTKTABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTable *gtktable_copy(NspGtkTable *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTable *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktable is initialized * /
  nsp_type_gtktable = new_type_gtktable(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtktable)) == NULLGTKTABLE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtktable_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"rows",s_int,NULLOBJ,-1}, 
	{"columns",s_int,NULLOBJ,-1}, 
	{"homogeneous",s_bool,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int rows = 1, columns = 1, homogeneous = FALSE;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &rows, &columns, &homogeneous) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_table_new(rows, columns, homogeneous))== NULL) return RET_BUG;

  nsp_type_gtktable = new_type_gtktable(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktable );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_table_resize(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int rows, columns;

  if ( GetArgs(stack,rhs,opt,T,&rows, &columns) == FAIL) return RET_BUG;
  gtk_table_resize(GTK_TABLE(self->obj), rows, columns);
  return 0;
}

static int _wrap_gtk_table_attach(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int, s_int, s_int, s_int,new_opts,t_end};
  nsp_option opts[] = {
	{"xoptions",obj,NULLOBJ,-1}, 
	{"yoptions",obj,NULLOBJ,-1}, 
	{"xpadding",s_int,NULLOBJ,-1}, 
	{"ypadding",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int left_attach, right_attach, top_attach, bottom_attach, xpadding = 0, ypadding = 0;
  NspGObject *child;
  NspObject *nsp_xoptions = NULL, *nsp_yoptions = NULL;
  GtkAttachOptions xoptions = GTK_EXPAND|GTK_FILL, yoptions = GTK_EXPAND|GTK_FILL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &left_attach, &right_attach, &top_attach, &bottom_attach, opts, &nsp_xoptions, &nsp_yoptions, &xpadding, &ypadding) == FAIL) return RET_BUG;
  if (nsp_xoptions && nspg_flags_get_value(GTK_TYPE_ATTACH_OPTIONS, nsp_xoptions, &xoptions)==FAIL)
      return RET_BUG;
  if (nsp_yoptions && nspg_flags_get_value(GTK_TYPE_ATTACH_OPTIONS, nsp_yoptions, &yoptions)==FAIL)
      return RET_BUG;
  gtk_table_attach(GTK_TABLE(self->obj), GTK_WIDGET(child->obj), left_attach, right_attach, top_attach, bottom_attach, xoptions, yoptions, xpadding, ypadding);
  return 0;
}

static int _wrap_gtk_table_attach_defaults(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int, s_int, s_int, s_int,t_end};
  int left_attach, right_attach, top_attach, bottom_attach;
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &left_attach, &right_attach, &top_attach, &bottom_attach) == FAIL) return RET_BUG;
  gtk_table_attach_defaults(GTK_TABLE(self->obj), GTK_WIDGET(widget->obj), left_attach, right_attach, top_attach, bottom_attach);
  return 0;
}

static int _wrap_gtk_table_set_row_spacing(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int row, spacing;

  if ( GetArgs(stack,rhs,opt,T,&row, &spacing) == FAIL) return RET_BUG;
  gtk_table_set_row_spacing(GTK_TABLE(self->obj), row, spacing);
  return 0;
}

static int _wrap_gtk_table_get_row_spacing(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int row, ret;

  if ( GetArgs(stack,rhs,opt,T,&row) == FAIL) return RET_BUG;
  ret = gtk_table_get_row_spacing(GTK_TABLE(self->obj), row);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_table_set_col_spacing(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int column, spacing;

  if ( GetArgs(stack,rhs,opt,T,&column, &spacing) == FAIL) return RET_BUG;
  gtk_table_set_col_spacing(GTK_TABLE(self->obj), column, spacing);
  return 0;
}

static int _wrap_gtk_table_get_col_spacing(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int column, ret;

  if ( GetArgs(stack,rhs,opt,T,&column) == FAIL) return RET_BUG;
  ret = gtk_table_get_col_spacing(GTK_TABLE(self->obj), column);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_table_set_row_spacings(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int spacing;

  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
  gtk_table_set_row_spacings(GTK_TABLE(self->obj), spacing);
  return 0;
}

static int _wrap_gtk_table_get_default_row_spacing(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_table_get_default_row_spacing(GTK_TABLE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_table_set_col_spacings(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int spacing;

  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
  gtk_table_set_col_spacings(GTK_TABLE(self->obj), spacing);
  return 0;
}

static int _wrap_gtk_table_get_default_col_spacing(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_table_get_default_col_spacing(GTK_TABLE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_table_set_homogeneous(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int homogeneous;

  if ( GetArgs(stack,rhs,opt,T,&homogeneous) == FAIL) return RET_BUG;
  gtk_table_set_homogeneous(GTK_TABLE(self->obj), homogeneous);
  return 0;
}

static int _wrap_gtk_table_get_homogeneous(NspGtkTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_table_get_homogeneous(GTK_TABLE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktable_methods[] = {
  {"resize",(nsp_method *) _wrap_gtk_table_resize},
  {"attach",(nsp_method *) _wrap_gtk_table_attach},
  {"attach_defaults",(nsp_method *) _wrap_gtk_table_attach_defaults},
  {"set_row_spacing",(nsp_method *) _wrap_gtk_table_set_row_spacing},
  {"get_row_spacing",(nsp_method *) _wrap_gtk_table_get_row_spacing},
  {"set_col_spacing",(nsp_method *) _wrap_gtk_table_set_col_spacing},
  {"get_col_spacing",(nsp_method *) _wrap_gtk_table_get_col_spacing},
  {"set_row_spacings",(nsp_method *) _wrap_gtk_table_set_row_spacings},
  {"get_default_row_spacing",(nsp_method *) _wrap_gtk_table_get_default_row_spacing},
  {"set_col_spacings",(nsp_method *) _wrap_gtk_table_set_col_spacings},
  {"get_default_col_spacing",(nsp_method *) _wrap_gtk_table_get_default_col_spacing},
  {"set_homogeneous",(nsp_method *) _wrap_gtk_table_set_homogeneous},
  {"get_homogeneous",(nsp_method *) _wrap_gtk_table_get_homogeneous},
  { NULL, NULL}
};

static NspMethods *gtktable_get_methods(void) { return gtktable_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktable_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkSocket ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkSocket_Private 
#include "nsp/gtk/gtksocket.h"
#include "nsp/interf.h"

/* NspGtkSocket inherits from NspGtkContainer */ 

int nsp_type_gtksocket_id=0;
NspTypeGtkSocket *nsp_type_gtksocket=NULL;

NspTypeGtkSocket *new_type_gtksocket(type_mode mode)
{
  NspTypeGtkSocket *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtksocket != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtksocket;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtksocket_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtksocket_get_methods; 
  type->new = (new_func *) new_gtksocket;

  /* specific methods for gtksocket */
      
  type->init = (init_func *) init_gtksocket;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtksocket */ 

  top->s_type =  (s_type_func *) gtksocket_type_as_string;    
  top->sh_type = (sh_type_func *) gtksocket_type_short_string;
  /* top->create = (create_func*) int_gtksocket_create;*/ 
  
  /* specific methods for gtksocket */
      
  type->init = (init_func *) init_gtksocket;

  if ( nsp_type_gtksocket_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSocket called nsp_type_gtksocket
       */
      type->id =  nsp_type_gtksocket_id = nsp_new_type_id();
      nsp_type_gtksocket = type;
      if ( nsp_register_type(nsp_type_gtksocket) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtksocket, GTK_TYPE_SOCKET);
      return ( mode == T_BASE ) ? type : new_type_gtksocket(mode);
    }
  else 
    {
       type->id = nsp_type_gtksocket_id;
       return type;
    }
}

/*
 * initialize GtkSocket instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtksocket(NspGtkSocket *o,NspTypeGtkSocket *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkSocket 
 */

NspGtkSocket *new_gtksocket() 
{
  NspGtkSocket *loc; 
  /* type must exists */
  nsp_type_gtksocket = new_type_gtksocket(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSocket)))== NULLGTKSOCKET) return loc;
  /* initialize object */
  if ( init_gtksocket(loc,nsp_type_gtksocket) == FAIL) return NULLGTKSOCKET;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkSocket 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtksocket_type_name[]="GtkSocket";
static char gtksocket_short_type_name[]="GtkSocket";

static char *gtksocket_type_as_string(void)
{
  return(gtksocket_type_name);
}

static char *gtksocket_type_short_string(void)
{
  return(gtksocket_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkSocket objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkSocket   *gtksocket_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtksocket_id) ) return ((NspGtkSocket *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtksocket));
  return NULL;
}

int IsGtkSocketObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtksocket_id);
}

int IsGtkSocket(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtksocket_id);
}

NspGtkSocket  *GetGtkSocketCopy(Stack stack, int i)
{
  if (  GetGtkSocket(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSocket  *GetGtkSocket(Stack stack, int i)
{
  NspGtkSocket *M;
  if (( M = gtksocket_object(NthObj(i))) == NULLGTKSOCKET)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSocket *gtksocket_copy(NspGtkSocket *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksocket);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksocket);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSocket
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkSocket *H;
  CheckRhs(0,0);
  / * want to be sure that type gtksocket is initialized * /
  nsp_type_gtksocket = new_type_gtksocket(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtksocket)) == NULLGTKSOCKET) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtksocket_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_socket_new())== NULL) return RET_BUG;

  nsp_type_gtksocket = new_type_gtksocket(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtksocket );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_socket_add_id(NspGtkSocket *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  gulong window_id;

  if ( GetArgs(stack,rhs,opt,T,&window_id) == FAIL) return RET_BUG;
  gtk_socket_add_id(GTK_SOCKET(self->obj), window_id);
  return 0;
}

static int _wrap_gtk_socket_get_id(NspGtkSocket *self,Stack stack,int rhs,int opt,int lhs)
{
  gulong ret;

  ret = gtk_socket_get_id(GTK_SOCKET(self->obj));
 if (  nsp_move_double(stack,1,(double) ret) == FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_socket_steal(NspGtkSocket *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  gulong wid;

  if ( GetArgs(stack,rhs,opt,T,&wid) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_socket_steal(GTK_SOCKET(self->obj), wid);
  return 0;
}

static NspMethods gtksocket_methods[] = {
  {"add_id",(nsp_method *) _wrap_gtk_socket_add_id},
  {"get_id",(nsp_method *) _wrap_gtk_socket_get_id},
  {"steal",(nsp_method *) _wrap_gtk_socket_steal},
  { NULL, NULL}
};

static NspMethods *gtksocket_get_methods(void) { return gtksocket_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtksocket_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkPaned ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkPaned_Private 
#include "nsp/gtk/gtkpaned.h"
#include "nsp/interf.h"

/* NspGtkPaned inherits from NspGtkContainer */ 

int nsp_type_gtkpaned_id=0;
NspTypeGtkPaned *nsp_type_gtkpaned=NULL;

NspTypeGtkPaned *new_type_gtkpaned(type_mode mode)
{
  NspTypeGtkPaned *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkpaned != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkpaned;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkpaned_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkpaned_get_methods; 
  type->new = (new_func *) new_gtkpaned;

  /* specific methods for gtkpaned */
      
  type->init = (init_func *) init_gtkpaned;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkpaned */ 

  top->s_type =  (s_type_func *) gtkpaned_type_as_string;    
  top->sh_type = (sh_type_func *) gtkpaned_type_short_string;
  /* top->create = (create_func*) int_gtkpaned_create;*/ 
  
  /* specific methods for gtkpaned */
      
  type->init = (init_func *) init_gtkpaned;

  if ( nsp_type_gtkpaned_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkPaned called nsp_type_gtkpaned
       */
      type->id =  nsp_type_gtkpaned_id = nsp_new_type_id();
      nsp_type_gtkpaned = type;
      if ( nsp_register_type(nsp_type_gtkpaned) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkpaned, GTK_TYPE_PANED);
      return ( mode == T_BASE ) ? type : new_type_gtkpaned(mode);
    }
  else 
    {
       type->id = nsp_type_gtkpaned_id;
       return type;
    }
}

/*
 * initialize GtkPaned instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkpaned(NspGtkPaned *o,NspTypeGtkPaned *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkPaned 
 */

NspGtkPaned *new_gtkpaned() 
{
  NspGtkPaned *loc; 
  /* type must exists */
  nsp_type_gtkpaned = new_type_gtkpaned(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkPaned)))== NULLGTKPANED) return loc;
  /* initialize object */
  if ( init_gtkpaned(loc,nsp_type_gtkpaned) == FAIL) return NULLGTKPANED;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkPaned 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkpaned_type_name[]="GtkPaned";
static char gtkpaned_short_type_name[]="GtkPaned";

static char *gtkpaned_type_as_string(void)
{
  return(gtkpaned_type_name);
}

static char *gtkpaned_type_short_string(void)
{
  return(gtkpaned_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkPaned objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkPaned   *gtkpaned_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkpaned_id) ) return ((NspGtkPaned *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkpaned));
  return NULL;
}

int IsGtkPanedObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkpaned_id);
}

int IsGtkPaned(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkpaned_id);
}

NspGtkPaned  *GetGtkPanedCopy(Stack stack, int i)
{
  if (  GetGtkPaned(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkPaned  *GetGtkPaned(Stack stack, int i)
{
  NspGtkPaned *M;
  if (( M = gtkpaned_object(NthObj(i))) == NULLGTKPANED)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkPaned *gtkpaned_copy(NspGtkPaned *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkpaned);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkpaned);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkPaned
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkPaned *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkpaned is initialized * /
  nsp_type_gtkpaned = new_type_gtkpaned(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtkpaned)) == NULLGTKPANED) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_paned_add1(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
  gtk_paned_add1(GTK_PANED(self->obj), GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_paned_add2(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
  gtk_paned_add2(GTK_PANED(self->obj), GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_paned_pack1(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,new_opts,t_end};
  nsp_option opts[] = {
	{"resize",s_bool,NULLOBJ,-1}, 
	{"shrink",s_bool,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int resize = FALSE, shrink = TRUE;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, opts, &resize, &shrink) == FAIL) return RET_BUG;
  gtk_paned_pack1(GTK_PANED(self->obj), GTK_WIDGET(child->obj), resize, shrink);
  return 0;
}

static int _wrap_gtk_paned_pack2(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,new_opts,t_end};
  nsp_option opts[] = {
	{"resize",s_bool,NULLOBJ,-1}, 
	{"shrink",s_bool,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int resize = TRUE, shrink = TRUE;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, opts, &resize, &shrink) == FAIL) return RET_BUG;
  gtk_paned_pack2(GTK_PANED(self->obj), GTK_WIDGET(child->obj), resize, shrink);
  return 0;
}

static int _wrap_gtk_paned_get_position(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_paned_get_position(GTK_PANED(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_paned_set_position(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int position;

  if ( GetArgs(stack,rhs,opt,T,&position) == FAIL) return RET_BUG;
  gtk_paned_set_position(GTK_PANED(self->obj), position);
  return 0;
}

static int _wrap_gtk_paned_compute_position(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int, s_int,t_end};
  int allocation, child1_req, child2_req;

  if ( GetArgs(stack,rhs,opt,T,&allocation, &child1_req, &child2_req) == FAIL) return RET_BUG;
  gtk_paned_compute_position(GTK_PANED(self->obj), allocation, child1_req, child2_req);
  return 0;
}

static NspMethods gtkpaned_methods[] = {
  {"add1",(nsp_method *) _wrap_gtk_paned_add1},
  {"add2",(nsp_method *) _wrap_gtk_paned_add2},
  {"pack1",(nsp_method *) _wrap_gtk_paned_pack1},
  {"pack2",(nsp_method *) _wrap_gtk_paned_pack2},
  {"get_position",(nsp_method *) _wrap_gtk_paned_get_position},
  {"set_position",(nsp_method *) _wrap_gtk_paned_set_position},
  {"compute_position",(nsp_method *) _wrap_gtk_paned_compute_position},
  { NULL, NULL}
};

static NspMethods *gtkpaned_get_methods(void) { return gtkpaned_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_paned__get_child1_resize(NspObject *self,char *attr)
{
  int ret;
  NspObject *nsp_ret;

  ret = (gboolean) GTK_PANED(NSP_GOBJECT_GET(self))->child1_resize;
  nsp_ret= (ret == TRUE) ? nsp_create_true_object(NVOID) : nsp_create_false_object(NVOID);
  return nsp_ret;
}

static NspObject *_wrap_gtk_paned__get_child2_resize(NspObject *self,char *attr)
{
  int ret;
  NspObject *nsp_ret;

  ret = (gboolean) GTK_PANED(NSP_GOBJECT_GET(self))->child2_resize;
  nsp_ret= (ret == TRUE) ? nsp_create_true_object(NVOID) : nsp_create_false_object(NVOID);
  return nsp_ret;
}

static NspObject *_wrap_gtk_paned__get_child1_shrink(NspObject *self,char *attr)
{
  int ret;
  NspObject *nsp_ret;

  ret = (gboolean) GTK_PANED(NSP_GOBJECT_GET(self))->child1_shrink;
  nsp_ret= (ret == TRUE) ? nsp_create_true_object(NVOID) : nsp_create_false_object(NVOID);
  return nsp_ret;
}

static NspObject *_wrap_gtk_paned__get_child2_shrink(NspObject *self,char *attr)
{
  int ret;
  NspObject *nsp_ret;

  ret = (gboolean) GTK_PANED(NSP_GOBJECT_GET(self))->child2_shrink;
  nsp_ret= (ret == TRUE) ? nsp_create_true_object(NVOID) : nsp_create_false_object(NVOID);
  return nsp_ret;
}

static AttrTab gtkpaned_attrs[] = {
  { "child1_resize", (attr_get_function *)_wrap_gtk_paned__get_child1_resize, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "child2_resize", (attr_get_function *)_wrap_gtk_paned__get_child2_resize, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "child1_shrink", (attr_get_function *)_wrap_gtk_paned__get_child1_shrink, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "child2_shrink", (attr_get_function *)_wrap_gtk_paned__get_child2_shrink, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkVPaned ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkVPaned_Private 
#include "nsp/gtk/gtkvpaned.h"
#include "nsp/interf.h"

/* NspGtkVPaned inherits from NspGtkPaned */ 

int nsp_type_gtkvpaned_id=0;
NspTypeGtkVPaned *nsp_type_gtkvpaned=NULL;

NspTypeGtkVPaned *new_type_gtkvpaned(type_mode mode)
{
  NspTypeGtkVPaned *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkvpaned != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkvpaned;
    }
  if ((type =  malloc(sizeof(NspTypeGtkPaned))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkpaned(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkvpaned_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkvpaned_get_methods; 
  type->new = (new_func *) new_gtkvpaned;

  /* specific methods for gtkvpaned */
      
  type->init = (init_func *) init_gtkvpaned;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkvpaned */ 

  top->s_type =  (s_type_func *) gtkvpaned_type_as_string;    
  top->sh_type = (sh_type_func *) gtkvpaned_type_short_string;
  /* top->create = (create_func*) int_gtkvpaned_create;*/ 
  
  /* specific methods for gtkvpaned */
      
  type->init = (init_func *) init_gtkvpaned;

  if ( nsp_type_gtkvpaned_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkVPaned called nsp_type_gtkvpaned
       */
      type->id =  nsp_type_gtkvpaned_id = nsp_new_type_id();
      nsp_type_gtkvpaned = type;
      if ( nsp_register_type(nsp_type_gtkvpaned) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkvpaned, GTK_TYPE_VPANED);
      return ( mode == T_BASE ) ? type : new_type_gtkvpaned(mode);
    }
  else 
    {
       type->id = nsp_type_gtkvpaned_id;
       return type;
    }
}

/*
 * initialize GtkVPaned instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkvpaned(NspGtkVPaned *o,NspTypeGtkVPaned *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkVPaned 
 */

NspGtkVPaned *new_gtkvpaned() 
{
  NspGtkVPaned *loc; 
  /* type must exists */
  nsp_type_gtkvpaned = new_type_gtkvpaned(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkVPaned)))== NULLGTKVPANED) return loc;
  /* initialize object */
  if ( init_gtkvpaned(loc,nsp_type_gtkvpaned) == FAIL) return NULLGTKVPANED;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkVPaned 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkvpaned_type_name[]="GtkVPaned";
static char gtkvpaned_short_type_name[]="GtkVPaned";

static char *gtkvpaned_type_as_string(void)
{
  return(gtkvpaned_type_name);
}

static char *gtkvpaned_type_short_string(void)
{
  return(gtkvpaned_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkVPaned objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkVPaned   *gtkvpaned_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkvpaned_id) ) return ((NspGtkVPaned *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkvpaned));
  return NULL;
}

int IsGtkVPanedObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkvpaned_id);
}

int IsGtkVPaned(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkvpaned_id);
}

NspGtkVPaned  *GetGtkVPanedCopy(Stack stack, int i)
{
  if (  GetGtkVPaned(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkVPaned  *GetGtkVPaned(Stack stack, int i)
{
  NspGtkVPaned *M;
  if (( M = gtkvpaned_object(NthObj(i))) == NULLGTKVPANED)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkVPaned *gtkvpaned_copy(NspGtkVPaned *self)
{
  /* return gtkpaned_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvpaned);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvpaned);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkVPaned
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkVPaned *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkvpaned is initialized * /
  nsp_type_gtkvpaned = new_type_gtkvpaned(T_BASE);
  if(( H = gtkpaned_create(NVOID,(NspTypeBase *) nsp_type_gtkvpaned)) == NULLGTKVPANED) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkvpaned_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_vpaned_new())== NULL) return RET_BUG;

  nsp_type_gtkvpaned = new_type_gtkvpaned(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkvpaned );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkvpaned_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkvpaned_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkHPaned ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkHPaned_Private 
#include "nsp/gtk/gtkhpaned.h"
#include "nsp/interf.h"

/* NspGtkHPaned inherits from NspGtkPaned */ 

int nsp_type_gtkhpaned_id=0;
NspTypeGtkHPaned *nsp_type_gtkhpaned=NULL;

NspTypeGtkHPaned *new_type_gtkhpaned(type_mode mode)
{
  NspTypeGtkHPaned *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkhpaned != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkhpaned;
    }
  if ((type =  malloc(sizeof(NspTypeGtkPaned))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkpaned(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkhpaned_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkhpaned_get_methods; 
  type->new = (new_func *) new_gtkhpaned;

  /* specific methods for gtkhpaned */
      
  type->init = (init_func *) init_gtkhpaned;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkhpaned */ 

  top->s_type =  (s_type_func *) gtkhpaned_type_as_string;    
  top->sh_type = (sh_type_func *) gtkhpaned_type_short_string;
  /* top->create = (create_func*) int_gtkhpaned_create;*/ 
  
  /* specific methods for gtkhpaned */
      
  type->init = (init_func *) init_gtkhpaned;

  if ( nsp_type_gtkhpaned_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkHPaned called nsp_type_gtkhpaned
       */
      type->id =  nsp_type_gtkhpaned_id = nsp_new_type_id();
      nsp_type_gtkhpaned = type;
      if ( nsp_register_type(nsp_type_gtkhpaned) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkhpaned, GTK_TYPE_HPANED);
      return ( mode == T_BASE ) ? type : new_type_gtkhpaned(mode);
    }
  else 
    {
       type->id = nsp_type_gtkhpaned_id;
       return type;
    }
}

/*
 * initialize GtkHPaned instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkhpaned(NspGtkHPaned *o,NspTypeGtkHPaned *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkHPaned 
 */

NspGtkHPaned *new_gtkhpaned() 
{
  NspGtkHPaned *loc; 
  /* type must exists */
  nsp_type_gtkhpaned = new_type_gtkhpaned(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkHPaned)))== NULLGTKHPANED) return loc;
  /* initialize object */
  if ( init_gtkhpaned(loc,nsp_type_gtkhpaned) == FAIL) return NULLGTKHPANED;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkHPaned 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkhpaned_type_name[]="GtkHPaned";
static char gtkhpaned_short_type_name[]="GtkHPaned";

static char *gtkhpaned_type_as_string(void)
{
  return(gtkhpaned_type_name);
}

static char *gtkhpaned_type_short_string(void)
{
  return(gtkhpaned_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkHPaned objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkHPaned   *gtkhpaned_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkhpaned_id) ) return ((NspGtkHPaned *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkhpaned));
  return NULL;
}

int IsGtkHPanedObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkhpaned_id);
}

int IsGtkHPaned(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkhpaned_id);
}

NspGtkHPaned  *GetGtkHPanedCopy(Stack stack, int i)
{
  if (  GetGtkHPaned(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkHPaned  *GetGtkHPaned(Stack stack, int i)
{
  NspGtkHPaned *M;
  if (( M = gtkhpaned_object(NthObj(i))) == NULLGTKHPANED)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkHPaned *gtkhpaned_copy(NspGtkHPaned *self)
{
  /* return gtkpaned_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhpaned);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhpaned);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkHPaned
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkHPaned *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkhpaned is initialized * /
  nsp_type_gtkhpaned = new_type_gtkhpaned(T_BASE);
  if(( H = gtkpaned_create(NVOID,(NspTypeBase *) nsp_type_gtkhpaned)) == NULLGTKHPANED) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkhpaned_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_hpaned_new())== NULL) return RET_BUG;

  nsp_type_gtkhpaned = new_type_gtkhpaned(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkhpaned );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkhpaned_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkhpaned_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkNotebook ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkNotebook_Private 
#include "nsp/gtk/gtknotebook.h"
#include "nsp/interf.h"

/* NspGtkNotebook inherits from NspGtkContainer */ 

int nsp_type_gtknotebook_id=0;
NspTypeGtkNotebook *nsp_type_gtknotebook=NULL;

NspTypeGtkNotebook *new_type_gtknotebook(type_mode mode)
{
  NspTypeGtkNotebook *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtknotebook != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtknotebook;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtknotebook_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtknotebook_get_methods; 
  type->new = (new_func *) new_gtknotebook;

  /* specific methods for gtknotebook */
      
  type->init = (init_func *) init_gtknotebook;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtknotebook */ 

  top->s_type =  (s_type_func *) gtknotebook_type_as_string;    
  top->sh_type = (sh_type_func *) gtknotebook_type_short_string;
  /* top->create = (create_func*) int_gtknotebook_create;*/ 
  
  /* specific methods for gtknotebook */
      
  type->init = (init_func *) init_gtknotebook;

  if ( nsp_type_gtknotebook_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkNotebook called nsp_type_gtknotebook
       */
      type->id =  nsp_type_gtknotebook_id = nsp_new_type_id();
      nsp_type_gtknotebook = type;
      if ( nsp_register_type(nsp_type_gtknotebook) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtknotebook, GTK_TYPE_NOTEBOOK);
      return ( mode == T_BASE ) ? type : new_type_gtknotebook(mode);
    }
  else 
    {
       type->id = nsp_type_gtknotebook_id;
       return type;
    }
}

/*
 * initialize GtkNotebook instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtknotebook(NspGtkNotebook *o,NspTypeGtkNotebook *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkNotebook 
 */

NspGtkNotebook *new_gtknotebook() 
{
  NspGtkNotebook *loc; 
  /* type must exists */
  nsp_type_gtknotebook = new_type_gtknotebook(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkNotebook)))== NULLGTKNOTEBOOK) return loc;
  /* initialize object */
  if ( init_gtknotebook(loc,nsp_type_gtknotebook) == FAIL) return NULLGTKNOTEBOOK;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkNotebook 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtknotebook_type_name[]="GtkNotebook";
static char gtknotebook_short_type_name[]="GtkNotebook";

static char *gtknotebook_type_as_string(void)
{
  return(gtknotebook_type_name);
}

static char *gtknotebook_type_short_string(void)
{
  return(gtknotebook_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkNotebook objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkNotebook   *gtknotebook_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtknotebook_id) ) return ((NspGtkNotebook *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtknotebook));
  return NULL;
}

int IsGtkNotebookObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtknotebook_id);
}

int IsGtkNotebook(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtknotebook_id);
}

NspGtkNotebook  *GetGtkNotebookCopy(Stack stack, int i)
{
  if (  GetGtkNotebook(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkNotebook  *GetGtkNotebook(Stack stack, int i)
{
  NspGtkNotebook *M;
  if (( M = gtknotebook_object(NthObj(i))) == NULLGTKNOTEBOOK)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkNotebook *gtknotebook_copy(NspGtkNotebook *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtknotebook);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtknotebook);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkNotebook
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkNotebook *H;
  CheckRhs(0,0);
  / * want to be sure that type gtknotebook is initialized * /
  nsp_type_gtknotebook = new_type_gtknotebook(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtknotebook)) == NULLGTKNOTEBOOK) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtknotebook_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_notebook_new())== NULL) return RET_BUG;

  nsp_type_gtknotebook = new_type_gtknotebook(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtknotebook );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_notebook_append_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check,t_end};
  NspGObject *child, *tab_label;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label) == FAIL) return RET_BUG;
  gtk_notebook_append_page(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), GTK_WIDGET(tab_label->obj));
  return 0;
}

static int _wrap_gtk_notebook_append_page_menu(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check, obj_check,t_end};
  NspGObject *child, *tab_label, *menu_label;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label, &nsp_type_gtkwidget, &menu_label) == FAIL) return RET_BUG;
  gtk_notebook_append_page_menu(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), GTK_WIDGET(tab_label->obj), GTK_WIDGET(menu_label->obj));
  return 0;
}

static int _wrap_gtk_notebook_prepend_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check,t_end};
  NspGObject *child, *tab_label;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label) == FAIL) return RET_BUG;
  gtk_notebook_prepend_page(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), GTK_WIDGET(tab_label->obj));
  return 0;
}

static int _wrap_gtk_notebook_prepend_page_menu(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check, obj_check,t_end};
  NspGObject *child, *tab_label, *menu_label;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label, &nsp_type_gtkwidget, &menu_label) == FAIL) return RET_BUG;
  gtk_notebook_prepend_page_menu(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), GTK_WIDGET(tab_label->obj), GTK_WIDGET(menu_label->obj));
  return 0;
}

static int _wrap_gtk_notebook_insert_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check, s_int,t_end};
  int position;
  NspGObject *child, *tab_label;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label, &position) == FAIL) return RET_BUG;
  gtk_notebook_insert_page(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), GTK_WIDGET(tab_label->obj), position);
  return 0;
}

static int _wrap_gtk_notebook_insert_page_menu(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check, obj_check, s_int,t_end};
  int position;
  NspGObject *child, *tab_label, *menu_label;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label, &nsp_type_gtkwidget, &menu_label, &position) == FAIL) return RET_BUG;
  gtk_notebook_insert_page_menu(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), GTK_WIDGET(tab_label->obj), GTK_WIDGET(menu_label->obj), position);
  return 0;
}

static int _wrap_gtk_notebook_remove_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int page_num;

  if ( GetArgs(stack,rhs,opt,T,&page_num) == FAIL) return RET_BUG;
  gtk_notebook_remove_page(GTK_NOTEBOOK(self->obj), page_num);
  return 0;
}

static int _wrap_gtk_notebook_get_current_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_notebook_get_current_page(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_get_nth_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int page_num;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&page_num) == FAIL) return RET_BUG;
  ret = gtk_notebook_get_nth_page(GTK_NOTEBOOK(self->obj), page_num);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_notebook_page_num(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  int ret;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
  ret = gtk_notebook_page_num(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_set_current_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int page_num;

  if ( GetArgs(stack,rhs,opt,T,&page_num) == FAIL) return RET_BUG;
  gtk_notebook_set_current_page(GTK_NOTEBOOK(self->obj), page_num);
  return 0;
}

static int _wrap_gtk_notebook_next_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_notebook_next_page(GTK_NOTEBOOK(self->obj));
  return 0;
}

static int _wrap_gtk_notebook_prev_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_notebook_prev_page(GTK_NOTEBOOK(self->obj));
  return 0;
}

static int _wrap_gtk_notebook_set_show_border(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int show_border;

  if ( GetArgs(stack,rhs,opt,T,&show_border) == FAIL) return RET_BUG;
  gtk_notebook_set_show_border(GTK_NOTEBOOK(self->obj), show_border);
  return 0;
}

static int _wrap_gtk_notebook_get_show_border(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_notebook_get_show_border(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_set_show_tabs(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int show_tabs;

  if ( GetArgs(stack,rhs,opt,T,&show_tabs) == FAIL) return RET_BUG;
  gtk_notebook_set_show_tabs(GTK_NOTEBOOK(self->obj), show_tabs);
  return 0;
}

static int _wrap_gtk_notebook_get_show_tabs(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_notebook_get_show_tabs(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_set_tab_pos(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_pos = NULL;
  GtkPositionType pos;

  if ( GetArgs(stack,rhs,opt,T,&nsp_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_pos, &pos)== FAIL)
      return RET_BUG;
  gtk_notebook_set_tab_pos(GTK_NOTEBOOK(self->obj), pos);
  return 0;
}

static int _wrap_gtk_notebook_get_tab_pos(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_notebook_get_tab_pos(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_set_homogeneous_tabs(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int homogeneous;

  if ( GetArgs(stack,rhs,opt,T,&homogeneous) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_notebook_set_homogeneous_tabs(GTK_NOTEBOOK(self->obj), homogeneous);
  return 0;
}

static int _wrap_gtk_notebook_set_tab_border(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int border_width;

  if ( GetArgs(stack,rhs,opt,T,&border_width) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_notebook_set_tab_border(GTK_NOTEBOOK(self->obj), border_width);
  return 0;
}

static int _wrap_gtk_notebook_set_tab_hborder(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int tab_hborder;

  if ( GetArgs(stack,rhs,opt,T,&tab_hborder) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_notebook_set_tab_hborder(GTK_NOTEBOOK(self->obj), tab_hborder);
  return 0;
}

static int _wrap_gtk_notebook_set_tab_vborder(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int tab_vborder;

  if ( GetArgs(stack,rhs,opt,T,&tab_vborder) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_notebook_set_tab_vborder(GTK_NOTEBOOK(self->obj), tab_vborder);
  return 0;
}

static int _wrap_gtk_notebook_set_scrollable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int scrollable;

  if ( GetArgs(stack,rhs,opt,T,&scrollable) == FAIL) return RET_BUG;
  gtk_notebook_set_scrollable(GTK_NOTEBOOK(self->obj), scrollable);
  return 0;
}

static int _wrap_gtk_notebook_get_scrollable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_notebook_get_scrollable(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_popup_enable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_notebook_popup_enable(GTK_NOTEBOOK(self->obj));
  return 0;
}

static int _wrap_gtk_notebook_popup_disable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_notebook_popup_disable(GTK_NOTEBOOK(self->obj));
  return 0;
}

static int _wrap_gtk_notebook_get_tab_label(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *child;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
  ret = gtk_notebook_get_tab_label(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_notebook_set_tab_label(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check,t_end};
  NspGObject *child, *tab_label;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label) == FAIL) return RET_BUG;
  gtk_notebook_set_tab_label(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), GTK_WIDGET(tab_label->obj));
  return 0;
}

static int _wrap_gtk_notebook_set_tab_label_text(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, string,t_end};
  char *tab_text;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &tab_text) == FAIL) return RET_BUG;
  gtk_notebook_set_tab_label_text(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), tab_text);
  return 0;
}

static int _wrap_gtk_notebook_get_tab_label_text(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *child;
  const gchar *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
  ret = gtk_notebook_get_tab_label_text(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_get_menu_label(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *child;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
  ret = gtk_notebook_get_menu_label(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_notebook_set_menu_label(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, obj_check,t_end};
  NspGObject *child, *menu_label;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &menu_label) == FAIL) return RET_BUG;
  gtk_notebook_set_menu_label(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), GTK_WIDGET(menu_label->obj));
  return 0;
}

static int _wrap_gtk_notebook_set_menu_label_text(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, string,t_end};
  char *menu_text;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &menu_text) == FAIL) return RET_BUG;
  gtk_notebook_set_menu_label_text(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), menu_text);
  return 0;
}

static int _wrap_gtk_notebook_get_menu_label_text(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *child;
  const gchar *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
  ret = gtk_notebook_get_menu_label_text(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#line 4860 "gtk.override"
static int
_wrap_gtk_notebook_query_tab_label_packing(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end} ;
  /* static char *kwlist[] = { "child", NULL };*/
  NspGObject *child;
  gboolean expand, fill;
  GtkPackType pack_type;
  
  if (GetArgs(stack,rhs,opt,T, &nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;;
  gtk_notebook_query_tab_label_packing(GTK_NOTEBOOK(self->obj),
				       GTK_WIDGET(child->obj),
				       &expand, &fill, &pack_type);
  if ( nsp_move_doubles(stack,1,1,3,(double) expand,(double) fill, (double) pack_type) == FAIL) return RET_BUG; 
  return 1;
}
#line 33515 "gtk.c"


static int _wrap_gtk_notebook_set_tab_label_packing(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_bool, s_bool, obj,t_end};
  int expand, fill;
  NspGObject *child;
  GtkPackType pack_type;
  NspObject *nsp_pack_type = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &expand, &fill, &nsp_pack_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_PACK_TYPE, nsp_pack_type, &pack_type)== FAIL)
      return RET_BUG;
  gtk_notebook_set_tab_label_packing(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), expand, fill, pack_type);
  return 0;
}

static int _wrap_gtk_notebook_reorder_child(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int,t_end};
  int position;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &position) == FAIL) return RET_BUG;
  gtk_notebook_reorder_child(GTK_NOTEBOOK(self->obj), GTK_WIDGET(child->obj), position);
  return 0;
}

static int _wrap_gtk_notebook_current_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  Scierror("%s: deprecated use GtkNotebook.get_current_page",stack.fname); return RET_BUG;
  ret = gtk_notebook_current_page(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_set_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int page_num;

  if ( GetArgs(stack,rhs,opt,T,&page_num) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkNotebook.set_current_page",stack.fname); return RET_BUG;
  gtk_notebook_set_page(GTK_NOTEBOOK(self->obj), page_num);
  return 0;
}

static NspMethods gtknotebook_methods[] = {
  {"append_page",(nsp_method *) _wrap_gtk_notebook_append_page},
  {"append_page_menu",(nsp_method *) _wrap_gtk_notebook_append_page_menu},
  {"prepend_page",(nsp_method *) _wrap_gtk_notebook_prepend_page},
  {"prepend_page_menu",(nsp_method *) _wrap_gtk_notebook_prepend_page_menu},
  {"insert_page",(nsp_method *) _wrap_gtk_notebook_insert_page},
  {"insert_page_menu",(nsp_method *) _wrap_gtk_notebook_insert_page_menu},
  {"remove_page",(nsp_method *) _wrap_gtk_notebook_remove_page},
  {"get_current_page",(nsp_method *) _wrap_gtk_notebook_get_current_page},
  {"get_nth_page",(nsp_method *) _wrap_gtk_notebook_get_nth_page},
  {"page_num",(nsp_method *) _wrap_gtk_notebook_page_num},
  {"set_current_page",(nsp_method *) _wrap_gtk_notebook_set_current_page},
  {"next_page",(nsp_method *) _wrap_gtk_notebook_next_page},
  {"prev_page",(nsp_method *) _wrap_gtk_notebook_prev_page},
  {"set_show_border",(nsp_method *) _wrap_gtk_notebook_set_show_border},
  {"get_show_border",(nsp_method *) _wrap_gtk_notebook_get_show_border},
  {"set_show_tabs",(nsp_method *) _wrap_gtk_notebook_set_show_tabs},
  {"get_show_tabs",(nsp_method *) _wrap_gtk_notebook_get_show_tabs},
  {"set_tab_pos",(nsp_method *) _wrap_gtk_notebook_set_tab_pos},
  {"get_tab_pos",(nsp_method *) _wrap_gtk_notebook_get_tab_pos},
  {"set_homogeneous_tabs",(nsp_method *) _wrap_gtk_notebook_set_homogeneous_tabs},
  {"set_tab_border",(nsp_method *) _wrap_gtk_notebook_set_tab_border},
  {"set_tab_hborder",(nsp_method *) _wrap_gtk_notebook_set_tab_hborder},
  {"set_tab_vborder",(nsp_method *) _wrap_gtk_notebook_set_tab_vborder},
  {"set_scrollable",(nsp_method *) _wrap_gtk_notebook_set_scrollable},
  {"get_scrollable",(nsp_method *) _wrap_gtk_notebook_get_scrollable},
  {"popup_enable",(nsp_method *) _wrap_gtk_notebook_popup_enable},
  {"popup_disable",(nsp_method *) _wrap_gtk_notebook_popup_disable},
  {"get_tab_label",(nsp_method *) _wrap_gtk_notebook_get_tab_label},
  {"set_tab_label",(nsp_method *) _wrap_gtk_notebook_set_tab_label},
  {"set_tab_label_text",(nsp_method *) _wrap_gtk_notebook_set_tab_label_text},
  {"get_tab_label_text",(nsp_method *) _wrap_gtk_notebook_get_tab_label_text},
  {"get_menu_label",(nsp_method *) _wrap_gtk_notebook_get_menu_label},
  {"set_menu_label",(nsp_method *) _wrap_gtk_notebook_set_menu_label},
  {"set_menu_label_text",(nsp_method *) _wrap_gtk_notebook_set_menu_label_text},
  {"get_menu_label_text",(nsp_method *) _wrap_gtk_notebook_get_menu_label_text},
  {"query_tab_label_packing",(nsp_method *) _wrap_gtk_notebook_query_tab_label_packing},
  {"set_tab_label_packing",(nsp_method *) _wrap_gtk_notebook_set_tab_label_packing},
  {"reorder_child",(nsp_method *) _wrap_gtk_notebook_reorder_child},
  {"current_page",(nsp_method *) _wrap_gtk_notebook_current_page},
  {"set_page",(nsp_method *) _wrap_gtk_notebook_set_page},
  { NULL, NULL}
};

static NspMethods *gtknotebook_get_methods(void) { return gtknotebook_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_notebook__get_tab_pos(NspObject *self,char *attr)
{
  gint ret;

  ret = (GtkPositionType) GTK_NOTEBOOK(NSP_GOBJECT_GET(self))->tab_pos;
  return nsp_new_double_obj((double) ret);
}

static AttrTab gtknotebook_attrs[] = {
  { "tab_pos", (attr_get_function *)_wrap_gtk_notebook__get_tab_pos, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkMenuShell ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkMenuShell_Private 
#include "nsp/gtk/gtkmenushell.h"
#include "nsp/interf.h"

/* NspGtkMenuShell inherits from NspGtkContainer */ 

int nsp_type_gtkmenushell_id=0;
NspTypeGtkMenuShell *nsp_type_gtkmenushell=NULL;

NspTypeGtkMenuShell *new_type_gtkmenushell(type_mode mode)
{
  NspTypeGtkMenuShell *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmenushell != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmenushell;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmenushell_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkmenushell_get_methods; 
  type->new = (new_func *) new_gtkmenushell;

  /* specific methods for gtkmenushell */
      
  type->init = (init_func *) init_gtkmenushell;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkmenushell */ 

  top->s_type =  (s_type_func *) gtkmenushell_type_as_string;    
  top->sh_type = (sh_type_func *) gtkmenushell_type_short_string;
  /* top->create = (create_func*) int_gtkmenushell_create;*/ 
  
  /* specific methods for gtkmenushell */
      
  type->init = (init_func *) init_gtkmenushell;

  if ( nsp_type_gtkmenushell_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMenuShell called nsp_type_gtkmenushell
       */
      type->id =  nsp_type_gtkmenushell_id = nsp_new_type_id();
      nsp_type_gtkmenushell = type;
      if ( nsp_register_type(nsp_type_gtkmenushell) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmenushell, GTK_TYPE_MENU_SHELL);
      return ( mode == T_BASE ) ? type : new_type_gtkmenushell(mode);
    }
  else 
    {
       type->id = nsp_type_gtkmenushell_id;
       return type;
    }
}

/*
 * initialize GtkMenuShell instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmenushell(NspGtkMenuShell *o,NspTypeGtkMenuShell *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkMenuShell 
 */

NspGtkMenuShell *new_gtkmenushell() 
{
  NspGtkMenuShell *loc; 
  /* type must exists */
  nsp_type_gtkmenushell = new_type_gtkmenushell(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMenuShell)))== NULLGTKMENUSHELL) return loc;
  /* initialize object */
  if ( init_gtkmenushell(loc,nsp_type_gtkmenushell) == FAIL) return NULLGTKMENUSHELL;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkMenuShell 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkmenushell_type_name[]="GtkMenuShell";
static char gtkmenushell_short_type_name[]="GtkMenuShell";

static char *gtkmenushell_type_as_string(void)
{
  return(gtkmenushell_type_name);
}

static char *gtkmenushell_type_short_string(void)
{
  return(gtkmenushell_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkMenuShell objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkMenuShell   *gtkmenushell_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkmenushell_id) ) return ((NspGtkMenuShell *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmenushell));
  return NULL;
}

int IsGtkMenuShellObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkmenushell_id);
}

int IsGtkMenuShell(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmenushell_id);
}

NspGtkMenuShell  *GetGtkMenuShellCopy(Stack stack, int i)
{
  if (  GetGtkMenuShell(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMenuShell  *GetGtkMenuShell(Stack stack, int i)
{
  NspGtkMenuShell *M;
  if (( M = gtkmenushell_object(NthObj(i))) == NULLGTKMENUSHELL)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMenuShell *gtkmenushell_copy(NspGtkMenuShell *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenushell);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenushell);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMenuShell
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkMenuShell *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkmenushell is initialized * /
  nsp_type_gtkmenushell = new_type_gtkmenushell(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtkmenushell)) == NULLGTKMENUSHELL) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_menu_shell_append(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
  gtk_menu_shell_append(GTK_MENU_SHELL(self->obj), GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_menu_shell_prepend(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
  gtk_menu_shell_prepend(GTK_MENU_SHELL(self->obj), GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_menu_shell_insert(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int,t_end};
  int position;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &position) == FAIL) return RET_BUG;
  gtk_menu_shell_insert(GTK_MENU_SHELL(self->obj), GTK_WIDGET(child->obj), position);
  return 0;
}

static int _wrap_gtk_menu_shell_deactivate(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_menu_shell_deactivate(GTK_MENU_SHELL(self->obj));
  return 0;
}

static int _wrap_gtk_menu_shell_select_item(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *menu_item;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &menu_item) == FAIL) return RET_BUG;
  gtk_menu_shell_select_item(GTK_MENU_SHELL(self->obj), GTK_WIDGET(menu_item->obj));
  return 0;
}

static int _wrap_gtk_menu_shell_deselect(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_menu_shell_deselect(GTK_MENU_SHELL(self->obj));
  return 0;
}

static int _wrap_gtk_menu_shell_activate_item(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_bool,t_end};
  int force_deactivate;
  NspGObject *menu_item;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &menu_item, &force_deactivate) == FAIL) return RET_BUG;
  gtk_menu_shell_activate_item(GTK_MENU_SHELL(self->obj), GTK_WIDGET(menu_item->obj), force_deactivate);
  return 0;
}

static NspMethods gtkmenushell_methods[] = {
  {"append",(nsp_method *) _wrap_gtk_menu_shell_append},
  {"prepend",(nsp_method *) _wrap_gtk_menu_shell_prepend},
  {"insert",(nsp_method *) _wrap_gtk_menu_shell_insert},
  {"deactivate",(nsp_method *) _wrap_gtk_menu_shell_deactivate},
  {"select_item",(nsp_method *) _wrap_gtk_menu_shell_select_item},
  {"deselect",(nsp_method *) _wrap_gtk_menu_shell_deselect},
  {"activate_item",(nsp_method *) _wrap_gtk_menu_shell_activate_item},
  { NULL, NULL}
};

static NspMethods *gtkmenushell_get_methods(void) { return gtkmenushell_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmenushell_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkMenu ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkMenu_Private 
#include "nsp/gtk/gtkmenu.h"
#include "nsp/interf.h"

/* NspGtkMenu inherits from NspGtkMenuShell */ 

int nsp_type_gtkmenu_id=0;
NspTypeGtkMenu *nsp_type_gtkmenu=NULL;

NspTypeGtkMenu *new_type_gtkmenu(type_mode mode)
{
  NspTypeGtkMenu *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmenu != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmenu;
    }
  if ((type =  malloc(sizeof(NspTypeGtkMenuShell))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmenushell(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmenu_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkmenu_get_methods; 
  type->new = (new_func *) new_gtkmenu;

  /* specific methods for gtkmenu */
      
  type->init = (init_func *) init_gtkmenu;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkmenu */ 

  top->s_type =  (s_type_func *) gtkmenu_type_as_string;    
  top->sh_type = (sh_type_func *) gtkmenu_type_short_string;
  /* top->create = (create_func*) int_gtkmenu_create;*/ 
  
  /* specific methods for gtkmenu */
      
  type->init = (init_func *) init_gtkmenu;

  if ( nsp_type_gtkmenu_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMenu called nsp_type_gtkmenu
       */
      type->id =  nsp_type_gtkmenu_id = nsp_new_type_id();
      nsp_type_gtkmenu = type;
      if ( nsp_register_type(nsp_type_gtkmenu) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmenu, GTK_TYPE_MENU);
      return ( mode == T_BASE ) ? type : new_type_gtkmenu(mode);
    }
  else 
    {
       type->id = nsp_type_gtkmenu_id;
       return type;
    }
}

/*
 * initialize GtkMenu instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmenu(NspGtkMenu *o,NspTypeGtkMenu *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkMenu 
 */

NspGtkMenu *new_gtkmenu() 
{
  NspGtkMenu *loc; 
  /* type must exists */
  nsp_type_gtkmenu = new_type_gtkmenu(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMenu)))== NULLGTKMENU) return loc;
  /* initialize object */
  if ( init_gtkmenu(loc,nsp_type_gtkmenu) == FAIL) return NULLGTKMENU;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkMenu 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkmenu_type_name[]="GtkMenu";
static char gtkmenu_short_type_name[]="GtkMenu";

static char *gtkmenu_type_as_string(void)
{
  return(gtkmenu_type_name);
}

static char *gtkmenu_type_short_string(void)
{
  return(gtkmenu_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkMenu objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkMenu   *gtkmenu_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkmenu_id) ) return ((NspGtkMenu *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmenu));
  return NULL;
}

int IsGtkMenuObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkmenu_id);
}

int IsGtkMenu(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmenu_id);
}

NspGtkMenu  *GetGtkMenuCopy(Stack stack, int i)
{
  if (  GetGtkMenu(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMenu  *GetGtkMenu(Stack stack, int i)
{
  NspGtkMenu *M;
  if (( M = gtkmenu_object(NthObj(i))) == NULLGTKMENU)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMenu *gtkmenu_copy(NspGtkMenu *self)
{
  /* return gtkmenushell_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenu);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenu);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMenu
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkMenu *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkmenu is initialized * /
  nsp_type_gtkmenu = new_type_gtkmenu(T_BASE);
  if(( H = gtkmenushell_create(NVOID,(NspTypeBase *) nsp_type_gtkmenu)) == NULLGTKMENU) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkmenu_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_menu_new())== NULL) return RET_BUG;

  nsp_type_gtkmenu = new_type_gtkmenu(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkmenu );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 3892 "gtk.override"
static void
nspgtk_menu_position(GtkMenu *menu, int *x, int *y, gboolean *push_in,
		     NspObject *func)
{
  NspObject *args[1];
  NspObject *nsp_ret[3];
  int nret = 3,nargs = 2;
  nspg_block_threads();
  args[0] = (NspObject *) gobject_gettype_and_create("menu",(GObject *)menu);
  if (args[0] == NULL) return ;
  if ( nsp_gtk_eval_function((NspPList *)func ,args,nargs,nsp_ret,&nret)== FAIL) 
    goto end ;
  if (nret != 3 ) 
    {
      Scierror("expecting three returned values\n"); 
      goto end;
    }
  else 
    {
      int_types T[]={ s_int,s_int,s_bool,t_end};
      if ( GetFromTable(nsp_ret,T,x,y,push_in) == FAIL) 
	{
	  Scierror("returned values are incorect \n"); 
	  goto end;
	}
    }
 end: 
  {
    nspg_unblock_threads();
    return;
  }
}

static int
_wrap_gtk_menu_popup(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  nsp_option opts[] = {
    {"parent_menu_shell",obj_check,NULLOBJ,-1}, 
    {"parent_menu_item",obj_check,NULLOBJ,-1}, 
    {"func",obj_check,NULLOBJ,-1}, 
    {"button",s_int,NULLOBJ,-1}, 
    {"activate_time",s_int,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };
  int_types T[] = {new_opts, t_end} ;
  /* "parent_menu_shell", "parent_menu_item", "func", "button", "activate_time",  */
  NspGObject *nsp_pms = NULL, *nsp_pmi=NULL;
  GtkWidget *pms = NULL, *pmi = NULL;
  NspObject *func=NULL;
  int button=0, time=-1;
  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type_gtkwidget, &nsp_pms,
	      &nsp_type_gtkwidget,&nsp_pmi,
	      &nsp_type_plist,&func,&button, &time)== FAIL) return RET_BUG;
  if ( nsp_pms != NULL) pms = GTK_WIDGET(nsp_pms->obj);
  if ( nsp_pmi != NULL) pmi = GTK_WIDGET(nsp_pmi->obj);
  if ( func != NULL ) {
    if (( func = (NspObject *)nsp_object_copy(func)) == NULL ) return RET_BUG;
    if ((nsp_object_set_name(func,"f")== FAIL)) return RET_BUG;
    gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
		   (GtkMenuPositionFunc)nspgtk_menu_position,
		   func, button, time);
  } else
    gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);
  return 0;
}
#line 34177 "gtk.c"


static int _wrap_gtk_menu_reposition(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_menu_reposition(GTK_MENU(self->obj));
  return 0;
}

static int _wrap_gtk_menu_popdown(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_menu_popdown(GTK_MENU(self->obj));
  return 0;
}

static int _wrap_gtk_menu_get_active(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

  ret = gtk_menu_get_active(GTK_MENU(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_menu_set_active(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int index;

  if ( GetArgs(stack,rhs,opt,T,&index) == FAIL) return RET_BUG;
  gtk_menu_set_active(GTK_MENU(self->obj), index);
  return 0;
}

static int _wrap_gtk_menu_set_accel_group(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *accel_group;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaccelgroup, &accel_group) == FAIL) return RET_BUG;
  gtk_menu_set_accel_group(GTK_MENU(self->obj), GTK_ACCEL_GROUP(accel_group->obj));
  return 0;
}

static int _wrap_gtk_menu_get_accel_group(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAccelGroup *ret;

  ret = gtk_menu_get_accel_group(GTK_MENU(self->obj));
  nsp_type_gtkaccelgroup = new_type_gtkaccelgroup(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkaccelgroup))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_menu_set_accel_path(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *accel_path;

  if ( GetArgs(stack,rhs,opt,T,&accel_path) == FAIL) return RET_BUG;
  gtk_menu_set_accel_path(GTK_MENU(self->obj), accel_path);
  return 0;
}

#line 4382 "gtk.override"

static void
nspgtk_menu_detach (GtkWidget *attach_widget, GtkMenu *menu)
{
  NspObject *func;
  NspObject *args[2];
  int nret = 1,nargs = 2;
  /* gboolean ret = FALSE;*/
  NspObject *nsp_ret;

  if (( func = g_object_get_data (G_OBJECT (menu), "nspgtk_menu_detach_func"))== NULL) return 
											 
  nspg_block_threads();

  args[0] = (NspObject *) gobject_create("menu",(GObject *)menu,(NspTypeBase *) nsp_type_gtkmenu );
  args[1] = (NspObject *) gobject_create("attach",(GObject *)attach_widget,(NspTypeBase *) nsp_type_gtkwidget );
  if ( args[0]== NULL ||args[1]== NULL ) goto end;
  if ( nsp_gtk_eval_function((NspPList *) func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end;
  /* returned value is unused 
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  */
  goto end; 
 end:
  {
    nspg_unblock_threads();
  }
}

static int
_wrap_gtk_menu_attach_to_widget (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /*  */
  int_types T[] = {obj_check, new_opts , t_end} ;
  nsp_option opts[] = {
    {"detach",obj_check,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };

  NspObject *nsp_attach_widget;
  NspPList *detach_func;
  GtkWidget *attach_widget;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &nsp_attach_widget,&opts,&nsp_type_plist,&detach_func) == FAIL)
    return RET_BUG;
  
  attach_widget = GTK_WIDGET (((NspGObject *) nsp_attach_widget)->obj);
  
  if ( detach_func != NULL) 
    {
      if (( detach_func =(NspPList *)nsp_object_copy((NspObject *) detach_func)) == NULLP_PLIST) return RET_BUG;
      if ((nsp_object_set_name((NspObject *)detach_func ,"detach")== FAIL)) return RET_BUG;
      g_object_set_data_full (self->obj,
			      "nspgtk_menu_detach_func",
			      detach_func,
			      nspg_destroy_notify);
    }
  else
    g_object_set_data (self->obj, "nspgtk_menu_detach_func", NULL);

  gtk_menu_attach_to_widget (GTK_MENU (self->obj), attach_widget,
			     (GtkMenuDetachFunc) nspgtk_menu_detach);
  return 0;
}
#line 34311 "gtk.c"


static int _wrap_gtk_menu_detach(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_menu_detach(GTK_MENU(self->obj));
  return 0;
}

static int _wrap_gtk_menu_get_attach_widget(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

  ret = gtk_menu_get_attach_widget(GTK_MENU(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_menu_set_tearoff_state(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int torn_off;

  if ( GetArgs(stack,rhs,opt,T,&torn_off) == FAIL) return RET_BUG;
  gtk_menu_set_tearoff_state(GTK_MENU(self->obj), torn_off);
  return 0;
}

static int _wrap_gtk_menu_get_tearoff_state(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_menu_get_tearoff_state(GTK_MENU(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_menu_set_title(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *title;

  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
  gtk_menu_set_title(GTK_MENU(self->obj), title);
  return 0;
}

static int _wrap_gtk_menu_get_title(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_menu_get_title(GTK_MENU(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_menu_reorder_child(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int,t_end};
  int position;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &position) == FAIL) return RET_BUG;
  gtk_menu_reorder_child(GTK_MENU(self->obj), GTK_WIDGET(child->obj), position);
  return 0;
}

static NspMethods gtkmenu_methods[] = {
  {"popup",(nsp_method *) _wrap_gtk_menu_popup},
  {"reposition",(nsp_method *) _wrap_gtk_menu_reposition},
  {"popdown",(nsp_method *) _wrap_gtk_menu_popdown},
  {"get_active",(nsp_method *) _wrap_gtk_menu_get_active},
  {"set_active",(nsp_method *) _wrap_gtk_menu_set_active},
  {"set_accel_group",(nsp_method *) _wrap_gtk_menu_set_accel_group},
  {"get_accel_group",(nsp_method *) _wrap_gtk_menu_get_accel_group},
  {"set_accel_path",(nsp_method *) _wrap_gtk_menu_set_accel_path},
  {"attach_to_widget",(nsp_method *) _wrap_gtk_menu_attach_to_widget},
  {"detach",(nsp_method *) _wrap_gtk_menu_detach},
  {"get_attach_widget",(nsp_method *) _wrap_gtk_menu_get_attach_widget},
  {"set_tearoff_state",(nsp_method *) _wrap_gtk_menu_set_tearoff_state},
  {"get_tearoff_state",(nsp_method *) _wrap_gtk_menu_get_tearoff_state},
  {"set_title",(nsp_method *) _wrap_gtk_menu_set_title},
  {"get_title",(nsp_method *) _wrap_gtk_menu_get_title},
  {"reorder_child",(nsp_method *) _wrap_gtk_menu_reorder_child},
  { NULL, NULL}
};

static NspMethods *gtkmenu_get_methods(void) { return gtkmenu_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmenu_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkMenuBar ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkMenuBar_Private 
#include "nsp/gtk/gtkmenubar.h"
#include "nsp/interf.h"

/* NspGtkMenuBar inherits from NspGtkMenuShell */ 

int nsp_type_gtkmenubar_id=0;
NspTypeGtkMenuBar *nsp_type_gtkmenubar=NULL;

NspTypeGtkMenuBar *new_type_gtkmenubar(type_mode mode)
{
  NspTypeGtkMenuBar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmenubar != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmenubar;
    }
  if ((type =  malloc(sizeof(NspTypeGtkMenuShell))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmenushell(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmenubar_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkmenubar_get_methods; 
  type->new = (new_func *) new_gtkmenubar;

  /* specific methods for gtkmenubar */
      
  type->init = (init_func *) init_gtkmenubar;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkmenubar */ 

  top->s_type =  (s_type_func *) gtkmenubar_type_as_string;    
  top->sh_type = (sh_type_func *) gtkmenubar_type_short_string;
  /* top->create = (create_func*) int_gtkmenubar_create;*/ 
  
  /* specific methods for gtkmenubar */
      
  type->init = (init_func *) init_gtkmenubar;

  if ( nsp_type_gtkmenubar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMenuBar called nsp_type_gtkmenubar
       */
      type->id =  nsp_type_gtkmenubar_id = nsp_new_type_id();
      nsp_type_gtkmenubar = type;
      if ( nsp_register_type(nsp_type_gtkmenubar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmenubar, GTK_TYPE_MENU_BAR);
      return ( mode == T_BASE ) ? type : new_type_gtkmenubar(mode);
    }
  else 
    {
       type->id = nsp_type_gtkmenubar_id;
       return type;
    }
}

/*
 * initialize GtkMenuBar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmenubar(NspGtkMenuBar *o,NspTypeGtkMenuBar *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkMenuBar 
 */

NspGtkMenuBar *new_gtkmenubar() 
{
  NspGtkMenuBar *loc; 
  /* type must exists */
  nsp_type_gtkmenubar = new_type_gtkmenubar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMenuBar)))== NULLGTKMENUBAR) return loc;
  /* initialize object */
  if ( init_gtkmenubar(loc,nsp_type_gtkmenubar) == FAIL) return NULLGTKMENUBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkMenuBar 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkmenubar_type_name[]="GtkMenuBar";
static char gtkmenubar_short_type_name[]="GtkMenuBar";

static char *gtkmenubar_type_as_string(void)
{
  return(gtkmenubar_type_name);
}

static char *gtkmenubar_type_short_string(void)
{
  return(gtkmenubar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkMenuBar objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkMenuBar   *gtkmenubar_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkmenubar_id) ) return ((NspGtkMenuBar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmenubar));
  return NULL;
}

int IsGtkMenuBarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkmenubar_id);
}

int IsGtkMenuBar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmenubar_id);
}

NspGtkMenuBar  *GetGtkMenuBarCopy(Stack stack, int i)
{
  if (  GetGtkMenuBar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMenuBar  *GetGtkMenuBar(Stack stack, int i)
{
  NspGtkMenuBar *M;
  if (( M = gtkmenubar_object(NthObj(i))) == NULLGTKMENUBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMenuBar *gtkmenubar_copy(NspGtkMenuBar *self)
{
  /* return gtkmenushell_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenubar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenubar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMenuBar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkMenuBar *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkmenubar is initialized * /
  nsp_type_gtkmenubar = new_type_gtkmenubar(T_BASE);
  if(( H = gtkmenushell_create(NVOID,(NspTypeBase *) nsp_type_gtkmenubar)) == NULLGTKMENUBAR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkmenubar_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_menu_bar_new())== NULL) return RET_BUG;

  nsp_type_gtkmenubar = new_type_gtkmenubar(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkmenubar );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkmenubar_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmenubar_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkLayout ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkLayout_Private 
#include "nsp/gtk/gtklayout.h"
#include "nsp/interf.h"

/* NspGtkLayout inherits from NspGtkContainer */ 

int nsp_type_gtklayout_id=0;
NspTypeGtkLayout *nsp_type_gtklayout=NULL;

NspTypeGtkLayout *new_type_gtklayout(type_mode mode)
{
  NspTypeGtkLayout *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtklayout != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtklayout;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtklayout_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtklayout_get_methods; 
  type->new = (new_func *) new_gtklayout;

  /* specific methods for gtklayout */
      
  type->init = (init_func *) init_gtklayout;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtklayout */ 

  top->s_type =  (s_type_func *) gtklayout_type_as_string;    
  top->sh_type = (sh_type_func *) gtklayout_type_short_string;
  /* top->create = (create_func*) int_gtklayout_create;*/ 
  
  /* specific methods for gtklayout */
      
  type->init = (init_func *) init_gtklayout;

  if ( nsp_type_gtklayout_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkLayout called nsp_type_gtklayout
       */
      type->id =  nsp_type_gtklayout_id = nsp_new_type_id();
      nsp_type_gtklayout = type;
      if ( nsp_register_type(nsp_type_gtklayout) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtklayout, GTK_TYPE_LAYOUT);
      return ( mode == T_BASE ) ? type : new_type_gtklayout(mode);
    }
  else 
    {
       type->id = nsp_type_gtklayout_id;
       return type;
    }
}

/*
 * initialize GtkLayout instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtklayout(NspGtkLayout *o,NspTypeGtkLayout *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkLayout 
 */

NspGtkLayout *new_gtklayout() 
{
  NspGtkLayout *loc; 
  /* type must exists */
  nsp_type_gtklayout = new_type_gtklayout(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkLayout)))== NULLGTKLAYOUT) return loc;
  /* initialize object */
  if ( init_gtklayout(loc,nsp_type_gtklayout) == FAIL) return NULLGTKLAYOUT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkLayout 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtklayout_type_name[]="GtkLayout";
static char gtklayout_short_type_name[]="GtkLayout";

static char *gtklayout_type_as_string(void)
{
  return(gtklayout_type_name);
}

static char *gtklayout_type_short_string(void)
{
  return(gtklayout_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkLayout objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkLayout   *gtklayout_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtklayout_id) ) return ((NspGtkLayout *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtklayout));
  return NULL;
}

int IsGtkLayoutObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtklayout_id);
}

int IsGtkLayout(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtklayout_id);
}

NspGtkLayout  *GetGtkLayoutCopy(Stack stack, int i)
{
  if (  GetGtkLayout(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkLayout  *GetGtkLayout(Stack stack, int i)
{
  NspGtkLayout *M;
  if (( M = gtklayout_object(NthObj(i))) == NULLGTKLAYOUT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkLayout *gtklayout_copy(NspGtkLayout *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklayout);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklayout);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkLayout
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkLayout *H;
  CheckRhs(0,0);
  / * want to be sure that type gtklayout is initialized * /
  nsp_type_gtklayout = new_type_gtklayout(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtklayout)) == NULLGTKLAYOUT) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtklayout_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"hadjustment",obj,NULLOBJ,-1}, 
	{"vadjustment",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *nsp_hadjustment = NULL, *nsp_vadjustment = NULL;
  GtkAdjustment *hadjustment = NULL, *vadjustment = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_hadjustment, &nsp_vadjustment) == FAIL) return RET_BUG;
  if ( nsp_hadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_hadjustment))
      hadjustment = GTK_ADJUSTMENT(nsp_hadjustment->obj);
    else if (! IsNone((NspObject *)nsp_hadjustment)) {
         Scierror( "hadjustment should be a GtkAdjustment or None");
         return RET_BUG;
    }
  }
  if ( nsp_vadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_vadjustment))
      vadjustment = GTK_ADJUSTMENT(nsp_vadjustment->obj);
    else if (! IsNone((NspObject *)nsp_vadjustment)) {
         Scierror( "vadjustment should be a GtkAdjustment or None");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_layout_new(hadjustment, vadjustment))== NULL) return RET_BUG;

  nsp_type_gtklayout = new_type_gtklayout(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtklayout );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_layout_put(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int, s_int,t_end};
  int x, y;
  NspGObject *child_widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child_widget, &x, &y) == FAIL) return RET_BUG;
  gtk_layout_put(GTK_LAYOUT(self->obj), GTK_WIDGET(child_widget->obj), x, y);
  return 0;
}

static int _wrap_gtk_layout_move(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int, s_int,t_end};
  int x, y;
  NspGObject *child_widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child_widget, &x, &y) == FAIL) return RET_BUG;
  gtk_layout_move(GTK_LAYOUT(self->obj), GTK_WIDGET(child_widget->obj), x, y);
  return 0;
}

static int _wrap_gtk_layout_set_size(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int width, height;

  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
  gtk_layout_set_size(GTK_LAYOUT(self->obj), width, height);
  return 0;
}

#line 6170 "gtk.override"
static int
_wrap_gtk_layout_get_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  guint width, height;
  gtk_layout_get_size(GTK_LAYOUT(self->obj), &width, &height);

  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL) 
    return RET_BUG; 
  return 1; 

}
#line 34899 "gtk.c"


static int _wrap_gtk_layout_get_hadjustment(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_layout_get_hadjustment(GTK_LAYOUT(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_layout_get_vadjustment(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_layout_get_vadjustment(GTK_LAYOUT(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_layout_set_hadjustment(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspGObject *nsp_adjustment;
  GtkAdjustment *adjustment = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_adjustment) == FAIL) return RET_BUG;
  if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
  else if ( ! IsNone((NspObject *) nsp_adjustment))  {
      Scierror( "adjustment should be a GtkAdjustment or None");
      return RET_BUG;
  }
  gtk_layout_set_hadjustment(GTK_LAYOUT(self->obj), adjustment);
  return 0;
}

static int _wrap_gtk_layout_set_vadjustment(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspGObject *nsp_adjustment;
  GtkAdjustment *adjustment = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_adjustment) == FAIL) return RET_BUG;
  if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
  else if ( ! IsNone((NspObject *) nsp_adjustment))  {
      Scierror( "adjustment should be a GtkAdjustment or None");
      return RET_BUG;
  }
  gtk_layout_set_vadjustment(GTK_LAYOUT(self->obj), adjustment);
  return 0;
}

static int _wrap_gtk_layout_freeze(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_layout_freeze(GTK_LAYOUT(self->obj));
  return 0;
}

static int _wrap_gtk_layout_thaw(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  gtk_layout_thaw(GTK_LAYOUT(self->obj));
  return 0;
}

static NspMethods gtklayout_methods[] = {
  {"put",(nsp_method *) _wrap_gtk_layout_put},
  {"move",(nsp_method *) _wrap_gtk_layout_move},
  {"set_size",(nsp_method *) _wrap_gtk_layout_set_size},
  {"get_size",(nsp_method *) _wrap_gtk_layout_get_size},
  {"get_hadjustment",(nsp_method *) _wrap_gtk_layout_get_hadjustment},
  {"get_vadjustment",(nsp_method *) _wrap_gtk_layout_get_vadjustment},
  {"set_hadjustment",(nsp_method *) _wrap_gtk_layout_set_hadjustment},
  {"set_vadjustment",(nsp_method *) _wrap_gtk_layout_set_vadjustment},
  {"freeze",(nsp_method *) _wrap_gtk_layout_freeze},
  {"thaw",(nsp_method *) _wrap_gtk_layout_thaw},
  { NULL, NULL}
};

static NspMethods *gtklayout_get_methods(void) { return gtklayout_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_layout__get_bin_window(NspObject *self,char *attr)
{
  GdkWindow *ret;

  ret = (GdkWindow*) GTK_LAYOUT(NSP_GOBJECT_GET(self))->bin_window;
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow);
}

static AttrTab gtklayout_attrs[] = {
  { "bin_window", (attr_get_function *)_wrap_gtk_layout__get_bin_window, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkFixed ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkFixed_Private 
#include "nsp/gtk/gtkfixed.h"
#include "nsp/interf.h"

/* NspGtkFixed inherits from NspGtkContainer */ 

int nsp_type_gtkfixed_id=0;
NspTypeGtkFixed *nsp_type_gtkfixed=NULL;

NspTypeGtkFixed *new_type_gtkfixed(type_mode mode)
{
  NspTypeGtkFixed *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfixed != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfixed;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfixed_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkfixed_get_methods; 
  type->new = (new_func *) new_gtkfixed;

  /* specific methods for gtkfixed */
      
  type->init = (init_func *) init_gtkfixed;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkfixed */ 

  top->s_type =  (s_type_func *) gtkfixed_type_as_string;    
  top->sh_type = (sh_type_func *) gtkfixed_type_short_string;
  /* top->create = (create_func*) int_gtkfixed_create;*/ 
  
  /* specific methods for gtkfixed */
      
  type->init = (init_func *) init_gtkfixed;

  if ( nsp_type_gtkfixed_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFixed called nsp_type_gtkfixed
       */
      type->id =  nsp_type_gtkfixed_id = nsp_new_type_id();
      nsp_type_gtkfixed = type;
      if ( nsp_register_type(nsp_type_gtkfixed) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfixed, GTK_TYPE_FIXED);
      return ( mode == T_BASE ) ? type : new_type_gtkfixed(mode);
    }
  else 
    {
       type->id = nsp_type_gtkfixed_id;
       return type;
    }
}

/*
 * initialize GtkFixed instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfixed(NspGtkFixed *o,NspTypeGtkFixed *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkFixed 
 */

NspGtkFixed *new_gtkfixed() 
{
  NspGtkFixed *loc; 
  /* type must exists */
  nsp_type_gtkfixed = new_type_gtkfixed(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFixed)))== NULLGTKFIXED) return loc;
  /* initialize object */
  if ( init_gtkfixed(loc,nsp_type_gtkfixed) == FAIL) return NULLGTKFIXED;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkFixed 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkfixed_type_name[]="GtkFixed";
static char gtkfixed_short_type_name[]="GtkFixed";

static char *gtkfixed_type_as_string(void)
{
  return(gtkfixed_type_name);
}

static char *gtkfixed_type_short_string(void)
{
  return(gtkfixed_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkFixed objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkFixed   *gtkfixed_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkfixed_id) ) return ((NspGtkFixed *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfixed));
  return NULL;
}

int IsGtkFixedObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkfixed_id);
}

int IsGtkFixed(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfixed_id);
}

NspGtkFixed  *GetGtkFixedCopy(Stack stack, int i)
{
  if (  GetGtkFixed(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFixed  *GetGtkFixed(Stack stack, int i)
{
  NspGtkFixed *M;
  if (( M = gtkfixed_object(NthObj(i))) == NULLGTKFIXED)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFixed *gtkfixed_copy(NspGtkFixed *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfixed);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfixed);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFixed
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkFixed *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkfixed is initialized * /
  nsp_type_gtkfixed = new_type_gtkfixed(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtkfixed)) == NULLGTKFIXED) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkfixed_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_fixed_new())== NULL) return RET_BUG;

  nsp_type_gtkfixed = new_type_gtkfixed(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkfixed );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_fixed_put(NspGtkFixed *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int, s_int,t_end};
  int x, y;
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &x, &y) == FAIL) return RET_BUG;
  gtk_fixed_put(GTK_FIXED(self->obj), GTK_WIDGET(widget->obj), x, y);
  return 0;
}

static int _wrap_gtk_fixed_move(NspGtkFixed *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int, s_int,t_end};
  int x, y;
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &x, &y) == FAIL) return RET_BUG;
  gtk_fixed_move(GTK_FIXED(self->obj), GTK_WIDGET(widget->obj), x, y);
  return 0;
}

static int _wrap_gtk_fixed_set_has_window(NspGtkFixed *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int has_window;

  if ( GetArgs(stack,rhs,opt,T,&has_window) == FAIL) return RET_BUG;
  gtk_fixed_set_has_window(GTK_FIXED(self->obj), has_window);
  return 0;
}

static int _wrap_gtk_fixed_get_has_window(NspGtkFixed *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_fixed_get_has_window(GTK_FIXED(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkfixed_methods[] = {
  {"put",(nsp_method *) _wrap_gtk_fixed_put},
  {"move",(nsp_method *) _wrap_gtk_fixed_move},
  {"set_has_window",(nsp_method *) _wrap_gtk_fixed_set_has_window},
  {"get_has_window",(nsp_method *) _wrap_gtk_fixed_get_has_window},
  { NULL, NULL}
};

static NspMethods *gtkfixed_get_methods(void) { return gtkfixed_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfixed_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkBin ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkBin_Private 
#include "nsp/gtk/gtkbin.h"
#include "nsp/interf.h"

/* NspGtkBin inherits from NspGtkContainer */ 

int nsp_type_gtkbin_id=0;
NspTypeGtkBin *nsp_type_gtkbin=NULL;

NspTypeGtkBin *new_type_gtkbin(type_mode mode)
{
  NspTypeGtkBin *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkbin != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkbin;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkbin_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkbin_get_methods; 
  type->new = (new_func *) new_gtkbin;

  /* specific methods for gtkbin */
      
  type->init = (init_func *) init_gtkbin;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkbin */ 

  top->s_type =  (s_type_func *) gtkbin_type_as_string;    
  top->sh_type = (sh_type_func *) gtkbin_type_short_string;
  /* top->create = (create_func*) int_gtkbin_create;*/ 
  
  /* specific methods for gtkbin */
      
  type->init = (init_func *) init_gtkbin;

  if ( nsp_type_gtkbin_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkBin called nsp_type_gtkbin
       */
      type->id =  nsp_type_gtkbin_id = nsp_new_type_id();
      nsp_type_gtkbin = type;
      if ( nsp_register_type(nsp_type_gtkbin) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkbin, GTK_TYPE_BIN);
      return ( mode == T_BASE ) ? type : new_type_gtkbin(mode);
    }
  else 
    {
       type->id = nsp_type_gtkbin_id;
       return type;
    }
}

/*
 * initialize GtkBin instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkbin(NspGtkBin *o,NspTypeGtkBin *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkBin 
 */

NspGtkBin *new_gtkbin() 
{
  NspGtkBin *loc; 
  /* type must exists */
  nsp_type_gtkbin = new_type_gtkbin(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkBin)))== NULLGTKBIN) return loc;
  /* initialize object */
  if ( init_gtkbin(loc,nsp_type_gtkbin) == FAIL) return NULLGTKBIN;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkBin 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkbin_type_name[]="GtkBin";
static char gtkbin_short_type_name[]="GtkBin";

static char *gtkbin_type_as_string(void)
{
  return(gtkbin_type_name);
}

static char *gtkbin_type_short_string(void)
{
  return(gtkbin_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkBin objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkBin   *gtkbin_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkbin_id) ) return ((NspGtkBin *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkbin));
  return NULL;
}

int IsGtkBinObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkbin_id);
}

int IsGtkBin(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkbin_id);
}

NspGtkBin  *GetGtkBinCopy(Stack stack, int i)
{
  if (  GetGtkBin(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkBin  *GetGtkBin(Stack stack, int i)
{
  NspGtkBin *M;
  if (( M = gtkbin_object(NthObj(i))) == NULLGTKBIN)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkBin *gtkbin_copy(NspGtkBin *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbin);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbin);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkBin
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkBin *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkbin is initialized * /
  nsp_type_gtkbin = new_type_gtkbin(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtkbin)) == NULLGTKBIN) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_bin_get_child(NspGtkBin *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

  ret = gtk_bin_get_child(GTK_BIN(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkbin_methods[] = {
  {"get_child",(nsp_method *) _wrap_gtk_bin_get_child},
  { NULL, NULL}
};

static NspMethods *gtkbin_get_methods(void) { return gtkbin_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_bin__get_child(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_BIN(NSP_GOBJECT_GET(self))->child;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static AttrTab gtkbin_attrs[] = {
  { "child", (attr_get_function *)_wrap_gtk_bin__get_child, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkViewport ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkViewport_Private 
#include "nsp/gtk/gtkviewport.h"
#include "nsp/interf.h"

/* NspGtkViewport inherits from NspGtkBin */ 

int nsp_type_gtkviewport_id=0;
NspTypeGtkViewport *nsp_type_gtkviewport=NULL;

NspTypeGtkViewport *new_type_gtkviewport(type_mode mode)
{
  NspTypeGtkViewport *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkviewport != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkviewport;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkviewport_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkviewport_get_methods; 
  type->new = (new_func *) new_gtkviewport;

  /* specific methods for gtkviewport */
      
  type->init = (init_func *) init_gtkviewport;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkviewport */ 

  top->s_type =  (s_type_func *) gtkviewport_type_as_string;    
  top->sh_type = (sh_type_func *) gtkviewport_type_short_string;
  /* top->create = (create_func*) int_gtkviewport_create;*/ 
  
  /* specific methods for gtkviewport */
      
  type->init = (init_func *) init_gtkviewport;

  if ( nsp_type_gtkviewport_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkViewport called nsp_type_gtkviewport
       */
      type->id =  nsp_type_gtkviewport_id = nsp_new_type_id();
      nsp_type_gtkviewport = type;
      if ( nsp_register_type(nsp_type_gtkviewport) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkviewport, GTK_TYPE_VIEWPORT);
      return ( mode == T_BASE ) ? type : new_type_gtkviewport(mode);
    }
  else 
    {
       type->id = nsp_type_gtkviewport_id;
       return type;
    }
}

/*
 * initialize GtkViewport instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkviewport(NspGtkViewport *o,NspTypeGtkViewport *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkViewport 
 */

NspGtkViewport *new_gtkviewport() 
{
  NspGtkViewport *loc; 
  /* type must exists */
  nsp_type_gtkviewport = new_type_gtkviewport(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkViewport)))== NULLGTKVIEWPORT) return loc;
  /* initialize object */
  if ( init_gtkviewport(loc,nsp_type_gtkviewport) == FAIL) return NULLGTKVIEWPORT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkViewport 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkviewport_type_name[]="GtkViewport";
static char gtkviewport_short_type_name[]="GtkViewport";

static char *gtkviewport_type_as_string(void)
{
  return(gtkviewport_type_name);
}

static char *gtkviewport_type_short_string(void)
{
  return(gtkviewport_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkViewport objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkViewport   *gtkviewport_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkviewport_id) ) return ((NspGtkViewport *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkviewport));
  return NULL;
}

int IsGtkViewportObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkviewport_id);
}

int IsGtkViewport(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkviewport_id);
}

NspGtkViewport  *GetGtkViewportCopy(Stack stack, int i)
{
  if (  GetGtkViewport(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkViewport  *GetGtkViewport(Stack stack, int i)
{
  NspGtkViewport *M;
  if (( M = gtkviewport_object(NthObj(i))) == NULLGTKVIEWPORT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkViewport *gtkviewport_copy(NspGtkViewport *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkviewport);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkviewport);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkViewport
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkViewport *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkviewport is initialized * /
  nsp_type_gtkviewport = new_type_gtkviewport(T_BASE);
  if(( H = gtkbin_create(NVOID,(NspTypeBase *) nsp_type_gtkviewport)) == NULLGTKVIEWPORT) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkviewport_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"hadjustment",obj,NULLOBJ,-1}, 
	{"vadjustment",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *nsp_hadjustment = NULL, *nsp_vadjustment = NULL;
  GtkAdjustment *hadjustment = NULL, *vadjustment = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_hadjustment, &nsp_vadjustment) == FAIL) return RET_BUG;
  if ( nsp_hadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_hadjustment))
      hadjustment = GTK_ADJUSTMENT(nsp_hadjustment->obj);
    else if (! IsNone((NspObject *)nsp_hadjustment)) {
         Scierror( "hadjustment should be a GtkAdjustment or None");
         return RET_BUG;
    }
  }
  if ( nsp_vadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_vadjustment))
      vadjustment = GTK_ADJUSTMENT(nsp_vadjustment->obj);
    else if (! IsNone((NspObject *)nsp_vadjustment)) {
         Scierror( "vadjustment should be a GtkAdjustment or None");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_viewport_new(hadjustment, vadjustment))== NULL) return RET_BUG;

  nsp_type_gtkviewport = new_type_gtkviewport(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkviewport );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_viewport_get_hadjustment(NspGtkViewport *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_viewport_get_hadjustment(GTK_VIEWPORT(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_viewport_get_vadjustment(NspGtkViewport *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_viewport_get_vadjustment(GTK_VIEWPORT(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_viewport_set_hadjustment(NspGtkViewport *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspGObject *nsp_adjustment;
  GtkAdjustment *adjustment = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_adjustment) == FAIL) return RET_BUG;
  if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
  else if ( ! IsNone((NspObject *) nsp_adjustment))  {
      Scierror( "adjustment should be a GtkAdjustment or None");
      return RET_BUG;
  }
  gtk_viewport_set_hadjustment(GTK_VIEWPORT(self->obj), adjustment);
  return 0;
}

static int _wrap_gtk_viewport_set_vadjustment(NspGtkViewport *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspGObject *nsp_adjustment;
  GtkAdjustment *adjustment = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_adjustment) == FAIL) return RET_BUG;
  if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
  else if ( ! IsNone((NspObject *) nsp_adjustment))  {
      Scierror( "adjustment should be a GtkAdjustment or None");
      return RET_BUG;
  }
  gtk_viewport_set_vadjustment(GTK_VIEWPORT(self->obj), adjustment);
  return 0;
}

static int _wrap_gtk_viewport_set_shadow_type(NspGtkViewport *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkShadowType type;
  NspObject *nsp_type = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
  gtk_viewport_set_shadow_type(GTK_VIEWPORT(self->obj), type);
  return 0;
}

static int _wrap_gtk_viewport_get_shadow_type(NspGtkViewport *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_viewport_get_shadow_type(GTK_VIEWPORT(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkviewport_methods[] = {
  {"get_hadjustment",(nsp_method *) _wrap_gtk_viewport_get_hadjustment},
  {"get_vadjustment",(nsp_method *) _wrap_gtk_viewport_get_vadjustment},
  {"set_hadjustment",(nsp_method *) _wrap_gtk_viewport_set_hadjustment},
  {"set_vadjustment",(nsp_method *) _wrap_gtk_viewport_set_vadjustment},
  {"set_shadow_type",(nsp_method *) _wrap_gtk_viewport_set_shadow_type},
  {"get_shadow_type",(nsp_method *) _wrap_gtk_viewport_get_shadow_type},
  { NULL, NULL}
};

static NspMethods *gtkviewport_get_methods(void) { return gtkviewport_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkviewport_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkScrolledWindow ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkScrolledWindow_Private 
#include "nsp/gtk/gtkscrolledwindow.h"
#include "nsp/interf.h"

/* NspGtkScrolledWindow inherits from NspGtkBin */ 

int nsp_type_gtkscrolledwindow_id=0;
NspTypeGtkScrolledWindow *nsp_type_gtkscrolledwindow=NULL;

NspTypeGtkScrolledWindow *new_type_gtkscrolledwindow(type_mode mode)
{
  NspTypeGtkScrolledWindow *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkscrolledwindow != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkscrolledwindow;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkscrolledwindow_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkscrolledwindow_get_methods; 
  type->new = (new_func *) new_gtkscrolledwindow;

  /* specific methods for gtkscrolledwindow */
      
  type->init = (init_func *) init_gtkscrolledwindow;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkscrolledwindow */ 

  top->s_type =  (s_type_func *) gtkscrolledwindow_type_as_string;    
  top->sh_type = (sh_type_func *) gtkscrolledwindow_type_short_string;
  /* top->create = (create_func*) int_gtkscrolledwindow_create;*/ 
  
  /* specific methods for gtkscrolledwindow */
      
  type->init = (init_func *) init_gtkscrolledwindow;

  if ( nsp_type_gtkscrolledwindow_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkScrolledWindow called nsp_type_gtkscrolledwindow
       */
      type->id =  nsp_type_gtkscrolledwindow_id = nsp_new_type_id();
      nsp_type_gtkscrolledwindow = type;
      if ( nsp_register_type(nsp_type_gtkscrolledwindow) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkscrolledwindow, GTK_TYPE_SCROLLED_WINDOW);
      return ( mode == T_BASE ) ? type : new_type_gtkscrolledwindow(mode);
    }
  else 
    {
       type->id = nsp_type_gtkscrolledwindow_id;
       return type;
    }
}

/*
 * initialize GtkScrolledWindow instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkscrolledwindow(NspGtkScrolledWindow *o,NspTypeGtkScrolledWindow *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkScrolledWindow 
 */

NspGtkScrolledWindow *new_gtkscrolledwindow() 
{
  NspGtkScrolledWindow *loc; 
  /* type must exists */
  nsp_type_gtkscrolledwindow = new_type_gtkscrolledwindow(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkScrolledWindow)))== NULLGTKSCROLLEDWINDOW) return loc;
  /* initialize object */
  if ( init_gtkscrolledwindow(loc,nsp_type_gtkscrolledwindow) == FAIL) return NULLGTKSCROLLEDWINDOW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkScrolledWindow 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkscrolledwindow_type_name[]="GtkScrolledWindow";
static char gtkscrolledwindow_short_type_name[]="GtkScrolledWindow";

static char *gtkscrolledwindow_type_as_string(void)
{
  return(gtkscrolledwindow_type_name);
}

static char *gtkscrolledwindow_type_short_string(void)
{
  return(gtkscrolledwindow_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkScrolledWindow objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkScrolledWindow   *gtkscrolledwindow_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkscrolledwindow_id) ) return ((NspGtkScrolledWindow *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkscrolledwindow));
  return NULL;
}

int IsGtkScrolledWindowObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkscrolledwindow_id);
}

int IsGtkScrolledWindow(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkscrolledwindow_id);
}

NspGtkScrolledWindow  *GetGtkScrolledWindowCopy(Stack stack, int i)
{
  if (  GetGtkScrolledWindow(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkScrolledWindow  *GetGtkScrolledWindow(Stack stack, int i)
{
  NspGtkScrolledWindow *M;
  if (( M = gtkscrolledwindow_object(NthObj(i))) == NULLGTKSCROLLEDWINDOW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkScrolledWindow *gtkscrolledwindow_copy(NspGtkScrolledWindow *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscrolledwindow);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscrolledwindow);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkScrolledWindow
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkScrolledWindow *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkscrolledwindow is initialized * /
  nsp_type_gtkscrolledwindow = new_type_gtkscrolledwindow(T_BASE);
  if(( H = gtkbin_create(NVOID,(NspTypeBase *) nsp_type_gtkscrolledwindow)) == NULLGTKSCROLLEDWINDOW) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkscrolledwindow_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"hadjustment",obj,NULLOBJ,-1}, 
	{"vadjustment",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *nsp_hadjustment = NULL, *nsp_vadjustment = NULL;
  GtkAdjustment *hadjustment = NULL, *vadjustment = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_hadjustment, &nsp_vadjustment) == FAIL) return RET_BUG;
  if ( nsp_hadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_hadjustment))
      hadjustment = GTK_ADJUSTMENT(nsp_hadjustment->obj);
    else if (! IsNone((NspObject *)nsp_hadjustment)) {
         Scierror( "hadjustment should be a GtkAdjustment or None");
         return RET_BUG;
    }
  }
  if ( nsp_vadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_vadjustment))
      vadjustment = GTK_ADJUSTMENT(nsp_vadjustment->obj);
    else if (! IsNone((NspObject *)nsp_vadjustment)) {
         Scierror( "vadjustment should be a GtkAdjustment or None");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_scrolled_window_new(hadjustment, vadjustment))== NULL) return RET_BUG;

  nsp_type_gtkscrolledwindow = new_type_gtkscrolledwindow(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkscrolledwindow );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scrolled_window_set_hadjustment(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *hadjustment;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &hadjustment) == FAIL) return RET_BUG;
  gtk_scrolled_window_set_hadjustment(GTK_SCROLLED_WINDOW(self->obj), GTK_ADJUSTMENT(hadjustment->obj));
  return 0;
}

static int _wrap_gtk_scrolled_window_set_vadjustment(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *hadjustment;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &hadjustment) == FAIL) return RET_BUG;
  gtk_scrolled_window_set_vadjustment(GTK_SCROLLED_WINDOW(self->obj), GTK_ADJUSTMENT(hadjustment->obj));
  return 0;
}

static int _wrap_gtk_scrolled_window_get_hadjustment(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_scrolled_window_get_hadjustment(GTK_SCROLLED_WINDOW(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scrolled_window_get_vadjustment(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkAdjustment *ret;

  ret = gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scrolled_window_set_policy(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, obj,t_end};
  GtkPolicyType hscrollbar_policy, vscrollbar_policy;
  NspObject *nsp_hscrollbar_policy = NULL, *nsp_vscrollbar_policy = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_hscrollbar_policy, &nsp_vscrollbar_policy) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POLICY_TYPE, nsp_hscrollbar_policy, &hscrollbar_policy)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POLICY_TYPE, nsp_vscrollbar_policy, &vscrollbar_policy)== FAIL)
      return RET_BUG;
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(self->obj), hscrollbar_policy, vscrollbar_policy);
  return 0;
}

static int _wrap_gtk_scrolled_window_set_placement(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkCornerType window_placement;
  NspObject *nsp_window_placement = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_window_placement) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_CORNER_TYPE, nsp_window_placement, &window_placement)== FAIL)
      return RET_BUG;
  gtk_scrolled_window_set_placement(GTK_SCROLLED_WINDOW(self->obj), window_placement);
  return 0;
}

static int _wrap_gtk_scrolled_window_get_placement(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_scrolled_window_get_placement(GTK_SCROLLED_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scrolled_window_set_shadow_type(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkShadowType type;
  NspObject *nsp_type = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(self->obj), type);
  return 0;
}

static int _wrap_gtk_scrolled_window_get_shadow_type(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_scrolled_window_get_shadow_type(GTK_SCROLLED_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scrolled_window_add_with_viewport(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
  gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(self->obj), GTK_WIDGET(child->obj));
  return 0;
}

static NspMethods gtkscrolledwindow_methods[] = {
  {"set_hadjustment",(nsp_method *) _wrap_gtk_scrolled_window_set_hadjustment},
  {"set_vadjustment",(nsp_method *) _wrap_gtk_scrolled_window_set_vadjustment},
  {"get_hadjustment",(nsp_method *) _wrap_gtk_scrolled_window_get_hadjustment},
  {"get_vadjustment",(nsp_method *) _wrap_gtk_scrolled_window_get_vadjustment},
  {"set_policy",(nsp_method *) _wrap_gtk_scrolled_window_set_policy},
  {"set_placement",(nsp_method *) _wrap_gtk_scrolled_window_set_placement},
  {"get_placement",(nsp_method *) _wrap_gtk_scrolled_window_get_placement},
  {"set_shadow_type",(nsp_method *) _wrap_gtk_scrolled_window_set_shadow_type},
  {"get_shadow_type",(nsp_method *) _wrap_gtk_scrolled_window_get_shadow_type},
  {"add_with_viewport",(nsp_method *) _wrap_gtk_scrolled_window_add_with_viewport},
  { NULL, NULL}
};

static NspMethods *gtkscrolledwindow_get_methods(void) { return gtkscrolledwindow_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkscrolledwindow_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkItem ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkItem_Private 
#include "nsp/gtk/gtkitem.h"
#include "nsp/interf.h"

/* NspGtkItem inherits from NspGtkBin */ 

int nsp_type_gtkitem_id=0;
NspTypeGtkItem *nsp_type_gtkitem=NULL;

NspTypeGtkItem *new_type_gtkitem(type_mode mode)
{
  NspTypeGtkItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkitem != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkitem;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkitem_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkitem_get_methods; 
  type->new = (new_func *) new_gtkitem;

  /* specific methods for gtkitem */
      
  type->init = (init_func *) init_gtkitem;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkitem */ 

  top->s_type =  (s_type_func *) gtkitem_type_as_string;    
  top->sh_type = (sh_type_func *) gtkitem_type_short_string;
  /* top->create = (create_func*) int_gtkitem_create;*/ 
  
  /* specific methods for gtkitem */
      
  type->init = (init_func *) init_gtkitem;

  if ( nsp_type_gtkitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkItem called nsp_type_gtkitem
       */
      type->id =  nsp_type_gtkitem_id = nsp_new_type_id();
      nsp_type_gtkitem = type;
      if ( nsp_register_type(nsp_type_gtkitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkitem, GTK_TYPE_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkitem(mode);
    }
  else 
    {
       type->id = nsp_type_gtkitem_id;
       return type;
    }
}

/*
 * initialize GtkItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkitem(NspGtkItem *o,NspTypeGtkItem *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkItem 
 */

NspGtkItem *new_gtkitem() 
{
  NspGtkItem *loc; 
  /* type must exists */
  nsp_type_gtkitem = new_type_gtkitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkItem)))== NULLGTKITEM) return loc;
  /* initialize object */
  if ( init_gtkitem(loc,nsp_type_gtkitem) == FAIL) return NULLGTKITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkItem 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkitem_type_name[]="GtkItem";
static char gtkitem_short_type_name[]="GtkItem";

static char *gtkitem_type_as_string(void)
{
  return(gtkitem_type_name);
}

static char *gtkitem_type_short_string(void)
{
  return(gtkitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkItem objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkItem   *gtkitem_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkitem_id) ) return ((NspGtkItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkitem));
  return NULL;
}

int IsGtkItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkitem_id);
}

int IsGtkItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkitem_id);
}

NspGtkItem  *GetGtkItemCopy(Stack stack, int i)
{
  if (  GetGtkItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkItem  *GetGtkItem(Stack stack, int i)
{
  NspGtkItem *M;
  if (( M = gtkitem_object(NthObj(i))) == NULLGTKITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkItem *gtkitem_copy(NspGtkItem *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkItem *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkitem is initialized * /
  nsp_type_gtkitem = new_type_gtkitem(T_BASE);
  if(( H = gtkbin_create(NVOID,(NspTypeBase *) nsp_type_gtkitem)) == NULLGTKITEM) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_item_select(NspGtkItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_item_select(GTK_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_item_deselect(NspGtkItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_item_deselect(GTK_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_item_toggle(NspGtkItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_item_toggle(GTK_ITEM(self->obj));
  return 0;
}

static NspMethods gtkitem_methods[] = {
  {"select",(nsp_method *) _wrap_gtk_item_select},
  {"deselect",(nsp_method *) _wrap_gtk_item_deselect},
  {"toggle",(nsp_method *) _wrap_gtk_item_toggle},
  { NULL, NULL}
};

static NspMethods *gtkitem_get_methods(void) { return gtkitem_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkitem_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkMenuItem ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkMenuItem_Private 
#include "nsp/gtk/gtkmenuitem.h"
#include "nsp/interf.h"

/* NspGtkMenuItem inherits from NspGtkItem */ 

int nsp_type_gtkmenuitem_id=0;
NspTypeGtkMenuItem *nsp_type_gtkmenuitem=NULL;

NspTypeGtkMenuItem *new_type_gtkmenuitem(type_mode mode)
{
  NspTypeGtkMenuItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmenuitem != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmenuitem;
    }
  if ((type =  malloc(sizeof(NspTypeGtkItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmenuitem_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkmenuitem_get_methods; 
  type->new = (new_func *) new_gtkmenuitem;

  /* specific methods for gtkmenuitem */
      
  type->init = (init_func *) init_gtkmenuitem;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkmenuitem */ 

  top->s_type =  (s_type_func *) gtkmenuitem_type_as_string;    
  top->sh_type = (sh_type_func *) gtkmenuitem_type_short_string;
  /* top->create = (create_func*) int_gtkmenuitem_create;*/ 
  
  /* specific methods for gtkmenuitem */
      
  type->init = (init_func *) init_gtkmenuitem;

  if ( nsp_type_gtkmenuitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMenuItem called nsp_type_gtkmenuitem
       */
      type->id =  nsp_type_gtkmenuitem_id = nsp_new_type_id();
      nsp_type_gtkmenuitem = type;
      if ( nsp_register_type(nsp_type_gtkmenuitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmenuitem, GTK_TYPE_MENU_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkmenuitem(mode);
    }
  else 
    {
       type->id = nsp_type_gtkmenuitem_id;
       return type;
    }
}

/*
 * initialize GtkMenuItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmenuitem(NspGtkMenuItem *o,NspTypeGtkMenuItem *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkMenuItem 
 */

NspGtkMenuItem *new_gtkmenuitem() 
{
  NspGtkMenuItem *loc; 
  /* type must exists */
  nsp_type_gtkmenuitem = new_type_gtkmenuitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMenuItem)))== NULLGTKMENUITEM) return loc;
  /* initialize object */
  if ( init_gtkmenuitem(loc,nsp_type_gtkmenuitem) == FAIL) return NULLGTKMENUITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkMenuItem 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkmenuitem_type_name[]="GtkMenuItem";
static char gtkmenuitem_short_type_name[]="GtkMenuItem";

static char *gtkmenuitem_type_as_string(void)
{
  return(gtkmenuitem_type_name);
}

static char *gtkmenuitem_type_short_string(void)
{
  return(gtkmenuitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkMenuItem objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkMenuItem   *gtkmenuitem_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkmenuitem_id) ) return ((NspGtkMenuItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmenuitem));
  return NULL;
}

int IsGtkMenuItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkmenuitem_id);
}

int IsGtkMenuItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmenuitem_id);
}

NspGtkMenuItem  *GetGtkMenuItemCopy(Stack stack, int i)
{
  if (  GetGtkMenuItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMenuItem  *GetGtkMenuItem(Stack stack, int i)
{
  NspGtkMenuItem *M;
  if (( M = gtkmenuitem_object(NthObj(i))) == NULLGTKMENUITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMenuItem *gtkmenuitem_copy(NspGtkMenuItem *self)
{
  /* return gtkitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenuitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenuitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMenuItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkMenuItem *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkmenuitem is initialized * /
  nsp_type_gtkmenuitem = new_type_gtkmenuitem(T_BASE);
  if(( H = gtkitem_create(NVOID,(NspTypeBase *) nsp_type_gtkmenuitem)) == NULLGTKMENUITEM) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 4355 "gtk.override"
static int
_wrap_gtkmenuitem_new(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  GObject *gobj;
  gchar *text = NULL;

  CheckRhs(0,1);
  if ( rhs == 0 ) 
      gobj = (GObject *)gtk_menu_item_new();
  else
    {
      if ((text = GetString(stack,1))== NULL) return RET_BUG;
      gobj = (GObject *)gtk_menu_item_new_with_mnemonic(text);
    }
  if (gobj == NULL ) {
    Scierror( "could not create GtkMenuItem object");
    return RET_BUG;
  }
  nsp_type_gtkmenuitem = new_type_gtkmenuitem(T_BASE);
  if ((ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkmenuitem))==NULL)
    return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
#line 36644 "gtk.c"


static int _wrap_gtk_menu_item_set_submenu(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *submenu;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &submenu) == FAIL) return RET_BUG;
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(self->obj), GTK_WIDGET(submenu->obj));
  return 0;
}

static int _wrap_gtk_menu_item_get_submenu(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

  ret = gtk_menu_item_get_submenu(GTK_MENU_ITEM(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_menu_item_remove_submenu(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_menu_item_remove_submenu(GTK_MENU_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_menu_item_select(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_menu_item_select(GTK_MENU_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_menu_item_deselect(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_menu_item_deselect(GTK_MENU_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_menu_item_activate(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_menu_item_activate(GTK_MENU_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_menu_item_toggle_size_request(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int requisition;

  if ( GetArgs(stack,rhs,opt,T,&requisition) == FAIL) return RET_BUG;
  gtk_menu_item_toggle_size_request(GTK_MENU_ITEM(self->obj), &requisition);
  return 0;
}

static int _wrap_gtk_menu_item_toggle_size_allocate(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int allocation;

  if ( GetArgs(stack,rhs,opt,T,&allocation) == FAIL) return RET_BUG;
  gtk_menu_item_toggle_size_allocate(GTK_MENU_ITEM(self->obj), allocation);
  return 0;
}

static int _wrap_gtk_menu_item_set_right_justified(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int right_justified;

  if ( GetArgs(stack,rhs,opt,T,&right_justified) == FAIL) return RET_BUG;
  gtk_menu_item_set_right_justified(GTK_MENU_ITEM(self->obj), right_justified);
  return 0;
}

static int _wrap_gtk_menu_item_get_right_justified(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_menu_item_get_right_justified(GTK_MENU_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_menu_item_set_accel_path(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *accel_path;

  if ( GetArgs(stack,rhs,opt,T,&accel_path) == FAIL) return RET_BUG;
  gtk_menu_item_set_accel_path(GTK_MENU_ITEM(self->obj), accel_path);
  return 0;
}

static int _wrap_gtk_menu_item_right_justify(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  Scierror("%s: deprecated use GtkMenuItem.set_right_justified",stack.fname); return RET_BUG;
  gtk_menu_item_right_justify(GTK_MENU_ITEM(self->obj));
  return 0;
}

static NspMethods gtkmenuitem_methods[] = {
  {"set_submenu",(nsp_method *) _wrap_gtk_menu_item_set_submenu},
  {"get_submenu",(nsp_method *) _wrap_gtk_menu_item_get_submenu},
  {"remove_submenu",(nsp_method *) _wrap_gtk_menu_item_remove_submenu},
  {"select",(nsp_method *) _wrap_gtk_menu_item_select},
  {"deselect",(nsp_method *) _wrap_gtk_menu_item_deselect},
  {"activate",(nsp_method *) _wrap_gtk_menu_item_activate},
  {"toggle_size_request",(nsp_method *) _wrap_gtk_menu_item_toggle_size_request},
  {"toggle_size_allocate",(nsp_method *) _wrap_gtk_menu_item_toggle_size_allocate},
  {"set_right_justified",(nsp_method *) _wrap_gtk_menu_item_set_right_justified},
  {"get_right_justified",(nsp_method *) _wrap_gtk_menu_item_get_right_justified},
  {"set_accel_path",(nsp_method *) _wrap_gtk_menu_item_set_accel_path},
  {"right_justify",(nsp_method *) _wrap_gtk_menu_item_right_justify},
  { NULL, NULL}
};

static NspMethods *gtkmenuitem_get_methods(void) { return gtkmenuitem_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmenuitem_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkTearoffMenuItem ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkTearoffMenuItem_Private 
#include "nsp/gtk/gtktearoffmenuitem.h"
#include "nsp/interf.h"

/* NspGtkTearoffMenuItem inherits from NspGtkMenuItem */ 

int nsp_type_gtktearoffmenuitem_id=0;
NspTypeGtkTearoffMenuItem *nsp_type_gtktearoffmenuitem=NULL;

NspTypeGtkTearoffMenuItem *new_type_gtktearoffmenuitem(type_mode mode)
{
  NspTypeGtkTearoffMenuItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktearoffmenuitem != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktearoffmenuitem;
    }
  if ((type =  malloc(sizeof(NspTypeGtkMenuItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmenuitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktearoffmenuitem_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktearoffmenuitem_get_methods; 
  type->new = (new_func *) new_gtktearoffmenuitem;

  /* specific methods for gtktearoffmenuitem */
      
  type->init = (init_func *) init_gtktearoffmenuitem;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktearoffmenuitem */ 

  top->s_type =  (s_type_func *) gtktearoffmenuitem_type_as_string;    
  top->sh_type = (sh_type_func *) gtktearoffmenuitem_type_short_string;
  /* top->create = (create_func*) int_gtktearoffmenuitem_create;*/ 
  
  /* specific methods for gtktearoffmenuitem */
      
  type->init = (init_func *) init_gtktearoffmenuitem;

  if ( nsp_type_gtktearoffmenuitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTearoffMenuItem called nsp_type_gtktearoffmenuitem
       */
      type->id =  nsp_type_gtktearoffmenuitem_id = nsp_new_type_id();
      nsp_type_gtktearoffmenuitem = type;
      if ( nsp_register_type(nsp_type_gtktearoffmenuitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktearoffmenuitem, GTK_TYPE_TEAROFF_MENU_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtktearoffmenuitem(mode);
    }
  else 
    {
       type->id = nsp_type_gtktearoffmenuitem_id;
       return type;
    }
}

/*
 * initialize GtkTearoffMenuItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktearoffmenuitem(NspGtkTearoffMenuItem *o,NspTypeGtkTearoffMenuItem *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkTearoffMenuItem 
 */

NspGtkTearoffMenuItem *new_gtktearoffmenuitem() 
{
  NspGtkTearoffMenuItem *loc; 
  /* type must exists */
  nsp_type_gtktearoffmenuitem = new_type_gtktearoffmenuitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTearoffMenuItem)))== NULLGTKTEAROFFMENUITEM) return loc;
  /* initialize object */
  if ( init_gtktearoffmenuitem(loc,nsp_type_gtktearoffmenuitem) == FAIL) return NULLGTKTEAROFFMENUITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkTearoffMenuItem 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktearoffmenuitem_type_name[]="GtkTearoffMenuItem";
static char gtktearoffmenuitem_short_type_name[]="GtkTearoffMenuItem";

static char *gtktearoffmenuitem_type_as_string(void)
{
  return(gtktearoffmenuitem_type_name);
}

static char *gtktearoffmenuitem_type_short_string(void)
{
  return(gtktearoffmenuitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkTearoffMenuItem objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkTearoffMenuItem   *gtktearoffmenuitem_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktearoffmenuitem_id) ) return ((NspGtkTearoffMenuItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktearoffmenuitem));
  return NULL;
}

int IsGtkTearoffMenuItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktearoffmenuitem_id);
}

int IsGtkTearoffMenuItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktearoffmenuitem_id);
}

NspGtkTearoffMenuItem  *GetGtkTearoffMenuItemCopy(Stack stack, int i)
{
  if (  GetGtkTearoffMenuItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTearoffMenuItem  *GetGtkTearoffMenuItem(Stack stack, int i)
{
  NspGtkTearoffMenuItem *M;
  if (( M = gtktearoffmenuitem_object(NthObj(i))) == NULLGTKTEAROFFMENUITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTearoffMenuItem *gtktearoffmenuitem_copy(NspGtkTearoffMenuItem *self)
{
  /* return gtkmenuitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktearoffmenuitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktearoffmenuitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTearoffMenuItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkTearoffMenuItem *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktearoffmenuitem is initialized * /
  nsp_type_gtktearoffmenuitem = new_type_gtktearoffmenuitem(T_BASE);
  if(( H = gtkmenuitem_create(NVOID,(NspTypeBase *) nsp_type_gtktearoffmenuitem)) == NULLGTKTEAROFFMENUITEM) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtktearoffmenuitem_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_tearoff_menu_item_new())== NULL) return RET_BUG;

  nsp_type_gtktearoffmenuitem = new_type_gtktearoffmenuitem(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktearoffmenuitem );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtktearoffmenuitem_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktearoffmenuitem_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkSeparatorMenuItem ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkSeparatorMenuItem_Private 
#include "nsp/gtk/gtkseparatormenuitem.h"
#include "nsp/interf.h"

/* NspGtkSeparatorMenuItem inherits from NspGtkMenuItem */ 

int nsp_type_gtkseparatormenuitem_id=0;
NspTypeGtkSeparatorMenuItem *nsp_type_gtkseparatormenuitem=NULL;

NspTypeGtkSeparatorMenuItem *new_type_gtkseparatormenuitem(type_mode mode)
{
  NspTypeGtkSeparatorMenuItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkseparatormenuitem != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkseparatormenuitem;
    }
  if ((type =  malloc(sizeof(NspTypeGtkMenuItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmenuitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkseparatormenuitem_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkseparatormenuitem_get_methods; 
  type->new = (new_func *) new_gtkseparatormenuitem;

  /* specific methods for gtkseparatormenuitem */
      
  type->init = (init_func *) init_gtkseparatormenuitem;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkseparatormenuitem */ 

  top->s_type =  (s_type_func *) gtkseparatormenuitem_type_as_string;    
  top->sh_type = (sh_type_func *) gtkseparatormenuitem_type_short_string;
  /* top->create = (create_func*) int_gtkseparatormenuitem_create;*/ 
  
  /* specific methods for gtkseparatormenuitem */
      
  type->init = (init_func *) init_gtkseparatormenuitem;

  if ( nsp_type_gtkseparatormenuitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSeparatorMenuItem called nsp_type_gtkseparatormenuitem
       */
      type->id =  nsp_type_gtkseparatormenuitem_id = nsp_new_type_id();
      nsp_type_gtkseparatormenuitem = type;
      if ( nsp_register_type(nsp_type_gtkseparatormenuitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkseparatormenuitem, GTK_TYPE_SEPARATOR_MENU_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkseparatormenuitem(mode);
    }
  else 
    {
       type->id = nsp_type_gtkseparatormenuitem_id;
       return type;
    }
}

/*
 * initialize GtkSeparatorMenuItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkseparatormenuitem(NspGtkSeparatorMenuItem *o,NspTypeGtkSeparatorMenuItem *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkSeparatorMenuItem 
 */

NspGtkSeparatorMenuItem *new_gtkseparatormenuitem() 
{
  NspGtkSeparatorMenuItem *loc; 
  /* type must exists */
  nsp_type_gtkseparatormenuitem = new_type_gtkseparatormenuitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSeparatorMenuItem)))== NULLGTKSEPARATORMENUITEM) return loc;
  /* initialize object */
  if ( init_gtkseparatormenuitem(loc,nsp_type_gtkseparatormenuitem) == FAIL) return NULLGTKSEPARATORMENUITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkSeparatorMenuItem 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkseparatormenuitem_type_name[]="GtkSeparatorMenuItem";
static char gtkseparatormenuitem_short_type_name[]="GtkSeparatorMenuItem";

static char *gtkseparatormenuitem_type_as_string(void)
{
  return(gtkseparatormenuitem_type_name);
}

static char *gtkseparatormenuitem_type_short_string(void)
{
  return(gtkseparatormenuitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkSeparatorMenuItem objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkSeparatorMenuItem   *gtkseparatormenuitem_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkseparatormenuitem_id) ) return ((NspGtkSeparatorMenuItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkseparatormenuitem));
  return NULL;
}

int IsGtkSeparatorMenuItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkseparatormenuitem_id);
}

int IsGtkSeparatorMenuItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkseparatormenuitem_id);
}

NspGtkSeparatorMenuItem  *GetGtkSeparatorMenuItemCopy(Stack stack, int i)
{
  if (  GetGtkSeparatorMenuItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSeparatorMenuItem  *GetGtkSeparatorMenuItem(Stack stack, int i)
{
  NspGtkSeparatorMenuItem *M;
  if (( M = gtkseparatormenuitem_object(NthObj(i))) == NULLGTKSEPARATORMENUITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSeparatorMenuItem *gtkseparatormenuitem_copy(NspGtkSeparatorMenuItem *self)
{
  /* return gtkmenuitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkseparatormenuitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkseparatormenuitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSeparatorMenuItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkSeparatorMenuItem *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkseparatormenuitem is initialized * /
  nsp_type_gtkseparatormenuitem = new_type_gtkseparatormenuitem(T_BASE);
  if(( H = gtkmenuitem_create(NVOID,(NspTypeBase *) nsp_type_gtkseparatormenuitem)) == NULLGTKSEPARATORMENUITEM) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkseparatormenuitem_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_separator_menu_item_new())== NULL) return RET_BUG;

  nsp_type_gtkseparatormenuitem = new_type_gtkseparatormenuitem(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkseparatormenuitem );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkseparatormenuitem_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkseparatormenuitem_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkCheckMenuItem ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkCheckMenuItem_Private 
#include "nsp/gtk/gtkcheckmenuitem.h"
#include "nsp/interf.h"

/* NspGtkCheckMenuItem inherits from NspGtkMenuItem */ 

int nsp_type_gtkcheckmenuitem_id=0;
NspTypeGtkCheckMenuItem *nsp_type_gtkcheckmenuitem=NULL;

NspTypeGtkCheckMenuItem *new_type_gtkcheckmenuitem(type_mode mode)
{
  NspTypeGtkCheckMenuItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcheckmenuitem != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcheckmenuitem;
    }
  if ((type =  malloc(sizeof(NspTypeGtkMenuItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmenuitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcheckmenuitem_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcheckmenuitem_get_methods; 
  type->new = (new_func *) new_gtkcheckmenuitem;

  /* specific methods for gtkcheckmenuitem */
      
  type->init = (init_func *) init_gtkcheckmenuitem;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcheckmenuitem */ 

  top->s_type =  (s_type_func *) gtkcheckmenuitem_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcheckmenuitem_type_short_string;
  /* top->create = (create_func*) int_gtkcheckmenuitem_create;*/ 
  
  /* specific methods for gtkcheckmenuitem */
      
  type->init = (init_func *) init_gtkcheckmenuitem;

  if ( nsp_type_gtkcheckmenuitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCheckMenuItem called nsp_type_gtkcheckmenuitem
       */
      type->id =  nsp_type_gtkcheckmenuitem_id = nsp_new_type_id();
      nsp_type_gtkcheckmenuitem = type;
      if ( nsp_register_type(nsp_type_gtkcheckmenuitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcheckmenuitem, GTK_TYPE_CHECK_MENU_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkcheckmenuitem(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcheckmenuitem_id;
       return type;
    }
}

/*
 * initialize GtkCheckMenuItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcheckmenuitem(NspGtkCheckMenuItem *o,NspTypeGtkCheckMenuItem *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkCheckMenuItem 
 */

NspGtkCheckMenuItem *new_gtkcheckmenuitem() 
{
  NspGtkCheckMenuItem *loc; 
  /* type must exists */
  nsp_type_gtkcheckmenuitem = new_type_gtkcheckmenuitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCheckMenuItem)))== NULLGTKCHECKMENUITEM) return loc;
  /* initialize object */
  if ( init_gtkcheckmenuitem(loc,nsp_type_gtkcheckmenuitem) == FAIL) return NULLGTKCHECKMENUITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkCheckMenuItem 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcheckmenuitem_type_name[]="GtkCheckMenuItem";
static char gtkcheckmenuitem_short_type_name[]="GtkCheckMenuItem";

static char *gtkcheckmenuitem_type_as_string(void)
{
  return(gtkcheckmenuitem_type_name);
}

static char *gtkcheckmenuitem_type_short_string(void)
{
  return(gtkcheckmenuitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkCheckMenuItem objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkCheckMenuItem   *gtkcheckmenuitem_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcheckmenuitem_id) ) return ((NspGtkCheckMenuItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcheckmenuitem));
  return NULL;
}

int IsGtkCheckMenuItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcheckmenuitem_id);
}

int IsGtkCheckMenuItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcheckmenuitem_id);
}

NspGtkCheckMenuItem  *GetGtkCheckMenuItemCopy(Stack stack, int i)
{
  if (  GetGtkCheckMenuItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCheckMenuItem  *GetGtkCheckMenuItem(Stack stack, int i)
{
  NspGtkCheckMenuItem *M;
  if (( M = gtkcheckmenuitem_object(NthObj(i))) == NULLGTKCHECKMENUITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCheckMenuItem *gtkcheckmenuitem_copy(NspGtkCheckMenuItem *self)
{
  /* return gtkmenuitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcheckmenuitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcheckmenuitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCheckMenuItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkCheckMenuItem *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcheckmenuitem is initialized * /
  nsp_type_gtkcheckmenuitem = new_type_gtkcheckmenuitem(T_BASE);
  if(( H = gtkmenuitem_create(NVOID,(NspTypeBase *) nsp_type_gtkcheckmenuitem)) == NULLGTKCHECKMENUITEM) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 4450 "gtk.override"
static int
_wrap_gtkcheckmenuitem_new(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  GObject *gobj;
  gchar *text = NULL;

  CheckRhs(0,1);
  if ( rhs == 0 ) 
      gobj = (GObject *)gtk_check_menu_item_new();
  else
    {
      if ((text = GetString(stack,1))== NULL) return RET_BUG;
      gobj = (GObject *)gtk_check_menu_item_new_with_mnemonic(text);
    }
  if (gobj == NULL ) {
    Scierror( "could not create GtkCheckMenuItem object");
    return RET_BUG;
  }
  nsp_type_gtkcheckmenuitem = new_type_gtkcheckmenuitem(T_BASE);
  if ((ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkcheckmenuitem))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
#line 37421 "gtk.c"


static int _wrap_gtk_check_menu_item_set_active(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int is_active;

  if ( GetArgs(stack,rhs,opt,T,&is_active) == FAIL) return RET_BUG;
  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(self->obj), is_active);
  return 0;
}

static int _wrap_gtk_check_menu_item_get_active(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_check_menu_item_toggled(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_check_menu_item_toggled(GTK_CHECK_MENU_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_check_menu_item_set_inconsistent(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_check_menu_item_set_inconsistent(GTK_CHECK_MENU_ITEM(self->obj), setting);
  return 0;
}

static int _wrap_gtk_check_menu_item_get_inconsistent(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_check_menu_item_get_inconsistent(GTK_CHECK_MENU_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_check_menu_item_set_show_toggle(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int always;

  if ( GetArgs(stack,rhs,opt,T,&always) == FAIL) return RET_BUG;
  Scierror("%s: deprecated don't use this method",stack.fname); return RET_BUG;
  gtk_check_menu_item_set_show_toggle(GTK_CHECK_MENU_ITEM(self->obj), always);
  return 0;
}

static int _wrap_gtk_check_menu_item_set_state(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int is_active;

  if ( GetArgs(stack,rhs,opt,T,&is_active) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkCheckMenuItem.set_active",stack.fname); return RET_BUG;
  gtk_check_menu_item_set_state(GTK_CHECK_MENU_ITEM(self->obj), is_active);
  return 0;
}

static NspMethods gtkcheckmenuitem_methods[] = {
  {"set_active",(nsp_method *) _wrap_gtk_check_menu_item_set_active},
  {"get_active",(nsp_method *) _wrap_gtk_check_menu_item_get_active},
  {"toggled",(nsp_method *) _wrap_gtk_check_menu_item_toggled},
  {"set_inconsistent",(nsp_method *) _wrap_gtk_check_menu_item_set_inconsistent},
  {"get_inconsistent",(nsp_method *) _wrap_gtk_check_menu_item_get_inconsistent},
  {"set_show_toggle",(nsp_method *) _wrap_gtk_check_menu_item_set_show_toggle},
  {"set_state",(nsp_method *) _wrap_gtk_check_menu_item_set_state},
  { NULL, NULL}
};

static NspMethods *gtkcheckmenuitem_get_methods(void) { return gtkcheckmenuitem_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_check_menu_item__get_active(NspObject *self,char *attr)
{
  int ret;
  NspObject *nsp_ret;

  ret = (gboolean) GTK_CHECK_MENU_ITEM(NSP_GOBJECT_GET(self))->active;
  nsp_ret= (ret == TRUE) ? nsp_create_true_object(NVOID) : nsp_create_false_object(NVOID);
  return nsp_ret;
}

static AttrTab gtkcheckmenuitem_attrs[] = {
  { "active", (attr_get_function *)_wrap_gtk_check_menu_item__get_active, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkRadioMenuItem ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkRadioMenuItem_Private 
#include "nsp/gtk/gtkradiomenuitem.h"
#include "nsp/interf.h"

/* NspGtkRadioMenuItem inherits from NspGtkCheckMenuItem */ 

int nsp_type_gtkradiomenuitem_id=0;
NspTypeGtkRadioMenuItem *nsp_type_gtkradiomenuitem=NULL;

NspTypeGtkRadioMenuItem *new_type_gtkradiomenuitem(type_mode mode)
{
  NspTypeGtkRadioMenuItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkradiomenuitem != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkradiomenuitem;
    }
  if ((type =  malloc(sizeof(NspTypeGtkCheckMenuItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcheckmenuitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkradiomenuitem_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkradiomenuitem_get_methods; 
  type->new = (new_func *) new_gtkradiomenuitem;

  /* specific methods for gtkradiomenuitem */
      
  type->init = (init_func *) init_gtkradiomenuitem;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkradiomenuitem */ 

  top->s_type =  (s_type_func *) gtkradiomenuitem_type_as_string;    
  top->sh_type = (sh_type_func *) gtkradiomenuitem_type_short_string;
  /* top->create = (create_func*) int_gtkradiomenuitem_create;*/ 
  
  /* specific methods for gtkradiomenuitem */
      
  type->init = (init_func *) init_gtkradiomenuitem;

  if ( nsp_type_gtkradiomenuitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRadioMenuItem called nsp_type_gtkradiomenuitem
       */
      type->id =  nsp_type_gtkradiomenuitem_id = nsp_new_type_id();
      nsp_type_gtkradiomenuitem = type;
      if ( nsp_register_type(nsp_type_gtkradiomenuitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkradiomenuitem, GTK_TYPE_RADIO_MENU_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkradiomenuitem(mode);
    }
  else 
    {
       type->id = nsp_type_gtkradiomenuitem_id;
       return type;
    }
}

/*
 * initialize GtkRadioMenuItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkradiomenuitem(NspGtkRadioMenuItem *o,NspTypeGtkRadioMenuItem *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkRadioMenuItem 
 */

NspGtkRadioMenuItem *new_gtkradiomenuitem() 
{
  NspGtkRadioMenuItem *loc; 
  /* type must exists */
  nsp_type_gtkradiomenuitem = new_type_gtkradiomenuitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRadioMenuItem)))== NULLGTKRADIOMENUITEM) return loc;
  /* initialize object */
  if ( init_gtkradiomenuitem(loc,nsp_type_gtkradiomenuitem) == FAIL) return NULLGTKRADIOMENUITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkRadioMenuItem 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkradiomenuitem_type_name[]="GtkRadioMenuItem";
static char gtkradiomenuitem_short_type_name[]="GtkRadioMenuItem";

static char *gtkradiomenuitem_type_as_string(void)
{
  return(gtkradiomenuitem_type_name);
}

static char *gtkradiomenuitem_type_short_string(void)
{
  return(gtkradiomenuitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkRadioMenuItem objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkRadioMenuItem   *gtkradiomenuitem_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkradiomenuitem_id) ) return ((NspGtkRadioMenuItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkradiomenuitem));
  return NULL;
}

int IsGtkRadioMenuItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkradiomenuitem_id);
}

int IsGtkRadioMenuItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkradiomenuitem_id);
}

NspGtkRadioMenuItem  *GetGtkRadioMenuItemCopy(Stack stack, int i)
{
  if (  GetGtkRadioMenuItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRadioMenuItem  *GetGtkRadioMenuItem(Stack stack, int i)
{
  NspGtkRadioMenuItem *M;
  if (( M = gtkradiomenuitem_object(NthObj(i))) == NULLGTKRADIOMENUITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRadioMenuItem *gtkradiomenuitem_copy(NspGtkRadioMenuItem *self)
{
  /* return gtkcheckmenuitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradiomenuitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradiomenuitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRadioMenuItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkRadioMenuItem *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkradiomenuitem is initialized * /
  nsp_type_gtkradiomenuitem = new_type_gtkradiomenuitem(T_BASE);
  if(( H = gtkcheckmenuitem_create(NVOID,(NspTypeBase *) nsp_type_gtkradiomenuitem)) == NULLGTKRADIOMENUITEM) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 4478 "gtk.override"
static int
_wrap_gtkradiomenuitem_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  GtkRadioMenuItem *group = NULL;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"group",obj,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };
  NspObject *nsp_group = NULL;
  gchar *text = NULL;
  if (GetArgs(stack,rhs,opt,T, &opts,&nsp_group, &text) == FAIL)  return RET_BUG;

  if ( nsp_group != NULL )
    {
      if (nspgobject_check(nsp_group,nsp_type_gtkradiomenuitem))
	group = GTK_RADIO_MENU_ITEM(nspgobject_get(nsp_group));    
      else {
	Scierror("group argument must be a GtkRadioButton");
	return RET_BUG;
      }
    }

  if (text == NULL) {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_menu_item_new(NULL);
    else
      gobj = (GObject *)gtk_radio_menu_item_new(group->group);
  } else {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_menu_item_new_with_mnemonic(NULL,text);
    else
      gobj = (GObject *)gtk_radio_menu_item_new_with_mnemonic(group->group, text);
  }
  if (gobj == NULL ) {
    Scierror( "could not create GtkRadioMenuItem object");
    return RET_BUG;
  }
  nsp_type_gtkradiomenuitem = new_type_gtkradiomenuitem(T_BASE);
  if ((ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkradiomenuitem))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
#line 37762 "gtk.c"


static NspMethods *gtkradiomenuitem_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkradiomenuitem_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkImageMenuItem ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkImageMenuItem_Private 
#include "nsp/gtk/gtkimagemenuitem.h"
#include "nsp/interf.h"

/* NspGtkImageMenuItem inherits from NspGtkMenuItem */ 

int nsp_type_gtkimagemenuitem_id=0;
NspTypeGtkImageMenuItem *nsp_type_gtkimagemenuitem=NULL;

NspTypeGtkImageMenuItem *new_type_gtkimagemenuitem(type_mode mode)
{
  NspTypeGtkImageMenuItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkimagemenuitem != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkimagemenuitem;
    }
  if ((type =  malloc(sizeof(NspTypeGtkMenuItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmenuitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkimagemenuitem_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkimagemenuitem_get_methods; 
  type->new = (new_func *) new_gtkimagemenuitem;

  /* specific methods for gtkimagemenuitem */
      
  type->init = (init_func *) init_gtkimagemenuitem;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkimagemenuitem */ 

  top->s_type =  (s_type_func *) gtkimagemenuitem_type_as_string;    
  top->sh_type = (sh_type_func *) gtkimagemenuitem_type_short_string;
  /* top->create = (create_func*) int_gtkimagemenuitem_create;*/ 
  
  /* specific methods for gtkimagemenuitem */
      
  type->init = (init_func *) init_gtkimagemenuitem;

  if ( nsp_type_gtkimagemenuitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkImageMenuItem called nsp_type_gtkimagemenuitem
       */
      type->id =  nsp_type_gtkimagemenuitem_id = nsp_new_type_id();
      nsp_type_gtkimagemenuitem = type;
      if ( nsp_register_type(nsp_type_gtkimagemenuitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkimagemenuitem, GTK_TYPE_IMAGE_MENU_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkimagemenuitem(mode);
    }
  else 
    {
       type->id = nsp_type_gtkimagemenuitem_id;
       return type;
    }
}

/*
 * initialize GtkImageMenuItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkimagemenuitem(NspGtkImageMenuItem *o,NspTypeGtkImageMenuItem *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkImageMenuItem 
 */

NspGtkImageMenuItem *new_gtkimagemenuitem() 
{
  NspGtkImageMenuItem *loc; 
  /* type must exists */
  nsp_type_gtkimagemenuitem = new_type_gtkimagemenuitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkImageMenuItem)))== NULLGTKIMAGEMENUITEM) return loc;
  /* initialize object */
  if ( init_gtkimagemenuitem(loc,nsp_type_gtkimagemenuitem) == FAIL) return NULLGTKIMAGEMENUITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkImageMenuItem 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkimagemenuitem_type_name[]="GtkImageMenuItem";
static char gtkimagemenuitem_short_type_name[]="GtkImageMenuItem";

static char *gtkimagemenuitem_type_as_string(void)
{
  return(gtkimagemenuitem_type_name);
}

static char *gtkimagemenuitem_type_short_string(void)
{
  return(gtkimagemenuitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkImageMenuItem objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkImageMenuItem   *gtkimagemenuitem_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkimagemenuitem_id) ) return ((NspGtkImageMenuItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkimagemenuitem));
  return NULL;
}

int IsGtkImageMenuItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkimagemenuitem_id);
}

int IsGtkImageMenuItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkimagemenuitem_id);
}

NspGtkImageMenuItem  *GetGtkImageMenuItemCopy(Stack stack, int i)
{
  if (  GetGtkImageMenuItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkImageMenuItem  *GetGtkImageMenuItem(Stack stack, int i)
{
  NspGtkImageMenuItem *M;
  if (( M = gtkimagemenuitem_object(NthObj(i))) == NULLGTKIMAGEMENUITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkImageMenuItem *gtkimagemenuitem_copy(NspGtkImageMenuItem *self)
{
  /* return gtkmenuitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimagemenuitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimagemenuitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkImageMenuItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkImageMenuItem *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkimagemenuitem is initialized * /
  nsp_type_gtkimagemenuitem = new_type_gtkimagemenuitem(T_BASE);
  if(( H = gtkmenuitem_create(NVOID,(NspTypeBase *) nsp_type_gtkimagemenuitem)) == NULLGTKIMAGEMENUITEM) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 4530 "gtk.override"
static int
_wrap_gtkimagemenuitem_new(Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "stock_id", "accel_group", NULL };*/
  NspObject *nsp_ret;
  int_types T[] = {new_opts, t_end} ;
  nsp_option opts[] = {
    {"stock_id",string,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {"mnemonic",string,NULLOBJ,-1}, 
    {"accel_group",obj_check,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };
  GObject *gobj;
  gchar *stock_id = NULL;
  gchar *label = NULL;
  gchar *mnemonic = NULL;
  NspObject *nsp_accel_group = NULL;
  GtkAccelGroup *accel_group= NULL;
  
  if (GetArgs(stack,rhs,opt,T,&opts,&stock_id,&label,&mnemonic, 
	      &nsp_type_gtkaccelgroup, &nsp_accel_group)==FAIL)
    return RET_BUG;
  
  if (stock_id)
    gobj = (GObject *)gtk_image_menu_item_new_from_stock(stock_id, accel_group);
  else if ( label ) 
    gobj = (GObject *)gtk_image_menu_item_new_with_label(label) ;
  else if (mnemonic ) 
    gobj = (GObject *)gtk_image_menu_item_new_with_label(label) ;
  else
    gobj = (GObject *)gtk_image_menu_item_new();
  if (gobj==NULL) {
    Scierror( "could not create GtkImageMenuItem object\n");
    return RET_BUG;
  }
  if ((nsp_ret=(NspObject*) gobject_create(NVOID, gobj,(NspTypeBase *) nsp_type_gtkimagemenuitem))==NULL) 
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 38007 "gtk.c"


static int _wrap_gtk_image_menu_item_set_image(NspGtkImageMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *image;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &image) == FAIL) return RET_BUG;
  gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(self->obj), GTK_WIDGET(image->obj));
  return 0;
}

static int _wrap_gtk_image_menu_item_get_image(NspGtkImageMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

  ret = gtk_image_menu_item_get_image(GTK_IMAGE_MENU_ITEM(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkimagemenuitem_methods[] = {
  {"set_image",(nsp_method *) _wrap_gtk_image_menu_item_set_image},
  {"get_image",(nsp_method *) _wrap_gtk_image_menu_item_get_image},
  { NULL, NULL}
};

static NspMethods *gtkimagemenuitem_get_methods(void) { return gtkimagemenuitem_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkimagemenuitem_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkHandleBox ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkHandleBox_Private 
#include "nsp/gtk/gtkhandlebox.h"
#include "nsp/interf.h"

/* NspGtkHandleBox inherits from NspGtkBin */ 

int nsp_type_gtkhandlebox_id=0;
NspTypeGtkHandleBox *nsp_type_gtkhandlebox=NULL;

NspTypeGtkHandleBox *new_type_gtkhandlebox(type_mode mode)
{
  NspTypeGtkHandleBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkhandlebox != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkhandlebox;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkhandlebox_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkhandlebox_get_methods; 
  type->new = (new_func *) new_gtkhandlebox;

  /* specific methods for gtkhandlebox */
      
  type->init = (init_func *) init_gtkhandlebox;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkhandlebox */ 

  top->s_type =  (s_type_func *) gtkhandlebox_type_as_string;    
  top->sh_type = (sh_type_func *) gtkhandlebox_type_short_string;
  /* top->create = (create_func*) int_gtkhandlebox_create;*/ 
  
  /* specific methods for gtkhandlebox */
      
  type->init = (init_func *) init_gtkhandlebox;

  if ( nsp_type_gtkhandlebox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkHandleBox called nsp_type_gtkhandlebox
       */
      type->id =  nsp_type_gtkhandlebox_id = nsp_new_type_id();
      nsp_type_gtkhandlebox = type;
      if ( nsp_register_type(nsp_type_gtkhandlebox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkhandlebox, GTK_TYPE_HANDLE_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkhandlebox(mode);
    }
  else 
    {
       type->id = nsp_type_gtkhandlebox_id;
       return type;
    }
}

/*
 * initialize GtkHandleBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkhandlebox(NspGtkHandleBox *o,NspTypeGtkHandleBox *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkHandleBox 
 */

NspGtkHandleBox *new_gtkhandlebox() 
{
  NspGtkHandleBox *loc; 
  /* type must exists */
  nsp_type_gtkhandlebox = new_type_gtkhandlebox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkHandleBox)))== NULLGTKHANDLEBOX) return loc;
  /* initialize object */
  if ( init_gtkhandlebox(loc,nsp_type_gtkhandlebox) == FAIL) return NULLGTKHANDLEBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkHandleBox 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkhandlebox_type_name[]="GtkHandleBox";
static char gtkhandlebox_short_type_name[]="GtkHandleBox";

static char *gtkhandlebox_type_as_string(void)
{
  return(gtkhandlebox_type_name);
}

static char *gtkhandlebox_type_short_string(void)
{
  return(gtkhandlebox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkHandleBox objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkHandleBox   *gtkhandlebox_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkhandlebox_id) ) return ((NspGtkHandleBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkhandlebox));
  return NULL;
}

int IsGtkHandleBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkhandlebox_id);
}

int IsGtkHandleBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkhandlebox_id);
}

NspGtkHandleBox  *GetGtkHandleBoxCopy(Stack stack, int i)
{
  if (  GetGtkHandleBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkHandleBox  *GetGtkHandleBox(Stack stack, int i)
{
  NspGtkHandleBox *M;
  if (( M = gtkhandlebox_object(NthObj(i))) == NULLGTKHANDLEBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkHandleBox *gtkhandlebox_copy(NspGtkHandleBox *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhandlebox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhandlebox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkHandleBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkHandleBox *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkhandlebox is initialized * /
  nsp_type_gtkhandlebox = new_type_gtkhandlebox(T_BASE);
  if(( H = gtkbin_create(NVOID,(NspTypeBase *) nsp_type_gtkhandlebox)) == NULLGTKHANDLEBOX) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkhandlebox_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_handle_box_new())== NULL) return RET_BUG;

  nsp_type_gtkhandlebox = new_type_gtkhandlebox(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkhandlebox );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_handle_box_set_shadow_type(NspGtkHandleBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkShadowType type;
  NspObject *nsp_type = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
  gtk_handle_box_set_shadow_type(GTK_HANDLE_BOX(self->obj), type);
  return 0;
}

static int _wrap_gtk_handle_box_get_shadow_type(NspGtkHandleBox *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_handle_box_get_shadow_type(GTK_HANDLE_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_handle_box_set_handle_position(NspGtkHandleBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_position = NULL;
  GtkPositionType position;

  if ( GetArgs(stack,rhs,opt,T,&nsp_position) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_position, &position)== FAIL)
      return RET_BUG;
  gtk_handle_box_set_handle_position(GTK_HANDLE_BOX(self->obj), position);
  return 0;
}

static int _wrap_gtk_handle_box_get_handle_position(NspGtkHandleBox *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_handle_box_get_handle_position(GTK_HANDLE_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_handle_box_set_snap_edge(NspGtkHandleBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_edge = NULL;
  GtkPositionType edge;

  if ( GetArgs(stack,rhs,opt,T,&nsp_edge) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_edge, &edge)== FAIL)
      return RET_BUG;
  gtk_handle_box_set_snap_edge(GTK_HANDLE_BOX(self->obj), edge);
  return 0;
}

static int _wrap_gtk_handle_box_get_snap_edge(NspGtkHandleBox *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_handle_box_get_snap_edge(GTK_HANDLE_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkhandlebox_methods[] = {
  {"set_shadow_type",(nsp_method *) _wrap_gtk_handle_box_set_shadow_type},
  {"get_shadow_type",(nsp_method *) _wrap_gtk_handle_box_get_shadow_type},
  {"set_handle_position",(nsp_method *) _wrap_gtk_handle_box_set_handle_position},
  {"get_handle_position",(nsp_method *) _wrap_gtk_handle_box_get_handle_position},
  {"set_snap_edge",(nsp_method *) _wrap_gtk_handle_box_set_snap_edge},
  {"get_snap_edge",(nsp_method *) _wrap_gtk_handle_box_get_snap_edge},
  { NULL, NULL}
};

static NspMethods *gtkhandlebox_get_methods(void) { return gtkhandlebox_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkhandlebox_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkFrame ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkFrame_Private 
#include "nsp/gtk/gtkframe.h"
#include "nsp/interf.h"

/* NspGtkFrame inherits from NspGtkBin */ 

int nsp_type_gtkframe_id=0;
NspTypeGtkFrame *nsp_type_gtkframe=NULL;

NspTypeGtkFrame *new_type_gtkframe(type_mode mode)
{
  NspTypeGtkFrame *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkframe != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkframe;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkframe_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkframe_get_methods; 
  type->new = (new_func *) new_gtkframe;

  /* specific methods for gtkframe */
      
  type->init = (init_func *) init_gtkframe;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkframe */ 

  top->s_type =  (s_type_func *) gtkframe_type_as_string;    
  top->sh_type = (sh_type_func *) gtkframe_type_short_string;
  /* top->create = (create_func*) int_gtkframe_create;*/ 
  
  /* specific methods for gtkframe */
      
  type->init = (init_func *) init_gtkframe;

  if ( nsp_type_gtkframe_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFrame called nsp_type_gtkframe
       */
      type->id =  nsp_type_gtkframe_id = nsp_new_type_id();
      nsp_type_gtkframe = type;
      if ( nsp_register_type(nsp_type_gtkframe) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkframe, GTK_TYPE_FRAME);
      return ( mode == T_BASE ) ? type : new_type_gtkframe(mode);
    }
  else 
    {
       type->id = nsp_type_gtkframe_id;
       return type;
    }
}

/*
 * initialize GtkFrame instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkframe(NspGtkFrame *o,NspTypeGtkFrame *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkFrame 
 */

NspGtkFrame *new_gtkframe() 
{
  NspGtkFrame *loc; 
  /* type must exists */
  nsp_type_gtkframe = new_type_gtkframe(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFrame)))== NULLGTKFRAME) return loc;
  /* initialize object */
  if ( init_gtkframe(loc,nsp_type_gtkframe) == FAIL) return NULLGTKFRAME;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkFrame 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkframe_type_name[]="GtkFrame";
static char gtkframe_short_type_name[]="GtkFrame";

static char *gtkframe_type_as_string(void)
{
  return(gtkframe_type_name);
}

static char *gtkframe_type_short_string(void)
{
  return(gtkframe_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkFrame objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkFrame   *gtkframe_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkframe_id) ) return ((NspGtkFrame *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkframe));
  return NULL;
}

int IsGtkFrameObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkframe_id);
}

int IsGtkFrame(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkframe_id);
}

NspGtkFrame  *GetGtkFrameCopy(Stack stack, int i)
{
  if (  GetGtkFrame(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFrame  *GetGtkFrame(Stack stack, int i)
{
  NspGtkFrame *M;
  if (( M = gtkframe_object(NthObj(i))) == NULLGTKFRAME)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFrame *gtkframe_copy(NspGtkFrame *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkframe);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkframe);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFrame
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkFrame *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkframe is initialized * /
  nsp_type_gtkframe = new_type_gtkframe(T_BASE);
  if(( H = gtkbin_create(NVOID,(NspTypeBase *) nsp_type_gtkframe)) == NULLGTKFRAME) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkframe_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"label",string,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  char *label = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &label) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_frame_new(label))== NULL) return RET_BUG;

  nsp_type_gtkframe = new_type_gtkframe(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkframe );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_frame_set_label(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *label;

  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
  gtk_frame_set_label(GTK_FRAME(self->obj), label);
  return 0;
}

static int _wrap_gtk_frame_get_label(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_frame_get_label(GTK_FRAME(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_frame_set_label_widget(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *label_widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &label_widget) == FAIL) return RET_BUG;
  gtk_frame_set_label_widget(GTK_FRAME(self->obj), GTK_WIDGET(label_widget->obj));
  return 0;
}

static int _wrap_gtk_frame_get_label_widget(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

  ret = gtk_frame_get_label_widget(GTK_FRAME(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_frame_set_label_align(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, s_double,t_end};
  double xalign, yalign;

  if ( GetArgs(stack,rhs,opt,T,&xalign, &yalign) == FAIL) return RET_BUG;
  gtk_frame_set_label_align(GTK_FRAME(self->obj), xalign, yalign);
  return 0;
}

#line 6183 "gtk.override"
static int
_wrap_gtk_frame_get_label_align(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gfloat xalign, yalign;

  gtk_frame_get_label_align(GTK_FRAME(self->obj), &xalign, &yalign);
  if ( nsp_move_doubles(stack,1,1,2,(double) xalign,(double) yalign) == FAIL) return RET_BUG; 
  return 1;

}
#line 38612 "gtk.c"


static int _wrap_gtk_frame_set_shadow_type(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkShadowType type;
  NspObject *nsp_type = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
  gtk_frame_set_shadow_type(GTK_FRAME(self->obj), type);
  return 0;
}

static int _wrap_gtk_frame_get_shadow_type(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_frame_get_shadow_type(GTK_FRAME(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkframe_methods[] = {
  {"set_label",(nsp_method *) _wrap_gtk_frame_set_label},
  {"get_label",(nsp_method *) _wrap_gtk_frame_get_label},
  {"set_label_widget",(nsp_method *) _wrap_gtk_frame_set_label_widget},
  {"get_label_widget",(nsp_method *) _wrap_gtk_frame_get_label_widget},
  {"set_label_align",(nsp_method *) _wrap_gtk_frame_set_label_align},
  {"get_label_align",(nsp_method *) _wrap_gtk_frame_get_label_align},
  {"set_shadow_type",(nsp_method *) _wrap_gtk_frame_set_shadow_type},
  {"get_shadow_type",(nsp_method *) _wrap_gtk_frame_get_shadow_type},
  { NULL, NULL}
};

static NspMethods *gtkframe_get_methods(void) { return gtkframe_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkframe_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkAspectFrame ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkAspectFrame_Private 
#include "nsp/gtk/gtkaspectframe.h"
#include "nsp/interf.h"

/* NspGtkAspectFrame inherits from NspGtkFrame */ 

int nsp_type_gtkaspectframe_id=0;
NspTypeGtkAspectFrame *nsp_type_gtkaspectframe=NULL;

NspTypeGtkAspectFrame *new_type_gtkaspectframe(type_mode mode)
{
  NspTypeGtkAspectFrame *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkaspectframe != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkaspectframe;
    }
  if ((type =  malloc(sizeof(NspTypeGtkFrame))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkframe(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkaspectframe_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkaspectframe_get_methods; 
  type->new = (new_func *) new_gtkaspectframe;

  /* specific methods for gtkaspectframe */
      
  type->init = (init_func *) init_gtkaspectframe;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkaspectframe */ 

  top->s_type =  (s_type_func *) gtkaspectframe_type_as_string;    
  top->sh_type = (sh_type_func *) gtkaspectframe_type_short_string;
  /* top->create = (create_func*) int_gtkaspectframe_create;*/ 
  
  /* specific methods for gtkaspectframe */
      
  type->init = (init_func *) init_gtkaspectframe;

  if ( nsp_type_gtkaspectframe_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAspectFrame called nsp_type_gtkaspectframe
       */
      type->id =  nsp_type_gtkaspectframe_id = nsp_new_type_id();
      nsp_type_gtkaspectframe = type;
      if ( nsp_register_type(nsp_type_gtkaspectframe) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkaspectframe, GTK_TYPE_ASPECT_FRAME);
      return ( mode == T_BASE ) ? type : new_type_gtkaspectframe(mode);
    }
  else 
    {
       type->id = nsp_type_gtkaspectframe_id;
       return type;
    }
}

/*
 * initialize GtkAspectFrame instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkaspectframe(NspGtkAspectFrame *o,NspTypeGtkAspectFrame *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkAspectFrame 
 */

NspGtkAspectFrame *new_gtkaspectframe() 
{
  NspGtkAspectFrame *loc; 
  /* type must exists */
  nsp_type_gtkaspectframe = new_type_gtkaspectframe(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAspectFrame)))== NULLGTKASPECTFRAME) return loc;
  /* initialize object */
  if ( init_gtkaspectframe(loc,nsp_type_gtkaspectframe) == FAIL) return NULLGTKASPECTFRAME;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkAspectFrame 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkaspectframe_type_name[]="GtkAspectFrame";
static char gtkaspectframe_short_type_name[]="GtkAspectFrame";

static char *gtkaspectframe_type_as_string(void)
{
  return(gtkaspectframe_type_name);
}

static char *gtkaspectframe_type_short_string(void)
{
  return(gtkaspectframe_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkAspectFrame objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkAspectFrame   *gtkaspectframe_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkaspectframe_id) ) return ((NspGtkAspectFrame *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkaspectframe));
  return NULL;
}

int IsGtkAspectFrameObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkaspectframe_id);
}

int IsGtkAspectFrame(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkaspectframe_id);
}

NspGtkAspectFrame  *GetGtkAspectFrameCopy(Stack stack, int i)
{
  if (  GetGtkAspectFrame(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAspectFrame  *GetGtkAspectFrame(Stack stack, int i)
{
  NspGtkAspectFrame *M;
  if (( M = gtkaspectframe_object(NthObj(i))) == NULLGTKASPECTFRAME)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAspectFrame *gtkaspectframe_copy(NspGtkAspectFrame *self)
{
  /* return gtkframe_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaspectframe);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaspectframe);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAspectFrame
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkAspectFrame *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkaspectframe is initialized * /
  nsp_type_gtkaspectframe = new_type_gtkaspectframe(T_BASE);
  if(( H = gtkframe_create(NVOID,(NspTypeBase *) nsp_type_gtkaspectframe)) == NULLGTKASPECTFRAME) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkaspectframe_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"label",string,NULLOBJ,-1}, 
	{"xalign",s_double,NULLOBJ,-1}, 
	{"yalign",s_double,NULLOBJ,-1}, 
	{"ratio",s_double,NULLOBJ,-1}, 
	{"obey_child",s_bool,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  char *label = NULL;
  double xalign = 0.5, yalign = 0.5, ratio = 1;
  int obey_child = TRUE;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &label, &xalign, &yalign, &ratio, &obey_child) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_aspect_frame_new(label, xalign, yalign, ratio, obey_child))== NULL) return RET_BUG;

  nsp_type_gtkaspectframe = new_type_gtkaspectframe(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkaspectframe );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_aspect_frame_set(NspGtkAspectFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"xalign",s_double,NULLOBJ,-1}, 
	{"yalign",s_double,NULLOBJ,-1}, 
	{"ratio",s_double,NULLOBJ,-1}, 
	{"obey_child",s_bool,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int obey_child = 1;
  double xalign = 0.0, yalign = 0.0, ratio = 1.0;

  if ( GetArgs(stack,rhs,opt,T,opts, &xalign, &yalign, &ratio, &obey_child) == FAIL) return RET_BUG;
  gtk_aspect_frame_set(GTK_ASPECT_FRAME(self->obj), xalign, yalign, ratio, obey_child);
  return 0;
}

static NspMethods gtkaspectframe_methods[] = {
  {"set",(nsp_method *) _wrap_gtk_aspect_frame_set},
  { NULL, NULL}
};

static NspMethods *gtkaspectframe_get_methods(void) { return gtkaspectframe_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkaspectframe_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkEventBox ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkEventBox_Private 
#include "nsp/gtk/gtkeventbox.h"
#include "nsp/interf.h"

/* NspGtkEventBox inherits from NspGtkBin */ 

int nsp_type_gtkeventbox_id=0;
NspTypeGtkEventBox *nsp_type_gtkeventbox=NULL;

NspTypeGtkEventBox *new_type_gtkeventbox(type_mode mode)
{
  NspTypeGtkEventBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkeventbox != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkeventbox;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkeventbox_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkeventbox_get_methods; 
  type->new = (new_func *) new_gtkeventbox;

  /* specific methods for gtkeventbox */
      
  type->init = (init_func *) init_gtkeventbox;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkeventbox */ 

  top->s_type =  (s_type_func *) gtkeventbox_type_as_string;    
  top->sh_type = (sh_type_func *) gtkeventbox_type_short_string;
  /* top->create = (create_func*) int_gtkeventbox_create;*/ 
  
  /* specific methods for gtkeventbox */
      
  type->init = (init_func *) init_gtkeventbox;

  if ( nsp_type_gtkeventbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkEventBox called nsp_type_gtkeventbox
       */
      type->id =  nsp_type_gtkeventbox_id = nsp_new_type_id();
      nsp_type_gtkeventbox = type;
      if ( nsp_register_type(nsp_type_gtkeventbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkeventbox, GTK_TYPE_EVENT_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkeventbox(mode);
    }
  else 
    {
       type->id = nsp_type_gtkeventbox_id;
       return type;
    }
}

/*
 * initialize GtkEventBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkeventbox(NspGtkEventBox *o,NspTypeGtkEventBox *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkEventBox 
 */

NspGtkEventBox *new_gtkeventbox() 
{
  NspGtkEventBox *loc; 
  /* type must exists */
  nsp_type_gtkeventbox = new_type_gtkeventbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkEventBox)))== NULLGTKEVENTBOX) return loc;
  /* initialize object */
  if ( init_gtkeventbox(loc,nsp_type_gtkeventbox) == FAIL) return NULLGTKEVENTBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkEventBox 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkeventbox_type_name[]="GtkEventBox";
static char gtkeventbox_short_type_name[]="GtkEventBox";

static char *gtkeventbox_type_as_string(void)
{
  return(gtkeventbox_type_name);
}

static char *gtkeventbox_type_short_string(void)
{
  return(gtkeventbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkEventBox objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkEventBox   *gtkeventbox_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkeventbox_id) ) return ((NspGtkEventBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkeventbox));
  return NULL;
}

int IsGtkEventBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkeventbox_id);
}

int IsGtkEventBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkeventbox_id);
}

NspGtkEventBox  *GetGtkEventBoxCopy(Stack stack, int i)
{
  if (  GetGtkEventBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkEventBox  *GetGtkEventBox(Stack stack, int i)
{
  NspGtkEventBox *M;
  if (( M = gtkeventbox_object(NthObj(i))) == NULLGTKEVENTBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkEventBox *gtkeventbox_copy(NspGtkEventBox *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkeventbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkeventbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkEventBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkEventBox *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkeventbox is initialized * /
  nsp_type_gtkeventbox = new_type_gtkeventbox(T_BASE);
  if(( H = gtkbin_create(NVOID,(NspTypeBase *) nsp_type_gtkeventbox)) == NULLGTKEVENTBOX) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkeventbox_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_event_box_new())== NULL) return RET_BUG;

  nsp_type_gtkeventbox = new_type_gtkeventbox(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkeventbox );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkeventbox_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkeventbox_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkAlignment ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkAlignment_Private 
#include "nsp/gtk/gtkalignment.h"
#include "nsp/interf.h"

/* NspGtkAlignment inherits from NspGtkBin */ 

int nsp_type_gtkalignment_id=0;
NspTypeGtkAlignment *nsp_type_gtkalignment=NULL;

NspTypeGtkAlignment *new_type_gtkalignment(type_mode mode)
{
  NspTypeGtkAlignment *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkalignment != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkalignment;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkalignment_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkalignment_get_methods; 
  type->new = (new_func *) new_gtkalignment;

  /* specific methods for gtkalignment */
      
  type->init = (init_func *) init_gtkalignment;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkalignment */ 

  top->s_type =  (s_type_func *) gtkalignment_type_as_string;    
  top->sh_type = (sh_type_func *) gtkalignment_type_short_string;
  /* top->create = (create_func*) int_gtkalignment_create;*/ 
  
  /* specific methods for gtkalignment */
      
  type->init = (init_func *) init_gtkalignment;

  if ( nsp_type_gtkalignment_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAlignment called nsp_type_gtkalignment
       */
      type->id =  nsp_type_gtkalignment_id = nsp_new_type_id();
      nsp_type_gtkalignment = type;
      if ( nsp_register_type(nsp_type_gtkalignment) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkalignment, GTK_TYPE_ALIGNMENT);
      return ( mode == T_BASE ) ? type : new_type_gtkalignment(mode);
    }
  else 
    {
       type->id = nsp_type_gtkalignment_id;
       return type;
    }
}

/*
 * initialize GtkAlignment instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkalignment(NspGtkAlignment *o,NspTypeGtkAlignment *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkAlignment 
 */

NspGtkAlignment *new_gtkalignment() 
{
  NspGtkAlignment *loc; 
  /* type must exists */
  nsp_type_gtkalignment = new_type_gtkalignment(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAlignment)))== NULLGTKALIGNMENT) return loc;
  /* initialize object */
  if ( init_gtkalignment(loc,nsp_type_gtkalignment) == FAIL) return NULLGTKALIGNMENT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkAlignment 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkalignment_type_name[]="GtkAlignment";
static char gtkalignment_short_type_name[]="GtkAlignment";

static char *gtkalignment_type_as_string(void)
{
  return(gtkalignment_type_name);
}

static char *gtkalignment_type_short_string(void)
{
  return(gtkalignment_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkAlignment objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkAlignment   *gtkalignment_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkalignment_id) ) return ((NspGtkAlignment *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkalignment));
  return NULL;
}

int IsGtkAlignmentObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkalignment_id);
}

int IsGtkAlignment(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkalignment_id);
}

NspGtkAlignment  *GetGtkAlignmentCopy(Stack stack, int i)
{
  if (  GetGtkAlignment(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAlignment  *GetGtkAlignment(Stack stack, int i)
{
  NspGtkAlignment *M;
  if (( M = gtkalignment_object(NthObj(i))) == NULLGTKALIGNMENT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAlignment *gtkalignment_copy(NspGtkAlignment *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkalignment);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkalignment);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAlignment
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkAlignment *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkalignment is initialized * /
  nsp_type_gtkalignment = new_type_gtkalignment(T_BASE);
  if(( H = gtkbin_create(NVOID,(NspTypeBase *) nsp_type_gtkalignment)) == NULLGTKALIGNMENT) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkalignment_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"xalign",s_double,NULLOBJ,-1}, 
	{"yalign",s_double,NULLOBJ,-1}, 
	{"xscale",s_double,NULLOBJ,-1}, 
	{"yscale",s_double,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  double xalign = 0.0, yalign = 0.0, xscale = 0.0, yscale = 0.0;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &xalign, &yalign, &xscale, &yscale) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_alignment_new(xalign, yalign, xscale, yscale))== NULL) return RET_BUG;

  nsp_type_gtkalignment = new_type_gtkalignment(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkalignment );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_alignment_set(NspGtkAlignment *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, s_double, s_double, s_double,t_end};
  double xalign, yalign, xscale, yscale;

  if ( GetArgs(stack,rhs,opt,T,&xalign, &yalign, &xscale, &yscale) == FAIL) return RET_BUG;
  gtk_alignment_set(GTK_ALIGNMENT(self->obj), xalign, yalign, xscale, yscale);
  return 0;
}

static NspMethods gtkalignment_methods[] = {
  {"set",(nsp_method *) _wrap_gtk_alignment_set},
  { NULL, NULL}
};

static NspMethods *gtkalignment_get_methods(void) { return gtkalignment_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkalignment_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkButton ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkButton_Private 
#include "nsp/gtk/gtkbutton.h"
#include "nsp/interf.h"

/* NspGtkButton inherits from NspGtkBin */ 

int nsp_type_gtkbutton_id=0;
NspTypeGtkButton *nsp_type_gtkbutton=NULL;

NspTypeGtkButton *new_type_gtkbutton(type_mode mode)
{
  NspTypeGtkButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkbutton != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkbutton;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkbutton_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkbutton_get_methods; 
  type->new = (new_func *) new_gtkbutton;

  /* specific methods for gtkbutton */
      
  type->init = (init_func *) init_gtkbutton;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkbutton */ 

  top->s_type =  (s_type_func *) gtkbutton_type_as_string;    
  top->sh_type = (sh_type_func *) gtkbutton_type_short_string;
  /* top->create = (create_func*) int_gtkbutton_create;*/ 
  
  /* specific methods for gtkbutton */
      
  type->init = (init_func *) init_gtkbutton;

  if ( nsp_type_gtkbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkButton called nsp_type_gtkbutton
       */
      type->id =  nsp_type_gtkbutton_id = nsp_new_type_id();
      nsp_type_gtkbutton = type;
      if ( nsp_register_type(nsp_type_gtkbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkbutton, GTK_TYPE_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkbutton(mode);
    }
  else 
    {
       type->id = nsp_type_gtkbutton_id;
       return type;
    }
}

/*
 * initialize GtkButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkbutton(NspGtkButton *o,NspTypeGtkButton *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkButton 
 */

NspGtkButton *new_gtkbutton() 
{
  NspGtkButton *loc; 
  /* type must exists */
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkButton)))== NULLGTKBUTTON) return loc;
  /* initialize object */
  if ( init_gtkbutton(loc,nsp_type_gtkbutton) == FAIL) return NULLGTKBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkButton 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkbutton_type_name[]="GtkButton";
static char gtkbutton_short_type_name[]="GtkButton";

static char *gtkbutton_type_as_string(void)
{
  return(gtkbutton_type_name);
}

static char *gtkbutton_type_short_string(void)
{
  return(gtkbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkButton objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkButton   *gtkbutton_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkbutton_id) ) return ((NspGtkButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkbutton));
  return NULL;
}

int IsGtkButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkbutton_id);
}

int IsGtkButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkbutton_id);
}

NspGtkButton  *GetGtkButtonCopy(Stack stack, int i)
{
  if (  GetGtkButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkButton  *GetGtkButton(Stack stack, int i)
{
  NspGtkButton *M;
  if (( M = gtkbutton_object(NthObj(i))) == NULLGTKBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkButton *gtkbutton_copy(NspGtkButton *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkButton *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkbutton is initialized * /
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  if(( H = gtkbin_create(NVOID,(NspTypeBase *) nsp_type_gtkbutton)) == NULLGTKBUTTON) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 4168 "gtk.override"
/* OK */
static int
_wrap_gtkbutton_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"mnemonic",string,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {"stock",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };

  gchar *mnemonic = NULL, *label = NULL, *stock = NULL;

  if (GetArgs(stack,rhs,opt,T, &opts,&mnemonic, &label, &stock) == FAIL)  return RET_BUG;
  if (stock)  
    gobj = (GObject *)gtk_button_new_from_stock(stock);
  else if (mnemonic)
    gobj = (GObject *)gtk_button_new_with_mnemonic(mnemonic);
  else if (label) 
    gobj = (GObject *)gtk_button_new_with_mnemonic(label);
  else 
    gobj = (GObject *)gtk_button_new();
  if (gobj == NULL ) {
    Scierror( "%s: could not create GtkButton object",stack.fname);
    return RET_BUG;
  }
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtkbutton))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
#line 39587 "gtk.c"


static int _wrap_gtk_button_pressed(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_button_pressed(GTK_BUTTON(self->obj));
  return 0;
}

static int _wrap_gtk_button_released(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_button_released(GTK_BUTTON(self->obj));
  return 0;
}

static int _wrap_gtk_button_clicked(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_button_clicked(GTK_BUTTON(self->obj));
  return 0;
}

static int _wrap_gtk_button_enter(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_button_enter(GTK_BUTTON(self->obj));
  return 0;
}

static int _wrap_gtk_button_leave(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_button_leave(GTK_BUTTON(self->obj));
  return 0;
}

static int _wrap_gtk_button_set_relief(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkReliefStyle newstyle;
  NspObject *nsp_newstyle = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_newstyle) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_RELIEF_STYLE, nsp_newstyle, &newstyle)== FAIL)
      return RET_BUG;
  gtk_button_set_relief(GTK_BUTTON(self->obj), newstyle);
  return 0;
}

static int _wrap_gtk_button_get_relief(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_button_get_relief(GTK_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_button_set_label(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *label;

  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
  gtk_button_set_label(GTK_BUTTON(self->obj), label);
  return 0;
}

static int _wrap_gtk_button_get_label(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_button_get_label(GTK_BUTTON(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_button_set_use_underline(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int use_underline;

  if ( GetArgs(stack,rhs,opt,T,&use_underline) == FAIL) return RET_BUG;
  gtk_button_set_use_underline(GTK_BUTTON(self->obj), use_underline);
  return 0;
}

static int _wrap_gtk_button_get_use_underline(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_button_get_use_underline(GTK_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_button_set_use_stock(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int use_stock;

  if ( GetArgs(stack,rhs,opt,T,&use_stock) == FAIL) return RET_BUG;
  gtk_button_set_use_stock(GTK_BUTTON(self->obj), use_stock);
  return 0;
}

static int _wrap_gtk_button_get_use_stock(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_button_get_use_stock(GTK_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkbutton_methods[] = {
  {"pressed",(nsp_method *) _wrap_gtk_button_pressed},
  {"released",(nsp_method *) _wrap_gtk_button_released},
  {"clicked",(nsp_method *) _wrap_gtk_button_clicked},
  {"enter",(nsp_method *) _wrap_gtk_button_enter},
  {"leave",(nsp_method *) _wrap_gtk_button_leave},
  {"set_relief",(nsp_method *) _wrap_gtk_button_set_relief},
  {"get_relief",(nsp_method *) _wrap_gtk_button_get_relief},
  {"set_label",(nsp_method *) _wrap_gtk_button_set_label},
  {"get_label",(nsp_method *) _wrap_gtk_button_get_label},
  {"set_use_underline",(nsp_method *) _wrap_gtk_button_set_use_underline},
  {"get_use_underline",(nsp_method *) _wrap_gtk_button_get_use_underline},
  {"set_use_stock",(nsp_method *) _wrap_gtk_button_set_use_stock},
  {"get_use_stock",(nsp_method *) _wrap_gtk_button_get_use_stock},
  { NULL, NULL}
};

static NspMethods *gtkbutton_get_methods(void) { return gtkbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkbutton_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkToggleButton ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkToggleButton_Private 
#include "nsp/gtk/gtktogglebutton.h"
#include "nsp/interf.h"

/* NspGtkToggleButton inherits from NspGtkButton */ 

int nsp_type_gtktogglebutton_id=0;
NspTypeGtkToggleButton *nsp_type_gtktogglebutton=NULL;

NspTypeGtkToggleButton *new_type_gtktogglebutton(type_mode mode)
{
  NspTypeGtkToggleButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktogglebutton != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktogglebutton;
    }
  if ((type =  malloc(sizeof(NspTypeGtkButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktogglebutton_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtktogglebutton_get_methods; 
  type->new = (new_func *) new_gtktogglebutton;

  /* specific methods for gtktogglebutton */
      
  type->init = (init_func *) init_gtktogglebutton;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtktogglebutton */ 

  top->s_type =  (s_type_func *) gtktogglebutton_type_as_string;    
  top->sh_type = (sh_type_func *) gtktogglebutton_type_short_string;
  /* top->create = (create_func*) int_gtktogglebutton_create;*/ 
  
  /* specific methods for gtktogglebutton */
      
  type->init = (init_func *) init_gtktogglebutton;

  if ( nsp_type_gtktogglebutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkToggleButton called nsp_type_gtktogglebutton
       */
      type->id =  nsp_type_gtktogglebutton_id = nsp_new_type_id();
      nsp_type_gtktogglebutton = type;
      if ( nsp_register_type(nsp_type_gtktogglebutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktogglebutton, GTK_TYPE_TOGGLE_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtktogglebutton(mode);
    }
  else 
    {
       type->id = nsp_type_gtktogglebutton_id;
       return type;
    }
}

/*
 * initialize GtkToggleButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktogglebutton(NspGtkToggleButton *o,NspTypeGtkToggleButton *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkToggleButton 
 */

NspGtkToggleButton *new_gtktogglebutton() 
{
  NspGtkToggleButton *loc; 
  /* type must exists */
  nsp_type_gtktogglebutton = new_type_gtktogglebutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkToggleButton)))== NULLGTKTOGGLEBUTTON) return loc;
  /* initialize object */
  if ( init_gtktogglebutton(loc,nsp_type_gtktogglebutton) == FAIL) return NULLGTKTOGGLEBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkToggleButton 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtktogglebutton_type_name[]="GtkToggleButton";
static char gtktogglebutton_short_type_name[]="GtkToggleButton";

static char *gtktogglebutton_type_as_string(void)
{
  return(gtktogglebutton_type_name);
}

static char *gtktogglebutton_type_short_string(void)
{
  return(gtktogglebutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkToggleButton objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkToggleButton   *gtktogglebutton_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtktogglebutton_id) ) return ((NspGtkToggleButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktogglebutton));
  return NULL;
}

int IsGtkToggleButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtktogglebutton_id);
}

int IsGtkToggleButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktogglebutton_id);
}

NspGtkToggleButton  *GetGtkToggleButtonCopy(Stack stack, int i)
{
  if (  GetGtkToggleButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkToggleButton  *GetGtkToggleButton(Stack stack, int i)
{
  NspGtkToggleButton *M;
  if (( M = gtktogglebutton_object(NthObj(i))) == NULLGTKTOGGLEBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkToggleButton *gtktogglebutton_copy(NspGtkToggleButton *self)
{
  /* return gtkbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktogglebutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktogglebutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkToggleButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkToggleButton *H;
  CheckRhs(0,0);
  / * want to be sure that type gtktogglebutton is initialized * /
  nsp_type_gtktogglebutton = new_type_gtktogglebutton(T_BASE);
  if(( H = gtkbutton_create(NVOID,(NspTypeBase *) nsp_type_gtktogglebutton)) == NULLGTKTOGGLEBUTTON) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 4228 "gtk.override"
/* OK */
static int
_wrap_gtktogglebutton_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"mnemonic",string,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };

  gchar *mnemonic = NULL, *label = NULL;

  if (GetArgs(stack,rhs,opt,T, &opts,&mnemonic, &label) == FAIL)  return RET_BUG;
  if (mnemonic)
    gobj = (GObject *)gtk_toggle_button_new_with_mnemonic(mnemonic);
  else if (label) 
    gobj = (GObject *)gtk_toggle_button_new_with_mnemonic(label);
  else 
    gobj = (GObject *)gtk_button_new();
  if (gobj == NULL ) {
    Scierror( "%s: could not create GtkToggleButton object",stack.fname);
    return RET_BUG;
  }
  nsp_type_gtktogglebutton = new_type_gtktogglebutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtktogglebutton))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
#line 39948 "gtk.c"


static int _wrap_gtk_toggle_button_set_mode(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int draw_indicator;

  if ( GetArgs(stack,rhs,opt,T,&draw_indicator) == FAIL) return RET_BUG;
  gtk_toggle_button_set_mode(GTK_TOGGLE_BUTTON(self->obj), draw_indicator);
  return 0;
}

static int _wrap_gtk_toggle_button_get_mode(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_toggle_button_get_mode(GTK_TOGGLE_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toggle_button_set_active(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int is_active;

  if ( GetArgs(stack,rhs,opt,T,&is_active) == FAIL) return RET_BUG;
  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self->obj), is_active);
  return 0;
}

static int _wrap_gtk_toggle_button_get_active(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toggle_button_toggled(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_toggle_button_toggled(GTK_TOGGLE_BUTTON(self->obj));
  return 0;
}

static int _wrap_gtk_toggle_button_set_inconsistent(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_toggle_button_set_inconsistent(GTK_TOGGLE_BUTTON(self->obj), setting);
  return 0;
}

static int _wrap_gtk_toggle_button_get_inconsistent(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_toggle_button_get_inconsistent(GTK_TOGGLE_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toggle_button_set_state(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int is_active;

  if ( GetArgs(stack,rhs,opt,T,&is_active) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkToggleButton.set_active",stack.fname); return RET_BUG;
  gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(self->obj), is_active);
  return 0;
}

static NspMethods gtktogglebutton_methods[] = {
  {"set_mode",(nsp_method *) _wrap_gtk_toggle_button_set_mode},
  {"get_mode",(nsp_method *) _wrap_gtk_toggle_button_get_mode},
  {"set_active",(nsp_method *) _wrap_gtk_toggle_button_set_active},
  {"get_active",(nsp_method *) _wrap_gtk_toggle_button_get_active},
  {"toggled",(nsp_method *) _wrap_gtk_toggle_button_toggled},
  {"set_inconsistent",(nsp_method *) _wrap_gtk_toggle_button_set_inconsistent},
  {"get_inconsistent",(nsp_method *) _wrap_gtk_toggle_button_get_inconsistent},
  {"set_state",(nsp_method *) _wrap_gtk_toggle_button_set_state},
  { NULL, NULL}
};

static NspMethods *gtktogglebutton_get_methods(void) { return gtktogglebutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_toggle_button__get_draw_indicator(NspObject *self,char *attr)
{
  int ret;
  NspObject *nsp_ret;

  ret = (gboolean) GTK_TOGGLE_BUTTON(NSP_GOBJECT_GET(self))->draw_indicator;
  nsp_ret= (ret == TRUE) ? nsp_create_true_object(NVOID) : nsp_create_false_object(NVOID);
  return nsp_ret;
}

static AttrTab gtktogglebutton_attrs[] = {
  { "draw_indicator", (attr_get_function *)_wrap_gtk_toggle_button__get_draw_indicator, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkCheckButton ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkCheckButton_Private 
#include "nsp/gtk/gtkcheckbutton.h"
#include "nsp/interf.h"

/* NspGtkCheckButton inherits from NspGtkToggleButton */ 

int nsp_type_gtkcheckbutton_id=0;
NspTypeGtkCheckButton *nsp_type_gtkcheckbutton=NULL;

NspTypeGtkCheckButton *new_type_gtkcheckbutton(type_mode mode)
{
  NspTypeGtkCheckButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcheckbutton != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcheckbutton;
    }
  if ((type =  malloc(sizeof(NspTypeGtkToggleButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtktogglebutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcheckbutton_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcheckbutton_get_methods; 
  type->new = (new_func *) new_gtkcheckbutton;

  /* specific methods for gtkcheckbutton */
      
  type->init = (init_func *) init_gtkcheckbutton;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcheckbutton */ 

  top->s_type =  (s_type_func *) gtkcheckbutton_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcheckbutton_type_short_string;
  /* top->create = (create_func*) int_gtkcheckbutton_create;*/ 
  
  /* specific methods for gtkcheckbutton */
      
  type->init = (init_func *) init_gtkcheckbutton;

  if ( nsp_type_gtkcheckbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCheckButton called nsp_type_gtkcheckbutton
       */
      type->id =  nsp_type_gtkcheckbutton_id = nsp_new_type_id();
      nsp_type_gtkcheckbutton = type;
      if ( nsp_register_type(nsp_type_gtkcheckbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcheckbutton, GTK_TYPE_CHECK_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkcheckbutton(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcheckbutton_id;
       return type;
    }
}

/*
 * initialize GtkCheckButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcheckbutton(NspGtkCheckButton *o,NspTypeGtkCheckButton *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkCheckButton 
 */

NspGtkCheckButton *new_gtkcheckbutton() 
{
  NspGtkCheckButton *loc; 
  /* type must exists */
  nsp_type_gtkcheckbutton = new_type_gtkcheckbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCheckButton)))== NULLGTKCHECKBUTTON) return loc;
  /* initialize object */
  if ( init_gtkcheckbutton(loc,nsp_type_gtkcheckbutton) == FAIL) return NULLGTKCHECKBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkCheckButton 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcheckbutton_type_name[]="GtkCheckButton";
static char gtkcheckbutton_short_type_name[]="GtkCheckButton";

static char *gtkcheckbutton_type_as_string(void)
{
  return(gtkcheckbutton_type_name);
}

static char *gtkcheckbutton_type_short_string(void)
{
  return(gtkcheckbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkCheckButton objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkCheckButton   *gtkcheckbutton_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcheckbutton_id) ) return ((NspGtkCheckButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcheckbutton));
  return NULL;
}

int IsGtkCheckButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcheckbutton_id);
}

int IsGtkCheckButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcheckbutton_id);
}

NspGtkCheckButton  *GetGtkCheckButtonCopy(Stack stack, int i)
{
  if (  GetGtkCheckButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCheckButton  *GetGtkCheckButton(Stack stack, int i)
{
  NspGtkCheckButton *M;
  if (( M = gtkcheckbutton_object(NthObj(i))) == NULLGTKCHECKBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCheckButton *gtkcheckbutton_copy(NspGtkCheckButton *self)
{
  /* return gtktogglebutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcheckbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcheckbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCheckButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkCheckButton *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcheckbutton is initialized * /
  nsp_type_gtkcheckbutton = new_type_gtkcheckbutton(T_BASE);
  if(( H = gtktogglebutton_create(NVOID,(NspTypeBase *) nsp_type_gtkcheckbutton)) == NULLGTKCHECKBUTTON) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 4262 "gtk.override"
static int
_wrap_gtkcheckbutton_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"mnemonic",string,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };

  gchar *mnemonic = NULL, *label = NULL;

  if (GetArgs(stack,rhs,opt,T, &opts,&mnemonic, &label) == FAIL)  return RET_BUG;
  if (mnemonic)
    gobj = (GObject *)gtk_check_button_new_with_mnemonic(mnemonic);
  else if (label) 
    gobj = (GObject *)gtk_check_button_new_with_mnemonic(label);
  else 
    gobj = (GObject *)gtk_button_new();
  if (gobj == NULL ) {
    Scierror( "%s: could not create GtkToggleButton object",stack.fname);
    return RET_BUG;
  }
  nsp_type_gtkcheckbutton = new_type_gtkcheckbutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtkcheckbutton))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
#line 40282 "gtk.c"


static NspMethods *gtkcheckbutton_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcheckbutton_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkRadioButton ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkRadioButton_Private 
#include "nsp/gtk/gtkradiobutton.h"
#include "nsp/interf.h"

/* NspGtkRadioButton inherits from NspGtkCheckButton */ 

int nsp_type_gtkradiobutton_id=0;
NspTypeGtkRadioButton *nsp_type_gtkradiobutton=NULL;

NspTypeGtkRadioButton *new_type_gtkradiobutton(type_mode mode)
{
  NspTypeGtkRadioButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkradiobutton != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkradiobutton;
    }
  if ((type =  malloc(sizeof(NspTypeGtkCheckButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcheckbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkradiobutton_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkradiobutton_get_methods; 
  type->new = (new_func *) new_gtkradiobutton;

  /* specific methods for gtkradiobutton */
      
  type->init = (init_func *) init_gtkradiobutton;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkradiobutton */ 

  top->s_type =  (s_type_func *) gtkradiobutton_type_as_string;    
  top->sh_type = (sh_type_func *) gtkradiobutton_type_short_string;
  /* top->create = (create_func*) int_gtkradiobutton_create;*/ 
  
  /* specific methods for gtkradiobutton */
      
  type->init = (init_func *) init_gtkradiobutton;

  if ( nsp_type_gtkradiobutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRadioButton called nsp_type_gtkradiobutton
       */
      type->id =  nsp_type_gtkradiobutton_id = nsp_new_type_id();
      nsp_type_gtkradiobutton = type;
      if ( nsp_register_type(nsp_type_gtkradiobutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkradiobutton, GTK_TYPE_RADIO_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkradiobutton(mode);
    }
  else 
    {
       type->id = nsp_type_gtkradiobutton_id;
       return type;
    }
}

/*
 * initialize GtkRadioButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkradiobutton(NspGtkRadioButton *o,NspTypeGtkRadioButton *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkRadioButton 
 */

NspGtkRadioButton *new_gtkradiobutton() 
{
  NspGtkRadioButton *loc; 
  /* type must exists */
  nsp_type_gtkradiobutton = new_type_gtkradiobutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRadioButton)))== NULLGTKRADIOBUTTON) return loc;
  /* initialize object */
  if ( init_gtkradiobutton(loc,nsp_type_gtkradiobutton) == FAIL) return NULLGTKRADIOBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkRadioButton 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkradiobutton_type_name[]="GtkRadioButton";
static char gtkradiobutton_short_type_name[]="GtkRadioButton";

static char *gtkradiobutton_type_as_string(void)
{
  return(gtkradiobutton_type_name);
}

static char *gtkradiobutton_type_short_string(void)
{
  return(gtkradiobutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkRadioButton objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkRadioButton   *gtkradiobutton_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkradiobutton_id) ) return ((NspGtkRadioButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkradiobutton));
  return NULL;
}

int IsGtkRadioButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkradiobutton_id);
}

int IsGtkRadioButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkradiobutton_id);
}

NspGtkRadioButton  *GetGtkRadioButtonCopy(Stack stack, int i)
{
  if (  GetGtkRadioButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRadioButton  *GetGtkRadioButton(Stack stack, int i)
{
  NspGtkRadioButton *M;
  if (( M = gtkradiobutton_object(NthObj(i))) == NULLGTKRADIOBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRadioButton *gtkradiobutton_copy(NspGtkRadioButton *self)
{
  /* return gtkcheckbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradiobutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradiobutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRadioButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkRadioButton *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkradiobutton is initialized * /
  nsp_type_gtkradiobutton = new_type_gtkradiobutton(T_BASE);
  if(( H = gtkcheckbutton_create(NVOID,(NspTypeBase *) nsp_type_gtkradiobutton)) == NULLGTKRADIOBUTTON) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 4295 "gtk.override"
static int
_wrap_gtkradiobutton_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  GtkRadioButton *group= NULL;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"group",obj,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };
  NspObject *nsp_group = NULL;
  gchar *label = NULL;
  if (GetArgs(stack,rhs,opt,T, &opts,&nsp_group, &label) == FAIL)  return RET_BUG;

  if ( nsp_group != NULL )
    {
      if (nspgobject_check(nsp_group,nsp_type_gtkradiobutton))
	group = GTK_RADIO_BUTTON(nspgobject_get(nsp_group));
      else {
	Scierror("group argument must be a GtkRadioButton");
	return RET_BUG;
      }
    }
  
  if (label == NULL) {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_button_new(NULL);
    else
      gobj = (GObject *)gtk_radio_button_new_from_widget( group);
  } else {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_button_new_with_mnemonic(NULL,label);
    else
      gobj = (GObject *)gtk_radio_button_new_with_mnemonic_from_widget(group, label);
  }
  if (!gobj) {
    Scierror( "could not create GtkRadioButton object");
    return RET_BUG;
  }
  nsp_type_gtkradiobutton = new_type_gtkradiobutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtkradiobutton))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
#line 40532 "gtk.c"


#line 4342 "gtk.override"
static int
_wrap_gtk_radio_button_get_group(NspGObject *self,Stack stack,int rhs,int opt,int lhs) {
  NspList *nsp_list;
  GSList *list, *tmp;
  Cell *cloc = NULLCELL,*cloc1=NULLCELL; 
  list = gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj));
  NSP_LIST_FROM_GLIST( gobject_gettype_and_create("lel",G_OBJECT(tmp->data)),g_slist_free);
}

#line 40545 "gtk.c"


static NspMethods gtkradiobutton_methods[] = {
  {"get_group",(nsp_method *) _wrap_gtk_radio_button_get_group},
  { NULL, NULL}
};

static NspMethods *gtkradiobutton_get_methods(void) { return gtkradiobutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkradiobutton_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkOptionMenu ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkOptionMenu_Private 
#include "nsp/gtk/gtkoptionmenu.h"
#include "nsp/interf.h"

/* NspGtkOptionMenu inherits from NspGtkButton */ 

int nsp_type_gtkoptionmenu_id=0;
NspTypeGtkOptionMenu *nsp_type_gtkoptionmenu=NULL;

NspTypeGtkOptionMenu *new_type_gtkoptionmenu(type_mode mode)
{
  NspTypeGtkOptionMenu *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkoptionmenu != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkoptionmenu;
    }
  if ((type =  malloc(sizeof(NspTypeGtkButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkoptionmenu_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkoptionmenu_get_methods; 
  type->new = (new_func *) new_gtkoptionmenu;

  /* specific methods for gtkoptionmenu */
      
  type->init = (init_func *) init_gtkoptionmenu;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkoptionmenu */ 

  top->s_type =  (s_type_func *) gtkoptionmenu_type_as_string;    
  top->sh_type = (sh_type_func *) gtkoptionmenu_type_short_string;
  /* top->create = (create_func*) int_gtkoptionmenu_create;*/ 
  
  /* specific methods for gtkoptionmenu */
      
  type->init = (init_func *) init_gtkoptionmenu;

  if ( nsp_type_gtkoptionmenu_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkOptionMenu called nsp_type_gtkoptionmenu
       */
      type->id =  nsp_type_gtkoptionmenu_id = nsp_new_type_id();
      nsp_type_gtkoptionmenu = type;
      if ( nsp_register_type(nsp_type_gtkoptionmenu) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkoptionmenu, GTK_TYPE_OPTION_MENU);
      return ( mode == T_BASE ) ? type : new_type_gtkoptionmenu(mode);
    }
  else 
    {
       type->id = nsp_type_gtkoptionmenu_id;
       return type;
    }
}

/*
 * initialize GtkOptionMenu instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkoptionmenu(NspGtkOptionMenu *o,NspTypeGtkOptionMenu *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkOptionMenu 
 */

NspGtkOptionMenu *new_gtkoptionmenu() 
{
  NspGtkOptionMenu *loc; 
  /* type must exists */
  nsp_type_gtkoptionmenu = new_type_gtkoptionmenu(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkOptionMenu)))== NULLGTKOPTIONMENU) return loc;
  /* initialize object */
  if ( init_gtkoptionmenu(loc,nsp_type_gtkoptionmenu) == FAIL) return NULLGTKOPTIONMENU;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkOptionMenu 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkoptionmenu_type_name[]="GtkOptionMenu";
static char gtkoptionmenu_short_type_name[]="GtkOptionMenu";

static char *gtkoptionmenu_type_as_string(void)
{
  return(gtkoptionmenu_type_name);
}

static char *gtkoptionmenu_type_short_string(void)
{
  return(gtkoptionmenu_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkOptionMenu objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkOptionMenu   *gtkoptionmenu_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkoptionmenu_id) ) return ((NspGtkOptionMenu *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkoptionmenu));
  return NULL;
}

int IsGtkOptionMenuObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkoptionmenu_id);
}

int IsGtkOptionMenu(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkoptionmenu_id);
}

NspGtkOptionMenu  *GetGtkOptionMenuCopy(Stack stack, int i)
{
  if (  GetGtkOptionMenu(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkOptionMenu  *GetGtkOptionMenu(Stack stack, int i)
{
  NspGtkOptionMenu *M;
  if (( M = gtkoptionmenu_object(NthObj(i))) == NULLGTKOPTIONMENU)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkOptionMenu *gtkoptionmenu_copy(NspGtkOptionMenu *self)
{
  /* return gtkbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkoptionmenu);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkoptionmenu);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkOptionMenu
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkOptionMenu *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkoptionmenu is initialized * /
  nsp_type_gtkoptionmenu = new_type_gtkoptionmenu(T_BASE);
  if(( H = gtkbutton_create(NVOID,(NspTypeBase *) nsp_type_gtkoptionmenu)) == NULLGTKOPTIONMENU) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkoptionmenu_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_option_menu_new())== NULL) return RET_BUG;

  nsp_type_gtkoptionmenu = new_type_gtkoptionmenu(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkoptionmenu );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_option_menu_get_menu(NspGtkOptionMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

  ret = gtk_option_menu_get_menu(GTK_OPTION_MENU(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_option_menu_set_menu(NspGtkOptionMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *menu;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &menu) == FAIL) return RET_BUG;
  gtk_option_menu_set_menu(GTK_OPTION_MENU(self->obj), GTK_WIDGET(menu->obj));
  return 0;
}

static int _wrap_gtk_option_menu_remove_menu(NspGtkOptionMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_option_menu_remove_menu(GTK_OPTION_MENU(self->obj));
  return 0;
}

static int _wrap_gtk_option_menu_get_history(NspGtkOptionMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_option_menu_get_history(GTK_OPTION_MENU(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_option_menu_set_history(NspGtkOptionMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int index;

  if ( GetArgs(stack,rhs,opt,T,&index) == FAIL) return RET_BUG;
  gtk_option_menu_set_history(GTK_OPTION_MENU(self->obj), index);
  return 0;
}

static NspMethods gtkoptionmenu_methods[] = {
  {"get_menu",(nsp_method *) _wrap_gtk_option_menu_get_menu},
  {"set_menu",(nsp_method *) _wrap_gtk_option_menu_set_menu},
  {"remove_menu",(nsp_method *) _wrap_gtk_option_menu_remove_menu},
  {"get_history",(nsp_method *) _wrap_gtk_option_menu_get_history},
  {"set_history",(nsp_method *) _wrap_gtk_option_menu_set_history},
  { NULL, NULL}
};

static NspMethods *gtkoptionmenu_get_methods(void) { return gtkoptionmenu_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkoptionmenu_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkBox ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkBox_Private 
#include "nsp/gtk/gtkbox.h"
#include "nsp/interf.h"

/* NspGtkBox inherits from NspGtkContainer */ 

int nsp_type_gtkbox_id=0;
NspTypeGtkBox *nsp_type_gtkbox=NULL;

NspTypeGtkBox *new_type_gtkbox(type_mode mode)
{
  NspTypeGtkBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkbox != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkbox;
    }
  if ((type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkbox_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkbox_get_methods; 
  type->new = (new_func *) new_gtkbox;

  /* specific methods for gtkbox */
      
  type->init = (init_func *) init_gtkbox;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkbox */ 

  top->s_type =  (s_type_func *) gtkbox_type_as_string;    
  top->sh_type = (sh_type_func *) gtkbox_type_short_string;
  /* top->create = (create_func*) int_gtkbox_create;*/ 
  
  /* specific methods for gtkbox */
      
  type->init = (init_func *) init_gtkbox;

  if ( nsp_type_gtkbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkBox called nsp_type_gtkbox
       */
      type->id =  nsp_type_gtkbox_id = nsp_new_type_id();
      nsp_type_gtkbox = type;
      if ( nsp_register_type(nsp_type_gtkbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkbox, GTK_TYPE_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkbox(mode);
    }
  else 
    {
       type->id = nsp_type_gtkbox_id;
       return type;
    }
}

/*
 * initialize GtkBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkbox(NspGtkBox *o,NspTypeGtkBox *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkBox 
 */

NspGtkBox *new_gtkbox() 
{
  NspGtkBox *loc; 
  /* type must exists */
  nsp_type_gtkbox = new_type_gtkbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkBox)))== NULLGTKBOX) return loc;
  /* initialize object */
  if ( init_gtkbox(loc,nsp_type_gtkbox) == FAIL) return NULLGTKBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkBox 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkbox_type_name[]="GtkBox";
static char gtkbox_short_type_name[]="GtkBox";

static char *gtkbox_type_as_string(void)
{
  return(gtkbox_type_name);
}

static char *gtkbox_type_short_string(void)
{
  return(gtkbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkBox objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkBox   *gtkbox_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkbox_id) ) return ((NspGtkBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkbox));
  return NULL;
}

int IsGtkBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkbox_id);
}

int IsGtkBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkbox_id);
}

NspGtkBox  *GetGtkBoxCopy(Stack stack, int i)
{
  if (  GetGtkBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkBox  *GetGtkBox(Stack stack, int i)
{
  NspGtkBox *M;
  if (( M = gtkbox_object(NthObj(i))) == NULLGTKBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkBox *gtkbox_copy(NspGtkBox *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkBox *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkbox is initialized * /
  nsp_type_gtkbox = new_type_gtkbox(T_BASE);
  if(( H = gtkcontainer_create(NVOID,(NspTypeBase *) nsp_type_gtkbox)) == NULLGTKBOX) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_box_pack_start(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,new_opts,t_end};
  nsp_option opts[] = {
	{"expand",s_bool,NULLOBJ,-1}, 
	{"fill",s_bool,NULLOBJ,-1}, 
	{"padding",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int expand = TRUE, fill = TRUE, padding = 0;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, opts, &expand, &fill, &padding) == FAIL) return RET_BUG;
  gtk_box_pack_start(GTK_BOX(self->obj), GTK_WIDGET(child->obj), expand, fill, padding);
  return 0;
}

static int _wrap_gtk_box_pack_end(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,new_opts,t_end};
  nsp_option opts[] = {
	{"expand",s_bool,NULLOBJ,-1}, 
	{"fill",s_bool,NULLOBJ,-1}, 
	{"padding",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int expand = TRUE, fill = TRUE, padding = 0;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, opts, &expand, &fill, &padding) == FAIL) return RET_BUG;
  gtk_box_pack_end(GTK_BOX(self->obj), GTK_WIDGET(child->obj), expand, fill, padding);
  return 0;
}

static int _wrap_gtk_box_pack_start_defaults(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
  gtk_box_pack_start_defaults(GTK_BOX(self->obj), GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_box_pack_end_defaults(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
  gtk_box_pack_end_defaults(GTK_BOX(self->obj), GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_box_set_homogeneous(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int homogeneous;

  if ( GetArgs(stack,rhs,opt,T,&homogeneous) == FAIL) return RET_BUG;
  gtk_box_set_homogeneous(GTK_BOX(self->obj), homogeneous);
  return 0;
}

static int _wrap_gtk_box_get_homogeneous(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_box_get_homogeneous(GTK_BOX(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_box_set_spacing(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int spacing;

  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
  gtk_box_set_spacing(GTK_BOX(self->obj), spacing);
  return 0;
}

static int _wrap_gtk_box_get_spacing(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_box_get_spacing(GTK_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_box_reorder_child(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int,t_end};
  int position;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &position) == FAIL) return RET_BUG;
  gtk_box_reorder_child(GTK_BOX(self->obj), GTK_WIDGET(child->obj), position);
  return 0;
}

#line 1466 "gtk.override"
static int
_wrap_gtk_box_query_child_packing(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end} ;
  /* static char *kwlist[] = { "child", NULL };*/
  NspGObject *pychild;
  GtkWidget *child;
  GList *children;
  gboolean expand, fill;
  guint padding;
  GtkPackType pack_type;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &pychild)== FAIL) return RET_BUG;

  child = GTK_WIDGET(pychild->obj);
  children = gtk_container_get_children(GTK_CONTAINER(self->obj));
  if (g_list_find(children, child) == NULL) {
    Scierror(
	     "first argument must be a child");
    return RET_BUG;
  }
  gtk_box_query_child_packing(GTK_BOX(self->obj),
			      child, &expand, &fill,
			      &padding, &pack_type);
  if (  nsp_move_doubles(stack,1,4,1,(double) expand,(double) fill,(double) padding, (double)pack_type ) == FAIL) 
    return RET_BUG; 
  return 1; 
}
#line 41155 "gtk.c"


static int _wrap_gtk_box_set_child_packing(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_bool, s_bool, s_int, obj,t_end};
  int expand, fill, padding;
  NspGObject *child;
  GtkPackType pack_type;
  NspObject *nsp_pack_type = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &expand, &fill, &padding, &nsp_pack_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_PACK_TYPE, nsp_pack_type, &pack_type)== FAIL)
      return RET_BUG;
  gtk_box_set_child_packing(GTK_BOX(self->obj), GTK_WIDGET(child->obj), expand, fill, padding, pack_type);
  return 0;
}

static NspMethods gtkbox_methods[] = {
  {"pack_start",(nsp_method *) _wrap_gtk_box_pack_start},
  {"pack_end",(nsp_method *) _wrap_gtk_box_pack_end},
  {"pack_start_defaults",(nsp_method *) _wrap_gtk_box_pack_start_defaults},
  {"pack_end_defaults",(nsp_method *) _wrap_gtk_box_pack_end_defaults},
  {"set_homogeneous",(nsp_method *) _wrap_gtk_box_set_homogeneous},
  {"get_homogeneous",(nsp_method *) _wrap_gtk_box_get_homogeneous},
  {"set_spacing",(nsp_method *) _wrap_gtk_box_set_spacing},
  {"get_spacing",(nsp_method *) _wrap_gtk_box_get_spacing},
  {"reorder_child",(nsp_method *) _wrap_gtk_box_reorder_child},
  {"query_child_packing",(nsp_method *) _wrap_gtk_box_query_child_packing},
  {"set_child_packing",(nsp_method *) _wrap_gtk_box_set_child_packing},
  { NULL, NULL}
};

static NspMethods *gtkbox_get_methods(void) { return gtkbox_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkbox_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkVBox ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkVBox_Private 
#include "nsp/gtk/gtkvbox.h"
#include "nsp/interf.h"

/* NspGtkVBox inherits from NspGtkBox */ 

int nsp_type_gtkvbox_id=0;
NspTypeGtkVBox *nsp_type_gtkvbox=NULL;

NspTypeGtkVBox *new_type_gtkvbox(type_mode mode)
{
  NspTypeGtkVBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkvbox != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkvbox;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkvbox_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkvbox_get_methods; 
  type->new = (new_func *) new_gtkvbox;

  /* specific methods for gtkvbox */
      
  type->init = (init_func *) init_gtkvbox;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkvbox */ 

  top->s_type =  (s_type_func *) gtkvbox_type_as_string;    
  top->sh_type = (sh_type_func *) gtkvbox_type_short_string;
  /* top->create = (create_func*) int_gtkvbox_create;*/ 
  
  /* specific methods for gtkvbox */
      
  type->init = (init_func *) init_gtkvbox;

  if ( nsp_type_gtkvbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkVBox called nsp_type_gtkvbox
       */
      type->id =  nsp_type_gtkvbox_id = nsp_new_type_id();
      nsp_type_gtkvbox = type;
      if ( nsp_register_type(nsp_type_gtkvbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkvbox, GTK_TYPE_VBOX);
      return ( mode == T_BASE ) ? type : new_type_gtkvbox(mode);
    }
  else 
    {
       type->id = nsp_type_gtkvbox_id;
       return type;
    }
}

/*
 * initialize GtkVBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkvbox(NspGtkVBox *o,NspTypeGtkVBox *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkVBox 
 */

NspGtkVBox *new_gtkvbox() 
{
  NspGtkVBox *loc; 
  /* type must exists */
  nsp_type_gtkvbox = new_type_gtkvbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkVBox)))== NULLGTKVBOX) return loc;
  /* initialize object */
  if ( init_gtkvbox(loc,nsp_type_gtkvbox) == FAIL) return NULLGTKVBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkVBox 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkvbox_type_name[]="GtkVBox";
static char gtkvbox_short_type_name[]="GtkVBox";

static char *gtkvbox_type_as_string(void)
{
  return(gtkvbox_type_name);
}

static char *gtkvbox_type_short_string(void)
{
  return(gtkvbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkVBox objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkVBox   *gtkvbox_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkvbox_id) ) return ((NspGtkVBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkvbox));
  return NULL;
}

int IsGtkVBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkvbox_id);
}

int IsGtkVBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkvbox_id);
}

NspGtkVBox  *GetGtkVBoxCopy(Stack stack, int i)
{
  if (  GetGtkVBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkVBox  *GetGtkVBox(Stack stack, int i)
{
  NspGtkVBox *M;
  if (( M = gtkvbox_object(NthObj(i))) == NULLGTKVBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkVBox *gtkvbox_copy(NspGtkVBox *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkVBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkVBox *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkvbox is initialized * /
  nsp_type_gtkvbox = new_type_gtkvbox(T_BASE);
  if(( H = gtkbox_create(NVOID,(NspTypeBase *) nsp_type_gtkvbox)) == NULLGTKVBOX) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkvbox_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"homogeneous",s_bool,NULLOBJ,-1}, 
	{"spacing",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int homogeneous = FALSE, spacing = 0;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &homogeneous, &spacing) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_vbox_new(homogeneous, spacing))== NULL) return RET_BUG;

  nsp_type_gtkvbox = new_type_gtkvbox(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkvbox );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkvbox_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkvbox_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkColorSelection ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkColorSelection_Private 
#include "nsp/gtk/gtkcolorselection.h"
#include "nsp/interf.h"

/* NspGtkColorSelection inherits from NspGtkVBox */ 

int nsp_type_gtkcolorselection_id=0;
NspTypeGtkColorSelection *nsp_type_gtkcolorselection=NULL;

NspTypeGtkColorSelection *new_type_gtkcolorselection(type_mode mode)
{
  NspTypeGtkColorSelection *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcolorselection != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcolorselection;
    }
  if ((type =  malloc(sizeof(NspTypeGtkVBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkvbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcolorselection_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcolorselection_get_methods; 
  type->new = (new_func *) new_gtkcolorselection;

  /* specific methods for gtkcolorselection */
      
  type->init = (init_func *) init_gtkcolorselection;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcolorselection */ 

  top->s_type =  (s_type_func *) gtkcolorselection_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcolorselection_type_short_string;
  /* top->create = (create_func*) int_gtkcolorselection_create;*/ 
  
  /* specific methods for gtkcolorselection */
      
  type->init = (init_func *) init_gtkcolorselection;

  if ( nsp_type_gtkcolorselection_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkColorSelection called nsp_type_gtkcolorselection
       */
      type->id =  nsp_type_gtkcolorselection_id = nsp_new_type_id();
      nsp_type_gtkcolorselection = type;
      if ( nsp_register_type(nsp_type_gtkcolorselection) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcolorselection, GTK_TYPE_COLOR_SELECTION);
      return ( mode == T_BASE ) ? type : new_type_gtkcolorselection(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcolorselection_id;
       return type;
    }
}

/*
 * initialize GtkColorSelection instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcolorselection(NspGtkColorSelection *o,NspTypeGtkColorSelection *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkColorSelection 
 */

NspGtkColorSelection *new_gtkcolorselection() 
{
  NspGtkColorSelection *loc; 
  /* type must exists */
  nsp_type_gtkcolorselection = new_type_gtkcolorselection(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkColorSelection)))== NULLGTKCOLORSELECTION) return loc;
  /* initialize object */
  if ( init_gtkcolorselection(loc,nsp_type_gtkcolorselection) == FAIL) return NULLGTKCOLORSELECTION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkColorSelection 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcolorselection_type_name[]="GtkColorSelection";
static char gtkcolorselection_short_type_name[]="GtkColorSelection";

static char *gtkcolorselection_type_as_string(void)
{
  return(gtkcolorselection_type_name);
}

static char *gtkcolorselection_type_short_string(void)
{
  return(gtkcolorselection_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkColorSelection objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkColorSelection   *gtkcolorselection_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcolorselection_id) ) return ((NspGtkColorSelection *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcolorselection));
  return NULL;
}

int IsGtkColorSelectionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcolorselection_id);
}

int IsGtkColorSelection(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcolorselection_id);
}

NspGtkColorSelection  *GetGtkColorSelectionCopy(Stack stack, int i)
{
  if (  GetGtkColorSelection(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkColorSelection  *GetGtkColorSelection(Stack stack, int i)
{
  NspGtkColorSelection *M;
  if (( M = gtkcolorselection_object(NthObj(i))) == NULLGTKCOLORSELECTION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkColorSelection *gtkcolorselection_copy(NspGtkColorSelection *self)
{
  /* return gtkvbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorselection);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorselection);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkColorSelection
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkColorSelection *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcolorselection is initialized * /
  nsp_type_gtkcolorselection = new_type_gtkcolorselection(T_BASE);
  if(( H = gtkvbox_create(NVOID,(NspTypeBase *) nsp_type_gtkcolorselection)) == NULLGTKCOLORSELECTION) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkcolorselection_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_color_selection_new())== NULL) return RET_BUG;

  nsp_type_gtkcolorselection = new_type_gtkcolorselection(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcolorselection );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_color_selection_get_has_opacity_control(NspGtkColorSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_color_selection_get_has_opacity_control(GTK_COLOR_SELECTION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_color_selection_set_has_opacity_control(NspGtkColorSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int has_opacity;

  if ( GetArgs(stack,rhs,opt,T,&has_opacity) == FAIL) return RET_BUG;
  gtk_color_selection_set_has_opacity_control(GTK_COLOR_SELECTION(self->obj), has_opacity);
  return 0;
}

static int _wrap_gtk_color_selection_get_has_palette(NspGtkColorSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_color_selection_get_has_palette(GTK_COLOR_SELECTION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_color_selection_set_has_palette(NspGtkColorSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int has_palette;

  if ( GetArgs(stack,rhs,opt,T,&has_palette) == FAIL) return RET_BUG;
  gtk_color_selection_set_has_palette(GTK_COLOR_SELECTION(self->obj), has_palette);
  return 0;
}

#line 4897 "gtk.override"
static int 
_wrap_gtk_color_selection_set_current_color(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check ,t_end};
  NspObject *nsp_color;
  GdkColor *color = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkcolor, &nsp_color) == FAIL) return RET_BUG;
  color = nspg_boxed_get(nsp_color, GdkColor);
  /* XXXX */
  color->red |=  (color->red << 8) ;
  color->green |=  (color->green << 8) ;
  color->blue |= (color->blue << 8) ;
  gtk_color_selection_set_current_color(GTK_COLOR_SELECTION(self->obj), color);
  color->red /= 256; 
  color->green /= 256; 
  color->blue /= 256; 
  return 0;
}

#line 41684 "gtk.c"


static int _wrap_gtk_color_selection_set_current_alpha(NspGtkColorSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int alpha;

  if ( GetArgs(stack,rhs,opt,T,&alpha) == FAIL) return RET_BUG;
  gtk_color_selection_set_current_alpha(GTK_COLOR_SELECTION(self->obj), alpha);
  return 0;
}

#line 4878 "gtk.override"
static int
_wrap_gtk_color_selection_get_current_color(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  GdkColor colour = { 0, };

  gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(self->obj),	&colour);
  /* XXXXX 
  Scierror("color = [%d,%d],[%d,%d],[%d,%d]\n", 
	   colour.red /256 , colour.red & 0x00ff, 
	   colour.green /256  , colour.green & 0x00ff, 
	   colour.blue /256 , colour.blue & 0x00ff);
  */
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, &colour, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 41715 "gtk.c"


static int _wrap_gtk_color_selection_get_current_alpha(NspGtkColorSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_color_selection_get_current_alpha(GTK_COLOR_SELECTION(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 4935 "gtk.override"
static int 
_wrap_gtk_color_selection_set_previous_color(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_color;
  GdkColor *color = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_color) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_COLOR))
      color = nspg_boxed_get(nsp_color, GdkColor);
  else {
      Scierror( "color should be a GdkColor");
      return RET_BUG;
  }
  /* XXXX */
  color->red |=  (color->red << 8) ;
  color->green |=  (color->green << 8) ;
  color->blue |= (color->blue << 8) ;
  gtk_color_selection_set_previous_color(GTK_COLOR_SELECTION(self->obj), color);
  color->red /= 256; 
  color->green /= 256; 
  color->blue /= 256; 
  return 0;
}

#line 41753 "gtk.c"


static int _wrap_gtk_color_selection_set_previous_alpha(NspGtkColorSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int alpha;

  if ( GetArgs(stack,rhs,opt,T,&alpha) == FAIL) return RET_BUG;
  gtk_color_selection_set_previous_alpha(GTK_COLOR_SELECTION(self->obj), alpha);
  return 0;
}

#line 4919 "gtk.override"
static int
_wrap_gtk_color_selection_get_previous_color(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkColor colour = { 0, };
  NspObject *ret;
  gtk_color_selection_get_previous_color(GTK_COLOR_SELECTION(self->obj),
					 &colour);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, &colour, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor)) == NULL) return RET_BUG;
  colour.red /= 256; 
  colour.green /= 256; 
  colour.blue /= 256; 
  MoveObj(stack,1,ret);
  return 1;
}
#line 41781 "gtk.c"


static int _wrap_gtk_color_selection_get_previous_alpha(NspGtkColorSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_color_selection_get_previous_alpha(GTK_COLOR_SELECTION(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_color_selection_is_adjusting(NspGtkColorSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_color_selection_is_adjusting(GTK_COLOR_SELECTION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_color_selection_set_update_policy(NspGtkColorSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_policy = NULL;
  GtkUpdateType policy;

  if ( GetArgs(stack,rhs,opt,T,&nsp_policy) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_UPDATE_TYPE, nsp_policy, &policy)== FAIL)
      return RET_BUG;
  gtk_color_selection_set_update_policy(GTK_COLOR_SELECTION(self->obj), policy);
  return 0;
}

static NspMethods gtkcolorselection_methods[] = {
  {"get_has_opacity_control",(nsp_method *) _wrap_gtk_color_selection_get_has_opacity_control},
  {"set_has_opacity_control",(nsp_method *) _wrap_gtk_color_selection_set_has_opacity_control},
  {"get_has_palette",(nsp_method *) _wrap_gtk_color_selection_get_has_palette},
  {"set_has_palette",(nsp_method *) _wrap_gtk_color_selection_set_has_palette},
  {"set_current_color",(nsp_method *) _wrap_gtk_color_selection_set_current_color},
  {"set_current_alpha",(nsp_method *) _wrap_gtk_color_selection_set_current_alpha},
  {"get_current_color",(nsp_method *) _wrap_gtk_color_selection_get_current_color},
  {"get_current_alpha",(nsp_method *) _wrap_gtk_color_selection_get_current_alpha},
  {"set_previous_color",(nsp_method *) _wrap_gtk_color_selection_set_previous_color},
  {"set_previous_alpha",(nsp_method *) _wrap_gtk_color_selection_set_previous_alpha},
  {"get_previous_color",(nsp_method *) _wrap_gtk_color_selection_get_previous_color},
  {"get_previous_alpha",(nsp_method *) _wrap_gtk_color_selection_get_previous_alpha},
  {"is_adjusting",(nsp_method *) _wrap_gtk_color_selection_is_adjusting},
  {"set_update_policy",(nsp_method *) _wrap_gtk_color_selection_set_update_policy},
  { NULL, NULL}
};

static NspMethods *gtkcolorselection_get_methods(void) { return gtkcolorselection_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcolorselection_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkFontSelection ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkFontSelection_Private 
#include "nsp/gtk/gtkfontselection.h"
#include "nsp/interf.h"

/* NspGtkFontSelection inherits from NspGtkVBox */ 

int nsp_type_gtkfontselection_id=0;
NspTypeGtkFontSelection *nsp_type_gtkfontselection=NULL;

NspTypeGtkFontSelection *new_type_gtkfontselection(type_mode mode)
{
  NspTypeGtkFontSelection *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfontselection != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfontselection;
    }
  if ((type =  malloc(sizeof(NspTypeGtkVBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkvbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfontselection_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkfontselection_get_methods; 
  type->new = (new_func *) new_gtkfontselection;

  /* specific methods for gtkfontselection */
      
  type->init = (init_func *) init_gtkfontselection;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkfontselection */ 

  top->s_type =  (s_type_func *) gtkfontselection_type_as_string;    
  top->sh_type = (sh_type_func *) gtkfontselection_type_short_string;
  /* top->create = (create_func*) int_gtkfontselection_create;*/ 
  
  /* specific methods for gtkfontselection */
      
  type->init = (init_func *) init_gtkfontselection;

  if ( nsp_type_gtkfontselection_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFontSelection called nsp_type_gtkfontselection
       */
      type->id =  nsp_type_gtkfontselection_id = nsp_new_type_id();
      nsp_type_gtkfontselection = type;
      if ( nsp_register_type(nsp_type_gtkfontselection) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfontselection, GTK_TYPE_FONT_SELECTION);
      return ( mode == T_BASE ) ? type : new_type_gtkfontselection(mode);
    }
  else 
    {
       type->id = nsp_type_gtkfontselection_id;
       return type;
    }
}

/*
 * initialize GtkFontSelection instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfontselection(NspGtkFontSelection *o,NspTypeGtkFontSelection *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkFontSelection 
 */

NspGtkFontSelection *new_gtkfontselection() 
{
  NspGtkFontSelection *loc; 
  /* type must exists */
  nsp_type_gtkfontselection = new_type_gtkfontselection(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFontSelection)))== NULLGTKFONTSELECTION) return loc;
  /* initialize object */
  if ( init_gtkfontselection(loc,nsp_type_gtkfontselection) == FAIL) return NULLGTKFONTSELECTION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkFontSelection 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkfontselection_type_name[]="GtkFontSelection";
static char gtkfontselection_short_type_name[]="GtkFontSelection";

static char *gtkfontselection_type_as_string(void)
{
  return(gtkfontselection_type_name);
}

static char *gtkfontselection_type_short_string(void)
{
  return(gtkfontselection_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkFontSelection objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkFontSelection   *gtkfontselection_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkfontselection_id) ) return ((NspGtkFontSelection *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfontselection));
  return NULL;
}

int IsGtkFontSelectionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkfontselection_id);
}

int IsGtkFontSelection(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfontselection_id);
}

NspGtkFontSelection  *GetGtkFontSelectionCopy(Stack stack, int i)
{
  if (  GetGtkFontSelection(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFontSelection  *GetGtkFontSelection(Stack stack, int i)
{
  NspGtkFontSelection *M;
  if (( M = gtkfontselection_object(NthObj(i))) == NULLGTKFONTSELECTION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFontSelection *gtkfontselection_copy(NspGtkFontSelection *self)
{
  /* return gtkvbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontselection);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontselection);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFontSelection
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkFontSelection *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkfontselection is initialized * /
  nsp_type_gtkfontselection = new_type_gtkfontselection(T_BASE);
  if(( H = gtkvbox_create(NVOID,(NspTypeBase *) nsp_type_gtkfontselection)) == NULLGTKFONTSELECTION) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkfontselection_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_font_selection_new())== NULL) return RET_BUG;

  nsp_type_gtkfontselection = new_type_gtkfontselection(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkfontselection );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_font_selection_get_font_name(NspGtkFontSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;

  ret = gtk_font_selection_get_font_name(GTK_FONT_SELECTION(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_font_selection_get_font(NspGtkFontSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkFont *ret;
  NspObject *nsp_ret;

  Scierror("%s: deprecated use GtkFontSelection.get_font_name",stack.fname); return RET_BUG;
  ret = gtk_font_selection_get_font(GTK_FONT_SELECTION(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_FONT, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkfont))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_font_selection_set_font_name(NspGtkFontSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *fontname;
  int ret;

  if ( GetArgs(stack,rhs,opt,T,&fontname) == FAIL) return RET_BUG;
  ret = gtk_font_selection_set_font_name(GTK_FONT_SELECTION(self->obj), fontname);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_font_selection_get_preview_text(NspGtkFontSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_font_selection_get_preview_text(GTK_FONT_SELECTION(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_font_selection_set_preview_text(NspGtkFontSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *text;

  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
  gtk_font_selection_set_preview_text(GTK_FONT_SELECTION(self->obj), text);
  return 0;
}

static NspMethods gtkfontselection_methods[] = {
  {"get_font_name",(nsp_method *) _wrap_gtk_font_selection_get_font_name},
  {"get_font",(nsp_method *) _wrap_gtk_font_selection_get_font},
  {"set_font_name",(nsp_method *) _wrap_gtk_font_selection_set_font_name},
  {"get_preview_text",(nsp_method *) _wrap_gtk_font_selection_get_preview_text},
  {"set_preview_text",(nsp_method *) _wrap_gtk_font_selection_set_preview_text},
  { NULL, NULL}
};

static NspMethods *gtkfontselection_get_methods(void) { return gtkfontselection_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfontselection_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkGammaCurve ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkGammaCurve_Private 
#include "nsp/gtk/gtkgammacurve.h"
#include "nsp/interf.h"

/* NspGtkGammaCurve inherits from NspGtkVBox */ 

int nsp_type_gtkgammacurve_id=0;
NspTypeGtkGammaCurve *nsp_type_gtkgammacurve=NULL;

NspTypeGtkGammaCurve *new_type_gtkgammacurve(type_mode mode)
{
  NspTypeGtkGammaCurve *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkgammacurve != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkgammacurve;
    }
  if ((type =  malloc(sizeof(NspTypeGtkVBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkvbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkgammacurve_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkgammacurve_get_methods; 
  type->new = (new_func *) new_gtkgammacurve;

  /* specific methods for gtkgammacurve */
      
  type->init = (init_func *) init_gtkgammacurve;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkgammacurve */ 

  top->s_type =  (s_type_func *) gtkgammacurve_type_as_string;    
  top->sh_type = (sh_type_func *) gtkgammacurve_type_short_string;
  /* top->create = (create_func*) int_gtkgammacurve_create;*/ 
  
  /* specific methods for gtkgammacurve */
      
  type->init = (init_func *) init_gtkgammacurve;

  if ( nsp_type_gtkgammacurve_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkGammaCurve called nsp_type_gtkgammacurve
       */
      type->id =  nsp_type_gtkgammacurve_id = nsp_new_type_id();
      nsp_type_gtkgammacurve = type;
      if ( nsp_register_type(nsp_type_gtkgammacurve) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkgammacurve, GTK_TYPE_GAMMA_CURVE);
      return ( mode == T_BASE ) ? type : new_type_gtkgammacurve(mode);
    }
  else 
    {
       type->id = nsp_type_gtkgammacurve_id;
       return type;
    }
}

/*
 * initialize GtkGammaCurve instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkgammacurve(NspGtkGammaCurve *o,NspTypeGtkGammaCurve *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkGammaCurve 
 */

NspGtkGammaCurve *new_gtkgammacurve() 
{
  NspGtkGammaCurve *loc; 
  /* type must exists */
  nsp_type_gtkgammacurve = new_type_gtkgammacurve(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkGammaCurve)))== NULLGTKGAMMACURVE) return loc;
  /* initialize object */
  if ( init_gtkgammacurve(loc,nsp_type_gtkgammacurve) == FAIL) return NULLGTKGAMMACURVE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkGammaCurve 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkgammacurve_type_name[]="GtkGammaCurve";
static char gtkgammacurve_short_type_name[]="GtkGammaCurve";

static char *gtkgammacurve_type_as_string(void)
{
  return(gtkgammacurve_type_name);
}

static char *gtkgammacurve_type_short_string(void)
{
  return(gtkgammacurve_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkGammaCurve objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkGammaCurve   *gtkgammacurve_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkgammacurve_id) ) return ((NspGtkGammaCurve *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkgammacurve));
  return NULL;
}

int IsGtkGammaCurveObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkgammacurve_id);
}

int IsGtkGammaCurve(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkgammacurve_id);
}

NspGtkGammaCurve  *GetGtkGammaCurveCopy(Stack stack, int i)
{
  if (  GetGtkGammaCurve(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkGammaCurve  *GetGtkGammaCurve(Stack stack, int i)
{
  NspGtkGammaCurve *M;
  if (( M = gtkgammacurve_object(NthObj(i))) == NULLGTKGAMMACURVE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkGammaCurve *gtkgammacurve_copy(NspGtkGammaCurve *self)
{
  /* return gtkvbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkgammacurve);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkgammacurve);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkGammaCurve
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkGammaCurve *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkgammacurve is initialized * /
  nsp_type_gtkgammacurve = new_type_gtkgammacurve(T_BASE);
  if(( H = gtkvbox_create(NVOID,(NspTypeBase *) nsp_type_gtkgammacurve)) == NULLGTKGAMMACURVE) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkgammacurve_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_gamma_curve_new())== NULL) return RET_BUG;

  nsp_type_gtkgammacurve = new_type_gtkgammacurve(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkgammacurve );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkgammacurve_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_gamma_curve__get_table(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_GAMMA_CURVE(NSP_GOBJECT_GET(self))->table;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_gamma_curve__get_curve(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_GAMMA_CURVE(NSP_GOBJECT_GET(self))->curve;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_gamma_curve__get_gamma(NspObject *self,char *attr)
{
  double ret;
  NspObject *nsp_ret;

  ret = (gfloat) GTK_GAMMA_CURVE(NSP_GOBJECT_GET(self))->gamma;
  nsp_ret=nsp_create_object_from_double(NVOID,(double) ret);
  return nsp_ret;
}

static NspObject *_wrap_gtk_gamma_curve__get_gamma_dialog(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_GAMMA_CURVE(NSP_GOBJECT_GET(self))->gamma_dialog;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_gamma_curve__get_gamma_text(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_GAMMA_CURVE(NSP_GOBJECT_GET(self))->gamma_text;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static AttrTab gtkgammacurve_attrs[] = {
  { "table", (attr_get_function *)_wrap_gtk_gamma_curve__get_table, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "curve", (attr_get_function *)_wrap_gtk_gamma_curve__get_curve, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "gamma", (attr_get_function *)_wrap_gtk_gamma_curve__get_gamma, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "gamma_dialog", (attr_get_function *)_wrap_gtk_gamma_curve__get_gamma_dialog, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "gamma_text", (attr_get_function *)_wrap_gtk_gamma_curve__get_gamma_text, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkHBox ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkHBox_Private 
#include "nsp/gtk/gtkhbox.h"
#include "nsp/interf.h"

/* NspGtkHBox inherits from NspGtkBox */ 

int nsp_type_gtkhbox_id=0;
NspTypeGtkHBox *nsp_type_gtkhbox=NULL;

NspTypeGtkHBox *new_type_gtkhbox(type_mode mode)
{
  NspTypeGtkHBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkhbox != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkhbox;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkhbox_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkhbox_get_methods; 
  type->new = (new_func *) new_gtkhbox;

  /* specific methods for gtkhbox */
      
  type->init = (init_func *) init_gtkhbox;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkhbox */ 

  top->s_type =  (s_type_func *) gtkhbox_type_as_string;    
  top->sh_type = (sh_type_func *) gtkhbox_type_short_string;
  /* top->create = (create_func*) int_gtkhbox_create;*/ 
  
  /* specific methods for gtkhbox */
      
  type->init = (init_func *) init_gtkhbox;

  if ( nsp_type_gtkhbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkHBox called nsp_type_gtkhbox
       */
      type->id =  nsp_type_gtkhbox_id = nsp_new_type_id();
      nsp_type_gtkhbox = type;
      if ( nsp_register_type(nsp_type_gtkhbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkhbox, GTK_TYPE_HBOX);
      return ( mode == T_BASE ) ? type : new_type_gtkhbox(mode);
    }
  else 
    {
       type->id = nsp_type_gtkhbox_id;
       return type;
    }
}

/*
 * initialize GtkHBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkhbox(NspGtkHBox *o,NspTypeGtkHBox *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkHBox 
 */

NspGtkHBox *new_gtkhbox() 
{
  NspGtkHBox *loc; 
  /* type must exists */
  nsp_type_gtkhbox = new_type_gtkhbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkHBox)))== NULLGTKHBOX) return loc;
  /* initialize object */
  if ( init_gtkhbox(loc,nsp_type_gtkhbox) == FAIL) return NULLGTKHBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkHBox 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkhbox_type_name[]="GtkHBox";
static char gtkhbox_short_type_name[]="GtkHBox";

static char *gtkhbox_type_as_string(void)
{
  return(gtkhbox_type_name);
}

static char *gtkhbox_type_short_string(void)
{
  return(gtkhbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkHBox objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkHBox   *gtkhbox_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkhbox_id) ) return ((NspGtkHBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkhbox));
  return NULL;
}

int IsGtkHBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkhbox_id);
}

int IsGtkHBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkhbox_id);
}

NspGtkHBox  *GetGtkHBoxCopy(Stack stack, int i)
{
  if (  GetGtkHBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkHBox  *GetGtkHBox(Stack stack, int i)
{
  NspGtkHBox *M;
  if (( M = gtkhbox_object(NthObj(i))) == NULLGTKHBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkHBox *gtkhbox_copy(NspGtkHBox *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkHBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkHBox *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkhbox is initialized * /
  nsp_type_gtkhbox = new_type_gtkhbox(T_BASE);
  if(( H = gtkbox_create(NVOID,(NspTypeBase *) nsp_type_gtkhbox)) == NULLGTKHBOX) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkhbox_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"homogeneous",s_bool,NULLOBJ,-1}, 
	{"spacing",s_int,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  int homogeneous = FALSE, spacing = 0;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &homogeneous, &spacing) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_hbox_new(homogeneous, spacing))== NULL) return RET_BUG;

  nsp_type_gtkhbox = new_type_gtkhbox(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkhbox );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkhbox_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkhbox_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkStatusbar ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkStatusbar_Private 
#include "nsp/gtk/gtkstatusbar.h"
#include "nsp/interf.h"

/* NspGtkStatusbar inherits from NspGtkHBox */ 

int nsp_type_gtkstatusbar_id=0;
NspTypeGtkStatusbar *nsp_type_gtkstatusbar=NULL;

NspTypeGtkStatusbar *new_type_gtkstatusbar(type_mode mode)
{
  NspTypeGtkStatusbar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkstatusbar != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkstatusbar;
    }
  if ((type =  malloc(sizeof(NspTypeGtkHBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkhbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkstatusbar_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkstatusbar_get_methods; 
  type->new = (new_func *) new_gtkstatusbar;

  /* specific methods for gtkstatusbar */
      
  type->init = (init_func *) init_gtkstatusbar;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkstatusbar */ 

  top->s_type =  (s_type_func *) gtkstatusbar_type_as_string;    
  top->sh_type = (sh_type_func *) gtkstatusbar_type_short_string;
  /* top->create = (create_func*) int_gtkstatusbar_create;*/ 
  
  /* specific methods for gtkstatusbar */
      
  type->init = (init_func *) init_gtkstatusbar;

  if ( nsp_type_gtkstatusbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkStatusbar called nsp_type_gtkstatusbar
       */
      type->id =  nsp_type_gtkstatusbar_id = nsp_new_type_id();
      nsp_type_gtkstatusbar = type;
      if ( nsp_register_type(nsp_type_gtkstatusbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkstatusbar, GTK_TYPE_STATUSBAR);
      return ( mode == T_BASE ) ? type : new_type_gtkstatusbar(mode);
    }
  else 
    {
       type->id = nsp_type_gtkstatusbar_id;
       return type;
    }
}

/*
 * initialize GtkStatusbar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkstatusbar(NspGtkStatusbar *o,NspTypeGtkStatusbar *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkStatusbar 
 */

NspGtkStatusbar *new_gtkstatusbar() 
{
  NspGtkStatusbar *loc; 
  /* type must exists */
  nsp_type_gtkstatusbar = new_type_gtkstatusbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkStatusbar)))== NULLGTKSTATUSBAR) return loc;
  /* initialize object */
  if ( init_gtkstatusbar(loc,nsp_type_gtkstatusbar) == FAIL) return NULLGTKSTATUSBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkStatusbar 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkstatusbar_type_name[]="GtkStatusbar";
static char gtkstatusbar_short_type_name[]="GtkStatusbar";

static char *gtkstatusbar_type_as_string(void)
{
  return(gtkstatusbar_type_name);
}

static char *gtkstatusbar_type_short_string(void)
{
  return(gtkstatusbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkStatusbar objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkStatusbar   *gtkstatusbar_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkstatusbar_id) ) return ((NspGtkStatusbar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkstatusbar));
  return NULL;
}

int IsGtkStatusbarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkstatusbar_id);
}

int IsGtkStatusbar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkstatusbar_id);
}

NspGtkStatusbar  *GetGtkStatusbarCopy(Stack stack, int i)
{
  if (  GetGtkStatusbar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkStatusbar  *GetGtkStatusbar(Stack stack, int i)
{
  NspGtkStatusbar *M;
  if (( M = gtkstatusbar_object(NthObj(i))) == NULLGTKSTATUSBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkStatusbar *gtkstatusbar_copy(NspGtkStatusbar *self)
{
  /* return gtkhbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstatusbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstatusbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkStatusbar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkStatusbar *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkstatusbar is initialized * /
  nsp_type_gtkstatusbar = new_type_gtkstatusbar(T_BASE);
  if(( H = gtkhbox_create(NVOID,(NspTypeBase *) nsp_type_gtkstatusbar)) == NULLGTKSTATUSBAR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkstatusbar_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_statusbar_new())== NULL) return RET_BUG;

  nsp_type_gtkstatusbar = new_type_gtkstatusbar(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkstatusbar );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_statusbar_get_context_id(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *context_description;
  int ret;

  if ( GetArgs(stack,rhs,opt,T,&context_description) == FAIL) return RET_BUG;
  ret = gtk_statusbar_get_context_id(GTK_STATUSBAR(self->obj), context_description);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_statusbar_push(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, string,t_end};
  int context_id, ret;
  char *text;

  if ( GetArgs(stack,rhs,opt,T,&context_id, &text) == FAIL) return RET_BUG;
  ret = gtk_statusbar_push(GTK_STATUSBAR(self->obj), context_id, text);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_statusbar_pop(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int context_id;

  if ( GetArgs(stack,rhs,opt,T,&context_id) == FAIL) return RET_BUG;
  gtk_statusbar_pop(GTK_STATUSBAR(self->obj), context_id);
  return 0;
}

static int _wrap_gtk_statusbar_remove(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int context_id, message_id;

  if ( GetArgs(stack,rhs,opt,T,&context_id, &message_id) == FAIL) return RET_BUG;
  gtk_statusbar_remove(GTK_STATUSBAR(self->obj), context_id, message_id);
  return 0;
}

static int _wrap_gtk_statusbar_set_has_resize_grip(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_statusbar_set_has_resize_grip(GTK_STATUSBAR(self->obj), setting);
  return 0;
}

static int _wrap_gtk_statusbar_get_has_resize_grip(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_statusbar_get_has_resize_grip(GTK_STATUSBAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkstatusbar_methods[] = {
  {"get_context_id",(nsp_method *) _wrap_gtk_statusbar_get_context_id},
  {"push",(nsp_method *) _wrap_gtk_statusbar_push},
  {"pop",(nsp_method *) _wrap_gtk_statusbar_pop},
  {"remove",(nsp_method *) _wrap_gtk_statusbar_remove},
  {"set_has_resize_grip",(nsp_method *) _wrap_gtk_statusbar_set_has_resize_grip},
  {"get_has_resize_grip",(nsp_method *) _wrap_gtk_statusbar_get_has_resize_grip},
  { NULL, NULL}
};

static NspMethods *gtkstatusbar_get_methods(void) { return gtkstatusbar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkstatusbar_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkCombo ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkCombo_Private 
#include "nsp/gtk/gtkcombo.h"
#include "nsp/interf.h"

/* NspGtkCombo inherits from NspGtkHBox */ 

int nsp_type_gtkcombo_id=0;
NspTypeGtkCombo *nsp_type_gtkcombo=NULL;

NspTypeGtkCombo *new_type_gtkcombo(type_mode mode)
{
  NspTypeGtkCombo *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcombo != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcombo;
    }
  if ((type =  malloc(sizeof(NspTypeGtkHBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkhbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcombo_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcombo_get_methods; 
  type->new = (new_func *) new_gtkcombo;

  /* specific methods for gtkcombo */
      
  type->init = (init_func *) init_gtkcombo;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcombo */ 

  top->s_type =  (s_type_func *) gtkcombo_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcombo_type_short_string;
  /* top->create = (create_func*) int_gtkcombo_create;*/ 
  
  /* specific methods for gtkcombo */
      
  type->init = (init_func *) init_gtkcombo;

  if ( nsp_type_gtkcombo_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCombo called nsp_type_gtkcombo
       */
      type->id =  nsp_type_gtkcombo_id = nsp_new_type_id();
      nsp_type_gtkcombo = type;
      if ( nsp_register_type(nsp_type_gtkcombo) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcombo, GTK_TYPE_COMBO);
      return ( mode == T_BASE ) ? type : new_type_gtkcombo(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcombo_id;
       return type;
    }
}

/*
 * initialize GtkCombo instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcombo(NspGtkCombo *o,NspTypeGtkCombo *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkCombo 
 */

NspGtkCombo *new_gtkcombo() 
{
  NspGtkCombo *loc; 
  /* type must exists */
  nsp_type_gtkcombo = new_type_gtkcombo(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCombo)))== NULLGTKCOMBO) return loc;
  /* initialize object */
  if ( init_gtkcombo(loc,nsp_type_gtkcombo) == FAIL) return NULLGTKCOMBO;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkCombo 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcombo_type_name[]="GtkCombo";
static char gtkcombo_short_type_name[]="GtkCombo";

static char *gtkcombo_type_as_string(void)
{
  return(gtkcombo_type_name);
}

static char *gtkcombo_type_short_string(void)
{
  return(gtkcombo_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkCombo objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkCombo   *gtkcombo_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcombo_id) ) return ((NspGtkCombo *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcombo));
  return NULL;
}

int IsGtkComboObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcombo_id);
}

int IsGtkCombo(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcombo_id);
}

NspGtkCombo  *GetGtkComboCopy(Stack stack, int i)
{
  if (  GetGtkCombo(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCombo  *GetGtkCombo(Stack stack, int i)
{
  NspGtkCombo *M;
  if (( M = gtkcombo_object(NthObj(i))) == NULLGTKCOMBO)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCombo *gtkcombo_copy(NspGtkCombo *self)
{
  /* return gtkhbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcombo);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcombo);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCombo
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkCombo *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcombo is initialized * /
  nsp_type_gtkcombo = new_type_gtkcombo(T_BASE);
  if(( H = gtkhbox_create(NVOID,(NspTypeBase *) nsp_type_gtkcombo)) == NULLGTKCOMBO) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkcombo_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_combo_new())== NULL) return RET_BUG;

  nsp_type_gtkcombo = new_type_gtkcombo(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcombo );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_combo_set_value_in_list(NspGtkCombo *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, s_bool,t_end};
  int val, ok_if_empty;

  if ( GetArgs(stack,rhs,opt,T,&val, &ok_if_empty) == FAIL) return RET_BUG;
  gtk_combo_set_value_in_list(GTK_COMBO(self->obj), val, ok_if_empty);
  return 0;
}

static int _wrap_gtk_combo_set_use_arrows(NspGtkCombo *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int val;

  if ( GetArgs(stack,rhs,opt,T,&val) == FAIL) return RET_BUG;
  gtk_combo_set_use_arrows(GTK_COMBO(self->obj), val);
  return 0;
}

static int _wrap_gtk_combo_set_use_arrows_always(NspGtkCombo *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int val;

  if ( GetArgs(stack,rhs,opt,T,&val) == FAIL) return RET_BUG;
  gtk_combo_set_use_arrows_always(GTK_COMBO(self->obj), val);
  return 0;
}

static int _wrap_gtk_combo_set_case_sensitive(NspGtkCombo *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int val;

  if ( GetArgs(stack,rhs,opt,T,&val) == FAIL) return RET_BUG;
  gtk_combo_set_case_sensitive(GTK_COMBO(self->obj), val);
  return 0;
}

static int _wrap_gtk_combo_set_item_string(NspGtkCombo *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, string,t_end};
  char *item_value;
  NspGObject *item;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkitem, &item, &item_value) == FAIL) return RET_BUG;
  gtk_combo_set_item_string(GTK_COMBO(self->obj), GTK_ITEM(item->obj), item_value);
  return 0;
}

#line 1496 "gtk.override"
static int
_wrap_gtk_combo_set_popdown_strings(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { smat, t_end} ;
  /* static char *kwlist[] = { "strings", NULL };*/
  NspSMatrix *st;
  GList *glist = NULL;
  int i;
  /* XXXX NspUnicode */
  if (GetArgs(stack,rhs,opt,T, &st )== FAIL ) return RET_BUG;
  
  for (i = 0; i < st->mn ; i++) 
    glist = g_list_append(glist, st->S[i]);
  gtk_combo_set_popdown_strings(GTK_COMBO(self->obj), glist);
  g_list_free(glist);
  return 0;
}
#line 43176 "gtk.c"


static int _wrap_gtk_combo_disable_activate(NspGtkCombo *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_combo_disable_activate(GTK_COMBO(self->obj));
  return 0;
}

static NspMethods gtkcombo_methods[] = {
  {"set_value_in_list",(nsp_method *) _wrap_gtk_combo_set_value_in_list},
  {"set_use_arrows",(nsp_method *) _wrap_gtk_combo_set_use_arrows},
  {"set_use_arrows_always",(nsp_method *) _wrap_gtk_combo_set_use_arrows_always},
  {"set_case_sensitive",(nsp_method *) _wrap_gtk_combo_set_case_sensitive},
  {"set_item_string",(nsp_method *) _wrap_gtk_combo_set_item_string},
  {"set_popdown_strings",(nsp_method *) _wrap_gtk_combo_set_popdown_strings},
  {"disable_activate",(nsp_method *) _wrap_gtk_combo_disable_activate},
  { NULL, NULL}
};

static NspMethods *gtkcombo_get_methods(void) { return gtkcombo_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_combo__get_entry(NspObject *self,char *attr)
{
  GtkEntry *ret;

  ret = (GtkEntry*) GTK_COMBO(NSP_GOBJECT_GET(self))->entry;
  nsp_type_gtkentry = new_type_gtkentry(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkentry);
}

static AttrTab gtkcombo_attrs[] = {
  { "entry", (attr_get_function *)_wrap_gtk_combo__get_entry, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkButtonBox ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkButtonBox_Private 
#include "nsp/gtk/gtkbuttonbox.h"
#include "nsp/interf.h"

/* NspGtkButtonBox inherits from NspGtkBox */ 

int nsp_type_gtkbuttonbox_id=0;
NspTypeGtkButtonBox *nsp_type_gtkbuttonbox=NULL;

NspTypeGtkButtonBox *new_type_gtkbuttonbox(type_mode mode)
{
  NspTypeGtkButtonBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkbuttonbox != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkbuttonbox;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkbuttonbox_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkbuttonbox_get_methods; 
  type->new = (new_func *) new_gtkbuttonbox;

  /* specific methods for gtkbuttonbox */
      
  type->init = (init_func *) init_gtkbuttonbox;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkbuttonbox */ 

  top->s_type =  (s_type_func *) gtkbuttonbox_type_as_string;    
  top->sh_type = (sh_type_func *) gtkbuttonbox_type_short_string;
  /* top->create = (create_func*) int_gtkbuttonbox_create;*/ 
  
  /* specific methods for gtkbuttonbox */
      
  type->init = (init_func *) init_gtkbuttonbox;

  if ( nsp_type_gtkbuttonbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkButtonBox called nsp_type_gtkbuttonbox
       */
      type->id =  nsp_type_gtkbuttonbox_id = nsp_new_type_id();
      nsp_type_gtkbuttonbox = type;
      if ( nsp_register_type(nsp_type_gtkbuttonbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkbuttonbox, GTK_TYPE_BUTTON_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkbuttonbox(mode);
    }
  else 
    {
       type->id = nsp_type_gtkbuttonbox_id;
       return type;
    }
}

/*
 * initialize GtkButtonBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkbuttonbox(NspGtkButtonBox *o,NspTypeGtkButtonBox *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkButtonBox 
 */

NspGtkButtonBox *new_gtkbuttonbox() 
{
  NspGtkButtonBox *loc; 
  /* type must exists */
  nsp_type_gtkbuttonbox = new_type_gtkbuttonbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkButtonBox)))== NULLGTKBUTTONBOX) return loc;
  /* initialize object */
  if ( init_gtkbuttonbox(loc,nsp_type_gtkbuttonbox) == FAIL) return NULLGTKBUTTONBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkButtonBox 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkbuttonbox_type_name[]="GtkButtonBox";
static char gtkbuttonbox_short_type_name[]="GtkButtonBox";

static char *gtkbuttonbox_type_as_string(void)
{
  return(gtkbuttonbox_type_name);
}

static char *gtkbuttonbox_type_short_string(void)
{
  return(gtkbuttonbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkButtonBox objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkButtonBox   *gtkbuttonbox_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkbuttonbox_id) ) return ((NspGtkButtonBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkbuttonbox));
  return NULL;
}

int IsGtkButtonBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkbuttonbox_id);
}

int IsGtkButtonBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkbuttonbox_id);
}

NspGtkButtonBox  *GetGtkButtonBoxCopy(Stack stack, int i)
{
  if (  GetGtkButtonBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkButtonBox  *GetGtkButtonBox(Stack stack, int i)
{
  NspGtkButtonBox *M;
  if (( M = gtkbuttonbox_object(NthObj(i))) == NULLGTKBUTTONBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkButtonBox *gtkbuttonbox_copy(NspGtkButtonBox *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbuttonbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbuttonbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkButtonBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkButtonBox *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkbuttonbox is initialized * /
  nsp_type_gtkbuttonbox = new_type_gtkbuttonbox(T_BASE);
  if(( H = gtkbox_create(NVOID,(NspTypeBase *) nsp_type_gtkbuttonbox)) == NULLGTKBUTTONBOX) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int _wrap_gtk_button_box_get_layout(NspGtkButtonBox *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_button_box_get_layout(GTK_BUTTON_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_button_box_set_layout(NspGtkButtonBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GtkButtonBoxStyle layout_style;
  NspObject *nsp_layout_style = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_layout_style) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_BUTTON_BOX_STYLE, nsp_layout_style, &layout_style)== FAIL)
      return RET_BUG;
  gtk_button_box_set_layout(GTK_BUTTON_BOX(self->obj), layout_style);
  return 0;
}

static int _wrap_gtk_button_box_set_child_secondary(NspGtkButtonBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_bool,t_end};
  int is_secondary;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &is_secondary) == FAIL) return RET_BUG;
  gtk_button_box_set_child_secondary(GTK_BUTTON_BOX(self->obj), GTK_WIDGET(child->obj), is_secondary);
  return 0;
}

static int _wrap_gtk_button_box_set_child_size(NspGtkButtonBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int min_width, min_height;

  if ( GetArgs(stack,rhs,opt,T,&min_width, &min_height) == FAIL) return RET_BUG;
  Scierror("%s: deprecated don't use this",stack.fname); return RET_BUG;
  gtk_button_box_set_child_size(GTK_BUTTON_BOX(self->obj), min_width, min_height);
  return 0;
}

static int _wrap_gtk_button_box_set_child_ipadding(NspGtkButtonBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int ipad_x, ipad_y;

  if ( GetArgs(stack,rhs,opt,T,&ipad_x, &ipad_y) == FAIL) return RET_BUG;
  Scierror("%s: deprecated don't use this",stack.fname); return RET_BUG;
  gtk_button_box_set_child_ipadding(GTK_BUTTON_BOX(self->obj), ipad_x, ipad_y);
  return 0;
}

#line 4203 "gtk.override"
static int
_wrap_gtk_button_box_get_child_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint min_width, min_height;
  CheckRhs(0,0);
  gtk_button_box_get_child_size(GTK_BUTTON_BOX(self->obj), &min_width, &min_height);
  if ( nsp_move_doubles(stack,1,1,2,(double) min_width, (double) min_height) == FAIL) return RET_BUG; 
  return 1;
}
#line 43475 "gtk.c"


#line 4214 "gtk.override"
static int
_wrap_gtk_button_box_get_child_ipadding(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ipad_x,  ipad_y;
  CheckRhs(0,0);
  gtk_button_box_get_child_ipadding(GTK_BUTTON_BOX(self->obj), &ipad_x, &ipad_y);
  if ( nsp_move_doubles(stack,1,1,2,(double) ipad_x,(double) ipad_y) == FAIL) return RET_BUG; 
  return 1;

}
#line 43489 "gtk.c"


static NspMethods gtkbuttonbox_methods[] = {
  {"get_layout",(nsp_method *) _wrap_gtk_button_box_get_layout},
  {"set_layout",(nsp_method *) _wrap_gtk_button_box_set_layout},
  {"set_child_secondary",(nsp_method *) _wrap_gtk_button_box_set_child_secondary},
  {"set_child_size",(nsp_method *) _wrap_gtk_button_box_set_child_size},
  {"set_child_ipadding",(nsp_method *) _wrap_gtk_button_box_set_child_ipadding},
  {"get_child_size",(nsp_method *) _wrap_gtk_button_box_get_child_size},
  {"get_child_ipadding",(nsp_method *) _wrap_gtk_button_box_get_child_ipadding},
  { NULL, NULL}
};

static NspMethods *gtkbuttonbox_get_methods(void) { return gtkbuttonbox_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkbuttonbox_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkVButtonBox ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkVButtonBox_Private 
#include "nsp/gtk/gtkvbuttonbox.h"
#include "nsp/interf.h"

/* NspGtkVButtonBox inherits from NspGtkButtonBox */ 

int nsp_type_gtkvbuttonbox_id=0;
NspTypeGtkVButtonBox *nsp_type_gtkvbuttonbox=NULL;

NspTypeGtkVButtonBox *new_type_gtkvbuttonbox(type_mode mode)
{
  NspTypeGtkVButtonBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkvbuttonbox != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkvbuttonbox;
    }
  if ((type =  malloc(sizeof(NspTypeGtkButtonBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbuttonbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkvbuttonbox_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkvbuttonbox_get_methods; 
  type->new = (new_func *) new_gtkvbuttonbox;

  /* specific methods for gtkvbuttonbox */
      
  type->init = (init_func *) init_gtkvbuttonbox;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkvbuttonbox */ 

  top->s_type =  (s_type_func *) gtkvbuttonbox_type_as_string;    
  top->sh_type = (sh_type_func *) gtkvbuttonbox_type_short_string;
  /* top->create = (create_func*) int_gtkvbuttonbox_create;*/ 
  
  /* specific methods for gtkvbuttonbox */
      
  type->init = (init_func *) init_gtkvbuttonbox;

  if ( nsp_type_gtkvbuttonbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkVButtonBox called nsp_type_gtkvbuttonbox
       */
      type->id =  nsp_type_gtkvbuttonbox_id = nsp_new_type_id();
      nsp_type_gtkvbuttonbox = type;
      if ( nsp_register_type(nsp_type_gtkvbuttonbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkvbuttonbox, GTK_TYPE_VBUTTON_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkvbuttonbox(mode);
    }
  else 
    {
       type->id = nsp_type_gtkvbuttonbox_id;
       return type;
    }
}

/*
 * initialize GtkVButtonBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkvbuttonbox(NspGtkVButtonBox *o,NspTypeGtkVButtonBox *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkVButtonBox 
 */

NspGtkVButtonBox *new_gtkvbuttonbox() 
{
  NspGtkVButtonBox *loc; 
  /* type must exists */
  nsp_type_gtkvbuttonbox = new_type_gtkvbuttonbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkVButtonBox)))== NULLGTKVBUTTONBOX) return loc;
  /* initialize object */
  if ( init_gtkvbuttonbox(loc,nsp_type_gtkvbuttonbox) == FAIL) return NULLGTKVBUTTONBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkVButtonBox 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkvbuttonbox_type_name[]="GtkVButtonBox";
static char gtkvbuttonbox_short_type_name[]="GtkVButtonBox";

static char *gtkvbuttonbox_type_as_string(void)
{
  return(gtkvbuttonbox_type_name);
}

static char *gtkvbuttonbox_type_short_string(void)
{
  return(gtkvbuttonbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkVButtonBox objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkVButtonBox   *gtkvbuttonbox_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkvbuttonbox_id) ) return ((NspGtkVButtonBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkvbuttonbox));
  return NULL;
}

int IsGtkVButtonBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkvbuttonbox_id);
}

int IsGtkVButtonBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkvbuttonbox_id);
}

NspGtkVButtonBox  *GetGtkVButtonBoxCopy(Stack stack, int i)
{
  if (  GetGtkVButtonBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkVButtonBox  *GetGtkVButtonBox(Stack stack, int i)
{
  NspGtkVButtonBox *M;
  if (( M = gtkvbuttonbox_object(NthObj(i))) == NULLGTKVBUTTONBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkVButtonBox *gtkvbuttonbox_copy(NspGtkVButtonBox *self)
{
  /* return gtkbuttonbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvbuttonbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvbuttonbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkVButtonBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkVButtonBox *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkvbuttonbox is initialized * /
  nsp_type_gtkvbuttonbox = new_type_gtkvbuttonbox(T_BASE);
  if(( H = gtkbuttonbox_create(NVOID,(NspTypeBase *) nsp_type_gtkvbuttonbox)) == NULLGTKVBUTTONBOX) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkvbuttonbox_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_vbutton_box_new())== NULL) return RET_BUG;

  nsp_type_gtkvbuttonbox = new_type_gtkvbuttonbox(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkvbuttonbox );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkvbuttonbox_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkvbuttonbox_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkHButtonBox ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkHButtonBox_Private 
#include "nsp/gtk/gtkhbuttonbox.h"
#include "nsp/interf.h"

/* NspGtkHButtonBox inherits from NspGtkButtonBox */ 

int nsp_type_gtkhbuttonbox_id=0;
NspTypeGtkHButtonBox *nsp_type_gtkhbuttonbox=NULL;

NspTypeGtkHButtonBox *new_type_gtkhbuttonbox(type_mode mode)
{
  NspTypeGtkHButtonBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkhbuttonbox != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkhbuttonbox;
    }
  if ((type =  malloc(sizeof(NspTypeGtkButtonBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbuttonbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkhbuttonbox_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkhbuttonbox_get_methods; 
  type->new = (new_func *) new_gtkhbuttonbox;

  /* specific methods for gtkhbuttonbox */
      
  type->init = (init_func *) init_gtkhbuttonbox;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkhbuttonbox */ 

  top->s_type =  (s_type_func *) gtkhbuttonbox_type_as_string;    
  top->sh_type = (sh_type_func *) gtkhbuttonbox_type_short_string;
  /* top->create = (create_func*) int_gtkhbuttonbox_create;*/ 
  
  /* specific methods for gtkhbuttonbox */
      
  type->init = (init_func *) init_gtkhbuttonbox;

  if ( nsp_type_gtkhbuttonbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkHButtonBox called nsp_type_gtkhbuttonbox
       */
      type->id =  nsp_type_gtkhbuttonbox_id = nsp_new_type_id();
      nsp_type_gtkhbuttonbox = type;
      if ( nsp_register_type(nsp_type_gtkhbuttonbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkhbuttonbox, GTK_TYPE_HBUTTON_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkhbuttonbox(mode);
    }
  else 
    {
       type->id = nsp_type_gtkhbuttonbox_id;
       return type;
    }
}

/*
 * initialize GtkHButtonBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkhbuttonbox(NspGtkHButtonBox *o,NspTypeGtkHButtonBox *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkHButtonBox 
 */

NspGtkHButtonBox *new_gtkhbuttonbox() 
{
  NspGtkHButtonBox *loc; 
  /* type must exists */
  nsp_type_gtkhbuttonbox = new_type_gtkhbuttonbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkHButtonBox)))== NULLGTKHBUTTONBOX) return loc;
  /* initialize object */
  if ( init_gtkhbuttonbox(loc,nsp_type_gtkhbuttonbox) == FAIL) return NULLGTKHBUTTONBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkHButtonBox 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkhbuttonbox_type_name[]="GtkHButtonBox";
static char gtkhbuttonbox_short_type_name[]="GtkHButtonBox";

static char *gtkhbuttonbox_type_as_string(void)
{
  return(gtkhbuttonbox_type_name);
}

static char *gtkhbuttonbox_type_short_string(void)
{
  return(gtkhbuttonbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkHButtonBox objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkHButtonBox   *gtkhbuttonbox_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkhbuttonbox_id) ) return ((NspGtkHButtonBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkhbuttonbox));
  return NULL;
}

int IsGtkHButtonBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkhbuttonbox_id);
}

int IsGtkHButtonBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkhbuttonbox_id);
}

NspGtkHButtonBox  *GetGtkHButtonBoxCopy(Stack stack, int i)
{
  if (  GetGtkHButtonBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkHButtonBox  *GetGtkHButtonBox(Stack stack, int i)
{
  NspGtkHButtonBox *M;
  if (( M = gtkhbuttonbox_object(NthObj(i))) == NULLGTKHBUTTONBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkHButtonBox *gtkhbuttonbox_copy(NspGtkHButtonBox *self)
{
  /* return gtkbuttonbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhbuttonbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkhbuttonbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkHButtonBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkHButtonBox *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkhbuttonbox is initialized * /
  nsp_type_gtkhbuttonbox = new_type_gtkhbuttonbox(T_BASE);
  if(( H = gtkbuttonbox_create(NVOID,(NspTypeBase *) nsp_type_gtkhbuttonbox)) == NULLGTKHBUTTONBOX) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkhbuttonbox_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_hbutton_box_new())== NULL) return RET_BUG;

  nsp_type_gtkhbuttonbox = new_type_gtkhbuttonbox(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkhbuttonbox );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkhbuttonbox_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkhbuttonbox_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkCalendar ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkCalendar_Private 
#include "nsp/gtk/gtkcalendar.h"
#include "nsp/interf.h"

/* NspGtkCalendar inherits from NspGtkWidget */ 

int nsp_type_gtkcalendar_id=0;
NspTypeGtkCalendar *nsp_type_gtkcalendar=NULL;

NspTypeGtkCalendar *new_type_gtkcalendar(type_mode mode)
{
  NspTypeGtkCalendar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcalendar != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcalendar;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcalendar_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcalendar_get_methods; 
  type->new = (new_func *) new_gtkcalendar;

  /* specific methods for gtkcalendar */
      
  type->init = (init_func *) init_gtkcalendar;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcalendar */ 

  top->s_type =  (s_type_func *) gtkcalendar_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcalendar_type_short_string;
  /* top->create = (create_func*) int_gtkcalendar_create;*/ 
  
  /* specific methods for gtkcalendar */
      
  type->init = (init_func *) init_gtkcalendar;

  if ( nsp_type_gtkcalendar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCalendar called nsp_type_gtkcalendar
       */
      type->id =  nsp_type_gtkcalendar_id = nsp_new_type_id();
      nsp_type_gtkcalendar = type;
      if ( nsp_register_type(nsp_type_gtkcalendar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcalendar, GTK_TYPE_CALENDAR);
      return ( mode == T_BASE ) ? type : new_type_gtkcalendar(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcalendar_id;
       return type;
    }
}

/*
 * initialize GtkCalendar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcalendar(NspGtkCalendar *o,NspTypeGtkCalendar *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkCalendar 
 */

NspGtkCalendar *new_gtkcalendar() 
{
  NspGtkCalendar *loc; 
  /* type must exists */
  nsp_type_gtkcalendar = new_type_gtkcalendar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCalendar)))== NULLGTKCALENDAR) return loc;
  /* initialize object */
  if ( init_gtkcalendar(loc,nsp_type_gtkcalendar) == FAIL) return NULLGTKCALENDAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkCalendar 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcalendar_type_name[]="GtkCalendar";
static char gtkcalendar_short_type_name[]="GtkCalendar";

static char *gtkcalendar_type_as_string(void)
{
  return(gtkcalendar_type_name);
}

static char *gtkcalendar_type_short_string(void)
{
  return(gtkcalendar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkCalendar objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkCalendar   *gtkcalendar_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcalendar_id) ) return ((NspGtkCalendar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcalendar));
  return NULL;
}

int IsGtkCalendarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcalendar_id);
}

int IsGtkCalendar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcalendar_id);
}

NspGtkCalendar  *GetGtkCalendarCopy(Stack stack, int i)
{
  if (  GetGtkCalendar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCalendar  *GetGtkCalendar(Stack stack, int i)
{
  NspGtkCalendar *M;
  if (( M = gtkcalendar_object(NthObj(i))) == NULLGTKCALENDAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCalendar *gtkcalendar_copy(NspGtkCalendar *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcalendar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcalendar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCalendar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkCalendar *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcalendar is initialized * /
  nsp_type_gtkcalendar = new_type_gtkcalendar(T_BASE);
  if(( H = gtkwidget_create(NVOID,(NspTypeBase *) nsp_type_gtkcalendar)) == NULLGTKCALENDAR) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkcalendar_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_calendar_new())== NULL) return RET_BUG;

  nsp_type_gtkcalendar = new_type_gtkcalendar(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcalendar );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_calendar_select_month(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int month, year, ret;

  if ( GetArgs(stack,rhs,opt,T,&month, &year) == FAIL) return RET_BUG;
  ret = gtk_calendar_select_month(GTK_CALENDAR(self->obj), month, year);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_calendar_select_day(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int day;

  if ( GetArgs(stack,rhs,opt,T,&day) == FAIL) return RET_BUG;
  gtk_calendar_select_day(GTK_CALENDAR(self->obj), day);
  return 0;
}

static int _wrap_gtk_calendar_mark_day(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int day, ret;

  if ( GetArgs(stack,rhs,opt,T,&day) == FAIL) return RET_BUG;
  ret = gtk_calendar_mark_day(GTK_CALENDAR(self->obj), day);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_calendar_unmark_day(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int day, ret;

  if ( GetArgs(stack,rhs,opt,T,&day) == FAIL) return RET_BUG;
  ret = gtk_calendar_unmark_day(GTK_CALENDAR(self->obj), day);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 4973 "gtk.override"
static int _wrap_gtk_calendar_is_marked_day(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int day, ret;
  if ( GetArgs(stack,rhs,opt,T,&day) == FAIL) return RET_BUG;
  if ( day < 1 || day > 31 ) 
    {
      Scierror("day should be in the range [1,31]\n");
      return RET_BUG;
    }
  ret=  (GTK_CALENDAR (self->obj)->marked_date[day-1] == 1) ;
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}


#line 44208 "gtk.c"


static int _wrap_gtk_calendar_clear_marks(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_calendar_clear_marks(GTK_CALENDAR(self->obj));
  return 0;
}

static int _wrap_gtk_calendar_set_display_options(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_flags = NULL;
  GtkCalendarDisplayOptions flags;

  if ( GetArgs(stack,rhs,opt,T,&nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_CALENDAR_DISPLAY_OPTIONS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
  gtk_calendar_set_display_options(GTK_CALENDAR(self->obj), flags);
  return 0;
}

static int _wrap_gtk_calendar_get_display_options(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_calendar_get_display_options(GTK_CALENDAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 4962 "gtk.override"
static int
_wrap_gtk_calendar_get_date(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  guint year, month, day;

  gtk_calendar_get_date(GTK_CALENDAR(self->obj), &year, &month, &day);
  if ( nsp_move_doubles(stack,1,1,3,(double) year,(double) month,(double) day) == FAIL) return RET_BUG; 
  return 1;
}
#line 44249 "gtk.c"


static int _wrap_gtk_calendar_freeze(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_calendar_freeze(GTK_CALENDAR(self->obj));
  return 0;
}

static int _wrap_gtk_calendar_thaw(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_calendar_thaw(GTK_CALENDAR(self->obj));
  return 0;
}

static NspMethods gtkcalendar_methods[] = {
  {"select_month",(nsp_method *) _wrap_gtk_calendar_select_month},
  {"select_day",(nsp_method *) _wrap_gtk_calendar_select_day},
  {"mark_day",(nsp_method *) _wrap_gtk_calendar_mark_day},
  {"unmark_day",(nsp_method *) _wrap_gtk_calendar_unmark_day},
  {"is_marked",(nsp_method *) _wrap_gtk_calendar_is_marked_day},
  {"clear_marks",(nsp_method *) _wrap_gtk_calendar_clear_marks},
  {"set_display_options",(nsp_method *) _wrap_gtk_calendar_set_display_options},
  {"get_display_options",(nsp_method *) _wrap_gtk_calendar_get_display_options},
  {"get_date",(nsp_method *) _wrap_gtk_calendar_get_date},
  {"freeze",(nsp_method *) _wrap_gtk_calendar_freeze},
  {"thaw",(nsp_method *) _wrap_gtk_calendar_thaw},
  { NULL, NULL}
};

static NspMethods *gtkcalendar_get_methods(void) { return gtkcalendar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcalendar_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkWindow ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkWindow_Private 
#include "nsp/gtk/gtkwindow.h"
#include "nsp/interf.h"

/* NspGtkWindow inherits from NspGtkBin */ 

int nsp_type_gtkwindow_id=0;
NspTypeGtkWindow *nsp_type_gtkwindow=NULL;

NspTypeGtkWindow *new_type_gtkwindow(type_mode mode)
{
  NspTypeGtkWindow *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkwindow != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkwindow;
    }
  if ((type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkwindow_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkwindow_get_methods; 
  type->new = (new_func *) new_gtkwindow;

  /* specific methods for gtkwindow */
      
  type->init = (init_func *) init_gtkwindow;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkwindow */ 

  top->s_type =  (s_type_func *) gtkwindow_type_as_string;    
  top->sh_type = (sh_type_func *) gtkwindow_type_short_string;
  /* top->create = (create_func*) int_gtkwindow_create;*/ 
  
  /* specific methods for gtkwindow */
      
  type->init = (init_func *) init_gtkwindow;

  if ( nsp_type_gtkwindow_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkWindow called nsp_type_gtkwindow
       */
      type->id =  nsp_type_gtkwindow_id = nsp_new_type_id();
      nsp_type_gtkwindow = type;
      if ( nsp_register_type(nsp_type_gtkwindow) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkwindow, GTK_TYPE_WINDOW);
      return ( mode == T_BASE ) ? type : new_type_gtkwindow(mode);
    }
  else 
    {
       type->id = nsp_type_gtkwindow_id;
       return type;
    }
}

/*
 * initialize GtkWindow instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkwindow(NspGtkWindow *o,NspTypeGtkWindow *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkWindow 
 */

NspGtkWindow *new_gtkwindow() 
{
  NspGtkWindow *loc; 
  /* type must exists */
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkWindow)))== NULLGTKWINDOW) return loc;
  /* initialize object */
  if ( init_gtkwindow(loc,nsp_type_gtkwindow) == FAIL) return NULLGTKWINDOW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkWindow 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkwindow_type_name[]="GtkWindow";
static char gtkwindow_short_type_name[]="GtkWindow";

static char *gtkwindow_type_as_string(void)
{
  return(gtkwindow_type_name);
}

static char *gtkwindow_type_short_string(void)
{
  return(gtkwindow_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkWindow objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkWindow   *gtkwindow_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkwindow_id) ) return ((NspGtkWindow *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkwindow));
  return NULL;
}

int IsGtkWindowObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkwindow_id);
}

int IsGtkWindow(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkwindow_id);
}

NspGtkWindow  *GetGtkWindowCopy(Stack stack, int i)
{
  if (  GetGtkWindow(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkWindow  *GetGtkWindow(Stack stack, int i)
{
  NspGtkWindow *M;
  if (( M = gtkwindow_object(NthObj(i))) == NULLGTKWINDOW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkWindow *gtkwindow_copy(NspGtkWindow *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwindow);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwindow);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkWindow
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkWindow *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkwindow is initialized * /
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  if(( H = gtkbin_create(NVOID,(NspTypeBase *) nsp_type_gtkwindow)) == NULLGTKWINDOW) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkwindow_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"type",obj,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  GtkWindowType type = GTK_WINDOW_TOPLEVEL;
  NspObject *nsp_type = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_WINDOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_window_new(type))== NULL) return RET_BUG;

  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
    /* g_xxxx_object_ref(ret); XXXwe don't own the first reference of windows */
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkwindow );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_set_title(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *title;

  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
  gtk_window_set_title(GTK_WINDOW(self->obj), title);
  return 0;
}

static int _wrap_gtk_window_get_title(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_window_get_title(GTK_WINDOW(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_wmclass(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, string,t_end};
  char *wmclass_name, *wmclass_class;

  if ( GetArgs(stack,rhs,opt,T,&wmclass_name, &wmclass_class) == FAIL) return RET_BUG;
  gtk_window_set_wmclass(GTK_WINDOW(self->obj), wmclass_name, wmclass_class);
  return 0;
}

static int _wrap_gtk_window_set_role(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *role;

  if ( GetArgs(stack,rhs,opt,T,&role) == FAIL) return RET_BUG;
  gtk_window_set_role(GTK_WINDOW(self->obj), role);
  return 0;
}

static int _wrap_gtk_window_get_role(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_window_get_role(GTK_WINDOW(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_add_accel_group(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *accel_group;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaccelgroup, &accel_group) == FAIL) return RET_BUG;
  gtk_window_add_accel_group(GTK_WINDOW(self->obj), GTK_ACCEL_GROUP(accel_group->obj));
  return 0;
}

static int _wrap_gtk_window_remove_accel_group(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *accel_group;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaccelgroup, &accel_group) == FAIL) return RET_BUG;
  gtk_window_remove_accel_group(GTK_WINDOW(self->obj), GTK_ACCEL_GROUP(accel_group->obj));
  return 0;
}

static int _wrap_gtk_window_set_position(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_position = NULL;
  GtkWindowPosition position;

  if ( GetArgs(stack,rhs,opt,T,&nsp_position) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_WINDOW_POSITION, nsp_position, &position)== FAIL)
      return RET_BUG;
  gtk_window_set_position(GTK_WINDOW(self->obj), position);
  return 0;
}

static int _wrap_gtk_window_activate_focus(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_window_activate_focus(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_focus(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *focus;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &focus) == FAIL) return RET_BUG;
  gtk_window_set_focus(GTK_WINDOW(self->obj), GTK_WIDGET(focus->obj));
  return 0;
}

static int _wrap_gtk_window_get_focus(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

  ret = gtk_window_get_focus(GTK_WINDOW(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_set_default(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *default_widget;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &default_widget) == FAIL) return RET_BUG;
  gtk_window_set_default(GTK_WINDOW(self->obj), GTK_WIDGET(default_widget->obj));
  return 0;
}

static int _wrap_gtk_window_activate_default(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_window_activate_default(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_transient_for(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *parent;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &parent) == FAIL) return RET_BUG;
  gtk_window_set_transient_for(GTK_WINDOW(self->obj), GTK_WINDOW(parent->obj));
  return 0;
}

static int _wrap_gtk_window_get_transient_for(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWindow *ret;

  ret = gtk_window_get_transient_for(GTK_WINDOW(self->obj));
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_set_type_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_hint = NULL;
  GdkWindowTypeHint hint;

  if ( GetArgs(stack,rhs,opt,T,&nsp_hint) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GDK_TYPE_WINDOW_TYPE_HINT, nsp_hint, &hint)== FAIL)
      return RET_BUG;
  gtk_window_set_type_hint(GTK_WINDOW(self->obj), hint);
  return 0;
}

static int _wrap_gtk_window_get_type_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_window_get_type_hint(GTK_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_skip_taskbar_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_window_set_skip_taskbar_hint(GTK_WINDOW(self->obj), setting);
  return 0;
}

static int _wrap_gtk_window_get_skip_taskbar_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_window_get_skip_taskbar_hint(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_skip_pager_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_window_set_skip_pager_hint(GTK_WINDOW(self->obj), setting);
  return 0;
}

static int _wrap_gtk_window_get_skip_pager_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_window_get_skip_pager_hint(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_destroy_with_parent(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_window_set_destroy_with_parent(GTK_WINDOW(self->obj), setting);
  return 0;
}

static int _wrap_gtk_window_get_destroy_with_parent(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_window_get_destroy_with_parent(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_resizable(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int resizable;

  if ( GetArgs(stack,rhs,opt,T,&resizable) == FAIL) return RET_BUG;
  gtk_window_set_resizable(GTK_WINDOW(self->obj), resizable);
  return 0;
}

static int _wrap_gtk_window_get_resizable(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_window_get_resizable(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_gravity(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  GdkGravity gravity;
  NspObject *nsp_gravity = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_gravity) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GDK_TYPE_GRAVITY, nsp_gravity, &gravity)== FAIL)
      return RET_BUG;
  gtk_window_set_gravity(GTK_WINDOW(self->obj), gravity);
  return 0;
}

static int _wrap_gtk_window_get_gravity(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;

  ret = gtk_window_get_gravity(GTK_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 1360 "gtk.override"
static int
_wrap_gtk_window_set_geometry_hints(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { new_opts,t_end};
  nsp_option opts[] = {
    {"geometry",obj_check,NULLOBJ,-1},
    { "min_width",s_int,NULLOBJ,-1},
    { "min_height",s_int,NULLOBJ,-1},
    { "max_width",s_int,NULLOBJ,-1},
    { "max_height",s_int,NULLOBJ,-1},
    { "base_width",s_int,NULLOBJ,-1},
    {"base_height",s_int,NULLOBJ,-1},
    { "width_inc",s_int,NULLOBJ,-1},
    { "height_inc",s_int,NULLOBJ,-1},
    {"min_aspect",s_int,NULLOBJ,-1},
    { "max_aspect",s_int,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };

  NspObject *nsp_geometry_widget = NULL;
  GtkWidget *geometry_widget = NULL;
  gint min_width = -1, min_height = -1, max_width = -1, max_height = -1;
  gint base_width = -1, base_height = -1, width_inc = -1, height_inc = -1;
  gdouble min_aspect = -1.0, max_aspect = -1.0;
  GdkGeometry geometry = { 0 };
  GdkWindowHints geom_mask = 0;
  
  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type_gtkwidget,&nsp_geometry_widget,
	      &min_width,  &min_height, &max_width, &max_height,
	      &base_width, &base_height, &width_inc,
	      &height_inc, &min_aspect, &max_aspect)== FAIL) 
    return RET_BUG;
  if ( nsp_geometry_widget != NULL) 
    geometry_widget = GTK_WIDGET(nspgobject_get(nsp_geometry_widget));

  if (min_width >= 0 || min_height >= 0) {
    geometry.min_width = MAX(min_width, 0);
    geometry.min_height = MAX(min_height, 0);
    geom_mask |= GDK_HINT_MIN_SIZE;
  }
  if (max_width >= 0 || max_height >= 0) {
    geometry.max_width = MAX(max_width, 0);
    geometry.max_height = MAX(max_height, 0);
    geom_mask |= GDK_HINT_MAX_SIZE;
  }
  if (base_width >= 0 || base_height >= 0) {
    geometry.base_width = MAX(base_width, 0);
    geometry.base_height = MAX(base_height, 0);
    geom_mask |= GDK_HINT_BASE_SIZE;
  }
  if (width_inc >= 0 || height_inc >= 0) {
    geometry.width_inc = MAX(width_inc, 0);
    geometry.height_inc = MAX(height_inc, 0);
    geom_mask |= GDK_HINT_RESIZE_INC;
  }
  if (min_aspect >= 0.0 || max_aspect >= 0.0) {
    if (min_aspect <= 0.0 || max_aspect <= 0.0) {
      Scierror( "aspect ratios must be positive\n");
      return RET_BUG;
    }
    geometry.min_aspect = min_aspect;
    geometry.max_aspect = max_aspect;
    geom_mask |= GDK_HINT_ASPECT;
  }
  gtk_window_set_geometry_hints(GTK_WINDOW(self->obj), geometry_widget,
				&geometry, geom_mask);
  return 0;
}
#line 44845 "gtk.c"


static int _wrap_gtk_window_set_screen(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *screen;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen) == FAIL) return RET_BUG;
  gtk_window_set_screen(GTK_WINDOW(self->obj), GDK_SCREEN(screen->obj));
  return 0;
}

static int _wrap_gtk_window_get_screen(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GdkScreen *ret;

  ret = gtk_window_get_screen(GTK_WINDOW(self->obj));
  nsp_type_gdkscreen = new_type_gdkscreen(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkscreen))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_set_has_frame(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_window_set_has_frame(GTK_WINDOW(self->obj), setting);
  return 0;
}

static int _wrap_gtk_window_get_has_frame(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_window_get_has_frame(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_frame_dimensions(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int, s_int, s_int,t_end};
  int left, top, right, bottom;

  if ( GetArgs(stack,rhs,opt,T,&left, &top, &right, &bottom) == FAIL) return RET_BUG;
  gtk_window_set_frame_dimensions(GTK_WINDOW(self->obj), left, top, right, bottom);
  return 0;
}

static int _wrap_gtk_window_get_frame_dimensions(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int, s_int, s_int,t_end};
  int left, top, right, bottom;

  if ( GetArgs(stack,rhs,opt,T,&left, &top, &right, &bottom) == FAIL) return RET_BUG;
  gtk_window_get_frame_dimensions(GTK_WINDOW(self->obj), &left, &top, &right, &bottom);
  return 0;
}

static int _wrap_gtk_window_set_decorated(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_window_set_decorated(GTK_WINDOW(self->obj), setting);
  return 0;
}

static int _wrap_gtk_window_get_decorated(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_window_get_decorated(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_icon(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *icon;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbuf, &icon) == FAIL) return RET_BUG;
  gtk_window_set_icon(GTK_WINDOW(self->obj), GDK_PIXBUF(icon->obj));
  return 0;
}

static int _wrap_gtk_window_set_icon_from_file(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *filename;
  int ret;
  GError *err = NULL;

  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
  ret = gtk_window_set_icon_from_file(GTK_WINDOW(self->obj), filename, &err);
  if ( err != NULL ) {
    Scierror("%s: gtk error\n",stack.fname);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_get_icon(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;

  ret = gtk_window_get_icon(GTK_WINDOW(self->obj));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_set_modal(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int modal;

  if ( GetArgs(stack,rhs,opt,T,&modal) == FAIL) return RET_BUG;
  gtk_window_set_modal(GTK_WINDOW(self->obj), modal);
  return 0;
}

static int _wrap_gtk_window_get_modal(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_window_get_modal(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_add_mnemonic(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, obj_check,t_end};
  int keyval;
  NspGObject *target;

  if ( GetArgs(stack,rhs,opt,T,&keyval, &nsp_type_gtkwidget, &target) == FAIL) return RET_BUG;
  gtk_window_add_mnemonic(GTK_WINDOW(self->obj), keyval, GTK_WIDGET(target->obj));
  return 0;
}

static int _wrap_gtk_window_remove_mnemonic(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, obj_check,t_end};
  int keyval;
  NspGObject *target;

  if ( GetArgs(stack,rhs,opt,T,&keyval, &nsp_type_gtkwidget, &target) == FAIL) return RET_BUG;
  gtk_window_remove_mnemonic(GTK_WINDOW(self->obj), keyval, GTK_WIDGET(target->obj));
  return 0;
}

static int _wrap_gtk_window_mnemonic_activate(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, obj,t_end};
  int keyval, ret;
  NspObject *nsp_modifier = NULL;
  GdkModifierType modifier;

  if ( GetArgs(stack,rhs,opt,T,&keyval, &nsp_modifier) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_modifier, &modifier)==FAIL)
      return RET_BUG;
  ret = gtk_window_mnemonic_activate(GTK_WINDOW(self->obj), keyval, modifier);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_mnemonic_modifier(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_modifier = NULL;
  GdkModifierType modifier;

  if ( GetArgs(stack,rhs,opt,T,&nsp_modifier) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_modifier, &modifier)==FAIL)
      return RET_BUG;
  gtk_window_set_mnemonic_modifier(GTK_WINDOW(self->obj), modifier);
  return 0;
}

static int _wrap_gtk_window_get_mnemonic_modifier(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;

  ret = gtk_window_get_mnemonic_modifier(GTK_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_present(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_window_present(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_iconify(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_window_iconify(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_deiconify(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_window_deiconify(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_stick(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_window_stick(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_unstick(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_window_unstick(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_maximize(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_window_maximize(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_unmaximize(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_window_unmaximize(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_fullscreen(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_window_fullscreen(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_unfullscreen(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_window_unfullscreen(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_begin_resize_drag(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, s_int, s_int, s_int, s_int,t_end};
  int button, root_x, root_y;
  NspObject *nsp_edge = NULL;
  gulong timestamp;
  GdkWindowEdge edge;

  if ( GetArgs(stack,rhs,opt,T,&nsp_edge, &button, &root_x, &root_y, &timestamp) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GDK_TYPE_WINDOW_EDGE, nsp_edge, &edge)== FAIL)
      return RET_BUG;
  gtk_window_begin_resize_drag(GTK_WINDOW(self->obj), edge, button, root_x, root_y, timestamp);
  return 0;
}

static int _wrap_gtk_window_begin_move_drag(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int, s_int, s_int,t_end};
  int button, root_x, root_y;
  gulong timestamp;

  if ( GetArgs(stack,rhs,opt,T,&button, &root_x, &root_y, &timestamp) == FAIL) return RET_BUG;
  gtk_window_begin_move_drag(GTK_WINDOW(self->obj), button, root_x, root_y, timestamp);
  return 0;
}

static int _wrap_gtk_window_set_policy(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int, s_int,t_end};
  int allow_shrink, allow_grow, auto_shrink;

  if ( GetArgs(stack,rhs,opt,T,&allow_shrink, &allow_grow, &auto_shrink) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkWindow.set_resizable",stack.fname); return RET_BUG;
  gtk_window_set_policy(GTK_WINDOW(self->obj), allow_shrink, allow_grow, auto_shrink);
  return 0;
}

static int _wrap_gtk_window_set_default_size(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int width, height;

  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
  gtk_window_set_default_size(GTK_WINDOW(self->obj), width, height);
  return 0;
}

#line 1454 "gtk.override"
static int
_wrap_gtk_window_get_default_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint width, height;
  CheckRhs(0,0);
  gtk_window_get_default_size(GTK_WINDOW(self->obj), &width, &height);
  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL) 
    return RET_BUG; 
  return 1; 
}
#line 45157 "gtk.c"


static int _wrap_gtk_window_resize(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int width, height;

  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
  gtk_window_resize(GTK_WINDOW(self->obj), width, height);
  return 0;
}

#line 1441 "gtk.override"
static int
_wrap_gtk_window_get_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint width, height;

  gtk_window_get_size(GTK_WINDOW(self->obj), &width, &height);

  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL) 
    return RET_BUG; 
  return 1; 
}
#line 45182 "gtk.c"


static int _wrap_gtk_window_move(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_int,t_end};
  int x, y;

  if ( GetArgs(stack,rhs,opt,T,&x, &y) == FAIL) return RET_BUG;
  gtk_window_move(GTK_WINDOW(self->obj), x, y);
  return 0;
}

#line 1429 "gtk.override"
static int
_wrap_gtk_window_get_position(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint root_x, root_y;

  gtk_window_get_position(GTK_WINDOW(self->obj), &root_x, &root_y);
  if (  nsp_move_doubles(stack,1,1,2,(double) root_x,(double) root_y) == FAIL) 
    return RET_BUG; 
  return 1; 
}
#line 45206 "gtk.c"


static int _wrap_gtk_window_parse_geometry(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *geometry;
  int ret;

  if ( GetArgs(stack,rhs,opt,T,&geometry) == FAIL) return RET_BUG;
  ret = gtk_window_parse_geometry(GTK_WINDOW(self->obj), geometry);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_reshow_with_initial_size(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_window_reshow_with_initial_size(GTK_WINDOW(self->obj));
  return 0;
}

static NspMethods gtkwindow_methods[] = {
  {"set_title",(nsp_method *) _wrap_gtk_window_set_title},
  {"get_title",(nsp_method *) _wrap_gtk_window_get_title},
  {"set_wmclass",(nsp_method *) _wrap_gtk_window_set_wmclass},
  {"set_role",(nsp_method *) _wrap_gtk_window_set_role},
  {"get_role",(nsp_method *) _wrap_gtk_window_get_role},
  {"add_accel_group",(nsp_method *) _wrap_gtk_window_add_accel_group},
  {"remove_accel_group",(nsp_method *) _wrap_gtk_window_remove_accel_group},
  {"set_position",(nsp_method *) _wrap_gtk_window_set_position},
  {"activate_focus",(nsp_method *) _wrap_gtk_window_activate_focus},
  {"set_focus",(nsp_method *) _wrap_gtk_window_set_focus},
  {"get_focus",(nsp_method *) _wrap_gtk_window_get_focus},
  {"set_default",(nsp_method *) _wrap_gtk_window_set_default},
  {"activate_default",(nsp_method *) _wrap_gtk_window_activate_default},
  {"set_transient_for",(nsp_method *) _wrap_gtk_window_set_transient_for},
  {"get_transient_for",(nsp_method *) _wrap_gtk_window_get_transient_for},
  {"set_type_hint",(nsp_method *) _wrap_gtk_window_set_type_hint},
  {"get_type_hint",(nsp_method *) _wrap_gtk_window_get_type_hint},
  {"set_skip_taskbar_hint",(nsp_method *) _wrap_gtk_window_set_skip_taskbar_hint},
  {"get_skip_taskbar_hint",(nsp_method *) _wrap_gtk_window_get_skip_taskbar_hint},
  {"set_skip_pager_hint",(nsp_method *) _wrap_gtk_window_set_skip_pager_hint},
  {"get_skip_pager_hint",(nsp_method *) _wrap_gtk_window_get_skip_pager_hint},
  {"set_destroy_with_parent",(nsp_method *) _wrap_gtk_window_set_destroy_with_parent},
  {"get_destroy_with_parent",(nsp_method *) _wrap_gtk_window_get_destroy_with_parent},
  {"set_resizable",(nsp_method *) _wrap_gtk_window_set_resizable},
  {"get_resizable",(nsp_method *) _wrap_gtk_window_get_resizable},
  {"set_gravity",(nsp_method *) _wrap_gtk_window_set_gravity},
  {"get_gravity",(nsp_method *) _wrap_gtk_window_get_gravity},
  {"set_geometry_hints",(nsp_method *) _wrap_gtk_window_set_geometry_hints},
  {"set_screen",(nsp_method *) _wrap_gtk_window_set_screen},
  {"get_screen",(nsp_method *) _wrap_gtk_window_get_screen},
  {"set_has_frame",(nsp_method *) _wrap_gtk_window_set_has_frame},
  {"get_has_frame",(nsp_method *) _wrap_gtk_window_get_has_frame},
  {"set_frame_dimensions",(nsp_method *) _wrap_gtk_window_set_frame_dimensions},
  {"get_frame_dimensions",(nsp_method *) _wrap_gtk_window_get_frame_dimensions},
  {"set_decorated",(nsp_method *) _wrap_gtk_window_set_decorated},
  {"get_decorated",(nsp_method *) _wrap_gtk_window_get_decorated},
  {"set_icon",(nsp_method *) _wrap_gtk_window_set_icon},
  {"set_icon_from_file",(nsp_method *) _wrap_gtk_window_set_icon_from_file},
  {"get_icon",(nsp_method *) _wrap_gtk_window_get_icon},
  {"set_modal",(nsp_method *) _wrap_gtk_window_set_modal},
  {"get_modal",(nsp_method *) _wrap_gtk_window_get_modal},
  {"add_mnemonic",(nsp_method *) _wrap_gtk_window_add_mnemonic},
  {"remove_mnemonic",(nsp_method *) _wrap_gtk_window_remove_mnemonic},
  {"mnemonic_activate",(nsp_method *) _wrap_gtk_window_mnemonic_activate},
  {"set_mnemonic_modifier",(nsp_method *) _wrap_gtk_window_set_mnemonic_modifier},
  {"get_mnemonic_modifier",(nsp_method *) _wrap_gtk_window_get_mnemonic_modifier},
  {"present",(nsp_method *) _wrap_gtk_window_present},
  {"iconify",(nsp_method *) _wrap_gtk_window_iconify},
  {"deiconify",(nsp_method *) _wrap_gtk_window_deiconify},
  {"stick",(nsp_method *) _wrap_gtk_window_stick},
  {"unstick",(nsp_method *) _wrap_gtk_window_unstick},
  {"maximize",(nsp_method *) _wrap_gtk_window_maximize},
  {"unmaximize",(nsp_method *) _wrap_gtk_window_unmaximize},
  {"fullscreen",(nsp_method *) _wrap_gtk_window_fullscreen},
  {"unfullscreen",(nsp_method *) _wrap_gtk_window_unfullscreen},
  {"begin_resize_drag",(nsp_method *) _wrap_gtk_window_begin_resize_drag},
  {"begin_move_drag",(nsp_method *) _wrap_gtk_window_begin_move_drag},
  {"set_policy",(nsp_method *) _wrap_gtk_window_set_policy},
  {"set_default_size",(nsp_method *) _wrap_gtk_window_set_default_size},
  {"get_default_size",(nsp_method *) _wrap_gtk_window_get_default_size},
  {"resize",(nsp_method *) _wrap_gtk_window_resize},
  {"get_size",(nsp_method *) _wrap_gtk_window_get_size},
  {"move",(nsp_method *) _wrap_gtk_window_move},
  {"get_position",(nsp_method *) _wrap_gtk_window_get_position},
  {"parse_geometry",(nsp_method *) _wrap_gtk_window_parse_geometry},
  {"reshow_with_initial_size",(nsp_method *) _wrap_gtk_window_reshow_with_initial_size},
  { NULL, NULL}
};

static NspMethods *gtkwindow_get_methods(void) { return gtkwindow_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_window__get_title(NspObject *self,char *attr)
{
  const gchar *ret;
  NspObject *nsp_ret;

  ret = (gchar*) GTK_WINDOW(NSP_GOBJECT_GET(self))->title;
  nsp_ret = nsp_new_string_obj(NVOID,ret,-1);
  return nsp_ret;
}

static NspObject *_wrap_gtk_window__get_wmclass_name(NspObject *self,char *attr)
{
  const gchar *ret;
  NspObject *nsp_ret;

  ret = (gchar*) GTK_WINDOW(NSP_GOBJECT_GET(self))->wmclass_name;
  nsp_ret = nsp_new_string_obj(NVOID,ret,-1);
  return nsp_ret;
}

static NspObject *_wrap_gtk_window__get_wmclass_class(NspObject *self,char *attr)
{
  const gchar *ret;
  NspObject *nsp_ret;

  ret = (gchar*) GTK_WINDOW(NSP_GOBJECT_GET(self))->wmclass_class;
  nsp_ret = nsp_new_string_obj(NVOID,ret,-1);
  return nsp_ret;
}

static NspObject *_wrap_gtk_window__get_wm_role(NspObject *self,char *attr)
{
  const gchar *ret;
  NspObject *nsp_ret;

  ret = (gchar*) GTK_WINDOW(NSP_GOBJECT_GET(self))->wm_role;
  nsp_ret = nsp_new_string_obj(NVOID,ret,-1);
  return nsp_ret;
}

static NspObject *_wrap_gtk_window__get_focus_widget(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_WINDOW(NSP_GOBJECT_GET(self))->focus_widget;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_window__get_default_widget(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_WINDOW(NSP_GOBJECT_GET(self))->default_widget;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_window__get_transient_parent(NspObject *self,char *attr)
{
  GtkWindow *ret;

  ret = (GtkWindow*) GTK_WINDOW(NSP_GOBJECT_GET(self))->transient_parent;
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindow);
}

static NspObject *_wrap_gtk_window__get_frame(NspObject *self,char *attr)
{
  GdkWindow *ret;

  ret = (GdkWindow*) GTK_WINDOW(NSP_GOBJECT_GET(self))->frame;
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow);
}

static NspObject *_wrap_gtk_window__get_group(NspObject *self,char *attr)
{
  GtkWindowGroup *ret;

  ret = (GtkWindowGroup*) GTK_WINDOW(NSP_GOBJECT_GET(self))->group;
  nsp_type_gtkwindowgroup = new_type_gtkwindowgroup(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindowgroup);
}

static NspObject *_wrap_gtk_window__get_configure_request_count(NspObject *self,char *attr)
{
  int ret;

  ret = (guint16) GTK_WINDOW(NSP_GOBJECT_GET(self))->configure_request_count;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_allow_shrink(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->allow_shrink;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_allow_grow(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->allow_grow;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_configure_notify_received(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->configure_notify_received;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_need_default_position(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->need_default_position;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_need_default_size(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->need_default_size;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_position(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->position;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_type(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->type;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_has_user_ref_count(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->has_user_ref_count;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_has_focus(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->has_focus;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_modal(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->modal;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_destroy_with_parent(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->destroy_with_parent;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_has_frame(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->has_frame;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_iconify_initially(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->iconify_initially;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_stick_initially(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->stick_initially;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_maximize_initially(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->maximize_initially;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_decorated(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->decorated;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_type_hint(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->type_hint;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_gravity(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->gravity;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_frame_left(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->frame_left;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_frame_top(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->frame_top;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_frame_right(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->frame_right;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_frame_bottom(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->frame_bottom;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_keys_changed_handler(NspObject *self,char *attr)
{
  int ret;

  ret = (guint) GTK_WINDOW(NSP_GOBJECT_GET(self))->keys_changed_handler;
  return nsp_new_double_obj((double) ret);
}

static NspObject *_wrap_gtk_window__get_mnemonic_modifier(NspObject *self,char *attr)
{
  guint ret;

  ret = (GdkModifierType) GTK_WINDOW(NSP_GOBJECT_GET(self))->mnemonic_modifier;
  return nsp_new_double_obj((double) ret);
}

static AttrTab gtkwindow_attrs[] = {
  { "title", (attr_get_function *)_wrap_gtk_window__get_title, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "wmclass_name", (attr_get_function *)_wrap_gtk_window__get_wmclass_name, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "wmclass_class", (attr_get_function *)_wrap_gtk_window__get_wmclass_class, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "wm_role", (attr_get_function *)_wrap_gtk_window__get_wm_role, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "focus_widget", (attr_get_function *)_wrap_gtk_window__get_focus_widget, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "default_widget", (attr_get_function *)_wrap_gtk_window__get_default_widget, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "transient_parent", (attr_get_function *)_wrap_gtk_window__get_transient_parent, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "frame", (attr_get_function *)_wrap_gtk_window__get_frame, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "group", (attr_get_function *)_wrap_gtk_window__get_group, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "configure_request_count", (attr_get_function *)_wrap_gtk_window__get_configure_request_count, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "allow_shrink", (attr_get_function *)_wrap_gtk_window__get_allow_shrink, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "allow_grow", (attr_get_function *)_wrap_gtk_window__get_allow_grow, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "configure_notify_received", (attr_get_function *)_wrap_gtk_window__get_configure_notify_received, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "need_default_position", (attr_get_function *)_wrap_gtk_window__get_need_default_position, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "need_default_size", (attr_get_function *)_wrap_gtk_window__get_need_default_size, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "position", (attr_get_function *)_wrap_gtk_window__get_position, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "type", (attr_get_function *)_wrap_gtk_window__get_type, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "has_user_ref_count", (attr_get_function *)_wrap_gtk_window__get_has_user_ref_count, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "has_focus", (attr_get_function *)_wrap_gtk_window__get_has_focus, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "modal", (attr_get_function *)_wrap_gtk_window__get_modal, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "destroy_with_parent", (attr_get_function *)_wrap_gtk_window__get_destroy_with_parent, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "has_frame", (attr_get_function *)_wrap_gtk_window__get_has_frame, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "iconify_initially", (attr_get_function *)_wrap_gtk_window__get_iconify_initially, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "stick_initially", (attr_get_function *)_wrap_gtk_window__get_stick_initially, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "maximize_initially", (attr_get_function *)_wrap_gtk_window__get_maximize_initially, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "decorated", (attr_get_function *)_wrap_gtk_window__get_decorated, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "type_hint", (attr_get_function *)_wrap_gtk_window__get_type_hint, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "gravity", (attr_get_function *)_wrap_gtk_window__get_gravity, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "frame_left", (attr_get_function *)_wrap_gtk_window__get_frame_left, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "frame_top", (attr_get_function *)_wrap_gtk_window__get_frame_top, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "frame_right", (attr_get_function *)_wrap_gtk_window__get_frame_right, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "frame_bottom", (attr_get_function *)_wrap_gtk_window__get_frame_bottom, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "keys_changed_handler", (attr_get_function *)_wrap_gtk_window__get_keys_changed_handler, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "mnemonic_modifier", (attr_get_function *)_wrap_gtk_window__get_mnemonic_modifier, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkPlug ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkPlug_Private 
#include "nsp/gtk/gtkplug.h"
#include "nsp/interf.h"

/* NspGtkPlug inherits from NspGtkWindow */ 

int nsp_type_gtkplug_id=0;
NspTypeGtkPlug *nsp_type_gtkplug=NULL;

NspTypeGtkPlug *new_type_gtkplug(type_mode mode)
{
  NspTypeGtkPlug *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkplug != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkplug;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWindow))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwindow(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkplug_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkplug_get_methods; 
  type->new = (new_func *) new_gtkplug;

  /* specific methods for gtkplug */
      
  type->init = (init_func *) init_gtkplug;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkplug */ 

  top->s_type =  (s_type_func *) gtkplug_type_as_string;    
  top->sh_type = (sh_type_func *) gtkplug_type_short_string;
  /* top->create = (create_func*) int_gtkplug_create;*/ 
  
  /* specific methods for gtkplug */
      
  type->init = (init_func *) init_gtkplug;

  if ( nsp_type_gtkplug_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkPlug called nsp_type_gtkplug
       */
      type->id =  nsp_type_gtkplug_id = nsp_new_type_id();
      nsp_type_gtkplug = type;
      if ( nsp_register_type(nsp_type_gtkplug) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkplug, GTK_TYPE_PLUG);
      return ( mode == T_BASE ) ? type : new_type_gtkplug(mode);
    }
  else 
    {
       type->id = nsp_type_gtkplug_id;
       return type;
    }
}

/*
 * initialize GtkPlug instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkplug(NspGtkPlug *o,NspTypeGtkPlug *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkPlug 
 */

NspGtkPlug *new_gtkplug() 
{
  NspGtkPlug *loc; 
  /* type must exists */
  nsp_type_gtkplug = new_type_gtkplug(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkPlug)))== NULLGTKPLUG) return loc;
  /* initialize object */
  if ( init_gtkplug(loc,nsp_type_gtkplug) == FAIL) return NULLGTKPLUG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkPlug 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkplug_type_name[]="GtkPlug";
static char gtkplug_short_type_name[]="GtkPlug";

static char *gtkplug_type_as_string(void)
{
  return(gtkplug_type_name);
}

static char *gtkplug_type_short_string(void)
{
  return(gtkplug_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkPlug objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkPlug   *gtkplug_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkplug_id) ) return ((NspGtkPlug *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkplug));
  return NULL;
}

int IsGtkPlugObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkplug_id);
}

int IsGtkPlug(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkplug_id);
}

NspGtkPlug  *GetGtkPlugCopy(Stack stack, int i)
{
  if (  GetGtkPlug(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkPlug  *GetGtkPlug(Stack stack, int i)
{
  NspGtkPlug *M;
  if (( M = gtkplug_object(NthObj(i))) == NULLGTKPLUG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkPlug *gtkplug_copy(NspGtkPlug *self)
{
  /* return gtkwindow_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkplug);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkplug);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkPlug
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkPlug *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkplug is initialized * /
  nsp_type_gtkplug = new_type_gtkplug(T_BASE);
  if(( H = gtkwindow_create(NVOID,(NspTypeBase *) nsp_type_gtkplug)) == NULLGTKPLUG) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkplug_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int,t_end};
  gulong socket_id;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&socket_id) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_plug_new(socket_id))== NULL) return RET_BUG;

  nsp_type_gtkplug = new_type_gtkplug(T_BASE);
    /* g_xxxx_object_ref(ret); XXXwe don't own the first reference of windows */
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkplug );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_plug_construct(NspGtkPlug *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  gulong socket_id;

  if ( GetArgs(stack,rhs,opt,T,&socket_id) == FAIL) return RET_BUG;
  gtk_plug_construct(GTK_PLUG(self->obj), socket_id);
  return 0;
}

static int _wrap_gtk_plug_get_id(NspGtkPlug *self,Stack stack,int rhs,int opt,int lhs)
{
  gulong ret;

  ret = gtk_plug_get_id(GTK_PLUG(self->obj));
 if (  nsp_move_double(stack,1,(double) ret) == FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkplug_methods[] = {
  {"construct",(nsp_method *) _wrap_gtk_plug_construct},
  {"get_id",(nsp_method *) _wrap_gtk_plug_get_id},
  { NULL, NULL}
};

static NspMethods *gtkplug_get_methods(void) { return gtkplug_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkplug_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkDialog ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkDialog_Private 
#include "nsp/gtk/gtkdialog.h"
#include "nsp/interf.h"

/* NspGtkDialog inherits from NspGtkWindow */ 

int nsp_type_gtkdialog_id=0;
NspTypeGtkDialog *nsp_type_gtkdialog=NULL;

NspTypeGtkDialog *new_type_gtkdialog(type_mode mode)
{
  NspTypeGtkDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkdialog != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkdialog;
    }
  if ((type =  malloc(sizeof(NspTypeGtkWindow))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwindow(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkdialog_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkdialog_get_methods; 
  type->new = (new_func *) new_gtkdialog;

  /* specific methods for gtkdialog */
      
  type->init = (init_func *) init_gtkdialog;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkdialog */ 

  top->s_type =  (s_type_func *) gtkdialog_type_as_string;    
  top->sh_type = (sh_type_func *) gtkdialog_type_short_string;
  /* top->create = (create_func*) int_gtkdialog_create;*/ 
  
  /* specific methods for gtkdialog */
      
  type->init = (init_func *) init_gtkdialog;

  if ( nsp_type_gtkdialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkDialog called nsp_type_gtkdialog
       */
      type->id =  nsp_type_gtkdialog_id = nsp_new_type_id();
      nsp_type_gtkdialog = type;
      if ( nsp_register_type(nsp_type_gtkdialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkdialog, GTK_TYPE_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkdialog(mode);
    }
  else 
    {
       type->id = nsp_type_gtkdialog_id;
       return type;
    }
}

/*
 * initialize GtkDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkdialog(NspGtkDialog *o,NspTypeGtkDialog *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkDialog 
 */

NspGtkDialog *new_gtkdialog() 
{
  NspGtkDialog *loc; 
  /* type must exists */
  nsp_type_gtkdialog = new_type_gtkdialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkDialog)))== NULLGTKDIALOG) return loc;
  /* initialize object */
  if ( init_gtkdialog(loc,nsp_type_gtkdialog) == FAIL) return NULLGTKDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkDialog 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkdialog_type_name[]="GtkDialog";
static char gtkdialog_short_type_name[]="GtkDialog";

static char *gtkdialog_type_as_string(void)
{
  return(gtkdialog_type_name);
}

static char *gtkdialog_type_short_string(void)
{
  return(gtkdialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkDialog objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkDialog   *gtkdialog_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkdialog_id) ) return ((NspGtkDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkdialog));
  return NULL;
}

int IsGtkDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkdialog_id);
}

int IsGtkDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkdialog_id);
}

NspGtkDialog  *GetGtkDialogCopy(Stack stack, int i)
{
  if (  GetGtkDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkDialog  *GetGtkDialog(Stack stack, int i)
{
  NspGtkDialog *M;
  if (( M = gtkdialog_object(NthObj(i))) == NULLGTKDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkDialog *gtkdialog_copy(NspGtkDialog *self)
{
  /* return gtkwindow_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkdialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkdialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkDialog *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkdialog is initialized * /
  nsp_type_gtkdialog = new_type_gtkdialog(T_BASE);
  if(( H = gtkwindow_create(NVOID,(NspTypeBase *) nsp_type_gtkdialog)) == NULLGTKDIALOG) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 5850 "gtk.override"

/* gtk_dialog_new gtk_dialog_new_with_buttons are mixed here */ 
static int
_wrap_gtkdialog_new(Stack stack,int rhs,int opt,int lhs)
{
  gchar *title = NULL;
  NspGObject *nsp_window = NULL;
  GObject *ret;
  NspSMatrix *nsp_buttons = NULL;
  NspObject *nsp_ret;
  GtkDialogFlags flags = 0;
  int i;
  
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"title",string,NULLOBJ,-1}, 
    {"parent",obj,NULLOBJ,-1}, 
    {"flags",s_int,NULLOBJ,-1}, 
    {"buttons",smat,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };
  
  if (GetArgs(stack,rhs,opt,T,&opts, &title, &nsp_window, &flags, &nsp_buttons)== FAIL) return RET_BUG; 
  
  if ( nsp_window != NULL && ! nspgobject_check(nsp_window, nsp_type_gtkwindow)) {
    Scierror("window must be a GtkWindow");
    return RET_BUG;
  }
  ret =(GObject *)  gtk_dialog_new_with_buttons(title, (nsp_window != NULL) ? GTK_WINDOW(nsp_window->obj) : NULL,
						flags, NULL);
  if ( ret == NULL) {
    Scierror("could not create GtkDialog object");
    return RET_BUG;
  }
  if ( nsp_buttons != NULL) 
    {
      for (i = 0; i < nsp_buttons->mn ; i ++) 
	{
	  gtk_dialog_add_button(GTK_DIALOG(ret), nsp_buttons->S[i],i+1);
	}
    }
  nspg_block_threads();
  nsp_type_gtkdialog = new_type_gtkdialog(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *) ret,(NspTypeBase *) nsp_type_gtkdialog))== NULL)
    return RET_BUG; 
  nspg_unblock_threads();
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 46113 "gtk.c"


static int _wrap_gtk_dialog_add_action_widget(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, s_int,t_end};
  int response_id;
  NspGObject *child;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &response_id) == FAIL) return RET_BUG;
  gtk_dialog_add_action_widget(GTK_DIALOG(self->obj), GTK_WIDGET(child->obj), response_id);
  return 0;
}

static int _wrap_gtk_dialog_add_button(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, s_int,t_end};
  char *button_text;
  int response_id;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&button_text, &response_id) == FAIL) return RET_BUG;
  ret = gtk_dialog_add_button(GTK_DIALOG(self->obj), button_text, response_id);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_dialog_set_response_sensitive(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, s_bool,t_end};
  int response_id, setting;

  if ( GetArgs(stack,rhs,opt,T,&response_id, &setting) == FAIL) return RET_BUG;
  gtk_dialog_set_response_sensitive(GTK_DIALOG(self->obj), response_id, setting);
  return 0;
}

static int _wrap_gtk_dialog_set_default_response(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int response_id;

  if ( GetArgs(stack,rhs,opt,T,&response_id) == FAIL) return RET_BUG;
  gtk_dialog_set_default_response(GTK_DIALOG(self->obj), response_id);
  return 0;
}

static int _wrap_gtk_dialog_set_has_separator(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
  gtk_dialog_set_has_separator(GTK_DIALOG(self->obj), setting);
  return 0;
}

static int _wrap_gtk_dialog_get_has_separator(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_dialog_get_has_separator(GTK_DIALOG(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_dialog_response(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int response_id;

  if ( GetArgs(stack,rhs,opt,T,&response_id) == FAIL) return RET_BUG;
  gtk_dialog_response(GTK_DIALOG(self->obj), response_id);
  return 0;
}

#line 5900 "gtk.override"
static int
_wrap_gtk_dialog_run(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint retval;
  
  nspg_unblock_threads();
  retval = gtk_dialog_run(GTK_DIALOG(self->obj));
  nspg_block_threads();
  if ( nsp_move_double(stack,1,(double)retval) == FAIL) return RET_BUG; 
  return 1;
}
#line 46204 "gtk.c"


static NspMethods gtkdialog_methods[] = {
  {"add_action_widget",(nsp_method *) _wrap_gtk_dialog_add_action_widget},
  {"add_button",(nsp_method *) _wrap_gtk_dialog_add_button},
  {"set_response_sensitive",(nsp_method *) _wrap_gtk_dialog_set_response_sensitive},
  {"set_default_response",(nsp_method *) _wrap_gtk_dialog_set_default_response},
  {"set_has_separator",(nsp_method *) _wrap_gtk_dialog_set_has_separator},
  {"get_has_separator",(nsp_method *) _wrap_gtk_dialog_get_has_separator},
  {"response",(nsp_method *) _wrap_gtk_dialog_response},
  {"run",(nsp_method *) _wrap_gtk_dialog_run},
  { NULL, NULL}
};

static NspMethods *gtkdialog_get_methods(void) { return gtkdialog_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_dialog__get_vbox(NspObject *self,char *attr)
{
  GtkVBox *ret;

  ret = (GtkVBox*) GTK_DIALOG(NSP_GOBJECT_GET(self))->vbox;
  nsp_type_gtkvbox = new_type_gtkvbox(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkvbox);
}

static NspObject *_wrap_gtk_dialog__get_action_area(NspObject *self,char *attr)
{
  GtkHButtonBox *ret;

  ret = (GtkHButtonBox*) GTK_DIALOG(NSP_GOBJECT_GET(self))->action_area;
  nsp_type_gtkhbuttonbox = new_type_gtkhbuttonbox(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkhbuttonbox);
}

static AttrTab gtkdialog_attrs[] = {
  { "vbox", (attr_get_function *)_wrap_gtk_dialog__get_vbox, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "action_area", (attr_get_function *)_wrap_gtk_dialog__get_action_area, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkMessageDialog ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkMessageDialog_Private 
#include "nsp/gtk/gtkmessagedialog.h"
#include "nsp/interf.h"

/* NspGtkMessageDialog inherits from NspGtkDialog */ 

int nsp_type_gtkmessagedialog_id=0;
NspTypeGtkMessageDialog *nsp_type_gtkmessagedialog=NULL;

NspTypeGtkMessageDialog *new_type_gtkmessagedialog(type_mode mode)
{
  NspTypeGtkMessageDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmessagedialog != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmessagedialog;
    }
  if ((type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmessagedialog_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkmessagedialog_get_methods; 
  type->new = (new_func *) new_gtkmessagedialog;

  /* specific methods for gtkmessagedialog */
      
  type->init = (init_func *) init_gtkmessagedialog;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkmessagedialog */ 

  top->s_type =  (s_type_func *) gtkmessagedialog_type_as_string;    
  top->sh_type = (sh_type_func *) gtkmessagedialog_type_short_string;
  /* top->create = (create_func*) int_gtkmessagedialog_create;*/ 
  
  /* specific methods for gtkmessagedialog */
      
  type->init = (init_func *) init_gtkmessagedialog;

  if ( nsp_type_gtkmessagedialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMessageDialog called nsp_type_gtkmessagedialog
       */
      type->id =  nsp_type_gtkmessagedialog_id = nsp_new_type_id();
      nsp_type_gtkmessagedialog = type;
      if ( nsp_register_type(nsp_type_gtkmessagedialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmessagedialog, GTK_TYPE_MESSAGE_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkmessagedialog(mode);
    }
  else 
    {
       type->id = nsp_type_gtkmessagedialog_id;
       return type;
    }
}

/*
 * initialize GtkMessageDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmessagedialog(NspGtkMessageDialog *o,NspTypeGtkMessageDialog *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkMessageDialog 
 */

NspGtkMessageDialog *new_gtkmessagedialog() 
{
  NspGtkMessageDialog *loc; 
  /* type must exists */
  nsp_type_gtkmessagedialog = new_type_gtkmessagedialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMessageDialog)))== NULLGTKMESSAGEDIALOG) return loc;
  /* initialize object */
  if ( init_gtkmessagedialog(loc,nsp_type_gtkmessagedialog) == FAIL) return NULLGTKMESSAGEDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkMessageDialog 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkmessagedialog_type_name[]="GtkMessageDialog";
static char gtkmessagedialog_short_type_name[]="GtkMessageDialog";

static char *gtkmessagedialog_type_as_string(void)
{
  return(gtkmessagedialog_type_name);
}

static char *gtkmessagedialog_type_short_string(void)
{
  return(gtkmessagedialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkMessageDialog objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkMessageDialog   *gtkmessagedialog_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkmessagedialog_id) ) return ((NspGtkMessageDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmessagedialog));
  return NULL;
}

int IsGtkMessageDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkmessagedialog_id);
}

int IsGtkMessageDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmessagedialog_id);
}

NspGtkMessageDialog  *GetGtkMessageDialogCopy(Stack stack, int i)
{
  if (  GetGtkMessageDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMessageDialog  *GetGtkMessageDialog(Stack stack, int i)
{
  NspGtkMessageDialog *M;
  if (( M = gtkmessagedialog_object(NthObj(i))) == NULLGTKMESSAGEDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMessageDialog *gtkmessagedialog_copy(NspGtkMessageDialog *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmessagedialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmessagedialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMessageDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkMessageDialog *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkmessagedialog is initialized * /
  nsp_type_gtkmessagedialog = new_type_gtkmessagedialog(T_BASE);
  if(( H = gtkdialog_create(NVOID,(NspTypeBase *) nsp_type_gtkmessagedialog)) == NULLGTKMESSAGEDIALOG) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

#line 5913 "gtk.override"
/* XXXXX accepter une matrice pour message a concatener */ 
static int
_wrap_gtkmessagedialog_new(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GObject *gobj;
  GtkButtonsType buttons = GTK_BUTTONS_NONE;
  int_types T[] = {new_opts, t_end} ;
  nsp_option opts[] = {
    {"parent",obj_check,NULLOBJ,-1}, 
    {"flags",obj,NULLOBJ,-1}, 
    {"type",obj,NULLOBJ,-1}, 
    {"buttons",obj,NULLOBJ,-1}, 
    {"message",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };

  /* static char *kwlist[] = { "parent", "flags", "type", "buttons", "message_format", NULL };*/
  NspObject *nsp_flags = NULL, *nsp_type = NULL, *nsp_buttons = NULL;
  GtkDialogFlags flags = 0;
  GtkWindow *parent = NULL;
  GtkMessageType type = GTK_MESSAGE_INFO;
  NspGObject *nsp_parent = NULL;
  char *message_format = NULL;

  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type_gtkwindow, &nsp_parent, &nsp_flags, &nsp_type, &nsp_buttons, &message_format)== FAIL)
    return RET_BUG;
  if ( nsp_parent != NULL) parent = GTK_WINDOW(nsp_parent->obj);
  if (nspg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, nsp_flags, &flags))
    return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_MESSAGE_TYPE, nsp_type,&type))
    return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_BUTTONS_TYPE, nsp_buttons, &buttons))
    return RET_BUG;
  
  gobj = (GObject *)gtk_message_dialog_new(parent, flags, type, buttons, "%s", message_format);
  if (gobj == NULL ) {
        Scierror( "could not create GtkMessageDialog object");
        return RET_BUG;
    }

  if ((nsp_ret = (NspObject *) gobject_create(NVOID, gobj,(NspTypeBase *) nsp_type_gtkmessagedialog))== NULL) 
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 46490 "gtk.c"


static NspMethods *gtkmessagedialog_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_message_dialog__get_image(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_MESSAGE_DIALOG(NSP_GOBJECT_GET(self))->image;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_message_dialog__get_label(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_MESSAGE_DIALOG(NSP_GOBJECT_GET(self))->label;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static AttrTab gtkmessagedialog_attrs[] = {
  { "image", (attr_get_function *)_wrap_gtk_message_dialog__get_image, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "label", (attr_get_function *)_wrap_gtk_message_dialog__get_label, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkInputDialog ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkInputDialog_Private 
#include "nsp/gtk/gtkinputdialog.h"
#include "nsp/interf.h"

/* NspGtkInputDialog inherits from NspGtkDialog */ 

int nsp_type_gtkinputdialog_id=0;
NspTypeGtkInputDialog *nsp_type_gtkinputdialog=NULL;

NspTypeGtkInputDialog *new_type_gtkinputdialog(type_mode mode)
{
  NspTypeGtkInputDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkinputdialog != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkinputdialog;
    }
  if ((type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkinputdialog_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkinputdialog_get_methods; 
  type->new = (new_func *) new_gtkinputdialog;

  /* specific methods for gtkinputdialog */
      
  type->init = (init_func *) init_gtkinputdialog;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkinputdialog */ 

  top->s_type =  (s_type_func *) gtkinputdialog_type_as_string;    
  top->sh_type = (sh_type_func *) gtkinputdialog_type_short_string;
  /* top->create = (create_func*) int_gtkinputdialog_create;*/ 
  
  /* specific methods for gtkinputdialog */
      
  type->init = (init_func *) init_gtkinputdialog;

  if ( nsp_type_gtkinputdialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkInputDialog called nsp_type_gtkinputdialog
       */
      type->id =  nsp_type_gtkinputdialog_id = nsp_new_type_id();
      nsp_type_gtkinputdialog = type;
      if ( nsp_register_type(nsp_type_gtkinputdialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkinputdialog, GTK_TYPE_INPUT_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkinputdialog(mode);
    }
  else 
    {
       type->id = nsp_type_gtkinputdialog_id;
       return type;
    }
}

/*
 * initialize GtkInputDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkinputdialog(NspGtkInputDialog *o,NspTypeGtkInputDialog *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkInputDialog 
 */

NspGtkInputDialog *new_gtkinputdialog() 
{
  NspGtkInputDialog *loc; 
  /* type must exists */
  nsp_type_gtkinputdialog = new_type_gtkinputdialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkInputDialog)))== NULLGTKINPUTDIALOG) return loc;
  /* initialize object */
  if ( init_gtkinputdialog(loc,nsp_type_gtkinputdialog) == FAIL) return NULLGTKINPUTDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkInputDialog 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkinputdialog_type_name[]="GtkInputDialog";
static char gtkinputdialog_short_type_name[]="GtkInputDialog";

static char *gtkinputdialog_type_as_string(void)
{
  return(gtkinputdialog_type_name);
}

static char *gtkinputdialog_type_short_string(void)
{
  return(gtkinputdialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkInputDialog objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkInputDialog   *gtkinputdialog_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkinputdialog_id) ) return ((NspGtkInputDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkinputdialog));
  return NULL;
}

int IsGtkInputDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkinputdialog_id);
}

int IsGtkInputDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkinputdialog_id);
}

NspGtkInputDialog  *GetGtkInputDialogCopy(Stack stack, int i)
{
  if (  GetGtkInputDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkInputDialog  *GetGtkInputDialog(Stack stack, int i)
{
  NspGtkInputDialog *M;
  if (( M = gtkinputdialog_object(NthObj(i))) == NULLGTKINPUTDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkInputDialog *gtkinputdialog_copy(NspGtkInputDialog *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkinputdialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkinputdialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkInputDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkInputDialog *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkinputdialog is initialized * /
  nsp_type_gtkinputdialog = new_type_gtkinputdialog(T_BASE);
  if(( H = gtkdialog_create(NVOID,(NspTypeBase *) nsp_type_gtkinputdialog)) == NULLGTKINPUTDIALOG) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkinputdialog_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_input_dialog_new())== NULL) return RET_BUG;

  nsp_type_gtkinputdialog = new_type_gtkinputdialog(T_BASE);
    /* g_xxxx_object_ref(ret); XXXwe don't own the first reference of windows */
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkinputdialog );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkinputdialog_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkinputdialog_attrs[]={{NULL,NULL,NULL}} ;


/* ----------- GtkFontSelectionDialog ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkFontSelectionDialog_Private 
#include "nsp/gtk/gtkfontselectiondialog.h"
#include "nsp/interf.h"

/* NspGtkFontSelectionDialog inherits from NspGtkDialog */ 

int nsp_type_gtkfontselectiondialog_id=0;
NspTypeGtkFontSelectionDialog *nsp_type_gtkfontselectiondialog=NULL;

NspTypeGtkFontSelectionDialog *new_type_gtkfontselectiondialog(type_mode mode)
{
  NspTypeGtkFontSelectionDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfontselectiondialog != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfontselectiondialog;
    }
  if ((type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfontselectiondialog_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkfontselectiondialog_get_methods; 
  type->new = (new_func *) new_gtkfontselectiondialog;

  /* specific methods for gtkfontselectiondialog */
      
  type->init = (init_func *) init_gtkfontselectiondialog;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkfontselectiondialog */ 

  top->s_type =  (s_type_func *) gtkfontselectiondialog_type_as_string;    
  top->sh_type = (sh_type_func *) gtkfontselectiondialog_type_short_string;
  /* top->create = (create_func*) int_gtkfontselectiondialog_create;*/ 
  
  /* specific methods for gtkfontselectiondialog */
      
  type->init = (init_func *) init_gtkfontselectiondialog;

  if ( nsp_type_gtkfontselectiondialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFontSelectionDialog called nsp_type_gtkfontselectiondialog
       */
      type->id =  nsp_type_gtkfontselectiondialog_id = nsp_new_type_id();
      nsp_type_gtkfontselectiondialog = type;
      if ( nsp_register_type(nsp_type_gtkfontselectiondialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfontselectiondialog, GTK_TYPE_FONT_SELECTION_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkfontselectiondialog(mode);
    }
  else 
    {
       type->id = nsp_type_gtkfontselectiondialog_id;
       return type;
    }
}

/*
 * initialize GtkFontSelectionDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfontselectiondialog(NspGtkFontSelectionDialog *o,NspTypeGtkFontSelectionDialog *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkFontSelectionDialog 
 */

NspGtkFontSelectionDialog *new_gtkfontselectiondialog() 
{
  NspGtkFontSelectionDialog *loc; 
  /* type must exists */
  nsp_type_gtkfontselectiondialog = new_type_gtkfontselectiondialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFontSelectionDialog)))== NULLGTKFONTSELECTIONDIALOG) return loc;
  /* initialize object */
  if ( init_gtkfontselectiondialog(loc,nsp_type_gtkfontselectiondialog) == FAIL) return NULLGTKFONTSELECTIONDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkFontSelectionDialog 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkfontselectiondialog_type_name[]="GtkFontSelectionDialog";
static char gtkfontselectiondialog_short_type_name[]="GtkFontSelectionDialog";

static char *gtkfontselectiondialog_type_as_string(void)
{
  return(gtkfontselectiondialog_type_name);
}

static char *gtkfontselectiondialog_type_short_string(void)
{
  return(gtkfontselectiondialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkFontSelectionDialog objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkFontSelectionDialog   *gtkfontselectiondialog_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkfontselectiondialog_id) ) return ((NspGtkFontSelectionDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfontselectiondialog));
  return NULL;
}

int IsGtkFontSelectionDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkfontselectiondialog_id);
}

int IsGtkFontSelectionDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfontselectiondialog_id);
}

NspGtkFontSelectionDialog  *GetGtkFontSelectionDialogCopy(Stack stack, int i)
{
  if (  GetGtkFontSelectionDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFontSelectionDialog  *GetGtkFontSelectionDialog(Stack stack, int i)
{
  NspGtkFontSelectionDialog *M;
  if (( M = gtkfontselectiondialog_object(NthObj(i))) == NULLGTKFONTSELECTIONDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFontSelectionDialog *gtkfontselectiondialog_copy(NspGtkFontSelectionDialog *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontselectiondialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontselectiondialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFontSelectionDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkFontSelectionDialog *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkfontselectiondialog is initialized * /
  nsp_type_gtkfontselectiondialog = new_type_gtkfontselectiondialog(T_BASE);
  if(( H = gtkdialog_create(NVOID,(NspTypeBase *) nsp_type_gtkfontselectiondialog)) == NULLGTKFONTSELECTIONDIALOG) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkfontselectiondialog_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *title;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_font_selection_dialog_new(title))== NULL) return RET_BUG;

  nsp_type_gtkfontselectiondialog = new_type_gtkfontselectiondialog(T_BASE);
    /* g_xxxx_object_ref(ret); XXXwe don't own the first reference of windows */
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkfontselectiondialog );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_font_selection_dialog_get_font_name(NspGtkFontSelectionDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;

  ret = gtk_font_selection_dialog_get_font_name(GTK_FONT_SELECTION_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_font_selection_dialog_get_font(NspGtkFontSelectionDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkFont *ret;
  NspObject *nsp_ret;

  Scierror("%s: deprecated use GtkFontSelectionDialog.get_font_name",stack.fname); return RET_BUG;
  ret = gtk_font_selection_dialog_get_font(GTK_FONT_SELECTION_DIALOG(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_FONT, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkfont))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_font_selection_dialog_set_font_name(NspGtkFontSelectionDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *fontname;
  int ret;

  if ( GetArgs(stack,rhs,opt,T,&fontname) == FAIL) return RET_BUG;
  ret = gtk_font_selection_dialog_set_font_name(GTK_FONT_SELECTION_DIALOG(self->obj), fontname);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_font_selection_dialog_get_preview_text(NspGtkFontSelectionDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_font_selection_dialog_get_preview_text(GTK_FONT_SELECTION_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_font_selection_dialog_set_preview_text(NspGtkFontSelectionDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *text;

  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
  gtk_font_selection_dialog_set_preview_text(GTK_FONT_SELECTION_DIALOG(self->obj), text);
  return 0;
}

static NspMethods gtkfontselectiondialog_methods[] = {
  {"get_font_name",(nsp_method *) _wrap_gtk_font_selection_dialog_get_font_name},
  {"get_font",(nsp_method *) _wrap_gtk_font_selection_dialog_get_font},
  {"set_font_name",(nsp_method *) _wrap_gtk_font_selection_dialog_set_font_name},
  {"get_preview_text",(nsp_method *) _wrap_gtk_font_selection_dialog_get_preview_text},
  {"set_preview_text",(nsp_method *) _wrap_gtk_font_selection_dialog_set_preview_text},
  { NULL, NULL}
};

static NspMethods *gtkfontselectiondialog_get_methods(void) { return gtkfontselectiondialog_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_font_selection_dialog__get_fontsel(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_FONT_SELECTION_DIALOG(NSP_GOBJECT_GET(self))->fontsel;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_font_selection_dialog__get_main_vbox(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_FONT_SELECTION_DIALOG(NSP_GOBJECT_GET(self))->main_vbox;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_font_selection_dialog__get_action_area(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_FONT_SELECTION_DIALOG(NSP_GOBJECT_GET(self))->action_area;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_font_selection_dialog__get_ok_button(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_FONT_SELECTION_DIALOG(NSP_GOBJECT_GET(self))->ok_button;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_font_selection_dialog__get_apply_button(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_FONT_SELECTION_DIALOG(NSP_GOBJECT_GET(self))->apply_button;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_font_selection_dialog__get_cancel_button(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_FONT_SELECTION_DIALOG(NSP_GOBJECT_GET(self))->cancel_button;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static AttrTab gtkfontselectiondialog_attrs[] = {
  { "fontsel", (attr_get_function *)_wrap_gtk_font_selection_dialog__get_fontsel, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "main_vbox", (attr_get_function *)_wrap_gtk_font_selection_dialog__get_main_vbox, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "action_area", (attr_get_function *)_wrap_gtk_font_selection_dialog__get_action_area, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "ok_button", (attr_get_function *)_wrap_gtk_font_selection_dialog__get_ok_button, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "apply_button", (attr_get_function *)_wrap_gtk_font_selection_dialog__get_apply_button, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "cancel_button", (attr_get_function *)_wrap_gtk_font_selection_dialog__get_cancel_button, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkFileSelection ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkFileSelection_Private 
#include "nsp/gtk/gtkfileselection.h"
#include "nsp/interf.h"

/* NspGtkFileSelection inherits from NspGtkDialog */ 

int nsp_type_gtkfileselection_id=0;
NspTypeGtkFileSelection *nsp_type_gtkfileselection=NULL;

NspTypeGtkFileSelection *new_type_gtkfileselection(type_mode mode)
{
  NspTypeGtkFileSelection *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfileselection != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfileselection;
    }
  if ((type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfileselection_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkfileselection_get_methods; 
  type->new = (new_func *) new_gtkfileselection;

  /* specific methods for gtkfileselection */
      
  type->init = (init_func *) init_gtkfileselection;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkfileselection */ 

  top->s_type =  (s_type_func *) gtkfileselection_type_as_string;    
  top->sh_type = (sh_type_func *) gtkfileselection_type_short_string;
  /* top->create = (create_func*) int_gtkfileselection_create;*/ 
  
  /* specific methods for gtkfileselection */
      
  type->init = (init_func *) init_gtkfileselection;

  if ( nsp_type_gtkfileselection_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFileSelection called nsp_type_gtkfileselection
       */
      type->id =  nsp_type_gtkfileselection_id = nsp_new_type_id();
      nsp_type_gtkfileselection = type;
      if ( nsp_register_type(nsp_type_gtkfileselection) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfileselection, GTK_TYPE_FILE_SELECTION);
      return ( mode == T_BASE ) ? type : new_type_gtkfileselection(mode);
    }
  else 
    {
       type->id = nsp_type_gtkfileselection_id;
       return type;
    }
}

/*
 * initialize GtkFileSelection instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfileselection(NspGtkFileSelection *o,NspTypeGtkFileSelection *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkFileSelection 
 */

NspGtkFileSelection *new_gtkfileselection() 
{
  NspGtkFileSelection *loc; 
  /* type must exists */
  nsp_type_gtkfileselection = new_type_gtkfileselection(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFileSelection)))== NULLGTKFILESELECTION) return loc;
  /* initialize object */
  if ( init_gtkfileselection(loc,nsp_type_gtkfileselection) == FAIL) return NULLGTKFILESELECTION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkFileSelection 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkfileselection_type_name[]="GtkFileSelection";
static char gtkfileselection_short_type_name[]="GtkFileSelection";

static char *gtkfileselection_type_as_string(void)
{
  return(gtkfileselection_type_name);
}

static char *gtkfileselection_type_short_string(void)
{
  return(gtkfileselection_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkFileSelection objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkFileSelection   *gtkfileselection_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkfileselection_id) ) return ((NspGtkFileSelection *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfileselection));
  return NULL;
}

int IsGtkFileSelectionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkfileselection_id);
}

int IsGtkFileSelection(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfileselection_id);
}

NspGtkFileSelection  *GetGtkFileSelectionCopy(Stack stack, int i)
{
  if (  GetGtkFileSelection(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFileSelection  *GetGtkFileSelection(Stack stack, int i)
{
  NspGtkFileSelection *M;
  if (( M = gtkfileselection_object(NthObj(i))) == NULLGTKFILESELECTION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFileSelection *gtkfileselection_copy(NspGtkFileSelection *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfileselection);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfileselection);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFileSelection
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkFileSelection *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkfileselection is initialized * /
  nsp_type_gtkfileselection = new_type_gtkfileselection(T_BASE);
  if(( H = gtkdialog_create(NVOID,(NspTypeBase *) nsp_type_gtkfileselection)) == NULLGTKFILESELECTION) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkfileselection_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"title",string,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  char *title = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &title) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_file_selection_new(title))== NULL) return RET_BUG;

  nsp_type_gtkfileselection = new_type_gtkfileselection(T_BASE);
    /* g_xxxx_object_ref(ret); XXXwe don't own the first reference of windows */
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkfileselection );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_file_selection_set_filename(NspGtkFileSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *filename;

  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
  gtk_file_selection_set_filename(GTK_FILE_SELECTION(self->obj), filename);
  return 0;
}

static int _wrap_gtk_file_selection_get_filename(NspGtkFileSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;

  ret = gtk_file_selection_get_filename(GTK_FILE_SELECTION(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_selection_complete(NspGtkFileSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *pattern;

  if ( GetArgs(stack,rhs,opt,T,&pattern) == FAIL) return RET_BUG;
  gtk_file_selection_complete(GTK_FILE_SELECTION(self->obj), pattern);
  return 0;
}

static int _wrap_gtk_file_selection_show_fileop_buttons(NspGtkFileSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_file_selection_show_fileop_buttons(GTK_FILE_SELECTION(self->obj));
  return 0;
}

static int _wrap_gtk_file_selection_hide_fileop_buttons(NspGtkFileSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  gtk_file_selection_hide_fileop_buttons(GTK_FILE_SELECTION(self->obj));
  return 0;
}

#line 6488 "gtk.override"
static int
_wrap_gtk_file_selection_get_selections(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar **filenames = NULL;
  NspObject *ret;
  
  filenames = gtk_file_selection_get_selections(GTK_FILE_SELECTION(self->obj));
  if (( ret = (NspObject *)nsp_smatrix_create_from_table(filenames))== NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;

}
#line 47354 "gtk.c"


static int _wrap_gtk_file_selection_set_select_multiple(NspGtkFileSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,t_end};
  int select_multiple;

  if ( GetArgs(stack,rhs,opt,T,&select_multiple) == FAIL) return RET_BUG;
  gtk_file_selection_set_select_multiple(GTK_FILE_SELECTION(self->obj), select_multiple);
  return 0;
}

static int _wrap_gtk_file_selection_get_select_multiple(NspGtkFileSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;

  ret = gtk_file_selection_get_select_multiple(GTK_FILE_SELECTION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkfileselection_methods[] = {
  {"set_filename",(nsp_method *) _wrap_gtk_file_selection_set_filename},
  {"get_filename",(nsp_method *) _wrap_gtk_file_selection_get_filename},
  {"complete",(nsp_method *) _wrap_gtk_file_selection_complete},
  {"show_fileop_buttons",(nsp_method *) _wrap_gtk_file_selection_show_fileop_buttons},
  {"hide_fileop_buttons",(nsp_method *) _wrap_gtk_file_selection_hide_fileop_buttons},
  {"get_selections",(nsp_method *) _wrap_gtk_file_selection_get_selections},
  {"set_select_multiple",(nsp_method *) _wrap_gtk_file_selection_set_select_multiple},
  {"get_select_multiple",(nsp_method *) _wrap_gtk_file_selection_get_select_multiple},
  { NULL, NULL}
};

static NspMethods *gtkfileselection_get_methods(void) { return gtkfileselection_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_file_selection__get_dir_list(NspObject *self,char *attr)
{
  GtkTreeView *ret;

  ret = (GtkTreeView*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->dir_list;
  nsp_type_gtktreeview = new_type_gtktreeview(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeview);
}

static NspObject *_wrap_gtk_file_selection__get_file_list(NspObject *self,char *attr)
{
  GtkTreeView *ret;

  ret = (GtkTreeView*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->file_list;
  nsp_type_gtktreeview = new_type_gtktreeview(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeview);
}

static NspObject *_wrap_gtk_file_selection__get_selection_entry(NspObject *self,char *attr)
{
  GtkEntry *ret;

  ret = (GtkEntry*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->selection_entry;
  nsp_type_gtkentry = new_type_gtkentry(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkentry);
}

static NspObject *_wrap_gtk_file_selection__get_selection_text(NspObject *self,char *attr)
{
  GtkLabel *ret;

  ret = (GtkLabel*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->selection_text;
  nsp_type_gtklabel = new_type_gtklabel(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtklabel);
}

static NspObject *_wrap_gtk_file_selection__get_main_vbox(NspObject *self,char *attr)
{
  GtkVBox *ret;

  ret = (GtkVBox*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->main_vbox;
  nsp_type_gtkvbox = new_type_gtkvbox(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkvbox);
}

static NspObject *_wrap_gtk_file_selection__get_ok_button(NspObject *self,char *attr)
{
  GtkButton *ret;

  ret = (GtkButton*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->ok_button;
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbutton);
}

static NspObject *_wrap_gtk_file_selection__get_cancel_button(NspObject *self,char *attr)
{
  GtkButton *ret;

  ret = (GtkButton*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->cancel_button;
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbutton);
}

static NspObject *_wrap_gtk_file_selection__get_help_button(NspObject *self,char *attr)
{
  GtkButton *ret;

  ret = (GtkButton*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->help_button;
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbutton);
}

static NspObject *_wrap_gtk_file_selection__get_history_pulldown(NspObject *self,char *attr)
{
  GtkOptionMenu *ret;

  ret = (GtkOptionMenu*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->history_pulldown;
  nsp_type_gtkoptionmenu = new_type_gtkoptionmenu(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkoptionmenu);
}

static NspObject *_wrap_gtk_file_selection__get_history_menu(NspObject *self,char *attr)
{
  GtkMenu *ret;

  ret = (GtkMenu*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->history_menu;
  nsp_type_gtkmenu = new_type_gtkmenu(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkmenu);
}

static NspObject *_wrap_gtk_file_selection__get_fileop_dialog(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->fileop_dialog;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_file_selection__get_fileop_entry(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->fileop_entry;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_file_selection__get_fileop_file(NspObject *self,char *attr)
{
  const gchar *ret;
  NspObject *nsp_ret;

  ret = (gchar*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->fileop_file;
  nsp_ret = nsp_new_string_obj(NVOID,ret,-1);
  return nsp_ret;
}

static NspObject *_wrap_gtk_file_selection__get_fileop_c_dir(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->fileop_c_dir;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_file_selection__get_fileop_del_file(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->fileop_del_file;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_file_selection__get_fileop_ren_file(NspObject *self,char *attr)
{
  GtkWidget *ret;

  ret = (GtkWidget*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->fileop_ren_file;
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget);
}

static NspObject *_wrap_gtk_file_selection__get_button_area(NspObject *self,char *attr)
{
  GtkHButtonBox *ret;

  ret = (GtkHButtonBox*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->button_area;
  nsp_type_gtkhbuttonbox = new_type_gtkhbuttonbox(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkhbuttonbox);
}

static NspObject *_wrap_gtk_file_selection__get_action_area(NspObject *self,char *attr)
{
  GtkHBox *ret;

  ret = (GtkHBox*) GTK_FILE_SELECTION(NSP_GOBJECT_GET(self))->action_area;
  nsp_type_gtkhbox = new_type_gtkhbox(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkhbox);
}

static AttrTab gtkfileselection_attrs[] = {
  { "dir_list", (attr_get_function *)_wrap_gtk_file_selection__get_dir_list, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "file_list", (attr_get_function *)_wrap_gtk_file_selection__get_file_list, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "selection_entry", (attr_get_function *)_wrap_gtk_file_selection__get_selection_entry, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "selection_text", (attr_get_function *)_wrap_gtk_file_selection__get_selection_text, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "main_vbox", (attr_get_function *)_wrap_gtk_file_selection__get_main_vbox, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "ok_button", (attr_get_function *)_wrap_gtk_file_selection__get_ok_button, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "cancel_button", (attr_get_function *)_wrap_gtk_file_selection__get_cancel_button, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "help_button", (attr_get_function *)_wrap_gtk_file_selection__get_help_button, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "history_pulldown", (attr_get_function *)_wrap_gtk_file_selection__get_history_pulldown, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "history_menu", (attr_get_function *)_wrap_gtk_file_selection__get_history_menu, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "fileop_dialog", (attr_get_function *)_wrap_gtk_file_selection__get_fileop_dialog, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "fileop_entry", (attr_get_function *)_wrap_gtk_file_selection__get_fileop_entry, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "fileop_file", (attr_get_function *)_wrap_gtk_file_selection__get_fileop_file, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "fileop_c_dir", (attr_get_function *)_wrap_gtk_file_selection__get_fileop_c_dir, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "fileop_del_file", (attr_get_function *)_wrap_gtk_file_selection__get_fileop_del_file, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "fileop_ren_file", (attr_get_function *)_wrap_gtk_file_selection__get_fileop_ren_file, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "button_area", (attr_get_function *)_wrap_gtk_file_selection__get_button_area, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "action_area", (attr_get_function *)_wrap_gtk_file_selection__get_action_area, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkColorSelectionDialog ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkColorSelectionDialog_Private 
#include "nsp/gtk/gtkcolorselectiondialog.h"
#include "nsp/interf.h"

/* NspGtkColorSelectionDialog inherits from NspGtkDialog */ 

int nsp_type_gtkcolorselectiondialog_id=0;
NspTypeGtkColorSelectionDialog *nsp_type_gtkcolorselectiondialog=NULL;

NspTypeGtkColorSelectionDialog *new_type_gtkcolorselectiondialog(type_mode mode)
{
  NspTypeGtkColorSelectionDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcolorselectiondialog != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcolorselectiondialog;
    }
  if ((type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcolorselectiondialog_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkcolorselectiondialog_get_methods; 
  type->new = (new_func *) new_gtkcolorselectiondialog;

  /* specific methods for gtkcolorselectiondialog */
      
  type->init = (init_func *) init_gtkcolorselectiondialog;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkcolorselectiondialog */ 

  top->s_type =  (s_type_func *) gtkcolorselectiondialog_type_as_string;    
  top->sh_type = (sh_type_func *) gtkcolorselectiondialog_type_short_string;
  /* top->create = (create_func*) int_gtkcolorselectiondialog_create;*/ 
  
  /* specific methods for gtkcolorselectiondialog */
      
  type->init = (init_func *) init_gtkcolorselectiondialog;

  if ( nsp_type_gtkcolorselectiondialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkColorSelectionDialog called nsp_type_gtkcolorselectiondialog
       */
      type->id =  nsp_type_gtkcolorselectiondialog_id = nsp_new_type_id();
      nsp_type_gtkcolorselectiondialog = type;
      if ( nsp_register_type(nsp_type_gtkcolorselectiondialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcolorselectiondialog, GTK_TYPE_COLOR_SELECTION_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkcolorselectiondialog(mode);
    }
  else 
    {
       type->id = nsp_type_gtkcolorselectiondialog_id;
       return type;
    }
}

/*
 * initialize GtkColorSelectionDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcolorselectiondialog(NspGtkColorSelectionDialog *o,NspTypeGtkColorSelectionDialog *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkColorSelectionDialog 
 */

NspGtkColorSelectionDialog *new_gtkcolorselectiondialog() 
{
  NspGtkColorSelectionDialog *loc; 
  /* type must exists */
  nsp_type_gtkcolorselectiondialog = new_type_gtkcolorselectiondialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkColorSelectionDialog)))== NULLGTKCOLORSELECTIONDIALOG) return loc;
  /* initialize object */
  if ( init_gtkcolorselectiondialog(loc,nsp_type_gtkcolorselectiondialog) == FAIL) return NULLGTKCOLORSELECTIONDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkColorSelectionDialog 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkcolorselectiondialog_type_name[]="GtkColorSelectionDialog";
static char gtkcolorselectiondialog_short_type_name[]="GtkColorSelectionDialog";

static char *gtkcolorselectiondialog_type_as_string(void)
{
  return(gtkcolorselectiondialog_type_name);
}

static char *gtkcolorselectiondialog_type_short_string(void)
{
  return(gtkcolorselectiondialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkColorSelectionDialog objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkColorSelectionDialog   *gtkcolorselectiondialog_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkcolorselectiondialog_id) ) return ((NspGtkColorSelectionDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcolorselectiondialog));
  return NULL;
}

int IsGtkColorSelectionDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkcolorselectiondialog_id);
}

int IsGtkColorSelectionDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcolorselectiondialog_id);
}

NspGtkColorSelectionDialog  *GetGtkColorSelectionDialogCopy(Stack stack, int i)
{
  if (  GetGtkColorSelectionDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkColorSelectionDialog  *GetGtkColorSelectionDialog(Stack stack, int i)
{
  NspGtkColorSelectionDialog *M;
  if (( M = gtkcolorselectiondialog_object(NthObj(i))) == NULLGTKCOLORSELECTIONDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkColorSelectionDialog *gtkcolorselectiondialog_copy(NspGtkColorSelectionDialog *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorselectiondialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorselectiondialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkColorSelectionDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkColorSelectionDialog *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkcolorselectiondialog is initialized * /
  nsp_type_gtkcolorselectiondialog = new_type_gtkcolorselectiondialog(T_BASE);
  if(( H = gtkdialog_create(NVOID,(NspTypeBase *) nsp_type_gtkcolorselectiondialog)) == NULLGTKCOLORSELECTIONDIALOG) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkcolorselectiondialog_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *title;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_color_selection_dialog_new(title))== NULL) return RET_BUG;

  nsp_type_gtkcolorselectiondialog = new_type_gtkcolorselectiondialog(T_BASE);
    /* g_xxxx_object_ref(ret); XXXwe don't own the first reference of windows */
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcolorselectiondialog );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkcolorselectiondialog_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static NspObject *_wrap_gtk_color_selection_dialog__get_colorsel(NspObject *self,char *attr)
{
  GtkColorSelection *ret;

  ret = (GtkColorSelection*) GTK_COLOR_SELECTION_DIALOG(NSP_GOBJECT_GET(self))->colorsel;
  nsp_type_gtkcolorselection = new_type_gtkcolorselection(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcolorselection);
}

static NspObject *_wrap_gtk_color_selection_dialog__get_ok_button(NspObject *self,char *attr)
{
  GtkButton *ret;

  ret = (GtkButton*) GTK_COLOR_SELECTION_DIALOG(NSP_GOBJECT_GET(self))->ok_button;
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbutton);
}

static NspObject *_wrap_gtk_color_selection_dialog__get_cancel_button(NspObject *self,char *attr)
{
  GtkButton *ret;

  ret = (GtkButton*) GTK_COLOR_SELECTION_DIALOG(NSP_GOBJECT_GET(self))->cancel_button;
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbutton);
}

static NspObject *_wrap_gtk_color_selection_dialog__get_help_button(NspObject *self,char *attr)
{
  GtkButton *ret;

  ret = (GtkButton*) GTK_COLOR_SELECTION_DIALOG(NSP_GOBJECT_GET(self))->help_button;
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  return (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbutton);
}

static AttrTab gtkcolorselectiondialog_attrs[] = {
  { "colorsel", (attr_get_function *)_wrap_gtk_color_selection_dialog__get_colorsel, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "ok_button", (attr_get_function *)_wrap_gtk_color_selection_dialog__get_ok_button, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "cancel_button", (attr_get_function *)_wrap_gtk_color_selection_dialog__get_cancel_button, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { "help_button", (attr_get_function *)_wrap_gtk_color_selection_dialog__get_help_button, (attr_set_function *)int_set_failed,(attr_get_object_function *)int_get_object_failed },
  { NULL,NULL,NULL,NULL },
};



/* ----------- GtkWindowGroup ----------- */

/* -*- Mode: C -*- */
/*-------------------------------------------------------------------
 * This Software is ( Copyright ENPC 1998-2003 )                          
 * Jean-Philippe Chancelier Enpc/Cermics 
 *-------------------------------------------------------------------*/

#include "nsp/object.h"
#define  GtkWindowGroup_Private 
#include "nsp/gtk/gtkwindowgroup.h"
#include "nsp/interf.h"

/* NspGtkWindowGroup inherits from NspGObject */ 

int nsp_type_gtkwindowgroup_id=0;
NspTypeGtkWindowGroup *nsp_type_gtkwindowgroup=NULL;

NspTypeGtkWindowGroup *new_type_gtkwindowgroup(type_mode mode)
{
  NspTypeGtkWindowGroup *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkwindowgroup != 0 && mode == T_BASE ) 
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkwindowgroup;
    }
  if ((type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkwindowgroup_attrs ; 
  type->get_attrs = (attrs_func *)  int_get_attribute;
  type->set_attrs = (attrs_func *)  int_set_attribute;
  type->methods = gtkwindowgroup_get_methods; 
  type->new = (new_func *) new_gtkwindowgroup;

  /* specific methods for gtkwindowgroup */
      
  type->init = (init_func *) init_gtkwindowgroup;
  
  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);
  
  /* object methods redefined for gtkwindowgroup */ 

  top->s_type =  (s_type_func *) gtkwindowgroup_type_as_string;    
  top->sh_type = (sh_type_func *) gtkwindowgroup_type_short_string;
  /* top->create = (create_func*) int_gtkwindowgroup_create;*/ 
  
  /* specific methods for gtkwindowgroup */
      
  type->init = (init_func *) init_gtkwindowgroup;

  if ( nsp_type_gtkwindowgroup_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkWindowGroup called nsp_type_gtkwindowgroup
       */
      type->id =  nsp_type_gtkwindowgroup_id = nsp_new_type_id();
      nsp_type_gtkwindowgroup = type;
      if ( nsp_register_type(nsp_type_gtkwindowgroup) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkwindowgroup, GTK_TYPE_WINDOW_GROUP);
      return ( mode == T_BASE ) ? type : new_type_gtkwindowgroup(mode);
    }
  else 
    {
       type->id = nsp_type_gtkwindowgroup_id;
       return type;
    }
}

/*
 * initialize GtkWindowGroup instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkwindowgroup(NspGtkWindowGroup *o,NspTypeGtkWindowGroup *type)
{
  /* jump the first surtype */ 
  if ( type->surtype->init(&o->father,type->surtype) == FAIL) return FAIL;
  o->type = type; 
  NSP_OBJECT(o)->basetype = (NspTypeBase *)type;
  /* specific */
  return OK;
}

/*
 * new instance of GtkWindowGroup 
 */

NspGtkWindowGroup *new_gtkwindowgroup() 
{
  NspGtkWindowGroup *loc; 
  /* type must exists */
  nsp_type_gtkwindowgroup = new_type_gtkwindowgroup(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkWindowGroup)))== NULLGTKWINDOWGROUP) return loc;
  /* initialize object */
  if ( init_gtkwindowgroup(loc,nsp_type_gtkwindowgroup) == FAIL) return NULLGTKWINDOWGROUP;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for GtkWindowGroup 
 *-----------------------------------------------*/

/*
 * type as string 
 */

static char gtkwindowgroup_type_name[]="GtkWindowGroup";
static char gtkwindowgroup_short_type_name[]="GtkWindowGroup";

static char *gtkwindowgroup_type_as_string(void)
{
  return(gtkwindowgroup_type_name);
}

static char *gtkwindowgroup_type_short_string(void)
{
  return(gtkwindowgroup_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for GtkWindowGroup objects 
 * Note that some of these functions could become MACROS XXXXX 
 *-----------------------------------------------------*/

NspGtkWindowGroup   *gtkwindowgroup_object(NspObject *O)
{
  /** Follow pointer **/
  HOBJ_GET_OBJECT(O,NULL);
  /** Check type **/
  if ( check_cast (O,nsp_type_gtkwindowgroup_id) ) return ((NspGtkWindowGroup *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkwindowgroup));
  return NULL;
}

int IsGtkWindowGroupObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i) , nsp_type_gtkwindowgroup_id);
}

int IsGtkWindowGroup(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkwindowgroup_id);
}

NspGtkWindowGroup  *GetGtkWindowGroupCopy(Stack stack, int i)
{
  if (  GetGtkWindowGroup(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkWindowGroup  *GetGtkWindowGroup(Stack stack, int i)
{
  NspGtkWindowGroup *M;
  if (( M = gtkwindowgroup_object(NthObj(i))) == NULLGTKWINDOWGROUP)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkWindowGroup *gtkwindowgroup_copy(NspGtkWindowGroup *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwindowgroup);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwindowgroup);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkWindowGroup
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/

/* int int_clc_create(Stack stack, int rhs, int opt, int lhs)
{
  NspGtkWindowGroup *H;
  CheckRhs(0,0);
  / * want to be sure that type gtkwindowgroup is initialized * /
  nsp_type_gtkwindowgroup = new_type_gtkwindowgroup(T_BASE);
  if(( H = gobject_create(NVOID,(NspTypeBase *) nsp_type_gtkwindowgroup)) == NULLGTKWINDOWGROUP) return RET_BUG;
  MoveObj(stack,1,(NspObject  *) H);
  return 1;
} 
*/ 

static int
_wrap_gtkwindowgroup_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_window_group_new())== NULL) return RET_BUG;

  nsp_type_gtkwindowgroup = new_type_gtkwindowgroup(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkwindowgroup );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_group_add_window(NspGtkWindowGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *window;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &window) == FAIL) return RET_BUG;
  gtk_window_group_add_window(GTK_WINDOW_GROUP(self->obj), GTK_WINDOW(window->obj));
  return 0;
}

static int _wrap_gtk_window_group_remove_window(NspGtkWindowGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *window;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &window) == FAIL) return RET_BUG;
  gtk_window_group_remove_window(GTK_WINDOW_GROUP(self->obj), GTK_WINDOW(window->obj));
  return 0;
}

static NspMethods gtkwindowgroup_methods[] = {
  {"add_window",(nsp_method *) _wrap_gtk_window_group_add_window},
  {"remove_window",(nsp_method *) _wrap_gtk_window_group_remove_window},
  { NULL, NULL}
};

static NspMethods *gtkwindowgroup_get_methods(void) { return gtkwindowgroup_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkwindowgroup_attrs[]={{NULL,NULL,NULL}} ;

/*-------------------------------------------
 * functions 
 *-------------------------------------------*/
#line 3281 "gtk.override"

int _wrap_nsp_graphic_new(Stack stack, int rhs, int opt, int lhs)
{
  int win_id,open_gl=FALSE;
  int_types T[] = {obj_check, obj_check,new_opts,t_end};

  nsp_option opts[] ={{ "dim",mat_int,NULLOBJ,-1},
		      { "opengl", s_bool, NULLOBJ,-1},
		      { "popup_dim",mat_int,NULLOBJ,-1},
		      { "popup_pos",mat_int,NULLOBJ,-1},
		      { "viewport_pos",realmat,NULLOBJ,-1},
		      { "winnum",s_int,NULLOBJ,-1}, 
		      { NULL,t_end,NULLOBJ,-1}};
  int winnum = -1;
  NspMatrix *wdim = NULL, *wpdim = NULL,*viewport = NULL, *wpos = NULL;
  NspGObject *window, *vbox;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &window, &nsp_type_gtkwidget, &vbox,  
	       opts,  &wdim,&open_gl, &wpdim, &wpos, &viewport,&winnum) == FAIL) return RET_BUG;
  if (wdim != NULL) { CheckDims(stack.fname,3,wdim,1,2);}
  if (wpdim != NULL){ CheckDims(stack.fname,3,wpdim,1,2);}
  if (viewport != NULL) {CheckDims(stack.fname,3,viewport,1,2);}
  if (wpos != NULL) {CheckDims(stack.fname,3,wpos,1,2);}
#ifdef WITH_GTKGLEXT
  if ( open_gl == TRUE )
    win_id= nsp_graphic_new_gl(GTK_WIDGET(window->obj), GTK_WIDGET(vbox->obj), winnum,
			    (wdim) ? (int*) wdim->R: NULL ,
			    (wpdim) ? (int*)wpdim->R: NULL,
			    (viewport) ? viewport->R : NULL,
			    (wpos) ? (int*)wpos->R : NULL);
  else
#endif 
    win_id= nsp_graphic_new(GTK_WIDGET(window->obj), GTK_WIDGET(vbox->obj), winnum,
			    (wdim) ? (int*) wdim->R: NULL ,
			    (wpdim) ? (int*)wpdim->R: NULL,
			    (viewport) ? viewport->R : NULL,
			    (wpos) ? (int*)wpos->R : NULL);
  if ( nsp_move_doubles(stack,1,1,1,(double) win_id) == FAIL) return RET_BUG; 
  return 1;
}

#line 48127 "gtk.c"


int _wrap_gtk_accelerator_valid(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int, obj,t_end};
  int keyval, ret;
  NspObject *nsp_modifiers = NULL;
  GdkModifierType modifiers;

  if ( GetArgs(stack,rhs,opt,T,&keyval, &nsp_modifiers) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_modifiers, &modifiers)==FAIL)
      return RET_BUG;
    ret = gtk_accelerator_valid(keyval, modifiers);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_accelerator_name(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int, obj,t_end};
  int accelerator_key;
  gchar *ret;
  NspObject *nsp_accelerator_mods = NULL;
  GdkModifierType accelerator_mods;

  if ( GetArgs(stack,rhs,opt,T,&accelerator_key, &nsp_accelerator_mods) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accelerator_mods, &accelerator_mods)==FAIL)
      return RET_BUG;
    ret = gtk_accelerator_name(accelerator_key, accelerator_mods);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_accelerator_set_default_mod_mask(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_default_mod_mask = NULL;
  GdkModifierType default_mod_mask;

  if ( GetArgs(stack,rhs,opt,T,&nsp_default_mod_mask) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_default_mod_mask, &default_mod_mask)==FAIL)
      return RET_BUG;
    gtk_accelerator_set_default_mod_mask(default_mod_mask);
  return 0;
}

int _wrap_gtk_accelerator_get_default_mod_mask(Stack stack, int rhs, int opt, int lhs)
{
  int ret;

    ret = gtk_accelerator_get_default_mod_mask();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_accel_map_change_entry(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, s_int, obj, s_bool,t_end};
  char *accel_path;
  int accel_key, replace, ret;
  NspObject *nsp_accel_mods = NULL;
  GdkModifierType accel_mods;

  if ( GetArgs(stack,rhs,opt,T,&accel_path, &accel_key, &nsp_accel_mods, &replace) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accel_mods, &accel_mods)==FAIL)
      return RET_BUG;
    ret = gtk_accel_map_change_entry(accel_path, accel_key, accel_mods, replace);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_accel_map_load(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *file_name;

  if ( GetArgs(stack,rhs,opt,T,&file_name) == FAIL) return RET_BUG;
    gtk_accel_map_load(file_name);
  return 0;
}

int _wrap_gtk_accel_map_save(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *file_name;

  if ( GetArgs(stack,rhs,opt,T,&file_name) == FAIL) return RET_BUG;
    gtk_accel_map_save(file_name);
  return 0;
}

int _wrap_gtk_accel_map_load_fd(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int,t_end};
  int fd;

  if ( GetArgs(stack,rhs,opt,T,&fd) == FAIL) return RET_BUG;
    gtk_accel_map_load_fd(fd);
  return 0;
}

int _wrap_gtk_accel_map_save_fd(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int,t_end};
  int fd;

  if ( GetArgs(stack,rhs,opt,T,&fd) == FAIL) return RET_BUG;
    gtk_accel_map_save_fd(fd);
  return 0;
}

int _wrap_gtk_accel_map_add_filter(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *filter_pattern;

  if ( GetArgs(stack,rhs,opt,T,&filter_pattern) == FAIL) return RET_BUG;
    gtk_accel_map_add_filter(filter_pattern);
  return 0;
}

int _wrap_gtk_bindings_activate(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, s_int, obj,t_end};
  int keyval, ret;
  NspGObject *object;
  NspObject *nsp_modifiers = NULL;
  GdkModifierType modifiers;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkobject, &object, &keyval, &nsp_modifiers) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_modifiers, &modifiers)==FAIL)
      return RET_BUG;
    ret = gtk_bindings_activate(GTK_OBJECT(object->obj), keyval, modifiers);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 3324 "gtk.override"

static int
_wrap_gtk_binding_entry_add_signal(Stack stack,int rhs,int opt,int lhs)
{

  /*  
      FIXME: to be done 
  NspObject *first;
  gint len, i;
  NspObject *class;
  guint keyval, modifiers;
  gchar *signal_name;
  GType class_type;
  GtkBindingSet *bset = NULL;
  GSList *slist = NULL;
  gchar *errmsg;

  len = NspTuple_Size(args);
  if (len < 4) {
    Scierror( "binding_entry_add_signal requires at least 4 arguments");
    return RET_BUG;
  }
  first = NspSequence_GetSlice(args, 0, 4);
  if (!GetArgs(first, "Oiis:binding_entry_add_signal", &class,
			 &keyval, &modifiers, &signal_name)) {
    Nsp_DECREF(first);
    return RET_BUG;
  }
  Nsp_DECREF(first);

  class_type = nspg_type_from_object(class);
  if (class_type == 0)
    return RET_BUG;

  bset = gtk_binding_set_by_class(gtk_type_class(class_type));

  if ((len-4)%2) {
    Scierror("GtkBindingSet.add_signal requires an even number of parameter pairs following the first four args");
    return RET_BUG;
  }
  for (i=4; i < len; i+=2) {
    NspObject *item;
    GType arg_type;
    GtkBindingArg *arg = NULL;

    item = NspTuple_GET_ITEM(args, i);
    arg_type = nspg_type_from_object(item);
    if (!arg_type) {
      NspErr_Clear();
      Scierror("GtkBindingSet.add_signal parameter types must be int");
      goto arg_error;
    }
    arg = g_new0 (GtkBindingArg, 1);
    slist = g_slist_prepend(slist, arg);

    arg->arg_type = arg_type;
    switch (GTK_FUNDAMENTAL_TYPE(arg->arg_type)) {
    case GTK_TYPE_CHAR:
    case GTK_TYPE_UCHAR:
    case GTK_TYPE_INT:
    case GTK_TYPE_UINT:
    case GTK_TYPE_BOOL:
    case GTK_TYPE_ENUM:
    case GTK_TYPE_FLAGS:
    case GTK_TYPE_LONG:
    case GTK_TYPE_ULONG:
      arg->arg_type = GTK_TYPE_LONG;
      item = NspTuple_GET_ITEM(args, i+1);
      if (!NspInt_Check(item)) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal "
				 "arg[%u] must be int", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      arg->d.long_data = (glong)NspInt_AsLong(item);
      break;
    case GTK_TYPE_FLOAT:
    case GTK_TYPE_DOUBLE:
      arg->arg_type = GTK_TYPE_DOUBLE;
      item = NspTuple_GET_ITEM(args, i+1);
      if (!NspFloat_Check(item)) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal "
				 "arg[%u] must be float", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      arg->d.long_data = (gdouble)NspFloat_AsDouble(item);
      break;
    case GTK_TYPE_STRING:
      arg->arg_type = GTK_TYPE_STRING;
      if (arg->arg_type != GTK_TYPE_IDENTIFIER)
	arg->arg_type = GTK_TYPE_STRING;
      item = NspTuple_GET_ITEM(args, i+1);
      if (!NspString_Check(item)) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
				 "must be non-empty string", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      arg->d.string_data = (gchar*)NspString_AsString(item);
      if (!arg->d.string_data) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
				 "must be non-empty string", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      break;
    default:
      errmsg = g_strdup_printf("GtkBindingSet.add_signal unsupported "
			       "type %10s for arg[%u]",
			       gtk_type_name(arg->arg_type), i+1);
      Scierror( errmsg);
      g_free(errmsg);
      goto arg_error;
    } 
  }

  slist = g_slist_reverse (slist);
  gtk_binding_entry_add_signall (bset, keyval,modifiers, signal_name, slist);
  
  g_slist_foreach(slist, (GFunc)g_free, NULL);
  g_slist_free(slist);

  return 0;
  
 arg_error:
  if (slist) {
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
  }
  return RET_BUG;
  */
  return RET_BUG;
}

/* -------------- haven't updated stuff below this line -------------- */
#line 48407 "gtk.c"


int _wrap_gtk_color_selection_palette_to_string(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj, s_int,t_end};
  int n_colors;
  gchar *ret;
  NspObject *nsp_colors;
  GdkColor *colors = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_colors, &n_colors) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_colors, GDK_TYPE_COLOR))
      colors = nspg_boxed_get(nsp_colors, GdkColor);
  else {
      Scierror( "colors should be a GdkColor");
      return RET_BUG;
  }
    ret = gtk_color_selection_palette_to_string(colors, n_colors);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_drag_set_default_icon(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, obj_check, obj_check, s_int, s_int,t_end};
  int hot_x, hot_y;
  NspGObject *colormap, *pixmap, *mask;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkcolormap, &colormap, &nsp_type_gdkpixmap, &pixmap, &nsp_type_gdkbitmap, &mask, &hot_x, &hot_y) == FAIL) return RET_BUG;
  Scierror("%s: deprecated change the stock pixbuf for GTK_STOCK_DND",stack.fname); return RET_BUG;
    gtk_drag_set_default_icon(GDK_COLORMAP(colormap->obj), GDK_PIXMAP(pixmap->obj), GDK_DRAWABLE(mask->obj), hot_x, hot_y);
  return 0;
}

int _wrap_gtk_hbutton_box_get_spacing_default(Stack stack, int rhs, int opt, int lhs)
{
  int ret;

  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
    ret = gtk_hbutton_box_get_spacing_default();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_hbutton_box_get_layout_default(Stack stack, int rhs, int opt, int lhs)
{
  gint ret;

  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
    ret = gtk_hbutton_box_get_layout_default();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_hbutton_box_set_spacing_default(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int,t_end};
  int spacing;

  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
    gtk_hbutton_box_set_spacing_default(spacing);
  return 0;
}

int _wrap_gtk_hbutton_box_set_layout_default(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,t_end};
  GtkButtonBoxStyle layout;
  NspObject *nsp_layout = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_layout) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_BUTTON_BOX_STYLE, nsp_layout, &layout)== FAIL)
      return RET_BUG;
    gtk_hbutton_box_set_layout_default(layout);
  return 0;
}

int _wrap_gtk_icon_factory_lookup_default(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *stock_id;
  NspObject *nsp_ret;
  GtkIconSet *ret;

  if ( GetArgs(stack,rhs,opt,T,&stock_id) == FAIL) return RET_BUG;
    ret = gtk_icon_factory_lookup_default(stock_id);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_SET, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconset))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 6502 "gtk.override"
static int
_wrap_gtk_icon_size_lookup(Stack stack,int rhs,int opt,int lhs)
{
  int rep;
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "icon_size", NULL };*/
  NspObject *nsp_icon_size;
  GtkIconSize icon_size;
  gint width=-1, height=-1;

  if (GetArgs(stack,rhs,opt,T, &nsp_icon_size) == FAIL) return RET_BUG;;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_icon_size,  &icon_size)) return RET_BUG;
  rep=gtk_icon_size_lookup(icon_size, &width, &height);
  if ( nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL) return RET_BUG; 
  return 1; 
}
#line 48521 "gtk.c"


int _wrap_gtk_icon_size_register(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, s_int, s_int,t_end};
  char *name;
  int width, height;
  gint ret;

  if ( GetArgs(stack,rhs,opt,T,&name, &width, &height) == FAIL) return RET_BUG;
    ret = gtk_icon_size_register(name, width, height);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_icon_size_register_alias(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, obj,t_end};
  char *alias;
  GtkIconSize target;
  NspObject *nsp_target = NULL;

  if ( GetArgs(stack,rhs,opt,T,&alias, &nsp_target) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_target, &target)== FAIL)
      return RET_BUG;
    gtk_icon_size_register_alias(alias, target);
  return 0;
}

int _wrap_gtk_icon_size_from_name(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *name;
  gint ret;

  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    ret = gtk_icon_size_from_name(name);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_icon_size_get_name(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,t_end};
  const gchar *ret;
  GtkIconSize size;
  NspObject *nsp_size = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
    ret = gtk_icon_size_get_name(size);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_icon_set_new(Stack stack, int rhs, int opt, int lhs)
{
  NspObject *nsp_ret;
  GtkIconSet *ret;

    ret = gtk_icon_set_new();
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_SET, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconset))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_item_factory_add_foreign(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, string, obj_check, s_int, obj,t_end};
  char *full_path;
  NspGObject *accel_widget, *accel_group;
  int keyval;
  NspObject *nsp_modifiers = NULL;
  GdkModifierType modifiers;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &accel_widget, &full_path, &nsp_type_gtkaccelgroup, &accel_group, &keyval, &nsp_modifiers) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_modifiers, &modifiers)==FAIL)
      return RET_BUG;
    gtk_item_factory_add_foreign(GTK_WIDGET(accel_widget->obj), full_path, GTK_ACCEL_GROUP(accel_group->obj), keyval, modifiers);
  return 0;
}

int _wrap_gtk_item_factory_from_widget(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *widget;
  NspObject *nsp_ret;
  GtkItemFactory *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    ret = gtk_item_factory_from_widget(GTK_WIDGET(widget->obj));
  nsp_type_gtkitemfactory = new_type_gtkitemfactory(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkitemfactory))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_item_factory_path_from_widget(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *widget;
  const gchar *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    ret = gtk_item_factory_path_from_widget(GTK_WIDGET(widget->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_item_factory_from_path(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *path;
  NspObject *nsp_ret;
  GtkItemFactory *ret;

  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
    ret = gtk_item_factory_from_path(path);
  nsp_type_gtkitemfactory = new_type_gtkitemfactory(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkitemfactory))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_item_factories_path_delete(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, string,t_end};
  char *ifactory_path, *path;

  if ( GetArgs(stack,rhs,opt,T,&ifactory_path, &path) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
    gtk_item_factories_path_delete(ifactory_path, path);
  return 0;
}

int _wrap_gtk_check_version(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int, s_int, s_int,t_end};
  int required_major, required_minor, required_micro;
  const gchar *ret;

  if ( GetArgs(stack,rhs,opt,T,&required_major, &required_minor, &required_micro) == FAIL) return RET_BUG;
    ret = gtk_check_version(required_major, required_minor, required_micro);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_disable_setlocale(Stack stack, int rhs, int opt, int lhs)
{
    gtk_disable_setlocale();
  return 0;
}

int _wrap_gtk_get_default_language(Stack stack, int rhs, int opt, int lhs)
{
  NspObject *nsp_ret;
  PangoLanguage *ret;

    ret = gtk_get_default_language();
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,PANGO_TYPE_LANGUAGE, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_pangolanguage))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_events_pending(Stack stack, int rhs, int opt, int lhs)
{
  int ret;

    ret = gtk_events_pending();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_main_do_event(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event;

  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "event should be a GdkEvent");
      return RET_BUG;
  }
    gtk_main_do_event(event);
  return 0;
}

#line 3611 "gtk.override"
static int
_wrap_gtk_main(Stack stack,int rhs,int opt,int lhs)
{
  nspg_unblock_threads();
  gtk_main();
  nspg_block_threads();
  return 0;
}
#line 48727 "gtk.c"


int _wrap_gtk_main_level(Stack stack, int rhs, int opt, int lhs)
{
  int ret;

    ret = gtk_main_level();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_main_quit(Stack stack, int rhs, int opt, int lhs)
{
    gtk_main_quit();
  return 0;
}

#line 3621 "gtk.override"
static int
_wrap_gtk_main_iteration(Stack stack,int rhs,int opt,int lhs)
{
  int block = 1, ret;
  CheckRhs(0,1) ; 
  if ( rhs == 1 ) { if (GetScalarInt(stack,1,&block) == FAIL) return RET_BUG; }
  nspg_unblock_threads();
  ret = gtk_main_iteration_do(block);
  nspg_block_threads();
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG; 
  return 1;
}
#line 48758 "gtk.c"


#line 3635 "gtk.override"
static int
_wrap_gtk_main_iteration_do(Stack stack,int rhs,int opt,int lhs)
{
  int block = 1, ret;
  CheckRhs(0,1) ; 
  if ( rhs == 1 ) { if (GetScalarInt(stack,1,&block) == FAIL) return RET_BUG; }
  nspg_unblock_threads();
  ret = gtk_main_iteration_do(block);
  nspg_block_threads();
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG; 
  return 1;
}
#line 48774 "gtk.c"


int _wrap_gtk_grab_get_current(Stack stack, int rhs, int opt, int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;

    ret = gtk_grab_get_current();
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_quit_remove(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int,t_end};
  int quit_handler_id;

  if ( GetArgs(stack,rhs,opt,T,&quit_handler_id) == FAIL) return RET_BUG;
    gtk_quit_remove(quit_handler_id);
  return 0;
}

int _wrap_gtk_timeout_remove(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int,t_end};
  int timeout_handler_id;

  if ( GetArgs(stack,rhs,opt,T,&timeout_handler_id) == FAIL) return RET_BUG;
    gtk_timeout_remove(timeout_handler_id);
  return 0;
}

int _wrap_gtk_idle_remove(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int,t_end};
  int idle_handler_id;

  if ( GetArgs(stack,rhs,opt,T,&idle_handler_id) == FAIL) return RET_BUG;
    gtk_idle_remove(idle_handler_id);
  return 0;
}

int _wrap_gtk_get_current_event_time(Stack stack, int rhs, int opt, int lhs)
{
  gulong ret;

    ret = gtk_get_current_event_time();
 if (  nsp_move_double(stack,1,(double) ret) == FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_preview_set_gamma(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_double,t_end};
  double gamma;

  if ( GetArgs(stack,rhs,opt,T,&gamma) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkPixbuf",stack.fname); return RET_BUG;
    gtk_preview_set_gamma(gamma);
  return 0;
}

int _wrap_gtk_preview_set_color_cube(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int, s_int, s_int, s_int,t_end};
  int nred_shades, ngreen_shades, nblue_shades, ngray_shades;

  if ( GetArgs(stack,rhs,opt,T,&nred_shades, &ngreen_shades, &nblue_shades, &ngray_shades) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkPixbuf",stack.fname); return RET_BUG;
    gtk_preview_set_color_cube(nred_shades, ngreen_shades, nblue_shades, ngray_shades);
  return 0;
}

int _wrap_gtk_preview_set_install_cmap(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int,t_end};
  int install_cmap;

  if ( GetArgs(stack,rhs,opt,T,&install_cmap) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkPixbuf",stack.fname); return RET_BUG;
    gtk_preview_set_install_cmap(install_cmap);
  return 0;
}

int _wrap_gtk_preview_set_reserved(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int,t_end};
  int nreserved;

  if ( GetArgs(stack,rhs,opt,T,&nreserved) == FAIL) return RET_BUG;
  Scierror("%s: deprecated use GtkPixbuf",stack.fname); return RET_BUG;
    gtk_preview_set_reserved(nreserved);
  return 0;
}

int _wrap_gtk_preview_get_visual(Stack stack, int rhs, int opt, int lhs)
{
  NspObject *nsp_ret;
  GdkVisual *ret;

  Scierror("%s: deprecated use GtkPixbuf",stack.fname); return RET_BUG;
    ret = gtk_preview_get_visual();
  nsp_type_gdkvisual = new_type_gdkvisual(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkvisual))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_preview_get_cmap(Stack stack, int rhs, int opt, int lhs)
{
  NspObject *nsp_ret;
  GdkColormap *ret;

  Scierror("%s: deprecated use GtkPixbuf",stack.fname); return RET_BUG;
    ret = gtk_preview_get_cmap();
  nsp_type_gdkcolormap = new_type_gdkcolormap(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkcolormap))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_preview_reset(Stack stack, int rhs, int opt, int lhs)
{
  Scierror("%s: deprecated use GtkPixbuf",stack.fname); return RET_BUG;
    gtk_preview_reset();
  return 0;
}

int _wrap_gtk_rc_add_default_file(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *filename;

  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    gtk_rc_add_default_file(filename);
  return 0;
}

#line 5961 "gtk.override"
static int
_wrap_gtk_rc_set_default_files(Stack stack,int rhs,int opt,int lhs)
{
  NspSMatrix *nsp_filenames = NULL;
  CheckRhs(0,1);
  if ( rhs == 1) 
    {
      if (( nsp_filenames = GetSMat(stack,1))==NULL) return RET_BUG;
      gtk_rc_set_default_files(nsp_filenames->S);
    }
  return 0;
}
#line 48928 "gtk.c"


#line 5975 "gtk.override"
static int
_wrap_gtk_rc_get_default_files(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  char **filenames = gtk_rc_get_default_files();
  if (( ret = (NspObject *)nsp_smatrix_create_from_table(filenames))== NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 48941 "gtk.c"


int _wrap_gtk_rc_get_style_by_paths(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, string, string, obj,t_end};
  char *widget_path, *class_path;
  NspGObject *settings;
  GType type;
  NspObject *nsp_type = NULL, *nsp_ret;
  GtkStyle *ret;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtksettings, &settings, &widget_path, &class_path, &nsp_type) == FAIL) return RET_BUG;
  if ((type = nspg_type_from_object(nsp_type)) == FAIL)
      return RET_BUG;
    ret = gtk_rc_get_style_by_paths(GTK_SETTINGS(settings->obj), widget_path, class_path, type);
  nsp_type_gtkstyle = new_type_gtkstyle(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstyle))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_rc_reparse_all_for_settings(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, s_bool,t_end};
  int force_load, ret;
  NspGObject *settings;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtksettings, &settings, &force_load) == FAIL) return RET_BUG;
    ret = gtk_rc_reparse_all_for_settings(GTK_SETTINGS(settings->obj), force_load);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_rc_parse(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *filename;

  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    gtk_rc_parse(filename);
  return 0;
}

int _wrap_gtk_rc_parse_string(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *rc_string;

  if ( GetArgs(stack,rhs,opt,T,&rc_string) == FAIL) return RET_BUG;
    gtk_rc_parse_string(rc_string);
  return 0;
}

int _wrap_gtk_rc_reparse_all(Stack stack, int rhs, int opt, int lhs)
{
  int ret;

    ret = gtk_rc_reparse_all();
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_rc_find_module_in_path(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *module_file;
  gchar *ret;

  if ( GetArgs(stack,rhs,opt,T,&module_file) == FAIL) return RET_BUG;
    ret = gtk_rc_find_module_in_path(module_file);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_rc_get_theme_dir(Stack stack, int rhs, int opt, int lhs)
{
  gchar *ret;

    ret = gtk_rc_get_theme_dir();
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_rc_get_module_dir(Stack stack, int rhs, int opt, int lhs)
{
  gchar *ret;

    ret = gtk_rc_get_module_dir();
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_rc_get_im_module_path(Stack stack, int rhs, int opt, int lhs)
{
  gchar *ret;

    ret = gtk_rc_get_im_module_path();
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_rc_get_im_module_file(Stack stack, int rhs, int opt, int lhs)
{
  gchar *ret;

    ret = gtk_rc_get_im_module_file();
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_settings_get_default(Stack stack, int rhs, int opt, int lhs)
{
  NspObject *nsp_ret;
  GtkSettings *ret;

    ret = gtk_settings_get_default();
  nsp_type_gtksettings = new_type_gtksettings(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtksettings))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 6090 "gtk.override"
static int
_wrap_gtk_stock_add(Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list, t_end} ;
  NspList *nsp_items;
  Cell * cloc;
  GtkStockItem *items = NULL;
  int i, len;

  if (GetArgs(stack,rhs,opt,T,&nsp_items)   == FAIL) return RET_BUG;;

  len =nsp_list_length(nsp_items);
  if (len == 0) return 0;
  items = g_new(GtkStockItem, len);
  cloc = nsp_items->first; 
  i=1;
  while ( cloc != NULLCELL) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  NspList *item = (NspList *) cloc->O;
	  int_types kT[]={ string,string,s_int,s_int,string,list_end};
	  if ( !IsList(cloc->O) ) 
	    {
	      Scierror("%s: list element %d has wrong type\n",stack.fname,i);
	      goto error;
	    }
	  if ( GetListArgs(item,1,kT,&items[i].stock_id, &items[i].label,
			   &items[i].modifier, &items[i].keyval,
			   &items[i].translation_domain) == FAIL ) 
	    {
	      Scierror("%s: list element %d is incorrect (stock_id, label, modifiers,keyval,domain) expected\n",stack.fname,i);
	      goto error;
	    }
	}
      cloc = cloc->next;
      i++;
    }
  gtk_stock_add(items, len);
  g_free(items);
  return 0;
 error:
  g_free(items);
  return RET_BUG;
}
#line 49115 "gtk.c"


#line 6152 "gtk.override"
static int
_wrap_gtk_stock_lookup(Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end} ;
  int_types ret_T1[] = {s_bool,list_begin,string,string,s_int,s_int,string,list_end, t_end} ;
  int_types ret_T2[] = {s_bool,list_begin,list_end, t_end} ;
  gchar *stock_id;
  GtkStockItem item;
  if (GetArgs(stack,rhs,opt,T, &stock_id) == FAIL) return RET_BUG;;

  if(gtk_stock_lookup(stock_id, &item)) {
    return RetArgs(stack,lhs,ret_T1, TRUE, item.stock_id, item.label, item.modifier, item.keyval, item.translation_domain);
  }
  else 
    return RetArgs(stack,lhs,ret_T2, FALSE);
}
#line 49135 "gtk.c"


#line 6137 "gtk.override"
static int
_wrap_gtk_stock_list_ids(Stack stack,int rhs,int opt,int lhs)
{
  GSList *list, *tmp;
  NspList *nsp_list; 
  Cell *cloc = NULLCELL,*cloc1=NULLCELL;  
  list = gtk_stock_list_ids();
  NSP_LIST_FROM_GLIST(nsp_new_string_obj("lel",tmp->data,-1),g_slist_free);
  /* XXX
   * g_slist_foreach (list, (GFunc)g_free, NULL);
   * g_slist_free (list);  
   */
}
#line 49152 "gtk.c"


int _wrap_gtk_tree_row_reference_inserted(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, obj,t_end};
  NspGObject *proxy;
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gobject, &proxy, &nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
    gtk_tree_row_reference_inserted(G_OBJECT(proxy->obj), path);
  return 0;
}

int _wrap_gtk_tree_row_reference_deleted(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, obj,t_end};
  NspGObject *proxy;
  NspObject *nsp_path;
  GtkTreePath *path = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gobject, &proxy, &nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
    gtk_tree_row_reference_deleted(G_OBJECT(proxy->obj), path);
  return 0;
}

int _wrap_gtk_tree_row_reference_reordered(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, obj, obj, s_int,t_end};
  int new_order;
  NspGObject *proxy;
  NspObject *nsp_path, *nsp_iter;
  GtkTreePath *path = NULL;
  GtkTreeIter *iter = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gobject, &proxy, &nsp_path, &nsp_iter, &new_order) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "path should be a GtkTreePath");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "iter should be a GtkTreeIter");
      return RET_BUG;
  }
    gtk_tree_row_reference_reordered(G_OBJECT(proxy->obj), path, iter, &new_order);
  return 0;
}

int _wrap_gtk_vbutton_box_get_spacing_default(Stack stack, int rhs, int opt, int lhs)
{
  int ret;

  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
    ret = gtk_vbutton_box_get_spacing_default();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_vbutton_box_set_spacing_default(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int,t_end};
  int spacing;

  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
    gtk_vbutton_box_set_spacing_default(spacing);
  return 0;
}

int _wrap_gtk_vbutton_box_get_layout_default(Stack stack, int rhs, int opt, int lhs)
{
  gint ret;

  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
    ret = gtk_vbutton_box_get_layout_default();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_vbutton_box_set_layout_default(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,t_end};
  GtkButtonBoxStyle layout;
  NspObject *nsp_layout = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_layout) == FAIL) return RET_BUG;
  Scierror("%s: deprecated ",stack.fname); return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_BUTTON_BOX_STYLE, nsp_layout, &layout)== FAIL)
      return RET_BUG;
    gtk_vbutton_box_set_layout_default(layout);
  return 0;
}

int _wrap_gtk_widget_push_colormap(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *cmap;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkcolormap, &cmap) == FAIL) return RET_BUG;
    gtk_widget_push_colormap(GDK_COLORMAP(cmap->obj));
  return 0;
}

int _wrap_gtk_widget_push_composite_child(Stack stack, int rhs, int opt, int lhs)
{
    gtk_widget_push_composite_child();
  return 0;
}

int _wrap_gtk_widget_pop_composite_child(Stack stack, int rhs, int opt, int lhs)
{
    gtk_widget_pop_composite_child();
  return 0;
}

int _wrap_gtk_widget_pop_colormap(Stack stack, int rhs, int opt, int lhs)
{
    gtk_widget_pop_colormap();
  return 0;
}

int _wrap_gtk_widget_get_default_style(Stack stack, int rhs, int opt, int lhs)
{
  NspObject *nsp_ret;
  GtkStyle *ret;

    ret = gtk_widget_get_default_style();
  nsp_type_gtkstyle = new_type_gtkstyle(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstyle))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_widget_set_default_colormap(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,t_end};
  NspGObject *colormap;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkcolormap, &colormap) == FAIL) return RET_BUG;
    gtk_widget_set_default_colormap(GDK_COLORMAP(colormap->obj));
  return 0;
}

int _wrap_gtk_widget_get_default_colormap(Stack stack, int rhs, int opt, int lhs)
{
  NspObject *nsp_ret;
  GdkColormap *ret;

    ret = gtk_widget_get_default_colormap();
  nsp_type_gdkcolormap = new_type_gdkcolormap(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkcolormap))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_widget_get_default_visual(Stack stack, int rhs, int opt, int lhs)
{
  NspObject *nsp_ret;
  GdkVisual *ret;

    ret = gtk_widget_get_default_visual();
  nsp_type_gdkvisual = new_type_gdkvisual(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkvisual))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_widget_set_default_direction(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,t_end};
  GtkTextDirection dir;
  NspObject *nsp_dir = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_dir) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, nsp_dir, &dir)== FAIL)
      return RET_BUG;
    gtk_widget_set_default_direction(dir);
  return 0;
}

int _wrap_gtk_widget_get_default_direction(Stack stack, int rhs, int opt, int lhs)
{
  gint ret;

    ret = gtk_widget_get_default_direction();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_window_set_default_icon_from_file(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,t_end};
  char *filename;
  int ret;
  GError *err = NULL;

  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    ret = gtk_window_set_default_icon_from_file(filename, &err);
  if ( err != NULL ) {
    Scierror("%s: gtk error\n",stack.fname);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_window_set_auto_startup_notification(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_bool,t_end};
  int setting;

  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_auto_startup_notification(setting);
  return 0;
}

#line 1348 "gtk.override"
static int
_wrap_gtk_window_list_toplevels(Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  Cell *cloc = NULLCELL,*cloc1=NULLCELL; 
  CheckRhs(0,0);
  list = gtk_window_list_toplevels();
  NSP_LIST_FROM_GLIST( gobject_gettype_and_create("lel",G_OBJECT(tmp->data)),g_list_free);
}
#line 49396 "gtk.c"


/*----------------------------------------------------
 * Interface 
 * i.e a set of function which are accessible at nsp level
 *----------------------------------------------------*/

static OpTab gtk_func[]={
  {"gtktreepath_new", _wrap_gtktreepath_new},
  {"gtkiconset_new", _wrap_gtkiconset_new},
  {"gtkiconsource_new", _wrap_gtkiconsource_new},
  {"gtktextattributes_new", _wrap_gtktextattributes_new},
  {"gtkaccelgroup_new", _wrap_gtkaccelgroup_new},
  {"gtkiconfactory_new", _wrap_gtkiconfactory_new},
  {"gtkitemfactory_new", _wrap_gtkitemfactory_new},
  {"gtkimcontextsimple_new", _wrap_gtkimcontextsimple_new},
  {"gtkimmulticontext_new", _wrap_gtkimmulticontext_new},
  {"gtkcellrenderertoggle_new", _wrap_gtkcellrenderertoggle_new},
  {"gtkcellrenderertext_new", _wrap_gtkcellrenderertext_new},
  {"gtkcellrendererpixbuf_new", _wrap_gtkcellrendererpixbuf_new},
  {"gtkadjustment_new", _wrap_gtkadjustment_new},
  {"gtksizegroup_new", _wrap_gtksizegroup_new},
  {"gtkstyle_new", _wrap_gtkstyle_new},
  {"gtktextbuffer_new", _wrap_gtktextbuffer_new},
  {"gtktextchildanchor_new", _wrap_gtktextchildanchor_new},
  {"gtktexttag_new", _wrap_gtktexttag_new},
  {"gtktexttagtable_new", _wrap_gtktexttagtable_new},
  {"gtktooltips_new", _wrap_gtktooltips_new},
  {"gtkliststore_new", _wrap_gtkliststore_new},
  {"gtktreemodelsort_new", _wrap_gtktreemodelsort_new},
  {"gtktreestore_new", _wrap_gtktreestore_new},
  {"gtktreeviewcolumn_new", _wrap_gtktreeviewcolumn_new},
  {"gtkwidget_new", _wrap_gtkwidget_new},
  {"gtkvseparator_new", _wrap_gtkvseparator_new},
  {"gtkhseparator_new", _wrap_gtkhseparator_new},
  {"gtkvruler_new", _wrap_gtkvruler_new},
  {"gtkhruler_new", _wrap_gtkhruler_new},
  {"gtkvscrollbar_new", _wrap_gtkvscrollbar_new},
  {"gtkhscrollbar_new", _wrap_gtkhscrollbar_new},
  {"gtkvscale_new", _wrap_gtkvscale_new},
  {"gtkhscale_new", _wrap_gtkhscale_new},
  {"gtkprogressbar_new", _wrap_gtkprogressbar_new},
  {"gtkpreview_new", _wrap_gtkpreview_new},
  {"gtkarrow_new", _wrap_gtkarrow_new},
  {"gtkimage_new", _wrap_gtkimage_new},
  {"gtklabel_new", _wrap_gtklabel_new},
  {"gtkaccellabel_new", _wrap_gtkaccellabel_new},
  {"gtkinvisible_new", _wrap_gtkinvisible_new},
  {"gtkentry_new", _wrap_gtkentry_new},
  {"gtkspinbutton_new", _wrap_gtkspinbutton_new},
  {"gtkdrawingarea_new", _wrap_gtkdrawingarea_new},
  {"gtkcurve_new", _wrap_gtkcurve_new},
  {"gtktreeview_new", _wrap_gtktreeview_new},
  {"gtktoolbar_new", _wrap_gtktoolbar_new},
  {"gtktextview_new", _wrap_gtktextview_new},
  {"gtktable_new", _wrap_gtktable_new},
  {"gtksocket_new", _wrap_gtksocket_new},
  {"gtkvpaned_new", _wrap_gtkvpaned_new},
  {"gtkhpaned_new", _wrap_gtkhpaned_new},
  {"gtknotebook_new", _wrap_gtknotebook_new},
  {"gtkmenu_new", _wrap_gtkmenu_new},
  {"gtkmenubar_new", _wrap_gtkmenubar_new},
  {"gtklayout_new", _wrap_gtklayout_new},
  {"gtkfixed_new", _wrap_gtkfixed_new},
  {"gtkviewport_new", _wrap_gtkviewport_new},
  {"gtkscrolledwindow_new", _wrap_gtkscrolledwindow_new},
  {"gtkmenuitem_new", _wrap_gtkmenuitem_new},
  {"gtktearoffmenuitem_new", _wrap_gtktearoffmenuitem_new},
  {"gtkseparatormenuitem_new", _wrap_gtkseparatormenuitem_new},
  {"gtkcheckmenuitem_new", _wrap_gtkcheckmenuitem_new},
  {"gtkradiomenuitem_new", _wrap_gtkradiomenuitem_new},
  {"gtkimagemenuitem_new", _wrap_gtkimagemenuitem_new},
  {"gtkhandlebox_new", _wrap_gtkhandlebox_new},
  {"gtkframe_new", _wrap_gtkframe_new},
  {"gtkaspectframe_new", _wrap_gtkaspectframe_new},
  {"gtkeventbox_new", _wrap_gtkeventbox_new},
  {"gtkalignment_new", _wrap_gtkalignment_new},
  {"gtkbutton_new", _wrap_gtkbutton_new},
  {"gtktogglebutton_new", _wrap_gtktogglebutton_new},
  {"gtkcheckbutton_new", _wrap_gtkcheckbutton_new},
  {"gtkradiobutton_new", _wrap_gtkradiobutton_new},
  {"gtkoptionmenu_new", _wrap_gtkoptionmenu_new},
  {"gtkvbox_new", _wrap_gtkvbox_new},
  {"gtkcolorselection_new", _wrap_gtkcolorselection_new},
  {"gtkfontselection_new", _wrap_gtkfontselection_new},
  {"gtkgammacurve_new", _wrap_gtkgammacurve_new},
  {"gtkhbox_new", _wrap_gtkhbox_new},
  {"gtkstatusbar_new", _wrap_gtkstatusbar_new},
  {"gtkcombo_new", _wrap_gtkcombo_new},
  {"gtkvbuttonbox_new", _wrap_gtkvbuttonbox_new},
  {"gtkhbuttonbox_new", _wrap_gtkhbuttonbox_new},
  {"gtkcalendar_new", _wrap_gtkcalendar_new},
  {"gtkwindow_new", _wrap_gtkwindow_new},
  {"gtkplug_new", _wrap_gtkplug_new},
  {"gtkdialog_new", _wrap_gtkdialog_new},
  {"gtkmessagedialog_new", _wrap_gtkmessagedialog_new},
  {"gtkinputdialog_new", _wrap_gtkinputdialog_new},
  {"gtkfontselectiondialog_new", _wrap_gtkfontselectiondialog_new},
  {"gtkfileselection_new", _wrap_gtkfileselection_new},
  {"gtkcolorselectiondialog_new", _wrap_gtkcolorselectiondialog_new},
  {"gtkwindowgroup_new", _wrap_gtkwindowgroup_new},
  {"nsp_graphic_new", _wrap_nsp_graphic_new},
  {"gtk_accelerator_valid", _wrap_gtk_accelerator_valid},
  {"gtk_accelerator_name", _wrap_gtk_accelerator_name},
  {"gtk_accelerator_set_default_mod_mask", _wrap_gtk_accelerator_set_default_mod_mask},
  {"gtk_accelerator_get_default_mod_mask", _wrap_gtk_accelerator_get_default_mod_mask},
  {"gtk_accel_map_change_entry", _wrap_gtk_accel_map_change_entry},
  {"gtk_accel_map_load", _wrap_gtk_accel_map_load},
  {"gtk_accel_map_save", _wrap_gtk_accel_map_save},
  {"gtk_accel_map_load_fd", _wrap_gtk_accel_map_load_fd},
  {"gtk_accel_map_save_fd", _wrap_gtk_accel_map_save_fd},
  {"gtk_accel_map_add_filter", _wrap_gtk_accel_map_add_filter},
  {"gtk_bindings_activate", _wrap_gtk_bindings_activate},
  {"gtk_binding_entry_add_signal", _wrap_gtk_binding_entry_add_signal},
  {"gtk_color_selection_palette_to_string", _wrap_gtk_color_selection_palette_to_string},
  {"gtk_drag_set_default_icon", _wrap_gtk_drag_set_default_icon},
  {"gtk_hbutton_box_get_spacing_default", _wrap_gtk_hbutton_box_get_spacing_default},
  {"gtk_hbutton_box_get_layout_default", _wrap_gtk_hbutton_box_get_layout_default},
  {"gtk_hbutton_box_set_spacing_default", _wrap_gtk_hbutton_box_set_spacing_default},
  {"gtk_hbutton_box_set_layout_default", _wrap_gtk_hbutton_box_set_layout_default},
  {"gtk_icon_factory_lookup_default", _wrap_gtk_icon_factory_lookup_default},
  {"gtk_icon_size_lookup", _wrap_gtk_icon_size_lookup},
  {"gtk_icon_size_register", _wrap_gtk_icon_size_register},
  {"gtk_icon_size_register_alias", _wrap_gtk_icon_size_register_alias},
  {"gtk_icon_size_from_name", _wrap_gtk_icon_size_from_name},
  {"gtk_icon_size_get_name", _wrap_gtk_icon_size_get_name},
  {"gtk_icon_set_new", _wrap_gtk_icon_set_new},
  {"gtk_item_factory_add_foreign", _wrap_gtk_item_factory_add_foreign},
  {"gtk_item_factory_from_widget", _wrap_gtk_item_factory_from_widget},
  {"gtk_item_factory_path_from_widget", _wrap_gtk_item_factory_path_from_widget},
  {"gtk_item_factory_from_path", _wrap_gtk_item_factory_from_path},
  {"gtk_item_factories_path_delete", _wrap_gtk_item_factories_path_delete},
  {"gtk_check_version", _wrap_gtk_check_version},
  {"gtk_disable_setlocale", _wrap_gtk_disable_setlocale},
  {"gtk_get_default_language", _wrap_gtk_get_default_language},
  {"gtk_events_pending", _wrap_gtk_events_pending},
  {"gtk_main_do_event", _wrap_gtk_main_do_event},
  {"gtk_main", _wrap_gtk_main},
  {"gtk_main_level", _wrap_gtk_main_level},
  {"gtk_main_quit", _wrap_gtk_main_quit},
  {"gtk_main_iteration", _wrap_gtk_main_iteration},
  {"gtk_main_iteration_do", _wrap_gtk_main_iteration_do},
  {"gtk_grab_get_current", _wrap_gtk_grab_get_current},
  {"gtk_quit_remove", _wrap_gtk_quit_remove},
  {"gtk_timeout_remove", _wrap_gtk_timeout_remove},
  {"gtk_idle_remove", _wrap_gtk_idle_remove},
  {"gtk_get_current_event_time", _wrap_gtk_get_current_event_time},
  {"gtk_preview_set_gamma", _wrap_gtk_preview_set_gamma},
  {"gtk_preview_set_color_cube", _wrap_gtk_preview_set_color_cube},
  {"gtk_preview_set_install_cmap", _wrap_gtk_preview_set_install_cmap},
  {"gtk_preview_set_reserved", _wrap_gtk_preview_set_reserved},
  {"gtk_preview_get_visual", _wrap_gtk_preview_get_visual},
  {"gtk_preview_get_cmap", _wrap_gtk_preview_get_cmap},
  {"gtk_preview_reset", _wrap_gtk_preview_reset},
  {"gtk_rc_add_default_file", _wrap_gtk_rc_add_default_file},
  {"gtk_rc_set_default_files", _wrap_gtk_rc_set_default_files},
  {"gtk_rc_get_default_files", _wrap_gtk_rc_get_default_files},
  {"gtk_rc_get_style_by_paths", _wrap_gtk_rc_get_style_by_paths},
  {"gtk_rc_reparse_all_for_settings", _wrap_gtk_rc_reparse_all_for_settings},
  {"gtk_rc_parse", _wrap_gtk_rc_parse},
  {"gtk_rc_parse_string", _wrap_gtk_rc_parse_string},
  {"gtk_rc_reparse_all", _wrap_gtk_rc_reparse_all},
  {"gtk_rc_find_module_in_path", _wrap_gtk_rc_find_module_in_path},
  {"gtk_rc_get_theme_dir", _wrap_gtk_rc_get_theme_dir},
  {"gtk_rc_get_module_dir", _wrap_gtk_rc_get_module_dir},
  {"gtk_rc_get_im_module_path", _wrap_gtk_rc_get_im_module_path},
  {"gtk_rc_get_im_module_file", _wrap_gtk_rc_get_im_module_file},
  {"gtk_settings_get_default", _wrap_gtk_settings_get_default},
  {"gtk_stock_add", _wrap_gtk_stock_add},
  {"gtk_stock_lookup", _wrap_gtk_stock_lookup},
  {"gtk_stock_list_ids", _wrap_gtk_stock_list_ids},
  {"gtk_tree_row_reference_inserted", _wrap_gtk_tree_row_reference_inserted},
  {"gtk_tree_row_reference_deleted", _wrap_gtk_tree_row_reference_deleted},
  {"gtk_tree_row_reference_reordered", _wrap_gtk_tree_row_reference_reordered},
  {"gtk_vbutton_box_get_spacing_default", _wrap_gtk_vbutton_box_get_spacing_default},
  {"gtk_vbutton_box_set_spacing_default", _wrap_gtk_vbutton_box_set_spacing_default},
  {"gtk_vbutton_box_get_layout_default", _wrap_gtk_vbutton_box_get_layout_default},
  {"gtk_vbutton_box_set_layout_default", _wrap_gtk_vbutton_box_set_layout_default},
  {"gtk_widget_push_colormap", _wrap_gtk_widget_push_colormap},
  {"gtk_widget_push_composite_child", _wrap_gtk_widget_push_composite_child},
  {"gtk_widget_pop_composite_child", _wrap_gtk_widget_pop_composite_child},
  {"gtk_widget_pop_colormap", _wrap_gtk_widget_pop_colormap},
  {"gtk_widget_get_default_style", _wrap_gtk_widget_get_default_style},
  {"gtk_widget_set_default_colormap", _wrap_gtk_widget_set_default_colormap},
  {"gtk_widget_get_default_colormap", _wrap_gtk_widget_get_default_colormap},
  {"gtk_widget_get_default_visual", _wrap_gtk_widget_get_default_visual},
  {"gtk_widget_set_default_direction", _wrap_gtk_widget_set_default_direction},
  {"gtk_widget_get_default_direction", _wrap_gtk_widget_get_default_direction},
  {"gtk_window_set_default_icon_from_file", _wrap_gtk_window_set_default_icon_from_file},
  {"gtk_window_set_auto_startup_notification", _wrap_gtk_window_set_auto_startup_notification},
  {"gtk_window_list_toplevels", _wrap_gtk_window_list_toplevels},
  { NULL, NULL}
};

/** call ith function in the gtk interface **/

int gtk_Interf(int i, Stack stack, int rhs, int opt, int lhs)
{
  return (*(gtk_func[i].fonc))(stack,rhs,opt,lhs);
}

/** used to walk through the interface table 
    (for adding or removing functions) **/

void gtk_Interf_Info(int i, char **fname, function (**f))
{
  *fname = gtk_func[i].name;
  *f = gtk_func[i].fonc;
}

/* ----------- enums and flags ----------- */

void
gtk_add_constants(NspObject *module, const gchar *strip_prefix)
{
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_ACCEL_FLAGS, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_CALENDAR_DISPLAY_OPTIONS, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_CELL_RENDERER_STATE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_CELL_RENDERER_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_CELL_TYPE, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_BUTTON_ACTION, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_DEBUG_FLAG, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_DIALOG_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_RESPONSE_TYPE, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_DEST_DEFAULTS, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_TARGET_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_ANCHOR_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_ARROW_TYPE, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_ATTACH_OPTIONS, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_BUTTON_BOX_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_CURVE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_DELETE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_DIRECTION_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_EXPANDER_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_ICON_SIZE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_SIDE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_TEXT_DIRECTION, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_JUSTIFICATION, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_MATCH_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_MENU_DIRECTION_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_METRIC_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_MOVEMENT_STEP, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_ORIENTATION, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_CORNER_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_PACK_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_PATH_PRIORITY_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_PATH_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_POLICY_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_POSITION_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_PREVIEW_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_RELIEF_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_RESIZE_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_SCROLL_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_SELECTION_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_SHADOW_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_STATE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_SUBMENU_DIRECTION, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_SUBMENU_PLACEMENT, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_TOOLBAR_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_UPDATE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_VISIBILITY, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_WINDOW_POSITION, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_WINDOW_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_WRAP_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_SORT_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_IMAGE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_MESSAGE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_BUTTONS_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_NOTEBOOK_TAB, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_OBJECT_FLAGS, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_ARG_FLAGS, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_PRIVATE_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_PROGRESS_BAR_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_PROGRESS_BAR_ORIENTATION, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_RC_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_RC_TOKEN_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_SIZE_GROUP_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_SPIN_BUTTON_UPDATE_POLICY, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_SPIN_TYPE, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_TEXT_SEARCH_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_TEXT_WINDOW_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_TOOLBAR_CHILD_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_TOOLBAR_SPACE_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_TREE_VIEW_MODE, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_TREE_MODEL_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_TREE_VIEW_COLUMN_SIZING, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_TREE_VIEW_DROP_POSITION, strip_prefix);
  nsp_flags_add_constants((NspHash *)module, GTK_TYPE_WIDGET_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash *) module, GTK_TYPE_WIDGET_HELP_TYPE, strip_prefix);
}

/* intialise stuff extension classes */
/* void
gtk_register_classes(NspObject *d)
{
  NspObject *module;

  if ((module = PyImport_ImportModule("gtk")) != NULL) {
      NspObject *moddict = PyModule_GetDict(module);

      _GtkTreeModel = (PyTypeObject *)PyDict_GetItemString(moddict, "Treemodel");
  } else {
      Py_FatalError("could not import gtk");
      return;
  }
  if ((module = PyImport_ImportModule("pango")) != NULL) {
      NspObject *moddict = PyModule_GetDict(module);

      _PangoLayout = (PyTypeObject *)PyDict_GetItemString(moddict, "Layout");
      _PangoLanguage = (PyTypeObject *)PyDict_GetItemString(moddict, "Language");
      _PangoFontDescription = (PyTypeObject *)PyDict_GetItemString(moddict, "FontDescription");
      _PangoAttrList = (PyTypeObject *)PyDict_GetItemString(moddict, "AttrList");
      _PangoTabArray = (PyTypeObject *)PyDict_GetItemString(moddict, "TabArray");
      _PangoContext = (PyTypeObject *)PyDict_GetItemString(moddict, "Context");
  } else {
      Py_FatalError("could not import pango");
      return;
  }
  if ((module = PyImport_ImportModule("gdk")) != NULL) {
      NspObject *moddict = PyModule_GetDict(module);

      _GdkAtom = (PyTypeObject *)PyDict_GetItemString(moddict, "Atom");
      _GdkPixmap = (PyTypeObject *)PyDict_GetItemString(moddict, "Pixmap");
      _GdkWindow = (PyTypeObject *)PyDict_GetItemString(moddict, "Window");
      _GdkGc = (PyTypeObject *)PyDict_GetItemString(moddict, "Gc");
      _GdkFont = (PyTypeObject *)PyDict_GetItemString(moddict, "Font");
      _GdkPixbuf = (PyTypeObject *)PyDict_GetItemString(moddict, "Pixbuf");
      _GdkBitmap = (PyTypeObject *)PyDict_GetItemString(moddict, "Bitmap");
      _GdkPixbufAnimation = (PyTypeObject *)PyDict_GetItemString(moddict, "PixbufAnimation");
      _GdkDragContext = (PyTypeObject *)PyDict_GetItemString(moddict, "DragContext");
      _GdkColormap = (PyTypeObject *)PyDict_GetItemString(moddict, "Colormap");
      _GdkColor = (PyTypeObject *)PyDict_GetItemString(moddict, "Color");
      _GdkImage = (PyTypeObject *)PyDict_GetItemString(moddict, "Image");
      _GdkVisual = (PyTypeObject *)PyDict_GetItemString(moddict, "Visual");
      _GdkRectangle = (PyTypeObject *)PyDict_GetItemString(moddict, "Rectangle");
      _GdkEvent = (PyTypeObject *)PyDict_GetItemString(moddict, "Event");
      _GdkScreen = (PyTypeObject *)PyDict_GetItemString(moddict, "Screen");
      _GdkDisplay = (PyTypeObject *)PyDict_GetItemString(moddict, "Display");
  } else {
      Py_FatalError("could not import gdk");
      return;
  }


#line 197 "gtk.override"

#line 49743 "gtk.c"
  nspg_register_boxed(d, "TreePath", GTK_TYPE_TREE_PATH, &PyGtkTreePath_Type);
  nspg_register_boxed(d, "Requisition", GTK_TYPE_REQUISITION, &PyGtkRequisition_Type);
  nspg_register_boxed(d, "IconSet", GTK_TYPE_ICON_SET, &PyGtkIconSet_Type);
  nspg_register_boxed(d, "IconSource", GTK_TYPE_ICON_SOURCE, &PyGtkIconSource_Type);
  nspg_register_boxed(d, "SelectionData", GTK_TYPE_SELECTION_DATA, &PyGtkSelectionData_Type);
  nspg_register_boxed(d, "TextAttributes", GTK_TYPE_TEXT_ATTRIBUTES, &PyGtkTextAttributes_Type);
  nspg_register_boxed(d, "TextIter", GTK_TYPE_TEXT_ITER, &PyGtkTextIter_Type);
  nspg_register_boxed(d, "TreeIter", GTK_TYPE_TREE_ITER, &PyGtkTreeIter_Type);
  nspg_register_interface(d, "Editable", GTK_TYPE_EDITABLE, &PyGtkEditable_Type);
  nspg_register_interface(d, "CellEditable", GTK_TYPE_CELL_EDITABLE, &PyGtkCellEditable_Type);
  nspg_register_interface(d, "TreeModel", GTK_TYPE_TREE_MODEL, &PyGtkTreeModel_Type);
  nspg_register_interface(d, "TreeDragSource", GTK_TYPE_TREE_DRAG_SOURCE, &PyGtkTreeDragSource_Type);
  nspg_register_interface(d, "TreeDragDest", GTK_TYPE_TREE_DRAG_DEST, &PyGtkTreeDragDest_Type);
  nspg_register_interface(d, "TreeSortable", GTK_TYPE_TREE_SORTABLE, &PyGtkTreeSortable_Type);
  nspgobject_register_class(d, "GtkAccelGroup", GTK_TYPE_ACCEL_GROUP, &PyGtkAccelGroup_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkAccessible", GTK_TYPE_ACCESSIBLE, &PyGtkAccessible_Type, Py_BuildValue("(O)", &PyAtkObject_Type));
  nspgobject_register_class(d, "GtkIconFactory", GTK_TYPE_ICON_FACTORY, &PyGtkIconFactory_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkObject", GTK_TYPE_OBJECT, &PyGtkObject_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkItemFactory", GTK_TYPE_ITEM_FACTORY, &PyGtkItemFactory_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
  nspgobject_register_class(d, "GtkIMContext", GTK_TYPE_IM_CONTEXT, &PyGtkIMContext_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
  nspgobject_register_class(d, "GtkIMContextSimple", GTK_TYPE_IM_CONTEXT_SIMPLE, &PyGtkIMContextSimple_Type, Py_BuildValue("(O)", &PyGtkIMContext_Type));
  nspgobject_register_class(d, "GtkIMMulticontext", GTK_TYPE_IM_MULTICONTEXT, &PyGtkIMMulticontext_Type, Py_BuildValue("(O)", &PyGtkIMContext_Type));
  nspgobject_register_class(d, "GtkCellRenderer", GTK_TYPE_CELL_RENDERER, &PyGtkCellRenderer_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
  nspgobject_register_class(d, "GtkCellRendererToggle", GTK_TYPE_CELL_RENDERER_TOGGLE, &PyGtkCellRendererToggle_Type, Py_BuildValue("(O)", &PyGtkCellRenderer_Type));
  nspgobject_register_class(d, "GtkCellRendererText", GTK_TYPE_CELL_RENDERER_TEXT, &PyGtkCellRendererText_Type, Py_BuildValue("(O)", &PyGtkCellRenderer_Type));
  nspgobject_register_class(d, "GtkCellRendererPixbuf", GTK_TYPE_CELL_RENDERER_PIXBUF, &PyGtkCellRendererPixbuf_Type, Py_BuildValue("(O)", &PyGtkCellRenderer_Type));
  nspgobject_register_class(d, "GtkAdjustment", GTK_TYPE_ADJUSTMENT, &PyGtkAdjustment_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
  nspgobject_register_class(d, "GtkRcStyle", GTK_TYPE_RC_STYLE, &PyGtkRcStyle_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkSettings", GTK_TYPE_SETTINGS, &PyGtkSettings_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkSizeGroup", GTK_TYPE_SIZE_GROUP, &PyGtkSizeGroup_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkStyle", GTK_TYPE_STYLE, &PyGtkStyle_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkTextBuffer", GTK_TYPE_TEXT_BUFFER, &PyGtkTextBuffer_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkTextChildAnchor", GTK_TYPE_TEXT_CHILD_ANCHOR, &PyGtkTextChildAnchor_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkTextMark", GTK_TYPE_TEXT_MARK, &PyGtkTextMark_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkTextTag", GTK_TYPE_TEXT_TAG, &PyGtkTextTag_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkTextTagTable", GTK_TYPE_TEXT_TAG_TABLE, &PyGtkTextTagTable_Type, Py_BuildValue("(O)", &PyGObject_Type));
  nspgobject_register_class(d, "GtkTooltips", GTK_TYPE_TOOLTIPS, &PyGtkTooltips_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
  nspgobject_register_class(d, "GtkListStore", GTK_TYPE_LIST_STORE, &PyGtkListStore_Type, Py_BuildValue("(OOOOO)", &PyGObject_Type, &PyGtkTreeModel_Type, &PyGtkTreeDragSource_Type, &PyGtkTreeDragDest_Type, &PyGtkTreeSortable_Type));
  nspgobject_register_class(d, "GtkTreeModelSort", GTK_TYPE_TREE_MODEL_SORT, &PyGtkTreeModelSort_Type, Py_BuildValue("(OOO)", &PyGObject_Type, &PyGtkTreeModel_Type, &PyGtkTreeSortable_Type));
  nspgobject_register_class(d, "GtkTreeSelection", GTK_TYPE_TREE_SELECTION, &PyGtkTreeSelection_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
  nspgobject_register_class(d, "GtkTreeStore", GTK_TYPE_TREE_STORE, &PyGtkTreeStore_Type, Py_BuildValue("(OOOOO)", &PyGObject_Type, &PyGtkTreeModel_Type, &PyGtkTreeDragSource_Type, &PyGtkTreeDragDest_Type, &PyGtkTreeSortable_Type));
  nspgobject_register_class(d, "GtkTreeViewColumn", GTK_TYPE_TREE_VIEW_COLUMN, &PyGtkTreeViewColumn_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
  nspgobject_register_class(d, "GtkWidget", GTK_TYPE_WIDGET, &PyGtkWidget_Type, Py_BuildValue("(O)", &PyGtkObject_Type));
  nspgobject_register_class(d, "GtkSeparator", GTK_TYPE_SEPARATOR, &PyGtkSeparator_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
  nspgobject_register_class(d, "GtkVSeparator", GTK_TYPE_VSEPARATOR, &PyGtkVSeparator_Type, Py_BuildValue("(O)", &PyGtkSeparator_Type));
  nspgobject_register_class(d, "GtkHSeparator", GTK_TYPE_HSEPARATOR, &PyGtkHSeparator_Type, Py_BuildValue("(O)", &PyGtkSeparator_Type));
  nspgobject_register_class(d, "GtkRuler", GTK_TYPE_RULER, &PyGtkRuler_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
  nspgobject_register_class(d, "GtkVRuler", GTK_TYPE_VRULER, &PyGtkVRuler_Type, Py_BuildValue("(O)", &PyGtkRuler_Type));
  nspgobject_register_class(d, "GtkHRuler", GTK_TYPE_HRULER, &PyGtkHRuler_Type, Py_BuildValue("(O)", &PyGtkRuler_Type));
  nspgobject_register_class(d, "GtkRange", GTK_TYPE_RANGE, &PyGtkRange_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
  nspgobject_register_class(d, "GtkScrollbar", GTK_TYPE_SCROLLBAR, &PyGtkScrollbar_Type, Py_BuildValue("(O)", &PyGtkRange_Type));
  nspgobject_register_class(d, "GtkVScrollbar", GTK_TYPE_VSCROLLBAR, &PyGtkVScrollbar_Type, Py_BuildValue("(O)", &PyGtkScrollbar_Type));
  nspgobject_register_class(d, "GtkHScrollbar", GTK_TYPE_HSCROLLBAR, &PyGtkHScrollbar_Type, Py_BuildValue("(O)", &PyGtkScrollbar_Type));
  nspgobject_register_class(d, "GtkScale", GTK_TYPE_SCALE, &PyGtkScale_Type, Py_BuildValue("(O)", &PyGtkRange_Type));
  nspgobject_register_class(d, "GtkVScale", GTK_TYPE_VSCALE, &PyGtkVScale_Type, Py_BuildValue("(O)", &PyGtkScale_Type));
  nspgobject_register_class(d, "GtkHScale", GTK_TYPE_HSCALE, &PyGtkHScale_Type, Py_BuildValue("(O)", &PyGtkScale_Type));
  nspgobject_register_class(d, "GtkProgress", GTK_TYPE_PROGRESS, &PyGtkProgress_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
  nspgobject_register_class(d, "GtkProgressBar", GTK_TYPE_PROGRESS_BAR, &PyGtkProgressBar_Type, Py_BuildValue("(O)", &PyGtkProgress_Type));
  nspgobject_register_class(d, "GtkPreview", GTK_TYPE_PREVIEW, &PyGtkPreview_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
  nspgobject_register_class(d, "GtkOldEditable", GTK_TYPE_OLD_EDITABLE, &PyGtkOldEditable_Type, Py_BuildValue("(OO)", &PyGtkWidget_Type, &PyGtkEditable_Type));
  nspgobject_register_class(d, "GtkMisc", GTK_TYPE_MISC, &PyGtkMisc_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
  nspgobject_register_class(d, "GtkArrow", GTK_TYPE_ARROW, &PyGtkArrow_Type, Py_BuildValue("(O)", &PyGtkMisc_Type));
  nspgobject_register_class(d, "GtkImage", GTK_TYPE_IMAGE, &PyGtkImage_Type, Py_BuildValue("(O)", &PyGtkMisc_Type));
  nspgobject_register_class(d, "GtkLabel", GTK_TYPE_LABEL, &PyGtkLabel_Type, Py_BuildValue("(O)", &PyGtkMisc_Type));
  nspgobject_register_class(d, "GtkAccelLabel", GTK_TYPE_ACCEL_LABEL, &PyGtkAccelLabel_Type, Py_BuildValue("(O)", &PyGtkLabel_Type));
  nspgobject_register_class(d, "GtkInvisible", GTK_TYPE_INVISIBLE, &PyGtkInvisible_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
  nspgobject_register_class(d, "GtkEntry", GTK_TYPE_ENTRY, &PyGtkEntry_Type, Py_BuildValue("(OOO)", &PyGtkWidget_Type, &PyGtkEditable_Type, &PyGtkCellEditable_Type));
  nspgobject_register_class(d, "GtkSpinButton", GTK_TYPE_SPIN_BUTTON, &PyGtkSpinButton_Type, Py_BuildValue("(O)", &PyGtkEntry_Type));
  nspgobject_register_class(d, "GtkDrawingArea", GTK_TYPE_DRAWING_AREA, &PyGtkDrawingArea_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
  nspgobject_register_class(d, "GtkCurve", GTK_TYPE_CURVE, &PyGtkCurve_Type, Py_BuildValue("(O)", &PyGtkDrawingArea_Type));
  nspgobject_register_class(d, "GtkContainer", GTK_TYPE_CONTAINER, &PyGtkContainer_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
  nspgobject_register_class(d, "GtkTreeView", GTK_TYPE_TREE_VIEW, &PyGtkTreeView_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkToolbar", GTK_TYPE_TOOLBAR, &PyGtkToolbar_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkTextView", GTK_TYPE_TEXT_VIEW, &PyGtkTextView_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkTable", GTK_TYPE_TABLE, &PyGtkTable_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkSocket", GTK_TYPE_SOCKET, &PyGtkSocket_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkPaned", GTK_TYPE_PANED, &PyGtkPaned_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkVPaned", GTK_TYPE_VPANED, &PyGtkVPaned_Type, Py_BuildValue("(O)", &PyGtkPaned_Type));
  nspgobject_register_class(d, "GtkHPaned", GTK_TYPE_HPANED, &PyGtkHPaned_Type, Py_BuildValue("(O)", &PyGtkPaned_Type));
  nspgobject_register_class(d, "GtkNotebook", GTK_TYPE_NOTEBOOK, &PyGtkNotebook_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkMenuShell", GTK_TYPE_MENU_SHELL, &PyGtkMenuShell_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkMenu", GTK_TYPE_MENU, &PyGtkMenu_Type, Py_BuildValue("(O)", &PyGtkMenuShell_Type));
  nspgobject_register_class(d, "GtkMenuBar", GTK_TYPE_MENU_BAR, &PyGtkMenuBar_Type, Py_BuildValue("(O)", &PyGtkMenuShell_Type));
  nspgobject_register_class(d, "GtkLayout", GTK_TYPE_LAYOUT, &PyGtkLayout_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkFixed", GTK_TYPE_FIXED, &PyGtkFixed_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkBin", GTK_TYPE_BIN, &PyGtkBin_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkViewport", GTK_TYPE_VIEWPORT, &PyGtkViewport_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
  nspgobject_register_class(d, "GtkScrolledWindow", GTK_TYPE_SCROLLED_WINDOW, &PyGtkScrolledWindow_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
  nspgobject_register_class(d, "GtkItem", GTK_TYPE_ITEM, &PyGtkItem_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
  nspgobject_register_class(d, "GtkMenuItem", GTK_TYPE_MENU_ITEM, &PyGtkMenuItem_Type, Py_BuildValue("(O)", &PyGtkItem_Type));
  nspgobject_register_class(d, "GtkTearoffMenuItem", GTK_TYPE_TEAROFF_MENU_ITEM, &PyGtkTearoffMenuItem_Type, Py_BuildValue("(O)", &PyGtkMenuItem_Type));
  nspgobject_register_class(d, "GtkSeparatorMenuItem", GTK_TYPE_SEPARATOR_MENU_ITEM, &PyGtkSeparatorMenuItem_Type, Py_BuildValue("(O)", &PyGtkMenuItem_Type));
  nspgobject_register_class(d, "GtkCheckMenuItem", GTK_TYPE_CHECK_MENU_ITEM, &PyGtkCheckMenuItem_Type, Py_BuildValue("(O)", &PyGtkMenuItem_Type));
  nspgobject_register_class(d, "GtkRadioMenuItem", GTK_TYPE_RADIO_MENU_ITEM, &PyGtkRadioMenuItem_Type, Py_BuildValue("(O)", &PyGtkCheckMenuItem_Type));
  nspgobject_register_class(d, "GtkImageMenuItem", GTK_TYPE_IMAGE_MENU_ITEM, &PyGtkImageMenuItem_Type, Py_BuildValue("(O)", &PyGtkMenuItem_Type));
  nspgobject_register_class(d, "GtkHandleBox", GTK_TYPE_HANDLE_BOX, &PyGtkHandleBox_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
  nspgobject_register_class(d, "GtkFrame", GTK_TYPE_FRAME, &PyGtkFrame_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
  nspgobject_register_class(d, "GtkAspectFrame", GTK_TYPE_ASPECT_FRAME, &PyGtkAspectFrame_Type, Py_BuildValue("(O)", &PyGtkFrame_Type));
  nspgobject_register_class(d, "GtkEventBox", GTK_TYPE_EVENT_BOX, &PyGtkEventBox_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
  nspgobject_register_class(d, "GtkAlignment", GTK_TYPE_ALIGNMENT, &PyGtkAlignment_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
  nspgobject_register_class(d, "GtkButton", GTK_TYPE_BUTTON, &PyGtkButton_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
  nspgobject_register_class(d, "GtkToggleButton", GTK_TYPE_TOGGLE_BUTTON, &PyGtkToggleButton_Type, Py_BuildValue("(O)", &PyGtkButton_Type));
  nspgobject_register_class(d, "GtkCheckButton", GTK_TYPE_CHECK_BUTTON, &PyGtkCheckButton_Type, Py_BuildValue("(O)", &PyGtkToggleButton_Type));
  nspgobject_register_class(d, "GtkRadioButton", GTK_TYPE_RADIO_BUTTON, &PyGtkRadioButton_Type, Py_BuildValue("(O)", &PyGtkCheckButton_Type));
  nspgobject_register_class(d, "GtkOptionMenu", GTK_TYPE_OPTION_MENU, &PyGtkOptionMenu_Type, Py_BuildValue("(O)", &PyGtkButton_Type));
  nspgobject_register_class(d, "GtkBox", GTK_TYPE_BOX, &PyGtkBox_Type, Py_BuildValue("(O)", &PyGtkContainer_Type));
  nspgobject_register_class(d, "GtkVBox", GTK_TYPE_VBOX, &PyGtkVBox_Type, Py_BuildValue("(O)", &PyGtkBox_Type));
  nspgobject_register_class(d, "GtkColorSelection", GTK_TYPE_COLOR_SELECTION, &PyGtkColorSelection_Type, Py_BuildValue("(O)", &PyGtkVBox_Type));
  nspgobject_register_class(d, "GtkFontSelection", GTK_TYPE_FONT_SELECTION, &PyGtkFontSelection_Type, Py_BuildValue("(O)", &PyGtkVBox_Type));
  nspgobject_register_class(d, "GtkGammaCurve", GTK_TYPE_GAMMA_CURVE, &PyGtkGammaCurve_Type, Py_BuildValue("(O)", &PyGtkVBox_Type));
  nspgobject_register_class(d, "GtkHBox", GTK_TYPE_HBOX, &PyGtkHBox_Type, Py_BuildValue("(O)", &PyGtkBox_Type));
  nspgobject_register_class(d, "GtkStatusbar", GTK_TYPE_STATUSBAR, &PyGtkStatusbar_Type, Py_BuildValue("(O)", &PyGtkHBox_Type));
  nspgobject_register_class(d, "GtkCombo", GTK_TYPE_COMBO, &PyGtkCombo_Type, Py_BuildValue("(O)", &PyGtkHBox_Type));
  nspgobject_register_class(d, "GtkButtonBox", GTK_TYPE_BUTTON_BOX, &PyGtkButtonBox_Type, Py_BuildValue("(O)", &PyGtkBox_Type));
  nspgobject_register_class(d, "GtkVButtonBox", GTK_TYPE_VBUTTON_BOX, &PyGtkVButtonBox_Type, Py_BuildValue("(O)", &PyGtkButtonBox_Type));
  nspgobject_register_class(d, "GtkHButtonBox", GTK_TYPE_HBUTTON_BOX, &PyGtkHButtonBox_Type, Py_BuildValue("(O)", &PyGtkButtonBox_Type));
  nspgobject_register_class(d, "GtkCalendar", GTK_TYPE_CALENDAR, &PyGtkCalendar_Type, Py_BuildValue("(O)", &PyGtkWidget_Type));
  nspgobject_register_class(d, "GtkWindow", GTK_TYPE_WINDOW, &PyGtkWindow_Type, Py_BuildValue("(O)", &PyGtkBin_Type));
  nspgobject_register_class(d, "GtkPlug", GTK_TYPE_PLUG, &PyGtkPlug_Type, Py_BuildValue("(O)", &PyGtkWindow_Type));
  nspgobject_register_class(d, "GtkDialog", GTK_TYPE_DIALOG, &PyGtkDialog_Type, Py_BuildValue("(O)", &PyGtkWindow_Type));
  nspgobject_register_class(d, "GtkMessageDialog", GTK_TYPE_MESSAGE_DIALOG, &PyGtkMessageDialog_Type, Py_BuildValue("(O)", &PyGtkDialog_Type));
  nspgobject_register_class(d, "GtkInputDialog", GTK_TYPE_INPUT_DIALOG, &PyGtkInputDialog_Type, Py_BuildValue("(O)", &PyGtkDialog_Type));
  nspgobject_register_class(d, "GtkFontSelectionDialog", GTK_TYPE_FONT_SELECTION_DIALOG, &PyGtkFontSelectionDialog_Type, Py_BuildValue("(O)", &PyGtkDialog_Type));
  nspgobject_register_class(d, "GtkFileSelection", GTK_TYPE_FILE_SELECTION, &PyGtkFileSelection_Type, Py_BuildValue("(O)", &PyGtkDialog_Type));
  nspgobject_register_class(d, "GtkColorSelectionDialog", GTK_TYPE_COLOR_SELECTION_DIALOG, &PyGtkColorSelectionDialog_Type, Py_BuildValue("(O)", &PyGtkDialog_Type));
  nspgobject_register_class(d, "GtkWindowGroup", GTK_TYPE_WINDOW_GROUP, &PyGtkWindowGroup_Type, Py_BuildValue("(O)", &PyGObject_Type));
}
*/
