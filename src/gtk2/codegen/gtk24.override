/* -*- Mode: C -*- */
%%
headers
#include <gdk/gdk.h>
#include <gtk/gtk.h>

#include "nsp/object.h"
#include "nsp/interf.h"
#include <nsp/gtk/gboxed.h>
#include <nsp/gtk/gobject.h>

#define NSP_LIST_FROM_GLIST( sel_code, free_name) \
  if (( nsp_list =nsp_list_create(NVOID) ) == NULLLIST) \
    { \
      free_name(list); \
      return RET_BUG; \
    } \
  for (tmp = list; tmp != NULL; tmp = tmp->next)  \
    { \
      NspObject *gtk_obj = (NspObject *)sel_code ;\
      if (gtk_obj == NULL) goto clean ;  \
      if ( nsp_list_end_insert(nsp_list, gtk_obj) == FAIL ) goto clean; \
    } \
  MoveObj(stack,1,(NspObject *)nsp_list); \
  return 1; \
  clean :  \
    { \
      free_name(list); \
      nsp_list_destroy(nsp_list); \
      return RET_BUG; \
    } 

#define NSP_OBJ_LIST_FROM_GLIST( sel_code, free_name) \
  if (( nsp_list =nsp_list_create(NVOID) ) == NULLLIST) \
    { \
      free_name(list); \
      return NULLOBJ; \
    } \
  for (tmp = list; tmp != NULL; tmp = tmp->next)  \
    { \
      NspObject *gtk_obj = (NspObject *)sel_code ;\
      if (gtk_obj == NULL) goto clean ;  \
      if ( nsp_list_end_insert(nsp_list, gtk_obj) == FAIL ) goto clean; \
    } \
  return (NspObject *) nsp_list; \
  clean :  \
    { \
      free_name(list); \
      nsp_list_destroy(nsp_list); \
      return NULL; \
    } 

/* Build a NspList */ 

#define NSP_LIST_DEC NspList *nsp_list;

#define NSP_LIST(iter_code , sel_code ) \
  if ( (nsp_list = nsp_list_create(NVOID)) == NULLLIST )  return RET_BUG; \
  iter_code \
    { NspObject *nsp_node; \
      sel_code ; \
      if ( nsp_node == NULL) goto clean ;  \
      if ( nsp_list_end_insert(nsp_list, nsp_node) == FAIL ) goto clean; \
    } 

#define NSP_OBJ_LIST(iter_code , sel_code ) \
  if ( (nsp_list =nsp_list_create(NVOID)) == NULLLIST )  return NULL; \
  iter_code \
    { NspObject *nsp_node; \
      sel_code ; \
      if ( nsp_node == NULL) goto clean ;  \
      if ( nsp_list_end_insert(nsp_list, nsp_node) == FAIL ) goto clean; \
    } 


#define NSP_LIST_CLEAN \
  clean :  \
    { \
       nsp_list_destroy(nsp_list); \
      return RET_BUG; \
    }

#define NSP_OBJ_LIST_CLEAN \
  clean :  \
    { \
      nsp_list_destroy(nsp_list); \
      return NULL; \
    }


GList *glist_from_nsp_list(Stack stack,NspList *L,NspTypeBase *type)
{
  GList *items = NULL;
  Cell *cloc = L->first ; 
  while ( cloc != NULLCELL) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  if (! nspgobject_check(cloc->O, type)) 
	    {
	      Scierror("%s:list item is not a %s",NspFname(stack),type_get_name(type));
	      g_list_free(items);
	      return NULL;
	    }
	  else 
	    {
	      items = g_list_append(items, nspgobject_get(cloc->O));
	    }
	}
      cloc = cloc->next;
    }
  return items ;
}

/* utility */

#define nsp_style_color_array_get_bg(x,pos)   &((x)->bg[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_fg(x,pos)   &((x)->fg[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_light(x,pos) &((x)->light[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_dark(x,pos) &((x)->dark[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_mid(x,pos) &((x)->mid[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_text(x,pos) &((x)->text[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_base(x,pos) &((x)->base[Min(4,Max(0,pos))])
#define nsp_style_color_array_get_text_aa(x,pos) &((x)->text_aa[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_fg_gc(x,pos) ((x)->fg_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_bg_gc(x,pos) ((x)->bg_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_light_gc(x,pos) ((x)->light_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_dark_gc(x,pos) ((x)->dark_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_mid_gc(x,pos) ((x)->mid_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_text_gc(x,pos) ((x)->text_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_base_gc(x,pos) ((x)->base_gc[Min(4,Max(0,pos))])
#define nsp_style_gc_array_get_text_aa_gc(x,pos) ((x)->text_aa_gc[Min(4,Max(0,pos))])
#define nsp_style_pixmap_array_get_bg_pixmap(x,pos) ((x)->bg_pixmap[Min(4,Max(0,pos))])

/* XXXX */

#define GtkObject_Private
#define GtkCellRenderer_Private
#define GtkTreeModel_Private 

enum {STYLE_COLOUR_ARRAY, STYLE_GC_ARRAY, STYLE_PIXMAP_ARRAY} type;

/* XXXXX a revoir */

#define PYGTK_TYPE_GENERIC_TREE_MODEL G_TYPE_INVALID
#define PYGTK_TYPE_GENERIC_CELL_RENDERER G_TYPE_INVALID
#define  GtkCellEditable_Private 
#include "nsp/gtk/gtkcelleditable.h"

/* XXXX */
extern int nsp_graphic_new(GtkWidget *win,GtkWidget *box, int v2,int *wdim,int *wpdim,double *viewport_pos,int *wpos);
extern int nsp_graphic_new_gl(GtkWidget *win,GtkWidget *box, int v2,int *wdim,int *wpdim,double *viewport_pos,int *wpos);

/* XXXXX : only implemented in 2.4 */
#define gtk_calendar_set_display_options gtk_calendar_display_options
#define gtk_calendar_get_display_options(x) 0 

%%
init
%%
modulename gtk
%%
import gdk.Atom as GdkAtom
import gdk.Pixmap as GdkPixmap
import gdk.Window as GdkWindow
import gdk.Gc as GdkGc
import gdk.Font as GdkFont
import gdk.Pixbuf as GdkPixbuf
import gdk.Bitmap as GdkBitmap
import gdk.PixbufAnimation as GdkPixbufAnimation
import gdk.DragContext as GdkDragContext
import gdk.Colormap as GdkColormap
import gdk.Color as GdkColor
import gdk.Image as GdkImage
import gdk.Visual as GdkVisual
import gdk.Rectangle as GdkRectangle
import gdk.Event as GdkEvent
import gdk.Screen as GdkScreen
import gdk.Display as GdkDisplay

import gtk.Treemodel as GtkTreeModel
import pango.Layout as PangoLayout
import pango.Language as PangoLanguage
import pango.FontDescription  as PangoFontDescription 
import pango.AttrList  as PangoAttrList 
import pango.TabArray  as PangoTabArray
import pango.Context  as PangoContext

%%
ignore-glob
*_get_type
_*
*_ref
*_unref
%%
ignore gtk_tree_path_free gtk_tree_path_copy
%%
ignore gtk_tree_path_new_first gtk_tree_path_new_from_string 
%%
override gtk_tree_path_new
static int
_wrap_gtktreepath_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(1,1);
  if ((ret = (GObject *)nsp_gtk_tree_path_from_nspobject(NthObj(1)))== NULL) 
    {
      Scierror("Error: enable to create a GtkTreePath\n");
      return RET_BUG;
    }
  nsp_type_gtktreepath = new_type_gtktreepath(T_BASE);
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

NspObject *nsp_gtk_tree_path_to_nspobject(GtkTreePath *path)
{
  gint len, i, *indices;
  NspObject *ret; 
  len = gtk_tree_path_get_depth(path);
  indices = gtk_tree_path_get_indices(path);
  if ((ret = (NspObject *) nsp_matrix_create(NVOID,'r',1,len))== NULL) return NULL;
  for (i = 0; i < len; i++) ((NspMatrix *) ret)->R[i]= indices[i];
  return ret;
}

GtkTreePath *nsp_gtk_tree_path_from_nspobject(NspObject *object)
{
  GtkTreePath *path;
  /** Follow pointer **/
  HOBJ_GET_OBJECT(object,NULL);
  
  if ( IsGtkTreePath(object) )
    {
      return g_boxed_copy(GTK_TYPE_TREE_PATH,nspg_boxed_get(object,GtkTreePath));
    }
  
  if ( IsString(object)) 
    {
      path = gtk_tree_path_new_from_string(((NspSMatrix *) object)->S[0]);
      return path;
    }
  else if (IsMat(object) && ((NspMatrix *) object)->rc_type == 'r')
    {
      int i;
      NspMatrix *M = (NspMatrix *) object;
      path = gtk_tree_path_new();
      for (i = 0; i < M->mn; i++)  gtk_tree_path_append_index(path,(gint) M->R[i]);
      return path;
    }
  return NULL;
}
%%
override gtk_tree_path_get_indices
static int 
_wrap_gtk_tree_path_get_indices(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreePath *path = NSP_GBOXED_GET(self, GtkTreePath);
  NspObject *ret;
  if ((ret = nsp_gtk_tree_path_to_nspobject(path))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1;
}
%%
override-attr GtkStyle.fg
static NspObject *
_wrap_gtk_style__get_fg(NspGObject *self, char *attr)
{
  Scierror("Use method .get_fg[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.bg
static NspObject *
_wrap_gtk_style__get_bg(NspGObject *self, char *attr)
{
  Scierror("Use method .get_bg[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.light
static NspObject *
_wrap_gtk_style__get_light(NspGObject *self, char *attr)
{
  Scierror("Use method .get_light[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.dark
static NspObject *
_wrap_gtk_style__get_dark(NspGObject *self, char *attr)
{
  Scierror("Use method .get_dark[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.mid
static NspObject *
_wrap_gtk_style__get_mid(NspGObject *self, char *attr)
{
  Scierror("Use method .get_mid[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.text
static NspObject *
_wrap_gtk_style__get_text(NspGObject *self, char *attr)
{
  Scierror("Use method .get_text[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.base
static NspObject *
_wrap_gtk_style__get_base(NspGObject *self, char *attr)
{
  Scierror("Use method .get_base[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.text_aa
static NspObject *
_wrap_gtk_style__get_text_aa(NspGObject *self, char *attr)
{
  Scierror("Use method .get_text_aa[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.white
static NspObject *
_wrap_gtk_style__get_white(NspGObject *self, char *attr)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  return (NspObject *)gboxed_create(NVOID,GDK_TYPE_COLOR, &style->white, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor);
}
static int
_wrap_gtk_style__set_white(NspGObject *self, char *attr, NspObject *value)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  if (!nspg_boxed_check(value, GDK_TYPE_COLOR)) {
    Scierror("can only assign a GdkColor");
    return RET_BUG;
  }
  style->white = *nspg_boxed_get(value, GdkColor);
  return 0;
}
%%
override-attr GtkStyle.black
static NspObject *
_wrap_gtk_style__get_black(NspGObject *self, char *attr)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  return (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, &style->black, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor);
}
static int
_wrap_gtk_style__set_black(NspGObject *self, char *attr, NspObject *value)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  if (!nspg_boxed_check(value, GDK_TYPE_COLOR)) {
    Scierror( "can only assign a GdkColor");
    return RET_BUG;
  }
  style->black = *nspg_boxed_get(value, GdkColor);
  return 0;
}
%%
override-attr GtkStyle.fg_gc
static NspObject *
_wrap_gtk_style__get_fg_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_fg_gc[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.bg_gc
static NspObject *
_wrap_gtk_style__get_bg_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_bg_gc[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.light_gc
static NspObject *
_wrap_gtk_style__get_light_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_light_gc[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.dark_gc
static NspObject *
_wrap_gtk_style__get_dark_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_dark_gc[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.mid_gc
static NspObject *
_wrap_gtk_style__get_mid_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_mid_gc[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.text_gc
static NspObject *
_wrap_gtk_style__get_text_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_text_gc[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.base_gc
static NspObject *
_wrap_gtk_style__get_base_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_base_gc[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.text_aa_gc
static NspObject *
_wrap_gtk_style__get_text_aa_gc(NspGObject *self, char *attr)
{
  Scierror("Use method .get_text_aa_gc[pos]\n");
  return NULL;
}
%%
override-attr GtkStyle.white_gc
static NspObject *
_wrap_gtk_style__get_white_gc(NspGObject *self, char *attr)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  return (NspObject *) gobject_create(NVOID,(GObject *)style->white_gc,(NspTypeBase *) nsp_type_gdkgc );
}
static int
_wrap_gtk_style__set_white_gc(NspGObject *self, char *attr, NspObject *value)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  if (!nspgobject_check((NspGObject *) value,(NspTypeBase *) nsp_type_gdkgc)) {
    Scierror( "can only assign a GdkGC");
    return RET_BUG;
  }
  style->white_gc = GDK_GC(nspgobject_get(value));
  return 0;
}
%%
override-attr GtkStyle.black_gc
static NspObject *
_wrap_gtk_style__get_black_gc(NspGObject *self, char *attr)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  return (NspObject *) gobject_create(NVOID,(GObject *)style->black_gc,(NspTypeBase *) nsp_type_gdkgc );
}
static int
_wrap_gtk_style__set_black_gc(NspGObject *self, char *attr, NspObject *value)
{
  GtkStyle *style = GTK_STYLE(self->obj);
  if (!nspgobject_check((NspGObject *) value,(NspTypeBase *) nsp_type_gdkgc)) {
    Scierror( "can only assign a GdkGC");
    return RET_BUG;
  }
  style->black_gc = GDK_GC(nspgobject_get(value));
  return 0;
}
%%
override-attr GtkStyle.bg_pixmap
static NspObject *
_wrap_gtk_style__get_bg_pixmap(NspGObject *self, char *attr)
{
  Scierror("Use method .get_bg_pixmap[pos]\n");
  return NULL;
}
%%
override gtk_paint_polygon kwargs
static int
_wrap_gtk_paint_polygon(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,obj,obj,obj_check,string,realmat,s_bool, t_end} ;
  /*  static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "points", "fill", NULL }; */
  NspObject *window, *nsp_state_type, *nsp_shadow_type, *nsp_area;
  GtkStateType state_type;
  GtkShadowType shadow_type;
  GdkRectangle area;
  NspObject *widget;
  const gchar *detail;
  NspMatrix *nsp_points;
  gint npoints, i;
  GdkPoint *points;
  gboolean fill;
  
  if (GetArgs(stack,rhs,opt,T,
	      &nsp_type_gdkwindow, &window,
	      &nsp_state_type, &nsp_shadow_type, &nsp_area,
	      &nsp_type_gtkwidget, &widget, &detail,
	      &nsp_points, &fill) == FAIL) return RET_BUG;

  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state_type,&state_type)== FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_shadow_type,&shadow_type) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_area, &area)) return RET_BUG;
  
  if ( nsp_points->n != 2) { 
    Scierror("%s: third argument should have two columns\n");
    return RET_BUG;
  } 
  
  npoints = nsp_points->m;
  points = g_new(GdkPoint, npoints);
  for (i = 0; i < npoints ; i++) {
    points[i].x = nsp_points->R[i] ; 
    points[i].y = nsp_points->R[i +nsp_points->m ];
    }
  gtk_paint_polygon(GTK_STYLE(self->obj), GDK_WINDOW(nspgobject_get(window)),
		    state_type, shadow_type, &area,
		    GTK_WIDGET(nspgobject_get(widget)), detail,
		    points, npoints, fill);
  g_free(points);
  return 0;
}
%%
override-attr GtkSelectionData.data
static NspObject *
_wrap_gtk_selection_data__get_data(NspGObject *self, char *attr)
{
  if (nspg_boxed_get(self, GtkSelectionData)->length >= 0) {
    return nsp_new_string_obj(NVOID, 
			      (const char *) nspg_boxed_get(self, GtkSelectionData)->data,
			      (int) nspg_boxed_get(self, GtkSelectionData)->length);
  } else {
    return nsp_new_string_obj(NVOID,NULL,0);
  }
}
%%
ignore gtk_selection_data_copy gtk_selection_data_free
%%
override gtk_selection_data_set kwargs
static int
_wrap_gtk_selection_data_set(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,string, t_end} ;
  /* static char *kwlist[] = { "type", "format", "data", NULL };*/
  NspObject *nsp_type;
  GdkAtom type;
  int format, length;
  char *data;

  if (GetArgs(stack,rhs,opt,T,&nsp_type, &format, &data) == FAIL) return RET_BUG;
  length = strlen(data);
  if (nsp_gdk_atom_from_object(nsp_type,&type) == FAIL) return RET_BUG;
  gtk_selection_data_set(nspg_boxed_get(self, GtkSelectionData),
			 type, format,(const guchar *) data, length);
  return 0;
}
%%
override gtk_selection_data_get_text noargs
static int
_wrap_gtk_selection_data_get_text(NspObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* 
  guchar *ret;
  ret = gtk_selection_data_get_text(nspg_boxed_get(self, GtkSelectionData));
  if (ret) {
    NspObject *nsp_ret = NspUnicode_DecodeUTF8(ret, strlen(ret), "strict");
    g_free(ret);
    return nsp_ret;
  }
  */
  Scierror("To be done XXXXX gtk_selection_data_get_text");
  return 0;
}
%%
override gtk_selection_data_get_targets noargs
static int
_wrap_gtk_selection_data_get_targets(NspObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkAtom *targets;
  gint n_atoms;
  gint i;

  NSP_LIST_DEC; 

  if ( !gtk_selection_data_get_targets(nspg_boxed_get(self, GtkSelectionData), &targets, &n_atoms)) 
    return RET_BUG; 
  NSP_LIST( for (i = 0; i < n_atoms; i++), nsp_node = (NspObject *) gdkatom_create(NVOID,NULL,targets[i],NULL)); 
  g_free(targets);
  MoveObj(stack,1,(NspObject *) nsp_list);
  return 1; 
  NSP_LIST_CLEAN; 
}
%%
override gtk_tree_get_row_drag_data noargs
static int
_wrap_gtk_tree_get_row_drag_data(NspObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *tree_model;
  GtkTreePath *path;
  int_types T[] = {obj,obj, t_end} ;
  NspObject *nsp_model,*nsp_path; 
  if (gtk_tree_get_row_drag_data(nspg_boxed_get(self, GtkSelectionData), &tree_model, &path)) 
    {
      nsp_model = (NspObject *)  nspgobject_new(NVOID,(GObject *)tree_model);
      nsp_path =  (NspObject *)  nsp_gtk_tree_path_to_nspobject(path);
      gtk_tree_path_free(path);
      if ( nsp_model == NULL || nsp_path == NULL) return RET_BUG; 
    } 
  else 
    {
      nsp_model= (NspObject *) nsp_none_create(NVOID,NULL);
      nsp_path= (NspObject *) nsp_none_create(NVOID,NULL); 
    }
  return RetArgs(stack,lhs,T,nsp_model,nsp_path);  
}
%%
ignore gtk_widget_newv
%%
override gtk_widget_new 
extern int int_gobj_create(Stack stack,int rhs,int opt,int lhs);
static int
_wrap_gtkwidget_new(Stack stack, int rhs, int opt, int lhs)
{
  return int_gobj_create( stack, rhs, opt, lhs) ;
}

%%
override gtk_widget_translate_coordinates kwargs
static int
_wrap_gtk_widget_translate_coordinates(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "dest_widget", "src_x", "src_y", NULL };*/
  NspGObject *nsp_dest_widget;
  int src_x, src_y;
  GtkWidget *dest_widget = NULL;
  int dest_x, dest_y;

  if (GetArgs(stack,rhs,opt,T, &nsp_dest_widget, &src_x, &src_y) == FAIL) return RET_BUG;
    
  if (nspgobject_check( nsp_dest_widget, (NspTypeBase *) nsp_type_gtkwidget)) {
    dest_widget = GTK_WIDGET(nspgobject_get(nsp_dest_widget));
  } else if ( ! IsNone((NspObject *)nsp_dest_widget)) {
    Scierror("dest_widget must be a GtkWidget or None");
    return RET_BUG;
  }

  if (!gtk_widget_translate_coordinates(GTK_WIDGET(self->obj),dest_widget,src_x,src_y,&dest_x,&dest_y)) 
    {
      if ( nsp_move_doubles(stack,1,0,0) == FAIL) return RET_BUG; 
    }
  else 
    {
      if ( nsp_move_doubles(stack,1,1,2,(double) dest_x,(double) dest_y) == FAIL) return RET_BUG; 
    }
  return 1;
}
%%
override gtk_widget_size_request noargs
static int
_wrap_gtk_widget_size_request(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkRequisition requisition;
  gtk_widget_size_request(GTK_WIDGET(self->obj), &requisition);
  if (  nsp_move_doubles(stack,1,1,2,(double) requisition.width,
			 (double) requisition.height) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_widget_get_child_requisition noargs
static int
_wrap_gtk_widget_get_child_requisition(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkRequisition requisition;
  gtk_widget_get_child_requisition(GTK_WIDGET(self->obj), &requisition);
  if (  nsp_move_doubles(stack,1,1,2,(double) requisition.width,
			 (double) requisition.height) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_widget_add_accelerator
/* adding the case where the accelerator is transmited as a string to be decoded */

static int _wrap_gtk_widget_add_string_accelerator(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs);

static int _wrap_gtk_widget_add_accelerator(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj_check, s_int, obj, obj,t_end};
  NspObject *nsp_accel_mods = NULL, *nsp_accel_flags = NULL;
  int accel_key;
  NspGObject *accel_group;
  GdkModifierType accel_mods;
  GtkAccelFlags accel_flags;
  char *accel_signal;
  if ( rhs == 4 )  return _wrap_gtk_widget_add_string_accelerator(self,stack,rhs,opt,lhs);
  if ( GetArgs(stack,rhs,opt,T,&accel_signal, &nsp_type_gtkaccelgroup, &accel_group, &accel_key, &nsp_accel_mods, &nsp_accel_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accel_mods, &accel_mods)==FAIL)
      return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ACCEL_FLAGS, nsp_accel_flags, &accel_flags)==FAIL)
      return RET_BUG;
  gtk_widget_add_accelerator(GTK_WIDGET(self->obj), accel_signal, GTK_ACCEL_GROUP(accel_group->obj), accel_key, accel_mods, accel_flags);
  return 0;
}

/* added */
static int _wrap_gtk_widget_add_string_accelerator(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj_check,string , obj,t_end};
  NspObject *nsp_accel_flags = NULL;
  guint accel_key;
  NspGObject *accel_group;
  GdkModifierType accel_mods;
  GtkAccelFlags accel_flags;
  char *accel_signal;
  char *accel_string;

  if ( GetArgs(stack,rhs,opt,T,&accel_signal, &nsp_type_gtkaccelgroup, &accel_group,&accel_string,
	       &nsp_accel_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ACCEL_FLAGS, nsp_accel_flags, &accel_flags)==FAIL)
    return RET_BUG;
  gtk_accelerator_parse (accel_string, &accel_key, &accel_mods);
  if ( accel_key == 0 && accel_mods == 0) 
    {
      Scierror("Error: invalid accelerator %s\n",accel_string);
      return RET_BUG;
    }
  gtk_widget_add_accelerator(GTK_WIDGET(self->obj), accel_signal, GTK_ACCEL_GROUP(accel_group->obj), accel_key, accel_mods, accel_flags);
  return 0;
}



%%
override gtk_widget_get_allocation noargs
static int
_wrap_gtk_widget_get_allocation(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAllocation allocation;
  NspObject *ret;
  allocation = GTK_WIDGET(self->obj)->allocation;
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &allocation, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL)
     return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_widget_intersect kwargs
static int
_wrap_gtk_widget_intersect(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "area", NULL };*/
  NspObject *nsp_area, * ret;
  GdkRectangle area, intersect;

  if(GetArgs(stack,rhs,opt,T, &nsp_area) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_area, &area))  return RET_BUG;
  if (gtk_widget_intersect(GTK_WIDGET(self->obj), &area, &intersect))
    {
      if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &intersect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL) 
	return RET_BUG;
      MoveObj(stack,1,ret);
      return 1; 
    }
  else 
    return RET_BUG;
}
%%
override gtk_widget_get_toplevel noargs
static int _wrap_gtk_widget_get_toplevel(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWindow *ret;

  ret = (GtkWindow *) gtk_widget_get_toplevel(GTK_WIDGET(self->obj));
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

%%
override gtk_widget_get_parent noargs
/* the returned value is more specific than nsp_type_gtkwidget */
static int 
_wrap_gtk_widget_get_parent(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject * ob;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&ob) == FAIL) return RET_BUG;
  ret = gtk_widget_get_parent(GTK_WIDGET(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_gettype_and_create(NVOID,(GObject *)ret))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

%%
override gtk_widget_get_pointer noargs
static int
_wrap_gtk_widget_get_pointer(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int x, y;
  gtk_widget_get_pointer(GTK_WIDGET(self->obj), &x, &y);
  if (  nsp_move_doubles(stack,1,1,2,(double) x, (double) y) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_widget_path noargs
static int
_wrap_gtk_widget_path(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  guint length;
  gchar *path;
  gchar *path_reversed;
  NspObject *result;

  gtk_widget_path(GTK_WIDGET(self->obj), &length, &path, &path_reversed);
  result = nsp_new_string_obj(NVOID,path,-1);
  g_free(path);
  g_free(path_reversed);
  MoveObj(stack,1, result);
  return 1;
}
%%
override gtk_widget_class_path noargs
static int
_wrap_gtk_widget_class_path(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  guint length;
  gchar *path;
  gchar *path_reversed;
  NspObject *result;

  gtk_widget_class_path(GTK_WIDGET(self->obj), &length, &path,	&path_reversed);
  result = nsp_new_string_obj(NVOID,path,-1);
  g_free(path);
  g_free(path_reversed);
  MoveObj(stack,1,result);
  return 1;
}
%%
override gtk_container_child_type noargs
static int _wrap_gtk_container_child_type(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  NspTypeBase *type;
  GType ret;
  CheckRhs(0,0);
  ret = gtk_container_child_type(GTK_CONTAINER(self->obj));
  type = nsp_type_from_gtype(ret);
  if ( type == NULL) return RET_BUG; 
  if ((nsp_ret = (NspObject *) type_create(NVOID,type ,NULL))== NULL) return RET_BUG; 
  MoveObj(stack,1,nsp_ret);
  return 1; 
}

%%
override gtk_container_children noargs
static int
_wrap_gtk_container_children(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  Scierror("Deprecated: use GtkContainer.get_children");
  return RET_BUG;
}
%%
override gtk_container_get_children noargs

static int
_wrap_gtk_container_get_children(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;

  list = gtk_container_get_children(GTK_CONTAINER(self->obj));
  NSP_LIST_FROM_GLIST( gobject_gettype_and_create("lel",G_OBJECT(tmp->data)), g_list_free);
}
%%
override gtk_container_set_focus_chain kwargs
static int
_wrap_gtk_container_set_focus_chain(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list , t_end} ;
  /* static char *kwlist[] = { "focusable_widgets", NULL };*/
  NspList *nsp_focusable_widgets;
  GList *focusable_widgets = NULL;
  Cell *C;

  if (GetArgs(stack,rhs,opt,T,&nsp_focusable_widgets)== FAIL) return RET_BUG;
    
  C= nsp_focusable_widgets->first;
  while ( C != NULLCELL) 
    {
      if ( C->O != NULLOBJ )
	{
	  if (!nspgobject_check((NspGObject *) C->O,nsp_type_gtkwidget)) 
	    {
	      Scierror("focusable_widgets members must be GtkWidgets");
	      return RET_BUG;
	    }
	  focusable_widgets = g_list_prepend(focusable_widgets,
					     nspgobject_get(C->O));
	}
      C = C->next ;
    }
  focusable_widgets = g_list_reverse(focusable_widgets);
  gtk_container_set_focus_chain(GTK_CONTAINER(self->obj), focusable_widgets);
  g_list_free(focusable_widgets);
  return 0;
}
%%
override gtk_container_get_focus_chain noargs
static int
_wrap_gtk_container_get_focus_chain(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;

  if (! gtk_container_get_focus_chain(GTK_CONTAINER(self->obj), &list)) return 0;
  
  NSP_LIST_FROM_GLIST( gobject_gettype_and_create("lel",G_OBJECT(tmp->data)),g_list_free); 
  
}
%%
override gtk_container_child_get_property
static int
_wrap_gtk_container_child_get_property(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *pychild;
  gchar *property_name;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  GObjectClass *class;
  GParamSpec *pspec;
  GValue value = { 0, } ;
  NspObject *ret;
  
  int_types T[] = {obj_check,string, t_end} ;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &pychild,&property_name)== FAIL) return RET_BUG;
  
  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("%s: first argument must be a child",NspFname(stack));
    return RET_BUG;
  }
  
  class = G_OBJECT_GET_CLASS(container);
  pspec = gtk_container_class_find_child_property(class, property_name);
  if (!pspec) {
    Scierror("container does not support property `%s'", property_name);
    return RET_BUG;
  }
  
  g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
  
  gtk_container_child_get_property(container,
				   child,
				   property_name,
				   &value);
  
  ret = nspg_value_as_nspobject(&value, TRUE);
  g_value_unset(&value);
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_container_child_set_property
static int
_wrap_gtk_container_child_set_property(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *property_name;
  NspGObject *pychild;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  NspGObject *pyvalue;
  GObjectClass *class;
  GParamSpec *pspec;
  GValue value = { 0, } ;

  int_types T[] = {obj_check,string,obj, t_end} ;
  
  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget,&pychild,&property_name,&pyvalue)== FAIL) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("%s: first argument must be a child",NspFname(stack));
    return RET_BUG;
  }

  class = G_OBJECT_GET_CLASS(self->obj);
  pspec = gtk_container_class_find_child_property(class, property_name);

  if (!pspec) {
    Scierror("container does not support property `%s'", property_name);
    return RET_BUG;
  }
  g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

  nspg_value_from_nspobject(&value, (NspObject*)pyvalue);

  gtk_container_child_set_property(container,
				   child,
				   property_name,
				   &value);
  g_value_unset(&value);
  return 0;
}
%%
override gtk_container_child_set
static int
_wrap_gtk_container_child_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *pychild;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  GObjectClass *class;
  int i;
    
  CheckRhs(1,1000);
  if ((pychild = GetGtkWidget(stack,1)) == NULL) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("first argument must be a child");
    return RET_BUG;
  }

  class = G_OBJECT_GET_CLASS(self->obj);

  for ( i = 2 ; i <= rhs ; i++) 
    {
      gchar *property_name;
      NspObject *nsp_value;
      GParamSpec *pspec;
      GValue value = { 0 };
      if ( Ocheckname(NthObj(i),NVOID) ) 
	{
	  Scierror("Error: properties mus have names \n");
	  Scierror("\t%s of function %s\n",ArgPosition(rhs),NspFname(stack));
	  return RET_BUG;
	}
      /** A copy of object is entered as an object property **/
      /** GetObj takes care of Hobj pointers **/
      if (( nsp_value =nsp_get_object(stack,i)) == NULLOBJ ) return RET_BUG;
      property_name =nsp_object_get_name(nsp_value);
      pspec = gtk_container_class_find_child_property(class, property_name);
      if (!pspec) {
	Scierror("container does not support property `%s'",property_name);
	/* clean .....*/
	return RET_BUG;
      }
      g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
      nspg_value_from_nspobject(&value, (NspObject*)nsp_value);
      gtk_container_child_set_property(container, child, property_name, &value);
      g_value_unset(&value);
    }
  return 0;
}
%%
override gtk_container_child_get
static int
_wrap_gtk_container_child_get(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspSMatrix *props;
  NspGObject *pychild;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  GObjectClass *class;
  int  i;
  NspList *nsp_list; 

  CheckRhs(2,2);
  if ((pychild = GetGtkWidget(stack,1)) == NULL) return RET_BUG;
  if (( props = GetSMat(stack,2)) == NULLSMAT) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("first argument is not a child of given container\n");
    return RET_BUG;
  }
    
  class = G_OBJECT_GET_CLASS(self->obj);

  if (( nsp_list =nsp_list_create(NVOID) ) == NULLLIST) return RET_BUG; 
  
  for ( i = 0 ; i < props->mn ; i++) {
    gchar *property_name = props->S[i];
    GParamSpec *pspec;
    GValue value = { 0 };
    NspObject *item;
    pspec = gtk_container_class_find_child_property(class, property_name);
    if (!pspec) {
      Scierror("container does not support property `%s'",property_name);
      goto clean; 
    }

    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

    gtk_container_child_get_property(container, child, property_name, &value);

    item = nspg_value_as_nspobject(&value, TRUE);

    if ( nsp_list_end_insert(nsp_list, item) == FAIL )
      {
	g_value_unset(&value);
	goto clean;
      }

    g_value_unset(&value);
  }
  return 1;
 clean: 
  {
    nsp_list_destroy(nsp_list);
    return RET_BUG; 
  }

}
%%
override gtk_container_add_with_properties
static int
_wrap_gtk_container_add_with_properties(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *pychild;
  GtkContainer *container;
  GtkWidget *child;
  GObjectClass *class;
  int i;
    
  CheckRhs(1,100);
  if ((pychild = GetGtkWidget(stack,1)) == NULL) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  gtk_widget_freeze_child_notify(child);
  gtk_container_add(container, child);
  class = G_OBJECT_GET_CLASS(self->obj);

  for ( i = 2 ; i <= rhs ; i++) 
    {
      gchar *property_name;
      NspObject *nsp_value;
      GParamSpec *pspec;
      GValue value = { 0 };
      if ( Ocheckname(NthObj(i),NVOID) ) 
	{
	  Scierror("Error: properties must have names \n");
	  Scierror("\t%s of function %s\n",ArgPosition(rhs),NspFname(stack));
	  return RET_BUG;
	}
      /** A copy of object is entered as an object property **/
      /** GetObj takes care of Hobj pointers **/
      if (( nsp_value =nsp_get_object(stack,i)) == NULLOBJ ) return RET_BUG;
      property_name =nsp_object_get_name(nsp_value);
      pspec = gtk_container_class_find_child_property(class, property_name);
      if (!pspec) {
	Scierror("container does not support property `%s'",property_name);
	/* clean .....*/
	return RET_BUG;
      }
      g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
      nspg_value_from_nspobject(&value, (NspObject*)nsp_value);
      gtk_container_child_set_property(container, child, property_name, &value);
      g_value_unset(&value);
    }
  gtk_widget_thaw_child_notify(child);
  return 0;
}
%%
override gtk_container_foreach
static void
nspgtk_container_foreach_marshal(GtkWidget *widget, gpointer data)
{
  NspObject *args[2];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 1,nargs = 1;
  nspg_block_threads();

  args[0] = (NspObject *)gobject_gettype_and_create("widget",(GObject *)widget);
  if ( args[0]== NULL ) goto end;
  if (cunote->data) 
    {
      args[1]= cunote->data; 
      nargs= 2;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end ;
  /* 
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  */
  goto end; 
 end: 
  {
    nspg_unblock_threads();
    return;
  }
}

static int
_wrap_gtk_container_foreach(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify cunote;

  CheckRhs(1,2); 
  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 2 ) 
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }
  cunote.func = func;
  cunote.data = arg;
  gtk_container_foreach(GTK_CONTAINER(self->obj), nspgtk_container_foreach_marshal, &cunote);
  return 0;
}

%%
ignore gtk_label_new_with_mnemonic 
%%
override gtk_label_new noargs
static int
_wrap_gtklabel_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"str",string,NULLOBJ,-1}, 
	{"mnemonic",string,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };

  char *str = NULL,  * mnemonic= NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &str,&mnemonic) == FAIL) return RET_BUG;
  if ( mnemonic != NULL) 
    {
      if ((ret = (GObject *)gtk_label_new_with_mnemonic(mnemonic))== NULL) return RET_BUG;
    }
  else 
    {
      if ((ret = (GObject *)gtk_label_new(str))== NULL) return RET_BUG;
    }
  nsp_type_gtklabel = new_type_gtklabel(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtklabel );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

%%
override gtk_label_get noargs
static int
_wrap_gtk_label_get(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  gchar *text = NULL;
  gtk_label_get(GTK_LABEL(self->obj), &text);
  if (text)
    ret = nsp_new_string_obj(NVOID,text,-1);
  else 
    ret = nsp_new_string_obj(NVOID,"",0);
  if (ret == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_label_get_selection_bounds noargs
static int
_wrap_gtk_label_get_selection_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int start, end;

  if (!gtk_label_get_selection_bounds(GTK_LABEL(self->obj), &start, &end)) 
    {
      if (  nsp_move_doubles(stack,1,0,0) == FAIL) 
	return RET_BUG; 
    }
  else 
    {
      if (  nsp_move_doubles(stack,1,1,2,(double) start, (double) end) == FAIL) 
	return RET_BUG; 
    }
  return 1; 
}
%%
override gtk_label_get_layout_offsets noargs
static int
_wrap_gtk_label_get_layout_offsets(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint x, y; 
  gtk_label_get_layout_offsets(GTK_LABEL(self->obj), &x, &y);
  if (  nsp_move_doubles(stack,1,1,2,(double) x,(double) y) == FAIL) 
    return RET_BUG; 
  return 1; 
}
%%
override gtk_spin_button_get_increments noargs
static int
_wrap_gtk_spin_button_get_increments(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gdouble step;
  gdouble page;

  gtk_spin_button_get_increments(GTK_SPIN_BUTTON(self->obj), &step, &page);
  if (  nsp_move_doubles(stack,1,1,2,(double) step,(double) page) == FAIL) 
    return RET_BUG; 
  return 1; 

}
%%
override gtk_spin_button_get_range noargs
static int
_wrap_gtk_spin_button_get_range(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gdouble min;
  gdouble max;

  gtk_spin_button_get_range(GTK_SPIN_BUTTON(self->obj), &min, &max);
  if (  nsp_move_doubles(stack,1,1,2,(double) min,(double) max) == FAIL) 
    return RET_BUG; 
  return 1; 
}
%%
override gtk_window_list_toplevels noargs
static int
_wrap_gtk_window_list_toplevels(Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
  list = gtk_window_list_toplevels();
  NSP_LIST_FROM_GLIST( gobject_gettype_and_create("lel",G_OBJECT(tmp->data)),g_list_free);
}
%%
override gtk_window_set_geometry_hints kwargs
static int
_wrap_gtk_window_set_geometry_hints(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { new_opts,t_end};
  nsp_option opts[] = {
    {"geometry",obj_check,NULLOBJ,-1},
    { "min_width",s_int,NULLOBJ,-1},
    { "min_height",s_int,NULLOBJ,-1},
    { "max_width",s_int,NULLOBJ,-1},
    { "max_height",s_int,NULLOBJ,-1},
    { "base_width",s_int,NULLOBJ,-1},
    {"base_height",s_int,NULLOBJ,-1},
    { "width_inc",s_int,NULLOBJ,-1},
    { "height_inc",s_int,NULLOBJ,-1},
    {"min_aspect",s_int,NULLOBJ,-1},
    { "max_aspect",s_int,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };

  NspObject *nsp_geometry_widget = NULL;
  GtkWidget *geometry_widget = NULL;
  gint min_width = -1, min_height = -1, max_width = -1, max_height = -1;
  gint base_width = -1, base_height = -1, width_inc = -1, height_inc = -1;
  gdouble min_aspect = -1.0, max_aspect = -1.0;
  GdkGeometry geometry = { 0 };
  GdkWindowHints geom_mask = 0;
  
  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type_gtkwidget,&nsp_geometry_widget,
	      &min_width,  &min_height, &max_width, &max_height,
	      &base_width, &base_height, &width_inc,
	      &height_inc, &min_aspect, &max_aspect)== FAIL) 
    return RET_BUG;
  if ( nsp_geometry_widget != NULL) 
    geometry_widget = GTK_WIDGET(nspgobject_get(nsp_geometry_widget));

  if (min_width >= 0 || min_height >= 0) {
    geometry.min_width = MAX(min_width, 0);
    geometry.min_height = MAX(min_height, 0);
    geom_mask |= GDK_HINT_MIN_SIZE;
  }
  if (max_width >= 0 || max_height >= 0) {
    geometry.max_width = MAX(max_width, 0);
    geometry.max_height = MAX(max_height, 0);
    geom_mask |= GDK_HINT_MAX_SIZE;
  }
  if (base_width >= 0 || base_height >= 0) {
    geometry.base_width = MAX(base_width, 0);
    geometry.base_height = MAX(base_height, 0);
    geom_mask |= GDK_HINT_BASE_SIZE;
  }
  if (width_inc >= 0 || height_inc >= 0) {
    geometry.width_inc = MAX(width_inc, 0);
    geometry.height_inc = MAX(height_inc, 0);
    geom_mask |= GDK_HINT_RESIZE_INC;
  }
  if (min_aspect >= 0.0 || max_aspect >= 0.0) {
    if (min_aspect <= 0.0 || max_aspect <= 0.0) {
      Scierror( "aspect ratios must be positive\n");
      return RET_BUG;
    }
    geometry.min_aspect = min_aspect;
    geometry.max_aspect = max_aspect;
    geom_mask |= GDK_HINT_ASPECT;
  }
  gtk_window_set_geometry_hints(GTK_WINDOW(self->obj), geometry_widget,
				&geometry, geom_mask);
  return 0;
}
%%
override gtk_window_get_position
static int
_wrap_gtk_window_get_position(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint root_x, root_y;

  gtk_window_get_position(GTK_WINDOW(self->obj), &root_x, &root_y);
  if (  nsp_move_doubles(stack,1,1,2,(double) root_x,(double) root_y) == FAIL) 
    return RET_BUG; 
  return 1; 
}
%%
override gtk_window_get_size
static int
_wrap_gtk_window_get_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint width, height;

  gtk_window_get_size(GTK_WINDOW(self->obj), &width, &height);

  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL) 
    return RET_BUG; 
  return 1; 
}
%%
override gtk_window_get_default_size
static int
_wrap_gtk_window_get_default_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint width, height;
  CheckRhs(0,0);
  gtk_window_get_default_size(GTK_WINDOW(self->obj), &width, &height);
  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL) 
    return RET_BUG; 
  return 1; 
}
%%
override gtk_box_query_child_packing kwargs
static int
_wrap_gtk_box_query_child_packing(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end} ;
  /* static char *kwlist[] = { "child", NULL };*/
  NspGObject *pychild;
  GtkWidget *child;
  GList *children;
  gboolean expand, fill;
  guint padding;
  GtkPackType pack_type;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &pychild)== FAIL) return RET_BUG;

  child = GTK_WIDGET(pychild->obj);
  children = gtk_container_get_children(GTK_CONTAINER(self->obj));
  if (g_list_find(children, child) == NULL) {
    Scierror(
	     "first argument must be a child");
    return RET_BUG;
  }
  gtk_box_query_child_packing(GTK_BOX(self->obj),
			      child, &expand, &fill,
			      &padding, &pack_type);
  if (  nsp_move_doubles(stack,1,4,1,(double) expand,(double) fill,(double) padding, (double)pack_type ) == FAIL) 
    return RET_BUG; 
  return 1; 
}
%%
override gtk_combo_set_popdown_strings kwargs
static int
_wrap_gtk_combo_set_popdown_strings(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { smat, t_end} ;
  /* static char *kwlist[] = { "strings", NULL };*/
  NspSMatrix *st;
  GList *glist = NULL;
  int i;
  /* XXXX NspUnicode */
  if (GetArgs(stack,rhs,opt,T, &st )== FAIL ) return RET_BUG;
  
  for (i = 0; i < st->mn ; i++) 
    glist = g_list_append(glist, st->S[i]);
  gtk_combo_set_popdown_strings(GTK_COMBO(self->obj), glist);
  g_list_free(glist);
  return 0;
}
%%
override gtk_curve_get_vector kwargs
static int
_wrap_gtk_curve_get_vector(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "size", NULL };*/
  int size = -1; 
  NspMatrix  *ret;
  CheckRhs(0,1);
  if (rhs == 1) 
    {
      if ( GetScalarInt(stack,1,&size) == FAIL) return RET_BUG; 
    }
  if (size < 0) size = GTK_CURVE(self->obj)->num_points;
  if (( ret= nsp_matrix_create(NVOID,'r',1,size))== NULLMAT) return RET_BUG;
  gtk_curve_get_vector(GTK_CURVE(self->obj), size,(float *) ret->R);
  ret->convert = 'f';
  ret = Mat2double(ret);
  MoveObj(stack,1,(NspObject *) ret);
  return 1;
}
%%
override gtk_curve_set_vector kwargs
static int
_wrap_gtk_curve_set_vector(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {realmat, t_end} ;
  /* static char *kwlist[] = { "vector", NULL };*/
  NspMatrix *v;
  int size=0;
  if (GetArgs(stack,rhs,opt,T, &v) == FAIL) return RET_BUG;
  /* convert v to float XXXXX */
  v = Mat2float(v);
  gtk_curve_set_vector(GTK_CURVE(self->obj), size,(float *) v->R);
  /* back to double */
  v = Mat2double(v);
  return 0;
}
%%
override gtk_tree_model_get_column_type kwargs
/* changed so as to return a NspType */
static int _wrap_gtk_tree_model_get_column_type(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  NspTypeBase *type;
  int_types T[] = {s_int,t_end};
  int index;
  GType ret;
  if ( GetArgs(stack,rhs,opt,T,&index) == FAIL) return RET_BUG;
  ret = gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj), index);
  type = nsp_type_from_gtype(ret);
  if ( type == NULL) return RET_BUG; 
  if ((nsp_ret = (NspObject *) type_create(NVOID,type ,NULL))== NULL) return RET_BUG; 
  MoveObj(stack,1,nsp_ret);
  return 1; 
}

%%
override gtk_tree_model_get_iter kwargs
static int
_wrap_gtk_tree_model_get_iter(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "path", NULL };*/
  int_types T[] = {obj, t_end} ;
  NspObject *nsp_path;
  GtkTreeIter iter;
  GtkTreePath *path;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T,&nsp_path)== FAIL) return RET_BUG;

  path = nsp_gtk_tree_path_from_nspobject(nsp_path);
  if (!path) {
    Scierror( "GtkTreeModel.get_iter requires a tree path as its argument");
    return RET_BUG;
  }
  
  if (gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter, path)) {
    gtk_tree_path_free(path);
    if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL) return RET_BUG;
    MoveObj(stack,1,ret);
    return 1;
  } else {
    gtk_tree_path_free(path);
    Scierror("invalid tree path");
    return RET_BUG;
  }
}
%%
override gtk_tree_model_get_iter_from_string kwargs
static int
_wrap_gtk_tree_model_get_iter_from_string(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end} ;
  /* static char *kwlist[] = { "path_string", NULL };*/
  const gchar *path_string;
  GtkTreeIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &path_string)== FAIL) return RET_BUG;

  if (gtk_tree_model_get_iter_from_string(GTK_TREE_MODEL(self->obj), &iter,
					  path_string)) {
    if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
    MoveObj(stack,1,ret);
    return 1;
  } else {
    Scierror("invalid tree path");
    return RET_BUG;
  }
}
%%
override gtk_tree_model_get_value kwargs
static int
_wrap_gtk_tree_model_get_value(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { obj_check,s_int, t_end} ;
  /* static char *kwlist[] = { "iter", "column", NULL };*/
  NspObject *iter, *ret;
  gint column;
  GValue value = { 0, };

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeiter, &iter, &column)== FAIL) return RET_BUG;
  if (column < 0 ||
      column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
    Scierror("column number is out of range");
    return RET_BUG;
  }

  gtk_tree_model_get_value(GTK_TREE_MODEL(self->obj),
			   nspg_boxed_get(iter, GtkTreeIter), column, &value);
  ret = nspg_value_as_nspobject(&value, TRUE);
  g_value_unset(&value);
  if ( ret == NULLOBJ ) 
    {
      Scierror("Error: get_value method return a NULL Object \n");
      return RET_BUG;
    }
  MoveObj(stack,1,ret);
  return 1;
}
%%
override-slot GtkTreeModel.tp_as_number
/* XXXX */
%%
override-slot GtkTreeModel.tp_as_mapping
static int
_wrap_gtk_tree_model_tp_length(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  return gtk_tree_model_iter_n_children(GTK_TREE_MODEL(self->obj), NULL);
}
static NspObject *
_wrap_gtk_tree_model_tp_getitem(NspGObject *self, NspObject *item)
{
  GtkTreePath *path;
  GtkTreeIter iter;
  NspObject *ret = NULL;

  if (nspg_boxed_check(item, GTK_TYPE_TREE_ITER)) {
    return _nspgtk_tree_model_row_new(GTK_TREE_MODEL(self->obj),
				      nspg_boxed_get(item, GtkTreeIter));
  }

  path = nsp_gtk_tree_path_from_nspobject(item);
  if (!path) {
    Scierror(
	     "could not parse subscript as a tree path");
    return  NULL;
  }
  if (gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter, path)) {
    ret = _nspgtk_tree_model_row_new(GTK_TREE_MODEL(self->obj), &iter);
  } else {
    Scierror( "could not find tree path");
    ret = NULL;
  }
  gtk_tree_path_free(path);
  return ret;
}
static int
_wrap_gtk_tree_model_tp_setitem(NspGObject *self, NspObject *item,
                                NspObject *value)
{
  GtkTreeIter *iter, iter2;

  if (nspg_boxed_check(item, GTK_TYPE_TREE_ITER)) {
    iter = nspg_boxed_get(item, GtkTreeIter);
  } else {
    GtkTreePath *path = nsp_gtk_tree_path_from_nspobject(item);

    if (!path) {
      Scierror(
	       "could not parse subscript as a tree path");
      return  -1;
    }
    if (!gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter2,path)) {
      Scierror( "could not find tree path");
      gtk_tree_path_free(path);
      return RET_BUG;
    }
    iter = &iter2;
    gtk_tree_path_free(path);
  }

  if (value == NULL) {
    if (GTK_IS_LIST_STORE(self->obj)) {
      gtk_list_store_remove(GTK_LIST_STORE(self->obj), iter);
      return 0;
    } else if (GTK_IS_TREE_STORE(self->obj)) {
      gtk_tree_store_remove(GTK_TREE_STORE(self->obj), iter);
      return 0;
    } else {
      Scierror(
	       "don't know how to remove rows "
	       "from this type of tree model");
      return RET_BUG;
    }
  } else {
    return _nspgtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), iter,value);
  }
}
%%
override-slot GtkTreeModel.tp_iter
static int
_wrap_gtk_tree_model_tp_iter(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  return _nspgtk_tree_model_row_iter_new(GTK_TREE_MODEL(self->obj), NULL);
}
%%
override gtk_tree_sortable_get_sort_column_id noargs
static int
_wrap_gtk_tree_sortable_get_sort_column_id(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gboolean ret;
  gint sort_column_id, n=0;
  GtkSortType order;
  
  ret = gtk_tree_sortable_get_sort_column_id(GTK_TREE_SORTABLE(self->obj),
					     &sort_column_id, &order);
  if (ret) n = 2;
  if ( nsp_move_doubles(stack,1,1,n,(double) sort_column_id,(double) order) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_tree_sortable_set_sort_func
static gint
nspgtk_tree_sortable_sort_cb(GtkTreeModel *model, GtkTreeIter *iter1,
			     GtkTreeIter *iter2, gpointer user_data)
{
  NspObject *args[4];
  NspGtkCustomNotify *cunote = user_data;
  NspObject *nsp_ret;
  int nret = 1,nargs = 3;
  gint ret = 0;

  nspg_block_threads();

  args[0] = (NspObject *) gobject_create("model",(GObject *)model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[1] = (NspObject *) gboxed_create("iter1",GTK_TYPE_TREE_ITER, iter1,TRUE, TRUE,nsp_type_gtktreeiter);
  args[2] = (NspObject *) gboxed_create("iter2",GTK_TYPE_TREE_ITER, iter2,TRUE, TRUE,nsp_type_gtktreeiter);
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL ) goto end;
  if (cunote->data) 
    {
      args[3]= cunote->data; 
      nargs= 4;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end;

  if (nret ==1 && IsMat(nsp_ret) && ((NspMatrix *) nsp_ret)->mn==1 && ((NspMatrix *) nsp_ret)->rc_type == 'r' )
    ret =  ((NspMatrix *) nsp_ret)->R[0];
  goto end; 
 end:
  {
    nspg_unblock_threads();
    return ret;
  }
}

static int
_wrap_gtk_tree_sortable_set_sort_func(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint column;
  NspObject *nsp_func, *nsp_arg = NULL;
  NspGtkCustomNotify *cunote; 
  CheckRhs(2,3);
  if ( GetScalarInt(stack,1,&column) == FAIL) return RET_BUG; 
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,2)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 3 ) 
    {
      if (( nsp_arg = (NspObject *) GetListCopy(stack,3)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;
  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(self->obj), column,
				  nspgtk_tree_sortable_sort_cb, cunote,
				  nspgtk_custom_destroy_notify);
  return 0;
}

%%
override gtk_tree_sortable_set_default_sort_func
static int
_wrap_gtk_tree_sortable_set_default_sort_func(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_func, *nsp_arg = NULL;
  NspGtkCustomNotify *cunote; 
  CheckRhs(1,2);
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 2 ) 
    {
      if (( nsp_arg = (NspObject *) GetListCopy(stack,2)) == NULL) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;
  gtk_tree_sortable_set_default_sort_func(GTK_TREE_SORTABLE(self->obj),
					  nspgtk_tree_sortable_sort_cb,
					  cunote,
					  nspgtk_custom_destroy_notify);
  return 0;
}
%%
ignore gtk_list_store_newv
%%
override gtk_list_store_new

static int
_wrap_gtkliststore_new(Stack stack,int rhs,int opt,int lhs)
{
  int flag = TRUE;
  NspObject *ret;
  GObject *gobj;
  CheckRhs(1,2); 
  if ( opt != 0 ) {
    Scierror("GtkListStore do not accept optional named arguments");
    return RET_BUG;
  }

  if (rhs == 2) 
    {
      if ( GetScalarBool(stack,2,&flag) == FAIL) { return FAIL;}
    }

  if ( IsMatObj(stack,1)) 
    {
      /* building a liststore from a Matrix */
      NspMatrix *M;
      if ((M = GetRealMat(stack,1)) == NULLMAT) return RET_BUG;
      /* we build a list store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_list_store_from_mat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsSMatObj(stack,1)) 
    {
      /* building a liststore from a string matrix  */
      NspSMatrix *M;
      if ((M = GetSMat(stack,1)) == NULLSMAT) return RET_BUG;
      /* we build a list store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_list_store_from_smat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsBMatObj(stack,1)) 
    {
      /* building a liststore from a boolean matrix  */
      NspBMatrix *M;
      if ((M = GetBMat(stack,1)) == NULLBMAT) return RET_BUG;
      /* we build a list store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_list_store_from_bmat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsListObj(stack,1)) 
    {
      /* building a liststore from a list */
      NspList *l;
      if ((l = GetList(stack,1)) == NULL) return RET_BUG;
      if ((gobj = (GObject *) nsp_gtk_list_store_from_list(l,flag))== NULL) 
	return RET_BUG;
    }
  else 
    {
      Scierror("%s: firts argument has a wrong type \n",NspFname(stack));
      return RET_BUG;
    }
  if (( ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkliststore))== NULL) 
    return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
%%
ignore gtk_list_store_set_valist gtk_list_store_set_value 
%%
override gtk_list_store_set kwargs
/* Usage: 
 *   set[iter,col,value] 
 *   set[iter,list(...)] 
 *   if list gives mores than one row then the list store is extented 
 *   the iterator if given is not changed 
 */
static int
_wrap_gtk_list_store_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_iter=NULL;GtkTreeIter *p_iter;
  gint column;
  GValue value = { 0 }; NspObject *nsp_value;
  NspList *list;
  CheckRhs(2,3);  
  if (( nsp_iter = (NspObject *) GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
  p_iter = nspg_boxed_get(nsp_iter,GtkTreeIter);
  if ( rhs == 2 ) 
    {
      if ((list = GetList(stack,2))== NULL) return RET_BUG; 
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj),p_iter,NULL,list)== FAIL)
	return RET_BUG;
    }
  else 
    {
      int n_cols = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
      if (GetScalarInt(stack,2,&column) == FAIL) return RET_BUG;
      if ((nsp_value =nsp_get_object(stack,3))== NULLOBJ) return RET_BUG;
      if (column < 0 || column >= n_cols) 
	{
	  Scierror("column number is out of range [0,%d]",n_cols);
	  return RET_BUG; 
	}
      g_value_init(&value,gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),column));
      if (nspg_value_from_nspobject(&value, nsp_value)) {
	Scierror("value (%s) is of the wrong type for column %d\n",nsp_value->type->s_type(),column);
	return RET_BUG;
      }
      gtk_list_store_set_value(GTK_LIST_STORE(self->obj),p_iter,column, &value);
      g_value_unset(&value);
    }
  return 0;
}
%%
ignore gtk_list_store_setv
%%
override gtk_list_store_insert kwargs
static int
_wrap_gtk_list_store_insert(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  gint position;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(1,2);
  if ( GetScalarInt(stack,1,&position)== FAIL) return RET_BUG;
  gtk_list_store_insert(GTK_LIST_STORE(self->obj), &iter, position);

  if ( rhs == 2 ) 
    { 
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if (  nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row)== FAIL) return RET_BUG;
    }

  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL) 
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_list_store_insert_before kwargs
static int
_wrap_gtk_list_store_insert_before(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGtkTreeIter  *sibling;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(1,2);
  if (( sibling = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
  gtk_list_store_insert_before(GTK_LIST_STORE(self->obj), &iter,
			       nspg_boxed_get(sibling, GtkTreeIter));
  if ( rhs == 2) 
    { 
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) ==FAIL) 
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_list_store_insert_after kwargs
static int
_wrap_gtk_list_store_insert_after(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGtkTreeIter  *sibling;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(1,2);
  if (( sibling = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
  gtk_list_store_insert_after(GTK_LIST_STORE(self->obj), &iter,
			       nspg_boxed_get(sibling, GtkTreeIter));
  if ( rhs == 2) 
    { 
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) ==FAIL) 
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_list_store_prepend kwargs
static int
_wrap_gtk_list_store_prepend(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(0,1);
  gtk_list_store_prepend(GTK_LIST_STORE(self->obj), &iter);

  if ( rhs == 1 ) 
    {
      if (( row = GetList(stack,1)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) == FAIL) 
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL) 
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_list_store_append kwargs
static int
_wrap_gtk_list_store_append(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(0,1);
  gtk_list_store_append(GTK_LIST_STORE(self->obj), &iter);
 
  if ( rhs == 1 ) 
    {
      if (( row = GetList(stack,1)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) == FAIL) 
	return RET_BUG;
    }

  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
ignore gtk_tree_store_newv
%%
override gtk_tree_store_new 
/* very similar to liststore : 
 * we build the first level here 
 */
static int
_wrap_gtktreestore_new(Stack stack,int rhs,int opt,int lhs)
{
  int flag = TRUE;
  NspObject *ret;
  GObject *gobj;
  CheckRhs(1,2); 
  if ( opt != 0 ) {
    Scierror("GtkListStore do not accept optional named arguments");
    return RET_BUG;
  }

  if (rhs == 2) 
    {
      if (  GetScalarBool(stack,2,&flag) == FAIL) {return FAIL;}
    }
  if ( IsMatObj(stack,1)) 
    {
      /* building a treestore from a Matrix */
      NspMatrix *M;
      if ((M = GetRealMat(stack,1)) == NULLMAT) return RET_BUG;
      /* we build a tree store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_mat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsSMatObj(stack,1)) 
    {
      /* building a treestore from a string matrix  */
      NspSMatrix *M;
      if ((M = GetSMat(stack,1)) == NULLSMAT) return RET_BUG;
      /* we build a tree store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_smat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsBMatObj(stack,1)) 
    {
      /* building a treestore from a boolean matrix  */
      NspBMatrix *M;
      if ((M = GetBMat(stack,1)) == NULLBMAT) return RET_BUG;
      /* we build a tree store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_bmat(M))== NULL) 
	return RET_BUG;
    }
  else if ( IsListObj(stack,1)) 
    {
      /* building a treestore from a list */
      NspList *l;
      if ((l = GetList(stack,1)) == NULL) return RET_BUG;
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_list(l,flag))== NULL) 
	return RET_BUG;
    }
  else 
    {
      Scierror("%s: firts argument has a wrong type \n",NspFname(stack));
      return RET_BUG;
    }
  if (( ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtktreestore))== NULL) 
    return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
%%
ignore gtk_tree_store_set_valist gtk_tree_store_set_value gtk_tree_store_setv
%%
override gtk_tree_store_set

/* Usage: 
 *   set[iter,col,value] 
 *   set[iter,list(...)] 
 *   if list gives mores than one row then the list store is extented 
 *   the iterator if given is not changed 
 */
static int
_wrap_gtk_tree_store_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGtkTreeIter *nsp_iter=NULL;GtkTreeIter *p_iter;
  gint column;
  GValue value = { 0 }; NspObject *nsp_value;
  NspList *list;
  CheckRhs(2,3);  
  if (( nsp_iter = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
  p_iter = nspg_boxed_get(nsp_iter,GtkTreeIter);
  if ( rhs == 2 ) 
    {
      if ((list = GetList(stack,2))== NULL) return RET_BUG; 
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj),p_iter,NULL,list)== FAIL)
	return RET_BUG;
    }
  else 
    {
      int n_cols = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
      if (GetScalarInt(stack,2,&column) == FAIL) return RET_BUG;
      if ((nsp_value =nsp_get_object(stack,3))== NULLOBJ) return RET_BUG;
      if (column < 0 || column >= n_cols) 
	{
	  Scierror("column number is out of range [0,%d]",n_cols);
	  return RET_BUG; 
	}
      g_value_init(&value,gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),column));
      if (nspg_value_from_nspobject(&value, nsp_value)) {
	Scierror("value (%s) is of the wrong type for column %d\n",nsp_value->type->s_type(),column);
	return RET_BUG;
      }
      gtk_tree_store_set_value(GTK_TREE_STORE(self->obj),p_iter,column, &value);
      g_value_unset(&value);
    }
  return 0;
}
%%
override gtk_tree_store_insert kwargs
static int
_wrap_gtk_tree_store_insert(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter, *parent = NULL;
  gint position;
  NspList *row = NULL;
  NspObject *ret;
  NspGtkTreeIter  *nsp_parent;
  int pos= 0; 
  CheckRhs(1,3);
  if ( IsGtkTreeIterObj(stack,1) ) 
    {
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      pos = 1; 
    }
  CheckRhs(1+pos,2+pos);
  if ( GetScalarInt(stack,pos+1,&position)== FAIL) return RET_BUG;
  gtk_tree_store_insert(GTK_TREE_STORE(self->obj), &iter, parent, position);
  if ( rhs == 2+pos ) 
    { 
      if (( row = GetList(stack,2+pos)) == NULL) return RET_BUG;
      if (  nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row)== FAIL) return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL) 
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_tree_store_insert_before kwargs
static int
_wrap_gtk_tree_store_insert_before(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter  *sibling=NULL,*parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;
  NspGtkTreeIter *nsp_parent,*nsp_sibling;
  int pos=0;

  CheckRhs(1,3);
  if ( IsGtkTreeIterObj(stack,1) ) 
    {
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      pos = 1; 
    }
  CheckRhs(1+pos,2+pos);
  if (( nsp_sibling = GetGtkTreeIter(stack,1+pos))== NULL) return RET_BUG; 
  sibling = nspg_boxed_get(sibling, GtkTreeIter);
  gtk_tree_store_insert_before(GTK_TREE_STORE(self->obj),&iter,parent,sibling);
  if ( rhs == pos+2) 
    { 
      if (( row = GetList(stack,pos+2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL) 
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_tree_store_insert_after kwargs
static int
_wrap_gtk_tree_store_insert_after(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter  *sibling=NULL,*parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret; 
  NspGtkTreeIter *nsp_parent,*nsp_sibling;
  int pos=0;
  CheckRhs(1,3);
  if ( IsGtkTreeIterObj(stack,1) ) 
    {
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      pos = 1; 
    }
  CheckRhs(1+pos,2+pos);
  if (( nsp_sibling = GetGtkTreeIter(stack,1+pos))== NULL) return RET_BUG; 
  sibling = nspg_boxed_get(sibling, GtkTreeIter);
  gtk_tree_store_insert_after(GTK_TREE_STORE(self->obj),&iter,parent,sibling);
  if ( rhs == pos+2) 
    { 
      if (( row = GetList(stack,pos+2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL) 
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_tree_store_prepend kwargs
static int
_wrap_gtk_tree_store_prepend(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter *parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;
  NspGtkTreeIter *nsp_parent;
  
  CheckRhs(0,2);
  switch (rhs) 
    {
    case 0: gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
      break;
    case 1: 
      if ( IsGtkTreeIterObj(stack,1) ) 
	{
	  /* prepend[parent] */
	  if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
	  parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
	  gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
	}
      else 
	{
	  /* prepend[row] */
	  gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
	  if (( row = GetList(stack,1)) == NULL) return RET_BUG;
	  if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL) 
	    return RET_BUG;
	}
      break;
    case 2: 
      /* prepend[parent,row] */
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL) 
	return RET_BUG;
      break;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_tree_store_append kwargs
static int
_wrap_gtk_tree_store_append(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter  *parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret; 
  NspGtkTreeIter *nsp_parent;
  
  CheckRhs(0,2);
  switch (rhs) 
    {
    case 0: gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
      break;
    case 1: 
      if ( IsGtkTreeIterObj(stack,1) ) 
	{
	  /* append a row (tree titer gives the parent position) */
	  if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
	  parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
	  gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
	}
      else 
	{
	  /* append a row at top level  */
	  gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
	  if (( row = GetList(stack,1)) == NULL) return RET_BUG;
	  /* fill the row (or the rows if more than one row data is given) */
	  if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL) 
	    return RET_BUG;
	}
      break;
    case 2: 
      /* append a row (tree iter gives the parent position ) */
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG; 
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
	  /* fill the row (or the rows if more than one row data is given) */
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent,row) ==FAIL) 
	return RET_BUG;
      break;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;

}
%%
override gtk_tree_model_get_iter_first noargs
static int
_wrap_gtk_tree_model_get_iter_first(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  
  if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->obj), &iter))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
	return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  return RET_BUG;
}
%%
override gtk_tree_model_iter_next kwargs
static int
_wrap_gtk_tree_model_iter_next(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end} ;
  int rep;
  /* static char *kwlist[] = { "iter", NULL };*/
  NspObject *nsp_iter;
  GtkTreeIter *iter;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeiter, &nsp_iter)== FAIL) return RET_BUG;
  iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  if ( iter->user_data == NULL) 
    rep = FALSE;
  else
    rep =  gtk_tree_model_iter_next(GTK_TREE_MODEL(self->obj), iter); 
  if ( nsp_move_boolean(stack,1,rep)==FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_tree_model_iter_children kwargs
static int
_wrap_gtk_tree_model_iter_children(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "parent", NULL };*/
  NspGtkTreeIter *nsp_parent;
  GtkTreeIter iter, *parent = NULL;

  if (GetArgs(stack,rhs,opt,T, &nsp_parent) == FAIL) return RET_BUG;
  if (nspg_boxed_check((NspObject *) nsp_parent, GTK_TYPE_TREE_ITER))
    parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
  else {
    Scierror( "parent should be a GtkTreeIter");
    return RET_BUG;
  }

  if (gtk_tree_model_iter_children(GTK_TREE_MODEL(self->obj),
				   &iter, parent))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  else {
    return RET_BUG;
  }
}
%%
override gtk_tree_model_iter_nth_child kwargs
static int
_wrap_gtk_tree_model_iter_nth_child(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int, t_end} ;
  /* static char *kwlist[] = { "parent", "n", NULL };*/
  NspObject *nsp_parent;
  gint n;
  GtkTreeIter iter, *parent = NULL;
  if (GetArgs(stack,rhs,opt,T,&nsp_parent, &n) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_parent, GTK_TYPE_TREE_ITER))
    parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
  else if ( IsNone(nsp_parent))
    parent = NULL;
  else {
    Scierror( "parent should be a GtkTreeIter or None");
    return RET_BUG;
  }

  if (gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(self->obj),
				    &iter, parent, n))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  else 
    return RET_BUG;
}
%%
override gtk_tree_model_iter_parent kwargs
static int
_wrap_gtk_tree_model_iter_parent(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "child", NULL };*/
  NspObject *nsp_child;
  GtkTreeIter iter, *child = NULL;

  if (GetArgs(stack,rhs,opt,T, &nsp_child)== FAIL ) return RET_BUG;
  
  if (nspg_boxed_check(nsp_child, GTK_TYPE_TREE_ITER))
    child = nspg_boxed_get(nsp_child, GtkTreeIter);
  else {
    Scierror( "child should be a GtkTreeIter");
    return RET_BUG;
  }

  if (gtk_tree_model_iter_parent(GTK_TREE_MODEL(self->obj),
				 &iter, child))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  else {
    return RET_BUG;
  }
}
%%
override gtk_tree_model_foreach

static gboolean
nspgtk_tree_foreach_marshal(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter,  gpointer data)
{
  NspObject *args[4];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 1,nargs = 3;
  gboolean ret = FALSE;

  nspg_block_threads();
  /* Il faut ici proteger les args avec des noms et 
   * viter de les construire a chaque itration .... XXXXXX
   */

  args[0] = (NspObject *) gobject_create("model",(GObject *)model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[1] = (NspObject *) gboxed_create("path",GTK_TYPE_TREE_PATH,path,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
  args[2] = (NspObject *) gboxed_create("iter",GTK_TYPE_TREE_ITER, iter,TRUE, TRUE,nsp_type_gtktreeiter);
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL ) goto end;
  if (cunote->data) 
    {
      args[3]= cunote->data; 
      nargs= 4;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end;

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  goto end; 
 end:
  {
    nspg_unblock_threads();
    return ret;
  }
}

static int
_wrap_gtk_tree_model_foreach(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify cunote;

  CheckRhs(1,2); 

  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 2 ) 
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }
  cunote.func = func;
  cunote.data = arg;
  gtk_tree_model_foreach(GTK_TREE_MODEL(self->obj), nspgtk_tree_foreach_marshal, &cunote);
  /* XXXX detecter les erreurs ? */
  return 0;
}
%%
ignore gtk_tree_view_new_with_column
%%
override gtk_tree_view_new noargs
static int
_wrap_gtktreeview_new(Stack stack, int rhs, int opt, int lhs)
{
  NspGObject *nsp_model = NULL;
  GtkTreeModel *model = NULL;
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,1);
  if (rhs == 1) 
    {
      if (( nsp_model = (NspGObject *) GetGtkTreeModel(stack,1)) == NULL) 
	return RET_BUG;
      model = GTK_TREE_MODEL(nsp_model->obj);
      ret = (GObject *)gtk_tree_view_new_with_model(model);
    }
  else 
    {
      ret = (GObject *)gtk_tree_view_new();
    }
  if (ret == NULL) 
    {
      Scierror( "Can't create GtkTreeView");
      return RET_BUG;	
    }

  nsp_type_gtktreeview = new_type_gtktreeview(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktreeview );
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
%%
override gtk_tree_view_get_model noargs
/* I do not want gtk_tree_view_get_model to return a tree model 
 * but a more specific object i.e a liststore or treestore 
 */

static int _wrap_gtk_tree_view_get_model(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *ret;
  NspObject *nsp_ret;
  ret = gtk_tree_view_get_model(GTK_TREE_VIEW(self->obj));
  if ((nsp_ret =(NspObject *) gobject_gettype_and_create(NVOID,(GObject *) ret))==NULLOBJ) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

%%
override gtk_tree_view_get_visible_rect noargs
static int
_wrap_gtk_tree_view_get_visible_rect(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkRectangle visible_rect;

  gtk_tree_view_get_visible_rect(GTK_TREE_VIEW(self->obj), &visible_rect);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE,&visible_rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) 
      == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_tree_view_column_new kwargs
/* gtktreeviewcolumn_new(title="...",renderer=nsp_type_gtkcellrenderer,options= hash)
 * options a hash table of int values 
 */
static int
_wrap_gtktreeviewcolumn_new(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_cell = NULL,*nsp_ret; 
  NspHash *h =NULL;
  GtkTreeViewColumn *tvc;
  gchar *title = NULL; 
  GtkCellRenderer *cell = NULL;

  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"title",string,NULLOBJ,-1}, 
	{"renderer",obj_check,NULLOBJ,-1}, 
	{"attrs",hash,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };

  if (GetArgs(stack,rhs,opt,T, &opts, &title,&nsp_type_gtkcellrenderer,&nsp_cell, &h)== FAIL) 
    return RET_BUG;
  if ( nsp_cell != NULL) cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));
  
  tvc = gtk_tree_view_column_new();
  if (title != NULL )  gtk_tree_view_column_set_title(tvc, title);
  if (cell != NULL )   gtk_tree_view_column_pack_start(tvc, cell, TRUE);
  if (h != NULL) 
    {
      int i;
      for ( i =0 ; i < h->hsize ; i++) 
	{
	  Hash_Entry *loc = ((Hash_Entry *) h->htable) + i;
	  if ( loc->used )
	    {
	      if ( IsMat(loc->data) 
		   && (((NspMatrix *) loc->data)->mn == 1) 
		   && (((NspMatrix *) loc->data)->rc_type == 'r' ))
		gtk_tree_view_column_add_attribute(tvc, cell,nsp_object_get_name(loc->data),
						   ((NspMatrix *) loc->data)->R[0]);
	      else 
		{
		  Scierror("%s: attribute %s should be a real scalar\n",NspFname(stack),nsp_object_get_name(loc->data));
		  return RET_BUG;
		}
	    }
	}
    }

  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *) tvc,(NspTypeBase *) nsp_type_gtktreeviewcolumn );
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
%%
override gtk_tree_view_column_cell_get_size noargs
static int
_wrap_gtk_tree_view_column_cell_get_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int,s_int,s_int,t_end};
  GdkRectangle cell_area;
  gint x_offset, y_offset, width, height;

  gtk_tree_view_column_cell_get_size(GTK_TREE_VIEW_COLUMN(self->obj),
				     &cell_area,
				     &x_offset, &y_offset, &width, &height);

  return RetArgs(stack,lhs,T,
		 (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE,
					     &cell_area,TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle),
		 x_offset, y_offset, width, height);
}
%%
override gtk_tree_view_column_get_cell_renderers noargs
static int
_wrap_gtk_tree_view_column_get_cell_renderers(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  list = gtk_tree_view_column_get_cell_renderers(GTK_TREE_VIEW_COLUMN(self->obj));
  
  NSP_LIST_FROM_GLIST( gobject_gettype_and_create("lel",(GObject *) tmp->data),g_list_free); /* XXXX */
}
%%
override gtk_tree_view_column_set_cell_data_func kwargs
static void
nspgtk_cell_data_func_marshal (GtkTreeViewColumn *tree_column,
			       GtkCellRenderer *cell,
			       GtkTreeModel *tree_model,
			       GtkTreeIter *iter, gpointer data)
{
  NspObject *args[5], *nsp_ret;
  NspGtkCustomNotify *cunote = data;
  int nret = 1,nargs = 4;
  gboolean ret = FALSE;

  g_assert (cunote->func);

  nspg_block_threads();

  args[0] =  (NspObject *) gobject_create("tree_column",(GObject *)tree_column,(NspTypeBase *) nsp_type_gtktreeviewcolumn );
  args[1] = (NspObject *) gobject_create("cell",(GObject *) cell, (NspTypeBase *) nsp_type_gtkcellrenderer);
  args[2] =  (NspObject *) gobject_create("model",(GObject *)tree_model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[3] =  (NspObject *) gboxed_create("iter",GTK_TYPE_TREE_ITER, iter,TRUE, TRUE,(NspTypeBase *)nsp_type_gtktreeiter);
  
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL||args[3]== NULL ) goto end;
  if (cunote->data) 
    {
      args[4]= cunote->data; 
      nargs= 5;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end; 

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  nspg_unblock_threads();
 end: 
  {
    nspg_unblock_threads();
  }
}

static int
_wrap_gtk_tree_view_column_set_cell_data_func (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_func, *nsp_arg = NULL;
  GtkCellRenderer *cell;
  NspGtkCellRenderer *nsp_cell;
  NspGtkCustomNotify *cunote; 
  CheckRhs(2,3);
  if ((nsp_cell = GetGtkCellRenderer(stack,1)) == NULL) return RET_BUG; 
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,2)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 3 ) 
    {
      if (( nsp_arg = (NspObject *) GetListCopy(stack,3)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;

  gtk_tree_view_column_set_cell_data_func (GTK_TREE_VIEW_COLUMN (self->obj), cell,
					   nspgtk_cell_data_func_marshal,
					   cunote,
					   nspgtk_custom_destroy_notify);

  return 0;
}
%%
override gtk_tree_view_insert_column_with_data_func kwargs
static int
_wrap_gtk_tree_view_insert_column_with_data_func (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int position;
  gchar *title;
  NspObject *nsp_cell,*nsp_func, *nsp_arg = NULL;
  GtkCellRenderer *cell;
  NspGtkCustomNotify *cunote;
  gint retval;

  int_types T4[] = {s_int,string,obj_check,obj_check, t_end} ;
  int_types T5[] = {s_int,string,obj_check,obj_check,obj_check,t_end} ;
  
  CheckRhs(4,5) ;
  if ( rhs == 4 ) 
    {
      if (GetArgs(stack,rhs,opt,T4, &position, &title,&nsp_type_gtkcellrenderer,&nsp_cell,&nsp_type_plist, &nsp_func)== FAIL)
	return RET_BUG;
    }
  else
    {
      if (GetArgs(stack,rhs,opt,T5, &position, &title,&nsp_type_gtkcellrenderer,&nsp_cell,&nsp_type_plist, &nsp_func,&nsp_type_list, &nsp_arg)== FAIL)
	return RET_BUG;
    }
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));

  if (( nsp_func =nsp_object_copy(nsp_func)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"func")== FAIL)) return RET_BUG;
  if ( nsp_arg != NULL) 
    {
      if (( nsp_arg =nsp_object_copy(nsp_arg)) == NULL) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"arg")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;

  retval = gtk_tree_view_insert_column_with_data_func (
						       GTK_TREE_VIEW (self->obj),
						       position,
						       title,
						       cell,
						       nspgtk_cell_data_func_marshal,
						       cunote,
						       nspgtk_custom_destroy_notify);
  if ( nsp_move_double(stack,1,(double)retval) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_tree_view_column_set_attributes kwargs
static int
_wrap_gtk_tree_view_column_set_attributes(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspHash *h =NULL;
  GtkCellRenderer *cell;
  NspGtkCellRenderer *nsp_cell;
  gint i = 0;
  
  CheckRhs(2,2) ;
  if ((nsp_cell = GetGtkCellRenderer(stack,1)) == NULL) return RET_BUG; 
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));
  if ((h = GetHash(stack,2)) == NULL) return RET_BUG; 
  gtk_tree_view_column_clear_attributes(GTK_TREE_VIEW_COLUMN(self->obj),cell);

  for ( i =0 ; i < h->hsize ; i++) 
    {
      Hash_Entry *loc = ((Hash_Entry *) h->htable) + i;
      if ( loc->used )
	{
	  if ( IsMat(loc->data) 
	       && (((NspMatrix *) loc->data)->mn == 1) 
	       && (((NspMatrix *) loc->data)->rc_type == 'r' ))
	    gtk_tree_view_column_add_attribute(GTK_TREE_VIEW_COLUMN(self->obj), cell,nsp_object_get_name(loc->data),
					       ((NspMatrix *) loc->data)->R[0]);
	  else 
	    {
	      Scierror("%s: attribute %s should be a real scalar\n",NspFname(stack),nsp_object_get_name(loc->data));
	      return RET_BUG;
	    }
	}
    }
  return 0;
}
%%
override gtk_tree_view_get_path_at_pos kwargs
static int
_wrap_gtk_tree_view_get_path_at_pos(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  int_types ret_T[] = {obj,obj,s_int,s_int, t_end} ;
  gint x, y;
  GtkTreePath *path;
  GtkTreeViewColumn *column;
  gint cell_x, cell_y;
  NspObject *nsp_path,*nsp_column;
  if (GetArgs(stack,rhs,opt,T, &x, &y) == FAIL) return RET_BUG;

  if (gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(self->obj), x, y,
				    &path, &column, &cell_x, &cell_y)) 
    {
      if (path != NULL) 
	nsp_path = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH,path,TRUE,TRUE,
					       (NspTypeBase *) nsp_type_gtktreepath );
      else 
	nsp_path =(NspObject *) nsp_none_create(NVOID,NULL);
      if ( nsp_path == NULL) return RET_BUG; 
      if ((nsp_column =(NspObject *) nspgobject_new(NVOID,(GObject *)column)) == NULL) return RET_BUG; 
      return RetArgs(stack,lhs,ret_T, nsp_path,nsp_column,cell_x,cell_y);
    }
  Scierror("%s: failed to get path\n",NspFname(stack));
  return RET_BUG ;
}
%%
override gtk_tree_view_insert_column_with_attributes kwargs
/* could it be merged with insert column ? XXXX  */ 
static int
_wrap_gtk_tree_view_insert_column_with_attributes(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { s_int,string, obj_check, new_opts,t_end};
  nsp_option opts[] = {
    {"attrs",hash,NULLOBJ,-1},  
    {NULL,t_end,NULLOBJ,-1} };
  
  gint position, columns, real_position;
  GtkTreeViewColumn *column;
  GtkCellRenderer *cell;
  NspObject *nsp_cell,*nsp_ret;
  NspHash *h;
  const char *title;

  if (GetArgs(stack,rhs,opt,T, &position, &title, &nsp_type_gtkcellrenderer,&nsp_cell,&opts,&h) == FAIL)
    return RET_BUG;

  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));

  columns =  gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW(self->obj),
							  position, title, cell,
							  NULL);
  if (position == -1) {
    real_position = columns - 1;
  } else {
    real_position = position;
  }

  column = gtk_tree_view_get_column (GTK_TREE_VIEW(self->obj),  real_position);

  if (h != NULL) 
    {
      int i;
      for ( i =0 ; i < h->hsize ; i++) 
	{
	  Hash_Entry *loc = ((Hash_Entry *) h->htable) + i;
	  if ( loc->used )
	    {
	      if ( IsMat(loc->data) 
		   && (((NspMatrix *) loc->data)->mn == 1) 
		   && (((NspMatrix *) loc->data)->rc_type == 'r' ))
		gtk_tree_view_column_add_attribute(column, cell,nsp_object_get_name(loc->data),
						   ((NspMatrix *) loc->data)->R[0]);
	      else 
		{
		  Scierror("%s: attribute %s should be a real scalar\n",NspFname(stack),nsp_object_get_name(loc->data));
		  return RET_BUG;
		}
	    }
	}
    }
  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)column,(NspTypeBase *) nsp_type_gtktreeviewcolumn );
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
%%
override gtk_tree_view_get_visible_rect noargs
static int
_wrap_gtk_tree_view_get_visible_rect(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkRectangle visible_rect;
  NspObject *ret;
  CheckRhs(1,1);
  gtk_tree_view_get_visible_rect(GTK_TREE_VIEW(self->obj), &visible_rect);

  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &visible_rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle))
      == NULL)  return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_tree_view_get_cell_area kwargs
static int
_wrap_gtk_tree_view_get_cell_area(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end} ;
  /* static char *kwlist[] = { "path", "column", NULL };*/
  NspObject *nsp_path, *ret;
  NspGObject *column;
  GdkRectangle rect;
  GtkTreePath *path;
  
  if (GetArgs(stack,rhs,opt,T, &nsp_path, &nsp_type_gtktreeviewcolumn, &column) == FAIL) return RET_BUG;

  path = nsp_gtk_tree_path_from_nspobject(nsp_path);
  if (!path) {
    Scierror( "could not convert path to a GtkTreePath");
    return RET_BUG;
  }
  gtk_tree_view_get_cell_area(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj), &rect);
  if (path)
    gtk_tree_path_free(path);
    if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle))
	== NULL) 
     return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_tree_view_get_background_area kwargs
static int
_wrap_gtk_tree_view_get_background_area(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end} ;
  /* static char *kwlist[] = { "path", "column", NULL };*/
  NspObject *nsp_path, *ret;
  NspGObject *column;
  GdkRectangle rect;
  GtkTreePath *path;

  if (GetArgs(stack,rhs,opt,T, &nsp_path, &nsp_type_gtktreeviewcolumn, &column)== FAIL) return RET_BUG;

  path = nsp_gtk_tree_path_from_nspobject(nsp_path);
  if (!path) {
    Scierror( "could not convert path to a GtkTreePath");
    return RET_BUG;
  }
  gtk_tree_view_get_background_area(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj), &rect);
  if (path)
    gtk_tree_path_free(path);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL)
     return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_tree_view_widget_to_tree_coords args
static int
_wrap_gtk_tree_view_widget_to_tree_coords(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  gint wx, wy, tx, ty;

  if (GetArgs(stack,rhs,opt,T, &wx, &wy)==  FAIL)
    return RET_BUG;
  gtk_tree_view_widget_to_tree_coords(GTK_TREE_VIEW(self->obj), wx, wy, &tx, &ty);
  if ( nsp_move_doubles(stack,1,1,2,(double) tx,(double) ty) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_tree_view_tree_to_widget_coords args
static int
_wrap_gtk_tree_view_tree_to_widget_coords(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  gint tx, ty, wx, wy;

  if (GetArgs(stack,rhs,opt,T, &tx, &ty)== FAIL)
    return RET_BUG;
  gtk_tree_view_tree_to_widget_coords(GTK_TREE_VIEW(self->obj), tx, ty, &wx, &wy);
  if ( nsp_move_doubles(stack,1,1,2,(double) wx,(double) wy) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_tree_view_get_cursor noargs
static int
_wrap_gtk_tree_view_get_cursor(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list_begin,obj,obj,list_end, t_end} ;
  NspObject *nsp_path;
  NspObject *nsp_column=NULL;
  GtkTreePath *path;
  GtkTreeViewColumn *column;

  gtk_tree_view_get_cursor(GTK_TREE_VIEW(self->obj), &path, &column);

  if (path != NULL) { 
    nsp_path = (NspObject *)nsp_gtk_tree_path_to_nspobject(path);
  } else {
    nsp_path = (NspObject *)nsp_none_create(NVOID,NULL);
  }

  if (column != NULL) {
    nsp_column =(NspObject *) nspgobject_new(NVOID,(GObject*)column);
  } else {
    nsp_path =(NspObject *) nsp_none_create(NVOID,NULL);
  }
  
  return RetArgs(stack,lhs,T,nsp_path,nsp_column);
}
%%
override gtk_tree_view_get_columns noargs
static int
_wrap_gtk_tree_view_get_columns(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  list = gtk_tree_view_get_columns(GTK_TREE_VIEW(self->obj));
  NSP_LIST_FROM_GLIST(gobject_gettype_and_create("lel",G_OBJECT(tmp->data)),g_list_free);
}
%%
override gtk_tree_selection_get_selected noargs
static int
_wrap_gtk_tree_selection_get_selected(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *model;
  GtkTreeIter iter;
  GtkSelectionMode mode;
  NspObject *nsp_ret1,*nsp_ret2=NULL;
  int rep;
  mode = gtk_tree_selection_get_mode(GTK_TREE_SELECTION(self->obj));
  if (mode == GTK_SELECTION_MULTIPLE) {
    Scierror("GtkTreeSelection.get_selected can not be used when selection mode is gtk.SELECTION_MULTIPLE\n");
    return RET_BUG;
  }
  rep = gtk_tree_selection_get_selected(GTK_TREE_SELECTION(self->obj),&model, &iter); 
  if ( rep ) 
    {
      if ((nsp_ret1 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter,TRUE, TRUE,(NspTypeBase *) 
						 nsp_type_gtktreeiter ))==NULL) 
	return RET_BUG; 
      if ( lhs == 2) 
	{
	  if ((nsp_ret2 = (NspObject *) gobject_create(NVOID,(GObject *)model,(NspTypeBase *) nsp_type_gtktreemodel )) 
	      == NULL) 
	    return RET_BUG; 
	}
    }
  else 
    {
      if ((nsp_ret1 = (NspObject *)nsp_none_create(NVOID,NULL)) == NULL) 
	return RET_BUG;
      if ( lhs == 2) 
	{
	  if ((nsp_ret2 = (NspObject *) nsp_none_create(NVOID,NULL)) == NULL) 
	    return RET_BUG; 
	}
    }
  MoveObj(stack,1,nsp_ret1);
  if ( lhs == 2 ) MoveObj(stack,2,nsp_ret2);
  return Max(lhs,1);
}
%%
override gtk_tree_selection_selected_foreach
static void
nspgtk_tree_selection_foreach_marshal(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter,  gpointer data)
{
  NspObject *args[4];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 1,nargs = 3;
  /* gboolean ret = FALSE;*/

  nspg_block_threads();
  /* Il faut ici proteger les args avec des noms et 
   * viter de les construire a chaque itration .... XXXXXX
   */

  args[0] = (NspObject *) gobject_create("model",(GObject *)model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[1] = (NspObject *) gboxed_create("path",GTK_TYPE_TREE_PATH,path,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
  args[2] = (NspObject *) gboxed_create("iter",GTK_TYPE_TREE_ITER, iter,TRUE, TRUE,nsp_type_gtktreeiter);
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL ) goto end;
  if (cunote->data) 
    {
      args[3]= cunote->data; 
      nargs= 4;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end;
  /* 
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  */
  goto end; 
 end:
  {
    nspg_unblock_threads();
    /*return ret;*/
  }
}

static int
_wrap_gtk_tree_selection_selected_foreach(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify cunote;

  CheckRhs(1,2); 

  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 2 ) 
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }
  cunote.func = func;
  cunote.data = arg;
  gtk_tree_selection_selected_foreach(GTK_TREE_SELECTION(self->obj),
				      nspgtk_tree_selection_foreach_marshal,
				      &cunote);
  return 0;
}

%%
override gtk_tree_selection_set_select_function

static gboolean
nspgtk_tree_selection_marshal(GtkTreeSelection *selection,
			      GtkTreeModel *model,
			      GtkTreePath *path,
			      gboolean path_currently_selected,
			      gpointer data)
{
  NspObject *args[2];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 1,nargs = 1;
  gboolean ret = FALSE;

  nspg_block_threads();

  args[0] = (NspObject *) gboxed_create("path",GTK_TYPE_TREE_PATH,path,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
  if ( args[0]== NULL ) goto end;
  if (cunote->data) 
    {
      args[1]= cunote->data; 
      nargs= 2;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end;

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  goto end; 
 end:
  {
    nspg_unblock_threads();
    return ret;
  }
}

static int
_wrap_gtk_tree_selection_set_select_function(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify *cunote;

  CheckRhs(1,2); 

  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 2 ) 
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }

  cunote = g_new0(NspGtkCustomNotify, 1);
  cunote->func = func;
  cunote->data = arg;
  gtk_tree_selection_set_select_function(GTK_TREE_SELECTION(self->obj),
					 nspgtk_tree_selection_marshal,
					 cunote,
					 nspgtk_custom_destroy_notify);
  return 0;
}

%%
override nsp_graphic_new

int _wrap_nsp_graphic_new(Stack stack, int rhs, int opt, int lhs)
{
  int win_id,open_gl=FALSE;
  int_types T[] = {obj_check, obj_check,new_opts,t_end};

  nsp_option opts[] ={{ "dim",mat_int,NULLOBJ,-1},
		      { "opengl", s_bool, NULLOBJ,-1},
		      { "popup_dim",mat_int,NULLOBJ,-1},
		      { "popup_pos",mat_int,NULLOBJ,-1},
		      { "viewport_pos",realmat,NULLOBJ,-1},
		      { "winnum",s_int,NULLOBJ,-1}, 
		      { NULL,t_end,NULLOBJ,-1}};
  int winnum = -1;
  NspMatrix *wdim = NULL, *wpdim = NULL,*viewport = NULL, *wpos = NULL;
  NspGObject *window, *vbox;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &window, &nsp_type_gtkwidget, &vbox,  
	       opts,  &wdim,&open_gl, &wpdim, &wpos, &viewport,&winnum) == FAIL) return RET_BUG;
  if (wdim != NULL) { CheckDims(NspFname(stack),3,wdim,1,2);}
  if (wpdim != NULL){ CheckDims(NspFname(stack),3,wpdim,1,2);}
  if (viewport != NULL) {CheckDims(NspFname(stack),3,viewport,1,2);}
  if (wpos != NULL) {CheckDims(NspFname(stack),3,wpos,1,2);}
#ifdef WITH_GTKGLEXT
  if ( open_gl == TRUE )
    win_id= nsp_graphic_new_gl(GTK_WIDGET(window->obj), GTK_WIDGET(vbox->obj), winnum,
			    (wdim) ? (int*) wdim->R: NULL ,
			    (wpdim) ? (int*)wpdim->R: NULL,
			    (viewport) ? viewport->R : NULL,
			    (wpos) ? (int*)wpos->R : NULL);
  else
#endif 
    win_id= nsp_graphic_new(GTK_WIDGET(window->obj), GTK_WIDGET(vbox->obj), winnum,
			    (wdim) ? (int*) wdim->R: NULL ,
			    (wpdim) ? (int*)wpdim->R: NULL,
			    (viewport) ? viewport->R : NULL,
			    (wpos) ? (int*)wpos->R : NULL);
  if ( nsp_move_doubles(stack,1,1,1,(double) win_id) == FAIL) return RET_BUG; 
  return 1;
}

%%
override gtk_binding_entry_add_signal

static int
_wrap_gtk_binding_entry_add_signal(Stack stack,int rhs,int opt,int lhs)
{

  /*  
      FIXME: to be done 
  NspObject *first;
  gint len, i;
  NspObject *class;
  guint keyval, modifiers;
  gchar *signal_name;
  GType class_type;
  GtkBindingSet *bset = NULL;
  GSList *slist = NULL;
  gchar *errmsg;

  len = NspTuple_Size(args);
  if (len < 4) {
    Scierror( "binding_entry_add_signal requires at least 4 arguments");
    return RET_BUG;
  }
  first = NspSequence_GetSlice(args, 0, 4);
  if (!GetArgs(first, "Oiis:binding_entry_add_signal", &class,
			 &keyval, &modifiers, &signal_name)) {
    Nsp_DECREF(first);
    return RET_BUG;
  }
  Nsp_DECREF(first);

  class_type = nspg_type_from_object(class);
  if (class_type == 0)
    return RET_BUG;

  bset = gtk_binding_set_by_class(gtk_type_class(class_type));

  if ((len-4)%2) {
    Scierror("GtkBindingSet.add_signal requires an even number of parameter pairs following the first four args");
    return RET_BUG;
  }
  for (i=4; i < len; i+=2) {
    NspObject *item;
    GType arg_type;
    GtkBindingArg *arg = NULL;

    item = NspTuple_GET_ITEM(args, i);
    arg_type = nspg_type_from_object(item);
    if (!arg_type) {
      NspErr_Clear();
      Scierror("GtkBindingSet.add_signal parameter types must be int");
      goto arg_error;
    }
    arg = g_new0 (GtkBindingArg, 1);
    slist = g_slist_prepend(slist, arg);

    arg->arg_type = arg_type;
    switch (GTK_FUNDAMENTAL_TYPE(arg->arg_type)) {
    case GTK_TYPE_CHAR:
    case GTK_TYPE_UCHAR:
    case GTK_TYPE_INT:
    case GTK_TYPE_UINT:
    case GTK_TYPE_BOOL:
    case GTK_TYPE_ENUM:
    case GTK_TYPE_FLAGS:
    case GTK_TYPE_LONG:
    case GTK_TYPE_ULONG:
      arg->arg_type = GTK_TYPE_LONG;
      item = NspTuple_GET_ITEM(args, i+1);
      if (!NspInt_Check(item)) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal "
				 "arg[%u] must be int", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      arg->d.long_data = (glong)NspInt_AsLong(item);
      break;
    case GTK_TYPE_FLOAT:
    case GTK_TYPE_DOUBLE:
      arg->arg_type = GTK_TYPE_DOUBLE;
      item = NspTuple_GET_ITEM(args, i+1);
      if (!NspFloat_Check(item)) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal "
				 "arg[%u] must be float", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      arg->d.long_data = (gdouble)NspFloat_AsDouble(item);
      break;
    case GTK_TYPE_STRING:
      arg->arg_type = GTK_TYPE_STRING;
      if (arg->arg_type != GTK_TYPE_IDENTIFIER)
	arg->arg_type = GTK_TYPE_STRING;
      item = NspTuple_GET_ITEM(args, i+1);
      if (!NspString_Check(item)) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
				 "must be non-empty string", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      arg->d.string_data = (gchar*)NspString_AsString(item);
      if (!arg->d.string_data) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
				 "must be non-empty string", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      break;
    default:
      errmsg = g_strdup_printf("GtkBindingSet.add_signal unsupported "
			       "type %10s for arg[%u]",
			       gtk_type_name(arg->arg_type), i+1);
      Scierror( errmsg);
      g_free(errmsg);
      goto arg_error;
    } 
  }

  slist = g_slist_reverse (slist);
  gtk_binding_entry_add_signall (bset, keyval,modifiers, signal_name, slist);
  
  g_slist_foreach(slist, (GFunc)g_free, NULL);
  g_slist_free(slist);

  return 0;
  
 arg_error:
  if (slist) {
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
  }
  return RET_BUG;
  */
  return RET_BUG;
}

/* -------------- haven't updated stuff below this line -------------- */
%%
ignore-glob
_*
*_get_type
gtk_arg_*
gtk_args_*
gtk_draw_*
gtk_gc_*
gtk_init_add_*
gtk_input_add*
gtk_input_remove
gtk_marshal_*
gtk_pattern_*
gtk_quit_add_*
gtk_signal_*
gtk_signal_add_emission_hook*
gtk_signal_connect*
gtk_signal_new*
gtk_target_list_*
gtk_text_view_new
%%
ignore
gtk_binding_set_new
gtk_binding_set_by_class
gtk_binding_set_find
gtk_binding_set_clear
gtk_init
gtk_init_check
gtk_init_abi_check
gtk_init_check_abi_check
gtk_exit
gtk_set_locale
gtk_accel_group_ref
gtk_accel_group_unref
gtk_accel_groups_activate
gtk_accel_group_activate
gtk_accel_group_get_entry
gtk_accel_group_lock_entry
gtk_accel_group_unlock_entry
gtk_accel_group_add
gtk_accel_group_remove
gtk_accel_group_handle_add
gtk_accel_group_handle_remove
gtk_accel_group_create_add
gtk_accel_group_create_remove
gtk_accel_groups_from_object
gtk_accel_group_entries_from_object
gtk_signal_set_funcs
gtk_signal_lookup
gtk_signal_disconnect_by_func
gtk_signal_disconnect_by_data
gtk_signal_handler_block_by_func
gtk_signal_handler_block_by_data
gtk_signal_handler_unblock_by_func
gtk_signal_handler_unblock_by_data
gtk_signal_handler_pending_by_func
gtk_signal_n_emissions
gtk_signal_n_emissions_by_name
gtk_signal_name
gtk_signal_remove_emission_hook
gtk_signal_query
gtk_signal_emit
gtk_signal_emit_by_name
gtk_signal_emitv
gtk_signal_emitv_by_name
gtk_quit_remove_by_data
gtk_idle_remove_by_data
gtk_object_ref
gtk_object_unref
gtk_object_sink
gtk_object_weakref
gtk_object_weakunref
gtk_object_get
gtk_object_getv
gtk_object_set
gtk_object_setv
gtk_object_set_data
gtk_object_set_data_full
gtk_object_get_data
gtk_object_set_user_data
gtk_object_get_user_data
gtk_object_set_data_by_id
gtk_object_set_data_by_id_full
gtk_object_get_data_by_id
gtk_object_remove_data_by_id
gtk_object_remove_no_notify_by_id
gtk_object_arg_set
gtk_object_arg_get
gtk_trace_referencing
gtk_widget_ref
gtk_widget_unref
gtk_widget_get
gtk_widget_getv
gtk_widget_set
gtk_widget_setv
gtk_widget_style_get_valist
gtk_widget_destroyed
gtk_container_get_toplevels
gtk_container_add_child_arg_type
gtk_container_query_child_args
gtk_container_child_args_collect
gtk_container_child_arg_get_info
gtk_container_foreach_full
gtk_container_forall
gtk_container_add_with_args
gtk_container_addv
gtk_container_child_set_valist
gtk_container_child_get_valist
gtk_window_add_embedded_xid
gtk_window_remove_embedded_xid
gtk_range_trough_click
gtk_range_default_htrough_click
gtk_range_default_vtrough_click
gtk_tooltips_data_get
gtk_type_check_object_cast
gtk_type_check_class_cast
gtk_type_register_enum
gtk_type_register_flags
gtk_preview_uninit
gtk_item_factory_create_item
gtk_item_factory_delete_entry
gtk_item_factory_delete_entries
gtk_item_factory_popup_with_data
gtk_item_factory_popup_data
gtk_item_factory_set_translate_func
gtk_item_factory_create_items_ac
gtk_item_factory_create_menu_entries
gtk_menu_bar_append
gtk_menu_bar_insert
gtk_menu_bar_prepend
gtk_menu_append
gtk_menu_insert
gtk_menu_prepend
gtk_radio_menu_item_group
gtk_radio_menu_item_set_group
gtk_radio_button_group
gtk_radio_button_set_group
gtk_entry_new
gtk_entry_select_region
%%
ignore gtk_object_new gtk_object_newv gtk_object_query_args
gtk_object_add_arg_type gtk_object_args_collect gtk_object_arg_get_info
%%
ignore gtk_true gtk_false gtk_key_snooper_install gtk_key_snooper_remove
gtk_get_current_event gtk_get_event_widget gtk_propagate_event
%%
override gtk_main noargs
static int
_wrap_gtk_main(Stack stack,int rhs,int opt,int lhs)
{
  nspg_unblock_threads();
  gtk_main();
  nspg_block_threads();
  return 0;
}
%%
override gtk_main_iteration kwargs
static int
_wrap_gtk_main_iteration(Stack stack,int rhs,int opt,int lhs)
{
  int block = 1, ret;
  CheckRhs(0,1) ; 
  if ( rhs == 1 ) { if (GetScalarInt(stack,1,&block) == FAIL) return RET_BUG; }
  nspg_unblock_threads();
  ret = gtk_main_iteration_do(block);
  nspg_block_threads();
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_main_iteration_do kwargs
static int
_wrap_gtk_main_iteration_do(Stack stack,int rhs,int opt,int lhs)
{
  int block = 1, ret;
  CheckRhs(0,1) ; 
  if ( rhs == 1 ) { if (GetScalarInt(stack,1,&block) == FAIL) return RET_BUG; }
  nspg_unblock_threads();
  ret = gtk_main_iteration_do(block);
  nspg_block_threads();
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG; 
  return 1;
}
%%
ignore gtk_quit_add
/* moved to gpbject */
%%
override gtk_editable_insert_text kwargs

static int _wrap_gtk_editable_insert_text(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,new_opts,t_end};
  nsp_option opts[] = {
    {"position",s_int,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1}};
  char *new_text;
  int new_text_length;
  int position = 0;

  if ( GetArgs(stack,rhs,opt,T, &new_text, opts, &position) == FAIL) return RET_BUG;
  new_text_length= strlen(new_text);
  gtk_editable_insert_text(GTK_EDITABLE(self->obj), new_text,new_text_length , &position);
  if ( nsp_move_double(stack,1,(double)position) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_editable_get_selection_bounds noargs
static int
_wrap_gtk_editable_get_selection_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int start, end,  n= 0;

  if (gtk_editable_get_selection_bounds(GTK_EDITABLE(self->obj), &start, &end)) n = 2;
  if ( nsp_move_doubles(stack,1,1,2,(double) start,(double) end) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_entry_get_layout_offsets noargs
static int
_wrap_gtk_entry_get_layout_offsets(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int x, y;

  gtk_entry_get_layout_offsets(GTK_ENTRY(self->obj), &x, &y);
  if (  nsp_move_doubles(stack,1,1,2,(double) x,(double) y) == FAIL) 
    return RET_BUG; 
  return 1; 
}
%%
override gtk_item_factory_new
static int
_wrap_gtkitemfactory_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string ,string,new_opts,t_end};
  nsp_option opts[] = {
	{"accel_group",obj_check,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  char *path;
  NspGObject *nsp_accel_group = NULL;
  GType container_type;
  char *nsp_container_type;
  GtkAccelGroup *accel_group = NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_container_type, &path, opts,&nsp_type_gtkaccelgroup, &nsp_accel_group) == FAIL) return RET_BUG;
  if ( strcmp(nsp_container_type,"menu_bar") == 0) 
    container_type = GTK_TYPE_MENU_BAR; 
  else if ( strcmp(nsp_container_type,"menu") == 0) 
    container_type = GTK_TYPE_MENU; 
  else if ( strcmp(nsp_container_type,"optio_menu") == 0) 
    container_type = GTK_TYPE_OPTION_MENU; 
  else 
    {
      Scierror("%s: first argument should be \"menu_bar\", \"menu\" or \"optio_menu\"\n",NspFname(stack)); 
      return RET_BUG;
    }
  if ( nsp_accel_group != NULL ) accel_group = GTK_ACCEL_GROUP(nsp_accel_group->obj);

  if ((ret = (GObject *)gtk_item_factory_new(container_type, path, accel_group))== NULL) return RET_BUG;
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkitemfactory))== NULL) 
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
%%
override gtk_item_factory_get_item kwargs
static int _wrap_gtk_item_factory_get_item(NspGtkItemFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  
  int_types T[] = {string,t_end};
  char *path;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
  ret = gtk_item_factory_get_item(GTK_ITEM_FACTORY(self->obj), path);
  if ((nsp_ret = (NspObject *) gobject_gettype_and_create(NVOID,(GObject *)ret))== NULL) 
    return RET_BUG;  
  MoveObj(stack,1,nsp_ret);
  return 1;
}
%%
override gtk_item_factory_get_widget kwargs
static int _wrap_gtk_item_factory_get_widget(NspGtkItemFactory *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *path;
  NspObject *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
  ret = gtk_item_factory_get_widget(GTK_ITEM_FACTORY(self->obj), path);
  if ((nsp_ret = (NspObject *) gobject_gettype_and_create(NVOID,(GObject *)ret))== NULL) 
    return RET_BUG;  
  MoveObj(stack,1,nsp_ret);
  return 1;
}
%%
override gtk_item_factory_create_items kwargs
static void
nspgtk_item_factory_cb(NspGtkCustomNotify *cunote,
		       guint action, GtkWidget *widget)
{
  NspObject *args[3];
  NspObject *nsp_ret;
  int nret = 1,nargs = 2, pos=0;
  nspg_block_threads();
  args[0] = (NspObject *) gobject_gettype_and_create("widget",(GObject *)widget);

  if (cunote->data) 
    {
      args[0]= cunote->data; 
      nargs= 3;
      pos=1;
    }
  args[pos] =  (NspObject *)nsp_create_object_from_double("action",(double) action);
  args[pos+1]= (NspObject *) gobject_gettype_and_create("widget",(GObject *)widget); 
  if (args[0]==NULL|| args[pos]== NULL || args[pos+1]== NULL) goto end; 
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end ;
  /* 
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  */
  goto end; 
 end: 
  {
    nspg_unblock_threads();
    return;
  }
}

static int
_wrap_gtk_item_factory_create_items(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "entries", "callback_data", NULL };*/
  int_types T[] = {list,list, t_end} ;
  NspList *list;
  NspObject  *cb, *cbdata = NULL;
  GtkItemFactoryEntry ent;
  NspObject *extra_data = NULL;
  GtkItemFactory *ifact;
  int i;
  Cell *cloc;

  if (GetArgs(stack,rhs,opt,T, &list, &cbdata)== FAIL) return RET_BUG;

  ifact = GTK_ITEM_FACTORY(self->obj);

  cloc = list->first; 
  i=1;
  while ( cloc != NULLCELL) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  NspGtkCustomNotify *cunote = NULL;
	  NspList *item = (NspList *) cloc->O;
	  memset(&ent, 0, sizeof(ent));
	  cb = NULL;
	  int_types kT[]={ string,string,obj,s_int,string,obj,list_end};
	  if ( !IsList(cloc->O) ) 
	    {
	      Scierror("%s: list element %d has wrong type\n",NspFname(stack),i);
	      return RET_BUG;
	    }

	  if ( GetListArgs(item,1,kT,&(ent.path), &(ent.accelerator),
			   &cb, &(ent.callback_action), &(ent.item_type),
			   &extra_data) == FAIL ) 
	    {
	      Scierror("%s: list element %d should be a list\n",NspFname(stack),i);
	      return RET_BUG;
	    }
	  if ( IsNone(cb )) 
	    {
	      ent.callback = NULL;
	    } 
	  else if (IsNspPList(cb))
	    {
	      if (( cb =nsp_object_copy( cb)) == NULLOBJ ) return RET_BUG;
	      if ((nsp_object_set_name(cb,"callback")== FAIL)) return RET_BUG;
	      /* user_data */
	      if ( cbdata != NULL ) 
		{
		  if ((cbdata =(NspObject *)nsp_list_copy((NspList *)cbdata)) == NULL ) return RET_BUG;
		  if ((nsp_object_set_name((NspObject *)cbdata,"m")== FAIL)) return RET_BUG;
		} 
	      ent.callback = (GtkItemFactoryCallback)nspgtk_item_factory_cb;
	      cunote = g_new0(NspGtkCustomNotify, 1);
	      cunote->func = cb;
	      cunote->data = cbdata;
	    }
	  else 
	    {
	      Scierror("%s: list element %d callback can be None or a function\n",NspFname(stack),i);
	      return RET_BUG;
	    }
	  if ( IsSMat(extra_data) && ((NspSMatrix *) extra_data)->mn == 1)
	    {
	      ent.extra_data = g_strdup(((NspSMatrix *) extra_data)->S[0]);
	    }
	  else if ( IsGdkPixbuf(extra_data)) 
	    {
	      ent.extra_data = GDK_PIXBUF(nspgobject_get(extra_data));
	    }
	  else if ( IsNone(extra_data))
	    {
	      ent.extra_data=NULL;
	    }
	  else 
	    {
	      Scierror("%s: list element %d last argument must be a GdkPixBuf or a string\n",
		       NspFname(stack),i);
	      return RET_BUG;
	    }
	  if (cunote != NULL) {
	    nspg_block_threads();
	    g_object_weak_ref(G_OBJECT(ifact), (GWeakNotify) nspgtk_custom_destroy_notify,  cunote);
	    nspg_unblock_threads();
	  }
	  gtk_item_factory_create_item(ifact, &ent, cunote, 1);
	}
      cloc = cloc->next;
      i++;
    }
  return 0;
}
%%
override gtk_menu_popup kwargs
static void
nspgtk_menu_position(GtkMenu *menu, int *x, int *y, gboolean *push_in,
		     NspObject *func)
{
  NspObject *args[1];
  NspObject *nsp_ret[3];
  int nret = 3,nargs = 2;
  nspg_block_threads();
  args[0] = (NspObject *) gobject_gettype_and_create("menu",(GObject *)menu);
  if (args[0] == NULL) return ;
  if ( nsp_gtk_eval_function((NspPList *)func ,args,nargs,nsp_ret,&nret)== FAIL) 
    goto end ;
  if (nret != 3 ) 
    {
      Scierror("expecting three returned values\n"); 
      goto end;
    }
  else 
    {
      int_types T[]={ s_int,s_int,s_bool,t_end};
      if ( GetFromTable(nsp_ret,T,x,y,push_in) == FAIL) 
	{
	  Scierror("returned values are incorect \n"); 
	  goto end;
	}
    }
 end: 
  {
    nspg_unblock_threads();
    return;
  }
}

static int
_wrap_gtk_menu_popup(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  nsp_option opts[] = {
    {"parent_menu_shell",obj_check,NULLOBJ,-1}, 
    {"parent_menu_item",obj_check,NULLOBJ,-1}, 
    {"func",obj_check,NULLOBJ,-1}, 
    {"button",s_int,NULLOBJ,-1}, 
    {"activate_time",s_int,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };
  int_types T[] = {new_opts, t_end} ;
  /* "parent_menu_shell", "parent_menu_item", "func", "button", "activate_time",  */
  NspGObject *nsp_pms = NULL, *nsp_pmi=NULL;
  GtkWidget *pms = NULL, *pmi = NULL;
  NspObject *func=NULL;
  int button=0, time=-1;
  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type_gtkwidget, &nsp_pms,
	      &nsp_type_gtkwidget,&nsp_pmi,
	      &nsp_type_plist,&func,&button, &time)== FAIL) return RET_BUG;
  if ( nsp_pms != NULL) pms = GTK_WIDGET(nsp_pms->obj);
  if ( nsp_pmi != NULL) pmi = GTK_WIDGET(nsp_pmi->obj);
  if ( func != NULL ) {
    if (( func = (NspObject *)nsp_object_copy(func)) == NULL ) return RET_BUG;
    if ((nsp_object_set_name(func,"f")== FAIL)) return RET_BUG;
    gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
		   (GtkMenuPositionFunc)nspgtk_menu_position,
		   func, button, time);
  } else
    gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);
  return 0;
}
%%
override gtk_pixmap_get noargs
static int
_wrap_gtk_pixmap_get(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_pixmap, *nsp_mask;
  GdkPixmap *pixmap;
  GdkBitmap *mask;
  CheckRhs(0,0); 
  
  gtk_pixmap_get(GTK_PIXMAP(self->obj), &pixmap, &mask);
  if (pixmap == NULL ) 
    {
      Scierror("%s: can't get pixmap\n",NspFname(stack));
      return RET_BUG; 
    }
  if ( lhs == 2) 
    {
      if ( mask == NULL ) 
	{
	  Scierror("%s: can't get mask \n",NspFname(stack));
	  return RET_BUG; 
	}
      nsp_pixmap = (NspObject *) nspgobject_new(NVOID,(GObject *) pixmap);
      nsp_mask = (NspObject *) nspgobject_new(NVOID,(GObject *) mask);
      if ( nsp_pixmap == NULL || nsp_mask == NULL )  return RET_BUG; 
      MoveObj(stack,1,nsp_pixmap);
      MoveObj(stack,2,nsp_mask);
      return 2;
    }
  else 
    {
      nsp_pixmap = (NspObject *) nspgobject_new(NVOID,(GObject *) pixmap);
      if ( nsp_pixmap == NULL )  return RET_BUG; 
      MoveObj(stack,1,nsp_pixmap);
      return 1;
    }
  return 0; 
}
%%
ignore gtk_image_new_from_pixmap gtk_image_new_from_image gtk_image_new_from_file gtk_image_new_from_pixbuf gtk_image_new_from_stock gtk_image_new_from_icon_set gtk_image_new_from_animation
%%
override gtk_image_new 

static char *image_table[] = {  "pixmap", "image", "file",  "pixbuf",  "stock",  "icon_set","animation",NULL};
typedef enum { FROM_pixmap, FROM_image, FROM_file,  FROM_pixbuf,  FROM_stock,  FROM_icon_set,FROM_animation} image_from;

static int _wrap_gtk_image_new_from_pixmap(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string, obj_check, obj_check,t_end};
  NspGObject *pixmap, *mask;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&str,&nsp_type_gdkpixmap, &pixmap, &nsp_type_gdkpixmap, &mask) == FAIL) return RET_BUG;
    ret = gtk_image_new_from_pixmap(GDK_PIXMAP(pixmap->obj), GDK_PIXMAP(mask->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_image(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,obj_check, obj_check,t_end};
  NspGObject *image, *mask;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&str,&nsp_type_gdkimage, &image, &nsp_type_gdkpixmap, &mask) == FAIL) return RET_BUG;
    ret = gtk_image_new_from_image(GDK_IMAGE(image->obj), GDK_PIXMAP(mask->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_file(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,string,t_end};
  char *filename;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&str,&filename) == FAIL) return RET_BUG;
    ret = gtk_image_new_from_file(filename);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_pixbuf(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,obj_check,t_end};
  NspGObject *pixbuf;
  NspObject *nsp_ret;
  GtkWidget *ret;
  if ( rhs == 1 )
    {
      ret = gtk_image_new_from_pixbuf(NULL);
    }
  else 
    {
      if ( GetArgs(stack,rhs,opt,T,&str,&nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
      ret = gtk_image_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
    }
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_stock(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,string, objcopy,t_end};
  char *stock_id;
  GtkIconSize size;
  NspObject *nsp_size = NULL, *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&str,&stock_id, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
    ret = gtk_image_new_from_stock(stock_id, size);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_icon_set(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,obj, objcopy,t_end};
  NspObject *nsp_icon_set, *nsp_size = NULL, *nsp_ret;
  GtkIconSize size;
  GtkWidget *ret;
  GtkIconSet *icon_set = NULL;

  if ( GetArgs(stack,rhs,opt,T,&str,&nsp_icon_set, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_icon_set, GTK_TYPE_ICON_SET))
      icon_set = nspg_boxed_get(nsp_icon_set, GtkIconSet);
  else {
      Scierror( "icon_set should be a GtkIconSet");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
    ret = gtk_image_new_from_icon_set(icon_set, size);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_new_from_animation(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,obj_check,t_end};
  NspGObject *animation;
  NspObject *nsp_ret;
  GtkWidget *ret;

  if ( GetArgs(stack,rhs,opt,T,&str,&nsp_type_gdkpixbufanimation, &animation) == FAIL) return RET_BUG;
    ret = gtk_image_new_from_animation(GDK_PIXBUF_ANIMATION(animation->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtkimage_new(Stack stack, int rhs, int opt, int lhs)
{
  int rep;
  GObject *ret; NspObject *nsp_ret;

  if ( rhs == 0 ) 
    {
      if ((ret = (GObject *)gtk_image_new())== NULL) return RET_BUG;
      nsp_type_gtkimage = new_type_gtkimage(T_BASE);
      nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkimage );
      if ( nsp_ret == NULL) return RET_BUG;
      MoveObj(stack,1,nsp_ret);
      return 1;  
    }
  else 
    {
      if ((rep= GetStringInArray(stack,1,image_table,1)) == -1) return RET_BUG; 
      switch (rep) {
      case FROM_pixmap: return _wrap_gtk_image_new_from_pixmap(stack,rhs,opt,lhs);
      case FROM_image: return _wrap_gtk_image_new_from_image(stack,rhs,opt,lhs);
      case FROM_file:  return _wrap_gtk_image_new_from_file(stack,rhs,opt,lhs);
      case FROM_pixbuf:  return _wrap_gtk_image_new_from_pixbuf(stack,rhs,opt,lhs);
      case FROM_stock:  return _wrap_gtk_image_new_from_stock(stack,rhs,opt,lhs);
      case FROM_icon_set:return _wrap_gtk_image_new_from_icon_set(stack,rhs,opt,lhs);
      case FROM_animation: return _wrap_gtk_image_new_from_animation(stack,rhs,opt,lhs);
      }
    }
  return RET_BUG;;
}

%%
ignore gtk_button_new_with_label gtk_button_new_from_stock gtk_button_new_with_mnemonic
%%
override gtk_button_new kwargs
/* OK */
static int
_wrap_gtkbutton_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"mnemonic",string,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {"stock",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };

  gchar *mnemonic = NULL, *label = NULL, *stock = NULL;

  if (GetArgs(stack,rhs,opt,T, &opts,&mnemonic, &label, &stock) == FAIL)  return RET_BUG;
  if (stock)  
    gobj = (GObject *)gtk_button_new_from_stock(stock);
  else if (mnemonic)
    gobj = (GObject *)gtk_button_new_with_mnemonic(mnemonic);
  else if (label) 
    gobj = (GObject *)gtk_button_new_with_mnemonic(label);
  else 
    gobj = (GObject *)gtk_button_new();
  if (gobj == NULL ) {
    Scierror( "%s: could not create GtkButton object",NspFname(stack));
    return RET_BUG;
  }
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtkbutton))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
%%
override gtk_button_box_get_child_size noargs
static int
_wrap_gtk_button_box_get_child_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint min_width, min_height;
  CheckRhs(0,0);
  gtk_button_box_get_child_size(GTK_BUTTON_BOX(self->obj), &min_width, &min_height);
  if ( nsp_move_doubles(stack,1,1,2,(double) min_width, (double) min_height) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_button_box_get_child_ipadding noargs
static int
_wrap_gtk_button_box_get_child_ipadding(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ipad_x,  ipad_y;
  CheckRhs(0,0);
  gtk_button_box_get_child_ipadding(GTK_BUTTON_BOX(self->obj), &ipad_x, &ipad_y);
  if ( nsp_move_doubles(stack,1,1,2,(double) ipad_x,(double) ipad_y) == FAIL) return RET_BUG; 
  return 1;

}
%%
ignore gtk_toggle_button_new_with_label gtk_toggle_button_new_with_mnemonic
%%
override gtk_toggle_button_new kwargs
/* OK */
static int
_wrap_gtktogglebutton_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"mnemonic",string,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };

  gchar *mnemonic = NULL, *label = NULL;

  if (GetArgs(stack,rhs,opt,T, &opts,&mnemonic, &label) == FAIL)  return RET_BUG;
  if (mnemonic)
    gobj = (GObject *)gtk_toggle_button_new_with_mnemonic(mnemonic);
  else if (label) 
    gobj = (GObject *)gtk_toggle_button_new_with_mnemonic(label);
  else 
    gobj = (GObject *)gtk_button_new();
  if (gobj == NULL ) {
    Scierror( "%s: could not create GtkToggleButton object",NspFname(stack));
    return RET_BUG;
  }
  nsp_type_gtktogglebutton = new_type_gtktogglebutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtktogglebutton))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
%%
ignore gtk_check_button_new_with_label gtk_check_button_new_with_mnemonic
%%
override gtk_check_button_new kwargs
static int
_wrap_gtkcheckbutton_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"mnemonic",string,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };

  gchar *mnemonic = NULL, *label = NULL;

  if (GetArgs(stack,rhs,opt,T, &opts,&mnemonic, &label) == FAIL)  return RET_BUG;
  if (mnemonic)
    gobj = (GObject *)gtk_check_button_new_with_mnemonic(mnemonic);
  else if (label) 
    gobj = (GObject *)gtk_check_button_new_with_mnemonic(label);
  else 
    gobj = (GObject *)gtk_button_new();
  if (gobj == NULL ) {
    Scierror( "%s: could not create GtkToggleButton object",NspFname(stack));
    return RET_BUG;
  }
  nsp_type_gtkcheckbutton = new_type_gtkcheckbutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtkcheckbutton))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
%%
ignore-glob gtk_radio_button_new_*
%%
override gtk_radio_button_new kwargs
static int
_wrap_gtkradiobutton_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  GtkRadioButton *group= NULL;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"group",obj,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };
  NspObject *nsp_group = NULL;
  gchar *label = NULL;
  if (GetArgs(stack,rhs,opt,T, &opts,&nsp_group, &label) == FAIL)  return RET_BUG;

  if ( nsp_group != NULL )
    {
      if (nspgobject_check(nsp_group,nsp_type_gtkradiobutton))
	group = GTK_RADIO_BUTTON(nspgobject_get(nsp_group));
      else {
	Scierror("group argument must be a GtkRadioButton");
	return RET_BUG;
      }
    }
  
  if (label == NULL) {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_button_new(NULL);
    else
      gobj = (GObject *)gtk_radio_button_new_from_widget( group);
  } else {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_button_new_with_mnemonic(NULL,label);
    else
      gobj = (GObject *)gtk_radio_button_new_with_mnemonic_from_widget(group, label);
  }
  if (!gobj) {
    Scierror( "could not create GtkRadioButton object");
    return RET_BUG;
  }
  nsp_type_gtkradiobutton = new_type_gtkradiobutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtkradiobutton))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
%%
override gtk_radio_button_get_group noargs
static int
_wrap_gtk_radio_button_get_group(NspGObject *self,Stack stack,int rhs,int opt,int lhs) {
  NspList *nsp_list;
  GSList *list, *tmp;
  list = gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj));
  NSP_LIST_FROM_GLIST( gobject_gettype_and_create("lel",G_OBJECT(tmp->data)),g_slist_free);
}

%%
ignore gtk_menu_item_new_with_label gtk_menu_item_new_with_mnemonic
%%
override gtk_menu_item_new kwargs
static int
_wrap_gtkmenuitem_new(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  GObject *gobj;
  gchar *text = NULL;

  CheckRhs(0,1);
  if ( rhs == 0 ) 
      gobj = (GObject *)gtk_menu_item_new();
  else
    {
      if ((text = GetString(stack,1))== NULL) return RET_BUG;
      gobj = (GObject *)gtk_menu_item_new_with_mnemonic(text);
    }
  if (gobj == NULL ) {
    Scierror( "could not create GtkMenuItem object");
    return RET_BUG;
  }
  nsp_type_gtkmenuitem = new_type_gtkmenuitem(T_BASE);
  if ((ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkmenuitem))==NULL)
    return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
%%
override gtk_menu_attach_to_widget kwargs

static void
nspgtk_menu_detach (GtkWidget *attach_widget, GtkMenu *menu)
{
  NspObject *func;
  NspObject *args[2];
  int nret = 1,nargs = 2;
  /* gboolean ret = FALSE;*/
  NspObject *nsp_ret;

  if (( func = g_object_get_data (G_OBJECT (menu), "nspgtk_menu_detach_func"))== NULL) return 
											 
  nspg_block_threads();

  args[0] = (NspObject *) gobject_create("menu",(GObject *)menu,(NspTypeBase *) nsp_type_gtkmenu );
  args[1] = (NspObject *) gobject_create("attach",(GObject *)attach_widget,(NspTypeBase *) nsp_type_gtkwidget );
  if ( args[0]== NULL ||args[1]== NULL ) goto end;
  if ( nsp_gtk_eval_function((NspPList *) func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end;
  /* returned value is unused 
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  */
  goto end; 
 end:
  {
    nspg_unblock_threads();
  }
}

static int
_wrap_gtk_menu_attach_to_widget (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /*  */
  int_types T[] = {obj_check, new_opts , t_end} ;
  nsp_option opts[] = {
    {"detach",obj_check,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };

  NspObject *nsp_attach_widget;
  NspPList *detach_func;
  GtkWidget *attach_widget;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &nsp_attach_widget,&opts,&nsp_type_plist,&detach_func) == FAIL)
    return RET_BUG;
  
  attach_widget = GTK_WIDGET (((NspGObject *) nsp_attach_widget)->obj);
  
  if ( detach_func != NULL) 
    {
      if (( detach_func =(NspPList *)nsp_object_copy((NspObject *) detach_func)) == NULLP_PLIST) return RET_BUG;
      if ((nsp_object_set_name((NspObject *)detach_func ,"detach")== FAIL)) return RET_BUG;
      g_object_set_data_full (self->obj,
			      "nspgtk_menu_detach_func",
			      detach_func,
			      nspg_destroy_notify);
    }
  else
    g_object_set_data (self->obj, "nspgtk_menu_detach_func", NULL);

  gtk_menu_attach_to_widget (GTK_MENU (self->obj), attach_widget,
			     (GtkMenuDetachFunc) nspgtk_menu_detach);
  return 0;
}
%%
ignore gtk_check_menu_item_new_with_label gtk_check_menu_item_new_with_mnemonic
%%
override gtk_check_menu_item_new kwargs
static int
_wrap_gtkcheckmenuitem_new(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  GObject *gobj;
  gchar *text = NULL;

  CheckRhs(0,1);
  if ( rhs == 0 ) 
      gobj = (GObject *)gtk_check_menu_item_new();
  else
    {
      if ((text = GetString(stack,1))== NULL) return RET_BUG;
      gobj = (GObject *)gtk_check_menu_item_new_with_mnemonic(text);
    }
  if (gobj == NULL ) {
    Scierror( "could not create GtkCheckMenuItem object");
    return RET_BUG;
  }
  nsp_type_gtkcheckmenuitem = new_type_gtkcheckmenuitem(T_BASE);
  if ((ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkcheckmenuitem))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
%%
ignore gtk_radio_menu_item_new_with_label gtk_radio_menu_item_new_with_mnemonic
%%
override gtk_radio_menu_item_new kwargs
static int
_wrap_gtkradiomenuitem_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  GtkRadioMenuItem *group = NULL;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"group",obj,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };
  NspObject *nsp_group = NULL;
  gchar *text = NULL;
  if (GetArgs(stack,rhs,opt,T, &opts,&nsp_group, &text) == FAIL)  return RET_BUG;

  if ( nsp_group != NULL )
    {
      if (nspgobject_check(nsp_group,nsp_type_gtkradiomenuitem))
	group = GTK_RADIO_MENU_ITEM(nspgobject_get(nsp_group));    
      else {
	Scierror("group argument must be a GtkRadioButton");
	return RET_BUG;
      }
    }

  if (text == NULL) {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_menu_item_new(NULL);
    else
      gobj = (GObject *)gtk_radio_menu_item_new(group->group);
  } else {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_menu_item_new_with_mnemonic(NULL,text);
    else
      gobj = (GObject *)gtk_radio_menu_item_new_with_mnemonic(group->group, text);
  }
  if (gobj == NULL ) {
    Scierror( "could not create GtkRadioMenuItem object");
    return RET_BUG;
  }
  nsp_type_gtkradiomenuitem = new_type_gtkradiomenuitem(T_BASE);
  if ((ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkradiomenuitem))== NULL) return RET_BUG; 
  MoveObj(stack,1,ret);
  return 1; 
}
%%
ignore
gtk_image_menu_item_new_with_label
gtk_image_menu_item_new_from_stock
gtk_image_menu_item_new_with_mnemonic
%%
override gtk_image_menu_item_new kwargs
static int
_wrap_gtkimagemenuitem_new(Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "stock_id", "accel_group", NULL };*/
  NspObject *nsp_ret;
  int_types T[] = {new_opts, t_end} ;
  nsp_option opts[] = {
    {"stock_id",string,NULLOBJ,-1}, 
    {"label",string,NULLOBJ,-1}, 
    {"mnemonic",string,NULLOBJ,-1}, 
    {"accel_group",obj_check,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };
  GObject *gobj;
  gchar *stock_id = NULL;
  gchar *label = NULL;
  gchar *mnemonic = NULL;
  NspObject *nsp_accel_group = NULL;
  GtkAccelGroup *accel_group= NULL;
  
  if (GetArgs(stack,rhs,opt,T,&opts,&stock_id,&label,&mnemonic, 
	      &nsp_type_gtkaccelgroup, &nsp_accel_group)==FAIL)
    return RET_BUG;
  
  if (stock_id)
    gobj = (GObject *)gtk_image_menu_item_new_from_stock(stock_id, accel_group);
  else if ( label ) 
    gobj = (GObject *)gtk_image_menu_item_new_with_label(label) ;
  else if (mnemonic ) 
    gobj = (GObject *)gtk_image_menu_item_new_with_label(label) ;
  else
    gobj = (GObject *)gtk_image_menu_item_new();
  if (gobj==NULL) {
    Scierror( "could not create GtkImageMenuItem object\n");
    return RET_BUG;
  }
  if ((nsp_ret=(NspObject*) gobject_create(NVOID, gobj,(NspTypeBase *) nsp_type_gtkimagemenuitem))==NULL) 
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
%%
override-slot GtkRequisition.tp_as_sequence
/* GtkRequisition.tp_as_sequence XXXXX */
%%
override-attr GtkRequisition.width
static int
_wrap_gtk_requisition__set_width(NspGBoxed *self, char *attr, NspObject *value)
{
  int val;/* XXXXX gint */
  if ( IntScalar(value,&val) == FAIL) return FAIL;
  nspg_boxed_get(self, GtkRequisition)->width = val;
  return OK;
}
%%
override-attr GtkRequisition.height
static int
_wrap_gtk_requisition__set_height(NspGBoxed *self, char *attr, NspObject *value)
{
  int val; /* XXXXX gint */
  if ( IntScalar(value,&val) == FAIL) return FAIL;
  nspg_boxed_get(self, GtkRequisition)->height = val;
  return 0;
}
%%
ignore gtk_tree_remove_items
%%
override gtk_toolbar_append_item kwargs

typedef GtkWidget*  (*gtk_toolbar_f) (GtkToolbar *toolbar,
				      const char *text,
				      const char *tooltip_text,
				      const char *tooltip_private_text,
				      GtkWidget *icon,
				      GtkSignalFunc callback,
				      gpointer user_data);

static int
nsp_gtk_toolbar_item_add_callback_and_return(Stack stack,int flag,GtkWidget *ret,NspPList *callback,NspList *params)
{
  NspObject *nsp_ret=NULL;
  GClosure *closure;
  if ( ret == NULL) 
    {
      Scierror("%s: cannot create iem\n",NspFname(stack));
      return RET_BUG;
    }
  if ( callback != NULL && flag ) 
    {
      /* callback */
      if (( callback =(NspPList *)nsp_object_copy((NspObject *) callback)) == NULLP_PLIST) return RET_BUG;
      if ((nsp_object_set_name((NspObject *) callback,"callback")== FAIL)) return RET_BUG;
      /* user_data */
      if ( params != NULL ) 
	{
	  if (( params =nsp_list_copy(params)) == NULLLIST ) return RET_BUG;
	  if ((nsp_object_set_name((NspObject *)params,"m")== FAIL)) return RET_BUG;
	} 
      closure = nspg_closure_new(callback,params, NULL);
      g_signal_connect_closure(ret, "clicked", closure, FALSE);
      nspgobject_watch_closure(nsp_ret, closure);
    }
  if ((nsp_ret = (NspObject *) gobject_gettype_and_create(NVOID,(GObject *)ret))== NULL) return RET_BUG; 
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_toolbar_prepend_or_append_item(NspGObject *self,Stack stack,int rhs,int opt,int lhs,gtk_toolbar_f func)
{
  /* "text", "tooltip_text", "tooltip_private_text", "icon", "callback", "user_data" */
  nsp_option opts[] = {
    {"text",string,NULLOBJ,-1}, 
    {"tooltip_text",string,NULLOBJ,-1}, 
    {"tooltip_private_text",string,NULLOBJ,-1}, 
    {"icon",obj_check,NULLOBJ,-1}, 
    {"callback",obj_check,NULLOBJ,-1}, 
    {"params",list,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} 
  };
  int_types T[] = {new_opts, t_end} ;

  char *text=NULL, *tooltip_text=NULL, *tooltip_private_text=NULL;
  NspObject *nsp_icon= NULL;
  NspPList *callback=NULL;
  NspList *params=NULL;
  GtkWidget *icon = NULL;
  GtkWidget *ret ;
  
  if (GetArgs(stack,rhs,opt,T,&opts, &text, &tooltip_text, &tooltip_private_text, 
	      &nsp_type_gtkwidget,&nsp_icon,&nsp_type_plist,&callback, &params)  == FAIL) 
    return RET_BUG;;
  if ( nsp_icon != NULL)  icon = GTK_WIDGET(((NspGObject *)nsp_icon)->obj);

  ret = (*func)(GTK_TOOLBAR(self->obj), text, tooltip_text,
		tooltip_private_text, icon, NULL, NULL);
  
  return nsp_gtk_toolbar_item_add_callback_and_return(stack,TRUE,ret,callback,params);
}

static int
_wrap_gtk_toolbar_append_item(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_gtk_toolbar_prepend_or_append_item(self,stack,rhs,opt,lhs,gtk_toolbar_append_item);
}

%%
override gtk_toolbar_prepend_item kwargs

static int
_wrap_gtk_toolbar_prepend_item(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_gtk_toolbar_prepend_or_append_item(self,stack,rhs,opt,lhs,gtk_toolbar_prepend_item);
}
%%
override gtk_toolbar_insert_stock kwargs
static int
_wrap_gtk_toolbar_insert_stock(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* "stock_id", "tooltip_text", "tooltip_private_text", "callback", "user_data", "position" */
  nsp_option opts[] = {
    {"stock_id",string,NULLOBJ,-1}, 
    {"tooltip_text",string,NULLOBJ,-1}, 
    {"tooltip_private_text",string,NULLOBJ,-1}, 
    {"callback",obj_check,NULLOBJ,-1}, 
    {"params",list,NULLOBJ,-1}, 
    {"position",s_int,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} 
  };
  int_types T[] = { new_opts, t_end} ;

  char *stock_id= NULL,*tooltip_text=NULL, *tooltip_private_text=NULL;
  NspPList *callback=NULL;
  NspList *params=NULL;
  GtkWidget *ret;
  int position = -1;
  
  if (GetArgs(stack,rhs,opt,T,&opts, &stock_id, &tooltip_text, &tooltip_private_text, 
	      &nsp_type_plist,&callback, &params,&position)  == FAIL) 
    return RET_BUG;;

  ret = gtk_toolbar_insert_stock(GTK_TOOLBAR(self->obj), stock_id, tooltip_text,
				 tooltip_private_text, NULL, NULL,
				 position);

  return nsp_gtk_toolbar_item_add_callback_and_return(stack,TRUE,ret,callback,params);
}
%%
override gtk_toolbar_append_element kwargs
static int
_wrap_gtk_toolbar_append_element(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* "type", "widget", "text", "tooltip_text","tooltip_private_text", "icon", "callback", "user_data" */

  nsp_option opts[] = {
    {"type",obj,NULLOBJ,-1}, 
    {"widget",obj_check,NULLOBJ,-1}, 
    {"text",string,NULLOBJ,-1}, 
    {"tooltip_text",string,NULLOBJ,-1}, 
    {"tooltip_private_text",string,NULLOBJ,-1}, 
    {"icon",obj_check,NULLOBJ,-1}, 
    {"callback",obj_check,NULLOBJ,-1}, 
    {"params",list,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} 
  };
  int_types T[] = { new_opts, t_end} ;
  int flag;
  char *text=NULL, *tooltip_text=NULL, *tooltip_private_text=NULL;
  NspObject *nsp_icon= NULL,*nsp_type=NULL,*nsp_widget=NULL;
  NspPList *callback=NULL;
  NspList *params=NULL;
  GtkWidget *icon = NULL, *widget=NULL,*ret;
  GtkToolbarChildType type;
  
  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type,&nsp_type_gtkwidget,&nsp_widget, &text, &tooltip_text, &tooltip_private_text, 
	      &nsp_type_gtkwidget,&nsp_icon,&nsp_type_plist,&callback, &params)  == FAIL) 
    return RET_BUG;;

  if ( nsp_icon != NULL)  icon = GTK_WIDGET(((NspGObject *)nsp_icon)->obj);

  if (nspg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,nsp_type,&type))   return RET_BUG;
  widget = GTK_WIDGET(((NspGObject *)nsp_widget)->obj);

  ret = gtk_toolbar_append_element(GTK_TOOLBAR(self->obj), type, widget,
				   text, tooltip_text, tooltip_private_text,
				   icon, NULL, NULL);
  
  flag = (type == GTK_TOOLBAR_CHILD_BUTTON ||
	  type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	  type == GTK_TOOLBAR_CHILD_RADIOBUTTON);

  return nsp_gtk_toolbar_item_add_callback_and_return(stack,flag,ret,callback,params);
}
%%
override gtk_toolbar_prepend_element kwargs
static int
_wrap_gtk_toolbar_prepend_element(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* "type", "widget", "text", "tooltip_text","tooltip_private_text", "icon", "callback", "user_data" */

  nsp_option opts[] = {
    {"type",obj,NULLOBJ,-1}, 
    {"widget",obj_check,NULLOBJ,-1}, 
    {"text",string,NULLOBJ,-1}, 
    {"tooltip_text",string,NULLOBJ,-1}, 
    {"tooltip_private_text",string,NULLOBJ,-1}, 
    {"icon",obj_check,NULLOBJ,-1}, 
    {"callback",obj_check,NULLOBJ,-1}, 
    {"params",list,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} 
  };
  int_types T[] = { new_opts, t_end} ;
  int flag;
  char *text=NULL, *tooltip_text=NULL, *tooltip_private_text=NULL;
  NspObject *nsp_icon= NULL,*nsp_type=NULL,*nsp_widget=NULL;
  NspPList *callback=NULL;
  NspList *params=NULL;
  GtkWidget *icon = NULL, *widget=NULL,*ret;
  GtkToolbarChildType type;
  
  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type,&nsp_type_gtkwidget,&nsp_widget, &text, &tooltip_text, &tooltip_private_text, 
	      &nsp_type_gtkwidget,&nsp_icon,&nsp_type_plist,&callback, &params)  == FAIL) 
    return RET_BUG;;
  
  if ( nsp_icon != NULL)  icon = GTK_WIDGET(((NspGObject *)nsp_icon)->obj);

  if (nspg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,nsp_type, &type))   return RET_BUG;
  widget = GTK_WIDGET(((NspGObject *)nsp_widget)->obj);

  ret = gtk_toolbar_prepend_element(GTK_TOOLBAR(self->obj), type, widget,
				   text, tooltip_text, tooltip_private_text,
				   icon, NULL, NULL);
  
  flag = (type == GTK_TOOLBAR_CHILD_BUTTON ||
	  type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	  type == GTK_TOOLBAR_CHILD_RADIOBUTTON); 

  return nsp_gtk_toolbar_item_add_callback_and_return(stack,flag,ret,callback,params);
}
%%
override gtk_toolbar_insert_element kwargs
static int
_wrap_gtk_toolbar_insert_element(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{

  /* "type", "widget", "text", "tooltip_text", "tooltip_private_text", "icon", "callback","user_data", "position", NULL };*/

  nsp_option opts[] = {
    {"type",obj,NULLOBJ,-1}, 
    {"widget",obj_check,NULLOBJ,-1}, 
    {"text",string,NULLOBJ,-1}, 
    {"tooltip_text",string,NULLOBJ,-1}, 
    {"tooltip_private_text",string,NULLOBJ,-1}, 
    {"icon",obj_check,NULLOBJ,-1}, 
    {"callback",obj_check,NULLOBJ,-1}, 
    {"params",list,NULLOBJ,-1}, 
    {"position",s_int,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} 
  };
  int_types T[] = { new_opts, t_end} ;
  int position =-1;
  int flag;
  char *text=NULL, *tooltip_text=NULL, *tooltip_private_text=NULL;
  NspObject *nsp_icon= NULL,*nsp_type=NULL,*nsp_widget=NULL;
  NspPList *callback=NULL;
  NspList *params=NULL;
  GtkWidget *icon = NULL, *widget=NULL,*ret;
  GtkToolbarChildType type;

  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type,&nsp_type_gtkwidget,&nsp_widget, &text, &tooltip_text, &tooltip_private_text, 
	      &nsp_type_gtkwidget,&nsp_icon,&nsp_type_plist,&callback, &params,&position)  == FAIL) 
    return RET_BUG;;
  
  if ( nsp_icon != NULL)  icon =GTK_WIDGET(((NspGObject *)nsp_icon)->obj);

  if (nspg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,nsp_type, &type))   return RET_BUG;
  widget = GTK_WIDGET(((NspGObject *)nsp_widget)->obj);


  ret = gtk_toolbar_insert_element(GTK_TOOLBAR(self->obj), type, widget,
				   text, tooltip_text, tooltip_private_text,
				   icon, NULL, NULL, position);

  flag = (type == GTK_TOOLBAR_CHILD_BUTTON ||
	  type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	  type == GTK_TOOLBAR_CHILD_RADIOBUTTON); 

  return nsp_gtk_toolbar_item_add_callback_and_return(stack,flag,ret,callback,params);
}
%%
override gtk_notebook_query_tab_label_packing kwargs
static int
_wrap_gtk_notebook_query_tab_label_packing(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end} ;
  /* static char *kwlist[] = { "child", NULL };*/
  NspGObject *child;
  gboolean expand, fill;
  GtkPackType pack_type;
  
  if (GetArgs(stack,rhs,opt,T, &nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;;
  gtk_notebook_query_tab_label_packing(GTK_NOTEBOOK(self->obj),
				       GTK_WIDGET(child->obj),
				       &expand, &fill, &pack_type);
  if ( nsp_move_doubles(stack,1,1,3,(double) expand,(double) fill, (double) pack_type) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_color_selection_get_current_color noargs
static int
_wrap_gtk_color_selection_get_current_color(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  GdkColor colour = { 0, };

  gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(self->obj),	&colour);
  /* XXXXX 
  Scierror("color = [%d,%d],[%d,%d],[%d,%d]\n", 
	   colour.red /256 , colour.red & 0x00ff, 
	   colour.green /256  , colour.green & 0x00ff, 
	   colour.blue /256 , colour.blue & 0x00ff);
  */
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, &colour, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_color_selection_set_current_color
static int 
_wrap_gtk_color_selection_set_current_color(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check ,t_end};
  NspObject *nsp_color;
  GdkColor *color = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkcolor, &nsp_color) == FAIL) return RET_BUG;
  color = nspg_boxed_get(nsp_color, GdkColor);
  /* XXXX */
  color->red |=  (color->red << 8) ;
  color->green |=  (color->green << 8) ;
  color->blue |= (color->blue << 8) ;
  gtk_color_selection_set_current_color(GTK_COLOR_SELECTION(self->obj), color);
  color->red /= 256; 
  color->green /= 256; 
  color->blue /= 256; 
  return 0;
}

%%
override gtk_color_selection_get_previous_color noargs
static int
_wrap_gtk_color_selection_get_previous_color(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkColor colour = { 0, };
  NspObject *ret;
  gtk_color_selection_get_previous_color(GTK_COLOR_SELECTION(self->obj),
					 &colour);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_COLOR, &colour, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor)) == NULL) return RET_BUG;
  colour.red /= 256; 
  colour.green /= 256; 
  colour.blue /= 256; 
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_color_selection_set_previous_color
static int 
_wrap_gtk_color_selection_set_previous_color(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,t_end};
  NspObject *nsp_color;
  GdkColor *color = NULL;

  if ( GetArgs(stack,rhs,opt,T,&nsp_color) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_COLOR))
      color = nspg_boxed_get(nsp_color, GdkColor);
  else {
      Scierror( "color should be a GdkColor");
      return RET_BUG;
  }
  /* XXXX */
  color->red |=  (color->red << 8) ;
  color->green |=  (color->green << 8) ;
  color->blue |= (color->blue << 8) ;
  gtk_color_selection_set_previous_color(GTK_COLOR_SELECTION(self->obj), color);
  color->red /= 256; 
  color->green /= 256; 
  color->blue /= 256; 
  return 0;
}

%%
override gtk_calendar_get_date noargs
static int
_wrap_gtk_calendar_get_date(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  guint year, month, day;

  gtk_calendar_get_date(GTK_CALENDAR(self->obj), &year, &month, &day);
  if ( nsp_move_doubles(stack,1,1,3,(double) year,(double) month,(double) day) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_calendar_is_marked_day
static int _wrap_gtk_calendar_is_marked_day(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,t_end};
  int day, ret;
  if ( GetArgs(stack,rhs,opt,T,&day) == FAIL) return RET_BUG;
  if ( day < 1 || day > 31 ) 
    {
      Scierror("day should be in the range [1,31]\n");
      return RET_BUG;
    }
  ret=  (GTK_CALENDAR (self->obj)->marked_date[day-1] == 1) ;
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}


%%
override gtk_drag_dest_set kwargs

static GtkTargetEntry * nsp_gtk_target_entry_from_list(Stack stack,NspList *list,int *n_targets) 
{
  int i=0;
  GtkTargetEntry *targets;
  Cell *cloc = list->first ; 

  while ( cloc != NULLCELL) {
    if ( cloc->O != NULLOBJ ) i++;
    cloc = cloc->next;
  }
  *n_targets = i; 

  if (( targets = g_new(GtkTargetEntry, *n_targets))== NULL) return targets; 
  i=0;
  cloc = list->first ; 
  while ( cloc != NULLCELL) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  if (! IsList(cloc->O) )
	    {
	      Scierror("%s: list item %d is not a list \n",NspFname(stack),i+1);
	      g_free(targets);
	      return NULL;
	    }
	  else 
	    {
	      NspList *loc = (NspList *)cloc->O; 
	      int_types T[] = { string,s_int,s_int, t_end} ;
	      if ( GetListArgs(loc,i+1,T, &targets[i].target,&targets[i].flags, &targets[i].info)== FAIL) 
		{
		  g_free(targets);
		  return NULL;
		}
	    }
	}
      cloc = cloc->next;
      i++;
    }
  
  return targets; 
}


static int
_wrap_gtk_drag_dest_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,list,obj, t_end} ;
  NspObject *nsp_flags, *nsp_actions;
  NspList *nsp_targets;
  GtkDestDefaults flags;
  GtkTargetEntry *targets;
  GdkDragAction actions;
  gint n_targets;

  if (GetArgs(stack,rhs,opt,T, &nsp_flags, &nsp_targets, &nsp_actions)   == FAIL) return RET_BUG;;
  if (nspg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, nsp_flags, &flags))
        return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION, nsp_actions, &actions))
    return RET_BUG;

  if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets))==NULL) return RET_BUG; 
  gtk_drag_dest_set(GTK_WIDGET(self->obj), flags, targets, n_targets,  actions);
  g_free(targets);
  return 0;
}
%%
override gtk_drag_dest_find_target kwargs
static int
_wrap_gtk_drag_dest_find_target(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,list, t_end} ;
  NspObject *context,*nsp_ret;
  NspList *nsp_target_list;
  gint  n_targets;
  GtkTargetEntry *targets;
  GtkTargetList *target_list;
  GdkAtom atom;

  if (GetArgs(stack,rhs,opt,T, &nsp_type_gdkdragcontext, &context, &nsp_target_list)  == FAIL) 
    return RET_BUG;;

  if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_target_list, &n_targets))==NULL) return RET_BUG; 
  target_list = gtk_target_list_new(targets, n_targets);
  g_free(targets);

  atom = gtk_drag_dest_find_target(GTK_WIDGET(self->obj),
				   GDK_DRAG_CONTEXT(nspgobject_get(context)),
				   target_list);
  gtk_target_list_unref(target_list);
  if ((nsp_ret = (NspObject *) gdkatom_create(NVOID,NULL,atom,NULL))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
%%
override gtk_drag_dest_get_target_list noargs
static int
_wrap_gtk_drag_dest_get_target_list(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTargetList *target_list;
  /* NspObject *ret;
  GList *tmp;
  */

  target_list = gtk_drag_dest_get_target_list(GTK_WIDGET(self->obj));

  if (!target_list) {
    return RET_BUG; 
  }
  /*
  ret = NspList_New(0);
  for (tmp = target_list->list; tmp != NULL; tmp = tmp->next) {
    GtkTargetPair *pair = tmp->data;
    NspObject *item;
    item = Nsp_BuildValue("(Nii)", (NspObject *) gdkatom_create(NVOID,NULL,pair->target,NULL),
			  pair->flags, pair->info);
    NspList_Append(ret, item);
    Nsp_DECREF(item);
  }
  gtk_target_list_unref(target_list);
  return ret;
  */
  Scierror("XXXX To be done gtk_drag_dest_get_target_list");
  return 0;
}
%%
override gtk_drag_dest_set_target_list kwargs
static int
_wrap_gtk_drag_dest_set_target_list(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "target_list", NULL };*/
  int_types T[] = {list, t_end} ;
  NspList *nsp_target_list;
  gint  n_targets;
  GtkTargetEntry *targets;
  GtkTargetList *target_list;

  if (GetArgs(stack,rhs,opt,T, &nsp_target_list) == FAIL) return RET_BUG;;

  if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_target_list, &n_targets))==NULL) return RET_BUG; 
  target_list = gtk_target_list_new(targets, n_targets);
  g_free(targets);
  gtk_drag_dest_set_target_list(GTK_WIDGET(self->obj), target_list);
  gtk_target_list_unref(target_list);
  return 0;
}
%%
override gtk_drag_source_set kwargs
static int
_wrap_gtk_drag_source_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,list,obj, t_end} ;
  NspList  *nsp_targets;
  NspObject *nsp_sbmask, *nsp_actions;
  GdkModifierType sbmask;
  GtkTargetEntry *targets;
  GdkDragAction actions;
  gint n_targets;
  
  if (GetArgs(stack,rhs,opt,T,&nsp_sbmask, &nsp_targets, &nsp_actions) == FAIL) return RET_BUG;;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,  nsp_sbmask,&sbmask))
    return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION,  nsp_actions, &actions))
    return RET_BUG;

  if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets))==NULL) return RET_BUG; 
  gtk_drag_source_set(GTK_WIDGET(self->obj), sbmask, targets, n_targets, actions);
  g_free(targets);
  return 0;
}
%%
override gtk_drag_begin kwargs
static int
_wrap_gtk_drag_begin(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list,obj,s_int, obj_check, t_end} ;
  NspObject  *nsp_actions, *event,*nsp_ret;
  NspList *nsp_targets;
  GtkTargetEntry *tents;
  GtkTargetList *targets;
  GdkDragAction actions;
  gint button, n_targets;
  GdkDragContext *context;
  
  if (GetArgs(stack,rhs,opt,T,&nsp_targets, &nsp_actions, &button,&nsp_type_gdkevent, &event) == FAIL) return RET_BUG;;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION, nsp_actions,&actions))
    return RET_BUG;
  
  if ((tents = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets))==NULL) return RET_BUG; 
  targets = gtk_target_list_new(tents, n_targets);
  g_free(tents);
  context = gtk_drag_begin(GTK_WIDGET(self->obj), targets, actions, button,
			   nspg_boxed_get(event, GdkEvent));
  gtk_target_list_unref(targets);
  if ((nsp_ret = (NspObject *) nspgobject_new(NVOID,(GObject *)context))==NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
%%
ignore
  gtk_drag_source_handle_event gtk_drag_dest_handle_event
  gtk_selection_clear
  gtk_selection_request gtk_selection_notify gtk_selection_property_notify
  gtk_selection_incr_event
%%
override gtk_selection_add_targets kwargs
static int
_wrap_gtk_selection_add_targets(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,list, t_end} ;
  NspObject  *nsp_selection;
  NspList *nsp_targets;
  GtkTargetEntry *targets;
  GdkAtom selection;
  int n_targets;

  if (GetArgs(stack,rhs,opt,T, &nsp_selection, &nsp_targets) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection, &selection)  == FAIL) return RET_BUG;;

  if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets))==NULL) return RET_BUG; 
  gtk_selection_add_targets(GTK_WIDGET(self->obj), selection,  targets, n_targets);
  g_free(targets);
  return 0;
}
%%
ignore gtk_text_iter_free
%%
override gtk_text_iter_copy noargs
static NspObject *
_wrap_gtk_text_iter_copy(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  return (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, nspg_boxed_get(self, GtkTextIter), TRUE, TRUE,NULL);
}
%%
override gtk_text_iter_get_slice kwargs
static int
_wrap_gtk_text_iter_get_slice(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "end", NULL };*/
  /* 
  int_types T[] = {obj, t_end} ;
  NspObject *g_end;
  gchar *text;
  NspObject *pytext;

  if (GetArgs(stack,rhs,opt,T, &g_end)  == FAIL) return RET_BUG;
  if (!nspg_boxed_check(g_end, GTK_TYPE_TEXT_ITER)) {
    Scierror( "end must be a GtkTextIter");
    return RET_BUG;
  }
  text = gtk_text_iter_get_slice(nspg_boxed_get(self, GtkTextIter),
				 nspg_boxed_get(g_end, GtkTextIter));
  pytext = NspUnicode_DecodeUTF8(text, strlen(text), "strict");
  g_free(text);
  MoveObj(stack,1,pytext);
  return 1;
  */
  Scierror("XXXX To be done gtk_text_iter_get_slice");
  return 0;
}
%%
override gtk_text_iter_get_text kwargs
static int
_wrap_gtk_text_iter_get_text(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "end", NULL };*/
  /*
  int_types T[] = {obj, t_end} ;
  NspObject *end;
  gchar *text;
  NspObject *pytext;

  if (GetArgs(stack,rhs,opt,T, &end) == FAIL) return RET_BUG;;
  if (!nspg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
    Scierror( "end must be a GtkTextIter");
    return RET_BUG;
  }
  text = gtk_text_iter_get_text(nspg_boxed_get(self, GtkTextIter),
				nspg_boxed_get(end, GtkTextIter));
  pytext = NspUnicode_DecodeUTF8(text, strlen(text), "strict");
  g_free(text);
  MoveObj(stack,1,pytext);
  return 1;
  */
  Scierror("To be done gtk_text_iter_get_text");
  return 0;
}
%%
override gtk_text_iter_get_visible_slice kwargs
static int
_wrap_gtk_text_iter_get_visible_slice(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "end", NULL };*/
  /*
    int_types T[] = {obj, t_end} ;
    
    NspObject *end;
    gchar *text;
    NspObject *pytext;

    if (GetArgs(stack,rhs,opt,T,&end)  == FAIL) return RET_BUG;;
    if (!nspg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
        Scierror( "end must be a GtkTextIter");
        return RET_BUG;
    }
    text = gtk_text_iter_get_visible_slice(nspg_boxed_get(self, GtkTextIter),
                                           nspg_boxed_get(end, GtkTextIter));
    pytext = NspUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    MoveObj(stack,1,pytext);
    return 1;
  */
  Scierror("To be done gtk_text_iter_get_visible_slice");
  return 0;
}
%%
override gtk_text_iter_get_visible_text kwargs
static int
_wrap_gtk_text_iter_get_visible_text(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
    /* static char *kwlist[] = { "end", NULL };*/

  /*
    int_types T[] = { t_end} ;
    NspObject *end;
    gchar *text;
    NspObject *pytext;

    if (GetArgs(stack,rhs,opt,T,&end)  == FAIL) return RET_BUG;
    if (!nspg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
        Scierror( "end must be a GtkTextIter");
        return RET_BUG;
    }
    text = gtk_text_iter_get_visible_text(nspg_boxed_get(self, GtkTextIter),
                                          nspg_boxed_get(end, GtkTextIter));
    pytext = NspUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    MoveObj(stack,1,pytext);
    return 1;
  */
  Scierror("To be done gtk_text_iter_get_visible_text");
  return 0;
}
%%
override gtk_text_iter_get_marks noargs
static NspObject *
_wrap_gtk_text_iter_get_marks(NspGBoxed *self)
{
  GSList *list, *tmp;
  NspList *nsp_list;
  list = gtk_text_iter_get_marks(nspg_boxed_get(self, GtkTextIter));
  NSP_OBJ_LIST_FROM_GLIST(nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);
}
%%
override gtk_text_iter_get_toggled_tags kwargs
static int
_wrap_gtk_text_iter_get_toggled_tags(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end} ;
  /* static char *kwlist[] = { "toggled_on", NULL };*/
  int toggled_on;
  GSList *list, *tmp;
  NspList *nsp_list;

  if (GetArgs(stack,rhs,opt,T,&toggled_on) == FAIL) return RET_BUG;;
  list = gtk_text_iter_get_toggled_tags(nspg_boxed_get(self, GtkTextIter), toggled_on);
    
  NSP_LIST_FROM_GLIST(gobject_gettype_and_create("lel",(GObject *)tmp->data),g_slist_free);
}
%%
override gtk_text_iter_get_tags noargs
static NspObject *
_wrap_gtk_text_iter_get_tags(NspGBoxed *self)
{
  GSList *list, *tmp;
  NspList *nsp_list;
  list = gtk_text_iter_get_tags(nspg_boxed_get(self, GtkTextIter));
  NSP_OBJ_LIST_FROM_GLIST(nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);
}
%%
override gtk_text_iter_forward_search kwargs
static int
_wrap_gtk_text_iter_forward_search(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "str", "flags", "limit", NULL };*/
  gchar *str;
  NspObject *nsp_limit = NULLOBJ;
  GtkTextIter match_start, match_end, *limit = NULL;
  GtkTextSearchFlags flags;

  CheckRhs(2,3);
  if ( rhs == 2 ) 
    {
      int_types T2[] = { string,s_int,obj, t_end} ;
      if (GetArgs(stack,rhs,opt,T2, &str, &flags) == FAIL) return RET_BUG;;
    }
  else 
    {
      int_types T3[] = { string,s_int, t_end} ;
      if (GetArgs(stack,rhs,opt,T3, &str, &flags, &nsp_limit)     == FAIL) return RET_BUG;;
      if (nspg_boxed_check(nsp_limit, GTK_TYPE_TEXT_ITER))
	limit = nspg_boxed_get(nsp_limit, GtkTextIter);
    }
  if (gtk_text_iter_forward_search(nspg_boxed_get(self, GtkTextIter), str,
				   flags, &match_start, &match_end, limit))
    {
      NspObject *ret; 
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_start,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_end,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,2,ret);
      return 2;
    }
  return 0;
}
%%
override gtk_text_iter_backward_search kwargs
static int
_wrap_gtk_text_iter_backward_search(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "str", "flags", "limit", NULL };*/
  gchar *str;
  NspObject *nsp_limit = NULL;
  GtkTextIter match_start, match_end, *limit = NULL;
  GtkTextSearchFlags flags;

  CheckRhs(2,3);
  if ( rhs == 2 ) 
    {
      int_types T2[] = { string,s_int,obj, t_end} ;
      if (GetArgs(stack,rhs,opt,T2, &str, &flags) == FAIL) return RET_BUG;;
    }
  else 
    {
      int_types T3[] = { string,s_int, t_end} ;
      if (GetArgs(stack,rhs,opt,T3, &str, &flags, &nsp_limit)     == FAIL) return RET_BUG;;
      if (nspg_boxed_check(nsp_limit, GTK_TYPE_TEXT_ITER))
	limit = nspg_boxed_get(nsp_limit, GtkTextIter);
    }
  if (gtk_text_iter_backward_search(nspg_boxed_get(self, GtkTextIter), str,
				    flags, &match_start, &match_end, limit))
    {
      NspObject *ret; 
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_start,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_end,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,2,ret);
      return 2;
    }
  return 0;
}
%%
override gtk_text_buffer_insert_with_tags
static int
_wrap_gtk_text_buffer_insert_with_tags(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject  *nsp_iter;
  gint i,  start_offset;
  gchar *text;
  GtkTextIter *iter, start;

  if (rhs-opt < 1) {
    Scierror("GtkTextBuffer.insert_with_tags_by_name requires at least 1 meth. argument");
    return RET_BUG;
  }

  if (( nsp_iter = (NspObject *) GetGtkTextIter(stack,1)) == NULL) return RET_BUG; 
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);

  if ( rhs >= 2) 
    {
      if (( text = GetString(stack,2))== NULL) return RET_BUG; 
      start_offset = gtk_text_iter_get_offset(iter);
      gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text));
      gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj), &start, start_offset);
    }
  for (i = 3; i <= rhs ; i++) 
    {
      GtkTextTag *tag;
      if (( tag = (GtkTextTag *) GetGtkTextTag(stack,i))== NULL) return RET_BUG; 
      gtk_text_buffer_apply_tag(GTK_TEXT_BUFFER(self->obj),tag, &start, iter);
    }
  return 0;
}
%%
override gtk_text_buffer_insert_with_tags_by_name
static int
_wrap_gtk_text_buffer_insert_with_tags_by_name(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject  *nsp_iter;
  gint  i, start_offset;
  gchar *text;
  GtkTextIter *iter, start;

  if (rhs-opt < 1) {
    Scierror("GtkTextBuffer.insert_with_tags_by_name requires at least 1 meth. argument");
    return RET_BUG;
  }

  if (( nsp_iter =(NspObject *)  GetGtkTextIter(stack,1)) == NULL) return RET_BUG; 
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);

  if ( rhs >= 2) 
    {
      if (( text = GetString(stack,2))== NULL) return RET_BUG; 
      start_offset = gtk_text_iter_get_offset(iter);
      gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text));
      gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj), &start, start_offset);
    }
  for (i = 3; i <= rhs ; i++) 
    {
      char *tagname;
      if (( tagname = GetString(stack,i))== NULL) return RET_BUG; 
      gtk_text_buffer_apply_tag_by_name(GTK_TEXT_BUFFER(self->obj),tagname, &start, iter);
    }
  return 0;
}
%%
override gtk_text_buffer_create_tag kwargs
static int
_wrap_gtk_text_buffer_create_tag(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int i;
  gchar *tag_name = NULL;
  GtkTextTag *tag;
  GtkTextTagTable *table;
  NspObject *ret;

  if ( rhs -opt != 1 ) 
    {
      Scierror("Expecting a tag name followed by optional named arguments\n");
      return RET_BUG;
    }

  if (( tag_name = GetString(stack,1))== NULL) return RET_BUG;
  table = GTK_TEXT_TAG_TABLE(GTK_TEXT_BUFFER(self->obj)->tag_table);
  if ( table && g_hash_table_lookup(table->hash, tag_name)) {
    Scierror("A tag named '%s' is already in the tag table", tag_name);
    return RET_BUG;
  }
  
  tag = gtk_text_buffer_create_tag(GTK_TEXT_BUFFER(self->obj), tag_name, NULL);

  for ( i = rhs -opt + 1; i <= rhs ; i++) 
    {
      /* set tag properties if any */
      NspObject *prop = NthObj(i) ;
      GParamSpec *pspec;
      GValue value = { 0, };
      gchar *prop_str =nsp_object_get_name(NthObj(i)); 
      
      pspec = g_object_class_find_property (G_OBJECT_GET_CLASS(tag),  prop_str);
      if (!pspec) {
	Scierror( "unsupported tag property `%s'", prop_str);
	/* XXX: Free tag? */
	return RET_BUG;
      }
      g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
      if (nspg_value_from_nspobject(&value, prop) < 0) {
	Scierror( "could not convert tag property '%s' to correct type",  prop_str);
	/* XXX: Free tag? */
	return RET_BUG;
      }
      g_object_set_property((GObject *)tag, prop_str, &value);
      g_value_unset(&value);
    }
  if ((ret = (NspObject *) gobject_create(NVOID,(GObject *)tag,(NspTypeBase *) nsp_type_gtktexttag))== NULL) 
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_text_buffer_get_iter_at_line_offset kwargs
static int
_wrap_gtk_text_buffer_get_iter_at_line_offset(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "line_number", "char_offset", NULL };*/
  GtkTextIter iter;
  int line_number, char_offset;
  NspObject *ret;
  
  if (GetArgs(stack,rhs,opt,T, &line_number, &char_offset) == FAIL) return RET_BUG;;

  gtk_text_buffer_get_iter_at_line_offset(GTK_TEXT_BUFFER(self->obj), &iter, line_number, char_offset);
  if ((ret =(NspObject *)  gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_text_buffer_get_iter_at_line_index kwargs
static int
_wrap_gtk_text_buffer_get_iter_at_line_index(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "line_number", "byte_offset", NULL };*/
  GtkTextIter iter;
  int line_number, byte_offset;
  NspObject *ret;
  
  if (GetArgs(stack,rhs,opt,T,&line_number, &byte_offset)  == FAIL) return RET_BUG;;
  
  gtk_text_buffer_get_iter_at_line_index(GTK_TEXT_BUFFER(self->obj), &iter, line_number, byte_offset);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_text_buffer_get_iter_at_offset kwargs
static int
_wrap_gtk_text_buffer_get_iter_at_offset(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int char_offset;
  int_types T[] = {s_int, t_end} ;
  GtkTextIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &char_offset) == FAIL) return RET_BUG;;
  gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),  &iter, char_offset);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) 
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_text_buffer_get_iter_at_line kwargs
static int
_wrap_gtk_text_buffer_get_iter_at_line(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int line_number;
  int_types T[] = {s_int, t_end} ;
  GtkTextIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &line_number) == FAIL) return RET_BUG;;
  gtk_text_buffer_get_iter_at_line(GTK_TEXT_BUFFER(self->obj), &iter, line_number);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_text_buffer_get_start_iter noargs
static int
_wrap_gtk_text_buffer_get_start_iter(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextIter iter;
  NspObject *ret;
  gtk_text_buffer_get_start_iter(GTK_TEXT_BUFFER(self->obj), &iter);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_text_buffer_get_end_iter noargs
static int
_wrap_gtk_text_buffer_get_end_iter(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextIter iter;
  NspObject *ret;
  gtk_text_buffer_get_end_iter(GTK_TEXT_BUFFER(self->obj), &iter);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_text_buffer_get_bounds noargs
static int
_wrap_gtk_text_buffer_get_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret1,*ret2; 
  GtkTextIter start, end;
  CheckRhs(1,1);
  CheckLhs(2,2);
  gtk_text_buffer_get_bounds(GTK_TEXT_BUFFER(self->obj), &start, &end);
  if ((ret1 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &start,TRUE, TRUE,nsp_type_gtktextiter))== NULL) 
    return RET_BUG; 
  MoveObj(stack,1,ret1);
  if ((ret2 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &end,TRUE, TRUE,nsp_type_gtktextiter))==NULL) 
    return RET_BUG; 
  MoveObj(stack,2,ret2);
  return 2;
}
%%
override gtk_text_buffer_get_iter_at_mark kwargs
static int
_wrap_gtk_text_buffer_get_iter_at_mark(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *mark;
  int_types T[] = {obj_check, t_end} ;
  GtkTextIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark) == FAIL) return RET_BUG;;
  gtk_text_buffer_get_iter_at_mark(GTK_TEXT_BUFFER(self->obj), &iter, GTK_TEXT_MARK(mark->obj));
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_text_buffer_set_text kwargs
static int
_wrap_gtk_text_buffer_set_text(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  char *text;
  int_types T[] = { string, t_end} ;
  if (GetArgs(stack,rhs,opt,T, &text) == FAIL) return RET_BUG;
  gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->obj), text, strlen(text));
  return 0;
}
%%
override gtk_text_buffer_get_selection_bounds noargs
static int
_wrap_gtk_text_buffer_get_selection_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret1,*ret2; 
  GtkTextIter start, end;
  CheckRhs(1,1);
  CheckLhs(2,2);
  if (!gtk_text_buffer_get_selection_bounds(GTK_TEXT_BUFFER(self->obj),&start, &end)) 
    return RET_BUG; 
  if ((ret1 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &start,TRUE, TRUE,nsp_type_gtktextiter))== NULL) 
    return RET_BUG; 
  MoveObj(stack,1,ret1);
  if ((ret2 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &end,TRUE, TRUE,nsp_type_gtktextiter))==NULL) 
    return RET_BUG; 
  MoveObj(stack,1,ret2);
  return 2;
}
%%
override gtk_text_buffer_insert kwargs
static int
_wrap_gtk_text_buffer_insert(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check , string, t_end} ;
  NspObject *nsp_iter;
  char *text;
  GtkTextIter *iter = NULL;
  
  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter,  &nsp_iter, &text)  == FAIL) return RET_BUG;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text));
  return 0;
}
%%
override gtk_text_buffer_insert_at_cursor kwargs
static int
_wrap_gtk_text_buffer_insert_at_cursor(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { string, t_end} ;
  char *text;

  if (GetArgs(stack,rhs,opt,T, &text)  == FAIL) return RET_BUG;
  gtk_text_buffer_insert_at_cursor(GTK_TEXT_BUFFER(self->obj), text,strlen(text));
  return 0;
}
%%
override gtk_text_buffer_insert_interactive kwargs
static int
_wrap_gtk_text_buffer_insert_interactive(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check ,string,s_bool, t_end} ;
  /* static char *kwlist[] = { "iter", "text", "default_editable", NULL };*/
  NspObject *nsp_iter;
  char *text;
  int len, default_editable, ret;
  GtkTextIter *iter = NULL;
  
  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter,&nsp_iter, &text, &default_editable) == FAIL) return RET_BUG;;
  len = strlen(text);
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  ret = gtk_text_buffer_insert_interactive(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text), default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_text_buffer_insert_interactive_at_cursor kwargs
static int
_wrap_gtk_text_buffer_insert_interactive_at_cursor(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_bool, t_end} ;
  char *text;
  int  default_editable, ret;
  if (GetArgs(stack,rhs,opt,T, &text, &default_editable) ==  FAIL) return RET_BUG;;
  ret = gtk_text_buffer_insert_interactive_at_cursor(GTK_TEXT_BUFFER(self->obj), text,strlen(text), default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_text_child_anchor_get_widgets noargs
static int
_wrap_gtk_text_child_anchor_get_widgets(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  list = gtk_text_child_anchor_get_widgets(GTK_TEXT_CHILD_ANCHOR(self->obj));
  NSP_LIST_FROM_GLIST(gobject_gettype_and_create("lel",(GObject *)tmp->data),g_list_free);
}
%%
override gtk_text_view_get_visible_rect noargs
static int
_wrap_gtk_text_view_get_visible_rect(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkRectangle visible_rect;
  NspObject *ret;

  gtk_text_view_get_visible_rect(GTK_TEXT_VIEW(self->obj), &visible_rect);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &visible_rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_text_view_buffer_to_window_coords kwargs
static int
_wrap_gtk_text_view_buffer_to_window_coords(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "win", "buffer_x", "buffer_y", NULL };*/
  GtkTextWindowType win;
  gint buffer_x, buffer_y, window_x = 0, window_y = 0;
  NspObject *nsp_win;
  
  if (GetArgs(stack,rhs,opt,T, &nsp_win, &buffer_x, &buffer_y) == FAIL) return RET_BUG;;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_win,&win))
    return RET_BUG;
  gtk_text_view_buffer_to_window_coords(GTK_TEXT_VIEW(self->obj), win,
					buffer_x, buffer_y,
					&window_x, &window_y);
  if ( nsp_move_doubles(stack,1,1,2,(double) window_x,(double) window_y) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_text_view_window_to_buffer_coords kwargs
static int
_wrap_gtk_text_view_window_to_buffer_coords(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "win", "window_x", "window_y", NULL };*/
  GtkTextWindowType win;
  gint window_x, window_y, buffer_x = 0, buffer_y = 0;
  NspObject *nsp_win;
    
  if (GetArgs(stack,rhs,opt,T, &nsp_win, &window_x, &window_y) == FAIL) return RET_BUG;;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_win,&win))
    return RET_BUG;
  gtk_text_view_window_to_buffer_coords(GTK_TEXT_VIEW(self->obj), win,
					window_x, window_y,
					&buffer_x, &buffer_y);
  if ( nsp_move_doubles(stack,1,1,2,(double) buffer_x,(double) buffer_y) == FAIL) return RET_BUG; 
  return 1;
}
%%
ignore gtk_dialog_new_with_buttons
%%
override gtk_dialog_new kwargs

/* gtk_dialog_new gtk_dialog_new_with_buttons are mixed here */ 
static int
_wrap_gtkdialog_new(Stack stack,int rhs,int opt,int lhs)
{
  gchar *title = NULL;
  NspGObject *nsp_window = NULL;
  GObject *ret;
  NspSMatrix *nsp_buttons = NULL;
  NspObject *nsp_ret;
  GtkDialogFlags flags = 0;
  int i;
  
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"title",string,NULLOBJ,-1}, 
    {"parent",obj,NULLOBJ,-1}, 
    {"flags",s_int,NULLOBJ,-1}, 
    {"buttons",smat,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };
  
  if (GetArgs(stack,rhs,opt,T,&opts, &title, &nsp_window, &flags, &nsp_buttons)== FAIL) return RET_BUG; 
  
  if ( nsp_window != NULL && ! nspgobject_check(nsp_window, nsp_type_gtkwindow)) {
    Scierror("window must be a GtkWindow");
    return RET_BUG;
  }
  ret =(GObject *)  gtk_dialog_new_with_buttons(title, (nsp_window != NULL) ? GTK_WINDOW(nsp_window->obj) : NULL,
						flags, NULL);
  if ( ret == NULL) {
    Scierror("could not create GtkDialog object");
    return RET_BUG;
  }
  if ( nsp_buttons != NULL) 
    {
      for (i = 0; i < nsp_buttons->mn ; i ++) 
	{
	  gtk_dialog_add_button(GTK_DIALOG(ret), nsp_buttons->S[i],i+1);
	}
    }
  nspg_block_threads();
  nsp_type_gtkdialog = new_type_gtkdialog(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *) ret,(NspTypeBase *) nsp_type_gtkdialog))== NULL)
    return RET_BUG; 
  nspg_unblock_threads();
  MoveObj(stack,1,nsp_ret);
  return 1;
}
%%
override gtk_dialog_run noargs
static int
_wrap_gtk_dialog_run(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint retval;
  
  nspg_unblock_threads();
  retval = gtk_dialog_run(GTK_DIALOG(self->obj));
  nspg_block_threads();
  if ( nsp_move_double(stack,1,(double)retval) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_message_dialog_new kwargs
/* XXXXX accepter une matrice pour message a concatener */ 
static int
_wrap_gtkmessagedialog_new(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GObject *gobj;
  GtkButtonsType buttons = GTK_BUTTONS_NONE;
  int_types T[] = {new_opts, t_end} ;
  nsp_option opts[] = {
    {"parent",obj_check,NULLOBJ,-1}, 
    {"flags",obj,NULLOBJ,-1}, 
    {"type",obj,NULLOBJ,-1}, 
    {"buttons",obj,NULLOBJ,-1}, 
    {"message",string,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };

  /* static char *kwlist[] = { "parent", "flags", "type", "buttons", "message_format", NULL };*/
  NspObject *nsp_flags = NULL, *nsp_type = NULL, *nsp_buttons = NULL;
  GtkDialogFlags flags = 0;
  GtkWindow *parent = NULL;
  GtkMessageType type = GTK_MESSAGE_INFO;
  NspGObject *nsp_parent = NULL;
  char *message_format = NULL;

  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type_gtkwindow, &nsp_parent, &nsp_flags, &nsp_type, &nsp_buttons, &message_format)== FAIL)
    return RET_BUG;
  if ( nsp_parent != NULL) parent = GTK_WINDOW(nsp_parent->obj);
  if (nspg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, nsp_flags, &flags))
    return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_MESSAGE_TYPE, nsp_type,&type))
    return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_BUTTONS_TYPE, nsp_buttons, &buttons))
    return RET_BUG;
  
  gobj = (GObject *)gtk_message_dialog_new(parent, flags, type, buttons, "%s", message_format);
  if (gobj == NULL ) {
        Scierror( "could not create GtkMessageDialog object");
        return RET_BUG;
    }

  if ((nsp_ret = (NspObject *) gobject_create(NVOID, gobj,(NspTypeBase *) nsp_type_gtkmessagedialog))== NULL) 
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

%%
override gtk_rc_set_default_files kwargs
static int
_wrap_gtk_rc_set_default_files(Stack stack,int rhs,int opt,int lhs)
{
  NspSMatrix *nsp_filenames = NULL;
  CheckRhs(0,1);
  if ( rhs == 1) 
    {
      if (( nsp_filenames = GetSMat(stack,1))==NULL) return RET_BUG;
      gtk_rc_set_default_files(nsp_filenames->S);
    }
  return 0;
}
%%
override gtk_rc_get_default_files noargs
static int
_wrap_gtk_rc_get_default_files(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  char **filenames = gtk_rc_get_default_files();
  if (( ret = (NspObject *)nsp_smatrix_create_from_table(filenames))== NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_icon_set_new_from_pixbuf kwargs 
/* XXXXX ce qui suit devrait etre dans icon_set_new */ 
static int
_wrap_gtk_icon_set_new_from_pixbuf(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkIconSet *ret;
  NspGObject *pixbuf = NULL;
  CheckRhs(0,1);
  CheckLhs(1,1); 
  if ( rhs == 1) 
    {
      if ((pixbuf = GetGObject(stack,1)) == NULL) return RET_BUG; 
      if ( !nspgobject_check(pixbuf,(NspTypeBase *) nsp_type_gdkpixbuf)) { 
        Scierror("first argument should be a GdkPixbuf");
        return RET_BUG;
      }
    }
  if (pixbuf)
    ret =  gtk_icon_set_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
  else
    ret =  gtk_icon_set_new();
  if ( ret == NULL ) 
    {
      Scierror("could not create GtkIconSet object");
      return RET_BUG;
    }      
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_SET, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconset))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}


static int 
_wrap_gtkiconset_new(Stack stack,int rhs,int opt,int lhs)
{
  return _wrap_gtk_icon_set_new_from_pixbuf(stack,rhs,opt,lhs);
}
%%
override gtk_icon_set_get_sizes noargs
static int
_wrap_gtk_icon_set_get_sizes(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkIconSize *sizes;
  int i, n_sizes;
  NspMatrix  *ret;

  gtk_icon_set_get_sizes(nspg_boxed_get(self, GtkIconSet), &sizes, &n_sizes);
  if (( ret = nsp_matrix_create(NVOID,'r',1,n_sizes))==NULLMAT) return RET_BUG;
  for (i = 0; i < n_sizes; i++)  ret->R[i]= sizes[i];
  MoveObj(stack,1,(NspObject *) ret) ; 
  return 1;
}
%%
override gtk_cell_renderer_get_size kwargs
static int
_wrap_gtk_cell_renderer_get_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "widget", "cell_area", NULL };*/
  gint x_offset = 0, y_offset = 0, width = 0, height = 0;
  GdkRectangle cell_area;
  NspGObject *nsp_widget;
  NspObject *nsp_cell_area = NULL;
  
  CheckRhs(1,2); 
  if ((nsp_widget = (NspGObject *)nsp_get_object(stack,1))== NULL) return RET_BUG; 
  if ( rhs == 2 ) 
    {
      if ((nsp_cell_area =nsp_get_object(stack,2))== NULL) return RET_BUG; 
    }

  if (!nspgobject_check(nsp_widget,(NspTypeBase *) nsp_type_gtkwidget)) {
    Scierror( "widget must be a GtkWidget");
    return RET_BUG;
  }
  if (nsp_cell_area != NULL ) {
    if (!nsp_gdk_rectangle_from_object(nsp_cell_area, &cell_area))
      return RET_BUG;
  }

  gtk_cell_renderer_get_size(GTK_CELL_RENDERER(self->obj),
			     GTK_WIDGET(nspgobject_get(nsp_widget)),
			     ( IsNone(nsp_cell_area )) ? NULL : &cell_area,
			     &x_offset, &y_offset, &width, &height);
  if (  nsp_move_doubles(stack,1,1,4,(double)  x_offset,(double) y_offset, (double) width,(double) height) == FAIL) return RET_BUG; 
  return 1; 
}
%%
override gtk_cell_renderer_get_fixed_size noargs
static int
_wrap_gtk_cell_renderer_get_fixed_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint width, height;

  gtk_cell_renderer_get_fixed_size(GTK_CELL_RENDERER(self->obj),
				   &width, &height);

  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL) 
    return RET_BUG; 
  return 1; 
}
%%
override gtk_stock_add kwargs
static int
_wrap_gtk_stock_add(Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list, t_end} ;
  NspList *nsp_items;
  Cell * cloc;
  GtkStockItem *items = NULL;
  int i, len;

  if (GetArgs(stack,rhs,opt,T,&nsp_items)   == FAIL) return RET_BUG;;

  len =nsp_list_length(nsp_items);
  if (len == 0) return 0;
  items = g_new(GtkStockItem, len);
  cloc = nsp_items->first; 
  i=1;
  while ( cloc != NULLCELL) 
    {
      if ( cloc->O != NULLOBJ ) 
	{
	  NspList *item = (NspList *) cloc->O;
	  int_types kT[]={ string,string,s_int,s_int,string,list_end};
	  if ( !IsList(cloc->O) ) 
	    {
	      Scierror("%s: list element %d has wrong type\n",NspFname(stack),i);
	      goto error;
	    }
	  if ( GetListArgs(item,1,kT,&items[i].stock_id, &items[i].label,
			   &items[i].modifier, &items[i].keyval,
			   &items[i].translation_domain) == FAIL ) 
	    {
	      Scierror("%s: list element %d is incorrect (stock_id, label, modifiers,keyval,domain) expected\n",NspFname(stack),i);
	      goto error;
	    }
	}
      cloc = cloc->next;
      i++;
    }
  gtk_stock_add(items, len);
  g_free(items);
  return 0;
 error:
  g_free(items);
  return RET_BUG;
}
%%
override gtk_stock_list_ids noargs
static int
_wrap_gtk_stock_list_ids(Stack stack,int rhs,int opt,int lhs)
{
  GSList *list, *tmp;
  NspList *nsp_list; 
  list = gtk_stock_list_ids();
  NSP_LIST_FROM_GLIST(nsp_new_string_obj("lel",tmp->data,-1),g_slist_free);
  /* XXX
   * g_slist_foreach (list, (GFunc)g_free, NULL);
   * g_slist_free (list);  
   */
}
%%
override gtk_stock_lookup args
static int
_wrap_gtk_stock_lookup(Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end} ;
  int_types ret_T1[] = {s_bool,list_begin,string,string,s_int,s_int,string,list_end, t_end} ;
  int_types ret_T2[] = {s_bool,list_begin,list_end, t_end} ;
  gchar *stock_id;
  GtkStockItem item;
  if (GetArgs(stack,rhs,opt,T, &stock_id) == FAIL) return RET_BUG;;

  if(gtk_stock_lookup(stock_id, &item)) {
    return RetArgs(stack,lhs,ret_T1, TRUE, item.stock_id, item.label, item.modifier, item.keyval, item.translation_domain);
  }
  else 
    return RetArgs(stack,lhs,ret_T2, FALSE);
}
%%
override gtk_layout_get_size noargs
static int
_wrap_gtk_layout_get_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  guint width, height;
  gtk_layout_get_size(GTK_LAYOUT(self->obj), &width, &height);

  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL) 
    return RET_BUG; 
  return 1; 

}
%%
override gtk_frame_get_label_align noargs
static int
_wrap_gtk_frame_get_label_align(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gfloat xalign, yalign;

  gtk_frame_get_label_align(GTK_FRAME(self->obj), &xalign, &yalign);
  if ( nsp_move_doubles(stack,1,1,2,(double) xalign,(double) yalign) == FAIL) return RET_BUG; 
  return 1;

}
%%
override gtk_misc_get_alignment noargs
static int
_wrap_gtk_misc_get_alignment(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gfloat xalign, yalign;
  
  gtk_misc_get_alignment(GTK_MISC(self->obj), &xalign, &yalign);
  if ( nsp_move_doubles(stack,1,1,2,(double) xalign,(double) yalign) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_misc_get_padding noargs
static int
_wrap_gtk_misc_get_padding(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint xpad, ypad;

  gtk_misc_get_padding(GTK_MISC(self->obj), &xpad, &ypad);
  if ( nsp_move_doubles(stack,1,1,2,(double) xpad,(double) ypad) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_ruler_get_range noargs
static int
_wrap_gtk_ruler_get_range(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gdouble lower, upper, position, max_size;

  gtk_ruler_get_range(GTK_RULER(self->obj), &lower, &upper, &position,
		      &max_size);
  if ( nsp_move_doubles(stack,1,1,4,(double) lower,(double) upper,(double) position,(double) max_size ) == FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_im_context_get_preedit_string noargs
static int
_wrap_gtk_im_context_get_preedit_string(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* 
  gchar *str;
  PangoAttrList *attrs;
  gint cursor_pos;
  NspObject *ret;

  gtk_im_context_get_preedit_string(GTK_IM_CONTEXT(self->obj),
				    &str, &attrs, &cursor_pos);
  
  ret = Nsp_BuildValue("(sNi)", str, (NspObject *) gboxed_create(NVOID,PANGO_TYPE_ATTR_LIST, attrs,TRUE,TRUE,NULL),
  cursor_pos);
  g_free(str);

  return ret;
  */
  Scierror(" To be done gtk_im_context_get_preedit_string");
  return 0;
}
%%
override gtk_im_context_filter_keypress kwargs
static int
_wrap_gtk_im_context_filter_keypress(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "key", NULL };*/
  NspObject *key;
  int ret;
  
  if (GetArgs(stack,rhs,opt,T,&key)  == FAIL) return RET_BUG;;
  
  if (!nspg_boxed_check(key, GDK_TYPE_EVENT)) {
    Scierror( "key must be a GdkEvent");
    return RET_BUG;
  }

  ret = gtk_im_context_filter_keypress(GTK_IM_CONTEXT(self->obj),
				       nspg_boxed_get(key, GdkEventKey));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG; 
  return 1;
}
%%
override gtk_im_context_get_surrounding noargs
static int
_wrap_gtk_im_context_get_surrounding(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[]={string,s_int,t_end};
  gchar *text;
  gint cursor_index;
  int rep;
  if ( !gtk_im_context_get_surrounding(GTK_IM_CONTEXT(self->obj), &text, &cursor_index)) 
    {
      Scierror("%s: cannot get text\n",NspFname(stack));
      return RET_BUG; 
    }
  rep = RetArgs(stack,lhs,T, text, cursor_index);
  g_free(text);
  return rep;
}
%%
override-attr GtkTooltips.active_tips_data
static NspObject *
_wrap_gtk_tooltips__get_active_tips_data(NspGObject *self, char *attr)
{
  int_types T[] = {obj,obj,string,string, t_end} ;
  GtkTooltips *tips = GTK_TOOLTIPS(self->obj);
  GtkTooltipsData *data = tips->active_tips_data;
  if (data == NULL) return NULL;
  return (NspObject *)BuildListFromArgs(T, nspgobject_new(NVOID,(GObject *)data->tooltips),
			   nspgobject_new(NVOID,(GObject *)data->widget),
			   data->tip_text, data->tip_private);
}
%%
override-attr GtkTooltips.tips_data_list
static NspObject *
_wrap_gtk_tooltips__get_tips_data_list(NspGObject *self, char *attr)
{
  /* 
  GList *list = GTK_TOOLTIPS(self->obj)->tips_data_list;
  gint         i, length;
  NspObject    *pylist;
  GList *iter;

  length = g_list_length(list);
  pylist = NspList_New(length);

  i = 0;
  for (iter = list; iter; iter = iter->next) {
    GtkTooltipsData *data = (GtkTooltipsData*)iter->data;
    NspObject *item = Nsp_BuildValue("OOss",
				     nspgobject_new((GObject *)data->tooltips),
				     nspgobject_new((GObject *)data->widget),
				     data->tip_text,
				     data->tip_private);
    NspList_SetItem(pylist, i, item);
    Nsp_INCREF(item);
  }
  return pylist;
  */ 
  Scierror("XXXX To be done gtk_tooltips__get_tips_data_list");
  return 0;
}
%%
override-attr GtkAdjustment.value
static int
_wrap_gtk_adjustment__set_value(NspGObject *self, char *attr, NspObject *value)
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->value = val;
  gtk_adjustment_value_changed(adjustment);
  return 0;
}
%%
override-attr GtkAdjustment.lower
static int
_wrap_gtk_adjustment__set_lower(NspGObject *self, char *attr, NspObject *value)
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->lower = val;
  gtk_adjustment_changed(adjustment);
  return 0;
}
%%
override-attr GtkAdjustment.upper
static int
_wrap_gtk_adjustment__set_upper(NspGObject *self, char *attr, NspObject *value)
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->upper = val;
  gtk_adjustment_changed(adjustment);
  return 0;
}
%%
override-attr GtkAdjustment.step_increment
static int
_wrap_gtk_adjustment__set_step_increment(NspGObject *self, char *attr, NspObject *value)
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->step_increment = val;
  gtk_adjustment_changed(adjustment);
  return 0;
}
%%
override-attr GtkAdjustment.page_increment
static int
_wrap_gtk_adjustment__set_page_increment(NspGObject *self, char *attr, NspObject *value)
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->page_increment = val;
  gtk_adjustment_changed(adjustment);
  return 0;
}
%%
override-attr GtkAdjustment.page_size
static int
_wrap_gtk_adjustment__set_page_size(NspGObject *self, char *attr, NspObject *value) 
{
  double val;
  GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);
  if ( DoubleScalar(value,&val) == FAIL) return RET_BUG;
  adjustment->page_size = val;
  gtk_adjustment_changed(adjustment);
  return 0;
}
%%
override gtk_adjustment_set_all kwargs
static int
_wrap_gtk_adjustment_set_all(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  Scierror("deprecated: use individual setters");
  return RET_BUG;
}
%%
override gtk_text_view_get_iter_location kwargs
static int
_wrap_gtk_text_view_get_iter_location(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end} ;
  /* static char *kwlist[] = { "iter", NULL };*/
  NspObject *nsp_iter;
  GdkRectangle location;
  GtkTextIter *iter = NULL;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter, &nsp_iter)  == FAIL) return RET_BUG;;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  gtk_text_view_get_iter_location(GTK_TEXT_VIEW(self->obj), iter, &location);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &location, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_text_view_get_line_at_y kwargs
static int
_wrap_gtk_text_view_get_line_at_y(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end} ;
  int_types ret_T[] = {obj,s_int, t_end} ;
  /* static char *kwlist[] = { "y", NULL };*/
  GtkTextIter iter;
  gint y, line_top;
  
  if (GetArgs(stack,rhs,opt,T, &y)   == FAIL) return RET_BUG;;
  gtk_text_view_get_line_at_y(GTK_TEXT_VIEW(self->obj),  &iter, y, &line_top);
  return RetArgs(stack,lhs,ret_T,
		 (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter,TRUE, TRUE, NULL),
		 line_top);
}
%%
override gtk_text_view_get_line_yrange kwargs
static int
_wrap_gtk_text_view_get_line_yrange(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end} ;
  /* static char *kwlist[] = { "iter", NULL };*/
  GtkTextIter *iter = NULL;
  gint y = -1, height = -1;
  NspObject *nsp_iter;
  
  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter, &nsp_iter)  == FAIL) return RET_BUG;;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  gtk_text_view_get_line_yrange(GTK_TEXT_VIEW(self->obj),
				iter, &y, &height);
  if (  nsp_move_doubles(stack,1,1,2,(double) y,(double) height) == FAIL) 
    return RET_BUG; 
  return 1; 
}
%%
override gtk_text_view_get_iter_at_location kwargs
static int
_wrap_gtk_text_view_get_iter_at_location(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,t_end} ;
  /* static char *kwlist[] = { "x", "y", NULL };*/
  GtkTextIter iter;
  gint x, y;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &x, &y)  == FAIL) return RET_BUG;;
  gtk_text_view_get_iter_at_location(GTK_TEXT_VIEW(self->obj),  &iter, x, y);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
%%
override gtk_file_selection_get_selections noargs
static int
_wrap_gtk_file_selection_get_selections(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar **filenames = NULL;
  NspObject *ret;
  
  filenames = gtk_file_selection_get_selections(GTK_FILE_SELECTION(self->obj));
  if (( ret = (NspObject *)nsp_smatrix_create_from_table(filenames))== NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;

}
%%
override gtk_icon_size_lookup kwargs
static int
_wrap_gtk_icon_size_lookup(Stack stack,int rhs,int opt,int lhs)
{
  int rep;
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "icon_size", NULL };*/
  NspObject *nsp_icon_size;
  GtkIconSize icon_size;
  gint width=-1, height=-1;

  if (GetArgs(stack,rhs,opt,T, &nsp_icon_size) == FAIL) return RET_BUG;;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_icon_size,  &icon_size)) return RET_BUG;
  rep=gtk_icon_size_lookup(icon_size, &width, &height);
  if ( nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL) return RET_BUG; 
  return 1; 
}
%%
override-attr GtkTextAttributes.bg_color
static NspObject *
_wrap_gtk_text_attributes__get_bg_color(NspObject *self, char *attr)
{
  GdkColor ret;
  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.bg_color;
  return (NspObject *)gboxed_create(NVOID,GDK_TYPE_COLOR, &ret, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor);
}
%%
override-attr GtkTextAttributes.fg_color
static NspObject *
_wrap_gtk_text_attributes__get_fg_color(NspObject *self, char *attr)
{
  GdkColor ret;
  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.fg_color;
  return (NspObject *)gboxed_create(NVOID,GDK_TYPE_COLOR, &ret, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkcolor);
}
%%
override-attr GtkTextAttributes.bg_stipple
static NspObject *
_wrap_gtk_text_attributes__get_bg_stipple(NspObject *self, char *attr)
{
  GdkBitmap *ret;
  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.bg_stipple;
  /* nspgobject_new handles NULL checking */
  return (NspObject *) nspgobject_new(NVOID,(GObject *)ret);
}
%%
override-attr GtkTextAttributes.fg_stipple
static NspObject *
_wrap_gtk_text_attributes__get_fg_stipple(NspObject *self, char *attr)
{
  GdkBitmap *ret;

  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.fg_stipple;
  /* nspgobject_new handles NULL checking */
  return (NspObject *) nspgobject_new(NVOID,(GObject *)ret);
}
%%
override-attr GtkTextAttributes.rise
static NspObject *
_wrap_gtk_text_attributes__get_rise(NspObject *self, char *attr)
{
  int ret;
  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.rise;
  return nsp_new_double_obj((double) ret);
}
%%
override-attr GtkTextAttributes.underline
static NspObject *
_wrap_gtk_text_attributes__get_underline(NspObject *self, char *attr)
{
  int ret;
  ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.underline;
  return nsp_new_double_obj((double) ret);
}
%%
override-attr GtkTextAttributes.strikethrough
static NspObject *
_wrap_gtk_text_attributes__get_strikethrough(NspObject *self, char *attr)
{
  int ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.strikethrough;
  return (ret)  ? nsp_create_true_object(NVOID) : nsp_create_false_object(NVOID);
}
%%
override-attr GtkTextAttributes.draw_bg
static NspObject *
_wrap_gtk_text_attributes__get_draw_bg(NspObject *self, char *attr)
{
  int ret = nspg_boxed_get(self, GtkTextAttributes)->appearance.draw_bg;
  return (ret)  ? nsp_create_true_object(NVOID) : nsp_create_false_object(NVOID);
}
%%
override gtk_cell_layout_set_cell_data_func kwargs

static void
nspgtk_cell_layout_data_func_marshal (GtkCellLayout *tree_column,
				      GtkCellRenderer *cell,
				      GtkTreeModel *tree_model,
				      GtkTreeIter *iter, gpointer data)
{
  NspObject *args[5], *nsp_ret;
  NspGtkCustomNotify *cunote = data;
  int nret = 1,nargs = 4;
  gboolean ret = FALSE;

  g_assert (cunote->func);

  nspg_block_threads();

  args[0] =  (NspObject *) gobject_create("tree_column",(GObject *)tree_column,(NspTypeBase *) nsp_type_gtktreeviewcolumn );
  args[1] = (NspObject *) gobject_create("cell",(GObject *) cell, (NspTypeBase *) nsp_type_gtkcellrenderer);
  args[2] =  (NspObject *) gobject_create("model",(GObject *)tree_model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[3] =  (NspObject *) gboxed_create("iter",GTK_TYPE_TREE_ITER, iter,TRUE, TRUE,(NspTypeBase *)nsp_type_gtktreeiter);
  
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL||args[3]== NULL ) goto end;
  if (cunote->data) 
    {
      args[4]= cunote->data; 
      nargs= 5;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL) 
    goto end; 

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  nspg_unblock_threads();
 end: 
  {
    nspg_unblock_threads();
  }
}

static int
_wrap_gtk_cell_layout_set_cell_data_func (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_func, *nsp_arg = NULL;
  GtkCellRenderer *cell;
  NspGtkCellRenderer *nsp_cell;
  NspGtkCustomNotify *cunote; 
  CheckRhs(2,3);
  if ((nsp_cell = GetGtkCellRenderer(stack,1)) == NULL) return RET_BUG; 
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,2)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"tree_foreach")== FAIL)) return RET_BUG;
  /** extra arguments **/
  if ( rhs == 3 ) 
    {
      if (( nsp_arg = (NspObject *) GetListCopy(stack,3)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;

  gtk_cell_layout_set_cell_data_func (GTK_CELL_LAYOUT (self->obj), cell,
				    nspgtk_cell_layout_data_func_marshal,
				    cunote,
				    nspgtk_custom_destroy_notify);
  return 0;
}
%%
ignore gtk_combo_box_new_with_model
%%
ignore gtk_combo_box_new_text
%%
override gtk_combo_box_new

/* merging gtkcombobox _new, new_with_model, new_text
 * 
 */
static int
_wrap_gtkcombobox_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  NspGObject *model = NULL;
  NspSMatrix *Smat = NULL;
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"model",obj_check,NULLOBJ,-1}, 
	{"text",smat,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  if ( GetArgs(stack,rhs,opt,T,opts,&nsp_type_gtktreemodel,&model,&Smat) == FAIL) return RET_BUG;
  if ( model != NULL) 
    {
      if ((ret = (GObject *) gtk_combo_box_new_with_model(GTK_TREE_MODEL(model->obj)))
	  == NULL) return RET_BUG;
    }
  else if ( Smat != NULL) 
    {
      int i;
      if ((ret = (GObject *) gtk_combo_box_new_text()) == NULL) return RET_BUG;
      /* append smat */
      for ( i = 0 ; i < Smat->mn ; i++)
	gtk_combo_box_append_text(GTK_COMBO_BOX(ret),Smat->S[i]);
    }
  else 
    {
      if ((ret = (GObject *)gtk_combo_box_new())== NULL) return RET_BUG;
    }
  nsp_type_gtkcombobox = new_type_gtkcombobox(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcombobox );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
%%
ignore gtk_combo_box_entry_new_with_model
%%
ignore gtk_combo_box_entry_new_text
%%
override gtk_combo_box_entry_new

/* merging gtkcomboboxentry _new, new_with_model, new_text
 * gtkcomboboxentry_new(text=)
 * gtkcomboboxentry_new(model=,text_column=)
 * if both text and column are given text is ignored 
 */
static int
_wrap_gtkcomboboxentry_new(Stack stack, int rhs, int opt, int lhs)
{
  int text_column=0;
  GObject *ret; NspObject *nsp_ret;
  NspGObject *model = NULL;
  NspSMatrix *Smat = NULL;
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"model",obj_check,NULLOBJ,-1}, 
	{"text_column",s_int,NULLOBJ,-1}, 
	{"text",smat,NULLOBJ,-1}, 
	{NULL,t_end,NULLOBJ,-1} };
  if ( GetArgs(stack,rhs,opt,T,opts,&nsp_type_gtktreemodel,&model,&text_column,&Smat) == FAIL)
    return RET_BUG;
  if ( model != NULL) 
    {
      if ((ret = (GObject *) gtk_combo_box_entry_new_with_model(GTK_TREE_MODEL(model->obj),text_column))
	  == NULL) return RET_BUG;
    }
  else if ( Smat != NULL) 
    {
      int i;
      if ((ret = (GObject *) gtk_combo_box_entry_new_text()) == NULL) return RET_BUG;
      /* append smat */
      for ( i = 0 ; i < Smat->mn ; i++)
	gtk_combo_box_append_text(GTK_COMBO_BOX(ret),Smat->S[i]);
    }
  else 
    {
      if ((ret = (GObject *)gtk_combo_box_entry_new())== NULL) return RET_BUG;
    }
  nsp_type_gtkcombobox = new_type_gtkcombobox(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcombobox );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

%%
ignore gtk_cell_view_new_with_text
%%
ignore gtk_cell_view_new_with_markup
%%
ignore gtk_cell_view_new_with_pixbuf
%%
override gtk_cell_view_new with _with_text,_with_markup,_with_pixbuf

/* merging gtk_cell_view_new 
 * gtkcomboboxentry_new(text=)
 * gtkcomboboxentry_new(model=,text_column=)
 * if both text and column are given text is ignored 
 */

static int
_wrap_gtkcellview_new(Stack stack, int rhs, int opt, int lhs)
{
  char *Text=NULL,*Markup=NULL;
  NspGObject *pixbuf = NULL;
  GObject *ret; NspObject *nsp_ret;
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
    {"text",string,NULLOBJ,-1}, 
    {"markup",string,NULLOBJ,-1}, 
    {"pixbuf",obj_check,NULLOBJ,-1}, 
    {NULL,t_end,NULLOBJ,-1} };
  if ( GetArgs(stack,rhs,opt,T,opts,&Text,&Markup,&nsp_type_gdkpixbuf,&pixbuf) == FAIL)
    return RET_BUG;
  if ( Text != NULL)
    {
      if ((ret =(GObject *) gtk_cell_view_new_with_text(Text))== NULL) return RET_BUG;
    }
  else if ( Markup != NULL)
    {
      if ((ret =(GObject *) gtk_cell_view_new_with_markup(Markup))== NULL) return RET_BUG;
    }
  else if ( pixbuf != NULL)
    {
      if ((ret =(GObject *) gtk_cell_view_new_with_pixbuf(GDK_PIXBUF(pixbuf->obj)))== NULL) return RET_BUG;
    }
  else 
    {
      if ((ret = (GObject *)gtk_cell_view_new())== NULL) return RET_BUG;      
    }
  nsp_type_gtkcellview = new_type_gtkcellview(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcellview );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

%%
ignore-win32
        GTK_TYPE_PLUG
        GTK_TYPE_SOCKET
        gtk_socket_new
        gtk_socket_steal
        gtk_socket_add_id
        gtk_socket_get_id
        gtk_plug_new
        gtk_plug_construct
        gtk_plug_get_id
%%
