<FUNCTION>
<NAME>scig_click_handler_none</NAME>
<RETURNS>int  </RETURNS>
int win, int x, int y, int ibut, int motion, int release
</FUNCTION>
<FUNCTION>
<NAME>scig_click_handler_sci</NAME>
<RETURNS>int  </RETURNS>
int win, int x, int y, int ibut, int motion, int release
</FUNCTION>
<USER_FUNCTION>
<NAME>Scig_click_handler</NAME>
<RETURNS>int </RETURNS>
int,int,int,int,int,int
</USER_FUNCTION>
<FUNCTION>
<NAME>set_scig_click_handler</NAME>
<RETURNS>Scig_click_handler  </RETURNS>
Scig_click_handler f
</FUNCTION>
<FUNCTION>
<NAME>reset_scig_click_handler</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>PushClickQueue</NAME>
<RETURNS>int  </RETURNS>
int win, int x, int y, int ibut, int motion, int release
</FUNCTION>
<FUNCTION>
<NAME>CheckClickQueue</NAME>
<RETURNS>int  </RETURNS>
int *win, int *x, int *y, int *ibut
</FUNCTION>
<FUNCTION>
<NAME>ClearClickQueue</NAME>
<RETURNS>int  </RETURNS>
int win
</FUNCTION>
<FUNCTION>
<NAME>Sci_Help</NAME>
<RETURNS>int  </RETURNS>
char *mandir, char *locale, char *help_file
</FUNCTION>
<FUNCTION>
<NAME>Scisncr</NAME>
<RETURNS>void  </RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>sciprint2</NAME>
<RETURNS>int  </RETURNS>
int iv, char *fmt, ...
</FUNCTION>
<FUNCTION>
<NAME>nsp_in_gtk_window</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_gtk_window</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_activate_gtk_events_check</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_events_activated</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>write_scilab</NAME>
<RETURNS>void  </RETURNS>
char *s
</FUNCTION>
<FUNCTION>
<NAME>Xorgetchar</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_gtk_events</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>sci_winch_signal</NAME>
<RETURNS>void  </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_gtk_init</NAME>
<RETURNS>void  </RETURNS>
int argc, char **argv,int no_window
</FUNCTION>
<FUNCTION>
<NAME>start_sci_gtk</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>sci_clear_and_exit</NAME>
<RETURNS>void  </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>sci_usr1_signal</NAME>
<RETURNS>void  </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>sci_sig_tstp</NAME>
<RETURNS>void  </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>kill_process_group</NAME>
<RETURNS>int  </RETURNS>
int pid, int sig
</FUNCTION>
<FUNCTION>
<NAME>getcolordef</NAME>
<RETURNS>void  </RETURNS>
int *screenc
</FUNCTION>
<FUNCTION>
<NAME>setcolordef</NAME>
<RETURNS>void  </RETURNS>
int screenc
</FUNCTION>
<FUNCTION>
<NAME>using_readline</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>get_one_char</NAME>
<RETURNS>int  </RETURNS>
char *prompt
</FUNCTION>
<FUNCTION>
<NAME>SciGtkReadLine</NAME>
<RETURNS>void  </RETURNS>
char *prompt, char *buffer, int *buf_size, int *len_line, int *eof
</FUNCTION>
<FUNCTION>
<NAME>nsp_read_history</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_write_history</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>create_plugged_main_menu</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>MenuFixCurrentWin</NAME>
<RETURNS>void  </RETURNS>
int ivalue
</FUNCTION>
<FUNCTION>
<NAME>graphic_initial_menu</NAME>
<RETURNS>void  *</RETURNS>
int winid
</FUNCTION>
<FUNCTION>
<NAME>scig_print</NAME>
<RETURNS>void  </RETURNS>
int winid
</FUNCTION>
<FUNCTION>
<NAME>nsp_qr</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A,NspMatrix **q,NspMatrix **r,NspMatrix **E,NspMatrix **Rank,NspMatrix **Sval,double *tol,char mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_lsq</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A,NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_det</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A,char mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_spec</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix **d,NspMatrix **v
</FUNCTION>
<FUNCTION>
<NAME>nsp_spec_sym</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A,NspMatrix **d,char flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_rcond</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A,double *rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholesky</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_lu</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A,NspMatrix **L,NspMatrix **E
</FUNCTION>
<FUNCTION>
<NAME>nsp_svd</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A,NspMatrix **S,NspMatrix **U,NspMatrix **V,char flag,NspMatrix **Rank,double *tol
</FUNCTION>
<FUNCTION>
<NAME>nsp_inv</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_norm</NAME>
<RETURNS>double  </RETURNS>
NspMatrix *A, char flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_vector_norm</NAME>
<RETURNS>double  </RETURNS>
NspMatrix *A, double p
</FUNCTION>
<FUNCTION>
<NAME>nsp_balanc</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A,NspMatrix **D
</FUNCTION>
<FUNCTION>
<NAME>nsp_gbalanc</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A,NspMatrix *B,NspMatrix **X,NspMatrix **Y
</FUNCTION>
<FUNCTION>
<NAME>nsp_hess</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A,NspMatrix **U
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_is_symmetric</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_is_upper_triangular</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_is_lower_triangular</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_have_nan_or_inf</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_expm</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_lsq</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_square</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B, double *rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_triangular</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B, char tri_type, int *info
</FUNCTION>
<USER_FUNCTION>
<NAME>Scig_command_handler</NAME>
<RETURNS>int </RETURNS>
char *
</USER_FUNCTION>
<FUNCTION>
<NAME>scig_command_handler_none</NAME>
<RETURNS>int  </RETURNS>
char *command
</FUNCTION>
<FUNCTION>
<NAME>set_scig_command_handler</NAME>
<RETURNS>Scig_command_handler  </RETURNS>
Scig_command_handler f
</FUNCTION>
<FUNCTION>
<NAME>reset_scig_command_handler</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>enqueue_nsp_command</NAME>
<RETURNS>int  </RETURNS>
char *command
</FUNCTION>
<FUNCTION>
<NAME>checkqueue_nsp_command</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>lockqueue_nsp_command</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>unlockqueue_nsp_command</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>dequeue_nsp_command</NAME>
<RETURNS>int  </RETURNS>
char *buf,int buf_len
</FUNCTION>
<STRUCT>
<NAME>NspLink</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_link</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_link</NAME>
struct nsp_link {
  nsp_gframe *frame; /* a link must be in a frame to be drawn */
  void *object_sid;
  int color; 
  int thickness;
  NspMatrix *poly ;       /* the polyline */
  grl_lock locks[2];      /* two lock points */
  int hilited ; 
  int show    ; 
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspLink</NAME>
struct NspLink {
  /*< private >*/
  NspObject father; 
  NspTypeLink *type; 
  /*< public >*/
  /* specific*/
  nsp_link *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_link_id</NAME>
extern int nsp_type_link_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_link</NAME>
extern NspTypeLink *nsp_type_link;
</VARIABLE>
<FUNCTION>
<NAME>new_type_link</NAME>
<RETURNS>NspTypeLink  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_link</NAME>
<RETURNS>NspLink  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLLINK</NAME>
#define NULLLINK (NspLink*) 0
</MACRO>
<FUNCTION>
<NAME>IsLinkObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetLinkCopy</NAME>
<RETURNS>NspLink  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetLink</NAME>
<RETURNS>NspLink  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>link_create_n</NAME>
<RETURNS>NspLink  *</RETURNS>
char *name,int n,int color,int thickness
</FUNCTION>
<FUNCTION>
<NAME>link_lock_update</NAME>
<RETURNS>void  </RETURNS>
NspGFrame *F, NspLink *L,int lp,double ptnew[2]
</FUNCTION>
<FUNCTION>
<NAME>link_split</NAME>
<RETURNS>int  </RETURNS>
NspGFrame *F,NspLink *L,NspLink **L1,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>link_check</NAME>
<RETURNS>void  </RETURNS>
NspGFrame *F,NspLink *L
</FUNCTION>
<FUNCTION>
<NAME>IsLink</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>link_add_control</NAME>
<RETURNS>int  </RETURNS>
NspLink *L,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>link_remove_control</NAME>
<RETURNS>int  </RETURNS>
NspLink *L,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>link_create</NAME>
<RETURNS>NspLink  *</RETURNS>
char *name,NspMatrix *D,int color,int thickness, NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>TokenLineSet</NAME>
<RETURNS>int  </RETURNS>
int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_dir</NAME>
<RETURNS>int  </RETURNS>
const char *Dir, char *Fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_dir_full</NAME>
<RETURNS>int  </RETURNS>
const char *Dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_from_std</NAME>
<RETURNS>int  </RETURNS>
int display
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_from_smat</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *M,int display,int echo, int error,int pause
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_file</NAME>
<RETURNS>int  </RETURNS>
char *Str, int display,int echo, int error,int pause
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_from_string</NAME>
<RETURNS>int  </RETURNS>
char *Str, int display,int echo, int error,int pause
</FUNCTION>
<STRUCT>
<NAME>Hash_Entry</NAME>
</STRUCT>
<STRUCT>
<NAME>Hash_Entry</NAME>
struct Hash_Entry { 
  unsigned int used; /* used to detect if data is present */
  NspObject *data;  
};
</STRUCT>
<STRUCT>
<NAME>NspTypeHash</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeHash</NAME>
struct NspTypeHash { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>NspHash</NAME>
</STRUCT>
<STRUCT>
<NAME>NspHash</NAME>
struct NspHash {
  /*< private >*/
  NspObject father; 
  NspTypeHash *type; 
  /*< public >*/
  unsigned int hsize,filled; /* size of hash table and number of present entries */
  void  *htable; /* an array of size hsize+1 */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_hash_id</NAME>
extern int nsp_type_hash_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_hash</NAME>
extern NspTypeHash *nsp_type_hash;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_hash_init</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_hash</NAME>
<RETURNS>NspTypeHash  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_hash</NAME>
<RETURNS>NspHash  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLHASH</NAME>
#define NULLHASH (NspHash*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_hash_create</NAME>
<RETURNS>NspHash  *</RETURNS>
char *name, unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_copy</NAME>
<RETURNS>NspHash  *</RETURNS>
NspHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_destroy</NAME>
<RETURNS>void  </RETURNS>
NspHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_info</NAME>
<RETURNS>void  </RETURNS>
NspHash *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_print</NAME>
<RETURNS>void  </RETURNS>
NspHash *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_object</NAME>
<RETURNS>NspHash  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsHashObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsHash</NAME>
<RETURNS>int  </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetHashCopy</NAME>
<RETURNS>NspHash  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetHash</NAME>
<RETURNS>NspHash  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_resize</NAME>
<RETURNS>int  </RETURNS>
NspHash *H, unsigned int new_size
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_merge</NAME>
<RETURNS>int  </RETURNS>
NspHash *H1, NspHash *H2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_get_next_object</NAME>
<RETURNS>int  </RETURNS>
NspHash *H, int *i, NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_enter_copy</NAME>
<RETURNS>int  </RETURNS>
NspHash *H, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_enter</NAME>
<RETURNS>int  </RETURNS>
NspHash *H, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_remove</NAME>
<RETURNS>void  </RETURNS>
NspHash *H, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_find_and_copy</NAME>
<RETURNS>int  </RETURNS>
NspHash *H, char *str, NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_find</NAME>
<RETURNS>int  </RETURNS>
NspHash *H,const char *str, NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_equal</NAME>
<RETURNS>NspBMatrix   *</RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_not_equal</NAME>
<RETURNS>NspBMatrix   *</RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_full_equal</NAME>
<RETURNS>int  </RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_full_not_equal</NAME>
<RETURNS>int  </RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<ENUM>
<NAME>HashOperation</NAME>
typedef enum {
  H_FIND,
  H_FIND_COPY,
  H_ENTER,
  H_ENTER_COPY,
  H_REMOVE 
} HashOperation;
</ENUM>
<FUNCTION>
<NAME>nsp_hsearch</NAME>
<RETURNS>int  </RETURNS>
NspHash *H,const char *key, NspObject **data,HashOperation action
</FUNCTION>
<FUNCTION>
<NAME>nsp_hcreate_from_list</NAME>
<RETURNS>NspHash  *</RETURNS>
char *name,unsigned int nel, NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_hcreate</NAME>
<RETURNS>NspHash  *</RETURNS>
char *name, unsigned int nel
</FUNCTION>
<FUNCTION>
<NAME>nsp_hdestroy</NAME>
<RETURNS>void  </RETURNS>
NspHash *H
</FUNCTION>
<VARIABLE>
<NAME>int_column</NAME>
extern function int_column;
</VARIABLE>
<VARIABLE>
<NAME>int_mx2latexmat</NAME>
extern function int_mx2latexmat;
</VARIABLE>
<VARIABLE>
<NAME>int_mx2latextab</NAME>
extern function int_mx2latextab;
</VARIABLE>
<VARIABLE>
<NAME>int_mx_finite</NAME>
extern function int_mx_finite;
</VARIABLE>
<VARIABLE>
<NAME>int_mx_isinf</NAME>
extern function int_mx_isinf;
</VARIABLE>
<VARIABLE>
<NAME>int_mx_isnan</NAME>
extern function int_mx_isnan;
</VARIABLE>
<VARIABLE>
<NAME>int_mxabs</NAME>
extern function int_mxabs;
</VARIABLE>
<VARIABLE>
<NAME>int_mxacos</NAME>
extern function int_mxacos;
</VARIABLE>
<VARIABLE>
<NAME>int_mxacos</NAME>
extern function int_mxacos;
</VARIABLE>
<VARIABLE>
<NAME>int_mxacosh</NAME>
extern function int_mxacosh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxacosh</NAME>
extern function int_mxacosh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxaddcols</NAME>
extern function int_mxaddcols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxaddcols</NAME>
extern function int_mxaddcols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxaddrows</NAME>
extern function int_mxaddrows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxaddrows</NAME>
extern function int_mxaddrows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxarg</NAME>
extern function int_mxarg;
</VARIABLE>
<VARIABLE>
<NAME>int_mxarg</NAME>
extern function int_mxarg;
</VARIABLE>
<VARIABLE>
<NAME>int_mxasin</NAME>
extern function int_mxasin;
</VARIABLE>
<VARIABLE>
<NAME>int_mxasin</NAME>
extern function int_mxasin;
</VARIABLE>
<VARIABLE>
<NAME>int_mxasinh</NAME>
extern function int_mxasinh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxasinh</NAME>
extern function int_mxasinh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatan2</NAME>
extern function int_mxatan2;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatan2</NAME>
extern function int_mxatan2;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatan</NAME>
extern function int_mxatan;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatan</NAME>
extern function int_mxatan;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatanh</NAME>
extern function int_mxatanh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatanh</NAME>
extern function int_mxatanh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxbackdivel</NAME>
extern function int_mxbackdivel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxbackdivel</NAME>
extern function int_mxbackdivel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxceil</NAME>
extern function int_mxceil;
</VARIABLE>
<VARIABLE>
<NAME>int_mxceil</NAME>
extern function int_mxceil;
</VARIABLE>
<VARIABLE>
<NAME>int_mxclean</NAME>
extern function int_mxclean;
</VARIABLE>
<VARIABLE>
<NAME>int_mxclean</NAME>
extern function int_mxclean;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcomplexify</NAME>
extern function int_mxcomplexify;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcomplexify</NAME>
extern function int_mxcomplexify;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatd</NAME>
extern function int_mxconcatd;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatd</NAME>
extern function int_mxconcatd;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatdiag</NAME>
extern function int_mxconcatdiag;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatdiag</NAME>
extern function int_mxconcatdiag;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatr</NAME>
extern function int_mxconcatr;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatr</NAME>
extern function int_mxconcatr;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatr_mb</NAME>
extern function int_mxconcatr_mb;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatr_mb</NAME>
extern function int_mxconcatr_mb;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconj</NAME>
extern function int_mxconj;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconj</NAME>
extern function int_mxconj;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcopy</NAME>
extern function int_mxcopy;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcopy</NAME>
extern function int_mxcopy;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcos</NAME>
extern function int_mxcos;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcos</NAME>
extern function int_mxcos;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcosh</NAME>
extern function int_mxcosh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcosh</NAME>
extern function int_mxcosh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcreate</NAME>
extern function int_mxcreate;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcreate</NAME>
extern function int_mxcreate;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcuprod</NAME>
extern function int_mxcuprod;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcuprod</NAME>
extern function int_mxcuprod;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcusum</NAME>
extern function int_mxcusum;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcusum</NAME>
extern function int_mxcusum;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdadd</NAME>
extern function int_mxdadd;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdadd</NAME>
extern function int_mxdadd;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeletecols</NAME>
extern function int_mxdeletecols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeletecols</NAME>
extern function int_mxdeletecols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeleteelts</NAME>
extern function int_mxdeleteelts;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeleteelts</NAME>
extern function int_mxdeleteelts;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeleterows</NAME>
extern function int_mxdeleterows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeleterows</NAME>
extern function int_mxdeleterows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdestroy</NAME>
extern function int_mxdestroy;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdestroy</NAME>
extern function int_mxdestroy;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiag</NAME>
extern function int_mxdiag;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiag</NAME>
extern function int_mxdiag;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiagcre</NAME>
extern function int_mxdiagcre;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiagcre</NAME>
extern function int_mxdiagcre;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiage</NAME>
extern function int_mxdiage;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiage</NAME>
extern function int_mxdiage;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiagset</NAME>
extern function int_mxdiagset;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiagset</NAME>
extern function int_mxdiagset;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdivel</NAME>
extern function int_mxdivel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdivel</NAME>
extern function int_mxdivel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdquote</NAME>
extern function int_mxdquote;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdquote</NAME>
extern function int_mxdquote;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdsub</NAME>
extern function int_mxdsub;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdsub</NAME>
extern function int_mxdsub;
</VARIABLE>
<VARIABLE>
<NAME>int_mxeq</NAME>
extern function int_mxeq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxeq</NAME>
extern function int_mxeq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxerf</NAME>
extern function int_mxerf;
</VARIABLE>
<VARIABLE>
<NAME>int_mxerf</NAME>
extern function int_mxerf;
</VARIABLE>
<VARIABLE>
<NAME>int_mxerfc</NAME>
extern function int_mxerfc;
</VARIABLE>
<VARIABLE>
<NAME>int_mxerfc</NAME>
extern function int_mxerfc;
</VARIABLE>
<VARIABLE>
<NAME>int_mxexpel</NAME>
extern function int_mxexpel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxexpel</NAME>
extern function int_mxexpel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextract</NAME>
extern function int_mxextract;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextract</NAME>
extern function int_mxextract;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractcols</NAME>
extern function int_mxextractcols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractcols</NAME>
extern function int_mxextractcols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractelts</NAME>
extern function int_mxextractelts;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractelts</NAME>
extern function int_mxextractelts;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractrows</NAME>
extern function int_mxextractrows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractrows</NAME>
extern function int_mxextractrows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxeye</NAME>
extern function int_mxeye;
</VARIABLE>
<VARIABLE>
<NAME>int_mxeye</NAME>
extern function int_mxeye;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfeq</NAME>
extern function int_mxfeq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfeq</NAME>
extern function int_mxfeq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfge</NAME>
extern function int_mxfge;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfge</NAME>
extern function int_mxfge;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfgt</NAME>
extern function int_mxfgt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfgt</NAME>
extern function int_mxfgt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfind</NAME>
extern function int_mxfind;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfind</NAME>
extern function int_mxfind;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfle</NAME>
extern function int_mxfle;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfle</NAME>
extern function int_mxfle;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfloor</NAME>
extern function int_mxfloor;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfloor</NAME>
extern function int_mxfloor;
</VARIABLE>
<VARIABLE>
<NAME>int_mxflt</NAME>
extern function int_mxflt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxflt</NAME>
extern function int_mxflt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfneq</NAME>
extern function int_mxfneq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfneq</NAME>
extern function int_mxfneq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxge</NAME>
extern function int_mxge;
</VARIABLE>
<VARIABLE>
<NAME>int_mxge</NAME>
extern function int_mxge;
</VARIABLE>
<VARIABLE>
<NAME>int_mxgt</NAME>
extern function int_mxgt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxgt</NAME>
extern function int_mxgt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxiand</NAME>
extern function int_mxiand;
</VARIABLE>
<VARIABLE>
<NAME>int_mxiand</NAME>
extern function int_mxiand;
</VARIABLE>
<VARIABLE>
<NAME>int_mxidiv</NAME>
extern function int_mxidiv;
</VARIABLE>
<VARIABLE>
<NAME>int_mxidiv</NAME>
extern function int_mxidiv;
</VARIABLE>
<VARIABLE>
<NAME>int_mximagpart</NAME>
extern function int_mximagpart;
</VARIABLE>
<VARIABLE>
<NAME>int_mximagpart</NAME>
extern function int_mximagpart;
</VARIABLE>
<VARIABLE>
<NAME>int_mximpl</NAME>
extern function int_mximpl;
</VARIABLE>
<VARIABLE>
<NAME>int_mximpl</NAME>
extern function int_mximpl;
</VARIABLE>
<VARIABLE>
<NAME>int_mxinfo</NAME>
extern function int_mxinfo;
</VARIABLE>
<VARIABLE>
<NAME>int_mxinfo</NAME>
extern function int_mxinfo;
</VARIABLE>
<VARIABLE>
<NAME>int_mxint</NAME>
extern function int_mxint;
</VARIABLE>
<VARIABLE>
<NAME>int_mxint</NAME>
extern function int_mxint;
</VARIABLE>
<VARIABLE>
<NAME>int_mxior</NAME>
extern function int_mxior;
</VARIABLE>
<VARIABLE>
<NAME>int_mxior</NAME>
extern function int_mxior;
</VARIABLE>
<VARIABLE>
<NAME>int_mxkron</NAME>
extern function int_mxkron;
</VARIABLE>
<VARIABLE>
<NAME>int_mxkron</NAME>
extern function int_mxkron;
</VARIABLE>
<VARIABLE>
<NAME>int_mxle</NAME>
extern function int_mxle;
</VARIABLE>
<VARIABLE>
<NAME>int_mxle</NAME>
extern function int_mxle;
</VARIABLE>
<VARIABLE>
<NAME>int_mxlogel</NAME>
extern function int_mxlogel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxlogel</NAME>
extern function int_mxlogel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxlt</NAME>
extern function int_mxlt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxlt</NAME>
extern function int_mxlt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmat2vect</NAME>
extern function int_mxmat2vect;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmat2vect</NAME>
extern function int_mxmat2vect;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmatrix</NAME>
extern function int_mxmatrix;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmatrix</NAME>
extern function int_mxmatrix;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmaxi</NAME>
extern function int_mxmaxi;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmaxi</NAME>
extern function int_mxmaxi;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmini</NAME>
extern function int_mxmini;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmini</NAME>
extern function int_mxmini;
</VARIABLE>
<VARIABLE>
<NAME>int_mxminus</NAME>
extern function int_mxminus;
</VARIABLE>
<VARIABLE>
<NAME>int_mxminus</NAME>
extern function int_mxminus;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmodulo</NAME>
extern function int_mxmodulo;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmodulo</NAME>
extern function int_mxmodulo;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmultel</NAME>
extern function int_mxmultel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmultel</NAME>
extern function int_mxmultel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxneq</NAME>
extern function int_mxneq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxneq</NAME>
extern function int_mxneq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxones</NAME>
extern function int_mxones;
</VARIABLE>
<VARIABLE>
<NAME>int_mxones</NAME>
extern function int_mxones;
</VARIABLE>
<VARIABLE>
<NAME>int_mxpolar</NAME>
extern function int_mxpolar;
</VARIABLE>
<VARIABLE>
<NAME>int_mxpolar</NAME>
extern function int_mxpolar;
</VARIABLE>
<VARIABLE>
<NAME>int_mxpowel</NAME>
extern function int_mxpowel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxpowel</NAME>
extern function int_mxpowel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxprint_xxx</NAME>
extern function int_mxprint_xxx;
</VARIABLE>
<VARIABLE>
<NAME>int_mxprod</NAME>
extern function int_mxprod;
</VARIABLE>
<VARIABLE>
<NAME>int_mxprod</NAME>
extern function int_mxprod;
</VARIABLE>
<VARIABLE>
<NAME>int_mxquote</NAME>
extern function int_mxquote;
</VARIABLE>
<VARIABLE>
<NAME>int_mxquote</NAME>
extern function int_mxquote;
</VARIABLE>
<VARIABLE>
<NAME>int_mxrand</NAME>
extern function int_mxrand;
</VARIABLE>
<VARIABLE>
<NAME>int_mxrand</NAME>
extern function int_mxrand;
</VARIABLE>
<VARIABLE>
<NAME>int_mxrealpart</NAME>
extern function int_mxrealpart;
</VARIABLE>
<VARIABLE>
<NAME>int_mxrealpart</NAME>
extern function int_mxrealpart;
</VARIABLE>
<VARIABLE>
<NAME>int_mxredim</NAME>
extern function int_mxredim;
</VARIABLE>
<VARIABLE>
<NAME>int_mxredim</NAME>
extern function int_mxredim;
</VARIABLE>
<VARIABLE>
<NAME>int_mxresize</NAME>
extern function int_mxresize;
</VARIABLE>
<VARIABLE>
<NAME>int_mxresize</NAME>
extern function int_mxresize;
</VARIABLE>
<VARIABLE>
<NAME>int_mxround</NAME>
extern function int_mxround;
</VARIABLE>
<VARIABLE>
<NAME>int_mxround</NAME>
extern function int_mxround;
</VARIABLE>
<VARIABLE>
<NAME>int_mxseti</NAME>
extern function int_mxseti;
</VARIABLE>
<VARIABLE>
<NAME>int_mxseti</NAME>
extern function int_mxseti;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsetr</NAME>
extern function int_mxsetr;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsetr</NAME>
extern function int_mxsetr;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsetrc</NAME>
extern function int_mxsetrc;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsetrc</NAME>
extern function int_mxsetrc;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsign</NAME>
extern function int_mxsign;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsign</NAME>
extern function int_mxsign;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsin</NAME>
extern function int_mxsin;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsin</NAME>
extern function int_mxsin;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsinh</NAME>
extern function int_mxsinh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsinh</NAME>
extern function int_mxsinh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsort</NAME>
extern function int_mxsort;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsort</NAME>
extern function int_mxsort;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsqrtel</NAME>
extern function int_mxsqrtel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsqrtel</NAME>
extern function int_mxsqrtel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsum</NAME>
extern function int_mxsum;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsum</NAME>
extern function int_mxsum;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtan</NAME>
extern function int_mxtan;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtan</NAME>
extern function int_mxtan;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtanh</NAME>
extern function int_mxtanh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtanh</NAME>
extern function int_mxtanh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest10</NAME>
extern function int_mxtest10;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest11</NAME>
extern function int_mxtest11;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest1</NAME>
extern function int_mxtest1;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest20</NAME>
extern function int_mxtest20;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest2</NAME>
extern function int_mxtest2;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest3</NAME>
extern function int_mxtest3;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest4</NAME>
extern function int_mxtest4;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest5</NAME>
extern function int_mxtest5;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest5_2</NAME>
extern function int_mxtest5_2;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest6</NAME>
extern function int_mxtest6;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest7</NAME>
extern function int_mxtest7;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest8</NAME>
extern function int_mxtest8;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest9</NAME>
extern function int_mxtest9;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtest</NAME>
extern function int_mxtest;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtestmatrix</NAME>
extern function int_mxtestmatrix;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtestmatrix</NAME>
extern function int_mxtestmatrix;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtril</NAME>
extern function int_mxtril;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtril</NAME>
extern function int_mxtril;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtriu</NAME>
extern function int_mxtriu;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtriu</NAME>
extern function int_mxtriu;
</VARIABLE>
<VARIABLE>
<NAME>int_mxzeros</NAME>
extern function int_mxzeros;
</VARIABLE>
<VARIABLE>
<NAME>int_mxzeros</NAME>
extern function int_mxzeros;
</VARIABLE>
<STRUCT>
<NAME>NspMod</NAME>
</STRUCT>
<STRUCT>
<NAME>NspMod</NAME>
struct NspMod {
  /*< private >*/
  NspObject father; 
  NspTypeMod *type; 
  /*< public >*/
  char *path;   /* absolute XXX path of the module */ 
  char *mname;  /* module name */ 
  NspHash *T;      /* hash table to store module objects of type me 
		   (module elts) */
  Lmo *L;       /* List of submodules */
  int flag;     /* are we a copy ? */ 
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_mod_id</NAME>
extern int nsp_type_mod_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_mod</NAME>
extern NspTypeMod *nsp_type_mod;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_mod_init</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_mod</NAME>
<RETURNS>NspTypeMod  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_mod</NAME>
<RETURNS>NspMod  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>ModSize</NAME>
<RETURNS>int  </RETURNS>
NspMod *Mat, int flag
</FUNCTION>
<FUNCTION>
<NAME>ModType</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ModShType</NAME>
<RETURNS>char  *</RETURNS>
NspMod *M
</FUNCTION>
<FUNCTION>
<NAME>ModLoopExtract</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>ModObjEq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>ModObjNeq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLMOD</NAME>
#define NULLMOD (NspMod *) 0
</MACRO>
<FUNCTION>
<NAME>ModFullComp</NAME>
<RETURNS>int  </RETURNS>
NspMod * A,NspMod * B,char *op,int *err
</FUNCTION>
<FUNCTION>
<NAME>ModCreate</NAME>
<RETURNS>NspMod  *</RETURNS>
char *name,char *dir,char *mname
</FUNCTION>
<FUNCTION>
<NAME>ModCopy</NAME>
<RETURNS>NspMod  *</RETURNS>
NspMod *H
</FUNCTION>
<FUNCTION>
<NAME>ModDestroy</NAME>
<RETURNS>void  </RETURNS>
NspMod *H
</FUNCTION>
<FUNCTION>
<NAME>ModInfo</NAME>
<RETURNS>void  </RETURNS>
NspMod *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>ModPrint</NAME>
<RETURNS>void  </RETURNS>
NspMod *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>ModEnter</NAME>
<RETURNS>int  </RETURNS>
NspMod *H,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>ModEnterCopy</NAME>
<RETURNS>int  </RETURNS>
NspMod *H,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>ModDelete</NAME>
<RETURNS>void  </RETURNS>
NspMod *H,char *str
</FUNCTION>
<FUNCTION>
<NAME>ModFind</NAME>
<RETURNS>int  </RETURNS>
NspMod *H,char *str,NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>ModFindCopy</NAME>
<RETURNS>int  </RETURNS>
NspMod *H,char *str,NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>ModMerge</NAME>
<RETURNS>int  </RETURNS>
NspMod *H1,NspMod*H2
</FUNCTION>
<FUNCTION>
<NAME>ModNextObj</NAME>
<RETURNS>int  </RETURNS>
NspMod *H,int *i,  NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>ModFill</NAME>
<RETURNS>int  </RETURNS>
NspMod *Mo
</FUNCTION>
<STRUCT>
<NAME>nsp_gframe</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_gframe</NAME>
struct nsp_gframe {
  NspList *objs ;       /* Object of type list: list of internal objects */
  BCG *Xgc;
  double scale[4];  /* the scales */
  double r[4] ;     /* frame position in its father */
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspGframe</NAME>
struct NspGframe {
  /*< private >*/
  NspObject father; 
  NspTypeGFrame *type; 
  /*< public >*/
  nsp_gframe *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_gframe_id</NAME>
extern int nsp_type_gframe_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_gframe</NAME>
extern NspTypeGFrame *nsp_type_gframe;
</VARIABLE>
<FUNCTION>
<NAME>new_type_gframe</NAME>
<RETURNS>NspTypeGFrame  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_gframe</NAME>
<RETURNS>NspGFrame  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLGFRAME</NAME>
#define NULLGFRAME (NspGFrame*) 0
</MACRO>
<FUNCTION>
<NAME>gframe_object</NAME>
<RETURNS>NspGFrame  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGFrameObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGFrameCopy</NAME>
<RETURNS>NspGFrame  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGFrame</NAME>
<RETURNS>NspGFrame  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsGFrame</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>gframe_path_extract</NAME>
<RETURNS>NspObject  *</RETURNS>
NspGFrame *H, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>gframe_create</NAME>
<RETURNS>NspGFrame  *</RETURNS>
char *name,BCG *Xgc,int init_objs,const double scale[],double r[],NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>gframe_draw</NAME>
<RETURNS>void  </RETURNS>
NspGFrame *R
</FUNCTION>
<FUNCTION>
<NAME>gframe_select_obj</NAME>
<RETURNS>int  </RETURNS>
NspGFrame *R, const double *pt, NspObject **Objs,NspObject *exclude
</FUNCTION>
<FUNCTION>
<NAME>gframe_select_lock</NAME>
<RETURNS>int  </RETURNS>
NspGFrame *F,double pt[2], NspObject **O, int *cp, int *lock_c
</FUNCTION>
<FUNCTION>
<NAME>gframe_select_and_move</NAME>
<RETURNS>int  </RETURNS>
NspGFrame *R, const double *pt
</FUNCTION>
<FUNCTION>
<NAME>gframe_select_and_hilite</NAME>
<RETURNS>int  </RETURNS>
NspGFrame *R,const double pt[2]
</FUNCTION>
<STRUCT>
<NAME>NspLmo</NAME>
</STRUCT>
<STRUCT>
<NAME>NspLmo</NAME>
struct NspLmo {
  /*< private >*/
  NspObject father; 
  NspTypeLmo *type; 
  /*< public >*/
  char *path;  
  char *module;
} ;
</STRUCT>
<VARIABLE>
<NAME>nsp_type_lmo_id</NAME>
extern int nsp_type_lmo_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_lmo</NAME>
extern NspTypeLmo *nsp_type_lmo;
</VARIABLE>
<FUNCTION>
<NAME>new_type_lmo</NAME>
<RETURNS>NspTypeLmo  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_lmo</NAME>
<RETURNS>NspLmo  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>LmoType</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>LmoShType</NAME>
<RETURNS>char  *</RETURNS>
NspLmo *M
</FUNCTION>
<FUNCTION>
<NAME>LmoLoopExtract</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>LmoObjEq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>LmoObjNeq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLLMO</NAME>
#define NULLLMO ( NspLmo *) 0 
</MACRO>
<FUNCTION>
<NAME>module_path_search_name</NAME>
<RETURNS>NspObject  *</RETURNS>
NspList *L,NspSMatrix *Sm,char **oname
</FUNCTION>
<FUNCTION>
<NAME>module_path_search_object</NAME>
<RETURNS>NspObject  *</RETURNS>
NspList *L,NspSMatrix *Sm,char **oname
</FUNCTION>
<STRUCT>
<NAME>NspNone</NAME>
</STRUCT>
<STRUCT>
<NAME>NspNone</NAME>
struct NspNone {
  /*< private >*/
  NspObject father; 
  NspTypeNone *type; 
  /*< public >*/
  
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_none_id</NAME>
extern int nsp_type_none_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_none</NAME>
extern NspTypeNone *nsp_type_none;
</VARIABLE>
<FUNCTION>
<NAME>new_type_none</NAME>
<RETURNS>NspTypeNone  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_none</NAME>
<RETURNS>NspNone  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLNONE</NAME>
#define NULLNONE (NspNone*) 0
</MACRO>
<FUNCTION>
<NAME>none_create</NAME>
<RETURNS>NspNone  *</RETURNS>
char *name,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>none_copy</NAME>
<RETURNS>NspNone  *</RETURNS>
NspNone *H
</FUNCTION>
<FUNCTION>
<NAME>none_destroy</NAME>
<RETURNS>void  </RETURNS>
NspNone *H
</FUNCTION>
<FUNCTION>
<NAME>none_info</NAME>
<RETURNS>void  </RETURNS>
NspNone *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>none_print</NAME>
<RETURNS>void  </RETURNS>
NspNone *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>none_object</NAME>
<RETURNS>NspNone  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsNoneObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsNone</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetNoneCopy</NAME>
<RETURNS>NspNone  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetNone</NAME>
<RETURNS>NspNone  *</RETURNS>
Stack stack, int i
</FUNCTION>
<STRUCT>
<NAME>NspClassb</NAME>
struct NspClassb {
  NspClassA father; 
  NspTypeClassB *type; 
  int classb_color;
  int classb_thickness;
  NspMatrix *classb_val;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_classb_id</NAME>
extern int nsp_type_classb_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_classb</NAME>
extern NspTypeClassB *nsp_type_classb;
</VARIABLE>
<FUNCTION>
<NAME>new_type_classb</NAME>
<RETURNS>NspTypeClassB  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_classb</NAME>
<RETURNS>NspClassB  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCLB</NAME>
#define NULLCLB (NspClassB*) 0
</MACRO>
<FUNCTION>
<NAME>classb_create</NAME>
<RETURNS>NspClassB  *</RETURNS>
char *name,int color,int thickness,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>classb_copy</NAME>
<RETURNS>NspClassB  *</RETURNS>
NspClassB *H
</FUNCTION>
<FUNCTION>
<NAME>classb_destroy</NAME>
<RETURNS>void  </RETURNS>
NspClassB *H
</FUNCTION>
<FUNCTION>
<NAME>classb_info</NAME>
<RETURNS>void  </RETURNS>
NspClassB *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>classb_print</NAME>
<RETURNS>void  </RETURNS>
NspClassB *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>classb_object</NAME>
<RETURNS>NspClassB  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsClassBObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsClassB</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetClassBCopy</NAME>
<RETURNS>NspClassB  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetClassB</NAME>
<RETURNS>NspClassB  *</RETURNS>
Stack stack, int i
</FUNCTION>
<MACRO>
<NAME>HAVE_INLINE</NAME>
#define HAVE_INLINE 1
</MACRO>
<MACRO>
<NAME>HAVE_VALUES_H</NAME>
#define HAVE_VALUES_H 1
</MACRO>
<MACRO>
<NAME>HAVE_FLOAT_H</NAME>
#define HAVE_FLOAT_H 1
</MACRO>
<MACRO>
<NAME>HAVE_LIMITS_H</NAME>
#define HAVE_LIMITS_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_TIME_H</NAME>
#define HAVE_SYS_TIME_H 1
</MACRO>
<MACRO>
<NAME>WTU</NAME>
#define WTU 1
</MACRO>
<MACRO>
<NAME>USE_SHARP_SIGN</NAME>
#define USE_SHARP_SIGN 1
</MACRO>
<MACRO>
<NAME>HAVE_EXP10</NAME>
#define HAVE_EXP10 1
</MACRO>
<MACRO>
<NAME>HAVE_TGAMMA</NAME>
#define HAVE_TGAMMA 1
</MACRO>
<MACRO>
<NAME>HAVE_LGAMMA</NAME>
#define HAVE_LGAMMA 1
</MACRO>
<MACRO>
<NAME>HAVE_GETWD</NAME>
#define HAVE_GETWD 1
</MACRO>
<MACRO>
<NAME>HAVE_GETCWD</NAME>
#define HAVE_GETCWD 1
</MACRO>
<MACRO>
<NAME>HAVE_MKSTEMP</NAME>
#define HAVE_MKSTEMP 1
</MACRO>
<MACRO>
<NAME>HAVE_SLEEP</NAME>
#define HAVE_SLEEP 1
</MACRO>
<MACRO>
<NAME>HAVE_STRERROR</NAME>
#define HAVE_STRERROR 1
</MACRO>
<MACRO>
<NAME>HAVE_TERMCAP</NAME>
#define HAVE_TERMCAP 1
</MACRO>
<MACRO>
<NAME>HAVE_USLEEP</NAME>
#define HAVE_USLEEP 1
</MACRO>
<MACRO>
<NAME>HAVE_ISINF</NAME>
#define HAVE_ISINF 1
</MACRO>
<MACRO>
<NAME>HAVE_ISNAN</NAME>
#define HAVE_ISNAN 1
</MACRO>
<MACRO>
<NAME>HAVE_FINITE</NAME>
#define HAVE_FINITE 1
</MACRO>
<MACRO>
<NAME>WITH_PVM</NAME>
#define WITH_PVM 1
</MACRO>
<MACRO>
<NAME>WITH_GTKGLEXT</NAME>
#define WITH_GTKGLEXT 1
</MACRO>
<MACRO>
<NAME>WITH_GTKHTML</NAME>
#define WITH_GTKHTML 1
</MACRO>
<MACRO>
<NAME>WITH_FFTW3</NAME>
#define WITH_FFTW3 1
</MACRO>
<MACRO>
<NAME>WITH_SNDFILE</NAME>
#define WITH_SNDFILE 1
</MACRO>
<MACRO>
<NAME>WITH_ASOUND</NAME>
#define WITH_ASOUND 1
</MACRO>
<MACRO>
<NAME>WITH_GMP</NAME>
#define WITH_GMP 1
</MACRO>
<MACRO>
<NAME>POINTER_INT</NAME>
#define POINTER_INT 1
</MACRO>
<MACRO>
<NAME>NSP_INT_TO_POINTER</NAME>
#define NSP_INT_TO_POINTER(i) ((int *) (i))
</MACRO>
<MACRO>
<NAME>NSP_POINTER_TO_INT</NAME>
#define NSP_POINTER_TO_INT(i) ((int) (i))
</MACRO>
<MACRO>
<NAME>NSP_INT_TO_POINTER</NAME>
#define NSP_INT_TO_POINTER(i) ((int *) (long) (i))
</MACRO>
<MACRO>
<NAME>NSP_POINTER_TO_INT</NAME>
#define NSP_POINTER_TO_INT(i) ((int) (long) (i))
</MACRO>
<MACRO>
<NAME>CNAME</NAME>
#define CNAME(name1,name2) name1##name2
</MACRO>
<MACRO>
<NAME>CNAME</NAME>
#define CNAME(name1,name2) name1/**/name2
</MACRO>
<MACRO>
<NAME>C2F</NAME>
#define C2F(name) name##_
</MACRO>
<MACRO>
<NAME>F2C</NAME>
#define F2C(name) name##_
</MACRO>
<MACRO>
<NAME>C2F</NAME>
#define C2F(name) name/**/_
</MACRO>
<MACRO>
<NAME>F2C</NAME>
#define F2C(name) name/**/_
</MACRO>
<MACRO>
<NAME>C2F</NAME>
#define C2F(name) name
</MACRO>
<MACRO>
<NAME>F2C</NAME>
#define F2C(name) name
</MACRO>
<MACRO>
<NAME>exp10</NAME>
#define exp10(x) pow((double) 10.0,x)
</MACRO>
<FUNCTION>
<NAME>exp10</NAME>
<RETURNS>double  </RETURNS>
double
</FUNCTION>
<MACRO>
<NAME>getwd</NAME>
#define getwd(x) getcwd(x,1024) /* you must define char x[1024] */
</MACRO>
<TYPEDEF>
<NAME>integer</NAME>
typedef int integer;
</TYPEDEF>
<MACRO>
<NAME>DBL_EPSILON</NAME>
#   define  DBL_EPSILON             2.2204460492503131e-16
</MACRO>
<MACRO>
<NAME>DBL_MAX</NAME>
#   define  DBL_MAX                 1.7976931348623158e+308
</MACRO>
<MACRO>
<NAME>DBL_MIN</NAME>
#   define  DBL_MIN                 2.2250738585072014e-308
</MACRO>
<MACRO>
<NAME>SHRT_MAX</NAME>
#   define  SHRT_MAX                32767
</MACRO>
<MACRO>
<NAME>LONG_MAX</NAME>
#   define  LONG_MAX                2147483647
</MACRO>
<MACRO>
<NAME>MACHINE_RESOLUTION</NAME>
#   define  MACHINE_RESOLUTION      DBL_EPSILON
</MACRO>
<MACRO>
<NAME>LARGEST_REAL</NAME>
#   define  LARGEST_REAL            DBL_MAX
</MACRO>
<MACRO>
<NAME>SMALLEST_REAL</NAME>
#   define  SMALLEST_REAL           DBL_MIN
</MACRO>
<MACRO>
<NAME>LARGEST_SHORT_INTEGER</NAME>
#   define  LARGEST_SHORT_INTEGER   SHRT_MAX
</MACRO>
<MACRO>
<NAME>LARGEST_LONG_INTEGER</NAME>
#   define  LARGEST_LONG_INTEGER    LONG_MAX
</MACRO>
<STRUCT>
<NAME>NspPlist</NAME>
struct NspPlist {
  /*< private >*/
  NspObject father; 
  NspTypePList *type; 
  /*< public >*/
  char *file_name;  /* NULL or points to the function source file-name */
  PList D;          /* points to the parsed expression */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_plist_id</NAME>
extern int nsp_type_plist_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_plist</NAME>
extern NspTypePList *nsp_type_plist;
</VARIABLE>
<FUNCTION>
<NAME>new_type_plist</NAME>
<RETURNS>NspTypePList  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_plist</NAME>
<RETURNS>NspPList  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>NspPListSize</NAME>
<RETURNS>int  </RETURNS>
NspPList *Mat, int flag
</FUNCTION>
<FUNCTION>
<NAME>NspPListType</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>NspPListShType</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>NspPListLoopExtract</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>NspPListObjEq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>NspPListObjNeq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>NspPListXdrLoad</NAME>
<RETURNS>NspPList  *</RETURNS>
XDR *xdrs
</FUNCTION>
<FUNCTION>
<NAME>NspPListXdrSave</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, NspPList *M
</FUNCTION>
<MACRO>
<NAME>NULLP_PLIST</NAME>
#define NULLP_PLIST (NspPList*) 0 
</MACRO>
<MACRO>
<NAME>NULLPLIST</NAME>
#define NULLPLIST (PList) 0 
</MACRO>
<FUNCTION>
<NAME>NspPListObj</NAME>
<RETURNS>NspPList  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsNspPListObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsNspPList</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetNspPListCopy</NAME>
<RETURNS>NspPList  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetNspPList</NAME>
<RETURNS>NspPList  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>NspPListCreate</NAME>
<RETURNS>NspPList  *</RETURNS>
char *name, PList L, char *filename
</FUNCTION>
<FUNCTION>
<NAME>NspPListCopy</NAME>
<RETURNS>NspPList  *</RETURNS>
NspPList *A
</FUNCTION>
<FUNCTION>
<NAME>NspPListDestroy</NAME>
<RETURNS>void  </RETURNS>
NspPList *P_L
</FUNCTION>
<FUNCTION>
<NAME>NspPListPrInt</NAME>
<RETURNS>void  </RETURNS>
NspPList *P_L
</FUNCTION>
<FUNCTION>
<NAME>NspPListInfo</NAME>
<RETURNS>void  </RETURNS>
NspPList *P_L, int indent
</FUNCTION>
<FUNCTION>
<NAME>NspPListPrint</NAME>
<RETURNS>void  </RETURNS>
NspPList *P_L, int indent
</FUNCTION>
<FUNCTION>
<NAME>NspPListSave</NAME>
<RETURNS>int  </RETURNS>
NspPList *P_L
</FUNCTION>
<FUNCTION>
<NAME>NspPList2SMatrix</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspPList *P_L, int indent
</FUNCTION>
<FUNCTION>
<NAME>ParseAdd</NAME>
<RETURNS>int  </RETURNS>
PList *plist, int op, int arity, int line
</FUNCTION>
<FUNCTION>
<NAME>ParseAddName</NAME>
<RETURNS>int  </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>ParseAddString</NAME>
<RETURNS>int  </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>ParseAddComment</NAME>
<RETURNS>int  </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>ParseAddList</NAME>
<RETURNS>int  </RETURNS>
PList *plist, PList *l
</FUNCTION>
<FUNCTION>
<NAME>ParseAppend</NAME>
<RETURNS>int  </RETURNS>
PList *plist, PList *l
</FUNCTION>
<FUNCTION>
<NAME>ParseAddList1</NAME>
<RETURNS>int  </RETURNS>
PList *plist, PList *l
</FUNCTION>
<FUNCTION>
<NAME>ParseAddDoubleI</NAME>
<RETURNS>int  </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>ParseAddDouble</NAME>
<RETURNS>int  </RETURNS>
PList *plist
</FUNCTION>
<FUNCTION>
<NAME>EPListCreate</NAME>
<RETURNS>PList  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>PListDestroy</NAME>
<RETURNS>void  </RETURNS>
PList *List
</FUNCTION>
<FUNCTION>
<NAME>PListCopy</NAME>
<RETURNS>PList  </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>Last</NAME>
<RETURNS>PList  </RETURNS>
PList plist
</FUNCTION>
<FUNCTION>
<NAME>PListPrInt_I</NAME>
<RETURNS>void  </RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>PListPrInt</NAME>
<RETURNS>void  </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>FirstEl</NAME>
<RETURNS>PList  </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>PrettyPrintOPname</NAME>
<RETURNS>int  </RETURNS>
int type, int indent, int pos
</FUNCTION>
<FUNCTION>
<NAME>PListPrettyPrint</NAME>
<RETURNS>void  </RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>ArgPrettyPrint</NAME>
<RETURNS>int  </RETURNS>
PList L, int i, int pos, int posret
</FUNCTION>
<FUNCTION>
<NAME>PListPrint</NAME>
<RETURNS>void  </RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>ArgPrint</NAME>
<RETURNS>void  </RETURNS>
PList L, int i
</FUNCTION>
<FUNCTION>
<NAME>PListInfo</NAME>
<RETURNS>void  </RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>ShowLine</NAME>
<RETURNS>void  </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>PListSave</NAME>
<RETURNS>int  </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>PListLoad</NAME>
<RETURNS>int  </RETURNS>
PList *L
</FUNCTION>
<FUNCTION>
<NAME>PList2SMatrix</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>plist_get_nargs</NAME>
<RETURNS>void  </RETURNS>
PList List,int *lhs , int *rhsp1
</FUNCTION>
<VARIABLE>
<NAME>debug</NAME>
extern int debug; 
</VARIABLE>
<VARIABLE>
<NAME>debugI</NAME>
extern int debugI;
</VARIABLE>
<MACRO>
<NAME>TBUF</NAME>
#define TBUF 1024
</MACRO>
<VARIABLE>
<NAME>Token</NAME>
extern Token_Obj Token ;
</VARIABLE>
<FUNCTION>
<NAME>IsSciKeyWord</NAME>
<RETURNS>int  </RETURNS>
char *id
</FUNCTION>
<FUNCTION>
<NAME>IsCodeKeyword</NAME>
<RETURNS>int  </RETURNS>
    int keyc
</FUNCTION>
<FUNCTION>
<NAME>Keycode2str</NAME>
<RETURNS>char  *</RETURNS>
int keyc
</FUNCTION>
<FUNCTION>
<NAME>OpCode2Str</NAME>
<RETURNS>char  *</RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>OpCode2NickN</NAME>
<RETURNS>char  *</RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>PrintOPname</NAME>
<RETURNS>int  </RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>TokenCode2Name</NAME>
<RETURNS>char  *</RETURNS>
int key
</FUNCTION>
<FUNCTION>
<NAME>SciGetLine</NAME>
<RETURNS>char  *</RETURNS>
char *prompt
</FUNCTION>
<VARIABLE>
<NAME>int_spminus</NAME>
extern function int_spminus;
</VARIABLE>
<VARIABLE>
<NAME>Datas</NAME>
extern NspList *Datas ;
</VARIABLE>
<FUNCTION>
<NAME>nsp_init_frames</NAME>
<RETURNS>int  </RETURNS>
int argc, char **argv
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_frame</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_delete</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frames_info</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_info</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frames_print</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_print</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_replace_object</NAME>
<RETURNS>int  </RETURNS>
 NspObject *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_replace_object</NAME>
<RETURNS>int  </RETURNS>
NspObject *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_frames_search_object</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_search_object</NAME>
<RETURNS>NspObject  *</RETURNS>
nsp_const_string  str
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_search_object</NAME>
<RETURNS>NspObject  *</RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_remove_object</NAME>
<RETURNS>void  </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_search_and_remove_object</NAME>
<RETURNS>NspObject  *</RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_remove_object</NAME>
<RETURNS>void  </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_search_and_move_up_object</NAME>
<RETURNS>int  </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_move_up_object</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_declare_global</NAME>
<RETURNS>int  </RETURNS>
char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_insert_hash_contents</NAME>
<RETURNS>int  </RETURNS>
NspHash *H
</FUNCTION>
<STRUCT>
<NAME>NspClassA</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeClassA</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>classa_save</NAME>
<RETURNS>int </RETURNS>
NspFile  *F, NspClassA *M
</USER_FUNCTION>
<STRUCT>
<NAME>NspTypeClassA</NAME>
struct NspTypeClassA { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>NspClassA</NAME>
struct NspClassA {
  /*< private >*/
  NspObject father; 
  NspTypeClassA *type; 
  /*< public >*/
  int classa_color;
  int classa_thickness;
  NspMatrix *classa_val;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_classa_id</NAME>
extern int nsp_type_classa_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_classa</NAME>
extern NspTypeClassA *nsp_type_classa;
</VARIABLE>
<FUNCTION>
<NAME>new_type_classa</NAME>
<RETURNS>NspTypeClassA  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_classa</NAME>
<RETURNS>NspClassA  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCLA</NAME>
#define NULLCLA (NspClassA*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_classa_create</NAME>
<RETURNS>NspClassA  *</RETURNS>
char *name,int color,int thickness,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_copy</NAME>
<RETURNS>NspClassA  *</RETURNS>
NspClassA *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_destroy</NAME>
<RETURNS>void  </RETURNS>
NspClassA *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_info</NAME>
<RETURNS>void  </RETURNS>
NspClassA *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_print</NAME>
<RETURNS>void  </RETURNS>
NspClassA *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_object</NAME>
<RETURNS>NspClassA  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsClassAObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsClassA</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetClassACopy</NAME>
<RETURNS>NspClassA  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetClassA</NAME>
<RETURNS>NspClassA  *</RETURNS>
Stack stack, int i
</FUNCTION>
<MACRO>
<NAME>SHREXT_NAME</NAME>
#define SHREXT_NAME ".dll"
</MACRO>
<MACRO>
<NAME>SHREXT_NAME</NAME>
#define SHREXT_NAME ".so"
</MACRO>
<FUNCTION>
<NAME>nsp_double2int</NAME>
<RETURNS>int  </RETURNS>
int *n, double *dx, int *ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_float2int</NAME>
<RETURNS>int  </RETURNS>
int *n, float *dx, int *ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_double2float</NAME>
<RETURNS>int  </RETURNS>
int *n, double *dx, float *rx
</FUNCTION>
<FUNCTION>
<NAME>nsp_int2double</NAME>
<RETURNS>int  </RETURNS>
int *n, int *idx, int *incx, double *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_int2float</NAME>
<RETURNS>int  </RETURNS>
int *n, int *idx, int *incx, float *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_float2double</NAME>
<RETURNS>int  </RETURNS>
int *n, float *rdx, int *incx, double *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_convert_double_to_type</NAME>
<RETURNS>int  </RETURNS>
double *x, int n, const char *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_convert_type_to_double</NAME>
<RETURNS>int  </RETURNS>
double *x, int n, const char *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_dset</NAME>
<RETURNS>int  </RETURNS>
const int *n, const double *dx, double *dy, const int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dadd</NAME>
<RETURNS>int  </RETURNS>
int *n, double *dx, int *incx, double *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dadd_maxplus</NAME>
<RETURNS>int  </RETURNS>
int *n, double *dx, int *incx, double *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dsub</NAME>
<RETURNS>int  </RETURNS>
int *n, double *dx, int *incx, double *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dsub_maxplus</NAME>
<RETURNS>int  </RETURNS>
int *n, double *dx, int *incx, double *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dsum</NAME>
<RETURNS>double  </RETURNS>
int *n, double *dx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_dvmul</NAME>
<RETURNS>int  </RETURNS>
int *n, double *dx, int *incx, double *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_icopy</NAME>
<RETURNS>int  </RETURNS>
const int *n, const int *idx, const int *incx, int *idy, const int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_iset</NAME>
<RETURNS>int  </RETURNS>
int *n, int *idx, int *idy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_iadd</NAME>
<RETURNS>int  </RETURNS>
int *n, int *ival, int *idy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dzcopy</NAME>
<RETURNS>int  </RETURNS>
const int *n, const double *zx, const int *incx, doubleC *zy, const int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dzscal</NAME>
<RETURNS>int  </RETURNS>
int *n, double *da, doubleC *zx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_dzset</NAME>
<RETURNS>int  </RETURNS>
int *n, double *dx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zadd</NAME>
<RETURNS>int  </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zadd_maxplus</NAME>
<RETURNS>int  </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>myzabs</NAME>
<RETURNS>double  </RETURNS>
double real, double imag
</FUNCTION>
<FUNCTION>
<NAME>nsp_zasum</NAME>
<RETURNS>double  </RETURNS>
int *n, doubleC *zx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_zsub</NAME>
<RETURNS>int  </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zsub_maxplus</NAME>
<RETURNS>int  </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zsum</NAME>
<RETURNS>void  </RETURNS>
doubleC *ret_val, int *n, doubleC *zx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_zvmul</NAME>
<RETURNS>int  </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_urand</NAME>
<RETURNS>double  </RETURNS>
int *iy
</FUNCTION>
<FUNCTION>
<NAME>nsp_magic_matrix_fill</NAME>
<RETURNS>void  </RETURNS>
double *m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_franck_matrix</NAME>
<RETURNS>void  </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_franck_inverse_matrix</NAME>
<RETURNS>void  </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_hilbert_matrix</NAME>
<RETURNS>void  </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_hilbert_inverse_matrix</NAME>
<RETURNS>void  </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_complex2double</NAME>
<RETURNS>void  </RETURNS>
double *tab, int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_double2complex</NAME>
<RETURNS>void  </RETURNS>
 double *tab, int size
</FUNCTION>
<FUNCTION>
<NAME>new_nsp_string</NAME>
<RETURNS>nsp_string  </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_basic_to_string</NAME>
<RETURNS>nsp_string  </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_copy</NAME>
<RETURNS>nsp_string  </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_destroy</NAME>
<RETURNS>void  </RETURNS>
nsp_string *str
</FUNCTION>
<FUNCTION>
<NAME>new_nsp_string_n</NAME>
<RETURNS>nsp_string  </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_resize</NAME>
<RETURNS>int  </RETURNS>
nsp_string *hstr, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_to_utf8</NAME>
<RETURNS>nsp_string  </RETURNS>
nsp_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_abs_c</NAME>
<RETURNS>double  </RETURNS>
const  doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_arg_c</NAME>
<RETURNS>double  </RETURNS>
 const doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_polar_c</NAME>
<RETURNS>void  </RETURNS>
 double r,double t,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_conj_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_norm_c</NAME>
<RETURNS>double  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_cos_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_cosh_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_exp_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_log_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_cc</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,const doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_cd</NAME>
<RETURNS>void  </RETURNS>
 const doubleC *x, double y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_dc</NAME>
<RETURNS>void  </RETURNS>
 double x, const doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_sin_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_sinh_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_div_cc</NAME>
<RETURNS>void  </RETURNS>
 const doubleC *x,doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_div_dc</NAME>
<RETURNS>void  </RETURNS>
 double x,const doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_ci</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *xe, int y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqrt_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_prod_c</NAME>
<RETURNS>void  </RETURNS>
 doubleC *x,const doubleC *y
</FUNCTION>
<FUNCTION>
<NAME>nsp_isnan_c</NAME>
<RETURNS>double  </RETURNS>
const  doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_isinf_c</NAME>
<RETURNS>double  </RETURNS>
const  doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_finite_c</NAME>
<RETURNS>double  </RETURNS>
 const doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_acos_c</NAME>
<RETURNS>void  </RETURNS>
 const doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_acosh_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_asin_c</NAME>
<RETURNS>void  </RETURNS>
 const doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_asinh_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_atan_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_atanh_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_ceil_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_aint_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_floor_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_log10_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_round_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_signum_c</NAME>
<RETURNS>void  </RETURNS>
 const doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_tan_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_tanh_c</NAME>
<RETURNS>void  </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<MACRO>
<NAME>OK</NAME>
#define OK 0
</MACRO>
<MACRO>
<NAME>FAIL</NAME>
#define FAIL 1
</MACRO>
<MACRO>
<NAME>finite</NAME>
#define finite(x) _finite(x) 
</MACRO>
<MACRO>
<NAME>finite</NAME>
#define finite(x) FINITE_IS_UNDEFINED
</MACRO>
<MACRO>
<NAME>isnan</NAME>
#define isnan(x) _isnan(x)
</MACRO>
<MACRO>
<NAME>isnan</NAME>
#define isnan(x)  ISNAN_IS_UNDEFINED
</MACRO>
<MACRO>
<NAME>ISNAN</NAME>
#define ISNAN(x) isnan(x)
</MACRO>
<MACRO>
<NAME>Abs</NAME>
#define Abs(x) ( ( (x) >= 0) ? (x) : -( x) )
</MACRO>
<MACRO>
<NAME>Min</NAME>
#define Min(x,y)	(((x)<(y))?(x):(y))
</MACRO>
<MACRO>
<NAME>Max</NAME>
#define Max(x,y)	(((x)>(y))?(x):(y))
</MACRO>
<FUNCTION>
<NAME>Mini</NAME>
<RETURNS>double  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>Maxi</NAME>
<RETURNS>double  </RETURNS>

</FUNCTION>
<MACRO>
<NAME>PI0</NAME>
#define PI0 (int *) 0
</MACRO>
<MACRO>
<NAME>PD0</NAME>
#define PD0 (double *) 0
</MACRO>
<MACRO>
<NAME>SMDOUBLE</NAME>
#define SMDOUBLE 1.e-200 /* Smalest number to avoid dividing by zero */
</MACRO>
<MACRO>
<NAME>linint</NAME>
#define linint(x) ((int) floor(x + 0.5 )) 
</MACRO>
<MACRO>
<NAME>inint</NAME>
#define inint(x) ((int) floor(x + 0.5 ))  
</MACRO>
<MACRO>
<NAME>anint</NAME>
#define anint(x) rint(x) 
</MACRO>
<MACRO>
<NAME>aint</NAME>
#define aint(x) ((x>= 0 ) ? floor(x)  : ceil(x))
</MACRO>
<MACRO>
<NAME>d_nint</NAME>
#define d_nint(x) (x)>=0 ? floor(x + .5) : -floor(.5 - x)
</MACRO>
<FUNCTION>
<NAME>tgamma</NAME>
<RETURNS>double  </RETURNS>
double
</FUNCTION>
<MACRO>
<NAME>int16max</NAME>
#define int16max   0x7FFF
</MACRO>
<MACRO>
<NAME>uns16max</NAME>
#define uns16max   0xFFFF
</MACRO>
<MACRO>
<NAME>MALLOC</NAME>
#define MALLOC(x) malloc(((size_t) x))
</MACRO>
<MACRO>
<NAME>FREE</NAME>
#define FREE(x) {if (x  != NULL) { free((void *) x); x= NULL;};}
</MACRO>
<MACRO>
<NAME>REALLOC</NAME>
#define REALLOC(x,y) realloc((void *) x,(size_t) y)
</MACRO>
<MACRO>
<NAME>MALLOC</NAME>
#define MALLOC(x) malloc(((unsigned) x))
</MACRO>
<MACRO>
<NAME>FREE</NAME>
#define FREE(x) {if (x  != NULL) {free((char *) x); x = NULL;}}
</MACRO>
<MACRO>
<NAME>REALLOC</NAME>
#define REALLOC(x,y) realloc((char *) x,(unsigned) y)
</MACRO>
<MACRO>
<NAME>NVOID</NAME>
#define NVOID ""
</MACRO>
<MACRO>
<NAME>HAS_STDARG</NAME>
#  define HAS_STDARG
</MACRO>
<MACRO>
<NAME>M_PI</NAME>
#define M_PI    3.14159265358979323846 
</MACRO>
<MACRO>
<NAME>M_E</NAME>
#define M_E     2.7182818284590452354
</MACRO>
<MACRO>
<NAME>M_LOG10E</NAME>
#define M_LOG10E 0.43429448190325182765
</MACRO>
<FUNCTION>
<NAME>acosh</NAME>
<RETURNS>double  </RETURNS>
double
</FUNCTION>
<FUNCTION>
<NAME>asinh</NAME>
<RETURNS>double  </RETURNS>
double
</FUNCTION>
<FUNCTION>
<NAME>atanh</NAME>
<RETURNS>double  </RETURNS>
double
</FUNCTION>
<FUNCTION>
<NAME>nsp_dlamch</NAME>
<RETURNS>double  </RETURNS>
char *cmach
</FUNCTION>
<FUNCTION>
<NAME>nsp_timer</NAME>
<RETURNS>double  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_realtime</NAME>
<RETURNS>int  </RETURNS>
double *t
</FUNCTION>
<FUNCTION>
<NAME>nsp_realtime_init</NAME>
<RETURNS>int  </RETURNS>
 double *t,  double *scale
</FUNCTION>
<FUNCTION>
<NAME>nsp_stimer</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>nsp_sparse_triplet</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_sparse_triplet</NAME>
struct nsp_sparse_triplet { /* used in mexlib */
  int *Ap; /* m+ 1 */
  int *Ai; /* Aisize */
  double *Ax; /* Aisize */
  int m,n,Aisize; 
};
</STRUCT>
<STRUCT>
<NAME>NspSpmatrix</NAME>
struct NspSpmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeSpMatrix *type; 
  /*< public >*/
  char rc_type;        /* 'r' or 'i' : real or complex matrix */
  int m,n,mn;   /* mn should be removed since m*n can be bigger than int */
  SpRow **D; /* array of size m giving the Rows datas */
  char convert; /* 't' : the matrix is stored in triplet , 'n': triplet not used   */
  nsp_sparse_triplet triplet; 
} ;
</STRUCT>
<VARIABLE>
<NAME>nsp_type_spmatrix_id</NAME>
extern int nsp_type_spmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_spmatrix</NAME>
extern NspTypeSpMatrix *nsp_type_spmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_spmatrix_init</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_spmatrix</NAME>
<RETURNS>NspTypeSpMatrix  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_spmatrix</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_type_as_string</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_type_short_string</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>SpLoopExtract</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_eq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_neq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLSP</NAME>
#define NULLSP (  NspSpMatrix *) 0
</MACRO>
<FUNCTION>
<NAME>SpObj</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSpMatObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSpMat</NAME>
<RETURNS>int  </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSpCopy</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSp</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealSp</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_destroy</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_nnz</NAME>
<RETURNS>int  </RETURNS>
const NspSpMatrix *HMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_info</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *Sp, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_print</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *Sp, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_copy</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_object</NAME>
<RETURNS>NspSpMatrix    *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_create</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
char *name, char type, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_sparse</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
char *name,NspMatrix *RC, NspMatrix *Values, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_get</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, NspMatrix **RC, NspMatrix **Values
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_resize_row</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *Sp, int i, int n
</FUNCTION>
<FUNCTION>
<NAME>SpRowDestroy</NAME>
<RETURNS>void  </RETURNS>
SpRow *Row
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_redim</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_enlarge_rows</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *Sp, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_enlarge</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_concatr</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, NspSpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_concatd</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, NspSpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_concatdiag</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, NspSpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_store</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A, int r, int c, int col, NspSpMatrix *B, int r1, int c1
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_insert_elt</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, int i, int j, NspSpMatrix *B, int rb, int cb
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_delete_elt</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, int row, int col, int amin, int amax
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_get_elt</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *B, int i, int j
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_set_rowcol</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspSpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_set_row</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, NspMatrix *Inds, NspSpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_delete_cols</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_compress_row</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_delete_rows</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_extract</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_extract_elts</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_extract_cols</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_extract_rows</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_diag_extract</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_diag_set</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, NspSpMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_diag_create</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_mult</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, NspSpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_mult_matrix</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSpMatrix *A, NspMatrix *X
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_mult_scal</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, NspSpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_complexify</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_setr</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_seti</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, double d
</FUNCTION>
<FUNCTION>
<NAME>RowCountNonNull</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, int i
</FUNCTION>
<FUNCTION>
<NAME>CountNonNull</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_from_mat</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_to_mat</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSpMatrix *Sp
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_transpose</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
const NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>plus</NAME>
<RETURNS>double  </RETURNS>
double x, double y, double xi, double yi, double *ival, char type
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_add</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, NspSpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_sub</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, NspSpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_multtt</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, NspSpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_mult_scal</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, NspSpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spmatrix_op_scal</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSpMatrix *A, NspSpMatrix *B, int *flag, char op
</FUNCTION>
<FUNCTION>
<NAME>SpClean</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, int rhs, double epsa, double epsr
</FUNCTION>
<FUNCTION>
<NAME>SpMaxiMinitt_G</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSpMatrix *A, NspSpMatrix *B, int flag, int minmaxflag, int *err
</FUNCTION>
<FUNCTION>
<NAME>SpMaxitt</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSpMatrix *A, NspSpMatrix *B, int flag, int *err
</FUNCTION>
<FUNCTION>
<NAME>SpMinitt</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSpMatrix *A, NspSpMatrix *B, int flag, int *err
</FUNCTION>
<FUNCTION>
<NAME>SpRealPart</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpImagPart</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpSum</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>SpMaxi</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
NspSpMatrix *A, char *flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>SpEye</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>SpOnes</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>SpZeros</NAME>
<RETURNS>NspSpMatrix  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>SpAcos</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpAcosh</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpAsin</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpAsinh</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpAtan</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpAtanh</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpCeil</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>R_aint</NAME>
<RETURNS>double  </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>SpInt</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpFloor</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>R_anint</NAME>
<RETURNS>double  </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>SpRound</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpSign</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpTan</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpTanh</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpAbs</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpErf</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpArg</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpConj</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpCos</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpCosh</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpExpEl</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpLogEl</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpSin</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpSinh</NAME>
<RETURNS>void  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpSqrtEl</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpMinus</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>SpFind</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *A, int lhs, NspMatrix **Res1, NspMatrix **Res2
</FUNCTION>
<FUNCTION>
<NAME>nsp_sparse_update_from_triplet</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_sparse_set_triplet_from_m</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *M,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_sparse_alloc_col_triplet</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *M,int nzmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_sparse_realloc_col_triplet</NAME>
<RETURNS>int  </RETURNS>
NspSpMatrix *M,int nzmax
</FUNCTION>
<STRUCT>
<NAME>NspSmatrix</NAME>
struct NspSmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeSMatrix *type; 
  /*< public >*/
  int m,n,mn;
  nsp_string *S;  /* a table of mn+1 strings the last one is NULL */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_smatrix_id</NAME>
extern int nsp_type_smatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_smatrix</NAME>
extern NspTypeSMatrix *nsp_type_smatrix;
</VARIABLE>
<FUNCTION>
<NAME>new_type_smatrix</NAME>
<RETURNS>NspTypeSMatrix  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_smatrix</NAME>
<RETURNS>NspSMatrix  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_type_as_string</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_type_short_string</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_loop_extract</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_eq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_neq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_is_true</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_xdr_load</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
XDR  *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_xdr_save</NAME>
<RETURNS>int  </RETURNS>
XDR  *F, NspSMatrix *M
</FUNCTION>
<MACRO>
<NAME>NULLSTRING</NAME>
#define NULLSTRING (nsp_string) 0
</MACRO>
<MACRO>
<NAME>NULLSMAT</NAME>
#define NULLSMAT   (NspSMatrix *) 0
</MACRO>
<FUNCTION>
<NAME>nsp_smatrix_object</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_object</NAME>
<RETURNS>char  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSMatObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSMat</NAME>
<RETURNS>int  </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsString</NAME>
<RETURNS>int  </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSMatCopy</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSMat</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetString</NAME>
<RETURNS>char  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetStringInArray</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int ith, char **Table, int flag
</FUNCTION>
<FUNCTION>
<NAME>GetStringInStruct</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int ith,void *T,unsigned int size, int flag
</FUNCTION>
<FUNCTION>
<NAME>is_string_in_array</NAME>
<RETURNS>int  </RETURNS>
const char *key, char **Table, int flag
</FUNCTION>
<FUNCTION>
<NAME>string_not_in_array</NAME>
<RETURNS>void  </RETURNS>
Stack stack,const char *key, char **Table,char *message
</FUNCTION>
<FUNCTION>
<NAME>is_string_in_struct</NAME>
<RETURNS>int  </RETURNS>
const char *key,void **Table,unsigned int size, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
nsp_const_string name,int m,int n,nsp_const_string str,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_with_length</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
nsp_const_string , int m, int n, int strl
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_from_table</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
char **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_from_array</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
nsp_const_string name,int n,const char **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_from_struct</NAME>
<RETURNS>NspSMatrix *</RETURNS>
nsp_const_string name,const void *T,unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_copy</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
const NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_resize</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_destroy</NAME>
<RETURNS>void  </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_info</NAME>
<RETURNS>void  </RETURNS>
const NspSMatrix *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_print</NAME>
<RETURNS>void  </RETURNS>
const NspSMatrix *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_redim</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_enlarge</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_right</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A,const NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>Scopy</NAME>
<RETURNS>int  </RETURNS>
int n, nsp_string *s1, nsp_string *s2
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_add_columns</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>Sset</NAME>
<RETURNS>int  </RETURNS>
int n, nsp_string s1, nsp_string *s2
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_down</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
const NspSMatrix *A,const NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_add_rows</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_set_submatrix</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A,const NspMatrix *Rows,const NspMatrix *Cols,const NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_set_rows</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, NspMatrix *Rows, NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_delete_columns</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_delete_rows</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_delete_elements</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_delete_elements2</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, NspMatrix *EltsR, NspMatrix *EltsC
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspSMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract_elements</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspSMatrix *A, NspMatrix *Elts, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract_columns</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspSMatrix *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>SMatLoopCol</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
char *str, NspSMatrix *Col, NspSMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract_rows</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspSMatrix *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_strings</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, NspSMatrix *B,nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_string_right</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, NspSMatrix *B, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_string_left</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, NspSMatrix *B, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strcmp</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSMatrix *A, NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_column_concat_padded</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspSMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_column_concat</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspSMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_row_concat</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspSMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_elts_concat</NAME>
<RETURNS>nsp_string  </RETURNS>
const NspSMatrix *A, nsp_const_string rstr, int rflag, nsp_const_string cstr, int cflag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_part</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspSMatrix *A, NspMatrix *Ind
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_elts_length</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_smatrix</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_tolower</NAME>
<RETURNS>void  </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_toupper</NAME>
<RETURNS>void  </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_capitalize</NAME>
<RETURNS>void  </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strstr</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSMatrix *A, nsp_const_string Str
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strindex</NAME>
<RETURNS>NspMatrix  *</RETURNS>
nsp_const_string Str,nsp_const_string Motif
</FUNCTION>
<FUNCTION>
<NAME>nsp_ascii_to_smatrix</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_to_ascii</NAME>
<RETURNS>NspMatrix  *</RETURNS>
nsp_const_string S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_sort_old</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspSMatrix *A,int flag,nsp_const_string  str1,nsp_const_string str2
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_split</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
nsp_const_string string, nsp_const_string splitChars, int msep
</FUNCTION>
<FUNCTION>
<NAME>nsp_row_smatrix_append_string</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>SMatCompOp</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspSMatrix *A, NspSMatrix *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>SMatFullComp</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A, NspSMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_transpose</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
const NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_subst</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
const NspSMatrix *A,nsp_const_string needle,nsp_const_string  replace
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strip_blanks</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_methods</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspObject *ob,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_read_lines</NAME>
<RETURNS>int  </RETURNS>
NspFile *F,NspSMatrix **S,int nlines
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_convert</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const char *name,NspSMatrix *A,const char *to_codeset,const char *from_codeset
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_to_utf8</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_utf8_validate</NAME>
<RETURNS>int  </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_utf8_from_unichar</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<VARIABLE>
<NAME>int_smxcreate</NAME>
extern function int_smxcreate;
</VARIABLE>
<VARIABLE>
<NAME>int_smxredim</NAME>
extern function int_smxredim;
</VARIABLE>
<VARIABLE>
<NAME>int_smxconcatr</NAME>
extern function int_smxconcatr;
</VARIABLE>
<VARIABLE>
<NAME>int_smxconcatr_m_s</NAME>
extern function int_smxconcatr_m_s;
</VARIABLE>
<VARIABLE>
<NAME>int_smxconcatd</NAME>
extern function int_smxconcatd;
</VARIABLE>
<VARIABLE>
<NAME>int_smxconcatd_m_s</NAME>
extern function int_smxconcatd_m_s;
</VARIABLE>
<VARIABLE>
<NAME>int_smxconcatdiag</NAME>
extern function int_smxconcatdiag;
</VARIABLE>
<VARIABLE>
<NAME>int_smxaddcols</NAME>
extern function int_smxaddcols;
</VARIABLE>
<VARIABLE>
<NAME>int_smxaddrows</NAME>
extern function int_smxaddrows;
</VARIABLE>
<VARIABLE>
<NAME>int_smxsetrc</NAME>
extern function int_smxsetrc;
</VARIABLE>
<VARIABLE>
<NAME>int_smxdeletecols</NAME>
extern function int_smxdeletecols;
</VARIABLE>
<VARIABLE>
<NAME>int_smxdeleterows</NAME>
extern function int_smxdeleterows;
</VARIABLE>
<VARIABLE>
<NAME>int_smxdeleteelts</NAME>
extern function int_smxdeleteelts;
</VARIABLE>
<VARIABLE>
<NAME>int_smxextract</NAME>
extern function int_smxextract;
</VARIABLE>
<VARIABLE>
<NAME>int_smxextractelts</NAME>
extern function int_smxextractelts;
</VARIABLE>
<VARIABLE>
<NAME>int_smxextractcols</NAME>
extern function int_smxextractcols;
</VARIABLE>
<VARIABLE>
<NAME>int_smxextractrows</NAME>
extern function int_smxextractrows;
</VARIABLE>
<VARIABLE>
<NAME>int_smxextractcolforloop</NAME>
extern function int_smxextractcolforloop;
</VARIABLE>
<VARIABLE>
<NAME>int_smxresize</NAME>
extern function int_smxresize;
</VARIABLE>
<VARIABLE>
<NAME>int_smxinfo</NAME>
extern function int_smxinfo;
</VARIABLE>
<VARIABLE>
<NAME>int_smxprint</NAME>
extern function int_smxprint;
</VARIABLE>
<VARIABLE>
<NAME>int_smxconcattt</NAME>
extern function int_smxconcattt;
</VARIABLE>
<VARIABLE>
<NAME>int_smxcomp</NAME>
extern function int_smxcomp;
</VARIABLE>
<VARIABLE>
<NAME>int_smxconcat</NAME>
extern function int_smxconcat;
</VARIABLE>
<VARIABLE>
<NAME>int_smxpart</NAME>
extern function int_smxpart;
</VARIABLE>
<VARIABLE>
<NAME>int_smxlength</NAME>
extern function int_smxlength;
</VARIABLE>
<VARIABLE>
<NAME>int_smxm2sm</NAME>
extern function int_smxm2sm;
</VARIABLE>
<VARIABLE>
<NAME>int_smxtoupper</NAME>
extern function int_smxtoupper;
</VARIABLE>
<VARIABLE>
<NAME>int_smxtolower</NAME>
extern function int_smxtolower;
</VARIABLE>
<VARIABLE>
<NAME>int_smxcapitalize</NAME>
extern function int_smxcapitalize;
</VARIABLE>
<VARIABLE>
<NAME>int_smxisalnum</NAME>
extern function int_smxisalnum;
</VARIABLE>
<VARIABLE>
<NAME>int_smxisalpha</NAME>
extern function int_smxisalpha;
</VARIABLE>
<VARIABLE>
<NAME>int_smxisascii</NAME>
extern function int_smxisascii;
</VARIABLE>
<VARIABLE>
<NAME>int_smxisdigit</NAME>
extern function int_smxisdigit;
</VARIABLE>
<VARIABLE>
<NAME>int_smxisgraph</NAME>
extern function int_smxisgraph;
</VARIABLE>
<VARIABLE>
<NAME>int_smxislower</NAME>
extern function int_smxislower;
</VARIABLE>
<VARIABLE>
<NAME>int_smxisprint</NAME>
extern function int_smxisprint;
</VARIABLE>
<VARIABLE>
<NAME>int_smxispunct</NAME>
extern function int_smxispunct;
</VARIABLE>
<VARIABLE>
<NAME>int_smxisspace</NAME>
extern function int_smxisspace;
</VARIABLE>
<VARIABLE>
<NAME>int_smxisupper</NAME>
extern function int_smxisupper;
</VARIABLE>
<VARIABLE>
<NAME>int_smxisxdigit</NAME>
extern function int_smxisxdigit;
</VARIABLE>
<VARIABLE>
<NAME>int_smxstrstr</NAME>
extern function int_smxstrstr;
</VARIABLE>
<VARIABLE>
<NAME>int_smxstrindex</NAME>
extern function int_smxstrindex;
</VARIABLE>
<VARIABLE>
<NAME>int_smxenlarge</NAME>
extern function int_smxenlarge;
</VARIABLE>
<VARIABLE>
<NAME>int_smxascii</NAME>
extern function int_smxascii;
</VARIABLE>
<VARIABLE>
<NAME>int_smxsort</NAME>
extern function int_smxsort;
</VARIABLE>
<VARIABLE>
<NAME>int_smxsplit</NAME>
extern function int_smxsplit;
</VARIABLE>
<VARIABLE>
<NAME>int_smxlt</NAME>
extern function int_smxlt;
</VARIABLE>
<VARIABLE>
<NAME>int_smxle</NAME>
extern function int_smxle;
</VARIABLE>
<VARIABLE>
<NAME>int_smxneq</NAME>
extern function int_smxneq;
</VARIABLE>
<VARIABLE>
<NAME>int_smxeq</NAME>
extern function int_smxeq;
</VARIABLE>
<VARIABLE>
<NAME>int_smxgt</NAME>
extern function int_smxgt;
</VARIABLE>
<VARIABLE>
<NAME>int_smxge</NAME>
extern function int_smxge;
</VARIABLE>
<VARIABLE>
<NAME>int_smxflt</NAME>
extern function int_smxflt;
</VARIABLE>
<VARIABLE>
<NAME>int_smxfle</NAME>
extern function int_smxfle;
</VARIABLE>
<VARIABLE>
<NAME>int_smxfneq</NAME>
extern function int_smxfneq;
</VARIABLE>
<VARIABLE>
<NAME>int_smxfeq</NAME>
extern function int_smxfeq;
</VARIABLE>
<VARIABLE>
<NAME>int_smxfgt</NAME>
extern function int_smxfgt;
</VARIABLE>
<VARIABLE>
<NAME>int_smxfge</NAME>
extern function int_smxfge;
</VARIABLE>
<VARIABLE>
<NAME>int_smxtranspose</NAME>
extern function int_smxtranspose;
</VARIABLE>
<VARIABLE>
<NAME>int_smxsubst</NAME>
extern function int_smxsubst;
</VARIABLE>
<VARIABLE>
<NAME>int_smxstripblanks</NAME>
extern function int_smxstripblanks;
</VARIABLE>
<STRUCT>
<NAME>NspList</NAME>
</STRUCT>
<STRUCT>
<NAME>NspList</NAME>
struct NspList {
  /*< private >*/
  NspObject father; 
  NspTypeList *type; 
  /*< public >*/
  Cell *first;        /* pointer to the first cell */
  Cell *last;         /* pointer to the last cell */
  Cell *current;      /* pointer to the current cell */
  int nel;            /* number of list elements */
  int icurrent;       /* index of the current cell */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_list_id</NAME>
extern int nsp_type_list_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_list</NAME>
extern NspTypeList *nsp_type_list;
</VARIABLE>
<FUNCTION>
<NAME>new_type_list</NAME>
<RETURNS>NspTypeList  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_list</NAME>
<RETURNS>NspList  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLLIST</NAME>
#define NULLLIST ( NspList *) 0 
</MACRO>
<MACRO>
<NAME>NULLCELL</NAME>
#define NULLCELL ( Cell *) 0 
</MACRO>
<MACRO>
<NAME>NULLOBJ</NAME>
#define NULLOBJ  ( NspObject *) 0 
</MACRO>
<FUNCTION>
<NAME>nsp_list_path_extract</NAME>
<RETURNS>NspObject  *</RETURNS>
NspList *L, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_object</NAME>
<RETURNS>NspList  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsListObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsList</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetListCopy</NAME>
<RETURNS>NspList  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetList</NAME>
<RETURNS>NspList  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>ListFollowExtract</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>EvalMacro</NAME>
<RETURNS>NspObject  *</RETURNS>
NspPList *, NspObject **, NspList *, int *
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_create</NAME>
<RETURNS>NspList  *</RETURNS>
char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_cell_create</NAME>
<RETURNS>Cell  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_cell_destroy</NAME>
<RETURNS>void  </RETURNS>
Cell **c
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_destroy</NAME>
<RETURNS>void  </RETURNS>
NspList *l
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_copy</NAME>
<RETURNS>NspList  *</RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_extract</NAME>
<RETURNS>NspList  *</RETURNS>
NspList *L, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_insert</NAME>
<RETURNS>int  </RETURNS>
NspList *L, NspObject *O, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_get_element</NAME>
<RETURNS>NspObject  *</RETURNS>
NspList *L, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_begin_insert</NAME>
<RETURNS>int  </RETURNS>
NspList *L, NspObject *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_end_insert</NAME>
<RETURNS>int  </RETURNS>
NspList *L, NspObject *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_remove_first</NAME>
<RETURNS>void  </RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_remove_last</NAME>
<RETURNS>void  </RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_store</NAME>
<RETURNS>int  </RETURNS>
NspList *L, NspObject *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_delete_elt_by_name</NAME>
<RETURNS>void  </RETURNS>
NspList *L, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_delete_elt</NAME>
<RETURNS>int  </RETURNS>
NspList *L, int nel
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_delete_cell</NAME>
<RETURNS>int  </RETURNS>
NspList *L, int nel
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_length</NAME>
<RETURNS>int  </RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_concat</NAME>
<RETURNS>int  </RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_info</NAME>
<RETURNS>void  </RETURNS>
NspList *L, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_print</NAME>
<RETURNS>void  </RETURNS>
NspList *L, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_cell_only_destroy</NAME>
<RETURNS>void  </RETURNS>
Cell **c
</FUNCTION>
<FUNCTION>
<NAME>nsp_sorted_list_search</NAME>
<RETURNS>NspObject  *</RETURNS>
NspList *L, nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_sorted_list_search_and_remove</NAME>
<RETURNS>NspObject  *</RETURNS>
NspList *L,nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_sorted_list_insert</NAME>
<RETURNS>int  </RETURNS>
NspList *L, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_map</NAME>
<RETURNS>NspList  *</RETURNS>
NspList *L, NspPList *PL, NspList *args
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_fold_right</NAME>
<RETURNS>NspObject  *</RETURNS>
NspList *L, NspPList *PL, NspList *args
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_equal</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_not_equal</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_full_equal</NAME>
<RETURNS>int  </RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_full_not_equal</NAME>
<RETURNS>int  </RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_compact</NAME>
<RETURNS>int  </RETURNS>
NspList *L1, char flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_get_cell_pointer</NAME>
<RETURNS>Cell  *</RETURNS>
NspList *L, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_unique</NAME>
<RETURNS>NspList  *</RETURNS>
NspList *L, NspMatrix **Ind, NspMatrix **Occ
</FUNCTION>
<MACRO>
<NAME>VERSION</NAME>
#define VERSION "scilab-2.7-CVS-2002-11-04"
</MACRO>
<MACRO>
<NAME>DEFAULT_MES</NAME>
#define DEFAULT_MES "scilab-2.7-CVS-2002-11-04 Scilab Group (Inria, Enpc)"
</MACRO>
<STRUCT>
<NAME>nsp_num_formats</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_num_formats</NAME>
struct nsp_num_formats {
  char curr_real_fmt[128];/* Current format string for real numbers and the real part of complex numbers. */
  int curr_real_fw; 
  char curr_imag_fmt[128];/*Current format string for the imaginary part of complex numbers. */
  int  curr_imag_fw;  /*Nonzero means don't do any fancy formatting. */
  int free_format;   /*Nonzero means print plus sign for nonzero, blank for zero. */
  int plus_format;   /*Nonzero means always print like dollars and cents. */
  int bank_format;   /*Nonzero means always print in latex syntax */
  int latex_format;  /* used with latex_format to add the fact that output is for texmacs */
  int latex_texmacs_format;  /*Nonzero means use an e format. */
  int print_e;   /*Nonzero means print E instead of e for exponent field. */
  int print_big_e;
};
</STRUCT>
<USER_FUNCTION>
<NAME>nsp_it_next</NAME>
<RETURNS>int </RETURNS>
const void *,double *,doubleC *,int *
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>nsp_it_init</NAME>
<RETURNS>char </RETURNS>
const void *,int *
</USER_FUNCTION>
<FUNCTION>
<NAME>gen_any_element_is_negative</NAME>
<RETURNS>int  </RETURNS>
const void *M, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<FUNCTION>
<NAME>gen_any_element_is_inf_or_nan</NAME>
<RETURNS>int  </RETURNS>
const void *M, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<FUNCTION>
<NAME>gen_all_elements_are_int_or_inf_or_nan</NAME>
<RETURNS>int  </RETURNS>
const void *M, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<FUNCTION>
<NAME>gen_pr_min_max_internal</NAME>
<RETURNS>void  </RETURNS>
const void *M, char flag, double *dmin, double *dmax, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<USER_FUNCTION>
<NAME>Mijfloat</NAME>
<RETURNS>void </RETURNS>
const nsp_num_formats *fmt,const void *,int i,int j
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_gen_matrix_as_read_syntax</NAME>
<RETURNS>void  </RETURNS>
const nsp_num_formats *fmt,const void *m, int nr, int nc, int inc,int indent, Mijfloat F
</FUNCTION>
<USER_FUNCTION>
<NAME>it_gen_f</NAME>
<RETURNS>int </RETURNS>
const void *
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>pr_mima</NAME>
<RETURNS>void </RETURNS>
const void *,char,double *,double *
</USER_FUNCTION>
<FUNCTION>
<NAME>gen_set_format</NAME>
<RETURNS>void  </RETURNS>
nsp_num_formats *fmt,void *M, it_gen_f is_neg, it_gen_f is_inf_or_nan, pr_mima min_max,it_gen_f all_iin, nsp_it_init Init
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_float</NAME>
<RETURNS>void  </RETURNS>
const nsp_num_formats *fmt,double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_imag_float</NAME>
<RETURNS>void  </RETURNS>
const nsp_num_formats *fmt,double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_complex</NAME>
<RETURNS>void  </RETURNS>
const nsp_num_formats *fmt,doubleC c
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_white</NAME>
<RETURNS>void  </RETURNS>
int fw
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_empty_matrix</NAME>
<RETURNS>void  </RETURNS>
int nr, int nc
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_any_float</NAME>
<RETURNS>void  </RETURNS>
const char *fmt, double d, int fw
</FUNCTION>
<FUNCTION>
<NAME>nsp_init_pr_format</NAME>
<RETURNS>void  </RETURNS>
nsp_num_formats *fmt
</FUNCTION>
<STRUCT>
<NAME>NspFile</NAME>
</STRUCT>
<STRUCT>
<NAME>NspFile</NAME>
struct NspFile {
  /*< private >*/
  NspObject father; 
  NspTypeSciFile *type; 
  /*< public >*/
  FILE *file ;   /* the file */
  XDR  xdrs[1];  /* xdr struture */
  int  flag;     /* flag for special open (xdr) */
  char openf[4]; /* flags used in fopen */
  char *fname;  /* file name */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_file_id</NAME>
extern int nsp_type_file_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_file</NAME>
extern NspTypeSciFile *nsp_type_file;
</VARIABLE>
<FUNCTION>
<NAME>new_type_file</NAME>
<RETURNS>NspTypeSciFile  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_file</NAME>
<RETURNS>NspFile  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_file_create</NAME>
<RETURNS>NspFile  *</RETURNS>
char *name, char *fname, char *str, int flag, FILE *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_copy</NAME>
<RETURNS>NspFile  *</RETURNS>
NspFile *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_destroy</NAME>
<RETURNS>void  </RETURNS>
NspFile *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_info</NAME>
<RETURNS>void  </RETURNS>
NspFile *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_print</NAME>
<RETURNS>void  </RETURNS>
NspFile *H, int indent,char *name, int rec_level
</FUNCTION>
<MACRO>
<NAME>OPEN_MASK</NAME>
#define OPEN_MASK 0x000f 
</MACRO>
<MACRO>
<NAME>XDR_MASK</NAME>
#define XDR_MASK 0x00f0 
</MACRO>
<MACRO>
<NAME>SWAP_MASK</NAME>
#define SWAP_MASK 0x0f00 
</MACRO>
<MACRO>
<NAME>SWAP_ON</NAME>
#define SWAP_ON(flag) (flag |= (1 << 8) )
</MACRO>
<MACRO>
<NAME>SWAP_OFF</NAME>
#define SWAP_OFF(flag) (flag &= ~SWAP_MASK )
</MACRO>
<MACRO>
<NAME>XDR_ON</NAME>
#define XDR_ON(flag)  (flag |= (1 << 4 ) )
</MACRO>
<MACRO>
<NAME>XDR_OFF</NAME>
#define XDR_OFF(flag)  (flag &= ~XDR_MASK )
</MACRO>
<MACRO>
<NAME>OPEN_ON</NAME>
#define OPEN_ON(flag)  (flag |= (1  ) )
</MACRO>
<MACRO>
<NAME>OPEN_OFF</NAME>
#define OPEN_OFF(flag)  (flag &= ~OPEN_MASK )
</MACRO>
<MACRO>
<NAME>IS_OPENED</NAME>
#define IS_OPENED(flag) ( flag & OPEN_MASK )
</MACRO>
<MACRO>
<NAME>IS_XDR</NAME>
#define IS_XDR(flag) ( flag & XDR_MASK)
</MACRO>
<MACRO>
<NAME>USE_SWAP</NAME>
#define USE_SWAP(flag) ( flag & SWAP_MASK) 
</MACRO>
<MACRO>
<NAME>NULLSCIFILE</NAME>
#define NULLSCIFILE (NspFile *) 0
</MACRO>
<FUNCTION>
<NAME>nsp_file_object</NAME>
<RETURNS>NspFile  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSciFileObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSciFileCopy</NAME>
<RETURNS>NspFile  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSciFile</NAME>
<RETURNS>NspFile  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_open</NAME>
<RETURNS>NspFile  *</RETURNS>
char *fname, char *mode,int xdr_on,int swap_on
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_close</NAME>
<RETURNS>int  </RETURNS>
NspFile *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_open_xdr_r</NAME>
<RETURNS>NspFile  *</RETURNS>
char *fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_close_xdr_r</NAME>
<RETURNS>int  </RETURNS>
NspFile *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_open_xdr_w</NAME>
<RETURNS>NspFile  *</RETURNS>
char *fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_close_xdr_w</NAME>
<RETURNS>int  </RETURNS>
NspFile *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_d</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_d</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, double *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_i</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, int ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_i</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, int *ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_c</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, char c
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_c</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, char *c
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_array_i</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, int *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_array_i</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, int *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_array_d</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, double *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_array_d</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, double *nx, int mn
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_string</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_string</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, char *buf, int buf_len
</FUNCTION>
<FUNCTION>
<NAME>is_little_endian</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_feof</NAME>
<RETURNS>int  </RETURNS>
NspFile *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_ferror</NAME>
<RETURNS>int  </RETURNS>
NspFile *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_clearerr</NAME>
<RETURNS>void  </RETURNS>
NspFile *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_fseek</NAME>
<RETURNS>int  </RETURNS>
NspFile *F,long int offset,const char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_ftell</NAME>
<RETURNS>int  </RETURNS>
NspFile *F,long int *offset
</FUNCTION>
<FUNCTION>
<NAME>nsp_mput</NAME>
<RETURNS>int  </RETURNS>
NspFile *F,void *x,int n, char *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_mget</NAME>
<RETURNS>int  </RETURNS>
NspFile *F,void *x,int n,const char *type, int *items_read
</FUNCTION>
<FUNCTION>
<NAME>nsp_mgetstr</NAME>
<RETURNS>int  </RETURNS>
NspFile *F, char **start, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mgetstr1</NAME>
<RETURNS>int  </RETURNS>
NspFile *F, char *start, int n, int *n_read
</FUNCTION>
<FUNCTION>
<NAME>nsp_putstr</NAME>
<RETURNS>int  </RETURNS>
NspFile *F, char *str
</FUNCTION>
<FUNCTION>
<NAME>do_printf</NAME>
<RETURNS>int  </RETURNS>
char *fname,FILE * fp, char *format,Stack stack,int n_args,int arg_cnt,int line, char **strv
</FUNCTION>
<FUNCTION>
<NAME>do_scanf</NAME>
<RETURNS>int  </RETURNS>
char *command,FILE *fp,char *format,Stack stack,int iline, int *nargs,char *strv,int *retval
</FUNCTION>
<MACRO>
<NAME>INTERSIZ</NAME>
#define INTERSIZ 256
</MACRO>
<ENUM>
<NAME>mxComplexity</NAME>
typedef enum { mxREAL, mxCOMPLEX } mxComplexity; 
</ENUM>
<TYPEDEF>
<NAME>bool</NAME>
typedef int bool;
</TYPEDEF>
<FUNCTION>
<NAME>nsp_mex_wrapper</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int rhs, int opt, int lhs,mexfun *mexFunction
</FUNCTION>
<FUNCTION>
<NAME>mxGetPr</NAME>
<RETURNS>double  *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetPi</NAME>
<RETURNS>double  *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetM</NAME>
<RETURNS>int  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetN</NAME>
<RETURNS>int  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsString</NAME>
<RETURNS>int  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsNumeric</NAME>
<RETURNS>int  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsFull</NAME>
<RETURNS>int  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsSparse</NAME>
<RETURNS>int  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsComplex</NAME>
<RETURNS>int  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetScalar</NAME>
<RETURNS>double  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mexErrMsgTxt</NAME>
<RETURNS>void  </RETURNS>
char *error_msg
</FUNCTION>
<FUNCTION>
<NAME>mxCreateFull</NAME>
<RETURNS>mxArray  *</RETURNS>
int m, int n, int it
</FUNCTION>
<FUNCTION>
<NAME>mxCreateDoubleMatrix</NAME>
<RETURNS>mxArray  *</RETURNS>
int m, int n,  mxComplexity it
</FUNCTION>
<FUNCTION>
<NAME>mxCalloc</NAME>
<RETURNS>void  *</RETURNS>
unsigned int n, unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>mxGetString</NAME>
<RETURNS>int  </RETURNS>
const mxArray *ptr, char *str, int strl
</FUNCTION>
<FUNCTION>
<NAME>mxFreeMatrix</NAME>
<RETURNS>void  </RETURNS>
mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxFree</NAME>
<RETURNS>void  </RETURNS>
void *ptr
</FUNCTION>
<FUNCTION>
<NAME>mexAtExit</NAME>
<RETURNS>int  </RETURNS>
void (*ExitFcn)(void)
</FUNCTION>
<FUNCTION>
<NAME>mxCreateSparse</NAME>
<RETURNS>mxArray  *</RETURNS>
int m, int n, int nzmax,mxComplexity ComplexFlag
</FUNCTION>
<FUNCTION>
<NAME>mxCreateString</NAME>
<RETURNS>mxArray  *</RETURNS>
char *string
</FUNCTION>
<FUNCTION>
<NAME>mxGetJc</NAME>
<RETURNS>int  *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetIr</NAME>
<RETURNS>int  *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsChar</NAME>
<RETURNS>bool  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetNumberOfDimensions</NAME>
<RETURNS>int  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetNumberOfFields</NAME>
<RETURNS>int  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetNumberOfElements</NAME>
<RETURNS>int  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsStruct</NAME>
<RETURNS>bool  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateStructMatrix</NAME>
<RETURNS>mxArray  *</RETURNS>
int m, int n, int nfields, const char **field_names
</FUNCTION>
<FUNCTION>
<NAME>mxGetInf</NAME>
<RETURNS>double  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxGetNaN</NAME>
<RETURNS>double  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxGetEps</NAME>
<RETURNS>double  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxIsInf</NAME>
<RETURNS>bool  </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>mxIsFinite</NAME>
<RETURNS>bool  </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>mxIsNaN</NAME>
<RETURNS>bool  </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>mxGetScalar</NAME>
<RETURNS>double  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetField</NAME>
<RETURNS>mxArray  *</RETURNS>
const mxArray *pa, int i, char *fieldname
</FUNCTION>
<FUNCTION>
<NAME>mxSetField</NAME>
<RETURNS>void  </RETURNS>
mxArray *pa, int i, const char *fieldname, mxArray *value
</FUNCTION>
<FUNCTION>
<NAME>mexWarnMsgTxt</NAME>
<RETURNS>void  </RETURNS>
char *error_msg
</FUNCTION>
<FUNCTION>
<NAME>mxIsCell</NAME>
<RETURNS>bool  </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetCell</NAME>
<RETURNS>mxArray  *</RETURNS>
const mxArray *ptr, int index
</FUNCTION>
<FUNCTION>
<NAME>mxSetCell</NAME>
<RETURNS>void  </RETURNS>
mxArray *array_ptr, int index, mxArray *value
</FUNCTION>
<FUNCTION>
<NAME>mxCreateCellMatrix</NAME>
<RETURNS>mxArray  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>mxArrayToString</NAME>
<RETURNS>char  *</RETURNS>
const mxArray *array_ptr
</FUNCTION>
<MACRO>
<NAME>mexPrintf</NAME>
#define mexPrintf Sciprintf
</MACRO>
<TYPEDEF>
<NAME>mxClassID</NAME>
typedef int  mxClassID;
</TYPEDEF>
<FUNCTION>
<NAME>mxGetClassID</NAME>
<RETURNS>mxClassID  </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<MACRO>
<NAME>mxUNKNOWN_CLASS</NAME>
#define  mxUNKNOWN_CLASS 0
</MACRO>
<MACRO>
<NAME>mxCELL_CLASS</NAME>
#define  mxCELL_CLASS  nsp_type_cells_id
</MACRO>
<MACRO>
<NAME>mxSTRUCT_CLASS</NAME>
#define  mxSTRUCT_CLASS  nsp_type_hash_id 
</MACRO>
<MACRO>
<NAME>mxCHAR_CLASS</NAME>
#define  mxCHAR_CLASS  nsp_type_smatrix_id
</MACRO>
<MACRO>
<NAME>mxLOGICAL_CLASS</NAME>
#define  mxLOGICAL_CLASS  nsp_type_bmatrix_id
</MACRO>
<MACRO>
<NAME>mxDOUBLE_CLASS</NAME>
#define  mxDOUBLE_CLASS  nsp_type_matrix_id
</MACRO>
<MACRO>
<NAME>mxSINGLE_CLASS</NAME>
#define  mxSINGLE_CLASS  -1 
</MACRO>
<MACRO>
<NAME>mxINT8_CLASS</NAME>
#define  mxINT8_CLASS  -1
</MACRO>
<MACRO>
<NAME>mxUINT8_CLASS</NAME>
#define  mxUINT8_CLASS  -1 
</MACRO>
<MACRO>
<NAME>mxINT16_CLASS</NAME>
#define  mxINT16_CLASS  -1
</MACRO>
<MACRO>
<NAME>mxUINT16_CLASS</NAME>
#define  mxUINT16_CLASS  -1
</MACRO>
<MACRO>
<NAME>mxINT32_CLASS</NAME>
#define  mxINT32_CLASS  -1
</MACRO>
<MACRO>
<NAME>mxUINT32_CLASS</NAME>
#define  mxUINT32_CLASS  -1
</MACRO>
<MACRO>
<NAME>mxINT64_CLASS</NAME>
#define  mxINT64_CLASS  -1
</MACRO>
<MACRO>
<NAME>mxUINT64_CLASS</NAME>
#define  mxUINT64_CLASS  -1;
</MACRO>
<MACRO>
<NAME>mxFUNCTION_CLASS</NAME>
#define  mxFUNCTION_CLASS  nsp_type_plist_id 
</MACRO>
<FUNCTION>
<NAME>mxMalloc</NAME>
<RETURNS>void  *</RETURNS>
size_t n
</FUNCTION>
<FUNCTION>
<NAME>mxDestroyArray</NAME>
<RETURNS>void  </RETURNS>
mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateCellArray</NAME>
<RETURNS>mxArray  *</RETURNS>
int ndim, const int *dims
</FUNCTION>
<FUNCTION>
<NAME>mxCalcSingleSubscript</NAME>
<RETURNS>int  </RETURNS>
const mxArray *array_ptr, int nsubs,const int *subs
</FUNCTION>
<FUNCTION>
<NAME>mexPutVariable</NAME>
<RETURNS>int  </RETURNS>
const char *workspace, const char *var_name,mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateCharMatrixFromStrings</NAME>
<RETURNS>mxArray  *</RETURNS>
int m, const char **str
</FUNCTION>
<FUNCTION>
<NAME>mexCallMATLAB</NAME>
<RETURNS>int  </RETURNS>
int nlhs, mxArray *plhs[], int nrhs,const  mxArray *prhs[], const char *command_name
</FUNCTION>
<MACRO>
<NAME>mexCallNsp</NAME>
#define mexCallNsp mexCallMATLAB
</MACRO>
<MACRO>
<NAME>mexCallScilab</NAME>
#define mexCallScilab mexCallMATLAB
</MACRO>
<FUNCTION>
<NAME>mxDuplicateArray</NAME>
<RETURNS>mxArray  *</RETURNS>
const mxArray *in
</FUNCTION>
<FUNCTION>
<NAME>mxSetName</NAME>
<RETURNS>void  </RETURNS>
mxArray *array_ptr,const char *var_name
</FUNCTION>
<FUNCTION>
<NAME>mexPutArray</NAME>
<RETURNS>int  </RETURNS>
 mxArray *array_ptr,const char *workspace
</FUNCTION>
<FUNCTION>
<NAME>mexEvalString</NAME>
<RETURNS>int  </RETURNS>
 char *command
</FUNCTION>
<FUNCTION>
<NAME>mxGetDimensions</NAME>
<RETURNS>int  *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxSetNzmax</NAME>
<RETURNS>int  </RETURNS>
 mxArray *array_ptr,int n
</FUNCTION>
<FUNCTION>
<NAME>mxGetNzmax</NAME>
<RETURNS>int  </RETURNS>
 mxArray *array_ptr
</FUNCTION>
<STRUCT>
<NAME>NspType</NAME>
</STRUCT>
<STRUCT>
<NAME>NspType</NAME>
struct NspType {
  /*< private >*/
  NspObject father; 
  NspTypeType *type; 
  /*< public >*/
  NspTypeBase *nsp_type;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_type_id</NAME>
extern int nsp_type_type_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_type</NAME>
extern NspTypeType *nsp_type_type;
</VARIABLE>
<FUNCTION>
<NAME>new_type_type</NAME>
<RETURNS>NspTypeType  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_type</NAME>
<RETURNS>NspType  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLTYPE</NAME>
#define NULLTYPE (NspType*) 0
</MACRO>
<FUNCTION>
<NAME>type_create</NAME>
<RETURNS>NspType  *</RETURNS>
char *name,NspTypeBase *type,NspTypeBase *derived_type
</FUNCTION>
<FUNCTION>
<NAME>type_copy</NAME>
<RETURNS>NspType  *</RETURNS>
NspType *H
</FUNCTION>
<FUNCTION>
<NAME>type_destroy</NAME>
<RETURNS>void  </RETURNS>
NspType *H
</FUNCTION>
<FUNCTION>
<NAME>type_info</NAME>
<RETURNS>void  </RETURNS>
NspType *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>type_print</NAME>
<RETURNS>void  </RETURNS>
NspType *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>type_object</NAME>
<RETURNS>NspType  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsTypeObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsType</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetTypeCopy</NAME>
<RETURNS>NspType  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetType</NAME>
<RETURNS>NspType  *</RETURNS>
Stack stack, int i
</FUNCTION>
<VARIABLE>
<NAME>nsp_types_hash_table</NAME>
extern NspHash *nsp_types_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_gtk_hash_table</NAME>
extern NspHash *nsp_gtk_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_atk_hash_table</NAME>
extern NspHash *nsp_atk_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_gdk_hash_table</NAME>
extern NspHash *nsp_gdk_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_pango_hash_table</NAME>
extern NspHash *nsp_pango_hash_table; 
</VARIABLE>
<FUNCTION>
<NAME>nsp_get_type_from_name</NAME>
<RETURNS>void  *</RETURNS>
char *name
</FUNCTION>
<FUNCTION>
<NAME>type_get_name</NAME>
<RETURNS>char  *</RETURNS>
void *type
</FUNCTION>
<TYPEDEF>
<NAME>M)</NAME>
typedef unsigned int matint_elt_size(void *M);
</TYPEDEF>
<MACRO>
<NAME>MAT_INT</NAME>
#define MAT_INT(t) ((NspTypeMatint *) t)
</MACRO>
<VARIABLE>
<NAME>nsp_type_matint_id</NAME>
extern int nsp_type_matint_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_matint</NAME>
extern NspTypeMatint *nsp_type_matint;
</VARIABLE>
<FUNCTION>
<NAME>new_type_matint</NAME>
<RETURNS>NspTypeMatint  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>matint_get_methods</NAME>
<RETURNS>NspMethods  *</RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>Boolean</NAME>
typedef int Boolean;
</TYPEDEF>
<STRUCT>
<NAME>NspBmatrix</NAME>
struct NspBmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeBMatrix *type; 
  /*< public >*/
  int m,n,mn;
  Boolean *B;	
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_bmatrix_id</NAME>
extern int nsp_type_bmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_bmatrix</NAME>
extern NspTypeBMatrix *nsp_type_bmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_bmatrix_init</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_bmatrix</NAME>
<RETURNS>NspTypeBMatrix  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_bmatrix_init</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_bmatrix_set</NAME>
<RETURNS>void  </RETURNS>
NspBMatrix *bmatrix, NspTypeBMatrix *type
</FUNCTION>
<FUNCTION>
<NAME>new_bmatrix</NAME>
<RETURNS>NspBMatrix  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLBMAT</NAME>
#define NULLBMAT (NspBMatrix*) 0
</MACRO>
<FUNCTION>
<NAME>BMatObj</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsBMatObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsBMat</NAME>
<RETURNS>int  </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetBMatCopy</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetBMat</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>BoolScalar</NAME>
<RETURNS>int  </RETURNS>
NspObject *O, Boolean *val
</FUNCTION>
<FUNCTION>
<NAME>GetScalarBool</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i, int *val
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_create</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
char *name, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_copy</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_resize</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_destroy</NAME>
<RETURNS>void  </RETURNS>
NspBMatrix *BMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_info</NAME>
<RETURNS>void  </RETURNS>
NspBMatrix *BMat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_print</NAME>
<RETURNS>void  </RETURNS>
NspBMatrix *BMat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_latex_print</NAME>
<RETURNS>void  </RETURNS>
NspBMatrix *BMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_latex_tab_print</NAME>
<RETURNS>void  </RETURNS>
NspBMatrix *BMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_redim</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_enlarge</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_concat_right</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_add_columns</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_concat_down</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBMatrix *A, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_concat_diag</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBMatrix *A, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_add_rows</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_set_submatrix</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_set_rows</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, NspMatrix *Rows, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_delete_columns</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_delete_rows</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_delete_elements</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_elements</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_columns</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBMatrix *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_rows</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>BMatLoopCol</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
char *str, NspBMatrix *Col, NspBMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_diag</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_set_diag</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A, NspBMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_create_diag</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_transpose</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_bmatrix</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_to_matrix</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspBMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>MatIsTrue</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_and</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_scalar_and</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_or</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_scalar_or</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_not</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>BMatIsTrue</NAME>
<RETURNS>int  </RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_count_true</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_find</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_find_2</NAME>
<RETURNS>int  </RETURNS>
const NspBMatrix *A, int lhs, NspMatrix **Res1, NspMatrix **Res2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_compare</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
const NspBMatrix *A, const NspBMatrix *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_full_compare</NAME>
<RETURNS>int  </RETURNS>
const NspBMatrix *A,const  NspBMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_comp</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspMatrix *A, NspMatrix *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_isinf</NAME>
<RETURNS>NspBMatrix   *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_isnan</NAME>
<RETURNS>NspBMatrix   *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_finite</NAME>
<RETURNS>NspBMatrix   *</RETURNS>
NspMatrix *A
</FUNCTION>
<STRUCT>
<NAME>NspMpmatrix</NAME>
struct NspMpmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeMaxpMatrix *type; 
  /*< public >*/
  int m,n,mn;/* NspMaxpMatrix dimensions */
  union { 
    double *R;     /* Pointer on real values */
    doubleC *C;    /* Pointer on complex values */
    int *I;    /* Pointer on integer values */
  };
  char rc_type;    /* 'r' : real or  'c' : complex  */
  char convert;    /* 'd','i','f' : double, int, float
		    * used to remember array converted in place */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_mpmatrix_id</NAME>
extern int nsp_type_mpmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_mpmatrix</NAME>
extern NspTypeMaxpMatrix *nsp_type_mpmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_mpmatrix_init</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_mpmatrix</NAME>
<RETURNS>NspTypeMaxpMatrix  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_mpmatrix</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLMAXPMAT</NAME>
#define NULLMAXPMAT (NspMaxpMatrix*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_mpmatrix_destroy</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_info</NAME>
<RETURNS>void  </RETURNS>
const NspMaxpMatrix *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_copy</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_print</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_loop_extract</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_copy</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_object</NAME>
<RETURNS>NspMaxpMatrix   *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_fullcomp</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_object</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsMpMatObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsMpMat</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatCopy</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMat</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatCopyInt</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatInt</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatCopyFloat</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatFloat</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopy_G</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMat_G</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopy</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMat</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopyInt</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatInt</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopyFloat</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatFloat</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>MpMatd2i</NAME>
<RETURNS>int  *</RETURNS>
NspMaxpMatrix *A, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>MpMat2double</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>MpMat2int</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>MpMat2float</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mp_matrix_from_m</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const char *name,NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const char *name, char type, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create_impl</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
double first, double step, double last
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create_from_doubles</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const char *name,int m,int n,...
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_fill_with</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_resize</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_scalar_to_mn</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_latex_print</NAME>
<RETURNS>void  </RETURNS>
const NspMaxpMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_latex_tab_print</NAME>
<RETURNS>void  </RETURNS>
const NspMaxpMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_redim</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_enlarge</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_concat_right</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_add_columns</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_concat_down</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const NspMaxpMatrix *A,const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_concat_diag</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const NspMaxpMatrix *A,const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_add_rows</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_set_submatrix</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_set_rows</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMatrix *Rows, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_delete_columns</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_delete_rows</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_delete_elements</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Rows,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_elements</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_columns</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_rows</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>MpMatLoopCol</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
char *str, NspMaxpMatrix *Col, NspMaxpMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_diag</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const NspMaxpMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_set_diag</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create_diag</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const NspMaxpMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_transpose</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
const NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_set_rval</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_set_ival</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_add</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_dadd</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_add_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sub</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_dsub</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sub_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_subs_calarm</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_clean</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A, int rhs, double epsa, double epsr
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_maxitt1</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B, NspMaxpMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_minitt1</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B, NspMaxpMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_slec</NAME>
<RETURNS>NspMaxpMatrix  **</RETURNS>
char *file, int *Count
</FUNCTION>
<FUNCTION>
<NAME>MaxpMatLec</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
FILE *fd
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_readline</NAME>
<RETURNS>int  </RETURNS>
FILE *fd
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_complexify</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *Mat, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_get_real</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_get_imag</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_inv_el</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_kron</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sort</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A, int flag, char *str1, char *str2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sum</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_prod</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cum_prod</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cum_sum</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_maxi</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A, char *flag, NspMaxpMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mini</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMaxpMatrix *A, char *flag, NspMaxpMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_createinit</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
char *name, char type, int m, int n, double (*func) ()
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_triu</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_tril</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_eye</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ones</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_zeros</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_rand</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_tt</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_el</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_scalarm</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_div_tt</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_div_el</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_div_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_bdiv_tt</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_bdiv_el</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_bdiv_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult_tt</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult_el</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_acos</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_acosh</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_asin</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_asinh</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_atan</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_atan2</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A,NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_atanh</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ceil</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_modulo</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_idiv</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_int</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_floor</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_round</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sign</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_tan</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_tanh</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_abs</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_erf</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_erfc</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_arg</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_polar</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_iand</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_iandu</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ior</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ioru</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_conj</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cos</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cosh</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_expel</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_logel</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sin</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sinh</NAME>
<RETURNS>void  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sqrtel</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_minus</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_magic</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_franck</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
int n, int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_hilbert</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
int n,int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_fullcomp</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_find</NAME>
<RETURNS>int  </RETURNS>
NspMaxpMatrix *A, int lhs, NspMaxpMatrix **Res1, NspMaxpMatrix **Res2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_cast_to_matrix</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMaxpMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_cast_to_mpmatrix</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspMatrix *M
</FUNCTION>
<VARIABLE>
<NAME>int_bmatrix_b2m</NAME>
extern function int_bmatrix_b2m;
</VARIABLE>
<VARIABLE>
<NAME>int_bmatrix_setrc</NAME>
extern function int_bmatrix_setrc;
</VARIABLE>
<STRUCT>
<NAME>NspObject</NAME>
</STRUCT>
<STRUCT>
<NAME>AttrTab</NAME>
</STRUCT>
<STRUCT>
<NAME>NspMethods</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>print_fun</NAME>
<RETURNS>void </RETURNS>
void *
</USER_FUNCTION>
<STRUCT>
<NAME>NspTypeBase</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_TYPE_OBJECT__</NAME>
#define NSP_TYPE_OBJECT__ \
  NspTypeId id ;                      /* each type has a unique id */ \
  NspTypeBase *surtype;               /* type of parent */ \
  NspTypeBase *interface ;  	      /* chained types for interfaces */ \
  init_func *init ;		      /* initializer */ \
  new_func *new ;		      /* allocations */ \
  AttrTab *attrs; 		      /* attribute table */ \
  attrs_func *get_attrs;	      /* get attribute wrapper */ \
  attrs_func *set_attrs;	      /* get attribute wrapper */ \
  methods_func *methods;	      /* methods */ \

struct _NspTypeBase {
</MACRO>
<STRUCT>
<NAME>NspTypeObject</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeObject</NAME>
struct NspTypeObject {
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
  print_func *pr ;		      /* printing*/   
  dealloc_func *dealloc;              /* dealloc */  
  copy_func *copy ;                   /* copy object */  
  size_func *size ;                   /* m,n or m*n  */  
  s_type_func *s_type;                /* type as a String */  
  sh_type_func *sh_type;              /* type as a short string */  
  info_func *info;                    /* info */  
  set_name_func *set_name;            /* set name */  
  get_name_func *get_name;            /* get name */  
  is_true_func  *is_true;             /* check if object can be considered as true */  
  loop_func     *loop;                /* for loops */  
  path_func     *path_extract;        /* used for x(1)(2)(...) */  
  get_from_obj_func *get_from_obj;    /* get object stored in SciObj */  
  eq_func *eq ;                       /* equality check */  
  eq_func *neq ;                      /* non-equality check */
  save_func *save;                    /* file save */
  load_func *load;                    /* file load */
  create_func *create;	      	      /* creates a new object  */ 
};
</STRUCT>
<MACRO>
<NAME>NSP_TYPE_OBJECT</NAME>
#define NSP_TYPE_OBJECT(t) ((NspTypeObject *) t) 
</MACRO>
<MACRO>
<NAME>NSP_TYPE_BASE</NAME>
#define NSP_TYPE_BASE(t) ((NspTypeBase *) t) 
</MACRO>
<FUNCTION>
<NAME>nsp_new_type_id</NAME>
<RETURNS>NspTypeId  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>registered_types</NAME>
</STRUCT>
<STRUCT>
<NAME>registered_types</NAME>
struct registered_types {
  NspTypeObject  *type;
  struct _registered_types *next;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_types</NAME>
extern registered_types *nsp_types;
</VARIABLE>
<FUNCTION>
<NAME>nsp_register_type</NAME>
<RETURNS>int  </RETURNS>
void *type
</FUNCTION>
<VARIABLE>
<NAME>nsp_no_type_id</NAME>
extern int nsp_no_type_id; /* this can no be a type id : used in save/load */
</VARIABLE>
<FUNCTION>
<NAME>nsp_get_type_from_id</NAME>
<RETURNS>void  *</RETURNS>
NspTypeId id
</FUNCTION>
<ENUM>
<NAME>type_mode</NAME>
typedef enum { T_BASE, T_DERIVED } type_mode;
</ENUM>
<STRUCT>
<NAME>NspObject</NAME>
struct NspObject {
  char *name;			/* object name: must be first */
  NspTypeObject *type;
  NspTypeBase *basetype;        /* type of base child  */
  int  ret_pos ;                /* used to store return position from an interface */ 
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_object_id</NAME>
extern int nsp_type_object_id ;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_object</NAME>
extern NspTypeObject  *nsp_type_object;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_object_init</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<MACRO>
<NAME>NSP_OBJECT</NAME>
#define NSP_OBJECT(o) ((NspObject *) o) 
</MACRO>
<FUNCTION>
<NAME>new_type_object</NAME>
<RETURNS>NspTypeObject  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_object_set</NAME>
<RETURNS>void  </RETURNS>
NspObject *o,NspTypeObject *type
</FUNCTION>
<FUNCTION>
<NAME>new_object</NAME>
<RETURNS>NspObject   *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_object_init</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>check_cast</NAME>
<RETURNS>int  </RETURNS>
void *obj,NspTypeId id
</FUNCTION>
<MACRO>
<NAME>NSP_OBJECT_INLINED</NAME>
#define NSP_OBJECT_INLINED static inline 
</MACRO>
<FUNCTION>
<NAME>check_implements</NAME>
<RETURNS>NspTypeBase  *</RETURNS>
void *obj,NspTypeId id
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_load_def</NAME>
<RETURNS>NspObject  *</RETURNS>
void * F
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_save_def</NAME>
<RETURNS>int  </RETURNS>
void * F, NspObject * M
</FUNCTION>
<STRUCT>
<NAME>Stack</NAME>
</STRUCT>
<STRUCT>
<NAME>Stack</NAME>
struct Stack {
  char *fname; /* function currently evaluated **/
  char *file_name ; /* current evaluated file **/
  int first;   /* position of first argument to be used **/
  NspObject **D;     /* D is dynamically changed so that D[1] is the first Objet used XXX **/
  NspObject **L;     /* Last position **/
  NspObject **S;     /* points to the whole stack **/
  NspObject *error_msg; 
  stack_error *error;
  int errcatch; 
  int pause; 
  NspObject *symbols; /* table of symbols of functions */
} ;
</STRUCT>
<MACRO>
<NAME>STACK_SIZE</NAME>
#define STACK_SIZE 50000
</MACRO>
<VARIABLE>
<NAME>SciStack</NAME>
extern Stack SciStack ;
</VARIABLE>
<FUNCTION>
<NAME>StackInfo</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>InitStack</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_init_stack</NAME>
<RETURNS>void  </RETURNS>
Stack *stack,NspObject **S
</FUNCTION>
<FUNCTION>
<NAME>int_get_failed</NAME>
<RETURNS>NspObject  *</RETURNS>
NspObject *self, char *attr
</FUNCTION>
<FUNCTION>
<NAME>int_get_object_failed</NAME>
<RETURNS>NspObject  *</RETURNS>
NspObject *self, char *attr
</FUNCTION>
<FUNCTION>
<NAME>int_set_failed</NAME>
<RETURNS>int  </RETURNS>
NspObject *self,char *attr, NspObject *val
</FUNCTION>
<STRUCT>
<NAME>AttrTab</NAME>
struct AttrTab {
  char *name;
  attr_get_function *get;
  attr_set_function *set;
  attr_get_object_function *get_object;
};
</STRUCT>
<FUNCTION>
<NAME>attr_search</NAME>
<RETURNS>int  </RETURNS>
char *key,AttrTab Table[]
</FUNCTION>
<FUNCTION>
<NAME>int_check_attr</NAME>
<RETURNS>int  </RETURNS>
char *key,AttrTab attrs[],Stack stack,int rhs,int opt,int lhs
</FUNCTION>
<FUNCTION>
<NAME>attrs_to_stack</NAME>
<RETURNS>int  </RETURNS>
char *key,AttrTab attrs[],Stack stack,int pos
</FUNCTION>
<FUNCTION>
<NAME>set_attribute_util</NAME>
<RETURNS>int  </RETURNS>
NspObject *ob, NspTypeBase *type, char *attr,NspObject *val
</FUNCTION>
<FUNCTION>
<NAME>int_set_attribute</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_set_attributes</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_set_attributes1</NAME>
<RETURNS>int  </RETURNS>
void *Ob,Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_create_with_attributes</NAME>
<RETURNS>int  </RETURNS>
NspObject *ob,Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_attribute_util</NAME>
<RETURNS>int  </RETURNS>
NspObject *ob, NspTypeBase *type, char *attr,NspObject *val
</FUNCTION>
<FUNCTION>
<NAME>int_get_attribute</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_attribute_util</NAME>
<RETURNS>NspObject  *</RETURNS>
NspObject *ob,NspTypeBase *type,char *attr
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_attribute_object</NAME>
<RETURNS>NspObject  *</RETURNS>
NspObject *ob,NspTypeBase *type, char *attr
</FUNCTION>
<FUNCTION>
<NAME>object_path_extract</NAME>
<RETURNS>NspObject  *</RETURNS>
NspObject *a, NspObject *ob
</FUNCTION>
<STRUCT>
<NAME>NspMethods</NAME>
struct NspMethods {
  char *name;
  nsp_method *meth; 
};
</STRUCT>
<FUNCTION>
<NAME>method_search</NAME>
<RETURNS>int  </RETURNS>
char *key, NspMethods *Table
</FUNCTION>
<FUNCTION>
<NAME>nsp_exec_method_util</NAME>
<RETURNS>int  </RETURNS>
NspObject *ob,NspTypeBase *type,char *method, Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>ArgMessage</NAME>
<RETURNS>void  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>MaybeObjCopy</NAME>
<RETURNS>void  *</RETURNS>
NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_search_object</NAME>
<RETURNS>NspObject  *</RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_void_object_destroy</NAME>
<RETURNS>void  </RETURNS>
NspObject **O
</FUNCTION>
<MACRO>
<NAME>Ocheckname</NAME>
#define Ocheckname(x,y) ( strcmp( NSP_OBJECT(x)->name,y)==0 ) 
</MACRO>
<FUNCTION>
<NAME>nsp_create_empty_matrix_object</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_doubles</NAME>
<RETURNS>NspObject  *</RETURNS>
 int m,int n,int it,double *rtab,double *itab,char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_copy_and_name</NAME>
<RETURNS>NspObject  *</RETURNS>
char *name,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_xdr_save</NAME>
<RETURNS>int  </RETURNS>
XDR *F, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_xdr_load</NAME>
<RETURNS>NspObject  *</RETURNS>
XDR *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_destroy</NAME>
<RETURNS>void  </RETURNS>
NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_void_object_destroy</NAME>
<RETURNS>void  </RETURNS>
NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_copy</NAME>
<RETURNS>NspObject  *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_get_size</NAME>
<RETURNS>int  </RETURNS>
const NspObject *O, int j
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_copy_with_name</NAME>
<RETURNS>NspObject  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_copy_and_name</NAME>
<RETURNS>NspObject  *</RETURNS>
char *name, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_type_as_string</NAME>
<RETURNS>char  *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_type_short</NAME>
<RETURNS>char  *</RETURNS>
 NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_type</NAME>
<RETURNS>int  </RETURNS>
const NspObject *O, NspTypeId id
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_implements</NAME>
<RETURNS>int  </RETURNS>
NspObject *O, NspTypeId id
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_info</NAME>
<RETURNS>void  </RETURNS>
NspObject *O, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_print</NAME>
<RETURNS>void  </RETURNS>
NspObject *O, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_is_true</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_loop_extract</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>def_loop</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_object</NAME>
<RETURNS>NspObject  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_object_copy</NAME>
<RETURNS>NspObject  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_double</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_complex</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str,const doubleC *d
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_int</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, int ival
</FUNCTION>
<FUNCTION>
<NAME>nsp_complexi_object_</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_str</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_str_and_size</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, int lstr
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_doubles</NAME>
<RETURNS>NspObject  *</RETURNS>
int m, int n, int it, double *rtab, double *itab, char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_empty_matrix_object</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_true_object</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_boolean_object</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str,int val
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_false_object</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_get_name</NAME>
<RETURNS>char  *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_set_name</NAME>
<RETURNS>int  </RETURNS>
NspObject *O,const char *str
</FUNCTION>
<FUNCTION>
<NAME>print_count_rows</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int first_arg,int last_arg
</FUNCTION>
<STRUCT>
<NAME>NspMe</NAME>
</STRUCT>
<STRUCT>
<NAME>NspMe</NAME>
struct NspMe {
  /*< private >*/
  NspObject father; 
  NspTypeMe *type; 
  /*< public >*/
  char *path;  
  char *module;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_me_id</NAME>
extern int nsp_type_me_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_me</NAME>
extern NspTypeMe *nsp_type_me;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_me_init</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_me</NAME>
<RETURNS>NspTypeMe  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_me</NAME>
<RETURNS>NspMe  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>MeType</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>MeShType</NAME>
<RETURNS>char  *</RETURNS>
NspMe *M
</FUNCTION>
<FUNCTION>
<NAME>MeLoopExtract</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>MeObjEq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>MeObjNeq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLXME</NAME>
#define NULLXME (NspMe *) 0
</MACRO>
<FUNCTION>
<NAME>MeFullComp</NAME>
<RETURNS>int  </RETURNS>
NspMe * A,NspMe * B,char *op,int *err
</FUNCTION>
<FUNCTION>
<NAME>MeCreate</NAME>
<RETURNS>NspMe  *</RETURNS>
char *name
</FUNCTION>
<FUNCTION>
<NAME>MeCopy</NAME>
<RETURNS>NspMe  *</RETURNS>
NspMe *H
</FUNCTION>
<FUNCTION>
<NAME>MeDestroy</NAME>
<RETURNS>void  </RETURNS>
NspMe *H
</FUNCTION>
<FUNCTION>
<NAME>MeInfo</NAME>
<RETURNS>void  </RETURNS>
NspMe *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>MePrint</NAME>
<RETURNS>void  </RETURNS>
NspMe *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>MeObj</NAME>
<RETURNS>NspMe   *</RETURNS>
 NspObject *O
</FUNCTION>
<STRUCT>
<NAME>NspRect</NAME>
</STRUCT>
<STRUCT>
<NAME>NspRect</NAME>
struct NspRect {
  /*< private >*/
  NspObject father; 
  NspTypeRect *type; 
  /*< public >*/
  BCG *Xgc;
  double r[4];
  int color; 
  int thickness;
  int background;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_rect_id</NAME>
extern int nsp_type_rect_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_rect</NAME>
extern NspTypeRect *nsp_type_rect;
</VARIABLE>
<FUNCTION>
<NAME>new_type_rect</NAME>
<RETURNS>NspTypeRect  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_rect</NAME>
<RETURNS>NspRect  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLRECT</NAME>
#define NULLRECT (NspRect*) 0
</MACRO>
<FUNCTION>
<NAME>IsRectObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRectCopy</NAME>
<RETURNS>NspRect  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRect</NAME>
<RETURNS>NspRect  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsRect</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>rect_create</NAME>
<RETURNS>NspRect  *</RETURNS>
char *name,BCG *Xgc, double *rect, int color, int thickness, int background,NspTypeBase *
</FUNCTION>
<FUNCTION>
<NAME>RectDraw</NAME>
<RETURNS>void  </RETURNS>
NspRect *R
</FUNCTION>
<FUNCTION>
<NAME>RectTranslate</NAME>
<RETURNS>void  </RETURNS>
NspRect *R,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>RectResize</NAME>
<RETURNS>void  </RETURNS>
NspRect *R,const double size[2]
</FUNCTION>
<STRUCT>
<NAME>NspIvect</NAME>
struct NspIvect {
  /*< private >*/
  NspObject father; 
  NspTypeIVect *type; 
  /*< public >*/
  double first,step,last ; /* implicit bounds  */
  int flag ;               /* set to 1 if 1:$ or : else set to 0 */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_ivect_id</NAME>
extern int nsp_type_ivect_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_ivect</NAME>
extern NspTypeIVect *nsp_type_ivect;
</VARIABLE>
<FUNCTION>
<NAME>new_type_ivect</NAME>
<RETURNS>NspTypeIVect  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_ivect</NAME>
<RETURNS>NspIVect  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLIVECT</NAME>
#define NULLIVECT (NspIVect*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_ivect_object</NAME>
<RETURNS>NspIVect  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_create</NAME>
<RETURNS>NspIVect  *</RETURNS>
char *name, double first, double step, double last, int flag
</FUNCTION>
<FUNCTION>
<NAME>IsIVectF</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_copy</NAME>
<RETURNS>NspIVect  *</RETURNS>
NspIVect *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_destroy</NAME>
<RETURNS>void  </RETURNS>
NspIVect *IV
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_info</NAME>
<RETURNS>void  </RETURNS>
NspIVect *IV, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_print</NAME>
<RETURNS>void  </RETURNS>
NspIVect *IV, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_2_mat</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspIVect *IV
</FUNCTION>
<FUNCTION>
<NAME>IsIVect</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<STRUCT>
<NAME>NspFunction</NAME>
</STRUCT>
<STRUCT>
<NAME>NspFunction</NAME>
struct NspFunction {
  /*< private >*/
  NspObject father; 
  NspTypeFunction *type; 
  /*< public >*/
  char *fname; /* function name */
  int  pos;/* function position inside interface */
  int  iface;/* Interface number in which the function is stored */
  int  status;/* status of the function */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_function_id</NAME>
extern int nsp_type_function_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_function</NAME>
extern NspTypeFunction *nsp_type_function;
</VARIABLE>
<FUNCTION>
<NAME>new_type_function</NAME>
<RETURNS>NspTypeFunction  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_function</NAME>
<RETURNS>NspFunction  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLFUNC</NAME>
#define NULLFUNC (NspFunction*) 0
</MACRO>
<FUNCTION>
<NAME>function_create</NAME>
<RETURNS>NspFunction  *</RETURNS>
char *name,char *fname,int iface,int pos,int status,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>function_copy</NAME>
<RETURNS>NspFunction  *</RETURNS>
NspFunction *H
</FUNCTION>
<FUNCTION>
<NAME>function_destroy</NAME>
<RETURNS>void  </RETURNS>
NspFunction *H
</FUNCTION>
<FUNCTION>
<NAME>function_info</NAME>
<RETURNS>void  </RETURNS>
NspFunction *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>function_print</NAME>
<RETURNS>void  </RETURNS>
NspFunction *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>function_object</NAME>
<RETURNS>NspFunction  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsFunctionObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsFunction</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetFunctionCopy</NAME>
<RETURNS>NspFunction  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetFunction</NAME>
<RETURNS>NspFunction  *</RETURNS>
Stack stack, int i
</FUNCTION>
<MACRO>
<NAME>Widget</NAME>
#define Widget int
</MACRO>
<ENUM>
<NAME>menu_answer</NAME>
typedef enum { menu_ok , menu_cancel, menu_fail } menu_answer; 
</ENUM>
<FUNCTION>
<NAME>nsp_choose</NAME>
<RETURNS>menu_answer  </RETURNS>
NspSMatrix *Items,NspSMatrix *Title,NspSMatrix *button,int *nrep
</FUNCTION>
<FUNCTION>
<NAME>nsp_choose_</NAME>
<RETURNS>menu_answer  </RETURNS>
const char *title,char **Items,int nItems,char **but_names,int n_but,int *choice
</FUNCTION>
<FUNCTION>
<NAME>nsp_message</NAME>
<RETURNS>menu_answer  </RETURNS>
NspSMatrix *Message,NspSMatrix *Buttons,int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_message_modeless</NAME>
<RETURNS>menu_answer  </RETURNS>
NspSMatrix *Message,NspSMatrix *Buttons
</FUNCTION>
<FUNCTION>
<NAME>nsp_message_</NAME>
<RETURNS>menu_answer  </RETURNS>
char *message,char **buttons,int n_buttons,int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_message_modeless_</NAME>
<RETURNS>menu_answer  </RETURNS>
char *message
</FUNCTION>
<FUNCTION>
<NAME>nsp_choices_with_combobox</NAME>
<RETURNS>menu_answer  </RETURNS>
char *title,NspList *L,int use_table
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_dialog</NAME>
<RETURNS>int  </RETURNS>
char **print_command,int *type,int *orientation,int *format
</FUNCTION>
<FUNCTION>
<NAME>nsp_export_dialog</NAME>
<RETURNS>int  </RETURNS>
char **file,int *type,int *orientation,int *format
</FUNCTION>
<FUNCTION>
<NAME>nsp_dialog</NAME>
<RETURNS>menu_answer  </RETURNS>
NspSMatrix *title,NspSMatrix *init,NspObject **answer
</FUNCTION>
<FUNCTION>
<NAME>nsp_dialog1</NAME>
<RETURNS>menu_answer  </RETURNS>
const char *title,const char *init,char **answer
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_file_window</NAME>
<RETURNS>menu_answer  </RETURNS>
const char *title,const char *dirname,int action,char **file
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_filename_open</NAME>
<RETURNS>char  *</RETURNS>
const char *title,const char *dirname,char **filters
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_filename_save</NAME>
<RETURNS>char  *</RETURNS>
const char *title,const char *dirname
</FUNCTION>
<FUNCTION>
<NAME>nsp_multi_dialog_</NAME>
<RETURNS>menu_answer  </RETURNS>
const char *title,char **pszTitle, char **pszName,int nv
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_dialog</NAME>
<RETURNS>menu_answer  </RETURNS>
NspSMatrix *Title,NspSMatrix *Labels_v,NspSMatrix *Labels_h,NspSMatrix *Init_matrix,int menu_type,int entry_size
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_set</NAME>
<RETURNS>void  </RETURNS>
int win_num,const char *button_name,int ne
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_unset</NAME>
<RETURNS>void  </RETURNS>
int win_num,const char *button_name,int ne
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_delete_button</NAME>
<RETURNS>int  </RETURNS>
int win_num,const char *button_name
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_add</NAME>
<RETURNS>int  </RETURNS>
int win_num,const char * button_name,char ** entries,int ne,int typ,char *fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_gtkcombobox_colormap_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
 BCG *Xgc,int init_color
</FUNCTION>
<FUNCTION>
<NAME>gtkcombobox_select_color_in_table</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *table,int init_color
</FUNCTION>
<FUNCTION>
<NAME>gtkcombobox_select_color</NAME>
<RETURNS>int  </RETURNS>
BCG *Xgc,int init_color
</FUNCTION>
<FUNCTION>
<NAME>nsp_multi_dialog</NAME>
<RETURNS>menu_answer  </RETURNS>
NspSMatrix *Title,NspSMatrix *Labels,NspSMatrix *Init_values
</FUNCTION>
<FUNCTION>
<NAME>nsp_multi_dialog_</NAME>
<RETURNS>menu_answer  </RETURNS>
const char *title,char **pszTitle, char **pszName,int nv
</FUNCTION>
<FUNCTION>
<NAME>nsp_dialogs_insert_title</NAME>
<RETURNS>void  </RETURNS>
const char *title,GtkWidget *vbox
</FUNCTION>
<STRUCT>
<NAME>NspModule</NAME>
</STRUCT>
<STRUCT>
<NAME>NspModule</NAME>
struct NspModule {
  /*< private >*/
  NspObject father; 
  NspTypeModule *type; 
  /*< public >*/
  char *path ; /* absolute XXX path of the module */
  char *mname;  /* module name */
  NspHash *T;      /* hash table to store module objects of type me (module elts) */
  NspList *L;       /* List of submodules */
  int flag;     /* are we a copy ? */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_module_id</NAME>
extern int nsp_type_module_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_module</NAME>
extern NspTypeModule *nsp_type_module;
</VARIABLE>
<FUNCTION>
<NAME>new_type_module</NAME>
<RETURNS>NspTypeModule  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_module</NAME>
<RETURNS>NspModule  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLMODULE</NAME>
#define NULLMODULE (NspModule*) 0
</MACRO>
<FUNCTION>
<NAME>module_create</NAME>
<RETURNS>NspModule  *</RETURNS>
char *name,const char *path,const char *mname,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>module_copy</NAME>
<RETURNS>NspModule  *</RETURNS>
NspModule *H
</FUNCTION>
<FUNCTION>
<NAME>module_destroy</NAME>
<RETURNS>void  </RETURNS>
NspModule *H
</FUNCTION>
<FUNCTION>
<NAME>module_info</NAME>
<RETURNS>void  </RETURNS>
NspModule *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>module_print</NAME>
<RETURNS>void  </RETURNS>
NspModule *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>module_object</NAME>
<RETURNS>NspModule  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsModuleObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsModule</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetModuleCopy</NAME>
<RETURNS>NspModule  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetModule</NAME>
<RETURNS>NspModule  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>module_copy_ref</NAME>
<RETURNS>NspModule  *</RETURNS>
NspModule *Mod
</FUNCTION>
<FUNCTION>
<NAME>nsp_module_search_name</NAME>
<RETURNS>NspObject  *</RETURNS>
NspList *L,char **Mname
</FUNCTION>
<FUNCTION>
<NAME>nsp_insert_module_last</NAME>
<RETURNS>int  </RETURNS>
NspList *L,char *dir,char **Mname
</FUNCTION>
<FUNCTION>
<NAME>nsp_module_import</NAME>
<RETURNS>int  </RETURNS>
NspList *L,char *dir,char **Mname
</FUNCTION>
<MACRO>
<NAME>NUMBER</NAME>
#define NUMBER -1
</MACRO>
<MACRO>
<NAME>NAME</NAME>
#define NAME   -2
</MACRO>
<MACRO>
<NAME>PLIST</NAME>
#define PLIST   -3
</MACRO>
<MACRO>
<NAME>STRING</NAME>
#define STRING   -4
</MACRO>
<MACRO>
<NAME>EMPTYMAT</NAME>
#define EMPTYMAT -5
</MACRO>
<MACRO>
<NAME>COMMENT</NAME>
#define COMMENT  -6 
</MACRO>
<MACRO>
<NAME>EMPTYCELL</NAME>
#define EMPTYCELL  -38
</MACRO>
<MACRO>
<NAME>OPNAME</NAME>
#define OPNAME -30
</MACRO>
<MACRO>
<NAME>OBJECT</NAME>
#define OBJECT -39  
</MACRO>
<MACRO>
<NAME>NAME_MAXL</NAME>
#define NAME_MAXL 52
</MACRO>
<MACRO>
<NAME>WHILE</NAME>
#define WHILE   -7
</MACRO>
<MACRO>
<NAME>END</NAME>
#define END     -8
</MACRO>
<MACRO>
<NAME>SELECT</NAME>
#define SELECT  -9
</MACRO>
<MACRO>
<NAME>CASE</NAME>
#define CASE    -10
</MACRO>
<MACRO>
<NAME>QUIT</NAME>
#define QUIT    -11
</MACRO>
<MACRO>
<NAME>NSP_EXIT</NAME>
#define NSP_EXIT -12 
</MACRO>
<MACRO>
<NAME>PRETURN</NAME>
#define PRETURN -13
</MACRO>
<MACRO>
<NAME>HELP</NAME>
#define HELP    -14
</MACRO>
<MACRO>
<NAME>WHAT</NAME>
#define WHAT    -15
</MACRO>
<MACRO>
<NAME>WHO</NAME>
#define WHO     -16
</MACRO>
<MACRO>
<NAME>PAUSE</NAME>
#define PAUSE   -17
</MACRO>
<MACRO>
<NAME>CLEAR</NAME>
#define CLEAR   -18
</MACRO>
<MACRO>
<NAME>IF</NAME>
#define IF      -19
</MACRO>
<MACRO>
<NAME>THEN</NAME>
#define THEN    -20
</MACRO>
<MACRO>
<NAME>DO</NAME>
#define DO      -21
</MACRO>
<MACRO>
<NAME>APROPOS</NAME>
#define APROPOS -22
</MACRO>
<MACRO>
<NAME>ABORT</NAME>
#define ABORT   -23
</MACRO>
<MACRO>
<NAME>BREAK</NAME>
#define BREAK   -24
</MACRO>
<MACRO>
<NAME>ELSEIF</NAME>
#define ELSEIF  -25
</MACRO>
<MACRO>
<NAME>ELSE</NAME>
#define ELSE    -26
</MACRO>
<MACRO>
<NAME>FOR</NAME>
#define FOR     -27
</MACRO>
<MACRO>
<NAME>FUNCTION</NAME>
#define FUNCTION -28
</MACRO>
<MACRO>
<NAME>ENDFUNCTION</NAME>
#define ENDFUNCTION -29
</MACRO>
<MACRO>
<NAME>EXEC</NAME>
#define EXEC -31
</MACRO>
<MACRO>
<NAME>GLOBAL</NAME>
#define GLOBAL -32
</MACRO>
<MACRO>
<NAME>CLEARGLOBAL</NAME>
#define CLEARGLOBAL   -33
</MACRO>
<MACRO>
<NAME>TRYCATCH</NAME>
#define TRYCATCH    -34
</MACRO>
<MACRO>
<NAME>CATCH</NAME>
#define CATCH  -35 
</MACRO>
<MACRO>
<NAME>FINALLY</NAME>
#define FINALLY  -36 
</MACRO>
<MACRO>
<NAME>CONTINUE</NAME>
#define CONTINUE  -37
</MACRO>
<MACRO>
<NAME>NOTKEY</NAME>
#define NOTKEY  -40
</MACRO>
<MACRO>
<NAME>DOTSTAR</NAME>
#define DOTSTAR   ((((int) '*') << 7) + (int) '.' )
</MACRO>
<MACRO>
<NAME>DOTSLASH</NAME>
#define DOTSLASH  ((((int) '/') << 7) + (int) '.' )
</MACRO>
<MACRO>
<NAME>DOTBSLASH</NAME>
#define DOTBSLASH ((((int) '\\') << 7) + (int) '.' )
</MACRO>
<MACRO>
<NAME>STARDOT</NAME>
#define STARDOT   ((((int) '.') << 7) + (int) '*' )
</MACRO>
<MACRO>
<NAME>SLASHDOT</NAME>
#define SLASHDOT  ((((int) '.') << 7) + (int) '/' )
</MACRO>
<MACRO>
<NAME>BSLASHDOT</NAME>
#define BSLASHDOT ((((int) '.') << 7) + (int) '\\' )
</MACRO>
<MACRO>
<NAME>DOTSTARDOT</NAME>
#define DOTSTARDOT  (((int) '.') <<14 ) + (((int) '*') << 7) + (int) '.' 
</MACRO>
<MACRO>
<NAME>DOTSLASHDOT</NAME>
#define DOTSLASHDOT  (((int) '.') <<14 )+(((int) '/') << 7) + (int) '.' 
</MACRO>
<MACRO>
<NAME>DOTBSLASHDOT</NAME>
#define DOTBSLASHDOT (((int) '.') <<14 )+ (((int) '\\') << 7) + (int) '.'
</MACRO>
<MACRO>
<NAME>DOTHAT</NAME>
#define DOTHAT ((((int) '^') << 7) + (int) '.' )
</MACRO>
<MACRO>
<NAME>EQ</NAME>
#define EQ     ((((int) '=') << 7) + (int) '=' )
</MACRO>
<MACRO>
<NAME>LEQ</NAME>
#define LEQ    ((((int) '<') << 7) + (int) '=' )
</MACRO>
<MACRO>
<NAME>GEQ</NAME>
#define GEQ    ((((int) '>') << 7) + (int) '=' )
</MACRO>
<MACRO>
<NAME>NEQ</NAME>
#define NEQ    ((((int) '<') << 7) + (int) '>' )
</MACRO>
<MACRO>
<NAME>DOTEQ</NAME>
#define DOTEQ     ((((int) '=') << 14) + (((int) '=') << 7)  + (int) '.' )
</MACRO>
<MACRO>
<NAME>DOTLEQ</NAME>
#define DOTLEQ    ((((int) '<') << 14) + (((int) '=') << 7)  + (int) '.' )
</MACRO>
<MACRO>
<NAME>DOTLT</NAME>
#define DOTLT    ((((int) '<') << 7) +  (int) '.' )
</MACRO>
<MACRO>
<NAME>DOTGEQ</NAME>
#define DOTGEQ    ((((int) '>') << 14) + (((int) '=') << 7)  + (int) '.' )
</MACRO>
<MACRO>
<NAME>DOTGT</NAME>
#define DOTGT    ((((int) '>') << 7) +  (int) '.' )
</MACRO>
<MACRO>
<NAME>DOTNEQ</NAME>
#define DOTNEQ    ((((int) '<') << 14) + (((int) '>') << 7)  + (int) '.' )
</MACRO>
<MACRO>
<NAME>DOTPRIM</NAME>
#define DOTPRIM ((((int) '.') << 7) + (int) '\'' )
</MACRO>
<MACRO>
<NAME>MOINS</NAME>
#define MOINS   ((((int) '-') << 7) + (int) '-' )
</MACRO>
<MACRO>
<NAME>NOTCODE</NAME>
#define NOTCODE 0
</MACRO>
<MACRO>
<NAME>SEQAND</NAME>
#define SEQAND   ((((int) '&') << 7) + (int) '&' )
</MACRO>
<MACRO>
<NAME>SEQOR</NAME>
#define SEQOR    ((((int) '|') << 7) + (int) '|' )
</MACRO>
<MACRO>
<NAME>FEVAL</NAME>
#define FEVAL -100
</MACRO>
<MACRO>
<NAME>ROWCONCAT</NAME>
#define ROWCONCAT -101
</MACRO>
<MACRO>
<NAME>COLCONCAT</NAME>
#define COLCONCAT -102
</MACRO>
<MACRO>
<NAME>LASTCASE</NAME>
#define LASTCASE  -103
</MACRO>
<MACRO>
<NAME>MLHS</NAME>
#define MLHS      -104
</MACRO>
<MACRO>
<NAME>P_MATRIX</NAME>
#define P_MATRIX  -105
</MACRO>
<MACRO>
<NAME>STATEMENTS</NAME>
#define STATEMENTS -106
</MACRO>
<MACRO>
<NAME>STATEMENTS1</NAME>
#define STATEMENTS1 -107
</MACRO>
<MACRO>
<NAME>OPT</NAME>
#define OPT        -108
</MACRO>
<MACRO>
<NAME>DIAGCONCAT</NAME>
#define DIAGCONCAT -109
</MACRO>
<MACRO>
<NAME>LISTEVAL</NAME>
#define LISTEVAL   -110
</MACRO>
<MACRO>
<NAME>ARGS</NAME>
#define ARGS       -111
</MACRO>
<MACRO>
<NAME>PARENTH</NAME>
#define PARENTH    -112
</MACRO>
<MACRO>
<NAME>DOTARGS</NAME>
#define DOTARGS    -113
</MACRO>
<MACRO>
<NAME>METARGS</NAME>
#define METARGS    -114
</MACRO>
<MACRO>
<NAME>CELLROWCONCAT</NAME>
#define CELLROWCONCAT -115
</MACRO>
<MACRO>
<NAME>CELLCOLCONCAT</NAME>
#define CELLCOLCONCAT -116
</MACRO>
<MACRO>
<NAME>CELLDIAGCONCAT</NAME>
#define CELLDIAGCONCAT -117
</MACRO>
<MACRO>
<NAME>P_CELL</NAME>
#define P_CELL  -118
</MACRO>
<MACRO>
<NAME>CELLARGS</NAME>
#define CELLARGS    -119
</MACRO>
<MACRO>
<NAME>CALLEVAL</NAME>
#define CALLEVAL  -120
</MACRO>
<STRUCT>
<NAME>OpTab</NAME>
</STRUCT>
<STRUCT>
<NAME>OpTab</NAME>
struct OpTab  {
  char *name;
  function *fonc;
};
</STRUCT>
<STRUCT>
<NAME>OpWrapTab</NAME>
</STRUCT>
<STRUCT>
<NAME>OpWrapTab</NAME>
struct OpWrapTab  {
  char *name;
  function *fonc;
  function_wrapper *wrapper;
};
</STRUCT>
<FUNCTION>
<NAME>SMatCreateFromAttrsTable</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
AttrTab *T
</FUNCTION>
<MACRO>
<NAME>NthObj</NAME>
#define NthObj(x) (stack.S[stack.first+x-1])
</MACRO>
<MACRO>
<NAME>CheckRhs</NAME>
#define CheckRhs(x,y) if ( rhs < x || rhs > y ) \
  { Scierror("Error: %d arguments is incorrect for function %s\n",rhs,stack.fname);return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckLhs</NAME>
#define CheckLhs(x,y) if ( lhs != -1 && ( lhs < x || lhs > y )) \
  { Scierror("Error %d returned values is incorrect for function %s\n",lhs,stack.fname);return RET_BUG;}
</MACRO>
<MACRO>
<NAME>CheckStdRhs</NAME>
#define CheckStdRhs(x,y) if ( rhs -opt < x || rhs -opt > y ) \
  { Scierror("Error: %d arguments is incorrect for function %s\n",rhs-opt,stack.fname);return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckOptRhs</NAME>
#define CheckOptRhs(x,y) if ( opt < x || opt > y ) \
  { Scierror("Error: %d optional arguments is incorrect for function %s\n",opt,stack.fname);return RET_BUG;} 
</MACRO>
<ENUM>
<NAME>int_types</NAME>
typedef enum { 
  s_int,        /* scalar int */
  s_double,     /* scalar double */
  s_bool,       /* scalar bool   */
  string,       /* string */
  stringcopy,   /* string copy */
  mat,          /* matrix */
  matcopy,      /* copy of matrix */
  realmat,      /* real matrix */
  realmatcopy,  /* copy of real matrix */
  smat,         /* string  matrix */
  smatcopy,     /* copy of string matrix */
  bmat,         /* boolean  matrix */
  bmatcopy,     /* copy of boolean matrix */
  mat_int,      /* matrix converted to int */
  matcopy_int,  /* copy of a matrix + int conversion */
  list,         /* a list */
  list_begin,   /* used to start a list description */
  list_end,     /* used to stop  a list description */
  obj,          /* an object */
  objcopy,      /* copy of object */
  obj_check,    /* an object preceeded by its type */
  hash,         /* a hash table */
  hashcopy,     /* a hash table copy*/
  opts,         /* optional arguments follow */ 
  new_opts,         /* optional arguments follow */ 
  t_end         /* end of type table  */ 
} int_types;
</ENUM>
<STRUCT>
<NAME>named_opts</NAME>
struct named_opts
{ 
  int n;         /* number of optional arguments */
  char **names;  /* options names */
  int_types *types; /* types associated to each optional name */
  NspObject **objs;    /* array to store pointers to selected optional arguments 
		  * (set to NULL) if optional argument is not found */
  int *posi;     /* stack position of arguments */
};
</STRUCT>
<STRUCT>
<NAME>nsp_option</NAME>
struct nsp_option
{ 
  char *name;  /* options names */
  int_types type; /* types associated to each optional name */
  NspObject *obj;    /* array to store pointers to selected optional arguments 
		  * (set to NULL) if optional argument is not found */
  int  position;     /* stack position of arguments */
};
</STRUCT>
<FUNCTION>
<NAME>RetArgs</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int lhs,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>GetArgs</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int rhs,int opt,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>GetListArgs</NAME>
<RETURNS>int  </RETURNS>
NspList *L,int pos,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>BuildListFromArgs</NAME>
<RETURNS>NspList  *</RETURNS>
int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>GetFromTable</NAME>
<RETURNS>int  </RETURNS>
NspObject **Objs,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>get_optional_args</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int rhs,int opt,nsp_option opts[],...
</FUNCTION>
<FUNCTION>
<NAME>get_optional_args_from_hash</NAME>
<RETURNS>int  </RETURNS>
Stack stack,NspHash *H,nsp_option opts[],...
</FUNCTION>
<FUNCTION>
<NAME>get_args_from_hash</NAME>
<RETURNS>int  </RETURNS>
Stack stack,NspHash *H,nsp_option opts[],...
</FUNCTION>
<FUNCTION>
<NAME>PutLhsObj</NAME>
<RETURNS>void  </RETURNS>
Stack stack,int nv,int ind[]
</FUNCTION>
<FUNCTION>
<NAME>OptCheck</NAME>
<RETURNS>void  </RETURNS>
NspObject **Os,NspObject **DefO,char **Names,int n,Stack ,int nopt
</FUNCTION>
<FUNCTION>
<NAME>ArgPosition</NAME>
<RETURNS>char  *</RETURNS>
int i
</FUNCTION>
<FUNCTION>
<NAME>ArgName</NAME>
<RETURNS>void  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>SwapObjs</NAME>
<RETURNS>void  </RETURNS>
Stack stack,int i,int j
</FUNCTION>
<FUNCTION>
<NAME>MoveObj</NAME>
<RETURNS>void  </RETURNS>
Stack stack ,int j,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>StackStore</NAME>
<RETURNS>void  </RETURNS>
Stack stack,NspObject * o,int pos
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_string</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int n,const char *bytes,int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_string_obj</NAME>
<RETURNS>NspObject  *</RETURNS>
char *name,const char *bytes,int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_double</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int n,double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_doubles</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int pos, int m,int n,...
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_double_obj</NAME>
<RETURNS>NspObject  *</RETURNS>
double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_boolean</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int n,int ival
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_boolean_obj</NAME>
<RETURNS>NspObject  *</RETURNS>
int ival
</FUNCTION>
<FUNCTION>
<NAME>ObjConvert</NAME>
<RETURNS>void  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>ModObj</NAME>
<RETURNS>NspMod   *</RETURNS>
 NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetModCopy</NAME>
<RETURNS>NspMod  *</RETURNS>
Stack S,int i
</FUNCTION>
<FUNCTION>
<NAME>GetMod</NAME>
<RETURNS>NspMod  *</RETURNS>
Stack S,int i
</FUNCTION>
<FUNCTION>
<NAME>GetMe</NAME>
<RETURNS>NspMe  *</RETURNS>
Stack stack,int i
</FUNCTION>
<FUNCTION>
<NAME>GetMeCopy</NAME>
<RETURNS>NspMe  *</RETURNS>
Stack stack,int i
</FUNCTION>
<FUNCTION>
<NAME>GetLmoCopy</NAME>
<RETURNS>NspLmo  *</RETURNS>
Stack S,int  i
</FUNCTION>
<FUNCTION>
<NAME>GetLmo</NAME>
<RETURNS>NspLmo  *</RETURNS>
Stack S,int i
</FUNCTION>
<MACRO>
<NAME>CheckSameDims</NAME>
#define CheckSameDims(fname,pos1,pos2,o1,o2) if ( o1->m != o2->m && o1->n != o2->n ) \
   { Scierror("%s: arguments %d and %d should have the same size\n",fname,pos1,pos2); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckDims</NAME>
#define CheckDims(fname,pos1,o1,m1,n1) if ( o1->m != m1 || o1->n != n1 ) \
   { Scierror("%s: arguments %d should be of size %dx%d\n",fname,pos1,m1,n1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckDimProp</NAME>
#define CheckDimProp(fname,pos1,pos2,log_exp) if ( log_exp ) \
   { Scierror("%s: arguments %d and %d have incompatible size\n",fname,pos1,pos2); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckSquare</NAME>
#define CheckSquare(fname,pos1,o1) if ( o1->m != o1->n ) \
   { Scierror("%s: arguments %d should be square\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckRows</NAME>
#define CheckRows(fname,pos1,o1,value) if ( o1->m != value ) \
   { Scierror("%s: arguments %d has an incorrect row dimension\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckCols</NAME>
#define CheckCols(fname,pos1,o1,value) if ( o1->n != value ) \
   { Scierror("%s: arguments %d has an incorrect col dimension\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckLength</NAME>
#define CheckLength(fname,pos1,o1,value) if ( o1->mn != value ) \
   { Scierror("%s: arguments %d should be of length %d\n",fname,pos1,value); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckScalar</NAME>
#define CheckScalar(fname,pos1,o1) if ( o1->mn != 1 ) \
   { Scierror("%s: arguments %d should be scalar\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckVector</NAME>
#define CheckVector(fname,pos1,o1) if ( o1->mn != 0 && o1->m != 1 && o1->n != 1 ) \
   { Scierror("%s: arguments %d should be a vector \n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckReal</NAME>
#define CheckReal(fname,pos,o1) if ( o1->rc_type != 'r' ) \
   { Scierror("%s: arguments %d should be a real matrix\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckComplex</NAME>
#define CheckComplex(fname,pos,o1) if ( o1->rc_type != 'r' ) \
   { Scierror("%s: arguments %d should be a complex  matrix\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<FUNCTION>
<NAME>call_interf</NAME>
<RETURNS>int  </RETURNS>
function *f, Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>AllInterf</NAME>
<RETURNS>int  </RETURNS>
int i, int num, Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<STRUCT>
<NAME>NspTypePMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePMatrix</NAME>
struct NspTypePMatrix { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} ;
</STRUCT>
<TYPEDEF>
<NAME>nsp_polynom</NAME>
typedef NspMatrix * nsp_polynom;
</TYPEDEF>
<STRUCT>
<NAME>NspPmatrix</NAME>
struct NspPmatrix {
  /*< private >*/
  NspObject father; 
  NspTypePMatrix *type; 
  /*< public >*/
  int m,n,mn;       /* matrix dimension (m,n,m*n) */
  nsp_polynom *S;     /* Each polynom is a Matrix **/
  char rc_type  ;   /* type 'r' or 'i' */
  char *var  ;   /* name of polynom variable */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_pmatrix_id</NAME>
extern int nsp_type_pmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_pmatrix</NAME>
extern NspTypePMatrix *nsp_type_pmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_pmatrix_init</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_pmatrix</NAME>
<RETURNS>NspTypePMatrix  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_pmatrix</NAME>
<RETURNS>NspPMatrix  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_size</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *Mat, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_type_as_string</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_type_short_string</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_loop_extract</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_eq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_neq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLPMAT</NAME>
#define NULLPMAT (NspPMatrix *) 0
</MACRO>
<MACRO>
<NAME>NULLPOLY</NAME>
#define NULLPOLY (nsp_polynom) 0
</MACRO>
<FUNCTION>
<NAME>nsp_pmatrix_object</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_length</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_pmatrix</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
NspMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_polynom</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_concat_down</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
const NspPMatrix *A,const NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_copy</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_create</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
char *name, int m, int n, doubleC *cval, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
NspPMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract_columns</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
NspPMatrix *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract_elements</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
NspPMatrix *A, NspMatrix *Elts, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract_rows</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
NspPMatrix *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_transpose</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
const NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_pcopy_polynom</NAME>
<RETURNS>int  </RETURNS>
int n, nsp_polynom *s1, nsp_polynom *s2
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_add_columns</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_add_rows</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_concat_right</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A,const NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_delete_elements</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_delete_rows</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_enlarge</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_redim</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_resize</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_set_rows</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A, NspMatrix *Rows, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_set_submatrix</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A,const NspMatrix *Rows,const NspMatrix *Cols,const NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_setrc</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pset_polynom</NAME>
<RETURNS>int  </RETURNS>
int n, doubleC *s1, nsp_polynom *s2
</FUNCTION>
<FUNCTION>
<NAME>nsp_basic_to_polynom</NAME>
<RETURNS>nsp_polynom  </RETURNS>
doubleC *d, char type
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_copy</NAME>
<RETURNS>nsp_polynom  </RETURNS>
nsp_polynom P
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspPMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_destroy</NAME>
<RETURNS>void  </RETURNS>
NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_info</NAME>
<RETURNS>void  </RETURNS>
NspPMatrix *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_print</NAME>
<RETURNS>void  </RETURNS>
NspPMatrix *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_destroy</NAME>
<RETURNS>void  </RETURNS>
nsp_polynom *P
</FUNCTION>
<FUNCTION>
<NAME>IsPMatObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsPMat</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetPMatCopy</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetPMat</NAME>
<RETURNS>NspPMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetPolynom</NAME>
<RETURNS>nsp_polynom  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>PMatCompOp</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspPMatrix *A, NspPMatrix *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>PMatFullComp</NAME>
<RETURNS>int  </RETURNS>
NspPMatrix *A, NspPMatrix *B, char *op, int *err
</FUNCTION>
<VARIABLE>
<NAME>VoidPt_Type</NAME>
extern SciFType * VoidPt_Type;
</VARIABLE>
<VARIABLE>
<NAME>GtkE_Type</NAME>
extern SciFType * GtkE_Type ;
</VARIABLE>
<VARIABLE>
<NAME>BMatrix_Type</NAME>
extern SciFType * BMatrix_Type ;
</VARIABLE>
<VARIABLE>
<NAME>SciFile_Type</NAME>
extern SciFType * SciFile_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Func_Type</NAME>
extern SciFType * Func_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Hash_Type</NAME>
extern SciFType * Hash_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Hobj_Type</NAME>
extern SciFType * Hobj_Type ;
</VARIABLE>
<VARIABLE>
<NAME>IVect_Type</NAME>
extern SciFType * IVect_Type;
</VARIABLE>
<VARIABLE>
<NAME>List_Type</NAME>
extern SciFType * List_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Matrix_Type</NAME>
extern SciFType * Matrix_Type ;
</VARIABLE>
<VARIABLE>
<NAME>PMatrix_Type</NAME>
extern SciFType * PMatrix_Type;
</VARIABLE>
<VARIABLE>
<NAME>P_PList_Type</NAME>
extern SciFType * P_PList_Type ;
</VARIABLE>
<VARIABLE>
<NAME>SMatrix_Type</NAME>
extern SciFType * SMatrix_Type;
</VARIABLE>
<VARIABLE>
<NAME>Sp_Type</NAME>
extern SciFType * Sp_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Array_Type</NAME>
extern SciFType * Array_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Mod_Type</NAME>
extern SciFType * Mod_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Me_Type</NAME>
extern SciFType * Me_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Lmo_Type</NAME>
extern SciFType * Lmo_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Rect_Type</NAME>
extern SciFType * Rect_Type ;
</VARIABLE>
<VARIABLE>
<NAME>GFrame_Type</NAME>
extern SciFType * GFrame_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Block_Type</NAME>
extern SciFType * Block_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Link_Type</NAME>
extern SciFType * Link_Type ;
</VARIABLE>
<USER_FUNCTION>
<NAME>IOVFun</NAME>
<RETURNS>int </RETURNS>
const char *fmt, va_list ap
</USER_FUNCTION>
<VARIABLE>
<NAME>Scivprintf</NAME>
extern IOVFun Scivprintf;
</VARIABLE>
<FUNCTION>
<NAME>SetScilabIO</NAME>
<RETURNS>IOVFun  </RETURNS>
IOVFun F
</FUNCTION>
<FUNCTION>
<NAME>Sciprintf1</NAME>
<RETURNS>int  </RETURNS>
int indent,const char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>Sciprintf</NAME>
<RETURNS>int  </RETURNS>
const char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>Sciprint2string_reset</NAME>
<RETURNS>NspObject  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>Sciprint2string</NAME>
<RETURNS>int  </RETURNS>
const char *fmt, va_list ap
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_set_diary</NAME>
<RETURNS>FILE  *</RETURNS>
FILE *f,int diary_echo
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_diary_on</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_diary</NAME>
<RETURNS>int  </RETURNS>
const char *fmt, va_list ap
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_diary_only</NAME>
<RETURNS>int  </RETURNS>
const char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_file</NAME>
<RETURNS>FILE  *</RETURNS>
FILE *f
</FUNCTION>
<FUNCTION>
<NAME>Sciprint2file</NAME>
<RETURNS>int  </RETURNS>
const char *fmt, va_list ap
</FUNCTION>
<TYPEDEF>
<NAME>IOFun</NAME>
typedef iofun *IOFun;
</TYPEDEF>
<USER_FUNCTION>
<NAME>IOFun1</NAME>
<RETURNS>int </RETURNS>
int indent,const char *fmt,...
</USER_FUNCTION>
<VARIABLE>
<NAME>Scierror</NAME>
extern iofun Scierror ;
</VARIABLE>
<FUNCTION>
<NAME>ParseError</NAME>
<RETURNS>int  </RETURNS>
char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>scidebug</NAME>
<RETURNS>int  </RETURNS>
int i,char *fmt,...
</FUNCTION>
<USER_FUNCTION>
<NAME>IOFun2</NAME>
<RETURNS>int </RETURNS>
FILE *f,const char *fmt,...
</USER_FUNCTION>
<VARIABLE>
<NAME>Scifprintf</NAME>
extern IOFun2 Scifprintf ;
</VARIABLE>
<USER_FUNCTION>
<NAME>SciGetC</NAME>
<RETURNS>int </RETURNS>
void
</USER_FUNCTION>
<VARIABLE>
<NAME>Scigetchar</NAME>
extern SciGetC Scigetchar ;
</VARIABLE>
<FUNCTION>
<NAME>SetScilabgetchar</NAME>
<RETURNS>SciGetC  </RETURNS>
SciGetC F
</FUNCTION>
<FUNCTION>
<NAME>SciReadClean</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_readline_clear_line</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>set_echo_mode</NAME>
<RETURNS>void  </RETURNS>
int mode
</FUNCTION>
<FUNCTION>
<NAME>get_echo_mode</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>set_is_reading</NAME>
<RETURNS>void  </RETURNS>
int mode
</FUNCTION>
<FUNCTION>
<NAME>get_is_reading</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_error_message_show</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_error_message_to_lasterror</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_error_message_clear</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_echo_input_line</NAME>
<RETURNS>int  </RETURNS>
int val
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_echo_input_line</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>nsp_error_vprintf</NAME>
extern IOVFun nsp_error_vprintf;
</VARIABLE>
<FUNCTION>
<NAME>sci_get_screen_size</NAME>
<RETURNS>void  </RETURNS>
int *rows, int *cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_intialize_reader</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_from_texmacs</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>NspHobj</NAME>
</STRUCT>
<STRUCT>
<NAME>NspHobj</NAME>
struct NspHobj {
  /*< private >*/
  NspObject father; 
  NspTypeHobj *type; 
  /*< public >*/
  char htype  ;   /* 'o' : optional argument 
		  * 'h' : handler 
		  * 'g' : global variable pointer 
		  */
  NspObject *O;        /* pointed object */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_hobj_id</NAME>
extern int nsp_type_hobj_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_hobj</NAME>
extern NspTypeHobj *nsp_type_hobj;
</VARIABLE>
<FUNCTION>
<NAME>new_type_hobj</NAME>
<RETURNS>NspTypeHobj  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_hobj</NAME>
<RETURNS>NspHobj  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLHOBJ</NAME>
#define NULLHOBJ (NspHobj *) 0
</MACRO>
<MACRO>
<NAME>NULLHOPT</NAME>
#define NULLHOPT (NspHobj *) 0
</MACRO>
<FUNCTION>
<NAME>HobjCreate</NAME>
<RETURNS>NspHobj  *</RETURNS>
char *name,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>HoptCreate</NAME>
<RETURNS>NspHobj  *</RETURNS>
char *name,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GobjCreate</NAME>
<RETURNS>NspHobj  *</RETURNS>
char *name,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_copy</NAME>
<RETURNS>NspHobj  *</RETURNS>
NspHobj *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_destroy</NAME>
<RETURNS>void  </RETURNS>
NspHobj *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_info</NAME>
<RETURNS>void  </RETURNS>
NspHobj *H,int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_print</NAME>
<RETURNS>void  </RETURNS>
NspHobj *H,int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>IsHobj</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsHopt</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_object</NAME>
<RETURNS>NspHobj   *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGlobal</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<MACRO>
<NAME>HOBJ_GET_OBJECT</NAME>
#define HOBJ_GET_OBJECT(Obj,rep)						\
  if (check_cast (Obj, nsp_type_hobj_id) == TRUE)			\
    {									\
      if (((NspHobj *)Obj)->htype != 'g') Obj = ((NspHobj *) Obj)->O;     \
      else {								\
	if ((Obj= nsp_global_frame_search_object(NSP_OBJECT(Obj)->name)) == NULLOBJ) \
	  {								\
	    Scierror("Pointer to a global non existant variable\n"); \
	    return rep;					     \
	  } \
      } \
    } 
</MACRO>
<STRUCT>
<NAME>NspModulelt</NAME>
struct NspModulelt {
  /*< private >*/
  NspObject father; 
  NspTypeModuleElt *type; 
  /*< public >*/
  char *path ;
  char *module;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_modulelt_id</NAME>
extern int nsp_type_modulelt_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_modulelt</NAME>
extern NspTypeModuleElt *nsp_type_modulelt;
</VARIABLE>
<FUNCTION>
<NAME>new_type_modulelt</NAME>
<RETURNS>NspTypeModuleElt  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_modulelt</NAME>
<RETURNS>NspModuleElt  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLME</NAME>
#define NULLME (NspModuleElt*) 0
</MACRO>
<FUNCTION>
<NAME>modulelt_create</NAME>
<RETURNS>NspModuleElt  *</RETURNS>
char *name,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>modulelt_copy</NAME>
<RETURNS>NspModuleElt  *</RETURNS>
NspModuleElt *H
</FUNCTION>
<FUNCTION>
<NAME>modulelt_destroy</NAME>
<RETURNS>void  </RETURNS>
NspModuleElt *H
</FUNCTION>
<FUNCTION>
<NAME>modulelt_info</NAME>
<RETURNS>void  </RETURNS>
NspModuleElt *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>modulelt_print</NAME>
<RETURNS>void  </RETURNS>
NspModuleElt *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>modulelt_object</NAME>
<RETURNS>NspModuleElt  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsModuleEltObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsModuleElt</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetModuleEltCopy</NAME>
<RETURNS>NspModuleElt  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetModuleElt</NAME>
<RETURNS>NspModuleElt  *</RETURNS>
Stack stack, int i
</FUNCTION>
<STRUCT>
<NAME>NspConnector</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_connector</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_connector</NAME>
struct nsp_connector {
  nsp_gframe *frame; /* a link must be in a frame to be drawn */
  void *object_sid;
  double r[4];
  int color; 
  int thickness;
  int background;
  gr_lock lock; /* Only one lock point for a connector */
  int hilited ; 
  int show    ;   
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspConnector</NAME>
struct NspConnector {
  /*< private >*/
  NspObject father; 
  NspTypeConnector *type; 
  /*< public >*/
  nsp_connector *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_connector_id</NAME>
extern int nsp_type_connector_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_connector</NAME>
extern NspTypeConnector *nsp_type_connector;
</VARIABLE>
<FUNCTION>
<NAME>new_type_connector</NAME>
<RETURNS>NspTypeConnector  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_connector</NAME>
<RETURNS>NspConnector  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCONNECTOR</NAME>
#define NULLCONNECTOR (NspConnector*) 0
</MACRO>
<FUNCTION>
<NAME>connector_object</NAME>
<RETURNS>NspConnector  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsConnectorObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetConnectorCopy</NAME>
<RETURNS>NspConnector  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetConnector</NAME>
<RETURNS>NspConnector  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsConnector</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>connector_create</NAME>
<RETURNS>NspConnector  *</RETURNS>
char *name,double rect[],int color,int thickness,int background,NspTypeBase *type
</FUNCTION>
<STRUCT>
<NAME>NspBlock</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_block</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_block</NAME>
struct nsp_block {
  nsp_gframe *frame;/* a block must be in a frame to be drawn */
  void *object_sid;
  double r[4]; 		
  int color;
  int thickness;
  int background;
  int n_locks ; /* number of lock points */
  grb_lock *locks; 
  int hilited ; 
  int show    ;   
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspBlock</NAME>
struct NspBlock {
  /*< private >*/
  NspObject father; 
  NspTypeBlock *type; 
  /*< public >*/
  nsp_block *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_block_id</NAME>
extern int nsp_type_block_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_block</NAME>
extern NspTypeBlock *nsp_type_block;
</VARIABLE>
<FUNCTION>
<NAME>new_type_block</NAME>
<RETURNS>NspTypeBlock  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_block</NAME>
<RETURNS>NspBlock  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLBLOCK</NAME>
#define NULLBLOCK (NspBlock*) 0
</MACRO>
<FUNCTION>
<NAME>block_object</NAME>
<RETURNS>NspBlock  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsBlockObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetBlockCopy</NAME>
<RETURNS>NspBlock  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetBlock</NAME>
<RETURNS>NspBlock  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsBlock</NAME>
<RETURNS>int  </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>block_create</NAME>
<RETURNS>NspBlock  *</RETURNS>
char *name,double rect[],int color,int thickness,int background, NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>eval_piecewise_hermite</NAME>
<RETURNS>void  </RETURNS>
double *t, double *st, double *dst, double *d2st,double *d3st, int m, double *x, double *y, double *d,int n, int outmode
</FUNCTION>
<FUNCTION>
<NAME>dpchim</NAME>
<RETURNS>void  </RETURNS>
double *x, double *u, double *d, int n, int inc
</FUNCTION>
<FUNCTION>
<NAME>cubic_spline</NAME>
<RETURNS>void  </RETURNS>
double *x, double *y, double *d, int n, int type,double *A_d, double *A_sd, double *qdy, double *lll
</FUNCTION>
<FUNCTION>
<NAME>derivd</NAME>
<RETURNS>void  </RETURNS>
double *x, double *u, double *du, int n, int inc, int type
</FUNCTION>
<FUNCTION>
<NAME>nlinear_interp</NAME>
<RETURNS>void  </RETURNS>
double **x , double val[], int dim[], int n,double **xp, double yp[], int np, int outmode,double u[], double v[], int ad[], int k[]
</FUNCTION>
<STRUCT>
<NAME>NspCells</NAME>
</STRUCT>
<STRUCT>
<NAME>NspCells</NAME>
struct NspCells {
  /*< private >*/
  NspObject father; 
  NspTypeCells *type; 
  /*< public >*/
  int m,n,mn;
  NspObject **objs;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_cells_id</NAME>
extern int nsp_type_cells_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_cells</NAME>
extern NspTypeCells *nsp_type_cells;
</VARIABLE>
<FUNCTION>
<NAME>new_type_cells</NAME>
<RETURNS>NspTypeCells  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_cells</NAME>
<RETURNS>NspCells  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_type_as_string</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_type_short_string</NAME>
<RETURNS>char  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_loop_extract</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_eq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_neq</NAME>
<RETURNS>int  </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_is_true</NAME>
<RETURNS>int  </RETURNS>
NspCells *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_xdr_load</NAME>
<RETURNS>NspCells  *</RETURNS>
XDR  *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_xdr_save</NAME>
<RETURNS>int  </RETURNS>
XDR *xdrs, NspCells *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_object</NAME>
<RETURNS>NspCells  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsCellsObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsCells</NAME>
<RETURNS>int  </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetCellsCopy</NAME>
<RETURNS>NspCells  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetCells</NAME>
<RETURNS>NspCells  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_create</NAME>
<RETURNS>NspCells  *</RETURNS>
const char *name, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_create_from_table</NAME>
<RETURNS>NspCells  *</RETURNS>
const char *name,NspObject **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_create_from_array</NAME>
<RETURNS>NspCells  *</RETURNS>
const char *name,int n, NspObject **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_copy</NAME>
<RETURNS>NspCells  *</RETURNS>
const NspCells *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_resize</NAME>
<RETURNS>int  </RETURNS>
NspCells *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_destroy</NAME>
<RETURNS>void  </RETURNS>
NspCells *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_info</NAME>
<RETURNS>void  </RETURNS>
const NspCells *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_print</NAME>
<RETURNS>void  </RETURNS>
const NspCells *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_redim</NAME>
<RETURNS>int  </RETURNS>
NspCells *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_enlarge</NAME>
<RETURNS>int  </RETURNS>
NspCells *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_concat_right</NAME>
<RETURNS>int  </RETURNS>
NspCells *A,const NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_add_columns</NAME>
<RETURNS>int  </RETURNS>
NspCells *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_concat_down</NAME>
<RETURNS>NspCells  *</RETURNS>
const NspCells *A,const NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_add_rows</NAME>
<RETURNS>int  </RETURNS>
NspCells *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_set_submatrix</NAME>
<RETURNS>int  </RETURNS>
NspCells *A,const NspMatrix *Rows,const NspMatrix *Cols,const NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_set_rows</NAME>
<RETURNS>int  </RETURNS>
NspCells *A, NspMatrix *Rows, NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_delete_columns</NAME>
<RETURNS>int  </RETURNS>
NspCells *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_delete_rows</NAME>
<RETURNS>int  </RETURNS>
NspCells *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_delete_elements</NAME>
<RETURNS>int  </RETURNS>
NspCells *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract</NAME>
<RETURNS>NspCells  *</RETURNS>
NspCells *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract_elements</NAME>
<RETURNS>NspCells  *</RETURNS>
NspCells *A, NspMatrix *Elts, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract_columns</NAME>
<RETURNS>NspCells  *</RETURNS>
NspCells *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>CellsLoopCol</NAME>
<RETURNS>NspCells  *</RETURNS>
char *str, NspCells *Col, NspCells *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract_rows</NAME>
<RETURNS>NspCells  *</RETURNS>
NspCells *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_set_element</NAME>
<RETURNS>int  </RETURNS>
NspCells *A,int index, NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLCELLS</NAME>
#define NULLCELLS (NspCells *) NULL
</MACRO>
<FUNCTION>
<NAME>nsp_cells_strcmp</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspCells *A, NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>CellsCompOp</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspCells *A, NspCells *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>CellsFullComp</NAME>
<RETURNS>int  </RETURNS>
NspCells *A, NspCells *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_transpose</NAME>
<RETURNS>NspCells  *</RETURNS>
const NspCells *A
</FUNCTION>
<STRUCT>
<NAME>doubleC</NAME>
struct doubleC
{ double r, i; };
</STRUCT>
<STRUCT>
<NAME>NspMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspMatrix</NAME>
struct NspMatrix {
  /*< private >*/
  NspObject father; 
  NspTypeMatrix *type; 
  /*< public >*/
  int m,n,mn;/* NspMatrix dimensions */
  union { 
    double *R;     /* Pointer on real values */
    doubleC *C;    /* Pointer on complex values */
    int *I;        /* Pointer on integer values */
  };
  char rc_type;    /* 'r' : real or  'c' : complex  */
  char convert;    /* 'd','i','f','c' : double, int, float, old_complex
		    * used to remember array converted in place */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_matrix_id</NAME>
extern int nsp_type_matrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_matrix</NAME>
extern NspTypeMatrix *nsp_type_matrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_matrix_init</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_matrix</NAME>
<RETURNS>NspTypeMatrix  *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_matrix</NAME>
<RETURNS>NspMatrix  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLMAT</NAME>
#define NULLMAT (NspMatrix*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_alloc_doubles</NAME>
<RETURNS>double  *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_realloc_doubles</NAME>
<RETURNS>double  *</RETURNS>
double *dp, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_int</NAME>
<RETURNS>int  *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_realloc_int</NAME>
<RETURNS>int  *</RETURNS>
int *dp, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_doubleC</NAME>
<RETURNS>doubleC  *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_realloc_doubleC</NAME>
<RETURNS>doubleC  *</RETURNS>
doubleC *dp, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_work_doubles</NAME>
<RETURNS>double  *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_work_int</NAME>
<RETURNS>int  *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_work_doubleC</NAME>
<RETURNS>doubleC  *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_destroy</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_info</NAME>
<RETURNS>void  </RETURNS>
const NspMatrix *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_copy</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_print</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>matrix_loop_extract</NAME>
<RETURNS>NspObject  *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>matrix_object</NAME>
<RETURNS>NspMatrix   *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_fullcomp</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>matrix_object</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsMatObj</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsMat</NAME>
<RETURNS>int  </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetMatCopyInt</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMatInt</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMatCopyFloat</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMatFloat</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopy_G</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMat_G</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopy</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMat</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopyInt</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatInt</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopyFloat</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatFloat</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMtlbMatCopy</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMtlbMat</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IntScalar</NAME>
<RETURNS>int  </RETURNS>
NspObject *O, int *val
</FUNCTION>
<FUNCTION>
<NAME>GetScalarInt</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i, int *val
</FUNCTION>
<FUNCTION>
<NAME>DoubleScalar</NAME>
<RETURNS>int  </RETURNS>
NspObject *O, double *val
</FUNCTION>
<FUNCTION>
<NAME>GetScalarDouble</NAME>
<RETURNS>int  </RETURNS>
Stack stack, int i, double *val
</FUNCTION>
<FUNCTION>
<NAME>Matd2i</NAME>
<RETURNS>int  *</RETURNS>
NspMatrix *A, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>Bounds</NAME>
<RETURNS>void  </RETURNS>
const NspMatrix *A, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_boundsbis</NAME>
<RETURNS>int  *</RETURNS>
const NspMatrix * A, int * imin, int * imax
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_boundster</NAME>
<RETURNS>void  </RETURNS>
const NspMatrix *A, int *ind, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>nsp_complement_for_deletions</NAME>
<RETURNS>int  *</RETURNS>
int mn, const NspMatrix *Elts, int *Count
</FUNCTION>
<FUNCTION>
<NAME>nsp_indices_for_deletions</NAME>
<RETURNS>int  *</RETURNS>
int mn, const NspMatrix *Elts, int *Count
</FUNCTION>
<FUNCTION>
<NAME>Mat2double</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>Mat2int</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>Mat2float</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>Mat2mtlb_cplx</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix * A
</FUNCTION>
<USER_FUNCTION>
<NAME>F_Enlarge</NAME>
<RETURNS>int </RETURNS>
void *A,int m,int n
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const char *name, char type, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_impl</NAME>
<RETURNS>NspMatrix  *</RETURNS>
double first, double step, double last
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_linspace</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const double first[],const double last[],int r,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_logspace</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const double first[],const double last[],int r,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_from_doubles</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const char *name,int m,int n,...
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_from_array</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const char *name,int m,int n,const double valr[],const double valc[]
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_fill_with</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_resize</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_scalar_to_mn</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_latex_print</NAME>
<RETURNS>void  </RETURNS>
const NspMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_latex_tab_print</NAME>
<RETURNS>void  </RETURNS>
const NspMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_redim</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_enlarge</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_concat_right</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_add_columns</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_concat_down</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspMatrix *A,const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_concat_diag</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspMatrix *A,const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_add_rows</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_set_submatrix</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>GenericMatSeRo</NAME>
<RETURNS>int  </RETURNS>
void *A, int Am, int An, int Amn, NspMatrix *Rows, void *B, int Bm, int Bn, int Bmn, F_Enlarge F, int *Bscal
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_set_rows</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *Rows, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>mat_is_increasing</NAME>
<RETURNS>int  </RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_delete_columns</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_delete_rows</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_delete_elements</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspMatrix *A,const  NspMatrix *Rows,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_elements</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspMatrix *A,const  NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_columns</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspMatrix *A,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_rows</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspMatrix *A,const  NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>MatLoopCol</NAME>
<RETURNS>NspMatrix  *</RETURNS>
char *str, NspMatrix *Col, NspMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_diag</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_set_diag</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_diag</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_transpose</NAME>
<RETURNS>NspMatrix  *</RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_set_rval</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_set_ival</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_dadd</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_dadd_maxplus</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add_scalar_maxplus</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_dsub</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub_scalar_maxplus</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_subs_calarm</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_clean</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A, int rhs, double epsa, double epsr
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxitt1</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B, NspMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minitt1</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B, NspMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minmax</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, char *str, NspMatrix **Amin, NspMatrix **Imin,NspMatrix **Amax, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_slec</NAME>
<RETURNS>NspMatrix  **</RETURNS>
char *file, int *Count
</FUNCTION>
<FUNCTION>
<NAME>fopen</NAME>
<RETURNS>FILE  *</RETURNS>
const char *, const char *
</FUNCTION>
<FUNCTION>
<NAME>MatLec</NAME>
<RETURNS>NspMatrix  *</RETURNS>
FILE *fd
</FUNCTION>
<FUNCTION>
<NAME>fooBOU</NAME>
<RETURNS>NspMatrix  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_readline</NAME>
<RETURNS>int  </RETURNS>
FILE *fd
</FUNCTION>
<FUNCTION>
<NAME>nsp_testnumtokens</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_numtokens</NAME>
<RETURNS>int  </RETURNS>
char *string
</FUNCTION>
<FUNCTION>
<NAME>nsp_csetd</NAME>
<RETURNS>void  </RETURNS>
const int *n,const double *z,doubleC *tab,const int *inc
</FUNCTION>
<FUNCTION>
<NAME>nsp_ciset</NAME>
<RETURNS>void  </RETURNS>
const int *n,const double *z, doubleC *tab, const int *inc
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_complexify</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *Mat, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_get_real</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_get_imag</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_inv_el</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_kron</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sort</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A, int flag, char *str1, char *str2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sum</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_prod</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cum_prod</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cum_sum</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxi</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A, char *flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mini</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A, char *flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_createinit</NAME>
<RETURNS>NspMatrix  *</RETURNS>
char *name, char type, int m, int n, double (*func) ()
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_triu</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tril</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_eye</NAME>
<RETURNS>NspMatrix  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ones</NAME>
<RETURNS>NspMatrix  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_zeros</NAME>
<RETURNS>NspMatrix  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_rand</NAME>
<RETURNS>NspMatrix  *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_urandseed</NAME>
<RETURNS>void  </RETURNS>
int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_urandseed</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_urandtype</NAME>
<RETURNS>void  </RETURNS>
int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_urandtype</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_matscalar</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_matmat</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_scalarmat</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_tt</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_el</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_scalarm</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_div_tt</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_div_el</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_div_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_tt</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_el</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult_tt</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult_el</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult_scalar</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_acos</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_acosh</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_asin</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_asinh</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_atan</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_atan2</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A,NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_atanh</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ceil</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_modulo</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_idiv</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_int</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_floor</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_round</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sign</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tan</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tanh</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_abs</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_erf</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_erfc</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_lgamma</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tgamma</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_arg</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_polar</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_iand</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_iandu</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ior</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ioru</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ishift</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A,int shift,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_conj</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cos</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cosh</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_expel</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_logel</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sin</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sinh</NAME>
<RETURNS>void  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sqrtel</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minus</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minus_maxplus</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_magic</NAME>
<RETURNS>NspMatrix  *</RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_franck</NAME>
<RETURNS>NspMatrix  *</RETURNS>
int n, int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_hilbert</NAME>
<RETURNS>NspMatrix  *</RETURNS>
int n,int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_fullcomp</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_find</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, int lhs, NspMatrix **Res1, NspMatrix **Res2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxplus_add</NAME>
<RETURNS>int  </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxplus_mult</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minplus_mult</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>GetMatCopy</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMat</NAME>
<RETURNS>NspMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>MaybeObjCopy</NAME>
<RETURNS>return  </RETURNS>
&stack.S[stack.first+i-1]
</FUNCTION>
