<STRUCT>
<NAME>NspPolyline</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePolyline</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePolyline</NAME>
struct _NspTypePolyline {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./polyline.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_polyline</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_polyline</NAME>
struct _nsp_polyline {
  NspMatrix* x;
  NspMatrix* y;
  gboolean close;
  int color;
  int mark;
  int mark_size;
  int fill_color;
  int thickness;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspPolyline</NAME>
struct _NspPolyline {
  /*< private >*/
  NspGraphic father;
  NspTypePolyline*type;
  /*< public >*/
  nsp_polyline *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_polyline_id</NAME>
extern int nsp_type_polyline_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_polyline</NAME>
extern NspTypePolyline *nsp_type_polyline;
</VARIABLE>
<FUNCTION>
<NAME>new_type_polyline</NAME>
<RETURNS>NspTypePolyline *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_polyline</NAME>
<RETURNS>NspPolyline *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLPOLYLINE</NAME>
#define NULLPOLYLINE (NspPolyline*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_polyline_create</NAME>
<RETURNS>NspPolyline *</RETURNS>
const char *name,NspMatrix* x,NspMatrix* y,gboolean close,int color,int mark,int mark_size,int fill_color,int thickness,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_create_default</NAME>
<RETURNS>NspPolyline *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_copy</NAME>
<RETURNS>NspPolyline *</RETURNS>
NspPolyline *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_destroy</NAME>
<RETURNS>void </RETURNS>
NspPolyline *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_info</NAME>
<RETURNS>int </RETURNS>
NspPolyline *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_print</NAME>
<RETURNS>int </RETURNS>
NspPolyline *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_latex</NAME>
<RETURNS>int </RETURNS>
NspPolyline *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_object</NAME>
<RETURNS>NspPolyline *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsPolylineObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsPolyline</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetPolylineCopy</NAME>
<RETURNS>NspPolyline *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetPolyline</NAME>
<RETURNS>NspPolyline *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_create_partial</NAME>
<RETURNS>int </RETURNS>
NspPolyline *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspPolyline *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_copy_partial</NAME>
<RETURNS>NspPolyline *</RETURNS>
NspPolyline *H,NspPolyline *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_full_copy_partial</NAME>
<RETURNS>NspPolyline *</RETURNS>
NspPolyline *H,NspPolyline *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_full_copy</NAME>
<RETURNS>NspPolyline *</RETURNS>
NspPolyline *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_check_values</NAME>
<RETURNS>int </RETURNS>
NspPolyline *H
</FUNCTION>
<FUNCTION>
<NAME>int_polyline_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_xdr_load_partial</NAME>
<RETURNS>NspPolyline *</RETURNS>
XDR *xdrs, NspPolyline *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspPolyline *M
</FUNCTION>
<STRUCT>
<NAME>NspTypeMe</NAME>
typedef struct _NspTypeMe { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeMe;
</STRUCT>
<STRUCT>
<NAME>NspMe</NAME>
struct _NspMe {
  /*< private >*/
  NspObject father; 
  NspTypeMe *type; 
  /*< public >*/
  char *path;  
  char *module;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_me_id</NAME>
extern int nsp_type_me_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_me</NAME>
extern NspTypeMe *nsp_type_me;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_me_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_me</NAME>
<RETURNS>NspTypeMe *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_me</NAME>
<RETURNS>NspMe *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>MeType</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>MeShType</NAME>
<RETURNS>char *</RETURNS>
NspMe *M
</FUNCTION>
<FUNCTION>
<NAME>MeLoopExtract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>MeObjEq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>MeObjNeq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLXME</NAME>
#define NULLXME (NspMe *) 0
</MACRO>
<FUNCTION>
<NAME>MeFullComp</NAME>
<RETURNS>int </RETURNS>
NspMe * A,NspMe * B,char *op,int *err
</FUNCTION>
<FUNCTION>
<NAME>MeCreate</NAME>
<RETURNS>NspMe *</RETURNS>
char *name
</FUNCTION>
<FUNCTION>
<NAME>MeCopy</NAME>
<RETURNS>NspMe *</RETURNS>
NspMe *H
</FUNCTION>
<FUNCTION>
<NAME>MeDestroy</NAME>
<RETURNS>void </RETURNS>
NspMe *H
</FUNCTION>
<FUNCTION>
<NAME>MeInfo</NAME>
<RETURNS>void </RETURNS>
NspMe *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>MePrint</NAME>
<RETURNS>void </RETURNS>
NspMe *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>MeObj</NAME>
<RETURNS>NspMe  *</RETURNS>
 NspObject *O
</FUNCTION>
<TYPEDEF>
<NAME>gint</NAME>
typedef int gint    ;
</TYPEDEF>
<TYPEDEF>
<NAME>guint</NAME>
typedef unsigned int guint   ;
</TYPEDEF>
<TYPEDEF>
<NAME>gshort</NAME>
typedef short gshort  ;
</TYPEDEF>
<TYPEDEF>
<NAME>gushort</NAME>
typedef unsigned short gushort ;
</TYPEDEF>
<TYPEDEF>
<NAME>glong</NAME>
typedef long int glong   ;
</TYPEDEF>
<TYPEDEF>
<NAME>gulong</NAME>
typedef unsigned long int gulong  ;
</TYPEDEF>
<TYPEDEF>
<NAME>gint8</NAME>
typedef signed char gint8   ;
</TYPEDEF>
<TYPEDEF>
<NAME>guint8</NAME>
typedef unsigned char guint8  ;
</TYPEDEF>
<TYPEDEF>
<NAME>gint16</NAME>
typedef signed short gint16  ;
</TYPEDEF>
<TYPEDEF>
<NAME>guint16</NAME>
typedef unsigned short guint16 ;
</TYPEDEF>
<TYPEDEF>
<NAME>gint32</NAME>
typedef int gint32  ;
</TYPEDEF>
<TYPEDEF>
<NAME>guint32</NAME>
typedef unsigned int guint32 ;
</TYPEDEF>
<TYPEDEF>
<NAME>gint64</NAME>
typedef __int64 gint64;
</TYPEDEF>
<TYPEDEF>
<NAME>guint64</NAME>
typedef unsigned __int64 guint64;
</TYPEDEF>
<TYPEDEF>
<NAME>gint64</NAME>
typedef long long int gint64;
</TYPEDEF>
<TYPEDEF>
<NAME>guint64</NAME>
typedef unsigned long long int guint64;
</TYPEDEF>
<ENUM>
<NAME>nsp_itype</NAME>
typedef enum   { nsp_gint, nsp_guint, nsp_gshort, nsp_gushort, nsp_glong , 
		 nsp_gulong, nsp_gint8, nsp_guint8, nsp_gint16,
		 nsp_guint16, nsp_gint32, nsp_guint32, nsp_gint64, 
		 nsp_guint64 } nsp_itype;
</ENUM>
<FUNCTION>
<NAME>update_exec_dir</NAME>
<RETURNS>void </RETURNS>
char *filename,char *exec_dir,char *filename_exec,unsigned int length
</FUNCTION>
<FUNCTION>
<NAME>update_exec_dir_from_dir</NAME>
<RETURNS>void </RETURNS>
char *dirname,char *exec_dir,unsigned int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_expand_file_with_exec_dir</NAME>
<RETURNS>void </RETURNS>
Stack *stack,char *filename,char *filename_exec
</FUNCTION>
<FUNCTION>
<NAME>nsp_expand_file_and_update_exec_dir</NAME>
<RETURNS>void </RETURNS>
Stack *stack,char *old,char *filename,char *filename_exec
</FUNCTION>
<FUNCTION>
<NAME>nsp_reset_exec_dir</NAME>
<RETURNS>void </RETURNS>
Stack *stack,char *old
</FUNCTION>
<FUNCTION>
<NAME>nsp_expand_dir_and_update_exec_dir</NAME>
<RETURNS>void </RETURNS>
Stack *stack,char *old,char *dirname,char *dirname_exec
</FUNCTION>
<MACRO>
<NAME>OK</NAME>
#define OK 0
</MACRO>
<MACRO>
<NAME>FAIL</NAME>
#define FAIL 1
</MACRO>
<MACRO>
<NAME>finite</NAME>
#define finite(x) _finite(x) 
</MACRO>
<MACRO>
<NAME>finite</NAME>
#define finite(x) FINITE_IS_UNDEFINED
</MACRO>
<MACRO>
<NAME>isnan</NAME>
#define isnan(x) _isnan(x)
</MACRO>
<MACRO>
<NAME>isnan</NAME>
#define isnan(x)  ISNAN_IS_UNDEFINED
</MACRO>
<MACRO>
<NAME>ISNAN</NAME>
#define ISNAN(x) isnan(x)
</MACRO>
<MACRO>
<NAME>Abs</NAME>
#define Abs(x) ( ( (x) >= 0) ? (x) : -( x) )
</MACRO>
<MACRO>
<NAME>Min</NAME>
#define Min(x,y)	(((x)<(y))?(x):(y))
</MACRO>
<MACRO>
<NAME>Max</NAME>
#define Max(x,y)	(((x)>(y))?(x):(y))
</MACRO>
<FUNCTION>
<NAME>Mini</NAME>
<RETURNS>double </RETURNS>
const double vect[],int
</FUNCTION>
<FUNCTION>
<NAME>Maxi</NAME>
<RETURNS>double </RETURNS>
const double vect[],int
</FUNCTION>
<MACRO>
<NAME>PI0</NAME>
#define PI0 (int *) 0
</MACRO>
<MACRO>
<NAME>PD0</NAME>
#define PD0 (double *) 0
</MACRO>
<MACRO>
<NAME>SMDOUBLE</NAME>
#define SMDOUBLE 1.e-200 /* Smalest number to avoid dividing by zero */
</MACRO>
<MACRO>
<NAME>linint</NAME>
#define linint(x) ((int) floor(x + 0.5 )) 
</MACRO>
<MACRO>
<NAME>inint</NAME>
#define inint(x) ((int) floor(x + 0.5 ))  
</MACRO>
<MACRO>
<NAME>anint</NAME>
#define anint(x) rint(x)   
</MACRO>
<MACRO>
<NAME>anint</NAME>
#define anint(x) ((x) >= 0.0 ? floor((x)+0.5) : ceil((x)-0.5))
</MACRO>
<MACRO>
<NAME>aint</NAME>
#define aint(x) ((x>= 0 ) ? floor(x)  : ceil(x))
</MACRO>
<MACRO>
<NAME>d_nint</NAME>
#define d_nint(x) (x)>=0 ? floor(x + .5) : -floor(.5 - x)
</MACRO>
<FUNCTION>
<NAME>tgamma</NAME>
<RETURNS>double </RETURNS>
double
</FUNCTION>
<MACRO>
<NAME>int16max</NAME>
#define int16max   0x7FFF
</MACRO>
<MACRO>
<NAME>uns16max</NAME>
#define uns16max   0xFFFF
</MACRO>
<MACRO>
<NAME>MALLOC</NAME>
#define MALLOC(x) malloc(((size_t) x))
</MACRO>
<MACRO>
<NAME>FREE</NAME>
#define FREE(x) {if (x  != NULL) { free((void *) x); x= NULL;};}
</MACRO>
<MACRO>
<NAME>REALLOC</NAME>
#define REALLOC(x,y) realloc((void *) x,(size_t) y)
</MACRO>
<MACRO>
<NAME>MALLOC</NAME>
#define MALLOC(x) malloc(((unsigned) x))
</MACRO>
<MACRO>
<NAME>FREE</NAME>
#define FREE(x) {if (x  != NULL) {free((char *) x); x = NULL;}}
</MACRO>
<MACRO>
<NAME>REALLOC</NAME>
#define REALLOC(x,y) realloc((char *) x,(unsigned) y)
</MACRO>
<MACRO>
<NAME>NVOID</NAME>
#define NVOID ""
</MACRO>
<MACRO>
<NAME>HAS_STDARG</NAME>
#  define HAS_STDARG
</MACRO>
<MACRO>
<NAME>M_PI</NAME>
#define M_PI    3.14159265358979323846 
</MACRO>
<MACRO>
<NAME>M_E</NAME>
#define M_E     2.7182818284590452354
</MACRO>
<MACRO>
<NAME>M_LOG10E</NAME>
#define M_LOG10E 0.43429448190325182765
</MACRO>
<FUNCTION>
<NAME>acosh</NAME>
<RETURNS>double </RETURNS>
double
</FUNCTION>
<FUNCTION>
<NAME>asinh</NAME>
<RETURNS>double </RETURNS>
double
</FUNCTION>
<FUNCTION>
<NAME>atanh</NAME>
<RETURNS>double </RETURNS>
double
</FUNCTION>
<FUNCTION>
<NAME>nsp_dlamch</NAME>
<RETURNS>double </RETURNS>
char *cmach
</FUNCTION>
<MACRO>
<NAME>SET_LOW_WORD</NAME>
#define SET_LOW_WORD(d,v)					\
  do {								\
    ieee_double_shape_type sl_u;				\
    sl_u.value = (d);						\
    sl_u.parts.lsw = (v);					\
    (d) = sl_u.value;						\
  } while (0)
</MACRO>
<TYPEDEF>
<NAME>uint32_t</NAME>
typedef unsigned int uint32_t;
</TYPEDEF>
<MACRO>
<NAME>SET_LOW_WORD</NAME>
#define SET_LOW_WORD(d,v)					\
  do {								\
    ieee_double_shape_type sl_u;				\
    sl_u.value = (d);						\
    if ( is_little_endian())					\
      sl_u.parts.msw = (v);					\
    else							\
      sl_u.parts.lsw = (v);					\
    (d) = sl_u.value;						\
  } while (0)
</MACRO>
<FUNCTION>
<NAME>nsp_double2int</NAME>
<RETURNS>int </RETURNS>
int *n, double *dx, int *ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_float2int</NAME>
<RETURNS>int </RETURNS>
int *n, float *dx, int *ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_double2float</NAME>
<RETURNS>int </RETURNS>
int *n, double *dx, float *rx
</FUNCTION>
<FUNCTION>
<NAME>nsp_int2double</NAME>
<RETURNS>int </RETURNS>
int *n, int *idx, int *incx, double *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_int2float</NAME>
<RETURNS>int </RETURNS>
int *n, int *idx, int *incx, float *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_float2double</NAME>
<RETURNS>int </RETURNS>
int *n, float *rdx, int *incx, double *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_convert_double_to_type</NAME>
<RETURNS>int </RETURNS>
double *x, int n, const char *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_convert_type_to_double</NAME>
<RETURNS>int </RETURNS>
double *x, int n, const char *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_dset</NAME>
<RETURNS>int </RETURNS>
const int *n, const double *dx, double *dy, const int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dadd</NAME>
<RETURNS>int </RETURNS>
const int n, const double *dx,const int incx, double *dy,const int incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dsub</NAME>
<RETURNS>int </RETURNS>
const int n,const  double *dx,const int incx, double *dy,const  int incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dadd_maxplus</NAME>
<RETURNS>int </RETURNS>
const int n, const double *dx, const  int incx, double *dy, const  int incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dsub_maxplus</NAME>
<RETURNS>int </RETURNS>
const int n,const double *dx,const int incx, double *dy,const int incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dsum</NAME>
<RETURNS>double </RETURNS>
int *n, double *dx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_dvmul</NAME>
<RETURNS>int </RETURNS>
const int n,const  double *dx,const  int incx, double *dy,const  int incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_icopy</NAME>
<RETURNS>int </RETURNS>
const int *n, const int *idx, const int *incx, int *idy, const int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_iset</NAME>
<RETURNS>int </RETURNS>
int *n, int *idx, int *idy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_iadd</NAME>
<RETURNS>int </RETURNS>
int *n, int *ival, int *idy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dzcopy</NAME>
<RETURNS>int </RETURNS>
const int *n, const double *zx, const int *incx, doubleC *zy, const int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dzscal</NAME>
<RETURNS>int </RETURNS>
int *n, double *da, doubleC *zx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_dzset</NAME>
<RETURNS>int </RETURNS>
int *n, double *dx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zadd</NAME>
<RETURNS>int </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zadd_maxplus</NAME>
<RETURNS>int </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>myzabs</NAME>
<RETURNS>double </RETURNS>
double real, double imag
</FUNCTION>
<FUNCTION>
<NAME>nsp_zasum</NAME>
<RETURNS>double </RETURNS>
int *n, doubleC *zx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_zsub</NAME>
<RETURNS>int </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zsub_maxplus</NAME>
<RETURNS>int </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zsum</NAME>
<RETURNS>void </RETURNS>
doubleC *ret_val, int *n, doubleC *zx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_zvmul</NAME>
<RETURNS>int </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_urand</NAME>
<RETURNS>double </RETURNS>
int *iy
</FUNCTION>
<FUNCTION>
<NAME>nsp_magic_matrix_fill</NAME>
<RETURNS>void </RETURNS>
double *m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_franck_matrix</NAME>
<RETURNS>void </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_franck_inverse_matrix</NAME>
<RETURNS>void </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_hilbert_matrix</NAME>
<RETURNS>void </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_hilbert_inverse_matrix</NAME>
<RETURNS>void </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_complex2double</NAME>
<RETURNS>void </RETURNS>
double *tab, int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_double2complex</NAME>
<RETURNS>void </RETURNS>
 double *tab, int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_dsumrows</NAME>
<RETURNS>void </RETURNS>
double *x, double *res, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_zsumrows</NAME>
<RETURNS>void </RETURNS>
doubleC *x, doubleC *res, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_dprod</NAME>
<RETURNS>double </RETURNS>
double *x, int n, int incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_dprodrows</NAME>
<RETURNS>void </RETURNS>
double *x, double *res, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_dcross</NAME>
<RETURNS>void </RETURNS>
double *A, double *B, double *C, int n, int dim_flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_zcross</NAME>
<RETURNS>void </RETURNS>
doubleC *A, doubleC *B, doubleC *C, int n, int dim_flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_dzdot</NAME>
<RETURNS>doubleC </RETURNS>
double *A, doubleC *B, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_zddot</NAME>
<RETURNS>doubleC </RETURNS>
doubleC *A, double *B, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rowdddot</NAME>
<RETURNS>void </RETURNS>
double *A, double *B, double *Z, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rowdzdot</NAME>
<RETURNS>void </RETURNS>
double *A, doubleC *B, doubleC *Z, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rowzddot</NAME>
<RETURNS>void </RETURNS>
doubleC *A, double *B, doubleC *Z, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rowzzdot</NAME>
<RETURNS>void </RETURNS>
doubleC *A, doubleC *B, doubleC *Z, int m, int n
</FUNCTION>
<STRUCT>
<NAME>NspTypeSMatrix</NAME>
typedef struct _NspTypeSMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeSMatrix;
</STRUCT>
<STRUCT>
<NAME>NspSmatrix</NAME>
struct _NspSmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeSMatrix *type; 
  /*< public >*/
  int m,n,mn;
  nsp_string *S;  /* a table of mn+1 strings the last one is NULL */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_smatrix_id</NAME>
extern int nsp_type_smatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_smatrix</NAME>
extern NspTypeSMatrix *nsp_type_smatrix;
</VARIABLE>
<FUNCTION>
<NAME>new_type_smatrix</NAME>
<RETURNS>NspTypeSMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_smatrix</NAME>
<RETURNS>NspSMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSTRING</NAME>
#define NULLSTRING (nsp_string) 0
</MACRO>
<MACRO>
<NAME>NULLSMAT</NAME>
#define NULLSMAT   (NspSMatrix *) 0
</MACRO>
<FUNCTION>
<NAME>nsp_smatrix_object</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_object</NAME>
<RETURNS>char *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSMat</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsString</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSMatCopy</NAME>
<RETURNS>NspSMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSMat</NAME>
<RETURNS>NspSMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetString</NAME>
<RETURNS>char *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetStringInArray</NAME>
<RETURNS>int </RETURNS>
Stack stack, int ith, char **Table, int flag
</FUNCTION>
<FUNCTION>
<NAME>GetStringInStruct</NAME>
<RETURNS>int </RETURNS>
Stack stack, int ith,void *T,unsigned int size, int flag
</FUNCTION>
<FUNCTION>
<NAME>is_string_in_array</NAME>
<RETURNS>int </RETURNS>
const char *key, char **Table, int flag
</FUNCTION>
<FUNCTION>
<NAME>string_not_in_array</NAME>
<RETURNS>void </RETURNS>
Stack stack,const char *key, char **Table,char *message
</FUNCTION>
<FUNCTION>
<NAME>is_string_in_struct</NAME>
<RETURNS>int </RETURNS>
const char *key,void **Table,unsigned int size, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create</NAME>
<RETURNS>NspSMatrix *</RETURNS>
nsp_const_string name,int m,int n,nsp_const_string str,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_clone</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const char *name, NspSMatrix *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_with_length</NAME>
<RETURNS>NspSMatrix *</RETURNS>
nsp_const_string name, int m, int n, int strl
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_from_table</NAME>
<RETURNS>NspSMatrix *</RETURNS>
char **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_from_array</NAME>
<RETURNS>NspSMatrix *</RETURNS>
nsp_const_string name,int n,const char **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_from_struct</NAME>
<RETURNS>NspSMatrix*</RETURNS>
nsp_const_string name,const void *T,unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_copy</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_resize</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_info</NAME>
<RETURNS>int </RETURNS>
const NspSMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_print</NAME>
<RETURNS>int </RETURNS>
const NspSMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_print_multicols</NAME>
<RETURNS>int </RETURNS>
const NspSMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_redim</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_right</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,const NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>Scopy</NAME>
<RETURNS>int </RETURNS>
int n, nsp_string *s1, nsp_string *s2
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_add_columns</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>Sset</NAME>
<RETURNS>int </RETURNS>
int n, nsp_string s1, nsp_string *s2
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_down</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const NspSMatrix *A,const NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_down1</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspSMatrix *B,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_add_rows</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,const NspMatrix *Rows,const NspMatrix *Cols,const NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_set_rows</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, NspMatrix *Rows, NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract_elements</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, NspMatrix *Elts, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract_columns</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>SMatLoopCol</NAME>
<RETURNS>NspSMatrix *</RETURNS>
char *str, NspSMatrix *Col, NspSMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract_rows</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_strings</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, NspSMatrix *B,nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_string_right</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, NspSMatrix *B, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_string_left</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, NspSMatrix *B, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strcmp</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSMatrix *A, NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_column_concat_padded</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_column_concat</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_row_concat</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_elts_concat</NAME>
<RETURNS>nsp_string </RETURNS>
const NspSMatrix *A, nsp_const_string rstr, int rflag, nsp_const_string cstr, int cflag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_part</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, NspMatrix *Ind
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_elts_length</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_smatrix</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_tolower</NAME>
<RETURNS>void </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_toupper</NAME>
<RETURNS>void </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_capitalize</NAME>
<RETURNS>void </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strstr</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSMatrix *A, nsp_const_string Str
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strindex</NAME>
<RETURNS>NspMatrix *</RETURNS>
nsp_const_string Str,nsp_const_string Motif
</FUNCTION>
<FUNCTION>
<NAME>nsp_ascii_to_smatrix</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_to_ascii</NAME>
<RETURNS>NspMatrix *</RETURNS>
nsp_const_string S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_sort_old</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSMatrix *A,int flag,nsp_const_string  str1,nsp_const_string str2
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_split_string</NAME>
<RETURNS>NspSMatrix *</RETURNS>
nsp_const_string string, nsp_const_string splitChars, int msep
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_split</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *Src, nsp_const_string splitChars, int msep
</FUNCTION>
<FUNCTION>
<NAME>nsp_row_smatrix_append_string</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>SMatCompOp</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspSMatrix *A, NspSMatrix *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>SMatFullComp</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, NspSMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_transpose</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_subst</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const NspSMatrix *A,nsp_const_string needle,nsp_const_string  replace
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strip_blanks</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_read_lines</NAME>
<RETURNS>int </RETURNS>
NspFile *F,NspSMatrix **S,int nlines
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_convert</NAME>
<RETURNS>NspSMatrix*</RETURNS>
const char *name,NspSMatrix *A,const char *to_codeset,const char *from_codeset
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_to_utf8</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_to_latin1</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_utf8_validate</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_utf8_from_unichar</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_latex_print</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *SMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_latex_tab_print</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *SMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_fscanf_matrix</NAME>
<RETURNS>int </RETURNS>
NspFile *F,char *format,NspMatrix **M,int flag,NspSMatrix **S
</FUNCTION>
<FUNCTION>
<NAME>nsp_read_lines</NAME>
<RETURNS>int </RETURNS>
NspFile *F,NspSMatrix **S,int nlines
</FUNCTION>
<FUNCTION>
<NAME>nsp_fscanf_smatrix</NAME>
<RETURNS>int </RETURNS>
NspFile *F,NspSMatrix **S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strtod</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspSMatrix *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_unique</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *x, NspObject **Ind, NspMatrix **Occ, Boolean first_ind, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_issorted</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspSMatrix *A, int flag, Boolean strict_order
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_has</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspSMatrix *A, NspSMatrix *x, int lhs, NspMatrix **ind, NspMatrix **ind2
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract_diag</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspSMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_set_diag</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, NspSMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_diag</NAME>
<RETURNS>NspSMatrix  *</RETURNS>
NspSMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_latex_utf8_symbols</NAME>
<RETURNS>NspSMatrix *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_type_as_string</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_type_short_string</NAME>
<RETURNS>char *</RETURNS>
NspObject *v
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_loop_extract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_eq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_neq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_is_true</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_xdr_load</NAME>
<RETURNS>NspSMatrix *</RETURNS>
XDR  *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *F, NspSMatrix *M
</FUNCTION>
<STRUCT>
<NAME>NspTypeMaxpMatrix</NAME>
typedef struct _NspTypeMaxpMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeMaxpMatrix;
</STRUCT>
<STRUCT>
<NAME>NspMpmatrix</NAME>
struct _NspMpmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeMaxpMatrix *type; 
  /*< public >*/
  int m,n,mn;/* NspMaxpMatrix dimensions */
  union { 
    double *R;     /* Pointer on real values */
    doubleC *C;    /* Pointer on complex values */
    int *I;        /* Pointer on integer values */
    float *F;      /* Pointer on float values */
  };
  char rc_type;    /* 'r' : real or  'c' : complex  */
  char convert;    /* 'd','i','f' , 'u' : double, int, float
		    * used to remember array converted in place */
  int impl[2];     /* start, step */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_mpmatrix_id</NAME>
extern int nsp_type_mpmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_mpmatrix</NAME>
extern NspTypeMaxpMatrix *nsp_type_mpmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_mpmatrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_mpmatrix</NAME>
<RETURNS>NspTypeMaxpMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_mpmatrix</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLMAXPMAT</NAME>
#define NULLMAXPMAT (NspMaxpMatrix*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_mpmatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_info</NAME>
<RETURNS>int </RETURNS>
 NspMaxpMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_copy</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_print</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_loop_extract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_copy</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_object</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_object</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsMpMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsMpMat</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatCopy</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatCopyInt</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatInt</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatCopyFloat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatFloat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopy_G</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMat_G</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopy</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopyInt</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatInt</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopyFloat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatFloat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>MpMatd2i</NAME>
<RETURNS>int *</RETURNS>
NspMaxpMatrix *A, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>MpMat2double</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>MpMat2int</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>MpMat2float</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mp_matrix_from_m</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const char *name,NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const char *name, char type, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_clone</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const char *name, NspMatrix *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create_impl</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
double first, double step, double last
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create_from_doubles</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const char *name,int m,int n,...
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_fill_with</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_resize</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_scalar_to_mn</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_latex_print</NAME>
<RETURNS>int </RETURNS>
const NspMaxpMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_latex_tab_print</NAME>
<RETURNS>int </RETURNS>
const NspMaxpMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_redim</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_concat_right</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_add_columns</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_concat_down</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_concat_diag</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_add_rows</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_set_rows</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMatrix *Rows, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Rows,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_elements</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_columns</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_rows</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>MpMatLoopCol</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
char *str, NspMaxpMatrix *Col, NspMaxpMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_diag</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_set_diag</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create_diag</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_transpose</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_set_rval</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_set_ival</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_add</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_dadd</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_add_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sub</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_dsub</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sub_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_subs_calarm</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_clean</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, int rhs, double epsa, double epsr
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_maxitt1</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B, NspMaxpMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_minitt1</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B, NspMaxpMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_slec</NAME>
<RETURNS>NspMaxpMatrix **</RETURNS>
char *file, int *Count
</FUNCTION>
<FUNCTION>
<NAME>MaxpMatLec</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
FILE *fd
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_readline</NAME>
<RETURNS>int </RETURNS>
FILE *fd
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_complexify</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_get_real</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_get_imag</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_inv_el</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_kron</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sort</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, int flag, char *str1, char *str2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sum</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_prod</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cum_prod</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cum_sum</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_maxi</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag, NspMaxpMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mini</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag, NspMaxpMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_createinit</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
char *name, char type, int m, int n, double (*func) ()
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_triu</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_tril</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_eye</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ones</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_zeros</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_rand</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_tt</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_el</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_scalarm</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_div_tt</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_div_el</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_div_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_bdiv_tt</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_bdiv_el</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_bdiv_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult_tt</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult_el</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_acos</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_acosh</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_asin</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_asinh</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_atan</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_atan2</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A,NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_atanh</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ceil</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_modulo</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_idiv</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_int</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_floor</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_round</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sign</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_tan</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_tanh</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_abs</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_erf</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_erfc</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_arg</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_polar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_iand</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_iandu</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ior</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ioru</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_conj</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cos</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cosh</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_expel</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_logel</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sin</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sinh</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sqrtel</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_minus</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_magic</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_franck</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int n, int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_hilbert</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int n,int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_fullcomp</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_find</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int lhs, NspMaxpMatrix **Res1, NspMaxpMatrix **Res2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_cast_to_matrix</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMaxpMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_cast_to_mpmatrix</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_graphic_context</NAME>
<RETURNS>BCG *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>store_graphic_object</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,NspObject *obj
</FUNCTION>
<FUNCTION>
<NAME>fillpolylines3D</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double *vectsx, double *vectsy, double *vectsz, int *fillvect,int n, int p
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_force_redraw</NAME>
<RETURNS>void </RETURNS>
nsp_figure *F,void *rect
</FUNCTION>
<FUNCTION>
<NAME>apply_transforms</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double Coord[],const double *M, VisionPos pos[],const double lim[], int ncoord
</FUNCTION>
<FUNCTION>
<NAME>apply_transforms_new</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double Coord[],const double *M, VisionPos pos[],const double lim[], int ncoord
</FUNCTION>
<VARIABLE>
<NAME>GL_gengine</NAME>
extern Gengine GL_gengine;
</VARIABLE>
<FUNCTION>
<NAME>nsp_polyhedron_create_from_triplet</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
char *name,double *x,double *y,double *z,int m,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_create_from_triplet</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
char *name,double *x,double *y,double *z,int m,int n,double *col, int ncol
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_update_from_triplet</NAME>
<RETURNS>int </RETURNS>
NspSPolyhedron *pol,double *x,double *y,double *z,int m,int n, double *col,int ncol
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_to_faces</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name,NspMatrix *F,double *x,int xmn,double *y,int ymn
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_to_coords</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name,NspMatrix *C,double *x,double *y,double *z,int m,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_facets_to_faces</NAME>
<RETURNS>int </RETURNS>
double *x,double *y,double *z,int *colors,int ncol,int m,int n,NspMatrix **Cr,NspMatrix **Fr,NspMatrix **Colr
</FUNCTION>
<FUNCTION>
<NAME>apply_transforms_new</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double Coord[],const double *M, VisionPos pos[],const double lim[], int ncoord
</FUNCTION>
<FUNCTION>
<NAME>apply_transforms_new1</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double Coord[],const double *M, VisionPos pos[],const double lim[], int ncoord
</FUNCTION>
<FUNCTION>
<NAME>fillpolylines3D_shade</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double *vectsx, double *vectsy, double *vectsz, int *fillvect,int n, int p
</FUNCTION>
<FUNCTION>
<NAME>nsp_obj3d_orientation</NAME>
<RETURNS>int </RETURNS>
int x[], int y[], int n
</FUNCTION>
<STRUCT>
<NAME>NspGRoot</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGRoot</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGRoot</NAME>
struct _NspTypeGRoot {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 43 "./groot.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_groot</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_groot</NAME>
struct _nsp_groot {
  NspList* figures;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspGRoot</NAME>
struct _NspGRoot {
  /*< private >*/
  NspObject father;
  NspTypeGRoot*type;
  /*< public >*/
  nsp_groot *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_groot_id</NAME>
extern int nsp_type_groot_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_groot</NAME>
extern NspTypeGRoot *nsp_type_groot;
</VARIABLE>
<FUNCTION>
<NAME>new_type_groot</NAME>
<RETURNS>NspTypeGRoot *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_groot</NAME>
<RETURNS>NspGRoot *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLGROOT</NAME>
#define NULLGROOT (NspGRoot*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_groot_create</NAME>
<RETURNS>NspGRoot *</RETURNS>
const char *name,NspList* figures,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_create_default</NAME>
<RETURNS>NspGRoot *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_copy</NAME>
<RETURNS>NspGRoot *</RETURNS>
NspGRoot *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_destroy</NAME>
<RETURNS>void </RETURNS>
NspGRoot *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_info</NAME>
<RETURNS>int </RETURNS>
NspGRoot *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_print</NAME>
<RETURNS>int </RETURNS>
NspGRoot *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_latex</NAME>
<RETURNS>int </RETURNS>
NspGRoot *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_object</NAME>
<RETURNS>NspGRoot *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGRootObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsGRoot</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetGRootCopy</NAME>
<RETURNS>NspGRoot *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGRoot</NAME>
<RETURNS>NspGRoot *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_create_partial</NAME>
<RETURNS>int </RETURNS>
NspGRoot *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspGRoot *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_copy_partial</NAME>
<RETURNS>NspGRoot *</RETURNS>
NspGRoot *H,NspGRoot *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_full_copy_partial</NAME>
<RETURNS>NspGRoot *</RETURNS>
NspGRoot *H,NspGRoot *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_full_copy</NAME>
<RETURNS>NspGRoot *</RETURNS>
NspGRoot *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_check_values</NAME>
<RETURNS>int </RETURNS>
NspGRoot *H
</FUNCTION>
<FUNCTION>
<NAME>int_groot_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_xdr_load_partial</NAME>
<RETURNS>NspGRoot *</RETURNS>
XDR *xdrs, NspGRoot *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_groot_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspGRoot *M
</FUNCTION>
<STRUCT>
<NAME>NspSqlC</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSqlC</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSqlC</NAME>
struct _NspTypeSqlC {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 29 "./sqlc.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_sqlc</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_sqlc</NAME>
struct _nsp_sqlc {
  gint op;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspSqlC</NAME>
struct _NspSqlC {
  /*< private >*/
  NspObject father;
  NspTypeSqlC*type;
  /*< public >*/
  nsp_sqlc *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_sqlc_id</NAME>
extern int nsp_type_sqlc_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_sqlc</NAME>
extern NspTypeSqlC *nsp_type_sqlc;
</VARIABLE>
<FUNCTION>
<NAME>new_type_sqlc</NAME>
<RETURNS>NspTypeSqlC *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_sqlc</NAME>
<RETURNS>NspSqlC *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSQLC</NAME>
#define NULLSQLC (NspSqlC*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_sqlc_create</NAME>
<RETURNS>NspSqlC *</RETURNS>
char *name,gint op,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_copy</NAME>
<RETURNS>NspSqlC *</RETURNS>
NspSqlC *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_destroy</NAME>
<RETURNS>void </RETURNS>
NspSqlC *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_info</NAME>
<RETURNS>int </RETURNS>
NspSqlC *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_print</NAME>
<RETURNS>int </RETURNS>
NspSqlC *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_latex</NAME>
<RETURNS>int </RETURNS>
NspSqlC *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_object</NAME>
<RETURNS>NspSqlC *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSqlCObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSqlC</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSqlCCopy</NAME>
<RETURNS>NspSqlC *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSqlC</NAME>
<RETURNS>NspSqlC *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_create_partial</NAME>
<RETURNS>int </RETURNS>
NspSqlC *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspSqlC *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_copy_partial</NAME>
<RETURNS>NspSqlC *</RETURNS>
NspSqlC *H,NspSqlC *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_full_copy_partial</NAME>
<RETURNS>NspSqlC *</RETURNS>
NspSqlC *H,NspSqlC *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_full_copy</NAME>
<RETURNS>NspSqlC *</RETURNS>
NspSqlC *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_check_values</NAME>
<RETURNS>int </RETURNS>
NspSqlC *H
</FUNCTION>
<FUNCTION>
<NAME>int_sqlc_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_xdr_load_partial</NAME>
<RETURNS>NspSqlC *</RETURNS>
XDR *xdrs, NspSqlC *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlc_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspSqlC *M
</FUNCTION>
<STRUCT>
<NAME>NspTypeMatrix</NAME>
typedef struct _NspTypeMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeMatrix;
</STRUCT>
<STRUCT>
<NAME>NspMatrix</NAME>
struct _NspMatrix {
  /*< private >*/
  NspObject father; 
  NspTypeMatrix *type; 
  /*< public >*/
  int m,n,mn;/* NspMatrix dimensions */
  union { 
    double *R;     /* Pointer on real values */
    doubleC *C;    /* Pointer on complex values */
    int *I;        /* Pointer on integer values */
    float *F;        /* Pointer on float values */
  };
  char rc_type;    /* 'r' : real or  'c' : complex  */
  char convert;    /* 'd','i','f','c','u': double, int, float, old_complex, unexpanded
		    * used to remember array converted in place 
		    */
  int impl[2];     /* start, step */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_matrix_id</NAME>
extern int nsp_type_matrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_matrix</NAME>
extern NspTypeMatrix *nsp_type_matrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_matrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_matrix</NAME>
<RETURNS>NspTypeMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_matrix</NAME>
<RETURNS>NspMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLMAT</NAME>
#define NULLMAT (NspMatrix*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_alloc_doubles</NAME>
<RETURNS>double *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_realloc_doubles</NAME>
<RETURNS>double *</RETURNS>
double *dp, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_int</NAME>
<RETURNS>int *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_realloc_int</NAME>
<RETURNS>int *</RETURNS>
int *dp, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_doubleC</NAME>
<RETURNS>doubleC *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_realloc_doubleC</NAME>
<RETURNS>doubleC *</RETURNS>
doubleC *dp, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_work_doubles</NAME>
<RETURNS>double *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_work_int</NAME>
<RETURNS>int *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_work_doubleC</NAME>
<RETURNS>doubleC *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_mat_or_imat</NAME>
<RETURNS>NspObject *</RETURNS>
int m, int n, char ind_type, int **index
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_info</NAME>
<RETURNS>int </RETURNS>
 NspMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_copy</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_print</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_latex_array_double</NAME>
<RETURNS>int </RETURNS>
int indent, char *name, double *val, int size, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_array_double</NAME>
<RETURNS>int </RETURNS>
int indent, char *name, double *val, int size, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>matrix_loop_extract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>matrix_object</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_fullcomp</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, char *op,int *err
</FUNCTION>
<FUNCTION>
<NAME>matrix_object</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsMat</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetMatCopyInt</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMatInt</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMatCopyFloat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMatFloat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopy_G</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMat_G</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopy</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopyInt</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatInt</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopyFloat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatFloat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMtlbMatCopy</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMtlbMat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IntScalar</NAME>
<RETURNS>int </RETURNS>
NspObject *O, int *val
</FUNCTION>
<FUNCTION>
<NAME>GetScalarInt</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i, int *val
</FUNCTION>
<FUNCTION>
<NAME>DoubleScalar</NAME>
<RETURNS>int </RETURNS>
NspObject *O, double *val
</FUNCTION>
<FUNCTION>
<NAME>GetScalarDouble</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i, double *val
</FUNCTION>
<FUNCTION>
<NAME>Matd2i</NAME>
<RETURNS>int *</RETURNS>
NspMatrix *A, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>Bounds</NAME>
<RETURNS>void </RETURNS>
const NspMatrix *A, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_boundster</NAME>
<RETURNS>void </RETURNS>
const NspMatrix *A, int *ind, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>Mat2double</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>Mat2int</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>Mat2float</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>Mat2mtlb_cplx</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix * A
</FUNCTION>
<USER_FUNCTION>
<NAME>F_Enlarge</NAME>
<RETURNS>int </RETURNS>
void *A,int m,int n
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name, char type, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_clone</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name, NspMatrix *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_impl</NAME>
<RETURNS>NspMatrix *</RETURNS>
double first, double step, double last
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_int_impl</NAME>
<RETURNS>NspMatrix *</RETURNS>
int first, int step, int last
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_linspace</NAME>
<RETURNS>NspMatrix *</RETURNS>
const double first[],const double last[],int r,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_logspace</NAME>
<RETURNS>NspMatrix *</RETURNS>
const double first[],const double last[],int r,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_from_doubles</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name,int m,int n,...
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_from_array</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name,int m,int n,const double valr[],const double valc[]
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_fill_with</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_resize</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_scalar_to_mn</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_latex_print</NAME>
<RETURNS>int </RETURNS>
const NspMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_latex_tab_print</NAME>
<RETURNS>int </RETURNS>
const NspMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_redim</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_concat_right</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_add_columns</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_concat_down</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_concat_diag</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_add_rows</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>GenericMatSeRoBis</NAME>
<RETURNS>int </RETURNS>
void *A, int Am, int An, int Amn, int nb_ind, int rmin, int rmax,void *B, int Bm, int Bn, int Bmn, F_Enlarge F, int *Bscal
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_set_rows</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *Rows, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>mat_is_increasing</NAME>
<RETURNS>int </RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const  NspMatrix *Rows,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_elements</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const  NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_columns</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_rows</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const  NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>MatLoopCol</NAME>
<RETURNS>NspMatrix *</RETURNS>
char *str, NspMatrix *Col, NspMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_diag</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_set_diag</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_diag</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_transpose</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_scale_rows</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_scale_cols</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_diff</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, int order, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult_scalar_bis</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add_scalar_bis</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add_mat</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub_scalar_bis</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalar_sub_mat_bis</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub_mat</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_set_rval</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_copy_and_complexify</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_set_ival</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_dadd</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_dadd_maxplus</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add_scalar_maxplus</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_dsub</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub_scalar_maxplus</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_subs_calarm</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_clean</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, int rhs, double epsa, double epsr
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxitt1</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, NspMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minitt1</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, NspMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minmax</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int dim, NspMatrix **Amin, NspMatrix **Imin,NspMatrix **Amax, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_slec</NAME>
<RETURNS>NspMatrix **</RETURNS>
char *file, int *Count
</FUNCTION>
<FUNCTION>
<NAME>fopen</NAME>
<RETURNS>FILE *</RETURNS>
const char *, const char *
</FUNCTION>
<FUNCTION>
<NAME>MatLec</NAME>
<RETURNS>NspMatrix *</RETURNS>
FILE *fd
</FUNCTION>
<FUNCTION>
<NAME>fooBOU</NAME>
<RETURNS>NspMatrix *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_csetd</NAME>
<RETURNS>void </RETURNS>
const int *n,const double *z,doubleC *tab,const int *inc
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_complexify</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_get_real</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_get_imag</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_isreal</NAME>
<RETURNS>int </RETURNS>
const NspMatrix *A, int strict
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_inv_el</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_kron</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sort</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, int flag, char *str1, char *str2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sum</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_prod</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cum_prod</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A,  int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cum_sum</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A,  int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxi</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, int dim_flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mini</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, int dim_flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_createinit</NAME>
<RETURNS>NspMatrix *</RETURNS>
char *name, char type, int m, int n, double (*func) ()
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_triu</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tril</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_eye</NAME>
<RETURNS>NspMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ones</NAME>
<RETURNS>NspMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_zeros</NAME>
<RETURNS>NspMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_rand</NAME>
<RETURNS>NspMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_randn</NAME>
<RETURNS>NspMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_matscalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_matmat</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_scalarmat</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_tt</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_el</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_scalarm</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_div_tt</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_div_el</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_div_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_tt</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_el</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult_tt</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult_el</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_acos</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_acosh</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_asin</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_asinh</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_atan</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_atan2</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A,NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_angle</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *Z
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_atanh</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ceil</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_modulo</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_idiv</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mod</NAME>
<RETURNS>void </RETURNS>
NspMatrix *x, NspMatrix *y
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_int</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_floor</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_round</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sign</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tan</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tanh</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_abs</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_erf</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_erfc</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_lgamma</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tgamma</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_polar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_complex</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_nearfloat</NAME>
<RETURNS>int </RETURNS>
int dir, NspMatrix *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_iand</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_iandu</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ior</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ioru</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ishift</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,int shift,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_conj</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cos</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cosh</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_expel</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_logel</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sin</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sinh</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sqrtel</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minus</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minus_maxplus</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_magic</NAME>
<RETURNS>NspMatrix *</RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_franck</NAME>
<RETURNS>NspMatrix *</RETURNS>
int n, int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_hilbert</NAME>
<RETURNS>NspMatrix *</RETURNS>
int n,int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_fullcomp</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_find</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int lhs, NspObject **Res1, NspObject **Res2, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mfind</NAME>
<RETURNS>int </RETURNS>
const NspMatrix *x, int m,const char **ops,const double *scalars, NspObject **Ind, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ndind2ind</NAME>
<RETURNS>int </RETURNS>
int *dims, int nd, NspMatrix **ndind, NspObject **Ind, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub2ind</NAME>
<RETURNS>int </RETURNS>
int *dims, int nd, NspMatrix **ndind, int nb_ind, NspObject **Ind, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ind2sub</NAME>
<RETURNS>int </RETURNS>
int *dims, int nd, NspObject **ndind, NspObject *Obj, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_nnz</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_unique</NAME>
<RETURNS>int </RETURNS>
NspMatrix *x, NspObject **Ind, NspMatrix **Occ, Boolean first_ind, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_unique_rows</NAME>
<RETURNS>int </RETURNS>
NspMatrix *x, NspObject **Ind, NspMatrix **Occ, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_unique_columns</NAME>
<RETURNS>int </RETURNS>
NspMatrix *x, NspObject **Ind, NspMatrix **Occ, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_dot</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B, int dim_flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cross</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *X, NspMatrix *Y, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_issorted</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspMatrix *A, int flag, Boolean strict_order, Boolean nan_ordered
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_has</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspMatrix *A, NspMatrix *x, int lhs, NspMatrix **ind, NspMatrix **ind2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxplus_add</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxplus_mult</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minplus_mult</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_array_maxi</NAME>
<RETURNS>int </RETURNS>
int n,const double *A, int incr, double *amax
</FUNCTION>
<FUNCTION>
<NAME>nsp_array_mini</NAME>
<RETURNS>int </RETURNS>
int n,const double *A, int incr, double *amax
</FUNCTION>
<FUNCTION>
<NAME>nsp_free_index_vector_cache</NAME>
<RETURNS>void </RETURNS>
index_vector *index
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_index_vector_cache</NAME>
<RETURNS>int </RETURNS>
index_vector *index
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_index_vector_from_object</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj,index_vector *index
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_index_vector</NAME>
<RETURNS>int </RETURNS>
Stack stack, int ipos,NspObject **Obj,index_vector *index
</FUNCTION>
<FUNCTION>
<NAME>nsp_fft</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_ifft</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *x
</FUNCTION>
<MACRO>
<NAME>NSP_MATRIX_INLINED</NAME>
#define NSP_MATRIX_INLINED static inline 
</MACRO>
<FUNCTION>
<NAME>GetMatCopy</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<STRUCT>
<NAME>NspTypeUmfpack</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeUmfpack</NAME>
struct _NspTypeUmfpack {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
};

</STRUCT>
<STRUCT>
<NAME>nsp_umfpack</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_umfpack</NAME>
struct _nsp_umfpack {
  char rc_type;
  char* data;
  nsp_sparse_triplet mtlb_T;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspUmfpack</NAME>
struct _NspUmfpack {
  /*< private >*/
  NspObject father;
  NspTypeUmfpack*type;
  /*< public >*/
  nsp_umfpack *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_umfpack_id</NAME>
extern int nsp_type_umfpack_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_umfpack</NAME>
extern NspTypeUmfpack *nsp_type_umfpack;
</VARIABLE>
<FUNCTION>
<NAME>new_type_umfpack</NAME>
<RETURNS>NspTypeUmfpack *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_umfpack</NAME>
<RETURNS>NspUmfpack *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLUMFPACK</NAME>
#define NULLUMFPACK (NspUmfpack*) 0
</MACRO>
<FUNCTION>
<NAME>umfpack_create</NAME>
<RETURNS>NspUmfpack *</RETURNS>
char *name,char rc_type,char* data,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_umfpack_copy</NAME>
<RETURNS>NspUmfpack *</RETURNS>
NspUmfpack *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_umfpack_destroy</NAME>
<RETURNS>void </RETURNS>
NspUmfpack *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_umfpack_info</NAME>
<RETURNS>int </RETURNS>
NspUmfpack *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_umfpack_print</NAME>
<RETURNS>int </RETURNS>
NspUmfpack *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_umfpack_object</NAME>
<RETURNS>NspUmfpack *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsUmfpackObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsUmfpack</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetUmfpackCopy</NAME>
<RETURNS>NspUmfpack *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetUmfpack</NAME>
<RETURNS>NspUmfpack *</RETURNS>
Stack stack, int i
</FUNCTION>
<STRUCT>
<NAME>NspPoints3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePoints3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePoints3d</NAME>
struct _NspTypePoints3d {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./points3d.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_points3d</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_points3d</NAME>
struct _nsp_points3d {
  NspMatrix* Mcoord;
  void* Mcoord_l;
  int color;
  int mark_type;
  int mark_size;
  int* pos;  int pos_length;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspPoints3d</NAME>
struct _NspPoints3d {
  /*< private >*/
  NspGraphic father;
  NspTypePoints3d*type;
  /*< public >*/
  nsp_points3d *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_points3d_id</NAME>
extern int nsp_type_points3d_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_points3d</NAME>
extern NspTypePoints3d *nsp_type_points3d;
</VARIABLE>
<FUNCTION>
<NAME>new_type_points3d</NAME>
<RETURNS>NspTypePoints3d *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_points3d</NAME>
<RETURNS>NspPoints3d *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLPOINTS3D</NAME>
#define NULLPOINTS3D (NspPoints3d*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_points3d_create</NAME>
<RETURNS>NspPoints3d *</RETURNS>
const char *name,NspMatrix* Mcoord,void* Mcoord_l,int color,int mark_type,int mark_size,int* pos, int pos_length,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_create_default</NAME>
<RETURNS>NspPoints3d *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_copy</NAME>
<RETURNS>NspPoints3d *</RETURNS>
NspPoints3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_destroy</NAME>
<RETURNS>void </RETURNS>
NspPoints3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_info</NAME>
<RETURNS>int </RETURNS>
NspPoints3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_print</NAME>
<RETURNS>int </RETURNS>
NspPoints3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_latex</NAME>
<RETURNS>int </RETURNS>
NspPoints3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_object</NAME>
<RETURNS>NspPoints3d *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsPoints3dObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsPoints3d</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetPoints3dCopy</NAME>
<RETURNS>NspPoints3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetPoints3d</NAME>
<RETURNS>NspPoints3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_create_partial</NAME>
<RETURNS>int </RETURNS>
NspPoints3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspPoints3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_copy_partial</NAME>
<RETURNS>NspPoints3d *</RETURNS>
NspPoints3d *H,NspPoints3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_full_copy_partial</NAME>
<RETURNS>NspPoints3d *</RETURNS>
NspPoints3d *H,NspPoints3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_full_copy</NAME>
<RETURNS>NspPoints3d *</RETURNS>
NspPoints3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_check_values</NAME>
<RETURNS>int </RETURNS>
NspPoints3d *H
</FUNCTION>
<FUNCTION>
<NAME>int_points3d_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_xdr_load_partial</NAME>
<RETURNS>NspPoints3d *</RETURNS>
XDR *xdrs, NspPoints3d *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_points3d_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspPoints3d *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_bounds_min_max</NAME>
<RETURNS>void </RETURNS>
int n,double *A,int incr,double *Amin, double *Amax
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_graphic_context</NAME>
<RETURNS>BCG *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>apply_transforms</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double Coord[],const double *M, VisionPos pos[],const double lim[], int ncoord
</FUNCTION>
<TYPEDEF>
<NAME>NTYPE</NAME>
typedef double NTYPE;
</TYPEDEF>
<MACRO>
<NAME>PIx2</NAME>
#define PIx2 6.283185307179586476925286        /* 2*pi */
</MACRO>
<MACRO>
<NAME>HF_LG_PIx2</NAME>
#define HF_LG_PIx2  0.918938533204672741780329736406    /* 0.5*log(2*pi) */
</MACRO>
<MACRO>
<NAME>DECLARE_D_0</NAME>
#define DECLARE_D_0 double _d0=0;
</MACRO>
<MACRO>
<NAME>LOG_ZERO</NAME>
#define LOG_ZERO (-(1/_d0))   /* to get -inf in double (was -1e-100 in the original code) */
</MACRO>
<MACRO>
<NAME>D_0</NAME>
#define D_0 ((give_log) ? LOG_ZERO : 0.0)
</MACRO>
<MACRO>
<NAME>D_1</NAME>
#define D_1 ((give_log) ? 0.0 : 1.0)
</MACRO>
<MACRO>
<NAME>DEXP</NAME>
#define DEXP(x)   ((give_log) ? (x) : exp(x))
</MACRO>
<MACRO>
<NAME>FEXP</NAME>
#define FEXP(f,x) ((give_log) ? -0.5*log(f)+(x) : exp(x)/sqrt(f))
</MACRO>
<MACRO>
<NAME>STIRLERR</NAME>
#define STIRLERR(n) nsp_stirlerr(n)
</MACRO>
<MACRO>
<NAME>FORCE_INT</NAME>
#define FORCE_INT(x) floor(x+0.5)
</MACRO>
<MACRO>
<NAME>NOT_NNEG_INT</NAME>
#define NOT_NNEG_INT(x) ((x<0.0) || (fabs((x) - floor((x)+0.5)) > 1e-7))
</MACRO>
<MACRO>
<NAME>INVALID_PARAMS</NAME>
#define INVALID_PARAMS -1.0  /* to be able to detect bad range parameters (was 0.0 original code) */
</MACRO>
<FUNCTION>
<NAME>nsp_stirlerr</NAME>
<RETURNS>double </RETURNS>
NTYPE n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bd0</NAME>
<RETURNS>double </RETURNS>
NTYPE x, double np
</FUNCTION>
<FUNCTION>
<NAME>nsp_dbinom_raw</NAME>
<RETURNS>double </RETURNS>
NTYPE x, NTYPE n, double p, double q, int give_log
</FUNCTION>
<FUNCTION>
<NAME>nsp_dpois_raw</NAME>
<RETURNS>double </RETURNS>
NTYPE x, double lambda, int give_log
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_beta</NAME>
<RETURNS>double </RETURNS>
double x, NTYPE a, NTYPE b, int give_log
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_binom</NAME>
<RETURNS>double </RETURNS>
NTYPE x, NTYPE n, double p, int give_log
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_f</NAME>
<RETURNS>double </RETURNS>
double x, NTYPE m, NTYPE n, int give_log
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_gamma</NAME>
<RETURNS>double </RETURNS>
double x, NTYPE r, double lambda, int give_log
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_hyper</NAME>
<RETURNS>double </RETURNS>
NTYPE x, NTYPE r, NTYPE b, NTYPE n, int give_log
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_nbinom</NAME>
<RETURNS>double </RETURNS>
NTYPE x, NTYPE n, double p, int give_log
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_pois</NAME>
<RETURNS>double </RETURNS>
NTYPE x, double lambda, int give_log
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_t</NAME>
<RETURNS>double </RETURNS>
double x, NTYPE df, int give_log
</FUNCTION>
<FUNCTION>
<NAME>lnp1m1</NAME>
<RETURNS>double </RETURNS>
double s
</FUNCTION>
<FUNCTION>
<NAME>nsp_log1p</NAME>
<RETURNS>double </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_expm1</NAME>
<RETURNS>double </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_erfcx</NAME>
<RETURNS>double </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_sinpi</NAME>
<RETURNS>double </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_cospi</NAME>
<RETURNS>double </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_tanpi</NAME>
<RETURNS>double </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_cotanpi</NAME>
<RETURNS>double </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_gamma</NAME>
<RETURNS>double </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_lngamma</NAME>
<RETURNS>double </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_digamma</NAME>
<RETURNS>double </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_kcdf</NAME>
<RETURNS>int </RETURNS>
double x, double *res, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_kcdflim</NAME>
<RETURNS>double </RETURNS>
double x, double *q
</FUNCTION>
<FUNCTION>
<NAME>nsp_invkcdflim</NAME>
<RETURNS>int </RETURNS>
double p, double q, double *x
</FUNCTION>
<FUNCTION>
<NAME>marsaglia_K</NAME>
<RETURNS>double </RETURNS>
double x, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_hypot</NAME>
<RETURNS>double </RETURNS>
double x, double y
</FUNCTION>
<FUNCTION>
<NAME>nsp_primefactors</NAME>
<RETURNS>void </RETURNS>
unsigned int n, unsigned int *factors, int *powers, int *nb_factors
</FUNCTION>
<FUNCTION>
<NAME>nsp_isprime</NAME>
<RETURNS>int </RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_primes</NAME>
<RETURNS>int </RETURNS>
int n, int **Primes, int *nb_primes
</FUNCTION>
<FUNCTION>
<NAME>nsp_convhull2d</NAME>
<RETURNS>void </RETURNS>
int n, double *x, double *y, int *nhull, int *ind, int *p
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_normal</NAME>
<RETURNS>double </RETURNS>
double x, double mu, double sigma
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_lognormal</NAME>
<RETURNS>double </RETURNS>
double x, double mu, double sigma
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_chi2</NAME>
<RETURNS>double </RETURNS>
double x, double nu
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_nchi2</NAME>
<RETURNS>double </RETURNS>
double x, double nu, double xnonc
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_exp</NAME>
<RETURNS>double </RETURNS>
double x, double Av
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_cauchy</NAME>
<RETURNS>double </RETURNS>
double x, double sigma
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_pareto</NAME>
<RETURNS>double </RETURNS>
double x, double a, double b
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_laplace</NAME>
<RETURNS>double </RETURNS>
double x, double a
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_logistic</NAME>
<RETURNS>double </RETURNS>
double x, double a, double b
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_weibull</NAME>
<RETURNS>double </RETURNS>
double x, double a, double b
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_rayleigh</NAME>
<RETURNS>double </RETURNS>
double x, double sigma
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_tailrayleigh</NAME>
<RETURNS>double </RETURNS>
double x, double sigma, double a
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_geometric</NAME>
<RETURNS>double </RETURNS>
double x, double p
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_uin</NAME>
<RETURNS>double </RETURNS>
double x, double n1, double n2
</FUNCTION>
<FUNCTION>
<NAME>nsp_pdf_unf</NAME>
<RETURNS>double </RETURNS>
double x, double a, double b
</FUNCTION>
<FUNCTION>
<NAME>nsp_binomial_coef</NAME>
<RETURNS>int </RETURNS>
double n, double k, double *res
</FUNCTION>
<TYPEDEF>
<NAME>Dxblk2</NAME>
typedef struct Dxblk2_ Dxblk2; 
</TYPEDEF>
<FUNCTION>
<NAME>dxlegf</NAME>
<RETURNS>int </RETURNS>
Dxblk2 *dxblk2, double *dnu1, int *nudiff, int *mu1, int *mu2, double *x, int *id, double *pqa, int *ipqa, int *ierror
</FUNCTION>
<STRUCT>
<NAME>NspTypeModule</NAME>
typedef struct _NspTypeModule { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeModule;
</STRUCT>
<STRUCT>
<NAME>NspModule</NAME>
struct _NspModule {
  /*< private >*/
  NspObject father; 
  NspTypeModule *type; 
  /*< public >*/
  char *path ; /* absolute XXX path of the module */
  char *mname;  /* module name */
  NspHash *T;      /* hash table to store module objects of type me (module elts) */
  NspList *L;       /* List of submodules */
  int flag;     /* are we a copy ? */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_module_id</NAME>
extern int nsp_type_module_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_module</NAME>
extern NspTypeModule *nsp_type_module;
</VARIABLE>
<FUNCTION>
<NAME>new_type_module</NAME>
<RETURNS>NspTypeModule *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_module</NAME>
<RETURNS>NspModule *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLMODULE</NAME>
#define NULLMODULE (NspModule*) 0
</MACRO>
<FUNCTION>
<NAME>module_create</NAME>
<RETURNS>NspModule *</RETURNS>
char *name,const char *path,const char *mname,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>module_copy</NAME>
<RETURNS>NspModule *</RETURNS>
NspModule *H
</FUNCTION>
<FUNCTION>
<NAME>module_destroy</NAME>
<RETURNS>void </RETURNS>
NspModule *H
</FUNCTION>
<FUNCTION>
<NAME>module_info</NAME>
<RETURNS>int </RETURNS>
NspModule *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>module_print</NAME>
<RETURNS>int </RETURNS>
NspModule *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>module_object</NAME>
<RETURNS>NspModule *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsModuleObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsModule</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetModuleCopy</NAME>
<RETURNS>NspModule *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetModule</NAME>
<RETURNS>NspModule *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>module_copy_ref</NAME>
<RETURNS>NspModule *</RETURNS>
NspModule *Mod
</FUNCTION>
<FUNCTION>
<NAME>nsp_module_search_name</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,char **Mname
</FUNCTION>
<FUNCTION>
<NAME>nsp_insert_module_last</NAME>
<RETURNS>int </RETURNS>
NspList *L,char *dir,char **Mname
</FUNCTION>
<FUNCTION>
<NAME>nsp_module_import</NAME>
<RETURNS>int </RETURNS>
NspList *L,char *dir,char **Mname
</FUNCTION>
<STRUCT>
<NAME>BHash_Entry</NAME>
</STRUCT>
<STRUCT>
<NAME>BHash_Entry</NAME>
struct _BHash_Entry { 
  unsigned int used; /* used to detect if data is present */
  char *key;
  int val;
};

</STRUCT>
<STRUCT>
<NAME>NspTypeBHash</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeBHash</NAME>
struct _NspTypeBHash { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};

</STRUCT>
<STRUCT>
<NAME>NspBHash</NAME>
struct _NspBHash {
  /*< private >*/
  NspObject father; 
  NspTypeBHash *type; 
  /*< public >*/
  unsigned int hsize,filled; /* size of bhash table and number of present entries */
  BHash_Entry *htable; /* an array of size hsize+1 */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_bhash_id</NAME>
extern int nsp_type_bhash_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_bhash</NAME>
extern NspTypeBHash *nsp_type_bhash;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_bhash_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_bhash</NAME>
<RETURNS>NspTypeBHash *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_bhash</NAME>
<RETURNS>NspBHash *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLBHASH</NAME>
#define NULLBHASH (NspBHash*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_bhash_create</NAME>
<RETURNS>NspBHash *</RETURNS>
const char *name, unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_copy</NAME>
<RETURNS>NspBHash *</RETURNS>
const NspBHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_destroy</NAME>
<RETURNS>void </RETURNS>
NspBHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_info</NAME>
<RETURNS>int </RETURNS>
NspBHash *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_print</NAME>
<RETURNS>int </RETURNS>
NspBHash *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_object</NAME>
<RETURNS>NspBHash *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsBHashObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsBHash</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetBHashCopy</NAME>
<RETURNS>NspBHash *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetBHash</NAME>
<RETURNS>NspBHash *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_resize</NAME>
<RETURNS>int </RETURNS>
NspBHash *H, unsigned int new_size
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_merge</NAME>
<RETURNS>int </RETURNS>
NspBHash *H1, NspBHash *H2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_get_next_object</NAME>
<RETURNS>int </RETURNS>
NspBHash *H,int *i,char **str,int *val
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_enter_pos_i</NAME>
<RETURNS>void </RETURNS>
NspBHash *H, int i,int val
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_enter_copy</NAME>
<RETURNS>int </RETURNS>
NspBHash *H, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_enter</NAME>
<RETURNS>int </RETURNS>
NspBHash *H,const char *str,int val
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_remove</NAME>
<RETURNS>void </RETURNS>
NspBHash *H, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_find_and_copy</NAME>
<RETURNS>int </RETURNS>
NspBHash *H, char *str, NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_find</NAME>
<RETURNS>int </RETURNS>
NspBHash *H,const char *str,int *val
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_equal</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBHash *L1, NspBHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_not_equal</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBHash *L1, NspBHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_full_equal</NAME>
<RETURNS>int </RETURNS>
NspBHash *L1, NspBHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_full_not_equal</NAME>
<RETURNS>int </RETURNS>
NspBHash *L1, NspBHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_get_keys</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const char *name,NspBHash *Hv
</FUNCTION>
<ENUM>
<NAME>BHashOperation</NAME>
typedef enum {
  BH_FIND,
  BH_ENTER,
  BH_REMOVE 
} BHashOperation;
</ENUM>
<FUNCTION>
<NAME>nsp_bhcreate_from_list</NAME>
<RETURNS>NspBHash *</RETURNS>
char *name,unsigned int nel, NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhcreate</NAME>
<RETURNS>NspBHash *</RETURNS>
const char *name, unsigned int nel
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhdestroy</NAME>
<RETURNS>void </RETURNS>
NspBHash *H
</FUNCTION>
<STRUCT>
<NAME>NspHm</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeHm</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeHm</NAME>
struct _NspTypeHm {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 46 "./hm.h"
};

</STRUCT>
<STRUCT>
<NAME>NspHm</NAME>
struct _NspHm {
  /*< private >*/
  NspObject father;
  NspTypeHm*type;
  /*< public >*/
    void* htable;
  int hsize;
  int filled;
  int base;
  int keysize;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_hm_id</NAME>
extern int nsp_type_hm_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_hm</NAME>
extern NspTypeHm *nsp_type_hm;
</VARIABLE>
<FUNCTION>
<NAME>new_type_hm</NAME>
<RETURNS>NspTypeHm *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_hm</NAME>
<RETURNS>NspHm *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLHM</NAME>
#define NULLHM (NspHm*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_hm_create</NAME>
<RETURNS>NspHm *</RETURNS>
const char *name,void* htable,int hsize,int filled,int base,int keysize,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_create_default</NAME>
<RETURNS>NspHm *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_copy</NAME>
<RETURNS>NspHm *</RETURNS>
NspHm *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_destroy</NAME>
<RETURNS>void </RETURNS>
NspHm *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_info</NAME>
<RETURNS>int </RETURNS>
NspHm *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_print</NAME>
<RETURNS>int </RETURNS>
NspHm *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_latex</NAME>
<RETURNS>int </RETURNS>
NspHm *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_object</NAME>
<RETURNS>NspHm *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsHmObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsHm</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetHmCopy</NAME>
<RETURNS>NspHm *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetHm</NAME>
<RETURNS>NspHm *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_create_partial</NAME>
<RETURNS>int </RETURNS>
NspHm *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspHm *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_copy_partial</NAME>
<RETURNS>NspHm *</RETURNS>
NspHm *H,NspHm *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_full_copy_partial</NAME>
<RETURNS>NspHm *</RETURNS>
NspHm *H,NspHm *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_full_copy</NAME>
<RETURNS>NspHm *</RETURNS>
NspHm *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_check_values</NAME>
<RETURNS>int </RETURNS>
NspHm *H
</FUNCTION>
<FUNCTION>
<NAME>int_hm_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_xdr_load_partial</NAME>
<RETURNS>NspHm *</RETURNS>
XDR *xdrs, NspHm *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_hm_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspHm *M
</FUNCTION>
<STRUCT>
<NAME>HM_Entry</NAME>
</STRUCT>
<STRUCT>
<NAME>HM_Entry</NAME>
struct _HM_Entry { 
  unsigned int used; /* used to detect if data is present */
  gint64 key;
  double val;
};

</STRUCT>
<ENUM>
<NAME>HMOperation</NAME>
typedef enum {
  HM_FIND,
  HM_ENTER,
  HM_REMOVE 
} HMOperation;
</ENUM>
<FUNCTION>
<NAME>nsp_parse_eval_file</NAME>
<RETURNS>int </RETURNS>
char *Str, int display,int echo, int errcatch, int pause,int mtlb
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_from_string</NAME>
<RETURNS>int </RETURNS>
const char *Str,int display,int echo, int errcatch,int pause
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_from_smat</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *M,int display,int echo, int errcatch,int pause
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_from_multistring</NAME>
<RETURNS>int </RETURNS>
const char *Str,int display,int echo, int errcatch,int pause
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_from_std</NAME>
<RETURNS>int </RETURNS>
int display
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_dir</NAME>
<RETURNS>int </RETURNS>
const char *Dir, char *Fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_dir_full</NAME>
<RETURNS>int </RETURNS>
const char *Dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_gtk_eval_function</NAME>
<RETURNS>int </RETURNS>
NspPList *func,NspObject *args[],int n_args, NspObject  *ret[],int *nret
</FUNCTION>
<FUNCTION>
<NAME>nsp_gtk_eval_function_catch</NAME>
<RETURNS>int </RETURNS>
NspPList *func,NspObject *args[],int n_args,NspObject  *ret[],int *nret, int errcatch,int pausecatch
</FUNCTION>
<FUNCTION>
<NAME>nsp_gtk_eval_function_by_name</NAME>
<RETURNS>int </RETURNS>
const char *name,NspObject *args[],int n_args, NspObject  *ret[],int *nret
</FUNCTION>
<FUNCTION>
<NAME>nsp_qr</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **q,NspMatrix **r,NspMatrix **E,NspMatrix **Rank,NspMatrix **Sval,double *tol,char mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_lsq</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, double *Rcond, int *Rank
</FUNCTION>
<FUNCTION>
<NAME>nsp_det</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A,char mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_spec</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix **d,NspMatrix **v
</FUNCTION>
<FUNCTION>
<NAME>nsp_spec_sym</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **d,char flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_gspec</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, NspMatrix **Vl, NspMatrix **Vr,NspMatrix **alpha, NspMatrix **beta
</FUNCTION>
<FUNCTION>
<NAME>nsp_rcond</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,double *rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholesky</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int *minor
</FUNCTION>
<FUNCTION>
<NAME>nsp_lu</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **L,NspMatrix **E, NspMatrix **Rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_svd</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **S,NspMatrix **U,NspMatrix **V,char flag,NspMatrix **Rank,double *tol
</FUNCTION>
<FUNCTION>
<NAME>nsp_inv</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, double *rcond, Boolean warning
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_norm</NAME>
<RETURNS>double </RETURNS>
NspMatrix *A, char flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_vector_norm</NAME>
<RETURNS>double </RETURNS>
NspMatrix *A, double p
</FUNCTION>
<FUNCTION>
<NAME>nsp_balanc</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **D
</FUNCTION>
<FUNCTION>
<NAME>nsp_gbalanc</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix *B,NspMatrix **X,NspMatrix **Y
</FUNCTION>
<FUNCTION>
<NAME>nsp_hess</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **U
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_is_symmetric</NAME>
<RETURNS>int </RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_is_upper_triangular</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_is_lower_triangular</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_have_nan_or_inf</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_lower_and_upper_bandwidth</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int *Kl, int *Ku
</FUNCTION>
<FUNCTION>
<NAME>nsp_expm</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_bdiv</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B, double tol_rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_lsq</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, double tol_rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_square</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, double *rcond, double tol_rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_square_pos_symmetric</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, double *rcond, double tol_rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_square_symmetric</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, double *rcond, double tol_rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_triangular</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, char tri_type, char trans, int *info
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_diagonal</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, int *info
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_banded</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Ab, int kl, int ku, NspMatrix *B, double *rcond, double tol_rcond, int *info, double *rrcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_increase_banded_mat</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, int kl, char flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_zgges</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix *B,int (*F)(const doubleC *alpha, const doubleC *beta),NspMatrix **VSL,NspMatrix **VSR,NspMatrix **Sdim
</FUNCTION>
<FUNCTION>
<NAME>nsp_dgges</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix *B,int (*F)(const double *alphar,const double *alphai,const double *beta),NspMatrix **VSL,NspMatrix **VSR,NspMatrix **Sdim
</FUNCTION>
<FUNCTION>
<NAME>nsp_dgees0</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **U,int (*F)(const double *re,const double *im),NspMatrix **Sdim
</FUNCTION>
<FUNCTION>
<NAME>nsp_zgees0</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **U,int (*F)(const doubleC *w), NspMatrix **Sdim
</FUNCTION>
<STRUCT>
<NAME>NspTypeList</NAME>
typedef struct _NspTypeList { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeList;
</STRUCT>
<TYPEDEF>
<NAME>Cell</NAME>
typedef struct cell Cell ;
</TYPEDEF>
<STRUCT>
<NAME>NspList</NAME>
struct _NspList {
  /*< private >*/
  NspObject father; 
  NspTypeList *type; 
  /*< public >*/
  Cell *first;        /* pointer to the first cell */
  Cell *last;         /* pointer to the last cell */
  Cell *current;      /* pointer to the current cell */
  int nel;            /* number of list elements */
  int icurrent;       /* index of the current cell */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_list_id</NAME>
extern int nsp_type_list_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_list</NAME>
extern NspTypeList *nsp_type_list;
</VARIABLE>
<FUNCTION>
<NAME>new_type_list</NAME>
<RETURNS>NspTypeList *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_list</NAME>
<RETURNS>NspList *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLLIST</NAME>
#define NULLLIST ( NspList *) 0 
</MACRO>
<MACRO>
<NAME>NULLCELL</NAME>
#define NULLCELL ( Cell *) 0 
</MACRO>
<FUNCTION>
<NAME>nsp_list_path_extract</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,int n, NspObject **Objs, int *copy
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_object</NAME>
<RETURNS>NspList *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsListObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsList</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetListCopy</NAME>
<RETURNS>NspList *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetList</NAME>
<RETURNS>NspList *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>ListFollowExtract</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_macro_code</NAME>
<RETURNS>NspObject *</RETURNS>
NspPList *, NspObject **, NspList *, int *
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_create</NAME>
<RETURNS>NspList *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_cell_create</NAME>
<RETURNS>Cell *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_cell_destroy</NAME>
<RETURNS>void </RETURNS>
Cell **c
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_destroy</NAME>
<RETURNS>void </RETURNS>
NspList *l
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_destroy_bis</NAME>
<RETURNS>void </RETURNS>
NspList *l
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_copy</NAME>
<RETURNS>NspList *</RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_full_copy</NAME>
<RETURNS>NspList *</RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_extract</NAME>
<RETURNS>NspList *</RETURNS>
NspList *L, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_insert</NAME>
<RETURNS>int </RETURNS>
NspList *L, NspObject *O, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_get_element</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_begin_insert</NAME>
<RETURNS>int </RETURNS>
NspList *L, NspObject *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_end_insert</NAME>
<RETURNS>int </RETURNS>
NspList *L, NspObject *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_remove_first</NAME>
<RETURNS>void  </RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_remove_last</NAME>
<RETURNS>void  </RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_store</NAME>
<RETURNS>int </RETURNS>
NspList *L, NspObject *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_delete_elt_by_name</NAME>
<RETURNS>void </RETURNS>
NspList *L, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_delete_elt</NAME>
<RETURNS>int </RETURNS>
NspList *L, int nel
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_delete_cell</NAME>
<RETURNS>int </RETURNS>
NspList *L, int nel
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_length</NAME>
<RETURNS>int </RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_concat</NAME>
<RETURNS>int </RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_info</NAME>
<RETURNS>int </RETURNS>
NspList *L, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_print</NAME>
<RETURNS>int </RETURNS>
NspList *L, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_latex_print</NAME>
<RETURNS>void </RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_cell_only_destroy</NAME>
<RETURNS>void </RETURNS>
Cell **c
</FUNCTION>
<FUNCTION>
<NAME>nsp_sorted_list_search</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L, nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_sorted_list_search_and_remove</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_sorted_list_insert</NAME>
<RETURNS>int </RETURNS>
NspList *L, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_map</NAME>
<RETURNS>NspList *</RETURNS>
NspList *L, NspPList *PL, NspList *args
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_fold_right</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,NspObject *x, NspPList *PL, NspList *args
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_fold_left</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L, NspObject *x,NspPList *PL, NspList *largs
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_equal</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_not_equal</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_full_equal</NAME>
<RETURNS>int </RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_full_not_equal</NAME>
<RETURNS>int </RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_compact</NAME>
<RETURNS>int </RETURNS>
NspList *L1, char flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_get_cell_pointer</NAME>
<RETURNS>Cell *</RETURNS>
NspList *L, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_unique</NAME>
<RETURNS>NspList *</RETURNS>
NspList *L, NspObject **Ind, NspMatrix **Occ, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_has</NAME>
<RETURNS>Boolean </RETURNS>
NspList *L, NspObject *Obj, int *ind
</FUNCTION>
<FUNCTION>
<NAME>nsp_remove_cell_from_list</NAME>
<RETURNS>void </RETURNS>
NspList *L, Cell *Loc
</FUNCTION>
<STRUCT>
<NAME>NspContour3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeContour3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeContour3d</NAME>
struct _NspTypeContour3d {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 49 "./contour3d.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_contour3d</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_contour3d</NAME>
struct _nsp_contour3d {
  NspMatrix* x;
  NspMatrix* y;
  NspMatrix* z;
  NspMatrix* zz;
  int flag;
  double zlev;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspContour3d</NAME>
struct _NspContour3d {
  /*< private >*/
  NspGraphic father;
  NspTypeContour3d*type;
  /*< public >*/
  nsp_contour3d *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_contour3d_id</NAME>
extern int nsp_type_contour3d_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_contour3d</NAME>
extern NspTypeContour3d *nsp_type_contour3d;
</VARIABLE>
<FUNCTION>
<NAME>new_type_contour3d</NAME>
<RETURNS>NspTypeContour3d *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_contour3d</NAME>
<RETURNS>NspContour3d *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCONTOUR3D</NAME>
#define NULLCONTOUR3D (NspContour3d*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_contour3d_create</NAME>
<RETURNS>NspContour3d *</RETURNS>
const char *name,NspMatrix* x,NspMatrix* y,NspMatrix* z,NspMatrix* zz,int flag,double zlev,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_create_default</NAME>
<RETURNS>NspContour3d *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_copy</NAME>
<RETURNS>NspContour3d *</RETURNS>
NspContour3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_destroy</NAME>
<RETURNS>void </RETURNS>
NspContour3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_info</NAME>
<RETURNS>int </RETURNS>
NspContour3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_print</NAME>
<RETURNS>int </RETURNS>
NspContour3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_latex</NAME>
<RETURNS>int </RETURNS>
NspContour3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_object</NAME>
<RETURNS>NspContour3d *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsContour3dObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsContour3d</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetContour3dCopy</NAME>
<RETURNS>NspContour3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetContour3d</NAME>
<RETURNS>NspContour3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_create_partial</NAME>
<RETURNS>int </RETURNS>
NspContour3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspContour3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_copy_partial</NAME>
<RETURNS>NspContour3d *</RETURNS>
NspContour3d *H,NspContour3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_full_copy_partial</NAME>
<RETURNS>NspContour3d *</RETURNS>
NspContour3d *H,NspContour3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_full_copy</NAME>
<RETURNS>NspContour3d *</RETURNS>
NspContour3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_check_values</NAME>
<RETURNS>int </RETURNS>
NspContour3d *H
</FUNCTION>
<FUNCTION>
<NAME>int_contour3d_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_xdr_load_partial</NAME>
<RETURNS>NspContour3d *</RETURNS>
XDR *xdrs, NspContour3d *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour3d_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspContour3d *M
</FUNCTION>
<STRUCT>
<NAME>NspSurf</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSurf</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSurf</NAME>
struct _NspTypeSurf {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./surf.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_surf</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_surf</NAME>
struct _nsp_surf {
  NspMatrix* x;
  NspMatrix* y;
  NspMatrix* z;
  NspMatrix* colors;
  gboolean mesh;
  gboolean zcolor;
  int mesh_color;
  int face_color;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspSurf</NAME>
struct _NspSurf {
  /*< private >*/
  NspGraphic father;
  NspTypeSurf*type;
  /*< public >*/
  nsp_surf *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_surf_id</NAME>
extern int nsp_type_surf_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_surf</NAME>
extern NspTypeSurf *nsp_type_surf;
</VARIABLE>
<FUNCTION>
<NAME>new_type_surf</NAME>
<RETURNS>NspTypeSurf *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_surf</NAME>
<RETURNS>NspSurf *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSURF</NAME>
#define NULLSURF (NspSurf*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_surf_create</NAME>
<RETURNS>NspSurf *</RETURNS>
const char *name,NspMatrix* x,NspMatrix* y,NspMatrix* z,NspMatrix* colors,gboolean mesh,gboolean zcolor,int mesh_color,int face_color,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_create_default</NAME>
<RETURNS>NspSurf *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_copy</NAME>
<RETURNS>NspSurf *</RETURNS>
NspSurf *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_destroy</NAME>
<RETURNS>void </RETURNS>
NspSurf *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_info</NAME>
<RETURNS>int </RETURNS>
NspSurf *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_print</NAME>
<RETURNS>int </RETURNS>
NspSurf *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_latex</NAME>
<RETURNS>int </RETURNS>
NspSurf *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_object</NAME>
<RETURNS>NspSurf *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSurfObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSurf</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSurfCopy</NAME>
<RETURNS>NspSurf *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSurf</NAME>
<RETURNS>NspSurf *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_create_partial</NAME>
<RETURNS>int </RETURNS>
NspSurf *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspSurf *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_copy_partial</NAME>
<RETURNS>NspSurf *</RETURNS>
NspSurf *H,NspSurf *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_full_copy_partial</NAME>
<RETURNS>NspSurf *</RETURNS>
NspSurf *H,NspSurf *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_full_copy</NAME>
<RETURNS>NspSurf *</RETURNS>
NspSurf *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_check_values</NAME>
<RETURNS>int </RETURNS>
NspSurf *H
</FUNCTION>
<FUNCTION>
<NAME>int_surf_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_xdr_load_partial</NAME>
<RETURNS>NspSurf *</RETURNS>
XDR *xdrs, NspSurf *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspSurf *M
</FUNCTION>
<ENUM>
<NAME>index_vector_error</NAME>
typedef enum { index_malloc_fail, index_wrong_object, index_wrong_value } index_vector_error;
</ENUM>
<STRUCT>
<NAME>index_vector</NAME>
</STRUCT>
<STRUCT>
<NAME>index_vector</NAME>
struct  _index_vector {
  int *val; /* array of integer pointer ind is "0-based" */
  int min;  /* min value of array "1-based" i.e min(val) +1 */
  int max;  /* max value of array "1-based" i.e max(val) +1*/
  int nval; /* size of array */
  int flag; /* TRUE if array goes from min to max with step 1 */
  int iwork;/* index of cache vector to use */
  index_vector_error error;/* error index */
};

</STRUCT>
<FUNCTION>
<NAME>nsp_get_index_vector_work</NAME>
<RETURNS>int *</RETURNS>
int work
</FUNCTION>
<STRUCT>
<NAME>NspGrstring</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGrstring</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGrstring</NAME>
struct _NspTypeGrstring {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./grstring.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_grstring</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_grstring</NAME>
struct _nsp_grstring {
  double x;
  double y;
  char* font;
  NspSMatrix* text;
  double angle;
  double w;
  double h;
  int fill;
  int posx;
  int posy;
  int size;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspGrstring</NAME>
struct _NspGrstring {
  /*< private >*/
  NspGraphic father;
  NspTypeGrstring*type;
  /*< public >*/
  nsp_grstring *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_grstring_id</NAME>
extern int nsp_type_grstring_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_grstring</NAME>
extern NspTypeGrstring *nsp_type_grstring;
</VARIABLE>
<FUNCTION>
<NAME>new_type_grstring</NAME>
<RETURNS>NspTypeGrstring *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_grstring</NAME>
<RETURNS>NspGrstring *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLGRSTRING</NAME>
#define NULLGRSTRING (NspGrstring*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_grstring_create</NAME>
<RETURNS>NspGrstring *</RETURNS>
const char *name,double x,double y,char* font,NspSMatrix* text,double angle,double w,double h,int fill,int posx,int posy,int size,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_create_default</NAME>
<RETURNS>NspGrstring *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_copy</NAME>
<RETURNS>NspGrstring *</RETURNS>
NspGrstring *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_destroy</NAME>
<RETURNS>void </RETURNS>
NspGrstring *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_info</NAME>
<RETURNS>int </RETURNS>
NspGrstring *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_print</NAME>
<RETURNS>int </RETURNS>
NspGrstring *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_latex</NAME>
<RETURNS>int </RETURNS>
NspGrstring *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_object</NAME>
<RETURNS>NspGrstring *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGrstringObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsGrstring</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetGrstringCopy</NAME>
<RETURNS>NspGrstring *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGrstring</NAME>
<RETURNS>NspGrstring *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_create_partial</NAME>
<RETURNS>int </RETURNS>
NspGrstring *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspGrstring *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_copy_partial</NAME>
<RETURNS>NspGrstring *</RETURNS>
NspGrstring *H,NspGrstring *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_full_copy_partial</NAME>
<RETURNS>NspGrstring *</RETURNS>
NspGrstring *H,NspGrstring *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_full_copy</NAME>
<RETURNS>NspGrstring *</RETURNS>
NspGrstring *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_check_values</NAME>
<RETURNS>int </RETURNS>
NspGrstring *H
</FUNCTION>
<FUNCTION>
<NAME>int_grstring_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_xdr_load_partial</NAME>
<RETURNS>NspGrstring *</RETURNS>
XDR *xdrs, NspGrstring *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_grstring_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspGrstring *M
</FUNCTION>
<VARIABLE>
<NAME>Datas</NAME>
extern NspList *Datas ;
</VARIABLE>
<FUNCTION>
<NAME>nsp_init_frames</NAME>
<RETURNS>int </RETURNS>
int argc, char **argv
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_frame</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_frame_with_local_vars</NAME>
<RETURNS>int </RETURNS>
NspCells *table
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_delete</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frames_info</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frames_print</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_replace_object</NAME>
<RETURNS>int </RETURNS>
 NspObject *A,int local_id
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_replace_object</NAME>
<RETURNS>int </RETURNS>
NspObject *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_frames_search_object</NAME>
<RETURNS>NspObject *</RETURNS>
const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frames_search_local_in_calling</NAME>
<RETURNS>NspObject *</RETURNS>
const char *str, int caller_flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_search_object</NAME>
<RETURNS>NspObject *</RETURNS>
nsp_const_string  str
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_search_object</NAME>
<RETURNS>NspObject *</RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_remove_object</NAME>
<RETURNS>void </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_remove_all_objects</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_search_and_remove_object</NAME>
<RETURNS>NspObject *</RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_remove_object</NAME>
<RETURNS>void </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_remove_all_objects</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_search_and_move_up_object</NAME>
<RETURNS>int </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_move_up_object</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_declare_global</NAME>
<RETURNS>int </RETURNS>
char *name,int id
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_insert_hash_contents</NAME>
<RETURNS>int </RETURNS>
NspHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_save</NAME>
<RETURNS>int </RETURNS>
NspFile *F
</FUNCTION>
<STRUCT>
<NAME>NspTypeNone</NAME>
typedef struct _NspTypeNone { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeNone;
</STRUCT>
<STRUCT>
<NAME>NspNone</NAME>
struct _NspNone {
  /*< private >*/
  NspObject father; 
  NspTypeNone *type; 
  /*< public >*/
  
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_none_id</NAME>
extern int nsp_type_none_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_none</NAME>
extern NspTypeNone *nsp_type_none;
</VARIABLE>
<FUNCTION>
<NAME>new_type_none</NAME>
<RETURNS>NspTypeNone *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_none</NAME>
<RETURNS>NspNone *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLNONE</NAME>
#define NULLNONE (NspNone*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_none_create</NAME>
<RETURNS>NspNone *</RETURNS>
char *name,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_none_copy</NAME>
<RETURNS>NspNone *</RETURNS>
NspNone *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_none_destroy</NAME>
<RETURNS>void </RETURNS>
NspNone *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_none_info</NAME>
<RETURNS>int </RETURNS>
NspNone *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_none_print</NAME>
<RETURNS>int </RETURNS>
NspNone *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_none_object</NAME>
<RETURNS>NspNone *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsNoneObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsNone</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetNoneCopy</NAME>
<RETURNS>NspNone *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetNone</NAME>
<RETURNS>NspNone *</RETURNS>
Stack stack, int i
</FUNCTION>
<STRUCT>
<NAME>NspTypeModuleElt</NAME>
typedef struct _NspTypeModuleElt { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeModuleElt;
</STRUCT>
<STRUCT>
<NAME>NspModulelt</NAME>
struct _NspModulelt {
  /*< private >*/
  NspObject father; 
  NspTypeModuleElt *type; 
  /*< public >*/
  char *path ;
  char *module;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_modulelt_id</NAME>
extern int nsp_type_modulelt_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_modulelt</NAME>
extern NspTypeModuleElt *nsp_type_modulelt;
</VARIABLE>
<FUNCTION>
<NAME>new_type_modulelt</NAME>
<RETURNS>NspTypeModuleElt *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_modulelt</NAME>
<RETURNS>NspModuleElt *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLME</NAME>
#define NULLME (NspModuleElt*) 0
</MACRO>
<FUNCTION>
<NAME>modulelt_create</NAME>
<RETURNS>NspModuleElt *</RETURNS>
char *name,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>modulelt_copy</NAME>
<RETURNS>NspModuleElt *</RETURNS>
NspModuleElt *H
</FUNCTION>
<FUNCTION>
<NAME>modulelt_destroy</NAME>
<RETURNS>void </RETURNS>
NspModuleElt *H
</FUNCTION>
<FUNCTION>
<NAME>modulelt_info</NAME>
<RETURNS>int </RETURNS>
NspModuleElt *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>modulelt_print</NAME>
<RETURNS>int </RETURNS>
NspModuleElt *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>modulelt_object</NAME>
<RETURNS>NspModuleElt *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsModuleEltObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsModuleElt</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetModuleEltCopy</NAME>
<RETURNS>NspModuleElt *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetModuleElt</NAME>
<RETURNS>NspModuleElt *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_cwd</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_extension</NAME>
<RETURNS>const char *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_user_home</NAME>
<RETURNS>char *</RETURNS>
char *name, nsp_tcldstring *bufferPtr
</FUNCTION>
<FUNCTION>
<NAME>nsp_getenv</NAME>
<RETURNS>const char *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_setenv</NAME>
<RETURNS>int </RETURNS>
const char *name,const char *value
</FUNCTION>
<FUNCTION>
<NAME>nsp_unsetenv</NAME>
<RETURNS>void </RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_chdir</NAME>
<RETURNS>int </RETURNS>
char *dirName
</FUNCTION>
<FUNCTION>
<NAME>nsp_copy_directory</NAME>
<RETURNS>int </RETURNS>
char *source,char *dest, nsp_tcldstring *errorPtr
</FUNCTION>
<FUNCTION>
<NAME>nsp_copy_file</NAME>
<RETURNS>int </RETURNS>
char *source, char *dest
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_directory</NAME>
<RETURNS>int </RETURNS>
char *path
</FUNCTION>
<FUNCTION>
<NAME>nsp_delete_file</NAME>
<RETURNS>int </RETURNS>
char *path
</FUNCTION>
<FUNCTION>
<NAME>nsp_do_glob</NAME>
<RETURNS>int </RETURNS>
char *separators, nsp_tcldstring *headPtr, char *tail,NspSMatrix *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_copy_cmd</NAME>
<RETURNS>int </RETURNS>
int argc, char **argv,int force
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_delete_cmd</NAME>
<RETURNS>int </RETURNS>
int argc, char **argv,int force
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_make_dirs_cmd</NAME>
<RETURNS>int </RETURNS>
 int argc, char **argv
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_rename_cmd</NAME>
<RETURNS>int </RETURNS>
 int argc, char **argv,int force
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_volumes</NAME>
<RETURNS>int </RETURNS>
Stack stack,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_match_files</NAME>
<RETURNS>int </RETURNS>
char *separators,  nsp_tcldstring *dirPtr, char *pattern, char *tail,NspSMatrix *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_putenv</NAME>
<RETURNS>int </RETURNS>
const char *string
</FUNCTION>
<FUNCTION>
<NAME>nsp_remove_directory</NAME>
<RETURNS>int </RETURNS>
char *path, int recursive, nsp_tcldstring *errorPtr
</FUNCTION>
<FUNCTION>
<NAME>nsp_rename_file</NAME>
<RETURNS>int </RETURNS>
char *source, char *dest
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_match</NAME>
<RETURNS>int </RETURNS>
char *string,char * pattern
</FUNCTION>
<FUNCTION>
<NAME>nsp_absolute_file_name</NAME>
<RETURNS>nsp_string </RETURNS>
const char *fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_dirname</NAME>
<RETURNS>nsp_string </RETURNS>
const char *fileName
</FUNCTION>
<FUNCTION>
<NAME>nsp_tail</NAME>
<RETURNS>nsp_string </RETURNS>
const char *fileName
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_exit_handler</NAME>
<RETURNS>void </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_finalize_environment</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_tclplatform_init</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_update_exec_dir</NAME>
<RETURNS>void </RETURNS>
const char *filename, char *exec_dir,char *filename_exec,unsigned int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_update_exec_dir_from_dir</NAME>
<RETURNS>void </RETURNS>
const char *dirname,char *exec_dir,unsigned int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_glob</NAME>
<RETURNS>int </RETURNS>
const char *pattern
</FUNCTION>
<FUNCTION>
<NAME>nsp_chdir_and_update_exec_dir</NAME>
<RETURNS>int </RETURNS>
Stack *stack,const char *dir_name
</FUNCTION>
<STRUCT>
<NAME>NspCompound</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeCompound</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeCompound</NAME>
struct _NspTypeCompound {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./compound.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_compound</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_compound</NAME>
struct _nsp_compound {
  NspMatrix* bounds;
  NspList* children;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspCompound</NAME>
struct _NspCompound {
  /*< private >*/
  NspGraphic father;
  NspTypeCompound*type;
  /*< public >*/
  nsp_compound *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_compound_id</NAME>
extern int nsp_type_compound_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_compound</NAME>
extern NspTypeCompound *nsp_type_compound;
</VARIABLE>
<FUNCTION>
<NAME>new_type_compound</NAME>
<RETURNS>NspTypeCompound *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_compound</NAME>
<RETURNS>NspCompound *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCOMPOUND</NAME>
#define NULLCOMPOUND (NspCompound*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_compound_create</NAME>
<RETURNS>NspCompound *</RETURNS>
const char *name,NspMatrix* bounds,NspList* children,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_create_default</NAME>
<RETURNS>NspCompound *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_copy</NAME>
<RETURNS>NspCompound *</RETURNS>
NspCompound *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_destroy</NAME>
<RETURNS>void </RETURNS>
NspCompound *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_info</NAME>
<RETURNS>int </RETURNS>
NspCompound *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_print</NAME>
<RETURNS>int </RETURNS>
NspCompound *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_latex</NAME>
<RETURNS>int </RETURNS>
NspCompound *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_object</NAME>
<RETURNS>NspCompound *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsCompoundObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsCompound</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetCompoundCopy</NAME>
<RETURNS>NspCompound *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetCompound</NAME>
<RETURNS>NspCompound *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_create_partial</NAME>
<RETURNS>int </RETURNS>
NspCompound *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspCompound *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_copy_partial</NAME>
<RETURNS>NspCompound *</RETURNS>
NspCompound *H,NspCompound *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_full_copy_partial</NAME>
<RETURNS>NspCompound *</RETURNS>
NspCompound *H,NspCompound *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_full_copy</NAME>
<RETURNS>NspCompound *</RETURNS>
NspCompound *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_check_values</NAME>
<RETURNS>int </RETURNS>
NspCompound *H
</FUNCTION>
<FUNCTION>
<NAME>int_compound_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_xdr_load_partial</NAME>
<RETURNS>NspCompound *</RETURNS>
XDR *xdrs, NspCompound *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_compound_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspCompound *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_get_axe_elts_as_compound</NAME>
<RETURNS>NspCompound *</RETURNS>
char *name,NspFigure *F
</FUNCTION>
<STRUCT>
<NAME>NspSqlRs</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSqlRs</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSqlRs</NAME>
struct _NspTypeSqlRs {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 29 "./sqlrs.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_sqlrs</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_sqlrs</NAME>
struct _nsp_sqlrs {
  gint op;
  NspMatrix* z;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspSqlRs</NAME>
struct _NspSqlRs {
  /*< private >*/
  NspObject father;
  NspTypeSqlRs*type;
  /*< public >*/
  nsp_sqlrs *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_sqlrs_id</NAME>
extern int nsp_type_sqlrs_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_sqlrs</NAME>
extern NspTypeSqlRs *nsp_type_sqlrs;
</VARIABLE>
<FUNCTION>
<NAME>new_type_sqlrs</NAME>
<RETURNS>NspTypeSqlRs *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_sqlrs</NAME>
<RETURNS>NspSqlRs *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSQLRS</NAME>
#define NULLSQLRS (NspSqlRs*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_sqlrs_create</NAME>
<RETURNS>NspSqlRs *</RETURNS>
char *name,gint op,NspMatrix* z,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_copy</NAME>
<RETURNS>NspSqlRs *</RETURNS>
NspSqlRs *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_destroy</NAME>
<RETURNS>void </RETURNS>
NspSqlRs *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_info</NAME>
<RETURNS>int </RETURNS>
NspSqlRs *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_print</NAME>
<RETURNS>int </RETURNS>
NspSqlRs *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_latex</NAME>
<RETURNS>int </RETURNS>
NspSqlRs *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_object</NAME>
<RETURNS>NspSqlRs *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSqlRsObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSqlRs</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSqlRsCopy</NAME>
<RETURNS>NspSqlRs *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSqlRs</NAME>
<RETURNS>NspSqlRs *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_create_partial</NAME>
<RETURNS>int </RETURNS>
NspSqlRs *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspSqlRs *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_copy_partial</NAME>
<RETURNS>NspSqlRs *</RETURNS>
NspSqlRs *H,NspSqlRs *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_full_copy_partial</NAME>
<RETURNS>NspSqlRs *</RETURNS>
NspSqlRs *H,NspSqlRs *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_full_copy</NAME>
<RETURNS>NspSqlRs *</RETURNS>
NspSqlRs *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_check_values</NAME>
<RETURNS>int </RETURNS>
NspSqlRs *H
</FUNCTION>
<FUNCTION>
<NAME>int_sqlrs_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_xdr_load_partial</NAME>
<RETURNS>NspSqlRs *</RETURNS>
XDR *xdrs, NspSqlRs *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqlrs_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspSqlRs *M
</FUNCTION>
<MACRO>
<NAME>Widget</NAME>
#define Widget int
</MACRO>
<ENUM>
<NAME>menu_answer</NAME>
typedef enum { menu_ok , menu_cancel, menu_fail, menu_bad_argument} menu_answer; 
</ENUM>
<FUNCTION>
<NAME>nsp_choose</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *Items,NspSMatrix *Title,NspSMatrix *button,int *nrep
</FUNCTION>
<FUNCTION>
<NAME>nsp_choose_</NAME>
<RETURNS>menu_answer </RETURNS>
const char *title,char **Items,int nItems,char **but_names,int n_but,int *choice
</FUNCTION>
<FUNCTION>
<NAME>nsp_message</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *Message,NspSMatrix *Buttons,int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_message_modeless</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *Message,NspSMatrix *Buttons
</FUNCTION>
<FUNCTION>
<NAME>nsp_message_</NAME>
<RETURNS>menu_answer </RETURNS>
const char *message,char **buttons,int n_buttons,int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_message_modeless_</NAME>
<RETURNS>menu_answer </RETURNS>
const char *message
</FUNCTION>
<FUNCTION>
<NAME>nsp_choices_with_combobox</NAME>
<RETURNS>menu_answer </RETURNS>
char *title,NspList *L,NspList **Res,int use_table
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_dialog</NAME>
<RETURNS>int </RETURNS>
char **print_command,int *type,int *orientation,int *format
</FUNCTION>
<FUNCTION>
<NAME>nsp_export_dialog</NAME>
<RETURNS>int </RETURNS>
char **file,int *type,int *orientation,int *format
</FUNCTION>
<FUNCTION>
<NAME>nsp_dialog</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *title,NspSMatrix *init,NspObject **answer
</FUNCTION>
<FUNCTION>
<NAME>nsp_dialog1</NAME>
<RETURNS>menu_answer </RETURNS>
const char *title,const char *init,char **answer
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_file_window</NAME>
<RETURNS>menu_answer </RETURNS>
const char *title,const char *dirname,int action,char **file
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_filename_open</NAME>
<RETURNS>char *</RETURNS>
const char *title,const char *dirname,char **filters
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_filename_save</NAME>
<RETURNS>char *</RETURNS>
const char *title,const char *dirname,const char *filename_in,char **filters
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_filename_folder</NAME>
<RETURNS>char *</RETURNS>
const char *title,const char *dirname
</FUNCTION>
<FUNCTION>
<NAME>nsp_multi_dialog_</NAME>
<RETURNS>menu_answer </RETURNS>
const char *title,char **pszTitle, char **pszName,int nv
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_dialog</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *Title,NspSMatrix *Labels_v,NspSMatrix *Labels_h,NspSMatrix *Init_matrix,int menu_type,int entry_size
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_set</NAME>
<RETURNS>void </RETURNS>
int win_num,const char *button_name,int ne
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_unset</NAME>
<RETURNS>void </RETURNS>
int win_num,const char *button_name,int ne
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_delete_button</NAME>
<RETURNS>int </RETURNS>
int win_num,const char *button_name
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_add</NAME>
<RETURNS>int </RETURNS>
int win_num,const char * button_name,char ** entries,int ne,int typ,char *fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_gtkcombobox_colormap_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
 BCG *Xgc,int init_color
</FUNCTION>
<FUNCTION>
<NAME>gtkcombobox_select_color_in_table</NAME>
<RETURNS>int </RETURNS>
NspMatrix *table,int init_color
</FUNCTION>
<FUNCTION>
<NAME>gtkcombobox_select_color</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,int init_color
</FUNCTION>
<FUNCTION>
<NAME>nsp_multi_dialog</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *Title,NspSMatrix *Labels,NspSMatrix *Init_values
</FUNCTION>
<FUNCTION>
<NAME>nsp_multi_dialog_</NAME>
<RETURNS>menu_answer </RETURNS>
const char *title,char **pszTitle, char **pszName,int nv
</FUNCTION>
<FUNCTION>
<NAME>nsp_dialogs_insert_title</NAME>
<RETURNS>void </RETURNS>
const char *title,GtkWidget *vbox
</FUNCTION>
<USER_FUNCTION>
<NAME>Stop_menu_handler</NAME>
<RETURNS>void </RETURNS>
void
</USER_FUNCTION>
<FUNCTION>
<NAME>set_stop_menu_handler</NAME>
<RETURNS>Stop_menu_handler </RETURNS>
 Stop_menu_handler f
</FUNCTION>
<FUNCTION>
<NAME>reset_stop_menu_handler</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>nsp_spline_enum</NAME>
typedef enum {
  NOT_A_KNOT, NATURAL, CLAMPED, PERIODIC, FAST, FAST_PERIODIC, 
  MONOTONE, BY_ZERO, C0, LINEAR, BY_NAN, UNDEFINED 
} nsp_spline_enum;
</ENUM>
<FUNCTION>
<NAME>nsp_eval_piecewise_hermite</NAME>
<RETURNS>void </RETURNS>
double *t, double *st, double *dst, double *d2st,double *d3st, int m, double *x, double *y, double *d,int n, int outmode
</FUNCTION>
<FUNCTION>
<NAME>nsp_dpchim</NAME>
<RETURNS>void </RETURNS>
double *x, double *u, double *d, int n, int inc
</FUNCTION>
<FUNCTION>
<NAME>nsp_cubic_spline</NAME>
<RETURNS>void </RETURNS>
double *x, double *y, double *d, int n, int type,double *A_d, double *A_sd, double *qdy, double *lll
</FUNCTION>
<FUNCTION>
<NAME>nsp_derivd</NAME>
<RETURNS>void </RETURNS>
double *x, double *u, double *du, int n, int inc, int type
</FUNCTION>
<FUNCTION>
<NAME>nsp_nlinear_interp</NAME>
<RETURNS>void </RETURNS>
double **x , double val[], int dim[], int n,double **xp, double yp[], int np, int outmode,double u[], double v[], int ad[], int k[]
</FUNCTION>
<FUNCTION>
<NAME>nsp_bicubic_subspline</NAME>
<RETURNS>int </RETURNS>
double *x, double *y, double *u, int nx, int ny, double *C, int type
</FUNCTION>
<FUNCTION>
<NAME>nsp_bicubic_spline</NAME>
<RETURNS>int </RETURNS>
double *x, double *y, double *u, int nx, int ny, double *C, int type
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_bicubic</NAME>
<RETURNS>void </RETURNS>
double *x, double *y, double *C, int nx, int ny, double *x_eval, double *y_eval,double *z_eval, double *dzdx_eval, double *dzdy_eval, int m, int outmode
</FUNCTION>
<MACRO>
<NAME>ELT_TYPE</NAME>
#define ELT_TYPE double
</MACRO>
<MACRO>
<NAME>NSP_VERSION</NAME>
#define NSP_VERSION "nsp-1.0"
</MACRO>
<MACRO>
<NAME>DEFAULT_MES</NAME>
#define DEFAULT_MES "nsp-1.0"
</MACRO>
<MACRO>
<NAME>HOST_TYPE</NAME>
#define HOST_TYPE   "i686-pc-linux-gnu"
</MACRO>
<FUNCTION>
<NAME>ShowDynLinks</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_linked</NAME>
<RETURNS>int </RETURNS>
nsp_const_string name,int *ilib
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_library</NAME>
<RETURNS>void </RETURNS>
int iflag, int *rhs,int *ilib,nsp_const_string shared_path, char **en_names, char strf
</FUNCTION>
<FUNCTION>
<NAME>nsp_dynamic_load</NAME>
<RETURNS>void </RETURNS>
nsp_const_string shared_path,char **en_names,char strf, int *ilib, int iflag, int *rhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_dlsymbols</NAME>
<RETURNS>NspHash *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_unlink_shared</NAME>
<RETURNS>void </RETURNS>
int ilib
</FUNCTION>
<FUNCTION>
<NAME>nsp_remove_interface</NAME>
<RETURNS>void </RETURNS>
int Nshared
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_initialize</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_delete_interface_functions</NAME>
<RETURNS>void </RETURNS>
int Int
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_search</NAME>
<RETURNS>int  </RETURNS>
nsp_const_string op, int ilib, int (**realop) ()
</FUNCTION>
<STRUCT>
<NAME>NspEpoints</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeEpoints</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeEpoints</NAME>
struct _NspTypeEpoints {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 47 "./epoints.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_epoints</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_epoints</NAME>
struct _nsp_epoints {
  char* ename;
  void* func;
  int shid;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspEpoints</NAME>
struct _NspEpoints {
  /*< private >*/
  NspObject father;
  NspTypeEpoints*type;
  /*< public >*/
  nsp_epoints *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_epoints_id</NAME>
extern int nsp_type_epoints_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_epoints</NAME>
extern NspTypeEpoints *nsp_type_epoints;
</VARIABLE>
<FUNCTION>
<NAME>new_type_epoints</NAME>
<RETURNS>NspTypeEpoints *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_epoints</NAME>
<RETURNS>NspEpoints *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLEPOINTS</NAME>
#define NULLEPOINTS (NspEpoints*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_epoints_create</NAME>
<RETURNS>NspEpoints *</RETURNS>
const char *name,char* ename,void* func,int shid,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_create_default</NAME>
<RETURNS>NspEpoints *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_copy</NAME>
<RETURNS>NspEpoints *</RETURNS>
NspEpoints *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_destroy</NAME>
<RETURNS>void </RETURNS>
NspEpoints *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_info</NAME>
<RETURNS>int </RETURNS>
NspEpoints *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_print</NAME>
<RETURNS>int </RETURNS>
NspEpoints *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_latex</NAME>
<RETURNS>int </RETURNS>
NspEpoints *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_object</NAME>
<RETURNS>NspEpoints *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsEpointsObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsEpoints</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetEpointsCopy</NAME>
<RETURNS>NspEpoints *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetEpoints</NAME>
<RETURNS>NspEpoints *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_create_partial</NAME>
<RETURNS>int </RETURNS>
NspEpoints *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspEpoints *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_copy_partial</NAME>
<RETURNS>NspEpoints *</RETURNS>
NspEpoints *H,NspEpoints *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_full_copy_partial</NAME>
<RETURNS>NspEpoints *</RETURNS>
NspEpoints *H,NspEpoints *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_full_copy</NAME>
<RETURNS>NspEpoints *</RETURNS>
NspEpoints *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_check_values</NAME>
<RETURNS>int </RETURNS>
NspEpoints *H
</FUNCTION>
<FUNCTION>
<NAME>int_epoints_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_xdr_load_partial</NAME>
<RETURNS>NspEpoints *</RETURNS>
XDR *xdrs, NspEpoints *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspEpoints *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_table_insert</NAME>
<RETURNS>int  </RETURNS>
const char *name,const char *ename, void *func, int sharedid
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_table_find</NAME>
<RETURNS>NspEpoints *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_table_show</NAME>
<RETURNS>void </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_epoints_table_remove_entries</NAME>
<RETURNS>void </RETURNS>
int shid
</FUNCTION>
<STRUCT>
<NAME>nsp_smio</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_smio</NAME>
struct _nsp_smio {
  XDR  xdrs[1];  /* xdr struture */
  int  flag;     /* flag for special open (xdr) */
  char openf[4]; /* flags used in fopen */
  unsigned int pos,len;   /* position in stream and len of string D */
  nsp_string D; /* string for storing data */
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspTypeSMio</NAME>
typedef struct _NspTypeSMio { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeSMio;
</STRUCT>
<STRUCT>
<NAME>NspSMio</NAME>
struct _NspSMio {
  /*< private >*/
  NspObject father; 
  NspTypeSMio *type; 
  /*< public >*/
  nsp_smio *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_smio_id</NAME>
extern int nsp_type_smio_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_smio</NAME>
extern NspTypeSMio *nsp_type_smio;
</VARIABLE>
<FUNCTION>
<NAME>new_type_smio</NAME>
<RETURNS>NspTypeSMio *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_smio</NAME>
<RETURNS>NspSMio *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_wcreate</NAME>
<RETURNS>NspSMio *</RETURNS>
char *name, char *str,int flag,unsigned int len
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_rcreate</NAME>
<RETURNS>NspSMio *</RETURNS>
char *name, char *str,int flag,const char *data,unsigned int len
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_copy</NAME>
<RETURNS>NspSMio *</RETURNS>
NspSMio *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_full_copy</NAME>
<RETURNS>NspSMio *</RETURNS>
NspSMio  *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_destroy</NAME>
<RETURNS>void </RETURNS>
NspSMio *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_info</NAME>
<RETURNS>int </RETURNS>
NspSMio *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_print</NAME>
<RETURNS>int </RETURNS>
NspSMio *H, int indent,char *name, int rec_level
</FUNCTION>
<MACRO>
<NAME>OPEN_MASK</NAME>
#define OPEN_MASK 0x000f 
</MACRO>
<MACRO>
<NAME>XDR_MASK</NAME>
#define XDR_MASK 0x00f0 
</MACRO>
<MACRO>
<NAME>SWAP_MASK</NAME>
#define SWAP_MASK 0x0f00 
</MACRO>
<MACRO>
<NAME>SWAP_ON</NAME>
#define SWAP_ON(flag) (flag |= (1 << 8) )
</MACRO>
<MACRO>
<NAME>SWAP_OFF</NAME>
#define SWAP_OFF(flag) (flag &= ~SWAP_MASK )
</MACRO>
<MACRO>
<NAME>XDR_ON</NAME>
#define XDR_ON(flag)  (flag |= (1 << 4 ) )
</MACRO>
<MACRO>
<NAME>XDR_OFF</NAME>
#define XDR_OFF(flag)  (flag &= ~XDR_MASK )
</MACRO>
<MACRO>
<NAME>OPEN_ON</NAME>
#define OPEN_ON(flag)  (flag |= (1  ) )
</MACRO>
<MACRO>
<NAME>OPEN_OFF</NAME>
#define OPEN_OFF(flag)  (flag &= ~OPEN_MASK )
</MACRO>
<MACRO>
<NAME>IS_OPENED</NAME>
#define IS_OPENED(flag) ( flag & OPEN_MASK )
</MACRO>
<MACRO>
<NAME>IS_XDR</NAME>
#define IS_XDR(flag) ( flag & XDR_MASK)
</MACRO>
<MACRO>
<NAME>USE_SWAP</NAME>
#define USE_SWAP(flag) ( flag & SWAP_MASK) 
</MACRO>
<MACRO>
<NAME>NULLSMIO</NAME>
#define NULLSMIO (NspSMio *) 0
</MACRO>
<FUNCTION>
<NAME>GetSMio</NAME>
<RETURNS>NspSMio *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSMioCopy</NAME>
<RETURNS>NspSMio *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_object</NAME>
<RETURNS>NspSMio *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_ropen</NAME>
<RETURNS>NspSMio *</RETURNS>
char *mode,int xdr_on,int swap_on, const char *str,unsigned int len
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_wopen</NAME>
<RETURNS>NspSMio *</RETURNS>
char *mode,int xdr_on,int swap_on,unsigned int len
</FUNCTION>
<FUNCTION>
<NAME>IsSMioObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>is_little_endian</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_close</NAME>
<RETURNS>int </RETURNS>
NspSMio *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_eof</NAME>
<RETURNS>int </RETURNS>
NspSMio *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_error</NAME>
<RETURNS>int </RETURNS>
NspSMio *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_get</NAME>
<RETURNS>int </RETURNS>
NspSMio *F,void *x,int n,const char *type,int *items_read
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_getc</NAME>
<RETURNS>int </RETURNS>
NspSMio *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_ungetc</NAME>
<RETURNS>int </RETURNS>
NspSMio *F,int  c
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_getstr</NAME>
<RETURNS>int </RETURNS>
NspSMio *F, char *start, int n,int *n_read
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_printf_matrix</NAME>
<RETURNS>int </RETURNS>
NspSMio *F,char *format,char *sep,NspMatrix *M,NspSMatrix *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_printf_smatrix</NAME>
<RETURNS>int </RETURNS>
NspSMio *F,NspSMatrix *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_put</NAME>
<RETURNS>int </RETURNS>
NspSMio *F,void *x,int n, char *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_putstr</NAME>
<RETURNS>int </RETURNS>
NspSMio *F,const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_read_lines</NAME>
<RETURNS>int </RETURNS>
NspSMio *F,NspSMatrix **S,int nlines
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_scanf_smatrix</NAME>
<RETURNS>int </RETURNS>
NspSMio *F,NspSMatrix **S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_scanf_matrix</NAME>
<RETURNS>int </RETURNS>
NspSMio *F,char *format,NspMatrix **M,int flag,NspSMatrix **S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_seek</NAME>
<RETURNS>int </RETURNS>
NspSMio *F,long int offset,const char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_tell</NAME>
<RETURNS>int </RETURNS>
NspSMio *F,long int *offset
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_clearerr</NAME>
<RETURNS>void </RETURNS>
NspSMio *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, NspSMio *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smio_xdr_load</NAME>
<RETURNS>NspSMio *</RETURNS>
XDR *xdrs
</FUNCTION>
<STRUCT>
<NAME>doubleC</NAME>
struct _doubleC { 
  double r;
  double i; 
};

</STRUCT>
<STRUCT>
<NAME>AttrTab</NAME>
</STRUCT>
<STRUCT>
<NAME>NspMethods</NAME>
</STRUCT>
<TYPEDEF>
<NAME>NspTypeId</NAME>
typedef unsigned int NspTypeId ;   
</TYPEDEF>
<STRUCT>
<NAME>NspTypeBase</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_TYPE_OBJECT__</NAME>
#define NSP_TYPE_OBJECT__					      \
  NspTypeId id ;                      /* each type has a unique id */ \
  NspTypeBase *surtype;               /* type of parent */		\
  NspTypeBase *interface ;  	      /* chained types for interfaces */ \
  init_func *init ;		      /* initializer */			\
  new_func *newf ;		      /* allocations */			\
  AttrTab *attrs; 		      /* attribute table */		\
  attrs_func *get_attrs;	      /* get attribute wrapper */	\
  attrs_func *set_attrs;	      /* get attribute wrapper */	\
  methods_func *methods;	      /* methods */		
</MACRO>
<MACRO>
<NAME>NSP_TYPE_OBJECT__</NAME>
#define NSP_TYPE_OBJECT__					      \
  NspTypeId id ;                      /* each type has a unique id */ \
  NspTypeBase *surtype;               /* type of parent */		\
  NspTypeBase *interface ;  	      /* chained types for interfaces */ \
  init_func *init ;		      /* initializer */			\
  new_func *new ;		      /* allocations */			\
  AttrTab *attrs; 		      /* attribute table */		\
  attrs_func *get_attrs;	      /* get attribute wrapper */	\
  attrs_func *set_attrs;	      /* get attribute wrapper */	\
  methods_func *methods;	      /* methods */		
</MACRO>
<STRUCT>
<NAME>NspTypeBase</NAME>
struct _NspTypeBase {
  NSP_TYPE_OBJECT__ 
} ;

</STRUCT>
<STRUCT>
<NAME>NspTypeObject</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeObject</NAME>
struct _NspTypeObject {
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
  print_func *pr ;		      /* printing*/   
  dealloc_func *dealloc;              /* dealloc */  
  copy_func *copy ;                   /* copy object */  
  size_func *size ;                   /* m,n or m*n  */  
  s_type_func *s_type;                /* type as a String */  
  sh_type_func *sh_type;              /* type as a short string */  
  info_func *info;                    /* info */  
  set_name_func *set_name;            /* set name */  
  get_name_func *get_name;            /* get name */  
  is_true_func  *is_true;             /* check if object can be considered as true */  
  loop_func     *loop;                /* for loops */  
  path_func     *path_extract;        /* used for x(1)(2)(...) */  
  get_from_obj_func *get_from_obj;    /* get object stored in SciObj */  
  eq_func *eq ;                       /* equality check */  
  eq_func *neq ;                      /* non-equality check */
  save_func *save;                    /* file save */
  load_func *load;                    /* file load */
  create_func *create;	      	      /* creates a new object  */ 
  print_func *latex;                  /* print in latex syntax */
  get_index_vector_func *as_index;    /* check if object can be used as index vector */
  copy_func *full_copy ;              /* full_copy object */  
};

</STRUCT>
<MACRO>
<NAME>NSP_TYPE_OBJECT</NAME>
#define NSP_TYPE_OBJECT(t) ((NspTypeObject *) t) 
</MACRO>
<MACRO>
<NAME>NSP_TYPE_BASE</NAME>
#define NSP_TYPE_BASE(t) ((NspTypeBase *) t) 
</MACRO>
<FUNCTION>
<NAME>nsp_new_type_id</NAME>
<RETURNS>NspTypeId  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>registered_types</NAME>
</STRUCT>
<STRUCT>
<NAME>registered_types</NAME>
struct _registered_types {
  NspTypeObject  *type;
  struct _registered_types *next;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_types</NAME>
extern registered_types *nsp_types;
</VARIABLE>
<FUNCTION>
<NAME>nsp_register_type</NAME>
<RETURNS>int </RETURNS>
void *type
</FUNCTION>
<VARIABLE>
<NAME>nsp_no_type_id</NAME>
extern const int nsp_no_type_id; /* this can no be a type id : used in save/load */
</VARIABLE>
<FUNCTION>
<NAME>nsp_get_type_from_id</NAME>
<RETURNS>void *</RETURNS>
NspTypeId id
</FUNCTION>
<ENUM>
<NAME>type_mode</NAME>
typedef enum { T_BASE, T_DERIVED } type_mode;
</ENUM>
<STRUCT>
<NAME>NspObject</NAME>
struct  _NspObject {
  nsp_const_string name;	/* object name: must be first */
  NspTypeObject *type;
  NspTypeBase *basetype;        /* type of base child  */
  int  ret_pos ;                /* used to store return position from an interface */ 
  int  flag  ;                /* flags for Object protection */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_object_id</NAME>
extern int nsp_type_object_id ;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_object</NAME>
extern NspTypeObject  *nsp_type_object;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_object_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<MACRO>
<NAME>NSP_OBJECT</NAME>
#define NSP_OBJECT(o) ((NspObject *) o) 
</MACRO>
<FUNCTION>
<NAME>new_type_object</NAME>
<RETURNS>NspTypeObject *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_object_set</NAME>
<RETURNS>void </RETURNS>
NspObject *o,NspTypeObject *type
</FUNCTION>
<FUNCTION>
<NAME>new_object</NAME>
<RETURNS>NspObject  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_object_init</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>NSP_OBJECT_INLINED</NAME>
#define NSP_OBJECT_INLINED static inline 
</MACRO>
<FUNCTION>
<NAME>check_cast</NAME>
<RETURNS>int </RETURNS>
const void *obj,NspTypeId id
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_id_from_object</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj
</FUNCTION>
<FUNCTION>
<NAME>check_implements</NAME>
<RETURNS>NspTypeBase *</RETURNS>
const void *obj,NspTypeId id
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_load_def</NAME>
<RETURNS>NspObject *</RETURNS>
void * F
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_save_def</NAME>
<RETURNS>int  </RETURNS>
void * F, NspObject * M
</FUNCTION>
<MACRO>
<NAME>NSP_INC_Stack</NAME>
#define NSP_INC_Stack
</MACRO>
<STRUCT>
<NAME>Stack</NAME>
</STRUCT>
<STRUCT>
<NAME>Stack_ref</NAME>
</STRUCT>
<STRUCT>
<NAME>Stack_ref</NAME>
struct _Stack_ref {
  NspObject **D;     /* D is dynamically changed so that D[1] is the first Objet used XXX **/
  NspObject **L;     /* Last position */
  NspObject **S;     /* points to the whole stack */
  NspObject *error_msg; 
  stack_error *error;
  int errcatch; 
  int pause; 
  NspObject *symbols; /* table of symbols of functions */
  char *current_exec_dir ; /* current exec directory */
} ;

</STRUCT>
<STRUCT>
<NAME>Stack</NAME>
struct _Stack {
  int first;   /* position of first argument to be used */
  const char *fname; /* function currently evaluated */
  Stack_ref *val;    /* this part is transmited by ref */
  char *file_name ; /*  function currently evaluated is in file_name */
  int  dollar ;     /* last dollar value to propagate */
} ;

</STRUCT>
<MACRO>
<NAME>STACK_SIZE</NAME>
#define STACK_SIZE 50000
</MACRO>
<VARIABLE>
<NAME>SciStack</NAME>
extern Stack SciStack ;
</VARIABLE>
<FUNCTION>
<NAME>StackInfo</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>InitStack</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_init_stack</NAME>
<RETURNS>void </RETURNS>
Stack *stack,NspObject **S
</FUNCTION>
<FUNCTION>
<NAME>int_get_failed</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *self, char *attr
</FUNCTION>
<FUNCTION>
<NAME>int_set_failed</NAME>
<RETURNS>int </RETURNS>
NspObject *self,char *attr, NspObject *val
</FUNCTION>
<FUNCTION>
<NAME>int_get_object_failed</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *self, char *attr, int *copy
</FUNCTION>
<FUNCTION>
<NAME>int_set_object_failed</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *self, NspObject *val
</FUNCTION>
<STRUCT>
<NAME>AttrTab</NAME>
struct _AttrTab {
  char *name;
  attr_get_function *get;
  attr_set_function *set;
  attr_get_object_function *get_object;
  attr_set_object_function *set_object;
};

</STRUCT>
<FUNCTION>
<NAME>attr_search</NAME>
<RETURNS>int </RETURNS>
const char *key,AttrTab Table[]
</FUNCTION>
<FUNCTION>
<NAME>int_check_attr</NAME>
<RETURNS>int </RETURNS>
char *key,AttrTab attrs[],Stack stack,int rhs,int opt,int lhs
</FUNCTION>
<FUNCTION>
<NAME>attrs_to_stack</NAME>
<RETURNS>int </RETURNS>
char *key,AttrTab attrs[],Stack stack,int pos
</FUNCTION>
<FUNCTION>
<NAME>set_attribute_util</NAME>
<RETURNS>int </RETURNS>
NspObject *ob, NspTypeBase *type, char *attr,NspObject *val
</FUNCTION>
<FUNCTION>
<NAME>int_set_attribute</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_set_attributes</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_set_attributes1</NAME>
<RETURNS>int </RETURNS>
void *Ob,Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_create_with_attributes</NAME>
<RETURNS>int </RETURNS>
NspObject *ob,Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_attribute_util</NAME>
<RETURNS>int </RETURNS>
NspObject *ob, NspTypeBase *type,const char *attr,NspObject *val
</FUNCTION>
<FUNCTION>
<NAME>int_get_attribute</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_attribute_util</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *ob,NspTypeBase *type,const char *attr
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_attribute_object</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *ob,NspTypeBase *type,const char *attr, int *copy
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_attribute_object</NAME>
<RETURNS>int </RETURNS>
NspObject *ob,NspTypeBase *type,NspObject *val
</FUNCTION>
<FUNCTION>
<NAME>object_path_extract</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *a,int n, NspObject **ob, int *copy
</FUNCTION>
<STRUCT>
<NAME>NspMethods</NAME>
struct _NspMethods {
  char *name;
  nsp_method *meth; 
};

</STRUCT>
<FUNCTION>
<NAME>method_search</NAME>
<RETURNS>int </RETURNS>
char *key, NspMethods *Table
</FUNCTION>
<FUNCTION>
<NAME>nsp_exec_method_util</NAME>
<RETURNS>int </RETURNS>
NspObject *ob,NspTypeBase *type,char *method, Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>ArgMessage</NAME>
<RETURNS>void </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>MaybeObjCopy</NAME>
<RETURNS>void *</RETURNS>
NspObject **Obj
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_search_object</NAME>
<RETURNS>NspObject *</RETURNS>
nsp_const_string str
</FUNCTION>
<MACRO>
<NAME>Ocheckname</NAME>
#define Ocheckname(x,y) ( strcmp( NSP_OBJECT(x)->name,y)==0 ) 
</MACRO>
<MACRO>
<NAME>NULLOBJ</NAME>
#define NULLOBJ  ( NspObject *) 0 
</MACRO>
<FUNCTION>
<NAME>nsp_void_object_destroy</NAME>
<RETURNS>void </RETURNS>
NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR *F, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_id</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_xdr_load</NAME>
<RETURNS>NspObject *</RETURNS>
XDR *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_destroy</NAME>
<RETURNS>void </RETURNS>
NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_void_object_destroy</NAME>
<RETURNS>void </RETURNS>
NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_copy</NAME>
<RETURNS>NspObject *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_full_copy</NAME>
<RETURNS>NspObject *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_full_copy_and_name</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_get_size</NAME>
<RETURNS>int </RETURNS>
const NspObject *O, int j
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_copy_with_name</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_copy_and_name</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_type_as_string</NAME>
<RETURNS>char *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_type_short</NAME>
<RETURNS>char *</RETURNS>
 NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_type</NAME>
<RETURNS>int </RETURNS>
const NspObject *O, NspTypeId id
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_implements</NAME>
<RETURNS>int </RETURNS>
NspObject *O, NspTypeId id
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_info</NAME>
<RETURNS>int </RETURNS>
NspObject *O, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_print</NAME>
<RETURNS>int </RETURNS>
NspObject *O, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_latex</NAME>
<RETURNS>int </RETURNS>
NspObject *O, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_is_true</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_loop_extract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>def_loop</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_object</NAME>
<RETURNS>NspObject *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_object_copy</NAME>
<RETURNS>NspObject *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_double</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_complex</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,const doubleC *d
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_int</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name, int ival
</FUNCTION>
<FUNCTION>
<NAME>nsp_complexi_object_</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_str</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_str_and_size</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,const char *str, int lstr
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_doubles</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,int m, int n,double *rtab, double *itab
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_tint</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name, nsp_int_union val, int type
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_empty_matrix_object</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_true_object</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_boolean_object</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,int val
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_false_object</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_get_name</NAME>
<RETURNS>const char *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_set_name</NAME>
<RETURNS>int </RETURNS>
NspObject *O,const char *str
</FUNCTION>
<FUNCTION>
<NAME>print_count_rows</NAME>
<RETURNS>int </RETURNS>
Stack stack,int first_arg,int last_arg
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_set_initial_name</NAME>
<RETURNS>const char *</RETURNS>
NspObject *ob,const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_destroy_name</NAME>
<RETURNS>void </RETURNS>
NspObject *ob
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_short_string_from_id</NAME>
<RETURNS>const char *</RETURNS>
int id
</FUNCTION>
<TYPEDEF>
<NAME>nsp_string</NAME>
typedef char * nsp_string ; /* a string i.e char * */
</TYPEDEF>
<TYPEDEF>
<NAME>nsp_const_string</NAME>
typedef const char *nsp_const_string ;  /* a constant string */
</TYPEDEF>
<FUNCTION>
<NAME>new_nsp_string</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_basic_to_string</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_copy</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_destroy</NAME>
<RETURNS>void </RETURNS>
nsp_string *str
</FUNCTION>
<FUNCTION>
<NAME>new_nsp_string_n</NAME>
<RETURNS>nsp_string </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_resize</NAME>
<RETURNS>int </RETURNS>
nsp_string *hstr, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_to_utf8</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_to_latin1</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_string</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_const_string bytes,int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_protect</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_const_string str
</FUNCTION>
<STRUCT>
<NAME>NspAxes</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeAxes</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeAxes</NAME>
struct _NspTypeAxes {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 55 "./axes.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_axes</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_axes</NAME>
struct _nsp_axes {
  nsp_gcscale scale;
  NspMatrix* wrect;
  double rho;
  gboolean top;
  NspMatrix* bounds;
  NspMatrix* arect;
  NspMatrix* frect;
  char* title;
  char* x;
  char* y;
  NspList* children;
  gboolean fixed;
  gboolean iso;
  gboolean auto_axis;
  int grid;
  int axes;
  gboolean xlog;
  gboolean ylog;
  int lpos;
  NspMatrix* rect;
  gboolean zoom;
  NspMatrix* zrect;
  gboolean clip;
  int line_width;
  int font_size;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspAxes</NAME>
struct _NspAxes {
  /*< private >*/
  NspGraphic father;
  NspTypeAxes*type;
  /*< public >*/
  nsp_axes *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_axes_id</NAME>
extern int nsp_type_axes_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_axes</NAME>
extern NspTypeAxes *nsp_type_axes;
</VARIABLE>
<FUNCTION>
<NAME>new_type_axes</NAME>
<RETURNS>NspTypeAxes *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_axes</NAME>
<RETURNS>NspAxes *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLAXES</NAME>
#define NULLAXES (NspAxes*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_axes_create</NAME>
<RETURNS>NspAxes *</RETURNS>
const char *name,nsp_gcscale scale,NspMatrix* wrect,double rho,gboolean top,NspMatrix* bounds,NspMatrix* arect,NspMatrix* frect,char* title,char* x,char* y,NspList* children,gboolean fixed,gboolean iso,gboolean auto_axis,int grid,int axes,gboolean xlog,gboolean ylog,int lpos,NspMatrix* rect,gboolean zoom,NspMatrix* zrect,gboolean clip,int line_width,int font_size,int background,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_create_default</NAME>
<RETURNS>NspAxes *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_copy</NAME>
<RETURNS>NspAxes *</RETURNS>
NspAxes *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_destroy</NAME>
<RETURNS>void </RETURNS>
NspAxes *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_info</NAME>
<RETURNS>int </RETURNS>
NspAxes *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_print</NAME>
<RETURNS>int </RETURNS>
NspAxes *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_latex</NAME>
<RETURNS>int </RETURNS>
NspAxes *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_object</NAME>
<RETURNS>NspAxes *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsAxesObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsAxes</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetAxesCopy</NAME>
<RETURNS>NspAxes *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetAxes</NAME>
<RETURNS>NspAxes *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_create_partial</NAME>
<RETURNS>int </RETURNS>
NspAxes *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspAxes *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_copy_partial</NAME>
<RETURNS>NspAxes *</RETURNS>
NspAxes *H,NspAxes *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_full_copy_partial</NAME>
<RETURNS>NspAxes *</RETURNS>
NspAxes *H,NspAxes *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_full_copy</NAME>
<RETURNS>NspAxes *</RETURNS>
NspAxes *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_check_values</NAME>
<RETURNS>int </RETURNS>
NspAxes *H
</FUNCTION>
<FUNCTION>
<NAME>int_axes_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_xdr_load_partial</NAME>
<RETURNS>NspAxes *</RETURNS>
XDR *xdrs, NspAxes *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspAxes *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_for_axes</NAME>
<RETURNS>NspAxes *</RETURNS>
BCG *Xgc,const double *wrect
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_i2f</NAME>
<RETURNS>void </RETURNS>
nsp_axes *A,int x,int y,double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_graphic_context</NAME>
<RETURNS>BCG *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_unlink_figure</NAME>
<RETURNS>void </RETURNS>
NspList *L, nsp_figure *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_check_figure</NAME>
<RETURNS>int </RETURNS>
NspList *L, nsp_figure *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_strf_axes</NAME>
<RETURNS>void </RETURNS>
NspAxes *A,double *rect, char scale
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_insert_child</NAME>
<RETURNS>int </RETURNS>
NspAxes *A, NspGraphic *G, int invalidate
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_invalidate</NAME>
<RETURNS>void </RETURNS>
NspGraphic *G
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_unzoom</NAME>
<RETURNS>void </RETURNS>
NspGraphic *Obj
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_zoom</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,int *box
</FUNCTION>
<FUNCTION>
<NAME>nsp_axes_update_frame_bounds</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double *wrect,double *frect,double *arect,int *aaint,int isomode, int auto_axes, char *xf
</FUNCTION>
<FUNCTION>
<NAME>nsp_draw_colorbar</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,nsp_axes *P,double vmin , double vmax, int *colminmax
</FUNCTION>
<FUNCTION>
<NAME>gr_compute_ticks</NAME>
<RETURNS>int </RETURNS>
double *xminv,double *xmaxv,double *grads, int *ngrads
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_for_current_axes</NAME>
<RETURNS>NspAxes *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_for_axes_in_figure</NAME>
<RETURNS>NspAxes *</RETURNS>
NspFigure *F,const double *wrect
</FUNCTION>
<STRUCT>
<NAME>NspBox3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeBox3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeBox3d</NAME>
struct _NspTypeBox3d {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./box3d.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_box3d</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_box3d</NAME>
struct _nsp_box3d {
  NspMatrix* x;
  NspMatrix* y;
  NspMatrix* z;
  gboolean mesh;
  int mesh_color;
  int face_color;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspBox3d</NAME>
struct _NspBox3d {
  /*< private >*/
  NspGraphic father;
  NspTypeBox3d*type;
  /*< public >*/
  nsp_box3d *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_box3d_id</NAME>
extern int nsp_type_box3d_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_box3d</NAME>
extern NspTypeBox3d *nsp_type_box3d;
</VARIABLE>
<FUNCTION>
<NAME>new_type_box3d</NAME>
<RETURNS>NspTypeBox3d *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_box3d</NAME>
<RETURNS>NspBox3d *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLBOX3D</NAME>
#define NULLBOX3D (NspBox3d*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_box3d_create</NAME>
<RETURNS>NspBox3d *</RETURNS>
const char *name,NspMatrix* x,NspMatrix* y,NspMatrix* z,gboolean mesh,int mesh_color,int face_color,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_create_default</NAME>
<RETURNS>NspBox3d *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_copy</NAME>
<RETURNS>NspBox3d *</RETURNS>
NspBox3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_destroy</NAME>
<RETURNS>void </RETURNS>
NspBox3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_info</NAME>
<RETURNS>int </RETURNS>
NspBox3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_print</NAME>
<RETURNS>int </RETURNS>
NspBox3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_latex</NAME>
<RETURNS>int </RETURNS>
NspBox3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_object</NAME>
<RETURNS>NspBox3d *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsBox3dObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsBox3d</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetBox3dCopy</NAME>
<RETURNS>NspBox3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetBox3d</NAME>
<RETURNS>NspBox3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_create_partial</NAME>
<RETURNS>int </RETURNS>
NspBox3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspBox3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_copy_partial</NAME>
<RETURNS>NspBox3d *</RETURNS>
NspBox3d *H,NspBox3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_full_copy_partial</NAME>
<RETURNS>NspBox3d *</RETURNS>
NspBox3d *H,NspBox3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_full_copy</NAME>
<RETURNS>NspBox3d *</RETURNS>
NspBox3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_check_values</NAME>
<RETURNS>int </RETURNS>
NspBox3d *H
</FUNCTION>
<FUNCTION>
<NAME>int_box3d_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_xdr_load_partial</NAME>
<RETURNS>NspBox3d *</RETURNS>
XDR *xdrs, NspBox3d *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_box3d_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspBox3d *M
</FUNCTION>
<ENUM>
<NAME>nsp_basic_types</NAME>
enum nsp_basic_types { 
  INUMBER32 = -14,
  INUMBER64,
  UNUMBER32,
  UNUMBER64,
  NUMBER =-10,
  NAME, 
  STRING, 
  COMMENT,
  OPNAME ,
  OBJECT ,
};
</ENUM>
<MACRO>
<NAME>NAME_MAXL</NAME>
#define NAME_MAXL 128
</MACRO>
<ENUM>
<NAME>nsp_ops</NAME>
enum nsp_ops { 
  NOTCODE_OP =129, /* start after standard ascii codes */			    
  QUOTE_OP ,			      
  STAR_OP ,			      
  PLUS_OP ,			      
  HAT_OP ,			      
  COLON_OP ,			      
  OR_OP ,			      
  AND_OP ,			      
  TILDE_OP ,			      
  RETURN_OP ,			      
  COMMA_OP ,			      
  SEMICOLON_OP ,		      
  MINUS_OP ,			      
  SLASH_OP ,			      
  BACKSLASH_OP ,		      
  DOTSTAR   ,			      
  DOTSLASH  ,			      
  DOTBSLASH ,			      
  DOTPLUS   ,			      
  STARDOT   ,			      
  SLASHDOT  ,			      
  BSLASHDOT ,			      
  DOTSTARDOT  ,			      
  DOTSLASHDOT  ,		      
  DOTBSLASHDOT ,		      
  DOTHAT ,			      
  EQ     ,			      
  LEQ    ,			      
  GEQ    ,			      
  NEQ    ,			      
  DOTEQ     ,			      
  DOTLEQ    ,			      
  DOTLT    ,			      
  DOTGEQ    ,			      
  DOTGT    ,			      
  DOTNEQ    ,			      
  DOTPRIM ,			      
  MOINS   ,   /* unary minus */	      
  SEQAND   ,   /* sequential and */   
  SEQOR ,   /* sequential or */	      
  LT_OP,
  GT_OP,
  LASTCODE_OP                         
};
</ENUM>
<ENUM>
<NAME>nsp_codes</NAME>
enum nsp_codes {
  FEVAL = -200, /* must be the fisrt and such that LASTCODE_NEG_OP is negative <= nsp_basic */
  ROWCONCAT ,
  COLCONCAT ,
  LASTCASE ,
  MLHS ,
  P_MATRIX,
  STATEMENTS ,
  STATEMENTS1 ,
  OPT ,
  DIAGCONCAT ,
  LISTEVAL ,
  ARGS ,
  PARENTH ,
  DOTARGS ,
  METARGS ,
  CELLROWCONCAT ,
  CELLCOLCONCAT ,
  CELLDIAGCONCAT ,
  P_CELL,
  CELLARGS ,
  CALLEVAL ,
  EQUAL_OP ,
  EMPTYCELL,
  EMPTYMAT,
  PLIST, 
  /* language keywords the first must be ABORT */
  ABORT ,   
  APROPOS,
  BREAK , 
  CASE ,  
  CATCH ,  
  CD_COMMAND,
  CLEAR,  
  CLEARGLOBAL,  
  CONTINUE,  
  DO  ,   
  ELSE,   
  ELSEIF, 
  END,    
  ENDFUNCTION,
  EXEC,
  NSP_EXIT,
  FINALLY,
  FOR,    
  FUNCTION,
  GLOBAL,
  HELP  , 
  IF,     
  LS_COMMAND,
  PAUSE,  
  PWD_COMMAND,
  QUIT ,  
  PRETURN,
  SELECT, 
  THEN,
  TRYCATCH,
  WHAT ,  
  WHILE,  
  WHO ,   
  /* guard */
  LASTCODE_NEG_OP  
};
</ENUM>
<STRUCT>
<NAME>NspContour</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeContour</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeContour</NAME>
struct _NspTypeContour {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 49 "./contour.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_contour</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_contour</NAME>
struct _nsp_contour {
  NspMatrix* z;
  NspMatrix* x;
  NspMatrix* y;
  NspMatrix* levels;
  int nlevels;
  NspMatrix* style;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspContour</NAME>
struct _NspContour {
  /*< private >*/
  NspGraphic father;
  NspTypeContour*type;
  /*< public >*/
  nsp_contour *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_contour_id</NAME>
extern int nsp_type_contour_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_contour</NAME>
extern NspTypeContour *nsp_type_contour;
</VARIABLE>
<FUNCTION>
<NAME>new_type_contour</NAME>
<RETURNS>NspTypeContour *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_contour</NAME>
<RETURNS>NspContour *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCONTOUR</NAME>
#define NULLCONTOUR (NspContour*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_contour_create</NAME>
<RETURNS>NspContour *</RETURNS>
const char *name,NspMatrix* z,NspMatrix* x,NspMatrix* y,NspMatrix* levels,int nlevels,NspMatrix* style,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_create_default</NAME>
<RETURNS>NspContour *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_copy</NAME>
<RETURNS>NspContour *</RETURNS>
NspContour *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_destroy</NAME>
<RETURNS>void </RETURNS>
NspContour *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_info</NAME>
<RETURNS>int </RETURNS>
NspContour *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_print</NAME>
<RETURNS>int </RETURNS>
NspContour *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_latex</NAME>
<RETURNS>int </RETURNS>
NspContour *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_object</NAME>
<RETURNS>NspContour *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsContourObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsContour</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetContourCopy</NAME>
<RETURNS>NspContour *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetContour</NAME>
<RETURNS>NspContour *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_create_partial</NAME>
<RETURNS>int </RETURNS>
NspContour *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspContour *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_copy_partial</NAME>
<RETURNS>NspContour *</RETURNS>
NspContour *H,NspContour *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_full_copy_partial</NAME>
<RETURNS>NspContour *</RETURNS>
NspContour *H,NspContour *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_full_copy</NAME>
<RETURNS>NspContour *</RETURNS>
NspContour *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_check_values</NAME>
<RETURNS>int </RETURNS>
NspContour *H
</FUNCTION>
<FUNCTION>
<NAME>int_contour_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_xdr_load_partial</NAME>
<RETURNS>NspContour *</RETURNS>
XDR *xdrs, NspContour *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspContour *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour2_obj</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *x, double *y, double *z, int *n1, int *n2,int *flagnz, int *nz, double *zz, int *style
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse</NAME>
<RETURNS>int </RETURNS>
Tokenizer *T,NspBHash *symb_table,PList *plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_top</NAME>
<RETURNS>int </RETURNS>
Tokenizer *T,NspBHash *symb_table,PList *plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_expr</NAME>
<RETURNS>PList </RETURNS>
NspSMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_function_name</NAME>
<RETURNS>char *</RETURNS>
PList plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_simple_mlhs</NAME>
<RETURNS>int </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_simple_listeval</NAME>
<RETURNS>int </RETURNS>
PList plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_simple_listeval</NAME>
<RETURNS>int </RETURNS>
PList plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_is_mlhs</NAME>
<RETURNS>int </RETURNS>
PList plist, PList *plist1, int *kount
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_is_mlhs</NAME>
<RETURNS>int </RETURNS>
PList plist, PList *plist1, int *kount
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_unique_name_in_mlhs</NAME>
<RETURNS>char *</RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_astcode_to_nickname</NAME>
<RETURNS>const char *</RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_astcode_to_name</NAME>
<RETURNS>const char *</RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_astcode_to_codename</NAME>
<RETURNS>const char *</RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_astcode_to_string</NAME>
<RETURNS>char *</RETURNS>
int type
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_nsp_keyword</NAME>
<RETURNS>int </RETURNS>
const char *id
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_code_keyword</NAME>
<RETURNS>int </RETURNS>
int keyc
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_opname</NAME>
<RETURNS>int </RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_lasterror_get</NAME>
<RETURNS>NspSMatrix *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_lasterror_clear</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>NspTypePList</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePList</NAME>
struct _NspTypePList { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};

</STRUCT>
<TYPEDEF>
<NAME>PCell</NAME>
typedef struct parse_cell PCell;
</TYPEDEF>
<TYPEDEF>
<NAME>PList</NAME>
typedef struct parse_cell *PList;
</TYPEDEF>
<STRUCT>
<NAME>parse_double</NAME>
</STRUCT>
<STRUCT>
<NAME>parse_double</NAME>
struct _parse_double {
  double val ; /* the value of the parsed double */
  nsp_string str;
};

</STRUCT>
<STRUCT>
<NAME>parse_int</NAME>
</STRUCT>
<STRUCT>
<NAME>parse_int</NAME>
struct _parse_int {
  union { 
    gint32 Gint32;
    guint32 Guint32;
    gint64 Gint64;
    guint64 Guint64;
  };
  nsp_string str;
};

</STRUCT>
<STRUCT>
<NAME>NspPlist</NAME>
struct _NspPlist {
  /*< private >*/
  NspObject father; 
  NspTypePList *type; 
  /*< public >*/
  char *file_name;  /* NULL or points to the function source file-name */
  PList D;          /* points to the parsed expression */
  int dir;          /* indice in directory array or -1 */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_plist_id</NAME>
extern int nsp_type_plist_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_plist</NAME>
extern NspTypePList *nsp_type_plist;
</VARIABLE>
<FUNCTION>
<NAME>new_type_plist</NAME>
<RETURNS>NspTypePList *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_plist</NAME>
<RETURNS>NspPList *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>NspPListSize</NAME>
<RETURNS>int </RETURNS>
NspPList *Mat, int flag
</FUNCTION>
<FUNCTION>
<NAME>NspPListType</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>NspPListShType</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>NspPListLoopExtract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>NspPListObjEq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>NspPListObjNeq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>NspPListXdrLoad</NAME>
<RETURNS>NspPList *</RETURNS>
XDR *xdrs
</FUNCTION>
<FUNCTION>
<NAME>NspPListXdrSave</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, NspPList *M
</FUNCTION>
<MACRO>
<NAME>NULLP_PLIST</NAME>
#define NULLP_PLIST (NspPList*) 0 
</MACRO>
<MACRO>
<NAME>NULLPLIST</NAME>
#define NULLPLIST (PList) 0 
</MACRO>
<FUNCTION>
<NAME>NspPListObj</NAME>
<RETURNS>NspPList *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsNspPListObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsNspPList</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetNspPListCopy</NAME>
<RETURNS>NspPList *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetNspPList</NAME>
<RETURNS>NspPList *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>NspPListCreate</NAME>
<RETURNS>NspPList *</RETURNS>
const char *name, PList L, char *filename
</FUNCTION>
<FUNCTION>
<NAME>NspPListCopy</NAME>
<RETURNS>NspPList *</RETURNS>
NspPList *A
</FUNCTION>
<FUNCTION>
<NAME>NspPListCopy_no_local_vars</NAME>
<RETURNS>NspPList *</RETURNS>
NspPList *A
</FUNCTION>
<FUNCTION>
<NAME>NspPListDestroy</NAME>
<RETURNS>void </RETURNS>
NspPList *P_L
</FUNCTION>
<FUNCTION>
<NAME>NspPListPrInt</NAME>
<RETURNS>void </RETURNS>
NspPList *P_L
</FUNCTION>
<FUNCTION>
<NAME>NspPListInfo</NAME>
<RETURNS>void </RETURNS>
NspPList *P_L, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>NspPListPrint</NAME>
<RETURNS>void </RETURNS>
NspPList *P_L, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>NspPListSave</NAME>
<RETURNS>int </RETURNS>
NspPList *P_L
</FUNCTION>
<FUNCTION>
<NAME>NspPList2SMatrix</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspPList *P_L, int indent
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_get_path</NAME>
<RETURNS>int </RETURNS>
char *fname,NspPList *P_L
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add</NAME>
<RETURNS>int </RETURNS>
PList *plist, int op, int arity, int line
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_last</NAME>
<RETURNS>int </RETURNS>
PList *plist, int op, int arity, int line
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_name</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_name1</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str, int arity
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_string</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_comment</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_list</NAME>
<RETURNS>int </RETURNS>
PList *plist, PList *l
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_append</NAME>
<RETURNS>int </RETURNS>
PList *plist, PList *l
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_list1</NAME>
<RETURNS>int </RETURNS>
PList *plist, PList *l
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_doublei</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_opname</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_object</NAME>
<RETURNS>int </RETURNS>
PList *plist, NspObject *obj
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_inti</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str, int type
</FUNCTION>
<FUNCTION>
<NAME>ParseAddDouble</NAME>
<RETURNS>int </RETURNS>
PList *plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_eplist_create</NAME>
<RETURNS>PList </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_destroy</NAME>
<RETURNS>void </RETURNS>
PList *List
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_copy</NAME>
<RETURNS>PList </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_copy_no_local_vars</NAME>
<RETURNS>PList </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_last</NAME>
<RETURNS>PList </RETURNS>
PList plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_print_internal</NAME>
<RETURNS>void </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_firstel</NAME>
<RETURNS>PList </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_pretty_print_opname</NAME>
<RETURNS>int </RETURNS>
int type, int indent, int pos
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_pretty_print</NAME>
<RETURNS>void </RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>nsp_arg_pretty_print</NAME>
<RETURNS>int </RETURNS>
PList L, int i, int pos, int posret
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_print</NAME>
<RETURNS>void </RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_info</NAME>
<RETURNS>void </RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>ShowLine</NAME>
<RETURNS>void </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_save</NAME>
<RETURNS>int </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_load</NAME>
<RETURNS>int </RETURNS>
PList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist2smatrix</NAME>
<RETURNS>NspSMatrix *</RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>plist_get_nargs</NAME>
<RETURNS>int </RETURNS>
PList List,int *lhs , int *rhsp1, NspSMatrix *in, NspSMatrix *out
</FUNCTION>
<ENUM>
<NAME>accelerated_ops</NAME>
typedef enum { 
  undef_tab=-1,
  concatr_tab=0, 
  concatd_tab=1,
  extract_tab=2,
  extractelts_tab=3,
  extractcols_tab=4,
  extractrows_tab=5,
  resize2vect_tab=6,
  deleteelts_tab=7,
  deletecols_tab=8,
  deleterows_tab=9,
  tozero_tab=10,
  setrowscols_tab=11} accelerated_ops;
</ENUM>
<STRUCT>
<NAME>AcceleratedTab</NAME>
</STRUCT>
<STRUCT>
<NAME>AcceleratedTab</NAME>
struct _AcceleratedTab
{
  int ops_id; /* this should be equal to the indice in table */
  const char *opname;
  int arity;
  const char **accelerated_types;
  int length;
  function **func;
} ;
</STRUCT>
<FUNCTION>
<NAME>nsp_get_fast_function</NAME>
<RETURNS>function *</RETURNS>
AcceleratedTab *tab, int type_id
</FUNCTION>
<FUNCTION>
<NAME>nsp_init_accelerated_tabs</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>NspClassBRef</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeClassBRef</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeClassBRef</NAME>
struct _NspTypeClassBRef {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 43 "./classbref.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_classbref</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_classbref</NAME>
struct _nsp_classbref {
  int clb_color;
  int clb_thickness;
  NspMatrix* clb_val;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspClassBRef</NAME>
struct _NspClassBRef {
  /*< private >*/
  NspClassARef father;
  NspTypeClassBRef*type;
  /*< public >*/
  nsp_classbref *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_classbref_id</NAME>
extern int nsp_type_classbref_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_classbref</NAME>
extern NspTypeClassBRef *nsp_type_classbref;
</VARIABLE>
<FUNCTION>
<NAME>new_type_classbref</NAME>
<RETURNS>NspTypeClassBRef *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_classbref</NAME>
<RETURNS>NspClassBRef *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCLASSBREF</NAME>
#define NULLCLASSBREF (NspClassBRef*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_classbref_create</NAME>
<RETURNS>NspClassBRef *</RETURNS>
const char *name,int clb_color,int clb_thickness,NspMatrix* clb_val,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_create_default</NAME>
<RETURNS>NspClassBRef *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_copy</NAME>
<RETURNS>NspClassBRef *</RETURNS>
NspClassBRef *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_destroy</NAME>
<RETURNS>void </RETURNS>
NspClassBRef *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_info</NAME>
<RETURNS>int </RETURNS>
NspClassBRef *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_print</NAME>
<RETURNS>int </RETURNS>
NspClassBRef *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_latex</NAME>
<RETURNS>int </RETURNS>
NspClassBRef *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_object</NAME>
<RETURNS>NspClassBRef *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsClassBRefObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsClassBRef</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetClassBRefCopy</NAME>
<RETURNS>NspClassBRef *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetClassBRef</NAME>
<RETURNS>NspClassBRef *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_create_partial</NAME>
<RETURNS>int </RETURNS>
NspClassBRef *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspClassBRef *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_copy_partial</NAME>
<RETURNS>NspClassBRef *</RETURNS>
NspClassBRef *H,NspClassBRef *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_full_copy_partial</NAME>
<RETURNS>NspClassBRef *</RETURNS>
NspClassBRef *H,NspClassBRef *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_full_copy</NAME>
<RETURNS>NspClassBRef *</RETURNS>
NspClassBRef *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_check_values</NAME>
<RETURNS>int </RETURNS>
NspClassBRef *H
</FUNCTION>
<FUNCTION>
<NAME>int_classbref_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_xdr_load_partial</NAME>
<RETURNS>NspClassBRef *</RETURNS>
XDR *xdrs, NspClassBRef *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_classbref_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspClassBRef *M
</FUNCTION>
<STRUCT>
<NAME>nsp_file</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_file</NAME>
struct _nsp_file {
  FILE *file ;   /* the file */
  XDR  xdrs[1];  /* xdr struture */
  int  flag;     /* flag for special open (xdr) */
  char openf[4]; /* flags used in fopen */
  char *fname;  /* file name */
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspTypeSciFile</NAME>
typedef struct _NspTypeSciFile { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeSciFile;
</STRUCT>
<STRUCT>
<NAME>NspFile</NAME>
struct _NspFile {
  /*< private >*/
  NspObject father; 
  NspTypeSciFile *type; 
  /*< public >*/
  nsp_file *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_file_id</NAME>
extern int nsp_type_file_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_file</NAME>
extern NspTypeSciFile *nsp_type_file;
</VARIABLE>
<FUNCTION>
<NAME>new_type_file</NAME>
<RETURNS>NspTypeSciFile *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_file</NAME>
<RETURNS>NspFile *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_file_create</NAME>
<RETURNS>NspFile *</RETURNS>
char *name,const char *fname, char *str, int flag, FILE *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_copy</NAME>
<RETURNS>NspFile *</RETURNS>
NspFile *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_destroy</NAME>
<RETURNS>void </RETURNS>
NspFile *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_info</NAME>
<RETURNS>int </RETURNS>
NspFile *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_print</NAME>
<RETURNS>int </RETURNS>
NspFile *H, int indent,char *name, int rec_level
</FUNCTION>
<MACRO>
<NAME>OPEN_MASK</NAME>
#define OPEN_MASK 0x000f 
</MACRO>
<MACRO>
<NAME>XDR_MASK</NAME>
#define XDR_MASK 0x00f0 
</MACRO>
<MACRO>
<NAME>SWAP_MASK</NAME>
#define SWAP_MASK 0x0f00 
</MACRO>
<MACRO>
<NAME>SWAP_ON</NAME>
#define SWAP_ON(flag) (flag |= (1 << 8) )
</MACRO>
<MACRO>
<NAME>SWAP_OFF</NAME>
#define SWAP_OFF(flag) (flag &= ~SWAP_MASK )
</MACRO>
<MACRO>
<NAME>XDR_ON</NAME>
#define XDR_ON(flag)  (flag |= (1 << 4 ) )
</MACRO>
<MACRO>
<NAME>XDR_OFF</NAME>
#define XDR_OFF(flag)  (flag &= ~XDR_MASK )
</MACRO>
<MACRO>
<NAME>OPEN_ON</NAME>
#define OPEN_ON(flag)  (flag |= (1  ) )
</MACRO>
<MACRO>
<NAME>OPEN_OFF</NAME>
#define OPEN_OFF(flag)  (flag &= ~OPEN_MASK )
</MACRO>
<MACRO>
<NAME>IS_OPENED</NAME>
#define IS_OPENED(flag) ( flag & OPEN_MASK )
</MACRO>
<MACRO>
<NAME>IS_XDR</NAME>
#define IS_XDR(flag) ( flag & XDR_MASK)
</MACRO>
<MACRO>
<NAME>USE_SWAP</NAME>
#define USE_SWAP(flag) ( flag & SWAP_MASK) 
</MACRO>
<MACRO>
<NAME>NULLSCIFILE</NAME>
#define NULLSCIFILE (NspFile *) 0
</MACRO>
<FUNCTION>
<NAME>nsp_file_object</NAME>
<RETURNS>NspFile *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSciFileObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSciFileCopy</NAME>
<RETURNS>NspFile *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSciFile</NAME>
<RETURNS>NspFile *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_open</NAME>
<RETURNS>NspFile *</RETURNS>
const char *fname, char *mode,int xdr_on,int swap_on
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_close</NAME>
<RETURNS>int </RETURNS>
NspFile *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_open_xdr_r</NAME>
<RETURNS>NspFile *</RETURNS>
const char *fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_close_xdr_r</NAME>
<RETURNS>int </RETURNS>
NspFile *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_open_xdr_w</NAME>
<RETURNS>NspFile *</RETURNS>
const char *fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_close_xdr_w</NAME>
<RETURNS>int </RETURNS>
NspFile *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_d</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_d</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, double *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_i</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, int ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_i</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, int *ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_c</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, char c
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_c</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, char *c
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_array_i</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, int *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_array_i</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, int *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_array_c</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs,char *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_array_c</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs,char *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_array_d</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, double *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_array_d</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, double *nx, int mn
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_string</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, char *buf, int buf_len
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_new_string</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, char **str
</FUNCTION>
<FUNCTION>
<NAME>is_little_endian</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_feof</NAME>
<RETURNS>int </RETURNS>
NspFile *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_ferror</NAME>
<RETURNS>int </RETURNS>
NspFile *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_clearerr</NAME>
<RETURNS>void </RETURNS>
NspFile *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_fseek</NAME>
<RETURNS>int </RETURNS>
NspFile *F,long int offset,const char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_ftell</NAME>
<RETURNS>int </RETURNS>
NspFile *F,long int *offset
</FUNCTION>
<FUNCTION>
<NAME>nsp_mput</NAME>
<RETURNS>int </RETURNS>
NspFile *F,void *x,int n, char *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_mget</NAME>
<RETURNS>int </RETURNS>
NspFile *F,void *x,int n,const char *type, int *items_read
</FUNCTION>
<FUNCTION>
<NAME>nsp_mgetstr</NAME>
<RETURNS>int </RETURNS>
NspFile *F, char **start, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mgetstr1</NAME>
<RETURNS>int </RETURNS>
NspFile *F, char *start, int n, int *n_read
</FUNCTION>
<FUNCTION>
<NAME>nsp_putstr</NAME>
<RETURNS>int </RETURNS>
NspFile *F, char *str
</FUNCTION>
<FUNCTION>
<NAME>do_printf</NAME>
<RETURNS>int </RETURNS>
char *fname, FILE *fp, char *format, Stack stack,int nargs, int arg_cnt, int line, char **strv
</FUNCTION>
<FUNCTION>
<NAME>do_scanf</NAME>
<RETURNS>int </RETURNS>
const char *command,FILE *fp,char *format,Stack stack,int iline, int *nargs,const char *strv,int *retval
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_string</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs,char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_string</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs,const char *str
</FUNCTION>
<MACRO>
<NAME>LINEMAXSIZE</NAME>
#define LINEMAXSIZE 4096 
</MACRO>
<TYPEDEF>
<NAME>Curline</NAME>
typedef struct _curline Curline; 
</TYPEDEF>
<STRUCT>
<NAME>curline</NAME>
struct _curline {
    int lpt1; /* position of the begining of the before last recognised token */
    int lpt2; /* position of the begining of the last recognised token */
    int lpt3; /* current char position in buf */
    char buf[LINEMAXSIZE];
} ;

</STRUCT>
<MACRO>
<NAME>TBUF</NAME>
#define TBUF 1024
</MACRO>
<STRUCT>
<NAME>token</NAME>
</STRUCT>
<STRUCT>
<NAME>token</NAME>
struct _token 
{
  char buf[TBUF];
  char syn[NAME_MAXL];
  double syv;
  char NextC;
  int id;
  int FlagEqu;
  int Line;
};
</STRUCT>
<TYPEDEF>
<NAME>Tokenizer</NAME>
typedef struct _tokenizer Tokenizer; 
</TYPEDEF>
<TYPEDEF>
<NAME>SciReadFunction</NAME>
typedef SciReadFunc *SciReadFunction;
</TYPEDEF>
<VARIABLE>
<NAME>nsp_defscireadline_rl</NAME>
extern SciReadFunc nsp_defscireadline_rl;
</VARIABLE>
<VARIABLE>
<NAME>DefSciReadLine_textview</NAME>
extern SciReadFunc DefSciReadLine_textview;
</VARIABLE>
<VARIABLE>
<NAME>DefSciReadLine</NAME>
extern SciReadFunction DefSciReadLine;
</VARIABLE>
<STRUCT>
<NAME>smat_tokenizer</NAME>
</STRUCT>
<STRUCT>
<NAME>smat_tokenizer</NAME>
struct _smat_tokenizer { 
  char **S;
  int ind;
  int pos;
  const char *line;
} ;

</STRUCT>
<STRUCT>
<NAME>string_tokenizer</NAME>
</STRUCT>
<STRUCT>
<NAME>string_tokenizer</NAME>
struct _string_tokenizer { 
  const char *str;
  int pos;
} ;

</STRUCT>
<ENUM>
<NAME>token_io</NAME>
typedef enum { 
  nsp_tok_stdio, nsp_tok_file, nsp_tok_string, nsp_tok_strings
}  token_io;
</ENUM>
<STRUCT>
<NAME>tokenizer</NAME>
struct _tokenizer {
  /* data */
  Curline curline; 
  token  tokenv;
  FILE *file; /* used when the tokenizer uses a File as input */
  smat_tokenizer strings; /* used when the tokenizer uses a string matrix as input */
  string_tokenizer string; /* used when the tokenizer uses a string matrix as input */
  int mtlb; /* is % a comment or not */
  /* methods */
  SciReadFunction token_readline;
  token_NextToken *NextToken;
  token_ParseCommandArg *ParseCommandArg;
  token_ParseString *ParseString;
  token_GetChar *GetChar;
  token_ForceNextChar *ForceNextChar;
  token_FuncForceNextChar *FuncForceNextChar;
  token_IgnoreWSpaces *IgnoreWSpaces;
  token_viewch *viewch;
  token_backch *backch;
  token_IsDotDotDot *IsDotDotDot;
  token_IsDotDot *IsDotDot;
  token_IsDotStarStar *IsDotStarStar;
  token_IsDotAlphaOld *IsDotAlphaOld;
  token_IsDotAlpha *IsDotAlpha;
  token_IsTranspose *IsTranspose;
  token_ParseShowLine *ParseShowLine;
  token_Getlin *Getlin;
  token_TokenLineSet *TokenLineSet;
  token_ParseOperators *ParseOperators;
  token_ParseNumber *ParseNumber;
  token_ParseSymb *ParseSymb;
  token_ParseComment *ParseComment;
  token_ParseError *ParseError;
  token_code2name *code2name;
  /* type of io */
  token_io io;
};

</STRUCT>
<FUNCTION>
<NAME>nsp_init_tokenizer</NAME>
<RETURNS>void </RETURNS>
Tokenizer *T
</FUNCTION>
<FUNCTION>
<NAME>nsp_tokeniser_file</NAME>
<RETURNS>void </RETURNS>
Tokenizer *T,FILE *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_tokeniser_string</NAME>
<RETURNS>void </RETURNS>
Tokenizer *T,const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_tokeniser_strings</NAME>
<RETURNS>void </RETURNS>
Tokenizer *T,char **S
</FUNCTION>
<USER_FUNCTION>
<NAME>MoreFun</NAME>
<RETURNS>void </RETURNS>
int *n
</USER_FUNCTION>
<VARIABLE>
<NAME>scimore</NAME>
extern MoreFun scimore ;
</VARIABLE>
<FUNCTION>
<NAME>scimore_void</NAME>
<RETURNS>void </RETURNS>
int *n
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_nsp_more</NAME>
<RETURNS>MoreFun </RETURNS>
MoreFun F
</FUNCTION>
<FUNCTION>
<NAME>nsp_prompt</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_force_prompt</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>inc_pause_prompt</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>dec_pause_prompt</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>zero_pause_prompt</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>NspArrows</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeArrows</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeArrows</NAME>
struct _NspTypeArrows {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./arrows.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_arrows</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_arrows</NAME>
struct _nsp_arrows {
  NspMatrix* x;
  NspMatrix* y;
  NspMatrix* color;
  double arsize;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspArrows</NAME>
struct _NspArrows {
  /*< private >*/
  NspGraphic father;
  NspTypeArrows*type;
  /*< public >*/
  nsp_arrows *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_arrows_id</NAME>
extern int nsp_type_arrows_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_arrows</NAME>
extern NspTypeArrows *nsp_type_arrows;
</VARIABLE>
<FUNCTION>
<NAME>new_type_arrows</NAME>
<RETURNS>NspTypeArrows *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_arrows</NAME>
<RETURNS>NspArrows *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLARROWS</NAME>
#define NULLARROWS (NspArrows*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_arrows_create</NAME>
<RETURNS>NspArrows *</RETURNS>
const char *name,NspMatrix* x,NspMatrix* y,NspMatrix* color,double arsize,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_create_default</NAME>
<RETURNS>NspArrows *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_copy</NAME>
<RETURNS>NspArrows *</RETURNS>
NspArrows *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_destroy</NAME>
<RETURNS>void </RETURNS>
NspArrows *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_info</NAME>
<RETURNS>int </RETURNS>
NspArrows *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_print</NAME>
<RETURNS>int </RETURNS>
NspArrows *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_latex</NAME>
<RETURNS>int </RETURNS>
NspArrows *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_object</NAME>
<RETURNS>NspArrows *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsArrowsObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsArrows</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetArrowsCopy</NAME>
<RETURNS>NspArrows *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetArrows</NAME>
<RETURNS>NspArrows *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_create_partial</NAME>
<RETURNS>int </RETURNS>
NspArrows *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspArrows *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_copy_partial</NAME>
<RETURNS>NspArrows *</RETURNS>
NspArrows *H,NspArrows *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_full_copy_partial</NAME>
<RETURNS>NspArrows *</RETURNS>
NspArrows *H,NspArrows *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_full_copy</NAME>
<RETURNS>NspArrows *</RETURNS>
NspArrows *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_check_values</NAME>
<RETURNS>int </RETURNS>
NspArrows *H
</FUNCTION>
<FUNCTION>
<NAME>int_arrows_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_xdr_load_partial</NAME>
<RETURNS>NspArrows *</RETURNS>
XDR *xdrs, NspArrows *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_arrows_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspArrows *M
</FUNCTION>
<MACRO>
<NAME>TCL_DSTRING_STATIC_SIZE</NAME>
#define TCL_DSTRING_STATIC_SIZE 200
</MACRO>
<TYPEDEF>
<NAME>nsp_tcldstring</NAME>
typedef struct nsp_tcldstring_  nsp_tcldstring ;
</TYPEDEF>
<MACRO>
<NAME>nsp_tcldstring_length</NAME>
#define nsp_tcldstring_length(dsPtr) ((dsPtr)->length)
</MACRO>
<MACRO>
<NAME>nsp_tcldstring_value</NAME>
#define nsp_tcldstring_value(dsPtr) ((dsPtr)->string)
</MACRO>
<FUNCTION>
<NAME>nsp_tcldstring_append</NAME>
<RETURNS>char *</RETURNS>
nsp_tcldstring *dsPtr, const char *string, int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_tcldstring_appendElement</NAME>
<RETURNS>char *</RETURNS>
 nsp_tcldstring *dsPtr, const char *string
</FUNCTION>
<FUNCTION>
<NAME>nsp_tcldstring_free</NAME>
<RETURNS>void </RETURNS>
nsp_tcldstring *dsPtr
</FUNCTION>
<FUNCTION>
<NAME>nsp_tcldstring_init</NAME>
<RETURNS>void </RETURNS>
nsp_tcldstring *dsPtr
</FUNCTION>
<FUNCTION>
<NAME>nsp_tcldstring_set_length</NAME>
<RETURNS>void </RETURNS>
nsp_tcldstring *dsPtr, int length
</FUNCTION>
<STRUCT>
<NAME>NspDiagram</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeDiagram</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeDiagram</NAME>
struct _NspTypeDiagram {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./diagram.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_diagram</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_diagram</NAME>
struct _nsp_diagram {
  NspMatrix* bounds;
  NspList* children;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspDiagram</NAME>
struct _NspDiagram {
  /*< private >*/
  NspGraphic father;
  NspTypeDiagram*type;
  /*< public >*/
  nsp_diagram *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_diagram_id</NAME>
extern int nsp_type_diagram_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_diagram</NAME>
extern NspTypeDiagram *nsp_type_diagram;
</VARIABLE>
<FUNCTION>
<NAME>new_type_diagram</NAME>
<RETURNS>NspTypeDiagram *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_diagram</NAME>
<RETURNS>NspDiagram *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLDIAGRAM</NAME>
#define NULLDIAGRAM (NspDiagram*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_diagram_create</NAME>
<RETURNS>NspDiagram *</RETURNS>
const char *name,NspMatrix* bounds,NspList* children,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_create_default</NAME>
<RETURNS>NspDiagram *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_copy</NAME>
<RETURNS>NspDiagram *</RETURNS>
NspDiagram *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_destroy</NAME>
<RETURNS>void </RETURNS>
NspDiagram *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_info</NAME>
<RETURNS>int </RETURNS>
NspDiagram *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_print</NAME>
<RETURNS>int </RETURNS>
NspDiagram *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_latex</NAME>
<RETURNS>int </RETURNS>
NspDiagram *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_object</NAME>
<RETURNS>NspDiagram *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsDiagramObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsDiagram</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetDiagramCopy</NAME>
<RETURNS>NspDiagram *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetDiagram</NAME>
<RETURNS>NspDiagram *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_create_partial</NAME>
<RETURNS>int </RETURNS>
NspDiagram *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspDiagram *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_copy_partial</NAME>
<RETURNS>NspDiagram *</RETURNS>
NspDiagram *H,NspDiagram *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_full_copy_partial</NAME>
<RETURNS>NspDiagram *</RETURNS>
NspDiagram *H,NspDiagram *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_full_copy</NAME>
<RETURNS>NspDiagram *</RETURNS>
NspDiagram *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_check_values</NAME>
<RETURNS>int </RETURNS>
NspDiagram *H
</FUNCTION>
<FUNCTION>
<NAME>int_diagram_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_xdr_load_partial</NAME>
<RETURNS>NspDiagram *</RETURNS>
XDR *xdrs, NspDiagram *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspDiagram *M
</FUNCTION>
<ENUM>
<NAME></NAME>
typedef enum { MOVE, MOVE_CONTROL } move_action ;
typedef enum _list_move_action list_move_action; 
enum _list_move_action {  L_INVALIDATE,  L_TRANSLATE,  L_LOCK_UPDATE,  L_LINK_CHECK};
</ENUM>
<FUNCTION>
<NAME>nsp_get_point_axes</NAME>
<RETURNS>NspGraphic *</RETURNS>
BCG *Xgc,int px,int py,double *dp
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_get_axe_elts_as_diagram</NAME>
<RETURNS>NspDiagram *</RETURNS>
char *name,NspFigure *F
</FUNCTION>
<FUNCTION>
<NAME>IsDiagramObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetDiagramCopy</NAME>
<RETURNS>NspDiagram *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetDiagram</NAME>
<RETURNS>NspDiagram *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsDiagram</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_select_obj</NAME>
<RETURNS>int </RETURNS>
NspDiagram *R, const double *pt, NspObject **Objs,NspObject *exclude
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_select_lock</NAME>
<RETURNS>int </RETURNS>
NspDiagram *F,double pt[2], NspObject **O, int *cp, int *lock_c
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_select_and_move</NAME>
<RETURNS>int </RETURNS>
NspDiagram *R, const double *pt, int mask
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_select_and_hilite</NAME>
<RETURNS>int </RETURNS>
NspDiagram *R,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_select_and_toggle_hilite</NAME>
<RETURNS>int </RETURNS>
NspDiagram *R,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_move_obj</NAME>
<RETURNS>int </RETURNS>
NspDiagram *R,NspObject *O, const double *pt, int stop, int cp,move_action  action
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_unhilite_objs</NAME>
<RETURNS>void </RETURNS>
NspDiagram *R, int draw
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_delete_hilited</NAME>
<RETURNS>void </RETURNS>
NspDiagram *R
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_create_new_block</NAME>
<RETURNS>NspObject*</RETURNS>
NspDiagram *R,const double pt[2],int mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_create_new_connector</NAME>
<RETURNS>NspObject*</RETURNS>
NspDiagram *R
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_create_new_link</NAME>
<RETURNS>NspObject*</RETURNS>
NspDiagram *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_create_new_gridblock</NAME>
<RETURNS>NspObject *</RETURNS>
NspDiagram *F, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_create_new_rect</NAME>
<RETURNS>int </RETURNS>
NspDiagram *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_hilite_near_pt</NAME>
<RETURNS>int  </RETURNS>
NspDiagram *R,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_locks_update</NAME>
<RETURNS>void </RETURNS>
NspDiagram *R,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_select_and_split</NAME>
<RETURNS>int </RETURNS>
NspDiagram *R,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_select_link_and_add_control</NAME>
<RETURNS>int </RETURNS>
NspDiagram *R,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_select_link_and_remove_control</NAME>
<RETURNS>int </RETURNS>
NspDiagram *R,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_get_hilited</NAME>
<RETURNS>NspObject *</RETURNS>
NspDiagram *R
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_full_copy</NAME>
<RETURNS>NspDiagram *</RETURNS>
 NspDiagram *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_from_nspdiagram</NAME>
<RETURNS>NspDiagram *</RETURNS>
char *name,BCG *Xgc, nsp_diagram *gf
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_destroy</NAME>
<RETURNS>void </RETURNS>
NspDiagram *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_get_hilited_list</NAME>
<RETURNS>NspList *</RETURNS>
nsp_diagram *gf, int full_copy
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_select_and_move_list</NAME>
<RETURNS>int </RETURNS>
NspDiagram *R,NspObject *Obj,const double pt[2], int *click
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_move_list_obj</NAME>
<RETURNS>int </RETURNS>
NspDiagram *F,NspList *L,const double pt[2],int stop,int cp,move_action action, int *click
</FUNCTION>
<FUNCTION>
<NAME>nsp_diagram_hilited_full_copy</NAME>
<RETURNS>NspDiagram *</RETURNS>
 NspDiagram *F
</FUNCTION>
<FUNCTION>
<NAME>link_lock_update</NAME>
<RETURNS>void </RETURNS>
NspDiagram *F, NspLink *L,int lp,double ptnew[2]
</FUNCTION>
<FUNCTION>
<NAME>link_check</NAME>
<RETURNS>void </RETURNS>
NspDiagram *F,NspLink *L
</FUNCTION>
<FUNCTION>
<NAME>link_split</NAME>
<RETURNS>int </RETURNS>
NspDiagram *F,NspLink *L,NspLink **L1,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>link_split</NAME>
<RETURNS>int </RETURNS>
NspDiagram *F,NspLink *L,NspLink **L1,const double pt[2]
</FUNCTION>
<STRUCT>
<NAME>NspTypeMod</NAME>
typedef struct _NspTypeMod { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeMod;
</STRUCT>
<TYPEDEF>
<NAME>Lmo</NAME>
typedef NspList Lmo ; /* Lmo is a List */
</TYPEDEF>
<STRUCT>
<NAME>NspMod</NAME>
struct _NspMod {
  /*< private >*/
  NspObject father; 
  NspTypeMod *type; 
  /*< public >*/
  char *path;   /* absolute XXX path of the module */ 
  char *mname;  /* module name */ 
  NspHash *T;      /* hash table to store module objects of type me 
		   (module elts) */
  Lmo *L;       /* List of submodules */
  int flag;     /* are we a copy ? */ 
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_mod_id</NAME>
extern int nsp_type_mod_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_mod</NAME>
extern NspTypeMod *nsp_type_mod;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_mod_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_mod</NAME>
<RETURNS>NspTypeMod *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_mod</NAME>
<RETURNS>NspMod *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>ModSize</NAME>
<RETURNS>int </RETURNS>
NspMod *Mat, int flag
</FUNCTION>
<FUNCTION>
<NAME>ModType</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ModShType</NAME>
<RETURNS>char *</RETURNS>
NspMod *M
</FUNCTION>
<FUNCTION>
<NAME>ModLoopExtract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>ModObjEq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>ModObjNeq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLMOD</NAME>
#define NULLMOD (NspMod *) 0
</MACRO>
<FUNCTION>
<NAME>ModFullComp</NAME>
<RETURNS>int </RETURNS>
NspMod * A,NspMod * B,char *op,int *err
</FUNCTION>
<FUNCTION>
<NAME>ModCreate</NAME>
<RETURNS>NspMod *</RETURNS>
char *name,char *dir,char *mname
</FUNCTION>
<FUNCTION>
<NAME>ModCopy</NAME>
<RETURNS>NspMod *</RETURNS>
NspMod *H
</FUNCTION>
<FUNCTION>
<NAME>ModDestroy</NAME>
<RETURNS>void </RETURNS>
NspMod *H
</FUNCTION>
<FUNCTION>
<NAME>ModInfo</NAME>
<RETURNS>void </RETURNS>
NspMod *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>ModPrint</NAME>
<RETURNS>void </RETURNS>
NspMod *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>ModEnter</NAME>
<RETURNS>int </RETURNS>
NspMod *H,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>ModEnterCopy</NAME>
<RETURNS>int </RETURNS>
NspMod *H,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>ModDelete</NAME>
<RETURNS>void </RETURNS>
NspMod *H,char *str
</FUNCTION>
<FUNCTION>
<NAME>ModFind</NAME>
<RETURNS>int </RETURNS>
NspMod *H,char *str,NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>ModFindCopy</NAME>
<RETURNS>int </RETURNS>
NspMod *H,char *str,NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>ModMerge</NAME>
<RETURNS>int </RETURNS>
NspMod *H1,NspMod*H2
</FUNCTION>
<FUNCTION>
<NAME>ModNextObj</NAME>
<RETURNS>int </RETURNS>
NspMod *H,int *i,  NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>ModFill</NAME>
<RETURNS>int </RETURNS>
NspMod *Mo
</FUNCTION>
<STRUCT>
<NAME>OpTab</NAME>
</STRUCT>
<STRUCT>
<NAME>OpTab</NAME>
struct _OpTab  {
  char *name;
  function *fonc;
};

</STRUCT>
<STRUCT>
<NAME>OpWrapTab</NAME>
</STRUCT>
<STRUCT>
<NAME>OpWrapTab</NAME>
struct _OpWrapTab  {
  char *name;
  function *fonc;
  function_wrapper *wrapper;
};

</STRUCT>
<STRUCT>
<NAME>OpGrTab</NAME>
</STRUCT>
<STRUCT>
<NAME>OpGrTab</NAME>
struct _OpGrTab  {
  char *name1;
  char *name2;
  function *fonc;
};

</STRUCT>
<FUNCTION>
<NAME>SMatCreateFromAttrsTable</NAME>
<RETURNS>NspSMatrix *</RETURNS>
AttrTab *T
</FUNCTION>
<MACRO>
<NAME>NthObj</NAME>
#define NthObj(x) (stack.val->S[stack.first+x-1])
</MACRO>
<MACRO>
<NAME>NspFname</NAME>
#define NspFname(x) (x).fname 
</MACRO>
<MACRO>
<NAME>NspFnameH</NAME>
#define NspFnameH(x) (x)->fname 
</MACRO>
<MACRO>
<NAME>NspFileName</NAME>
#define NspFileName(x) (x).file_name
</MACRO>
<MACRO>
<NAME>CheckRhs</NAME>
#define CheckRhs(x,y) if ( rhs < x || rhs > y )				\
    { Scierror("Error: %d arguments is incorrect for function %s\n",rhs,stack.fname);return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckRhsMin</NAME>
#define CheckRhsMin(x) if ( rhs < x )				\
    { Scierror("Error: %d arguments is incorrect for function %s\n",rhs,stack.fname);return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckLhs</NAME>
#define CheckLhs(x,y) if ( lhs != -1 && ( lhs < x || lhs > y ))		\
    { Scierror("Error %d returned values is incorrect for function %s\n",lhs,stack.fname);return RET_BUG;}
</MACRO>
<MACRO>
<NAME>CheckStdRhs</NAME>
#define CheckStdRhs(x,y) if ( rhs -opt < x || rhs -opt > y )		\
  { Scierror("Error: %d arguments is incorrect for function %s\n",rhs-opt,stack.fname);return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckStdRhsMin</NAME>
#define CheckStdRhsMin(x) if ( rhs -opt < x )				\
    { Scierror("Error: %d arguments is incorrect for function %s\n",rhs,stack.fname);return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckOptRhs</NAME>
#define CheckOptRhs(x,y) if ( opt < x || opt > y )			\
  { Scierror("Error: %d optional arguments is incorrect for function %s\n",opt,stack.fname);return RET_BUG;} 
</MACRO>
<ENUM>
<NAME>int_types</NAME>
typedef enum _int_types{ 
  s_int,        /* scalar int */
  s_double,     /* scalar double */
  s_bool,       /* scalar bool   */
  string,       /* string */
  stringcopy,   /* string copy */
  mat,          /* matrix */
  matcopy,      /* copy of matrix */
  realmat,      /* real matrix */
  realmatcopy,  /* copy of real matrix */
  smat,         /* string  matrix */
  smatcopy,     /* copy of string matrix */
  bmat,         /* boolean  matrix */
  bmatcopy,     /* copy of boolean matrix */
  mat_int,      /* matrix converted to int */
  matcopy_int,  /* copy of a matrix + int conversion */
  list,         /* a list */
  list_begin,   /* used to start a list description */
  list_end,     /* used to stop  a list description */
  obj,          /* an object */
  objcopy,      /* copy of object */
  obj_check,    /* an object preceeded by its type */
  hash,         /* a hash table */
  hashcopy,     /* a hash table copy*/
  opts,         /* optional arguments follow */ 
  new_opts,     /* optional arguments follow */
  dim_arg,      /* argument (constrained scalar string or scalar int) to choose a matrix dim */ 
  imat,         /* imatrix */
  imatcopy,     /* copy of imatrix */
  t_end         /* end of type table  */ 
} int_types;
</ENUM>
<STRUCT>
<NAME>nsp_option</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_option</NAME>
struct _nsp_option { 
  char *name;  /* options names */
  int_types type; /* types associated to each optional name */
  NspObject *obj;    /* array to store pointers to selected optional arguments 
		  * (set to NULL) if optional argument is not found */
  int  position;     /* stack position of arguments */
};

</STRUCT>
<FUNCTION>
<NAME>RetArgs</NAME>
<RETURNS>int </RETURNS>
Stack stack,int lhs,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>GetArgs</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int rhs,int opt,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>GetListArgs</NAME>
<RETURNS>int  </RETURNS>
NspList *L,int pos,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>BuildListFromArgs</NAME>
<RETURNS>NspList *</RETURNS>
const char *name,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>BuildHashFromArgs</NAME>
<RETURNS>NspHash*</RETURNS>
const char *name,const char *names[],int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>GetFromTable</NAME>
<RETURNS>int  </RETURNS>
NspObject **Objs,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>get_optional_args</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int rhs,int opt,nsp_option opts[],...
</FUNCTION>
<FUNCTION>
<NAME>get_optional_args_from_hash</NAME>
<RETURNS>int  </RETURNS>
Stack stack,NspHash *H,nsp_option opts[],...
</FUNCTION>
<FUNCTION>
<NAME>get_args_from_hash</NAME>
<RETURNS>int  </RETURNS>
Stack stack,NspHash *H,nsp_option opts[],...
</FUNCTION>
<FUNCTION>
<NAME>PutLhsObj</NAME>
<RETURNS>void </RETURNS>
Stack stack,int nv,int ind[]
</FUNCTION>
<FUNCTION>
<NAME>OptCheck</NAME>
<RETURNS>void </RETURNS>
NspObject **Os,NspObject **DefO,char **Names,int n,Stack ,int nopt
</FUNCTION>
<FUNCTION>
<NAME>ArgPosition</NAME>
<RETURNS>char *</RETURNS>
int i
</FUNCTION>
<FUNCTION>
<NAME>ArgName</NAME>
<RETURNS>void </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>SwapObjs</NAME>
<RETURNS>void </RETURNS>
Stack stack,int i,int j
</FUNCTION>
<FUNCTION>
<NAME>MoveObj</NAME>
<RETURNS>void </RETURNS>
Stack stack ,int j,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>StackStore</NAME>
<RETURNS>void </RETURNS>
Stack stack,NspObject * o,int pos
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_string</NAME>
<RETURNS>int </RETURNS>
Stack stack,int n,const char *bytes,int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_string_obj</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,const char *bytes,int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_double</NAME>
<RETURNS>int </RETURNS>
Stack stack,int n,double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_doubles</NAME>
<RETURNS>int </RETURNS>
Stack stack,int pos, int m,int n,...
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_double_obj</NAME>
<RETURNS>NspObject *</RETURNS>
double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_boolean</NAME>
<RETURNS>int </RETURNS>
Stack stack,int n,int ival
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_boolean_obj</NAME>
<RETURNS>NspObject *</RETURNS>
int ival
</FUNCTION>
<FUNCTION>
<NAME>ObjConvert</NAME>
<RETURNS>void </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>ModObj</NAME>
<RETURNS>NspMod  *</RETURNS>
 NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetModCopy</NAME>
<RETURNS>NspMod *</RETURNS>
Stack S,int i
</FUNCTION>
<FUNCTION>
<NAME>GetMod</NAME>
<RETURNS>NspMod *</RETURNS>
Stack S,int i
</FUNCTION>
<FUNCTION>
<NAME>GetMe</NAME>
<RETURNS>NspMe *</RETURNS>
Stack stack,int i
</FUNCTION>
<FUNCTION>
<NAME>GetMeCopy</NAME>
<RETURNS>NspMe *</RETURNS>
Stack stack,int i
</FUNCTION>
<FUNCTION>
<NAME>GetLmoCopy</NAME>
<RETURNS>NspLmo *</RETURNS>
Stack S,int  i
</FUNCTION>
<FUNCTION>
<NAME>GetLmo</NAME>
<RETURNS>NspLmo *</RETURNS>
Stack S,int i
</FUNCTION>
<FUNCTION>
<NAME>GetDimArg</NAME>
<RETURNS>int </RETURNS>
Stack stack, int pos, int *dim
</FUNCTION>
<FUNCTION>
<NAME>DimArg</NAME>
<RETURNS>int </RETURNS>
NspObject *O, int *dim
</FUNCTION>
<MACRO>
<NAME>CheckSameDims</NAME>
#define CheckSameDims(fname,pos1,pos2,o1,o2) if ( o1->m != o2->m || o1->n != o2->n ) \
   { Scierror("%s: arguments %d and %d should have the same size\n",fname,pos1,pos2); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckScalarOrDims</NAME>
#define CheckScalarOrDims(fname,pos1,o1,m1,n1) if ( (o1->mn != 1) && (o1->m != m1 || o1->n != n1) ) \
   { Scierror("%s: argument %d should be a scalar or of size %dx%d\n",fname,pos1,m1,n1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckDims</NAME>
#define CheckDims(fname,pos1,o1,m1,n1) if ( o1->m != m1 || o1->n != n1 ) \
   { Scierror("%s: argument %d should be of size %dx%d\n",fname,pos1,m1,n1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckDimProp</NAME>
#define CheckDimProp(fname,pos1,pos2,log_exp) if ( log_exp )		\
    { Scierror("%s: arguments %d and %d have incompatible size\n",fname,pos1,pos2); \
      return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckSquare</NAME>
#define CheckSquare(fname,pos1,o1) if ( o1->m != o1->n ) \
   { Scierror("%s: argument %d should be square\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckRows</NAME>
#define CheckRows(fname,pos1,o1,value) if ( o1->m != value ) \
   { Scierror("%s: argument %d has an incorrect row dimension\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckCols</NAME>
#define CheckCols(fname,pos1,o1,value) if ( o1->n != value ) \
   { Scierror("%s: argument %d has an incorrect col dimension\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckLength</NAME>
#define CheckLength(fname,pos1,o1,value) if ( o1->mn != value ) \
   { Scierror("%s: argument %d should be of length %d\n",fname,pos1,value); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckLength_</NAME>
#define CheckLength_(fname,pos1,o1,value,ret) if ( o1->mn != value )	\
   { Scierror("%s: argument %d should be of length %d\n",fname,pos1,value); \
     return ret;} 
</MACRO>
<MACRO>
<NAME>CheckScalar</NAME>
#define CheckScalar(fname,pos1,o1) if ( o1->mn != 1 ) \
   { Scierror("%s: argument %d should be scalar\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckVector</NAME>
#define CheckVector(fname,pos1,o1) if ( o1->mn != 0 && o1->m != 1 && o1->n != 1 ) \
   { Scierror("%s: argument %d should be a vector \n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckReal</NAME>
#define CheckReal(fname,pos,o1) if ( o1->rc_type != 'r' ) \
   { Scierror("%s: argument %d should be a real matrix\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckComplex</NAME>
#define CheckComplex(fname,pos,o1) if ( o1->rc_type != 'r' ) \
   { Scierror("%s: argument %d should be a complex  matrix\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckNonNegative</NAME>
#define CheckNonNegative(fname, k, pos1) if ( k < 0 ) \
   { Scierror("%s: argument %d must be non negative\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>GiveMatlabDimFlag</NAME>
#define GiveMatlabDimFlag(Mat) Mat->m == 1 || Mat->n == 1 || (Mat->m == 0 && Mat->n == 0) ? 0 : 1; 
</MACRO>
<FUNCTION>
<NAME>call_interf</NAME>
<RETURNS>int </RETURNS>
function *f, Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>AllInterf</NAME>
<RETURNS>int </RETURNS>
int i, int num, Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_expand_file_and_update_exec_dir</NAME>
<RETURNS>void </RETURNS>
Stack *stack,char *old,char *filename,char *filename_exec
</FUNCTION>
<FUNCTION>
<NAME>nsp_expand_file_with_exec_dir</NAME>
<RETURNS>void </RETURNS>
Stack *stack,char *filename,char *filename_exec
</FUNCTION>
<MACRO>
<NAME>NSP_INT_TO_POINTER</NAME>
#define NSP_INT_TO_POINTER(i) ((int *) (i)) 
</MACRO>
<MACRO>
<NAME>NSP_POINTER_TO_INT</NAME>
#define NSP_POINTER_TO_INT(i) ((int) (i))
</MACRO>
<MACRO>
<NAME>NSP_INT_TO_POINTER</NAME>
#define NSP_INT_TO_POINTER(i) ((int *) (long) (i))
</MACRO>
<MACRO>
<NAME>NSP_POINTER_TO_INT</NAME>
#define NSP_POINTER_TO_INT(i) ((int) (long) (i))
</MACRO>
<MACRO>
<NAME>CNAME</NAME>
#define CNAME(name1,name2) name1##name2
</MACRO>
<MACRO>
<NAME>CNAME</NAME>
#define CNAME(name1,name2) name1/**/name2
</MACRO>
<MACRO>
<NAME>C2F</NAME>
#define C2F(name) name##_
</MACRO>
<MACRO>
<NAME>F2C</NAME>
#define F2C(name) name##_
</MACRO>
<MACRO>
<NAME>C2F</NAME>
#define C2F(name) name/**/_
</MACRO>
<MACRO>
<NAME>F2C</NAME>
#define F2C(name) name/**/_
</MACRO>
<MACRO>
<NAME>C2F</NAME>
#define C2F(name) name
</MACRO>
<MACRO>
<NAME>F2C</NAME>
#define F2C(name) name
</MACRO>
<MACRO>
<NAME>exp10</NAME>
#define exp10(x) pow((double) 10.0,x)
</MACRO>
<FUNCTION>
<NAME>exp10</NAME>
<RETURNS>double </RETURNS>
double
</FUNCTION>
<MACRO>
<NAME>getwd</NAME>
#define getwd(x) getcwd(x,1024) /* you must define char x[1024] */
</MACRO>
<TYPEDEF>
<NAME>integer</NAME>
typedef int integer;
</TYPEDEF>
<MACRO>
<NAME>DBL_EPSILON</NAME>
#   define  DBL_EPSILON             2.2204460492503131e-16   
</MACRO>
<MACRO>
<NAME>DBL_MAX</NAME>
#   define  DBL_MAX                 1.7976931348623158e+308  
</MACRO>
<MACRO>
<NAME>DBL_MIN</NAME>
#   define  DBL_MIN                 2.2250738585072014e-308
</MACRO>
<MACRO>
<NAME>SHRT_MAX</NAME>
#   define  SHRT_MAX                32767
</MACRO>
<MACRO>
<NAME>LONG_MAX</NAME>
#   define  LONG_MAX                2147483647
</MACRO>
<MACRO>
<NAME>INT_MAX</NAME>
#   define  INT_MAX                 2147483647
</MACRO>
<MACRO>
<NAME>MACHINE_RESOLUTION</NAME>
#   define  MACHINE_RESOLUTION      DBL_EPSILON
</MACRO>
<MACRO>
<NAME>LARGEST_REAL</NAME>
#   define  LARGEST_REAL            DBL_MAX
</MACRO>
<MACRO>
<NAME>SMALLEST_REAL</NAME>
#   define  SMALLEST_REAL           DBL_MIN
</MACRO>
<MACRO>
<NAME>LARGEST_SHORT_INTEGER</NAME>
#   define  LARGEST_SHORT_INTEGER   SHRT_MAX
</MACRO>
<MACRO>
<NAME>LARGEST_LONG_INTEGER</NAME>
#   define  LARGEST_LONG_INTEGER    LONG_MAX
</MACRO>
<MACRO>
<NAME>WITH_SYMB_TABLE</NAME>
#define WITH_SYMB_TABLE 1 
</MACRO>
<MACRO>
<NAME>MTLB_MODE</NAME>
#define MTLB_MODE 1
</MACRO>
<MACRO>
<NAME>UPDATE_EXEC_DIR</NAME>
#define UPDATE_EXEC_DIR 1
</MACRO>
<MACRO>
<NAME>IMPORT</NAME>
#define IMPORT extern  __declspec (dllimport)
</MACRO>
<MACRO>
<NAME>EXPORT</NAME>
#define EXPORT __declspec (dllexport) 
</MACRO>
<MACRO>
<NAME>IMPORT</NAME>
#define IMPORT extern __attribute__ ((__dllimport__))
</MACRO>
<MACRO>
<NAME>EXPORT</NAME>
#define EXPORT extern 
</MACRO>
<MACRO>
<NAME>IMPORT</NAME>
#define IMPORT extern
</MACRO>
<MACRO>
<NAME>EXPORT</NAME>
#define EXPORT extern
</MACRO>
<MACRO>
<NAME>INLIBNSP</NAME>
#define INLIBNSP IMPORT
</MACRO>
<MACRO>
<NAME>INLIBNSP</NAME>
#define INLIBNSP EXPORT
</MACRO>
<MACRO>
<NAME>HAVE_CLOCK</NAME>
#define HAVE_CLOCK 1
</MACRO>
<MACRO>
<NAME>HAVE_DLFCN_H</NAME>
#define HAVE_DLFCN_H 1
</MACRO>
<MACRO>
<NAME>HAVE_EXP10</NAME>
#define HAVE_EXP10 1
</MACRO>
<MACRO>
<NAME>HAVE_FINITE</NAME>
#define HAVE_FINITE 1
</MACRO>
<MACRO>
<NAME>HAVE_FLOAT_H</NAME>
#define HAVE_FLOAT_H 1
</MACRO>
<MACRO>
<NAME>HAVE_GETCWD</NAME>
#define HAVE_GETCWD 1
</MACRO>
<MACRO>
<NAME>HAVE_GETRUSAGE</NAME>
#define HAVE_GETRUSAGE 1
</MACRO>
<MACRO>
<NAME>HAVE_GETWD</NAME>
#define HAVE_GETWD 1
</MACRO>
<MACRO>
<NAME>HAVE_GMP_H</NAME>
#define HAVE_GMP_H 1
</MACRO>
<MACRO>
<NAME>HAVE_GTHREAD</NAME>
#define HAVE_GTHREAD 
</MACRO>
<MACRO>
<NAME>HAVE_GTKSOURCEVIEW</NAME>
#define HAVE_GTKSOURCEVIEW 
</MACRO>
<MACRO>
<NAME>HAVE_GTKSOURCEVIEW_CONTEXT_CLASS</NAME>
#define HAVE_GTKSOURCEVIEW_CONTEXT_CLASS 
</MACRO>
<MACRO>
<NAME>HAVE_GTKSOURCEVIEW_GUTTER</NAME>
#define HAVE_GTKSOURCEVIEW_GUTTER 
</MACRO>
<MACRO>
<NAME>HAVE_INLINE</NAME>
#define HAVE_INLINE /**/
</MACRO>
<MACRO>
<NAME>HAVE_INTTYPES_H</NAME>
#define HAVE_INTTYPES_H 1
</MACRO>
<MACRO>
<NAME>HAVE_ISINF</NAME>
#define HAVE_ISINF 1
</MACRO>
<MACRO>
<NAME>HAVE_ISNAN</NAME>
#define HAVE_ISNAN 1
</MACRO>
<MACRO>
<NAME>HAVE_LGAMMA</NAME>
#define HAVE_LGAMMA 1
</MACRO>
<MACRO>
<NAME>HAVE_LIBM</NAME>
#define HAVE_LIBM 1
</MACRO>
<MACRO>
<NAME>HAVE_LIMITS_H</NAME>
#define HAVE_LIMITS_H 1
</MACRO>
<MACRO>
<NAME>HAVE_MEMORY_H</NAME>
#define HAVE_MEMORY_H 1
</MACRO>
<MACRO>
<NAME>HAVE_MKSTEMP</NAME>
#define HAVE_MKSTEMP 1
</MACRO>
<MACRO>
<NAME>HAVE_SLEEP</NAME>
#define HAVE_SLEEP 1
</MACRO>
<MACRO>
<NAME>HAVE_STDINT_H</NAME>
#define HAVE_STDINT_H 1
</MACRO>
<MACRO>
<NAME>HAVE_STDLIB_H</NAME>
#define HAVE_STDLIB_H 1
</MACRO>
<MACRO>
<NAME>HAVE_STRERROR</NAME>
#define HAVE_STRERROR 1
</MACRO>
<MACRO>
<NAME>HAVE_STRINGS_H</NAME>
#define HAVE_STRINGS_H 1
</MACRO>
<MACRO>
<NAME>HAVE_STRING_H</NAME>
#define HAVE_STRING_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_RESOURCE_H</NAME>
#define HAVE_SYS_RESOURCE_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_STAT_H</NAME>
#define HAVE_SYS_STAT_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_TIME_H</NAME>
#define HAVE_SYS_TIME_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_TYPES_H</NAME>
#define HAVE_SYS_TYPES_H 1
</MACRO>
<MACRO>
<NAME>HAVE_TERMCAP</NAME>
#define HAVE_TERMCAP /**/
</MACRO>
<MACRO>
<NAME>HAVE_TGAMMA</NAME>
#define HAVE_TGAMMA 1
</MACRO>
<MACRO>
<NAME>HAVE_TIMES</NAME>
#define HAVE_TIMES 1
</MACRO>
<MACRO>
<NAME>HAVE_UNISTD_H</NAME>
#define HAVE_UNISTD_H 1
</MACRO>
<MACRO>
<NAME>HAVE_USLEEP</NAME>
#define HAVE_USLEEP 1
</MACRO>
<MACRO>
<NAME>HAVE_VALUES_H</NAME>
#define HAVE_VALUES_H 1
</MACRO>
<MACRO>
<NAME>HAVE_WEBKIT</NAME>
#define HAVE_WEBKIT 
</MACRO>
<MACRO>
<NAME>HAVE_WEBKIT_ZOOM</NAME>
#define HAVE_WEBKIT_ZOOM 
</MACRO>
<MACRO>
<NAME>HAVE_ZLIB</NAME>
#define HAVE_ZLIB /**/
</MACRO>
<MACRO>
<NAME>HAVE_ZLIB_H</NAME>
#define HAVE_ZLIB_H 1
</MACRO>
<MACRO>
<NAME>HAVE_cairo_image_surface</NAME>
#define HAVE_cairo_image_surface /**/
</MACRO>
<MACRO>
<NAME>HAVE_cairo_pdf_surface</NAME>
#define HAVE_cairo_pdf_surface /**/
</MACRO>
<MACRO>
<NAME>HAVE_cairo_ps_surface</NAME>
#define HAVE_cairo_ps_surface /**/
</MACRO>
<MACRO>
<NAME>HAVE_cairo_svg_surface</NAME>
#define HAVE_cairo_svg_surface /**/
</MACRO>
<MACRO>
<NAME>LT_OBJDIR</NAME>
#define LT_OBJDIR ".libs/"
</MACRO>
<MACRO>
<NAME>PACKAGE</NAME>
#define PACKAGE "nsp"
</MACRO>
<MACRO>
<NAME>PACKAGE_BUGREPORT</NAME>
#define PACKAGE_BUGREPORT ""
</MACRO>
<MACRO>
<NAME>PACKAGE_NAME</NAME>
#define PACKAGE_NAME "nsp"
</MACRO>
<MACRO>
<NAME>PACKAGE_STRING</NAME>
#define PACKAGE_STRING "nsp 1.0"
</MACRO>
<MACRO>
<NAME>PACKAGE_TARNAME</NAME>
#define PACKAGE_TARNAME "nsp"
</MACRO>
<MACRO>
<NAME>PACKAGE_URL</NAME>
#define PACKAGE_URL ""
</MACRO>
<MACRO>
<NAME>PACKAGE_VERSION</NAME>
#define PACKAGE_VERSION "1.0"
</MACRO>
<MACRO>
<NAME>POINTER_INT</NAME>
#define POINTER_INT /**/
</MACRO>
<MACRO>
<NAME>STDC_HEADERS</NAME>
#define STDC_HEADERS 1
</MACRO>
<MACRO>
<NAME>USE_SHARP_SIGN</NAME>
#define USE_SHARP_SIGN /**/
</MACRO>
<MACRO>
<NAME>VERSION</NAME>
#define VERSION "1.0"
</MACRO>
<MACRO>
<NAME>WITH_ASOUND</NAME>
#define WITH_ASOUND /**/
</MACRO>
<MACRO>
<NAME>WITH_CAIRO</NAME>
#define WITH_CAIRO /**/
</MACRO>
<MACRO>
<NAME>WITH_CHOLMOD</NAME>
#define WITH_CHOLMOD /**/
</MACRO>
<MACRO>
<NAME>WITH_FFTW3</NAME>
#define WITH_FFTW3 /**/
</MACRO>
<MACRO>
<NAME>WITH_GMP</NAME>
#define WITH_GMP /**/
</MACRO>
<MACRO>
<NAME>WITH_GTK</NAME>
#define WITH_GTK /**/
</MACRO>
<MACRO>
<NAME>WITH_GTKGLEXT</NAME>
#define WITH_GTKGLEXT /**/
</MACRO>
<MACRO>
<NAME>WITH_PORTAUDIO</NAME>
#define WITH_PORTAUDIO /**/
</MACRO>
<MACRO>
<NAME>WITH_PVM</NAME>
#define WITH_PVM /**/
</MACRO>
<MACRO>
<NAME>WITH_READLINE</NAME>
#define WITH_READLINE /**/
</MACRO>
<MACRO>
<NAME>WITH_SNDFILE</NAME>
#define WITH_SNDFILE /**/
</MACRO>
<MACRO>
<NAME>WITH_UMFPACK</NAME>
#define WITH_UMFPACK /**/
</MACRO>
<MACRO>
<NAME>WTU</NAME>
#define WTU /**/
</MACRO>
<STRUCT>
<NAME>nsp_num_formats</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_num_formats</NAME>
struct _nsp_num_formats {
  char curr_real_fmt[128];/* Current format string for real numbers and the real part of complex numbers. */
  int curr_real_fw; 
  char curr_imag_fmt[128];/*Current format string for the imaginary part of complex numbers. */
  int  curr_imag_fw;  /*Nonzero means don't do any fancy formatting. */
  int free_format;   /*Nonzero means print plus sign for nonzero, blank for zero. */
  int plus_format;   /*Nonzero means always print like dollars and cents. */
  int bank_format;   /*Nonzero means always print in latex syntax */
  int latex_format;  /* used with latex_format to add the fact that output is for texmacs */
  int latex_texmacs_format;  /*Nonzero means use an e format. */
  int print_e;   /*Nonzero means print E instead of e for exponent field. */
  int print_big_e;
};

</STRUCT>
<USER_FUNCTION>
<NAME>nsp_it_next</NAME>
<RETURNS>int </RETURNS>
const void *,double *,doubleC *,int *
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>nsp_it_init</NAME>
<RETURNS>char </RETURNS>
const void *,int *
</USER_FUNCTION>
<FUNCTION>
<NAME>gen_any_element_is_negative</NAME>
<RETURNS>int </RETURNS>
const void *M, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<FUNCTION>
<NAME>gen_any_element_is_inf_or_nan</NAME>
<RETURNS>int </RETURNS>
const void *M, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<FUNCTION>
<NAME>gen_all_elements_are_int_or_inf_or_nan</NAME>
<RETURNS>int </RETURNS>
const void *M, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<FUNCTION>
<NAME>gen_pr_min_max_internal</NAME>
<RETURNS>void </RETURNS>
const void *M, char flag, double *dmin, double *dmax, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<USER_FUNCTION>
<NAME>Mijfloat</NAME>
<RETURNS>void </RETURNS>
const nsp_num_formats *fmt,const void *,int i,int j
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_gen_matrix_as_read_syntax</NAME>
<RETURNS>void </RETURNS>
const nsp_num_formats *fmt,const void *m, int nr, int nc, int inc,int indent, Mijfloat F
</FUNCTION>
<USER_FUNCTION>
<NAME>it_gen_f</NAME>
<RETURNS>int </RETURNS>
const void *
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>pr_mima</NAME>
<RETURNS>void </RETURNS>
const void *,char,double *,double *
</USER_FUNCTION>
<FUNCTION>
<NAME>gen_set_format</NAME>
<RETURNS>void </RETURNS>
nsp_num_formats *fmt,void *M, it_gen_f is_neg, it_gen_f is_inf_or_nan, pr_mima min_max,it_gen_f all_iin, nsp_it_init Init
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_float</NAME>
<RETURNS>void </RETURNS>
const nsp_num_formats *fmt,double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_imag_float</NAME>
<RETURNS>void </RETURNS>
const nsp_num_formats *fmt,double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_complex</NAME>
<RETURNS>void </RETURNS>
const nsp_num_formats *fmt,doubleC c
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_white</NAME>
<RETURNS>void </RETURNS>
int fw
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_empty_matrix</NAME>
<RETURNS>void </RETURNS>
int nr, int nc
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_any_float</NAME>
<RETURNS>void </RETURNS>
const char *fmt, double d, int fw
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_any_float_vs</NAME>
<RETURNS>int  </RETURNS>
const char *fmt, double d, int fw, int do_print
</FUNCTION>
<FUNCTION>
<NAME>nsp_init_pr_format</NAME>
<RETURNS>void </RETURNS>
nsp_num_formats *fmt
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_set_format</NAME>
<RETURNS>void </RETURNS>
nsp_num_formats *fmt,NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_string_as_read</NAME>
<RETURNS>void </RETURNS>
const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_real_matrix_print_internal</NAME>
<RETURNS>int </RETURNS>
nsp_num_formats *fmt,NspMatrix *m, int indent
</FUNCTION>
<FUNCTION>
<NAME>nsp_complex_matrix_print_internal</NAME>
<RETURNS>int </RETURNS>
nsp_num_formats *fmt,NspMatrix *cm, int indent
</FUNCTION>
<USER_FUNCTION>
<NAME>Mijplus</NAME>
<RETURNS>void </RETURNS>
const void *,int i,int j
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_plus_format</NAME>
<RETURNS>void </RETURNS>
const void *m, int nr, int nc, Mijplus F, int indent
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_general</NAME>
<RETURNS>int </RETURNS>
const nsp_num_formats *fmt,void *m, int nr, int nc, int inc, int total_width, int max_width, int winrows, int indent, Mijfloat F
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_format</NAME>
<RETURNS>void </RETURNS>
int output_max_field_width, int output_precision,int e
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_format</NAME>
<RETURNS>void </RETURNS>
int *output_max_field_width, int *output_precision,int *e
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort</NAME>
<RETURNS>void </RETURNS>
char *a, char *tab,int flag, int n, int es, int es1,int (*cmp) (), int (*swapcode) (), int (*swapcodeind) ()
</FUNCTION>
<MACRO>
<NAME>swapcodeind</NAME>
#define swapcodeind CNAME(swapcode,int)
</MACRO>
<STRUCT>
<NAME>NspVField</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeVField</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeVField</NAME>
struct _NspTypeVField {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./vfield.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_vfield</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_vfield</NAME>
struct _nsp_vfield {
  NspMatrix* fx;
  NspMatrix* fy;
  NspMatrix* x;
  NspMatrix* y;
  gboolean colored;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspVField</NAME>
struct _NspVField {
  /*< private >*/
  NspGraphic father;
  NspTypeVField*type;
  /*< public >*/
  nsp_vfield *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_vfield_id</NAME>
extern int nsp_type_vfield_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_vfield</NAME>
extern NspTypeVField *nsp_type_vfield;
</VARIABLE>
<FUNCTION>
<NAME>new_type_vfield</NAME>
<RETURNS>NspTypeVField *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_vfield</NAME>
<RETURNS>NspVField *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLVFIELD</NAME>
#define NULLVFIELD (NspVField*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_vfield_create</NAME>
<RETURNS>NspVField *</RETURNS>
const char *name,NspMatrix* fx,NspMatrix* fy,NspMatrix* x,NspMatrix* y,gboolean colored,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_create_default</NAME>
<RETURNS>NspVField *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_copy</NAME>
<RETURNS>NspVField *</RETURNS>
NspVField *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_destroy</NAME>
<RETURNS>void </RETURNS>
NspVField *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_info</NAME>
<RETURNS>int </RETURNS>
NspVField *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_print</NAME>
<RETURNS>int </RETURNS>
NspVField *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_latex</NAME>
<RETURNS>int </RETURNS>
NspVField *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_object</NAME>
<RETURNS>NspVField *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsVFieldObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsVField</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetVFieldCopy</NAME>
<RETURNS>NspVField *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetVField</NAME>
<RETURNS>NspVField *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_create_partial</NAME>
<RETURNS>int </RETURNS>
NspVField *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspVField *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_copy_partial</NAME>
<RETURNS>NspVField *</RETURNS>
NspVField *H,NspVField *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_full_copy_partial</NAME>
<RETURNS>NspVField *</RETURNS>
NspVField *H,NspVField *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_full_copy</NAME>
<RETURNS>NspVField *</RETURNS>
NspVField *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_check_values</NAME>
<RETURNS>int </RETURNS>
NspVField *H
</FUNCTION>
<FUNCTION>
<NAME>int_vfield_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_xdr_load_partial</NAME>
<RETURNS>NspVField *</RETURNS>
XDR *xdrs, NspVField *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_vfield_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspVField *M
</FUNCTION>
<VARIABLE>
<NAME>int_column</NAME>
extern function int_column;
</VARIABLE>
<VARIABLE>
<NAME>int_mx2latexmat</NAME>
extern function int_mx2latexmat;
</VARIABLE>
<VARIABLE>
<NAME>int_mx2latextab</NAME>
extern function int_mx2latextab;
</VARIABLE>
<VARIABLE>
<NAME>int_mx_finite</NAME>
extern function int_mx_finite;
</VARIABLE>
<VARIABLE>
<NAME>int_mx_isinf</NAME>
extern function int_mx_isinf;
</VARIABLE>
<VARIABLE>
<NAME>int_mx_isnan</NAME>
extern function int_mx_isnan;
</VARIABLE>
<VARIABLE>
<NAME>int_mxabs</NAME>
extern function int_mxabs;
</VARIABLE>
<VARIABLE>
<NAME>int_mxacos</NAME>
extern function int_mxacos;
</VARIABLE>
<VARIABLE>
<NAME>int_mxacosh</NAME>
extern function int_mxacosh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxaddcols</NAME>
extern function int_mxaddcols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxaddrows</NAME>
extern function int_mxaddrows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxangle</NAME>
extern function int_mxangle;
</VARIABLE>
<VARIABLE>
<NAME>int_mxasin</NAME>
extern function int_mxasin;
</VARIABLE>
<VARIABLE>
<NAME>int_mxasinh</NAME>
extern function int_mxasinh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatan2</NAME>
extern function int_mxatan2;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatan</NAME>
extern function int_mxatan;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatanh</NAME>
extern function int_mxatanh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxbackdivel</NAME>
extern function int_mxbackdivel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxceil</NAME>
extern function int_mxceil;
</VARIABLE>
<VARIABLE>
<NAME>int_mxclean</NAME>
extern function int_mxclean;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcomplexify</NAME>
extern function int_mxcomplexify;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatd</NAME>
extern function int_mxconcatd;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatdiag</NAME>
extern function int_mxconcatdiag;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatr_mb</NAME>
extern function int_mxconcatr_mb;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconj</NAME>
extern function int_mxconj;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcopy</NAME>
extern function int_mxcopy;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcos</NAME>
extern function int_mxcos;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcosh</NAME>
extern function int_mxcosh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcreate</NAME>
extern function int_mxcreate;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcuprod</NAME>
extern function int_mxcuprod;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcusum</NAME>
extern function int_mxcusum;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdadd</NAME>
extern function int_mxdadd;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeletecols</NAME>
extern function int_mxdeletecols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeleteelts</NAME>
extern function int_mxdeleteelts;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeleterows</NAME>
extern function int_mxdeleterows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdestroy</NAME>
extern function int_mxdestroy;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiag</NAME>
extern function int_mxdiag;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiagcre</NAME>
extern function int_mxdiagcre;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiage</NAME>
extern function int_mxdiage;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiagset</NAME>
extern function int_mxdiagset;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdivel</NAME>
extern function int_mxdivel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdquote</NAME>
extern function int_mxdquote;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdsub</NAME>
extern function int_mxdsub;
</VARIABLE>
<VARIABLE>
<NAME>int_mxeq</NAME>
extern function int_mxeq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxerf</NAME>
extern function int_mxerf;
</VARIABLE>
<VARIABLE>
<NAME>int_mxerfc</NAME>
extern function int_mxerfc;
</VARIABLE>
<VARIABLE>
<NAME>int_mxexpel</NAME>
extern function int_mxexpel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextract</NAME>
extern function int_mxextract;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractcols</NAME>
extern function int_mxextractcols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractelts</NAME>
extern function int_mxextractelts;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractrows</NAME>
extern function int_mxextractrows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxeye</NAME>
extern function int_mxeye;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfeq</NAME>
extern function int_mxfeq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfge</NAME>
extern function int_mxfge;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfgt</NAME>
extern function int_mxfgt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfind</NAME>
extern function int_mxfind;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfle</NAME>
extern function int_mxfle;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfloor</NAME>
extern function int_mxfloor;
</VARIABLE>
<VARIABLE>
<NAME>int_mxflt</NAME>
extern function int_mxflt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfneq</NAME>
extern function int_mxfneq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxge</NAME>
extern function int_mxge;
</VARIABLE>
<VARIABLE>
<NAME>int_mxgt</NAME>
extern function int_mxgt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxiand</NAME>
extern function int_mxiand;
</VARIABLE>
<VARIABLE>
<NAME>int_mxidiv</NAME>
extern function int_mxidiv;
</VARIABLE>
<VARIABLE>
<NAME>int_mximagpart</NAME>
extern function int_mximagpart;
</VARIABLE>
<VARIABLE>
<NAME>int_mximpl</NAME>
extern function int_mximpl;
</VARIABLE>
<VARIABLE>
<NAME>int_mxinfo</NAME>
extern function int_mxinfo;
</VARIABLE>
<VARIABLE>
<NAME>int_mxint</NAME>
extern function int_mxint;
</VARIABLE>
<VARIABLE>
<NAME>int_mxior</NAME>
extern function int_mxior;
</VARIABLE>
<VARIABLE>
<NAME>int_mxkron</NAME>
extern function int_mxkron;
</VARIABLE>
<VARIABLE>
<NAME>int_mxle</NAME>
extern function int_mxle;
</VARIABLE>
<VARIABLE>
<NAME>int_mxlogel</NAME>
extern function int_mxlogel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxlt</NAME>
extern function int_mxlt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmat2vect</NAME>
extern function int_mxmat2vect;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmatrix</NAME>
extern function int_mxmatrix;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmaxi</NAME>
extern function int_mxmaxi;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmini</NAME>
extern function int_mxmini;
</VARIABLE>
<VARIABLE>
<NAME>int_mxminus</NAME>
extern function int_mxminus;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmodulo</NAME>
extern function int_mxmodulo;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmultel</NAME>
extern function int_mxmultel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmult</NAME>
extern function int_mxmult;
</VARIABLE>
<VARIABLE>
<NAME>int_mxneq</NAME>
extern function int_mxneq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxones</NAME>
extern function int_mxones;
</VARIABLE>
<VARIABLE>
<NAME>int_mxpolar</NAME>
extern function int_mxpolar;
</VARIABLE>
<VARIABLE>
<NAME>int_mxpowel</NAME>
extern function int_mxpowel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxprint_xxx</NAME>
extern function int_mxprint_xxx;
</VARIABLE>
<VARIABLE>
<NAME>int_mxprod</NAME>
extern function int_mxprod;
</VARIABLE>
<VARIABLE>
<NAME>int_mxquote</NAME>
extern function int_mxquote;
</VARIABLE>
<VARIABLE>
<NAME>int_mxrand</NAME>
extern function int_mxrand;
</VARIABLE>
<VARIABLE>
<NAME>int_mxrealpart</NAME>
extern function int_mxrealpart;
</VARIABLE>
<VARIABLE>
<NAME>int_mxredim</NAME>
extern function int_mxredim;
</VARIABLE>
<VARIABLE>
<NAME>int_mxresize</NAME>
extern function int_mxresize;
</VARIABLE>
<VARIABLE>
<NAME>int_mxround</NAME>
extern function int_mxround;
</VARIABLE>
<VARIABLE>
<NAME>int_mxseti</NAME>
extern function int_mxseti;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsetr</NAME>
extern function int_mxsetr;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsetrc</NAME>
extern function int_mxsetrc;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsign</NAME>
extern function int_mxsign;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsin</NAME>
extern function int_mxsin;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsinh</NAME>
extern function int_mxsinh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsort</NAME>
extern function int_mxsort;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsqrtel</NAME>
extern function int_mxsqrtel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsum</NAME>
extern function int_mxsum;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtan</NAME>
extern function int_mxtan;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtanh</NAME>
extern function int_mxtanh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtestmatrix</NAME>
extern function int_mxtestmatrix;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtril</NAME>
extern function int_mxtril;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtriu</NAME>
extern function int_mxtriu;
</VARIABLE>
<VARIABLE>
<NAME>int_mxzeros</NAME>
extern function int_mxzeros;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiv</NAME>
extern function int_mxdiv; 
</VARIABLE>
<VARIABLE>
<NAME>int_mxbdiv</NAME>
extern function int_mxbdiv; 
</VARIABLE>
<STRUCT>
<NAME>NspTypeCells</NAME>
typedef struct _NspTypeCells { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeCells;
</STRUCT>
<STRUCT>
<NAME>NspCells</NAME>
struct _NspCells {
  /*< private >*/
  NspObject father; 
  NspTypeCells *type; 
  /*< public >*/
  int m,n,mn;
  NspObject **objs;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_cells_id</NAME>
extern int nsp_type_cells_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_cells</NAME>
extern NspTypeCells *nsp_type_cells;
</VARIABLE>
<FUNCTION>
<NAME>new_type_cells</NAME>
<RETURNS>NspTypeCells *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_cells</NAME>
<RETURNS>NspCells *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_object</NAME>
<RETURNS>NspCells *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsCellsObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsCells</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetCellsCopy</NAME>
<RETURNS>NspCells *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetCells</NAME>
<RETURNS>NspCells *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_create</NAME>
<RETURNS>NspCells *</RETURNS>
const char *name, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_clone</NAME>
<RETURNS>NspCells *</RETURNS>
const char *name, NspCells *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_create_from_table</NAME>
<RETURNS>NspCells *</RETURNS>
const char *name,NspObject **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_create_from_array</NAME>
<RETURNS>NspCells *</RETURNS>
const char *name,int n, NspObject **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_copy</NAME>
<RETURNS>NspCells *</RETURNS>
const NspCells *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_resize</NAME>
<RETURNS>int </RETURNS>
NspCells *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspCells *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_destroy</NAME>
<RETURNS>void </RETURNS>
NspCells *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_info</NAME>
<RETURNS>int </RETURNS>
const NspCells *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_print</NAME>
<RETURNS>int </RETURNS>
const NspCells *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_redim</NAME>
<RETURNS>int </RETURNS>
NspCells *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_enlarge</NAME>
<RETURNS>int </RETURNS>
NspCells *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_concat_right</NAME>
<RETURNS>int </RETURNS>
NspCells *A,const NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_add_columns</NAME>
<RETURNS>int </RETURNS>
NspCells *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_concat_down</NAME>
<RETURNS>NspCells *</RETURNS>
const NspCells *A,const NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_add_rows</NAME>
<RETURNS>int </RETURNS>
NspCells *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspCells *A,const NspMatrix *Rows,const NspMatrix *Cols,const NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_set_rows</NAME>
<RETURNS>int </RETURNS>
NspCells *A, NspMatrix *Rows, NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract_elements</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *A, NspMatrix *Elts, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract_columns</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>CellsLoopCol</NAME>
<RETURNS>NspCells *</RETURNS>
char *str, NspCells *Col, NspCells *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract_rows</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_set_element</NAME>
<RETURNS>int </RETURNS>
NspCells *A,int index, NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_unique</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *C, NspObject **Ind, NspMatrix **Occ, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_has</NAME>
<RETURNS>Boolean </RETURNS>
NspCells *C, NspObject *Obj, int *ind
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_map</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *C, NspPList *PL, NspList *args
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_m2ce</NAME>
<RETURNS>NspCells *</RETURNS>
NspMatrix *M, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<MACRO>
<NAME>NULLCELLS</NAME>
#define NULLCELLS (NspCells *) NULL
</MACRO>
<FUNCTION>
<NAME>nsp_cells_strcmp</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspCells *A, NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>CellsCompOp</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspCells *A, NspCells *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>CellsFullComp</NAME>
<RETURNS>int </RETURNS>
NspCells *A, NspCells *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_transpose</NAME>
<RETURNS>NspCells *</RETURNS>
const NspCells *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract_diag</NAME>
<RETURNS>NspCells  *</RETURNS>
NspCells *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_set_diag</NAME>
<RETURNS>int </RETURNS>
NspCells *A, NspCells *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_create_diag</NAME>
<RETURNS>NspCells  *</RETURNS>
NspCells *Diag, int k
</FUNCTION>
<STRUCT>
<NAME>NspObjs3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeObjs3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeObjs3d</NAME>
struct _NspTypeObjs3d {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 53 "./objs3d.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_objs3d</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_objs3d</NAME>
struct _nsp_objs3d {
  nsp_gcscale scale;
  NspMatrix* wrect;
  double rho;
  gboolean top;
  NspMatrix* bounds;
  NspMatrix* arect;
  NspMatrix* frect;
  char* title;
  NspList* children;
  NspMatrix* colormap;
  double alpha;
  double theta;
  gboolean with_box;
  int box_color;
  int box_style;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspObjs3d</NAME>
struct _NspObjs3d {
  /*< private >*/
  NspGraphic father;
  NspTypeObjs3d*type;
  /*< public >*/
  nsp_objs3d *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_objs3d_id</NAME>
extern int nsp_type_objs3d_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_objs3d</NAME>
extern NspTypeObjs3d *nsp_type_objs3d;
</VARIABLE>
<FUNCTION>
<NAME>new_type_objs3d</NAME>
<RETURNS>NspTypeObjs3d *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_objs3d</NAME>
<RETURNS>NspObjs3d *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLOBJS3D</NAME>
#define NULLOBJS3D (NspObjs3d*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_objs3d_create</NAME>
<RETURNS>NspObjs3d *</RETURNS>
const char *name,nsp_gcscale scale,NspMatrix* wrect,double rho,gboolean top,NspMatrix* bounds,NspMatrix* arect,NspMatrix* frect,char* title,NspList* children,NspMatrix* colormap,double alpha,double theta,gboolean with_box,int box_color,int box_style,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_create_default</NAME>
<RETURNS>NspObjs3d *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_copy</NAME>
<RETURNS>NspObjs3d *</RETURNS>
NspObjs3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_destroy</NAME>
<RETURNS>void </RETURNS>
NspObjs3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_info</NAME>
<RETURNS>int </RETURNS>
NspObjs3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_print</NAME>
<RETURNS>int </RETURNS>
NspObjs3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_latex</NAME>
<RETURNS>int </RETURNS>
NspObjs3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_object</NAME>
<RETURNS>NspObjs3d *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsObjs3dObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsObjs3d</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetObjs3dCopy</NAME>
<RETURNS>NspObjs3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetObjs3d</NAME>
<RETURNS>NspObjs3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_create_partial</NAME>
<RETURNS>int </RETURNS>
NspObjs3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspObjs3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_copy_partial</NAME>
<RETURNS>NspObjs3d *</RETURNS>
NspObjs3d *H,NspObjs3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_full_copy_partial</NAME>
<RETURNS>NspObjs3d *</RETURNS>
NspObjs3d *H,NspObjs3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_full_copy</NAME>
<RETURNS>NspObjs3d *</RETURNS>
NspObjs3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_check_values</NAME>
<RETURNS>int </RETURNS>
NspObjs3d *H
</FUNCTION>
<FUNCTION>
<NAME>int_objs3d_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_xdr_load_partial</NAME>
<RETURNS>NspObjs3d *</RETURNS>
XDR *xdrs, NspObjs3d *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspObjs3d *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_for_objs3d</NAME>
<RETURNS>NspObjs3d *</RETURNS>
BCG *Xgc,const double *wrect
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_insert_child</NAME>
<RETURNS>int </RETURNS>
NspObjs3d *A, NspGraphic *G
</FUNCTION>
<FUNCTION>
<NAME>nsp_objs3d_invalidate</NAME>
<RETURNS>void </RETURNS>
NspGraphic *G
</FUNCTION>
<FUNCTION>
<NAME>gr_compute_ticks</NAME>
<RETURNS>int </RETURNS>
double *xminv, double *xmaxv, double *grads, int *ngrads
</FUNCTION>
<FUNCTION>
<NAME>drawsegments3D</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double *x,double *y,double *z, int n, int *style, int iflag
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_change3d_orientation</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double theta,double alpha,const int *pt
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_for_current_objs3d</NAME>
<RETURNS>NspObjs3d *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_for_objs3d_in_figure</NAME>
<RETURNS>NspObjs3d *</RETURNS>
NspFigure *F,const double *wrect
</FUNCTION>
<STRUCT>
<NAME>NspTypeAstNode</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeAstNode</NAME>
struct _NspTypeAstNode {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
};

</STRUCT>
<STRUCT>
<NAME>nsp_astnode</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_astnode</NAME>
struct _nsp_astnode {
  int op;
  int arity; /* arity for operators or tag for names etc.. */
  void *obj; /* used to store a string pointer, 
	      * an object pointer a parse_double
	      * an int. Maybe an union could help.
	      */
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspAstNode</NAME>
struct _NspAstNode {
  /*< private >*/
  NspObject father;
  NspTypeAstNode*type;
  /*< public >*/
  nsp_astnode *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_astnode_id</NAME>
extern int nsp_type_astnode_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_astnode</NAME>
extern NspTypeAstNode *nsp_type_astnode;
</VARIABLE>
<FUNCTION>
<NAME>new_type_astnode</NAME>
<RETURNS>NspTypeAstNode *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_astnode</NAME>
<RETURNS>NspAstNode *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLASTNODE</NAME>
#define NULLASTNODE (NspAstNode*) 0
</MACRO>
<FUNCTION>
<NAME>astnode_create</NAME>
<RETURNS>NspAstNode *</RETURNS>
char *name,int op,int arity,void *data,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_astnode_copy</NAME>
<RETURNS>NspAstNode *</RETURNS>
NspAstNode *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_astnode_destroy</NAME>
<RETURNS>void </RETURNS>
NspAstNode *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_astnode_info</NAME>
<RETURNS>int </RETURNS>
NspAstNode *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_astnode_print</NAME>
<RETURNS>int </RETURNS>
NspAstNode *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_astnode_object</NAME>
<RETURNS>NspAstNode *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsAstNodeObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsAstNode</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetAstNodeCopy</NAME>
<RETURNS>NspAstNode *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetAstNode</NAME>
<RETURNS>NspAstNode *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>int_astnode_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<MACRO>
<NAME>NSP_INC_NspAstNode</NAME>
#define NSP_INC_NspAstNode
</MACRO>
<STRUCT>
<NAME>NspAstNode</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspBHash</NAME>
#define NSP_INC_NspBHash
</MACRO>
<STRUCT>
<NAME>NspBHash</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_Boolean</NAME>
#define NSP_INC_Boolean
</MACRO>
<TYPEDEF>
<NAME>Boolean</NAME>
typedef int Boolean;
</TYPEDEF>
<MACRO>
<NAME>NSP_INC_NspBMatrix</NAME>
#define NSP_INC_NspBMatrix
</MACRO>
<STRUCT>
<NAME>NspBMatrix</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspCells</NAME>
#define NSP_INC_NspCells
</MACRO>
<STRUCT>
<NAME>NspCells</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspCholmod</NAME>
#define NSP_INC_NspCholmod
</MACRO>
<STRUCT>
<NAME>NspCholmod</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspFile</NAME>
#define NSP_INC_NspFile
</MACRO>
<STRUCT>
<NAME>NspFile</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspFunction</NAME>
#define NSP_INC_NspFunction
</MACRO>
<STRUCT>
<NAME>NspFunction</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspHash</NAME>
#define NSP_INC_NspHash
</MACRO>
<STRUCT>
<NAME>NspHash</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspHobj</NAME>
#define NSP_INC_NspHobj
</MACRO>
<STRUCT>
<NAME>NspHobj</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspIMatrix</NAME>
#define NSP_INC_NspIMatrix
</MACRO>
<STRUCT>
<NAME>NspIMatrix</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspIVect</NAME>
#define NSP_INC_NspIVect
</MACRO>
<TYPEDEF>
<NAME>NspIVect</NAME>
typedef struct _NspIvect NspIVect;
</TYPEDEF>
<MACRO>
<NAME>NSP_INC_NspList</NAME>
#define NSP_INC_NspList
</MACRO>
<STRUCT>
<NAME>NspList</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspLmo</NAME>
#define NSP_INC_NspLmo
</MACRO>
<STRUCT>
<NAME>NspLmo</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_doubleC</NAME>
#define NSP_INC_doubleC
</MACRO>
<STRUCT>
<NAME>doubleC</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspMatrix</NAME>
#define NSP_INC_NspMatrix
</MACRO>
<STRUCT>
<NAME>NspMatrix</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspMe</NAME>
#define NSP_INC_NspMe
</MACRO>
<STRUCT>
<NAME>NspMe</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspMod</NAME>
#define NSP_INC_NspMod
</MACRO>
<STRUCT>
<NAME>NspMod</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspModule</NAME>
#define NSP_INC_NspModule
</MACRO>
<STRUCT>
<NAME>NspModule</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspModuleElt</NAME>
#define NSP_INC_NspModuleElt
</MACRO>
<TYPEDEF>
<NAME>NspModuleElt</NAME>
typedef struct _NspModulelt NspModuleElt;
</TYPEDEF>
<MACRO>
<NAME>NSP_INC_NspMaxpMatrix</NAME>
#define NSP_INC_NspMaxpMatrix
</MACRO>
<TYPEDEF>
<NAME>NspMaxpMatrix</NAME>
typedef struct _NspMpmatrix NspMaxpMatrix;
</TYPEDEF>
<MACRO>
<NAME>NSP_INC_NspNone</NAME>
#define NSP_INC_NspNone
</MACRO>
<STRUCT>
<NAME>NspNone</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspObject</NAME>
#define NSP_INC_NspObject
</MACRO>
<STRUCT>
<NAME>NspObject</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspPList</NAME>
#define NSP_INC_NspPList
</MACRO>
<TYPEDEF>
<NAME>NspPList</NAME>
typedef struct _NspPlist NspPList;
</TYPEDEF>
<MACRO>
<NAME>NSP_INC_NspPMatrix</NAME>
#define NSP_INC_NspPMatrix
</MACRO>
<TYPEDEF>
<NAME>NspPMatrix</NAME>
typedef struct _NspPmatrix NspPMatrix;
</TYPEDEF>
<MACRO>
<NAME>NSP_INC_NspScalExp</NAME>
#define NSP_INC_NspScalExp
</MACRO>
<STRUCT>
<NAME>NspScalExp</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspSerial</NAME>
#define NSP_INC_NspSerial
</MACRO>
<STRUCT>
<NAME>NspSerial</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspSMatrix</NAME>
#define NSP_INC_NspSMatrix
</MACRO>
<TYPEDEF>
<NAME>NspSMatrix</NAME>
typedef struct _NspSmatrix NspSMatrix;
</TYPEDEF>
<MACRO>
<NAME>NSP_INC_NspSMio</NAME>
#define NSP_INC_NspSMio
</MACRO>
<STRUCT>
<NAME>NspSMio</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspSpColMatrix</NAME>
#define NSP_INC_NspSpColMatrix
</MACRO>
<TYPEDEF>
<NAME>NspSpColMatrix</NAME>
typedef struct _NspSpColmatrix NspSpColMatrix;
</TYPEDEF>
<MACRO>
<NAME>NSP_INC_NspSpRowMatrix</NAME>
#define NSP_INC_NspSpRowMatrix
</MACRO>
<TYPEDEF>
<NAME>NspSpRowMatrix</NAME>
typedef struct _NspSpRowmatrix NspSpRowMatrix;
</TYPEDEF>
<MACRO>
<NAME>NSP_INC_NspType</NAME>
#define NSP_INC_NspType
</MACRO>
<STRUCT>
<NAME>NspType</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_NspUmfpack</NAME>
#define NSP_INC_NspUmfpack
</MACRO>
<STRUCT>
<NAME>NspUmfpack</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_INC_Stack</NAME>
#define NSP_INC_Stack
</MACRO>
<STRUCT>
<NAME>Stack</NAME>
</STRUCT>
<STRUCT>
<NAME>Stack_ref</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeScalExp</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeScalExp</NAME>
struct _NspTypeScalExp {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
};

</STRUCT>
<STRUCT>
<NAME>NspScalExp</NAME>
struct _NspScalExp {
  /*< private >*/
  NspObject father;
  NspTypeScalExp*type;
  /*< public >*/
  PList code;
  NspSMatrix *expr;
  NspSMatrix *vars;
  NspSMatrix *extra_vars;
  NspMatrix *bcode;
  NspMatrix *values;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_scalexp_id</NAME>
extern int nsp_type_scalexp_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_scalexp</NAME>
extern NspTypeScalExp *nsp_type_scalexp;
</VARIABLE>
<FUNCTION>
<NAME>new_type_scalexp</NAME>
<RETURNS>NspTypeScalExp *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_scalexp</NAME>
<RETURNS>NspScalExp *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSCALEXP</NAME>
#define NULLSCALEXP (NspScalExp*) 0
</MACRO>
<FUNCTION>
<NAME>scalexp_create</NAME>
<RETURNS>NspScalExp *</RETURNS>
char *name,NspSMatrix *expr,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalexp_copy</NAME>
<RETURNS>NspScalExp *</RETURNS>
NspScalExp *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalexp_destroy</NAME>
<RETURNS>void </RETURNS>
NspScalExp *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalexp_info</NAME>
<RETURNS>int </RETURNS>
NspScalExp *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalexp_print</NAME>
<RETURNS>int </RETURNS>
NspScalExp *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalexp_object</NAME>
<RETURNS>NspScalExp *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsScalExpObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsScalExp</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetScalExpCopy</NAME>
<RETURNS>NspScalExp *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetScalExp</NAME>
<RETURNS>NspScalExp *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>int_scalexp_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<ENUM>
<NAME>f_enum</NAME>
typedef enum { 
  f_sin, f_cos, f_tan, f_exp, f_log, f_sinh, f_cosh, f_tanh,
  f_int, f_round, f_ceil, f_floor, f_sign, f_abs, f_max, f_min,
  f_asin, f_acos, f_atan, f_asinh, f_acosh, f_atanh,
  f_atan2, f_log10, f_gamma
} f_enum;
</ENUM>
<STRUCT>
<NAME>expr_func</NAME>
</STRUCT>
<STRUCT>
<NAME>expr_func</NAME>
struct _expr_func {
  const char *name;
  f_enum id;
  double (*f1)(double);
  double (*f2)(double,double);
  int logical;
};

</STRUCT>
<STRUCT>
<NAME>NspTypeBMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeBMatrix</NAME>
struct _NspTypeBMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};

</STRUCT>
<STRUCT>
<NAME>NspBMatrix</NAME>
struct _NspBMatrix {
  /*< private >*/
  NspObject father; 
  NspTypeBMatrix *type; 
  /*< public >*/
  int m,n,mn;
  Boolean *B;	
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_bmatrix_id</NAME>
extern int nsp_type_bmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_bmatrix</NAME>
extern NspTypeBMatrix *nsp_type_bmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_bmatrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_bmatrix</NAME>
<RETURNS>NspTypeBMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_bmatrix_init</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_bmatrix_set</NAME>
<RETURNS>void </RETURNS>
NspBMatrix *bmatrix, NspTypeBMatrix *type
</FUNCTION>
<FUNCTION>
<NAME>new_bmatrix</NAME>
<RETURNS>NspBMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLBMAT</NAME>
#define NULLBMAT (NspBMatrix*) 0
</MACRO>
<FUNCTION>
<NAME>BMatObj</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsBMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsBMat</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetBMatCopy</NAME>
<RETURNS>NspBMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetBMat</NAME>
<RETURNS>NspBMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>BoolScalar</NAME>
<RETURNS>int </RETURNS>
NspObject *O, Boolean *val
</FUNCTION>
<FUNCTION>
<NAME>GetScalarBool</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i, int *val
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_create</NAME>
<RETURNS>NspBMatrix *</RETURNS>
const char *name, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_clone</NAME>
<RETURNS>NspBMatrix *</RETURNS>
const char *name, NspBMatrix *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_copy</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_resize</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspBMatrix *BMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_info</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *BMat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_print</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *BMat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_latex_print</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *BMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_latex_tab_print</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *BMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_redim</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_concat_right</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_add_columns</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_concat_down</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_concat_diag</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_add_rows</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_set_rows</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, NspMatrix *Rows, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_elements</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_columns</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_rows</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>BMatLoopCol</NAME>
<RETURNS>NspBMatrix *</RETURNS>
char *str, NspBMatrix *Col, NspBMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_diag</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_set_diag</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, NspBMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_create_diag</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_transpose</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_bmatrix</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_to_matrix</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspBMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>MatIsTrue</NAME>
<RETURNS>int </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_and</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_scalar_and</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_or</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_scalar_or</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_not</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>BMatIsTrue</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_count_true</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_find</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_find_2</NAME>
<RETURNS>int </RETURNS>
const NspBMatrix *A, int lhs, NspObject **Res1, NspObject **Res2, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_compare</NAME>
<RETURNS>NspBMatrix *</RETURNS>
const NspBMatrix *A, const NspBMatrix *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_full_compare</NAME>
<RETURNS>int </RETURNS>
const NspBMatrix *A,const  NspBMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_comp</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B,const char *op
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_comp_real</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B,const char *op
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_isinf</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_isnan</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_finite</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<STRUCT>
<NAME>nsp_sparse_triplet</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_sparse_triplet</NAME>
struct _nsp_sparse_triplet { /* used in mexlib */
  int *Jc; /* Ap;*/ /* m+ 1 */
  int *Ir; /* Ai;*/ /* Aisize */
  double *Pr; /* Ax;*/ /* Aisize */
  double *Pi; /* Ax;*/ /* Aisize */
  int m,n,Aisize;
};

</STRUCT>
<STRUCT>
<NAME>NspSegments</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSegments</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSegments</NAME>
struct _NspTypeSegments {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./segments.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_segments</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_segments</NAME>
struct _nsp_segments {
  NspMatrix* x;
  NspMatrix* y;
  NspMatrix* color;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspSegments</NAME>
struct _NspSegments {
  /*< private >*/
  NspGraphic father;
  NspTypeSegments*type;
  /*< public >*/
  nsp_segments *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_segments_id</NAME>
extern int nsp_type_segments_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_segments</NAME>
extern NspTypeSegments *nsp_type_segments;
</VARIABLE>
<FUNCTION>
<NAME>new_type_segments</NAME>
<RETURNS>NspTypeSegments *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_segments</NAME>
<RETURNS>NspSegments *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSEGMENTS</NAME>
#define NULLSEGMENTS (NspSegments*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_segments_create</NAME>
<RETURNS>NspSegments *</RETURNS>
const char *name,NspMatrix* x,NspMatrix* y,NspMatrix* color,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_create_default</NAME>
<RETURNS>NspSegments *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_copy</NAME>
<RETURNS>NspSegments *</RETURNS>
NspSegments *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_destroy</NAME>
<RETURNS>void </RETURNS>
NspSegments *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_info</NAME>
<RETURNS>int </RETURNS>
NspSegments *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_print</NAME>
<RETURNS>int </RETURNS>
NspSegments *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_latex</NAME>
<RETURNS>int </RETURNS>
NspSegments *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_object</NAME>
<RETURNS>NspSegments *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSegmentsObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSegments</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSegmentsCopy</NAME>
<RETURNS>NspSegments *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSegments</NAME>
<RETURNS>NspSegments *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_create_partial</NAME>
<RETURNS>int </RETURNS>
NspSegments *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspSegments *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_copy_partial</NAME>
<RETURNS>NspSegments *</RETURNS>
NspSegments *H,NspSegments *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_full_copy_partial</NAME>
<RETURNS>NspSegments *</RETURNS>
NspSegments *H,NspSegments *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_full_copy</NAME>
<RETURNS>NspSegments *</RETURNS>
NspSegments *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_check_values</NAME>
<RETURNS>int </RETURNS>
NspSegments *H
</FUNCTION>
<FUNCTION>
<NAME>int_segments_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_xdr_load_partial</NAME>
<RETURNS>NspSegments *</RETURNS>
XDR *xdrs, NspSegments *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_segments_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspSegments *M
</FUNCTION>
<STRUCT>
<NAME>NspGMatrix1</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGMatrix1</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGMatrix1</NAME>
struct _NspTypeGMatrix1 {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 49 "./gmatrix1.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_gmatrix1</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_gmatrix1</NAME>
struct _nsp_gmatrix1 {
  NspMatrix* data;
  gboolean remap;
  gboolean shade;
  NspMatrix* colminmax;
  NspMatrix* zminmax;
  NspMatrix* colout;
  NspMatrix* x;
  NspMatrix* y;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspGMatrix1</NAME>
struct _NspGMatrix1 {
  /*< private >*/
  NspGraphic father;
  NspTypeGMatrix1*type;
  /*< public >*/
  nsp_gmatrix1 *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_gmatrix1_id</NAME>
extern int nsp_type_gmatrix1_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_gmatrix1</NAME>
extern NspTypeGMatrix1 *nsp_type_gmatrix1;
</VARIABLE>
<FUNCTION>
<NAME>new_type_gmatrix1</NAME>
<RETURNS>NspTypeGMatrix1 *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_gmatrix1</NAME>
<RETURNS>NspGMatrix1 *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLGMATRIX1</NAME>
#define NULLGMATRIX1 (NspGMatrix1*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_gmatrix1_create</NAME>
<RETURNS>NspGMatrix1 *</RETURNS>
const char *name,NspMatrix* data,gboolean remap,gboolean shade,NspMatrix* colminmax,NspMatrix* zminmax,NspMatrix* colout,NspMatrix* x,NspMatrix* y,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_create_default</NAME>
<RETURNS>NspGMatrix1 *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_copy</NAME>
<RETURNS>NspGMatrix1 *</RETURNS>
NspGMatrix1 *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_destroy</NAME>
<RETURNS>void </RETURNS>
NspGMatrix1 *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_info</NAME>
<RETURNS>int </RETURNS>
NspGMatrix1 *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_print</NAME>
<RETURNS>int </RETURNS>
NspGMatrix1 *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_latex</NAME>
<RETURNS>int </RETURNS>
NspGMatrix1 *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_object</NAME>
<RETURNS>NspGMatrix1 *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGMatrix1Obj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsGMatrix1</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetGMatrix1Copy</NAME>
<RETURNS>NspGMatrix1 *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGMatrix1</NAME>
<RETURNS>NspGMatrix1 *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_create_partial</NAME>
<RETURNS>int </RETURNS>
NspGMatrix1 *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspGMatrix1 *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_copy_partial</NAME>
<RETURNS>NspGMatrix1 *</RETURNS>
NspGMatrix1 *H,NspGMatrix1 *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_full_copy_partial</NAME>
<RETURNS>NspGMatrix1 *</RETURNS>
NspGMatrix1 *H,NspGMatrix1 *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_full_copy</NAME>
<RETURNS>NspGMatrix1 *</RETURNS>
NspGMatrix1 *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_check_values</NAME>
<RETURNS>int </RETURNS>
NspGMatrix1 *H
</FUNCTION>
<FUNCTION>
<NAME>int_gmatrix1_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_xdr_load_partial</NAME>
<RETURNS>NspGMatrix1 *</RETURNS>
XDR *xdrs, NspGMatrix1 *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix1_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspGMatrix1 *M
</FUNCTION>
<FUNCTION>
<NAME>PermutOfSort</NAME>
<RETURNS>void </RETURNS>
const int *tab, int *perm
</FUNCTION>
<FUNCTION>
<NAME>PaintTriangle</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,const double *sx,const double *sy,const  double *fxy,const int *zxy, const double *zlevel,const int *fill
</FUNCTION>
<USER_FUNCTION>
<NAME>IOVFun</NAME>
<RETURNS>int </RETURNS>
const char *fmt, va_list ap
</USER_FUNCTION>
<FUNCTION>
<NAME>SetScilabIO</NAME>
<RETURNS>IOVFun </RETURNS>
IOVFun F
</FUNCTION>
<FUNCTION>
<NAME>Sciprintf1</NAME>
<RETURNS>int </RETURNS>
int indent,const char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>Sciprintf</NAME>
<RETURNS>int </RETURNS>
const char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>do_printf_stdout</NAME>
<RETURNS>int </RETURNS>
const FILE *ignore,const char *fmt, ...
</FUNCTION>
<FUNCTION>
<NAME>Sciprint2string_reset</NAME>
<RETURNS>NspObject *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>Sciprint2string</NAME>
<RETURNS>int  </RETURNS>
const char *fmt, va_list ap
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_set_diary</NAME>
<RETURNS>FILE *</RETURNS>
FILE *f,int diary_echo
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_diary_on</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_diary</NAME>
<RETURNS>int </RETURNS>
const char *fmt, va_list ap
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_diary_only</NAME>
<RETURNS>int </RETURNS>
const char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_file</NAME>
<RETURNS>FILE *</RETURNS>
FILE *f
</FUNCTION>
<FUNCTION>
<NAME>Sciprint2file</NAME>
<RETURNS>int </RETURNS>
const char *fmt, va_list ap
</FUNCTION>
<TYPEDEF>
<NAME>IOFun</NAME>
typedef iofun *IOFun;
</TYPEDEF>
<USER_FUNCTION>
<NAME>IOFun1</NAME>
<RETURNS>int </RETURNS>
int indent,const char *fmt,...
</USER_FUNCTION>
<VARIABLE>
<NAME>Scierror</NAME>
extern iofun Scierror ;
</VARIABLE>
<FUNCTION>
<NAME>ParseError</NAME>
<RETURNS>int  </RETURNS>
char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>scidebug</NAME>
<RETURNS>int </RETURNS>
int indent,char *fmt,...
</FUNCTION>
<USER_FUNCTION>
<NAME>IOFun2</NAME>
<RETURNS>int </RETURNS>
FILE *f,const char *fmt,...
</USER_FUNCTION>
<VARIABLE>
<NAME>Scifprintf</NAME>
extern IOFun2 Scifprintf ;
</VARIABLE>
<USER_FUNCTION>
<NAME>SciGetC</NAME>
<RETURNS>int </RETURNS>
void
</USER_FUNCTION>
<VARIABLE>
<NAME>Scigetchar</NAME>
extern SciGetC Scigetchar ;
</VARIABLE>
<FUNCTION>
<NAME>nsp_set_nsp_getchar</NAME>
<RETURNS>SciGetC </RETURNS>
SciGetC F
</FUNCTION>
<FUNCTION>
<NAME>nsp_read_clean_after_ctrc</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_readline_clear_line</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>set_echo_mode</NAME>
<RETURNS>void </RETURNS>
int mode
</FUNCTION>
<FUNCTION>
<NAME>get_echo_mode</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>set_is_reading</NAME>
<RETURNS>void </RETURNS>
int mode
</FUNCTION>
<FUNCTION>
<NAME>get_is_reading</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_in_text_view</NAME>
<RETURNS>void </RETURNS>
int value
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_in_text_view</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_error_message_show</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_error_message_to_lasterror</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_error_message_clear</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_echo_input_line</NAME>
<RETURNS>int </RETURNS>
int val
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_echo_input_line</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>nsp_error_vprintf</NAME>
extern IOVFun nsp_error_vprintf;
</VARIABLE>
<FUNCTION>
<NAME>sci_get_screen_size</NAME>
<RETURNS>void </RETURNS>
int *rows, int *cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_intialize_reader</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_from_texmacs</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>STRING_ONLY</NAME>
#define STRING_ONLY 
</MACRO>
<MACRO>
<NAME>ELT_TYPE</NAME>
#define ELT_TYPE nsp_string
</MACRO>
<VARIABLE>
<NAME>int_sprowmatrix_minus</NAME>
extern function int_sprowmatrix_minus;
</VARIABLE>
<STRUCT>
<NAME>NspTypeType</NAME>
typedef struct _NspTypeType { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeType;
</STRUCT>
<STRUCT>
<NAME>NspType</NAME>
struct _NspType {
  /*< private >*/
  NspObject father; 
  NspTypeType *type; 
  /*< public >*/
  NspTypeBase *nsp_type;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_type_id</NAME>
extern int nsp_type_type_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_type</NAME>
extern NspTypeType *nsp_type_type;
</VARIABLE>
<FUNCTION>
<NAME>new_type_type</NAME>
<RETURNS>NspTypeType *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_type</NAME>
<RETURNS>NspType *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLTYPE</NAME>
#define NULLTYPE (NspType*) 0
</MACRO>
<FUNCTION>
<NAME>type_create</NAME>
<RETURNS>NspType *</RETURNS>
char *name,NspTypeBase *type,NspTypeBase *derived_type
</FUNCTION>
<FUNCTION>
<NAME>type_copy</NAME>
<RETURNS>NspType *</RETURNS>
NspType *H
</FUNCTION>
<FUNCTION>
<NAME>type_destroy</NAME>
<RETURNS>void </RETURNS>
NspType *H
</FUNCTION>
<FUNCTION>
<NAME>type_info</NAME>
<RETURNS>int </RETURNS>
NspType *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>type_print</NAME>
<RETURNS>int </RETURNS>
NspType *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>type_object</NAME>
<RETURNS>NspType *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsTypeObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsType</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetTypeCopy</NAME>
<RETURNS>NspType *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetType</NAME>
<RETURNS>NspType *</RETURNS>
Stack stack, int i
</FUNCTION>
<VARIABLE>
<NAME>nsp_types_hash_table</NAME>
extern NspHash *nsp_types_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_gtk_hash_table</NAME>
extern NspHash *nsp_gtk_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_atk_hash_table</NAME>
extern NspHash *nsp_atk_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_gdk_hash_table</NAME>
extern NspHash *nsp_gdk_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_pango_hash_table</NAME>
extern NspHash *nsp_pango_hash_table; 
</VARIABLE>
<FUNCTION>
<NAME>nsp_get_type_from_name</NAME>
<RETURNS>void *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>type_get_name</NAME>
<RETURNS>char *</RETURNS>
void *type
</FUNCTION>
<STRUCT>
<NAME>NspQcurve</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeQcurve</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeQcurve</NAME>
struct _NspTypeQcurve {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./qcurve.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_qcurve</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_qcurve</NAME>
struct _nsp_qcurve {
  int mark;
  int width;
  int style;
  int color;
  int mode;
  NspMatrix* Pts;
  char* legend;
  int start;
  int last;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspQcurve</NAME>
struct _NspQcurve {
  /*< private >*/
  NspGraphic father;
  NspTypeQcurve*type;
  /*< public >*/
  nsp_qcurve *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_qcurve_id</NAME>
extern int nsp_type_qcurve_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_qcurve</NAME>
extern NspTypeQcurve *nsp_type_qcurve;
</VARIABLE>
<FUNCTION>
<NAME>new_type_qcurve</NAME>
<RETURNS>NspTypeQcurve *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_qcurve</NAME>
<RETURNS>NspQcurve *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLQCURVE</NAME>
#define NULLQCURVE (NspQcurve*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_qcurve_create</NAME>
<RETURNS>NspQcurve *</RETURNS>
const char *name,int mark,int width,int style,int color,int mode,NspMatrix* Pts,char* legend,int start,int last,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_create_default</NAME>
<RETURNS>NspQcurve *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_copy</NAME>
<RETURNS>NspQcurve *</RETURNS>
NspQcurve *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_destroy</NAME>
<RETURNS>void </RETURNS>
NspQcurve *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_info</NAME>
<RETURNS>int </RETURNS>
NspQcurve *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_print</NAME>
<RETURNS>int </RETURNS>
NspQcurve *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_latex</NAME>
<RETURNS>int </RETURNS>
NspQcurve *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_object</NAME>
<RETURNS>NspQcurve *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsQcurveObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsQcurve</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetQcurveCopy</NAME>
<RETURNS>NspQcurve *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetQcurve</NAME>
<RETURNS>NspQcurve *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_create_partial</NAME>
<RETURNS>int </RETURNS>
NspQcurve *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspQcurve *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_copy_partial</NAME>
<RETURNS>NspQcurve *</RETURNS>
NspQcurve *H,NspQcurve *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_full_copy_partial</NAME>
<RETURNS>NspQcurve *</RETURNS>
NspQcurve *H,NspQcurve *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_full_copy</NAME>
<RETURNS>NspQcurve *</RETURNS>
NspQcurve *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_check_values</NAME>
<RETURNS>int </RETURNS>
NspQcurve *H
</FUNCTION>
<FUNCTION>
<NAME>int_qcurve_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_xdr_load_partial</NAME>
<RETURNS>NspQcurve *</RETURNS>
XDR *xdrs, NspQcurve *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_qcurve_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspQcurve *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_oscillo_obj</NAME>
<RETURNS>NspAxes *</RETURNS>
int win,int ncurves,int style[],int bufsize,int yfree,double ymin,double ymax,NspList **Lc
</FUNCTION>
<FUNCTION>
<NAME>nsp_oscillo_add_point</NAME>
<RETURNS>void  </RETURNS>
NspList *L,double t,double *y, int n
</FUNCTION>
<STRUCT>
<NAME>NspPolyhedron</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePolyhedron</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePolyhedron</NAME>
struct _NspTypePolyhedron {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 43 "./polyhedron.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_polyhedron</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_polyhedron</NAME>
struct _nsp_polyhedron {
  NspMatrix* Mcoord;
  void* Mcoord_l;
  NspMatrix* Mface;
  NspMatrix* Mcolor;
  NspMatrix* Mback_color;
  gboolean mesh;
  int* pos;  int pos_length;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspPolyhedron</NAME>
struct _NspPolyhedron {
  /*< private >*/
  NspGraphic father;
  NspTypePolyhedron*type;
  /*< public >*/
  nsp_polyhedron *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_polyhedron_id</NAME>
extern int nsp_type_polyhedron_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_polyhedron</NAME>
extern NspTypePolyhedron *nsp_type_polyhedron;
</VARIABLE>
<FUNCTION>
<NAME>new_type_polyhedron</NAME>
<RETURNS>NspTypePolyhedron *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_polyhedron</NAME>
<RETURNS>NspPolyhedron *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLPOLYHEDRON</NAME>
#define NULLPOLYHEDRON (NspPolyhedron*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_polyhedron_create</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
const char *name,NspMatrix* Mcoord,void* Mcoord_l,NspMatrix* Mface,NspMatrix* Mcolor,NspMatrix* Mback_color,gboolean mesh,int* pos, int pos_length,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_create_default</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_copy</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
NspPolyhedron *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_destroy</NAME>
<RETURNS>void </RETURNS>
NspPolyhedron *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_info</NAME>
<RETURNS>int </RETURNS>
NspPolyhedron *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_print</NAME>
<RETURNS>int </RETURNS>
NspPolyhedron *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_latex</NAME>
<RETURNS>int </RETURNS>
NspPolyhedron *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_object</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsPolyhedronObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsPolyhedron</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetPolyhedronCopy</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetPolyhedron</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_create_partial</NAME>
<RETURNS>int </RETURNS>
NspPolyhedron *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspPolyhedron *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_copy_partial</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
NspPolyhedron *H,NspPolyhedron *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_full_copy_partial</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
NspPolyhedron *H,NspPolyhedron *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_full_copy</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
NspPolyhedron *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_check_values</NAME>
<RETURNS>int </RETURNS>
NspPolyhedron *H
</FUNCTION>
<FUNCTION>
<NAME>int_polyhedron_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_xdr_load_partial</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
XDR *xdrs, NspPolyhedron *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspPolyhedron *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_create_from_triplet</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
char *name,double *x,double *y,double *z,int m,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyhedron_create_from_facets</NAME>
<RETURNS>NspPolyhedron *</RETURNS>
char *name,double *xx,double *yy,double *zz,int m,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_to_coords</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name,NspMatrix *C,double *x,double *y,double *z,int m,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_surf_to_faces</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name,NspMatrix *F,double *x,int xmn,double *y,int ymn
</FUNCTION>
<FUNCTION>
<NAME>nsp_facets_to_faces</NAME>
<RETURNS>int </RETURNS>
double *x,double *y,double *z,int *colors,int ncol, int m,int n,NspMatrix **Cr,NspMatrix **Fr,NspMatrix **Colr
</FUNCTION>
<FUNCTION>
<NAME>nsp_obj3d_orientation</NAME>
<RETURNS>int </RETURNS>
int x[], int y[], int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_abs_c</NAME>
<RETURNS>double </RETURNS>
const  doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_arg_c</NAME>
<RETURNS>double </RETURNS>
 const doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_polar_c</NAME>
<RETURNS>void </RETURNS>
 double r,double t,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_conj_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_norm_c</NAME>
<RETURNS>double </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_cos_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_cosh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_exp_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_log_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_di</NAME>
<RETURNS>double </RETURNS>
double x, int p
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_ii</NAME>
<RETURNS>int </RETURNS>
int p, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_cc</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,const doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_cd</NAME>
<RETURNS>void </RETURNS>
 const doubleC *x, double y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_cd_or_ci</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x, double y, doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_dc</NAME>
<RETURNS>void </RETURNS>
 double x, const doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_ci</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x, int p,doubleC *y
</FUNCTION>
<FUNCTION>
<NAME>nsp_sin_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_sinh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_div_cc</NAME>
<RETURNS>void </RETURNS>
 const doubleC *x,const doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_div_dc</NAME>
<RETURNS>void </RETURNS>
 double x,const doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqrt_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_prod_c</NAME>
<RETURNS>void </RETURNS>
 doubleC *x,const doubleC *y
</FUNCTION>
<FUNCTION>
<NAME>nsp_isnan_c</NAME>
<RETURNS>double </RETURNS>
const  doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_isinf_c</NAME>
<RETURNS>double </RETURNS>
const  doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_finite_c</NAME>
<RETURNS>double </RETURNS>
 const doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_acos_c</NAME>
<RETURNS>void </RETURNS>
 const doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_acosh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_asin_c</NAME>
<RETURNS>void </RETURNS>
 const doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_asinh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_atan_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_atanh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_ceil_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_aint_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_floor_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_log10_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_round_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_signum_c</NAME>
<RETURNS>void </RETURNS>
 const doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_tan_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_tanh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<STRUCT>
<NAME>gr_lock</NAME>
</STRUCT>
<STRUCT>
<NAME>gr_lock</NAME>
struct _gr_lock {
  int n_ports ;
  int fixed ;   /* flag: if fixed == TRUE the number of ports cannot be changed 
		 * after creation
		 */
  gr_port *ports; 
  double pt[2]; /* lock position */
};

</STRUCT>
<STRUCT>
<NAME>NspConnector</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeConnector</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeConnector</NAME>
struct _NspTypeConnector {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 72 "./connector.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_connector</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_connector</NAME>
struct _nsp_connector {
  void* object_sid;
  double r[4];
  int color;
  int thickness;
  int background;
  gr_lock lock;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspConnector</NAME>
struct _NspConnector {
  /*< private >*/
  NspGraphic father;
  NspTypeConnector*type;
  /*< public >*/
  nsp_connector *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_connector_id</NAME>
extern int nsp_type_connector_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_connector</NAME>
extern NspTypeConnector *nsp_type_connector;
</VARIABLE>
<FUNCTION>
<NAME>new_type_connector</NAME>
<RETURNS>NspTypeConnector *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_connector</NAME>
<RETURNS>NspConnector *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCONNECTOR</NAME>
#define NULLCONNECTOR (NspConnector*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_connector_create</NAME>
<RETURNS>NspConnector *</RETURNS>
const char *name,void* object_sid,double* r,int color,int thickness,int background,gr_lock lock,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_create_default</NAME>
<RETURNS>NspConnector *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_copy</NAME>
<RETURNS>NspConnector *</RETURNS>
NspConnector *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_destroy</NAME>
<RETURNS>void </RETURNS>
NspConnector *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_info</NAME>
<RETURNS>int </RETURNS>
NspConnector *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_print</NAME>
<RETURNS>int </RETURNS>
NspConnector *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_latex</NAME>
<RETURNS>int </RETURNS>
NspConnector *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_object</NAME>
<RETURNS>NspConnector *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsConnectorObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsConnector</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetConnectorCopy</NAME>
<RETURNS>NspConnector *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetConnector</NAME>
<RETURNS>NspConnector *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_create_partial</NAME>
<RETURNS>int </RETURNS>
NspConnector *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspConnector *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_copy_partial</NAME>
<RETURNS>NspConnector *</RETURNS>
NspConnector *H,NspConnector *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_full_copy_partial</NAME>
<RETURNS>NspConnector *</RETURNS>
NspConnector *H,NspConnector *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_full_copy</NAME>
<RETURNS>NspConnector *</RETURNS>
NspConnector *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_check_values</NAME>
<RETURNS>int </RETURNS>
NspConnector *H
</FUNCTION>
<FUNCTION>
<NAME>int_connector_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_xdr_load_partial</NAME>
<RETURNS>NspConnector *</RETURNS>
XDR *xdrs, NspConnector *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_connector_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspConnector *M
</FUNCTION>
<STRUCT>
<NAME>NspGrRect</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGrRect</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGrRect</NAME>
struct _NspTypeGrRect {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 49 "./grrect.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_grrect</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_grrect</NAME>
struct _nsp_grrect {
  double x;
  double y;
  double w;
  double h;
  int fill_color;
  int thickness;
  int color;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspGrRect</NAME>
struct _NspGrRect {
  /*< private >*/
  NspGraphic father;
  NspTypeGrRect*type;
  /*< public >*/
  nsp_grrect *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_grrect_id</NAME>
extern int nsp_type_grrect_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_grrect</NAME>
extern NspTypeGrRect *nsp_type_grrect;
</VARIABLE>
<FUNCTION>
<NAME>new_type_grrect</NAME>
<RETURNS>NspTypeGrRect *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_grrect</NAME>
<RETURNS>NspGrRect *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLGRRECT</NAME>
#define NULLGRRECT (NspGrRect*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_grrect_create</NAME>
<RETURNS>NspGrRect *</RETURNS>
const char *name,double x,double y,double w,double h,int fill_color,int thickness,int color,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_create_default</NAME>
<RETURNS>NspGrRect *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_copy</NAME>
<RETURNS>NspGrRect *</RETURNS>
NspGrRect *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_destroy</NAME>
<RETURNS>void </RETURNS>
NspGrRect *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_info</NAME>
<RETURNS>int </RETURNS>
NspGrRect *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_print</NAME>
<RETURNS>int </RETURNS>
NspGrRect *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_latex</NAME>
<RETURNS>int </RETURNS>
NspGrRect *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_object</NAME>
<RETURNS>NspGrRect *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGrRectObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsGrRect</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetGrRectCopy</NAME>
<RETURNS>NspGrRect *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGrRect</NAME>
<RETURNS>NspGrRect *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_create_partial</NAME>
<RETURNS>int </RETURNS>
NspGrRect *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspGrRect *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_copy_partial</NAME>
<RETURNS>NspGrRect *</RETURNS>
NspGrRect *H,NspGrRect *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_full_copy_partial</NAME>
<RETURNS>NspGrRect *</RETURNS>
NspGrRect *H,NspGrRect *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_full_copy</NAME>
<RETURNS>NspGrRect *</RETURNS>
NspGrRect *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_check_values</NAME>
<RETURNS>int </RETURNS>
NspGrRect *H
</FUNCTION>
<FUNCTION>
<NAME>int_grrect_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_xdr_load_partial</NAME>
<RETURNS>NspGrRect *</RETURNS>
XDR *xdrs, NspGrRect *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_grrect_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspGrRect *M
</FUNCTION>
<STRUCT>
<NAME>NspGMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGMatrix</NAME>
struct _NspTypeGMatrix {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 49 "./gmatrix.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_gmatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_gmatrix</NAME>
struct _nsp_gmatrix {
  NspMatrix* data;
  NspMatrix* rect;
  gboolean remap;
  NspMatrix* colminmax;
  NspMatrix* zminmax;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspGMatrix</NAME>
struct _NspGMatrix {
  /*< private >*/
  NspGraphic father;
  NspTypeGMatrix*type;
  /*< public >*/
  nsp_gmatrix *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_gmatrix_id</NAME>
extern int nsp_type_gmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_gmatrix</NAME>
extern NspTypeGMatrix *nsp_type_gmatrix;
</VARIABLE>
<FUNCTION>
<NAME>new_type_gmatrix</NAME>
<RETURNS>NspTypeGMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_gmatrix</NAME>
<RETURNS>NspGMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLGMATRIX</NAME>
#define NULLGMATRIX (NspGMatrix*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_gmatrix_create</NAME>
<RETURNS>NspGMatrix *</RETURNS>
const char *name,NspMatrix* data,NspMatrix* rect,gboolean remap,NspMatrix* colminmax,NspMatrix* zminmax,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_create_default</NAME>
<RETURNS>NspGMatrix *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_copy</NAME>
<RETURNS>NspGMatrix *</RETURNS>
NspGMatrix *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspGMatrix *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_info</NAME>
<RETURNS>int </RETURNS>
NspGMatrix *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_print</NAME>
<RETURNS>int </RETURNS>
NspGMatrix *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_latex</NAME>
<RETURNS>int </RETURNS>
NspGMatrix *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_object</NAME>
<RETURNS>NspGMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGMatrixObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsGMatrix</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetGMatrixCopy</NAME>
<RETURNS>NspGMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGMatrix</NAME>
<RETURNS>NspGMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_create_partial</NAME>
<RETURNS>int </RETURNS>
NspGMatrix *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspGMatrix *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_copy_partial</NAME>
<RETURNS>NspGMatrix *</RETURNS>
NspGMatrix *H,NspGMatrix *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_full_copy_partial</NAME>
<RETURNS>NspGMatrix *</RETURNS>
NspGMatrix *H,NspGMatrix *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_full_copy</NAME>
<RETURNS>NspGMatrix *</RETURNS>
NspGMatrix *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_check_values</NAME>
<RETURNS>int </RETURNS>
NspGMatrix *H
</FUNCTION>
<FUNCTION>
<NAME>int_gmatrix_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_xdr_load_partial</NAME>
<RETURNS>NspGMatrix *</RETURNS>
XDR *xdrs, NspGMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_gmatrix_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspGMatrix *M
</FUNCTION>
<STRUCT>
<NAME>NspString3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeString3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeString3d</NAME>
struct _NspTypeString3d {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./string3d.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_string3d</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_string3d</NAME>
struct _nsp_string3d {
  NspMatrix* Mcoord;
  void* Mcoord_l;
  char* str;
  int font_type;
  int font_size;
  int* pos;  int pos_length;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspString3d</NAME>
struct _NspString3d {
  /*< private >*/
  NspGraphic father;
  NspTypeString3d*type;
  /*< public >*/
  nsp_string3d *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_string3d_id</NAME>
extern int nsp_type_string3d_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_string3d</NAME>
extern NspTypeString3d *nsp_type_string3d;
</VARIABLE>
<FUNCTION>
<NAME>new_type_string3d</NAME>
<RETURNS>NspTypeString3d *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_string3d</NAME>
<RETURNS>NspString3d *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSTRING3D</NAME>
#define NULLSTRING3D (NspString3d*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_string3d_create</NAME>
<RETURNS>NspString3d *</RETURNS>
const char *name,NspMatrix* Mcoord,void* Mcoord_l,char* str,int font_type,int font_size,int* pos, int pos_length,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_create_default</NAME>
<RETURNS>NspString3d *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_copy</NAME>
<RETURNS>NspString3d *</RETURNS>
NspString3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_destroy</NAME>
<RETURNS>void </RETURNS>
NspString3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_info</NAME>
<RETURNS>int </RETURNS>
NspString3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_print</NAME>
<RETURNS>int </RETURNS>
NspString3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_latex</NAME>
<RETURNS>int </RETURNS>
NspString3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_object</NAME>
<RETURNS>NspString3d *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsString3dObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsString3d</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetString3dCopy</NAME>
<RETURNS>NspString3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetString3d</NAME>
<RETURNS>NspString3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_create_partial</NAME>
<RETURNS>int </RETURNS>
NspString3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspString3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_copy_partial</NAME>
<RETURNS>NspString3d *</RETURNS>
NspString3d *H,NspString3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_full_copy_partial</NAME>
<RETURNS>NspString3d *</RETURNS>
NspString3d *H,NspString3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_full_copy</NAME>
<RETURNS>NspString3d *</RETURNS>
NspString3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_check_values</NAME>
<RETURNS>int </RETURNS>
NspString3d *H
</FUNCTION>
<FUNCTION>
<NAME>int_string3d_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_xdr_load_partial</NAME>
<RETURNS>NspString3d *</RETURNS>
XDR *xdrs, NspString3d *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_string3d_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspString3d *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_graphic_context</NAME>
<RETURNS>BCG *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>apply_transforms_new</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double Coord[],const double *M, VisionPos pos[],const double lim[], int ncoord
</FUNCTION>
<STRUCT>
<NAME>hfoo</NAME>
</STRUCT>
<STRUCT>
<NAME>hfoo</NAME>
struct _hfoo {
  int a;
  double *val;
};

</STRUCT>
<STRUCT>
<NAME>NspClassA</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeClassA</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeClassA</NAME>
struct _NspTypeClassA {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 52 "./classa.h"
};

</STRUCT>
<STRUCT>
<NAME>NspClassA</NAME>
struct _NspClassA {
  /*< private >*/
  NspObject father;
  NspTypeClassA*type;
  /*< public >*/
    int cla_color;
  int cla_thickness;
  NspMatrix* cla_val;
  NspBMatrix* cla_bval;
  NspList* cla_lval;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_classa_id</NAME>
extern int nsp_type_classa_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_classa</NAME>
extern NspTypeClassA *nsp_type_classa;
</VARIABLE>
<FUNCTION>
<NAME>new_type_classa</NAME>
<RETURNS>NspTypeClassA *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_classa</NAME>
<RETURNS>NspClassA *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCLASSA</NAME>
#define NULLCLASSA (NspClassA*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_classa_create</NAME>
<RETURNS>NspClassA *</RETURNS>
const char *name,int cla_color,int cla_thickness,NspMatrix* cla_val,NspBMatrix* cla_bval,NspList* cla_lval,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_create_default</NAME>
<RETURNS>NspClassA *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_copy</NAME>
<RETURNS>NspClassA *</RETURNS>
NspClassA *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_destroy</NAME>
<RETURNS>void </RETURNS>
NspClassA *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_info</NAME>
<RETURNS>int </RETURNS>
NspClassA *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_print</NAME>
<RETURNS>int </RETURNS>
NspClassA *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_latex</NAME>
<RETURNS>int </RETURNS>
NspClassA *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_object</NAME>
<RETURNS>NspClassA *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsClassAObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsClassA</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetClassACopy</NAME>
<RETURNS>NspClassA *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetClassA</NAME>
<RETURNS>NspClassA *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_create_partial</NAME>
<RETURNS>int </RETURNS>
NspClassA *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspClassA *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_copy_partial</NAME>
<RETURNS>NspClassA *</RETURNS>
NspClassA *H,NspClassA *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_full_copy_partial</NAME>
<RETURNS>NspClassA *</RETURNS>
NspClassA *H,NspClassA *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_full_copy</NAME>
<RETURNS>NspClassA *</RETURNS>
NspClassA *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_check_values</NAME>
<RETURNS>int </RETURNS>
NspClassA *H
</FUNCTION>
<FUNCTION>
<NAME>int_classa_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_xdr_load_partial</NAME>
<RETURNS>NspClassA *</RETURNS>
XDR *xdrs, NspClassA *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspClassA *M
</FUNCTION>
<TYPEDEF>
<NAME>grb_lock</NAME>
typedef struct b_lock grb_lock ; 
</TYPEDEF>
<STRUCT>
<NAME>NspBlock</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeBlock</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeBlock</NAME>
struct _NspTypeBlock {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 97 "./block.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_block</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_block</NAME>
struct _nsp_block {
  void* object_sid;
  double r[4];
  int color;
  int thickness;
  int background;
  int n_locks;
  grb_lock* locks;
  NspGraphic* icon;
  int draw_mode;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspBlock</NAME>
struct _NspBlock {
  /*< private >*/
  NspGraphic father;
  NspTypeBlock*type;
  /*< public >*/
  nsp_block *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_block_id</NAME>
extern int nsp_type_block_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_block</NAME>
extern NspTypeBlock *nsp_type_block;
</VARIABLE>
<FUNCTION>
<NAME>new_type_block</NAME>
<RETURNS>NspTypeBlock *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_block</NAME>
<RETURNS>NspBlock *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLBLOCK</NAME>
#define NULLBLOCK (NspBlock*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_block_create</NAME>
<RETURNS>NspBlock *</RETURNS>
const char *name,void* object_sid,double* r,int color,int thickness,int background,int n_locks,grb_lock* locks,NspGraphic* icon,int draw_mode,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_create_default</NAME>
<RETURNS>NspBlock *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_copy</NAME>
<RETURNS>NspBlock *</RETURNS>
NspBlock *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_destroy</NAME>
<RETURNS>void </RETURNS>
NspBlock *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_info</NAME>
<RETURNS>int </RETURNS>
NspBlock *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_print</NAME>
<RETURNS>int </RETURNS>
NspBlock *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_latex</NAME>
<RETURNS>int </RETURNS>
NspBlock *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_object</NAME>
<RETURNS>NspBlock *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsBlockObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsBlock</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetBlockCopy</NAME>
<RETURNS>NspBlock *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetBlock</NAME>
<RETURNS>NspBlock *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_create_partial</NAME>
<RETURNS>int </RETURNS>
NspBlock *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspBlock *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_copy_partial</NAME>
<RETURNS>NspBlock *</RETURNS>
NspBlock *H,NspBlock *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_full_copy_partial</NAME>
<RETURNS>NspBlock *</RETURNS>
NspBlock *H,NspBlock *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_full_copy</NAME>
<RETURNS>NspBlock *</RETURNS>
NspBlock *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_check_values</NAME>
<RETURNS>int </RETURNS>
NspBlock *H
</FUNCTION>
<FUNCTION>
<NAME>int_block_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_xdr_load_partial</NAME>
<RETURNS>NspBlock *</RETURNS>
XDR *xdrs, NspBlock *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspBlock *M
</FUNCTION>
<FUNCTION>
<NAME>getenv</NAME>
<RETURNS>char  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>putenv</NAME>
#define putenv(x) abs_putenv(x)
</MACRO>
<MACRO>
<NAME>getpid</NAME>
#define getpid() getpid()
</MACRO>
<MACRO>
<NAME>putenv</NAME>
#define putenv(x) _putenv(x)
</MACRO>
<MACRO>
<NAME>chdir</NAME>
#define chdir(x) _chdir(x)
</MACRO>
<MACRO>
<NAME>GETCWD</NAME>
#define GETCWD(x,y) _getcwd(x,y)
</MACRO>
<FUNCTION>
<NAME>Sciprintf</NAME>
<RETURNS>void </RETURNS>
char *fmt,...
</FUNCTION>
<MACRO>
<NAME>GETCWD</NAME>
#define GETCWD(x,y) getcwd(x,y)
</MACRO>
<MACRO>
<NAME>GETCWD</NAME>
#define GETCWD(x,y) getcwd(x,y)
</MACRO>
<MACRO>
<NAME>GETCWD</NAME>
#define GETCWD(x,y) getcwd(x,y)
</MACRO>
<MACRO>
<NAME>GETCWD</NAME>
#define GETCWD(x,y) getwd(x)
</MACRO>
<MACRO>
<NAME>FSIZE</NAME>
#define FSIZE 1024
</MACRO>
<FUNCTION>
<NAME>get_sci_data_strings</NAME>
<RETURNS>char *</RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>set_nsp_tmpdir</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>get_nsp_tmpdir</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>clean_tmpdir</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_change_curdir</NAME>
<RETURNS>int </RETURNS>
char *path
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_curdir</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_path_expand</NAME>
<RETURNS>void </RETURNS>
const char *in_name, char *out_name, int out_size
</FUNCTION>
<FUNCTION>
<NAME>nsp_timer</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_cputime</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_realtime</NAME>
<RETURNS>int </RETURNS>
double *t
</FUNCTION>
<FUNCTION>
<NAME>nsp_realtime_init</NAME>
<RETURNS>int </RETURNS>
 double *t,  double *scale
</FUNCTION>
<FUNCTION>
<NAME>nsp_stimer</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_tic</NAME>
<RETURNS>double </RETURNS>
int set_start_time
</FUNCTION>
<FUNCTION>
<NAME>nsp_toc</NAME>
<RETURNS>double </RETURNS>
double *etime
</FUNCTION>
<VARIABLE>
<NAME>debug</NAME>
extern int debug; 
</VARIABLE>
<VARIABLE>
<NAME>debugI</NAME>
extern int debugI;
</VARIABLE>
<MACRO>
<NAME>TBUF</NAME>
#define TBUF 1024
</MACRO>
<VARIABLE>
<NAME>Token</NAME>
extern Token_Obj Token ;
</VARIABLE>
<FUNCTION>
<NAME>nsp_astcode_to_nickname</NAME>
<RETURNS>const char *</RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_astcode_to_name</NAME>
<RETURNS>const char *</RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_nsp_keyword</NAME>
<RETURNS>int </RETURNS>
const char *id
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_code_keyword</NAME>
<RETURNS>int </RETURNS>
int keyc
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_opname</NAME>
<RETURNS>int </RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_ast_hash_create</NAME>
<RETURNS>NspHash *</RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>NspTypePMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePMatrix</NAME>
struct _NspTypePMatrix { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} ;

</STRUCT>
<TYPEDEF>
<NAME>nsp_polynom</NAME>
typedef NspMatrix * nsp_polynom;
</TYPEDEF>
<STRUCT>
<NAME>NspPmatrix</NAME>
struct _NspPmatrix {
  /*< private >*/
  NspObject father; 
  NspTypePMatrix *type; 
  /*< public >*/
  int m,n,mn;       /* matrix dimension (m,n,m*n) */
  nsp_polynom *S;     /* Each polynom is a Matrix **/
  char rc_type  ;   /* type 'r' or 'i' */
  char *var  ;   /* name of polynom variable */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_pmatrix_id</NAME>
extern int nsp_type_pmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_pmatrix</NAME>
extern NspTypePMatrix *nsp_type_pmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_pmatrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_pmatrix</NAME>
<RETURNS>NspTypePMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_pmatrix</NAME>
<RETURNS>NspPMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLPMAT</NAME>
#define NULLPMAT (NspPMatrix *) 0
</MACRO>
<MACRO>
<NAME>NULLPOLY</NAME>
#define NULLPOLY (nsp_polynom) 0
</MACRO>
<FUNCTION>
<NAME>nsp_pmatrix_object</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_length</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_pmatrix</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_polynom</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_concat_down</NAME>
<RETURNS>NspPMatrix *</RETURNS>
const NspPMatrix *A,const NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_copy</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_create</NAME>
<RETURNS>NspPMatrix *</RETURNS>
char *name, int m, int n,const doubleC *cval, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_create_m</NAME>
<RETURNS>NspPMatrix *</RETURNS>
char *name, int m, int n,NspMatrix *Val
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_clone</NAME>
<RETURNS>NspPMatrix *</RETURNS>
char *name, NspPMatrix *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract_columns</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract_elements</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspMatrix *Elts, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract_rows</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_transpose</NAME>
<RETURNS>NspPMatrix *</RETURNS>
const NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_add_columns</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_add_rows</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_concat_right</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A,const NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_redim</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_resize</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_set_rows</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, NspMatrix *Rows, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A,const NspMatrix *Rows,const NspMatrix *Cols,const NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_setrc</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspPMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_info</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_print</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_destroy</NAME>
<RETURNS>void </RETURNS>
nsp_polynom *P
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_add</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_minus</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_mult_m_p</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspMatrix *A, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_mult_p_m</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_mult_tt</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_mult_tt_p_m</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_mult_tt_m_p</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspMatrix *A, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_div_tt_p_m</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspMatrix *B,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_div_tt_m_p</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspMatrix *A, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_mult_p_p</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_dh_p_m</NAME>
<RETURNS>NspPMatrix *</RETURNS>
const NspPMatrix *P,const NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_hat_p_m</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *P,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_minus_m</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A,NspMatrix *B, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_add_m</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A,NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>IsPMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsPMat</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetPMatCopy</NAME>
<RETURNS>NspPMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetPMat</NAME>
<RETURNS>NspPMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetPolynom</NAME>
<RETURNS>nsp_polynom </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>PMatFullComp</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, NspPMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_companion</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_to_cells</NAME>
<RETURNS>NspCells *</RETURNS>
const char *name, NspPMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_horner</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspPMatrix *P,NspMatrix *V,int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_horner_tt</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspPMatrix *P,NspMatrix *V
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_comp</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspPMatrix *A, NspPMatrix *B,const char *op
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_pdiv_tt</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, NspPMatrix *B, NspPMatrix **Q, NspPMatrix **R
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_resize</NAME>
<RETURNS>int </RETURNS>
nsp_polynom poly
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_add</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom P,nsp_polynom Q
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_minus</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom P,nsp_polynom Q
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_mult</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom a,nsp_polynom b
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_mult_std</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom a,nsp_polynom b
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_mult_fft</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom a,nsp_polynom b
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_pdiv</NAME>
<RETURNS>int </RETURNS>
nsp_polynom a,nsp_polynom b,nsp_polynom *hq, nsp_polynom *hr
</FUNCTION>
<FUNCTION>
<NAME>nsp_pset_polynom</NAME>
<RETURNS>int </RETURNS>
int n, const doubleC *s1, nsp_polynom *s2
</FUNCTION>
<FUNCTION>
<NAME>nsp_basic_to_polynom</NAME>
<RETURNS>nsp_polynom </RETURNS>
const doubleC *d, char type
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_copy</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom P
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_copy_with_name</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom P
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_power</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom p,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_minus_m</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom p, void *v, char type
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_add_m</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom p, void *v, char type
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_horner</NAME>
<RETURNS>NspMatrix *</RETURNS>
nsp_polynom P,NspMatrix *b
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_hornerm</NAME>
<RETURNS>NspMatrix *</RETURNS>
nsp_polynom P,NspMatrix *b
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_roots</NAME>
<RETURNS>NspMatrix *</RETURNS>
nsp_polynom poly
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_mult_m</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom p, void *v, char type
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_div_m</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom p, void *v, char type
</FUNCTION>
<FUNCTION>
<NAME>nsp_hornerdd</NAME>
<RETURNS>double </RETURNS>
const double *a,const int n, double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_hornercd</NAME>
<RETURNS>doubleC </RETURNS>
const doubleC *a,const int n, double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_hornerdc</NAME>
<RETURNS>doubleC </RETURNS>
const double *a,const int n, doubleC x
</FUNCTION>
<FUNCTION>
<NAME>nsp_hornercc</NAME>
<RETURNS>doubleC </RETURNS>
const doubleC *a,const int n, doubleC x
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_size</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *Mat, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_type_as_string</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_type_short_string</NAME>
<RETURNS>char *</RETURNS>
NspObject *v
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_loop_extract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_eq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_neq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<STRUCT>
<NAME>NspTypeCholmod</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeCholmod</NAME>
struct _NspTypeCholmod {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
};

</STRUCT>
<STRUCT>
<NAME>nsp_cholmod</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_cholmod</NAME>
struct _nsp_cholmod {
  cholmod_factor *L ;
  cholmod_common Common;
  int m,n;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspCholmod</NAME>
struct _NspCholmod {
  /*< private >*/
  NspObject father;
  NspTypeCholmod*type;
  /*< public >*/
  nsp_cholmod *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_cholmod_id</NAME>
extern int nsp_type_cholmod_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_cholmod</NAME>
extern NspTypeCholmod *nsp_type_cholmod;
</VARIABLE>
<FUNCTION>
<NAME>new_type_cholmod</NAME>
<RETURNS>NspTypeCholmod *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_cholmod</NAME>
<RETURNS>NspCholmod *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCHOLMOD</NAME>
#define NULLCHOLMOD (NspCholmod*) 0
</MACRO>
<FUNCTION>
<NAME>cholmod_create</NAME>
<RETURNS>NspCholmod *</RETURNS>
char *name,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholmod_copy</NAME>
<RETURNS>NspCholmod *</RETURNS>
NspCholmod *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholmod_destroy</NAME>
<RETURNS>void </RETURNS>
NspCholmod *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholmod_info</NAME>
<RETURNS>int </RETURNS>
NspCholmod *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholmod_print</NAME>
<RETURNS>int </RETURNS>
NspCholmod *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholmod_object</NAME>
<RETURNS>NspCholmod *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsCholmodObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsCholmod</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetCholmodCopy</NAME>
<RETURNS>NspCholmod *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetCholmod</NAME>
<RETURNS>NspCholmod *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>int_cholmod_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<MACRO>
<NAME>XCNAME</NAME>
#define XCNAME(x,y) CNAME(x,y)
</MACRO>
<FUNCTION>
<NAME>sizeof</NAME>
<RETURNS>n*</RETURNS>
ELT_TYPE),n*sizeof(int),(dir == 'i' ) ? XCNAME(compareC,ELT_TYPE):XCNAME(compareD,ELT_TYPE),XCNAME(swapcode,ELT_TYPE),swapcodeind
</FUNCTION>
<FUNCTION>
<NAME>sizeof</NAME>
<RETURNS>n*</RETURNS>
ELT_TYPE),sizeof(int),(dir == 'i' ) ? XCNAME(LexiColcompareC,ELT_TYPE):XCNAME(LexiColcompareD,ELT_TYPE),XCNAME(LexiColswapcode,ELT_TYPE),swapcodeind
</FUNCTION>
<VARIABLE>
<NAME>VoidPt_Type</NAME>
extern SciFType * VoidPt_Type;
</VARIABLE>
<VARIABLE>
<NAME>GtkE_Type</NAME>
extern SciFType * GtkE_Type ;
</VARIABLE>
<VARIABLE>
<NAME>BMatrix_Type</NAME>
extern SciFType * BMatrix_Type ;
</VARIABLE>
<VARIABLE>
<NAME>SciFile_Type</NAME>
extern SciFType * SciFile_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Func_Type</NAME>
extern SciFType * Func_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Hash_Type</NAME>
extern SciFType * Hash_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Hobj_Type</NAME>
extern SciFType * Hobj_Type ;
</VARIABLE>
<VARIABLE>
<NAME>IVect_Type</NAME>
extern SciFType * IVect_Type;
</VARIABLE>
<VARIABLE>
<NAME>List_Type</NAME>
extern SciFType * List_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Matrix_Type</NAME>
extern SciFType * Matrix_Type ;
</VARIABLE>
<VARIABLE>
<NAME>PMatrix_Type</NAME>
extern SciFType * PMatrix_Type;
</VARIABLE>
<VARIABLE>
<NAME>P_PList_Type</NAME>
extern SciFType * P_PList_Type ;
</VARIABLE>
<VARIABLE>
<NAME>SMatrix_Type</NAME>
extern SciFType * SMatrix_Type;
</VARIABLE>
<VARIABLE>
<NAME>Sp_Type</NAME>
extern SciFType * Sp_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Array_Type</NAME>
extern SciFType * Array_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Mod_Type</NAME>
extern SciFType * Mod_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Me_Type</NAME>
extern SciFType * Me_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Lmo_Type</NAME>
extern SciFType * Lmo_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Rect_Type</NAME>
extern SciFType * Rect_Type ;
</VARIABLE>
<VARIABLE>
<NAME>GFrame_Type</NAME>
extern SciFType * GFrame_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Block_Type</NAME>
extern SciFType * Block_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Link_Type</NAME>
extern SciFType * Link_Type ;
</VARIABLE>
<STRUCT>
<NAME>NspFec</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeFec</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeFec</NAME>
struct _NspTypeFec {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 43 "./fec.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_fec</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_fec</NAME>
struct _nsp_fec {
  NspMatrix* x;
  NspMatrix* y;
  NspMatrix* triangles;
  NspMatrix* func;
  NspMatrix* colminmax;
  NspMatrix* zminmax;
  gboolean mesh;
  gboolean paint;
  NspMatrix* colout;
  gboolean colorbar;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspFec</NAME>
struct _NspFec {
  /*< private >*/
  NspGraphic father;
  NspTypeFec*type;
  /*< public >*/
  nsp_fec *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_fec_id</NAME>
extern int nsp_type_fec_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_fec</NAME>
extern NspTypeFec *nsp_type_fec;
</VARIABLE>
<FUNCTION>
<NAME>new_type_fec</NAME>
<RETURNS>NspTypeFec *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_fec</NAME>
<RETURNS>NspFec *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLFEC</NAME>
#define NULLFEC (NspFec*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_fec_create</NAME>
<RETURNS>NspFec *</RETURNS>
const char *name,NspMatrix* x,NspMatrix* y,NspMatrix* triangles,NspMatrix* func,NspMatrix* colminmax,NspMatrix* zminmax,gboolean mesh,gboolean paint,NspMatrix* colout,gboolean colorbar,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_create_default</NAME>
<RETURNS>NspFec *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_copy</NAME>
<RETURNS>NspFec *</RETURNS>
NspFec *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_destroy</NAME>
<RETURNS>void </RETURNS>
NspFec *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_info</NAME>
<RETURNS>int </RETURNS>
NspFec *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_print</NAME>
<RETURNS>int </RETURNS>
NspFec *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_latex</NAME>
<RETURNS>int </RETURNS>
NspFec *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_object</NAME>
<RETURNS>NspFec *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsFecObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsFec</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetFecCopy</NAME>
<RETURNS>NspFec *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetFec</NAME>
<RETURNS>NspFec *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_create_partial</NAME>
<RETURNS>int </RETURNS>
NspFec *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspFec *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_copy_partial</NAME>
<RETURNS>NspFec *</RETURNS>
NspFec *H,NspFec *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_full_copy_partial</NAME>
<RETURNS>NspFec *</RETURNS>
NspFec *H,NspFec *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_full_copy</NAME>
<RETURNS>NspFec *</RETURNS>
NspFec *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_check_values</NAME>
<RETURNS>int </RETURNS>
NspFec *H
</FUNCTION>
<FUNCTION>
<NAME>int_fec_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_xdr_load_partial</NAME>
<RETURNS>NspFec *</RETURNS>
XDR *xdrs, NspFec *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_fec_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspFec *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_graphic_context</NAME>
<RETURNS>BCG *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>PermutOfSort</NAME>
<RETURNS>void </RETURNS>
const int *tab, int *perm
</FUNCTION>
<FUNCTION>
<NAME>PaintTriangle</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,const double *sx,const double *sy,const  double *fxy,const int *zxy, const double *zlevel,const int *fill
</FUNCTION>
<FUNCTION>
<NAME>DrawTriangle</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,const double *sx,const double *sy,const  double *fxy,const int *zxy, const double *zlevel,const int *fill
</FUNCTION>
<FUNCTION>
<NAME>FindIntersection</NAME>
<RETURNS>void </RETURNS>
const double *sx,const double *sy,const double *fxy,double z,int inda, int indb,  int *xint, int *yint
</FUNCTION>
<STRUCT>
<NAME>NspRect</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeRect</NAME>
typedef struct _NspTypeRect { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeRect;
</STRUCT>
<STRUCT>
<NAME>NspRect</NAME>
struct _NspRect {
  /*< private >*/
  NspObject father; 
  NspTypeRect *type; 
  /*< public >*/
  BCG *Xgc;
  double r[4];
  int color; 
  int thickness;
  int background;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_rect_id</NAME>
extern int nsp_type_rect_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_rect</NAME>
extern NspTypeRect *nsp_type_rect;
</VARIABLE>
<FUNCTION>
<NAME>new_type_rect</NAME>
<RETURNS>NspTypeRect *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_rect</NAME>
<RETURNS>NspRect *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLRECT</NAME>
#define NULLRECT (NspRect*) 0
</MACRO>
<FUNCTION>
<NAME>IsRectObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRectCopy</NAME>
<RETURNS>NspRect *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRect</NAME>
<RETURNS>NspRect *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsRect</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>rect_create</NAME>
<RETURNS>NspRect *</RETURNS>
char *name,BCG *Xgc, double *rect, int color, int thickness, int background,NspTypeBase *
</FUNCTION>
<FUNCTION>
<NAME>RectDraw</NAME>
<RETURNS>void </RETURNS>
NspRect *R
</FUNCTION>
<FUNCTION>
<NAME>RectTranslate</NAME>
<RETURNS>void </RETURNS>
NspRect *R,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>RectResize</NAME>
<RETURNS>void </RETURNS>
NspRect *R,const double size[2]
</FUNCTION>
<STRUCT>
<NAME>NspTypeLmo</NAME>
typedef struct _NspTypeLmo { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeLmo;
</STRUCT>
<STRUCT>
<NAME>NspLmo</NAME>
struct _NspLmo {
  /*< private >*/
  NspObject father; 
  NspTypeLmo *type; 
  /*< public >*/
  char *path;  
  char *module;
} ;

</STRUCT>
<VARIABLE>
<NAME>nsp_type_lmo_id</NAME>
extern int nsp_type_lmo_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_lmo</NAME>
extern NspTypeLmo *nsp_type_lmo;
</VARIABLE>
<FUNCTION>
<NAME>new_type_lmo</NAME>
<RETURNS>NspTypeLmo *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_lmo</NAME>
<RETURNS>NspLmo *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>LmoType</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>LmoShType</NAME>
<RETURNS>char *</RETURNS>
NspLmo *M
</FUNCTION>
<FUNCTION>
<NAME>LmoLoopExtract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>LmoObjEq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>LmoObjNeq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLLMO</NAME>
#define NULLLMO ( NspLmo *) 0 
</MACRO>
<FUNCTION>
<NAME>module_path_search_name</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,NspSMatrix *Sm,char **oname
</FUNCTION>
<FUNCTION>
<NAME>module_path_search_object</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,NspSMatrix *Sm,char **oname
</FUNCTION>
<STRUCT>
<NAME>NspClassB</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeClassB</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeClassB</NAME>
struct _NspTypeClassB {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 43 "./classb.h"
};

</STRUCT>
<STRUCT>
<NAME>NspClassB</NAME>
struct _NspClassB {
  /*< private >*/
  NspClassA father;
  NspTypeClassB*type;
  /*< public >*/
    int clb_color;
  int clb_thickness;
  NspMatrix* clb_val;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_classb_id</NAME>
extern int nsp_type_classb_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_classb</NAME>
extern NspTypeClassB *nsp_type_classb;
</VARIABLE>
<FUNCTION>
<NAME>new_type_classb</NAME>
<RETURNS>NspTypeClassB *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_classb</NAME>
<RETURNS>NspClassB *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCLASSB</NAME>
#define NULLCLASSB (NspClassB*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_classb_create</NAME>
<RETURNS>NspClassB *</RETURNS>
const char *name,int clb_color,int clb_thickness,NspMatrix* clb_val,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_create_default</NAME>
<RETURNS>NspClassB *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_copy</NAME>
<RETURNS>NspClassB *</RETURNS>
NspClassB *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_destroy</NAME>
<RETURNS>void </RETURNS>
NspClassB *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_info</NAME>
<RETURNS>int </RETURNS>
NspClassB *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_print</NAME>
<RETURNS>int </RETURNS>
NspClassB *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_latex</NAME>
<RETURNS>int </RETURNS>
NspClassB *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_object</NAME>
<RETURNS>NspClassB *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsClassBObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsClassB</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetClassBCopy</NAME>
<RETURNS>NspClassB *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetClassB</NAME>
<RETURNS>NspClassB *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_create_partial</NAME>
<RETURNS>int </RETURNS>
NspClassB *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspClassB *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_copy_partial</NAME>
<RETURNS>NspClassB *</RETURNS>
NspClassB *H,NspClassB *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_full_copy_partial</NAME>
<RETURNS>NspClassB *</RETURNS>
NspClassB *H,NspClassB *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_full_copy</NAME>
<RETURNS>NspClassB *</RETURNS>
NspClassB *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_check_values</NAME>
<RETURNS>int </RETURNS>
NspClassB *H
</FUNCTION>
<FUNCTION>
<NAME>int_classb_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_xdr_load_partial</NAME>
<RETURNS>NspClassB *</RETURNS>
XDR *xdrs, NspClassB *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspClassB *M
</FUNCTION>
<STRUCT>
<NAME>NspTypeHobj</NAME>
typedef struct _NspTypeHobj { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeHobj;
</STRUCT>
<STRUCT>
<NAME>NspHobj</NAME>
struct _NspHobj {
  /*< private >*/
  NspObject father; 
  NspTypeHobj *type; 
  /*< public >*/
  char htype  ;   /* 'o' : optional argument 
		  * 'h' : handler 
		  * 'g' : global variable pointer 
		  */
  NspObject *O;        /* pointed object */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_hobj</NAME>
extern NspTypeHobj *nsp_type_hobj;
</VARIABLE>
<FUNCTION>
<NAME>new_type_hobj</NAME>
<RETURNS>NspTypeHobj *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_hobj</NAME>
<RETURNS>NspHobj *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLHOBJ</NAME>
#define NULLHOBJ (NspHobj *) 0
</MACRO>
<MACRO>
<NAME>NULLHOPT</NAME>
#define NULLHOPT (NspHobj *) 0
</MACRO>
<FUNCTION>
<NAME>HobjCreate</NAME>
<RETURNS>NspHobj *</RETURNS>
const char *name,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>HoptCreate</NAME>
<RETURNS>NspHobj *</RETURNS>
const char *name,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GobjCreate</NAME>
<RETURNS>NspHobj *</RETURNS>
const char *name,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_copy</NAME>
<RETURNS>NspHobj *</RETURNS>
NspHobj *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_destroy</NAME>
<RETURNS>void </RETURNS>
NspHobj *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_info</NAME>
<RETURNS>int </RETURNS>
NspHobj *H,int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_print</NAME>
<RETURNS>int </RETURNS>
NspHobj *H,int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>IsHobj</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsHopt</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_object</NAME>
<RETURNS>NspHobj  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGlobal</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<MACRO>
<NAME>HOBJ_GET_OBJECT</NAME>
#define HOBJ_GET_OBJECT(Obj,rep)					\
  if (check_cast (Obj, nsp_type_hobj_id) == TRUE)			\
    {									\
      if (((NspHobj *)Obj)->htype != 'g') Obj = ((NspHobj *) Obj)->O;	\
      else {								\
	if ((Obj= nsp_global_frame_search_object(NSP_OBJECT(Obj)->name)) == NULLOBJ) \
	  {								\
	    Scierror("Pointer to a global non existant variable\n");	\
	    return rep;							\
	  }								\
      }									\
    } 
</MACRO>
<STRUCT>
<NAME>NspFigure</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeFigure</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeFigure</NAME>
struct _NspTypeFigure {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 50 "./figure.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_figure</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_figure</NAME>
struct _nsp_figure {
  char* fname;
  char* driver;
  int id;
  NspMatrix* dims;
  NspMatrix* viewport_dims;
  gboolean wresize;
  NspMatrix* position;
  NspList* children;
  gboolean draw_now;
  NspFigureData* gc;
  void* Xgc;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspFigure</NAME>
struct _NspFigure {
  /*< private >*/
  NspGraphic father;
  NspTypeFigure*type;
  /*< public >*/
  nsp_figure *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_figure_id</NAME>
extern int nsp_type_figure_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_figure</NAME>
extern NspTypeFigure *nsp_type_figure;
</VARIABLE>
<FUNCTION>
<NAME>new_type_figure</NAME>
<RETURNS>NspTypeFigure *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_figure</NAME>
<RETURNS>NspFigure *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLFIGURE</NAME>
#define NULLFIGURE (NspFigure*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_figure_create</NAME>
<RETURNS>NspFigure *</RETURNS>
const char *name,char* fname,char* driver,int id,NspMatrix* dims,NspMatrix* viewport_dims,gboolean wresize,NspMatrix* position,NspList* children,gboolean draw_now,NspFigureData* gc,void* Xgc,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_create_default</NAME>
<RETURNS>NspFigure *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_copy</NAME>
<RETURNS>NspFigure *</RETURNS>
NspFigure *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_destroy</NAME>
<RETURNS>void </RETURNS>
NspFigure *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_info</NAME>
<RETURNS>int </RETURNS>
NspFigure *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_print</NAME>
<RETURNS>int </RETURNS>
NspFigure *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_latex</NAME>
<RETURNS>int </RETURNS>
NspFigure *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_object</NAME>
<RETURNS>NspFigure *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsFigureObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsFigure</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetFigureCopy</NAME>
<RETURNS>NspFigure *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetFigure</NAME>
<RETURNS>NspFigure *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_create_partial</NAME>
<RETURNS>int </RETURNS>
NspFigure *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspFigure *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_copy_partial</NAME>
<RETURNS>NspFigure *</RETURNS>
NspFigure *H,NspFigure *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_full_copy_partial</NAME>
<RETURNS>NspFigure *</RETURNS>
NspFigure *H,NspFigure *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_full_copy</NAME>
<RETURNS>NspFigure *</RETURNS>
NspFigure *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_check_values</NAME>
<RETURNS>int </RETURNS>
NspFigure *H
</FUNCTION>
<FUNCTION>
<NAME>int_figure_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_xdr_load_partial</NAME>
<RETURNS>NspFigure *</RETURNS>
XDR *xdrs, NspFigure *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspFigure *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_graphic_context</NAME>
<RETURNS>BCG *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_figure</NAME>
<RETURNS>NspFigure *</RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_for_figure</NAME>
<RETURNS>NspFigure *</RETURNS>
BCG *Xgc,int set_current
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_for_axes_or_objs3d</NAME>
<RETURNS>NspObject *</RETURNS>
BCG *Xgc,const double *wrect
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_pt_axes_or_objs3d</NAME>
<RETURNS>NspObject *</RETURNS>
BCG *Xgc,const int *pt
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_link_figure</NAME>
<RETURNS>void </RETURNS>
NspList *L, nsp_figure  *F,void *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_unlink_figure</NAME>
<RETURNS>void </RETURNS>
NspList *L, nsp_figure *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_check_figure</NAME>
<RETURNS>int </RETURNS>
NspList *L, nsp_figure *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_link_figure</NAME>
<RETURNS>void </RETURNS>
NspGraphic *G, void *F, void *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_unlink_figure</NAME>
<RETURNS>void </RETURNS>
NspGraphic *G, void *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_invalidate</NAME>
<RETURNS>void </RETURNS>
NspGraphic *G
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_for_axes_or_objs3d_from_pointer</NAME>
<RETURNS>NspObject *</RETURNS>
nsp_figure *F,void *obj
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_point_axes</NAME>
<RETURNS>NspGraphic *</RETURNS>
BCG *Xgc,int px,int py,double *dp
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_data_set_colormap</NAME>
<RETURNS>void </RETURNS>
NspFigure *F,NspMatrix *Mc
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_current_figure</NAME>
<RETURNS>int </RETURNS>
NspFigure *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_current_figure</NAME>
<RETURNS>NspFigure *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_send_scale_2D_to_opengl</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>nsp_send_scale_3D_to_opengl</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_remove_children</NAME>
<RETURNS>int </RETURNS>
NspFigure *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_for_current_axes_or_objs3d</NAME>
<RETURNS>NspObject *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_for_current_figure</NAME>
<RETURNS>NspFigure *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_figure_data_reset</NAME>
<RETURNS>void </RETURNS>
NspFigure *F
</FUNCTION>
<STRUCT>
<NAME>Hash_Entry</NAME>
</STRUCT>
<STRUCT>
<NAME>Hash_Entry</NAME>
struct _Hash_Entry { 
  unsigned int used; /* used to detect if data is present */
  NspObject *data;  
};

</STRUCT>
<STRUCT>
<NAME>NspTypeHash</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeHash</NAME>
struct _NspTypeHash { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};

</STRUCT>
<STRUCT>
<NAME>NspHash</NAME>
struct _NspHash {
  /*< private >*/
  NspObject father; 
  NspTypeHash *type; 
  /*< public >*/
  unsigned int hsize,filled; /* size of hash table and number of present entries */
  void  *htable; /* an array of size hsize+1 */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_hash_id</NAME>
extern int nsp_type_hash_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_hash</NAME>
extern NspTypeHash *nsp_type_hash;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_hash_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_hash</NAME>
<RETURNS>NspTypeHash *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_hash</NAME>
<RETURNS>NspHash *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLHASH</NAME>
#define NULLHASH (NspHash*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_hash_create</NAME>
<RETURNS>NspHash *</RETURNS>
const char *name, unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_copy</NAME>
<RETURNS>NspHash *</RETURNS>
NspHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_destroy</NAME>
<RETURNS>void </RETURNS>
NspHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_info</NAME>
<RETURNS>int </RETURNS>
NspHash *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_print</NAME>
<RETURNS>int </RETURNS>
NspHash *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_object</NAME>
<RETURNS>NspHash *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsHashObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsHash</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetHashCopy</NAME>
<RETURNS>NspHash *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetHash</NAME>
<RETURNS>NspHash *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_resize</NAME>
<RETURNS>int </RETURNS>
NspHash *H, unsigned int new_size
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_merge</NAME>
<RETURNS>int </RETURNS>
NspHash *H1, NspHash *H2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_get_next_object</NAME>
<RETURNS>int </RETURNS>
NspHash *H, int *i, NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_enter_copy</NAME>
<RETURNS>int </RETURNS>
NspHash *H, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_enter</NAME>
<RETURNS>int </RETURNS>
NspHash *H, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_remove</NAME>
<RETURNS>void </RETURNS>
NspHash *H, const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_find_and_copy</NAME>
<RETURNS>int </RETURNS>
NspHash *H, char *str, NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_find</NAME>
<RETURNS>int </RETURNS>
NspHash *H,const char *str, NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_equal</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_not_equal</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_full_equal</NAME>
<RETURNS>int </RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_full_not_equal</NAME>
<RETURNS>int </RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_find_by_number</NAME>
<RETURNS>int </RETURNS>
NspHash *H,int k, NspObject **O
</FUNCTION>
<ENUM>
<NAME>HashOperation</NAME>
typedef enum {
  H_FIND,
  H_FIND_COPY,
  H_ENTER,
  H_ENTER_COPY,
  H_REMOVE 
} HashOperation;
</ENUM>
<FUNCTION>
<NAME>nsp_hsearch</NAME>
<RETURNS>int </RETURNS>
NspHash *H,const char *key, NspObject **data,HashOperation action
</FUNCTION>
<FUNCTION>
<NAME>nsp_hcreate_from_list</NAME>
<RETURNS>NspHash *</RETURNS>
char *name,unsigned int nel, NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_hcreate</NAME>
<RETURNS>NspHash *</RETURNS>
const char *name, unsigned int nel
</FUNCTION>
<FUNCTION>
<NAME>nsp_hdestroy</NAME>
<RETURNS>void </RETURNS>
NspHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_current_frame_to_hash</NAME>
<RETURNS>NspHash *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_get_keys</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspHash *H
</FUNCTION>
<ENUM>
<NAME>nsp_print_mode</NAME>
typedef enum { print_std, print_latex, print_latextab } nsp_print_mode;
</ENUM>
<STRUCT>
<NAME>user_preferences</NAME>
</STRUCT>
<STRUCT>
<NAME>user_preferences</NAME>
struct _user_preferences
{
  int output_max_field_width;	/* */
  int output_precision;		/* */
  int split_long_rows;		/* */
  int print_empty_dimensions;	/* */
  int pr_as_read_syntax;	/* print in read syntax */
  int pr_depth ;        /* stop printing at given depth for recursive objects */
  int list_as_tree;     /* flag for list display */
  nsp_print_mode mode;  /* std, latex or latex tables */
  int active ;          /* only print if active is true */
  int color;            /* use terminal coded colors */
};
</STRUCT>
<FUNCTION>
<NAME>scig_click_handler_none</NAME>
<RETURNS>int </RETURNS>
int win, int x, int y, int ibut,int imask, int motion, int release
</FUNCTION>
<FUNCTION>
<NAME>scig_click_handler_sci</NAME>
<RETURNS>int </RETURNS>
int win, int x, int y, int ibut,int imask, int motion, int release
</FUNCTION>
<USER_FUNCTION>
<NAME>Scig_click_handler</NAME>
<RETURNS>int </RETURNS>
int,int,int,int,int,int,int
</USER_FUNCTION>
<FUNCTION>
<NAME>set_scig_click_handler</NAME>
<RETURNS>Scig_click_handler </RETURNS>
Scig_click_handler f
</FUNCTION>
<FUNCTION>
<NAME>reset_scig_click_handler</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>Sci_Help</NAME>
<RETURNS>int </RETURNS>
char *mandir, char *locale, char *help_file
</FUNCTION>
<FUNCTION>
<NAME>Scisncr</NAME>
<RETURNS>void </RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>sciprint2</NAME>
<RETURNS>int </RETURNS>
int iv, char *fmt, ...
</FUNCTION>
<FUNCTION>
<NAME>nsp_in_gtk_window</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_gtk_window</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_activate_gtk_events_check</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_events_activated</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>write_scilab</NAME>
<RETURNS>void </RETURNS>
char *s
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_gtk_events</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>sci_winch_signal</NAME>
<RETURNS>void </RETURNS>
int n
</FUNCTION>
<USER_FUNCTION>
<NAME>Get_char</NAME>
<RETURNS>int </RETURNS>
void
</USER_FUNCTION>
<VARIABLE>
<NAME>Xorgetchar</NAME>
extern Get_char Xorgetchar;
</VARIABLE>
<FUNCTION>
<NAME>nsp_gtk_init</NAME>
<RETURNS>void </RETURNS>
int argc, char **argv,int no_window,int use_textview
</FUNCTION>
<FUNCTION>
<NAME>start_sci_gtk</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>sci_clear_and_exit</NAME>
<RETURNS>void </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>sci_usr1_signal</NAME>
<RETURNS>void </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>sci_sig_tstp</NAME>
<RETURNS>void </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>kill_process_group</NAME>
<RETURNS>int </RETURNS>
int pid, int sig
</FUNCTION>
<FUNCTION>
<NAME>getcolordef</NAME>
<RETURNS>void </RETURNS>
int *screenc
</FUNCTION>
<FUNCTION>
<NAME>setcolordef</NAME>
<RETURNS>void </RETURNS>
int screenc
</FUNCTION>
<FUNCTION>
<NAME>using_readline</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>get_one_char</NAME>
<RETURNS>int </RETURNS>
char *prompt
</FUNCTION>
<FUNCTION>
<NAME>SciGtkReadLine</NAME>
<RETURNS>void </RETURNS>
char *prompt, char *buffer, int *buf_size, int *len_line, int *eof
</FUNCTION>
<FUNCTION>
<NAME>nsp_read_history</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_write_history</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_clear_history</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>create_plugged_main_menu</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>MenuFixCurrentWin</NAME>
<RETURNS>void </RETURNS>
int ivalue
</FUNCTION>
<FUNCTION>
<NAME>graphic_initial_menu</NAME>
<RETURNS>void *</RETURNS>
int winid
</FUNCTION>
<FUNCTION>
<NAME>scig_print</NAME>
<RETURNS>void </RETURNS>
int winid
</FUNCTION>
<STRUCT>
<NAME>NspGFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGFrame</NAME>
typedef struct _NspTypeGFrame { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeGFrame;
</STRUCT>
<STRUCT>
<NAME>nspgframe</NAME>
</STRUCT>
<STRUCT>
<NAME>nspgframe</NAME>
struct _nspgframe {
  NspList *objs ;   /* Object of type list: list of internal objects */
  BCG *Xgc;         /* graphic context to ne used */
  double scale[4];  /* the scales */
  double r[4] ;     /* frame position in its father as relative numbers */
  int top;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspGFrame</NAME>
struct _NspGFrame {
  /*< private >*/
  NspObject father; 
  NspTypeGFrame *type; 
  /*< public >*/
  nspgframe *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_gframe_id</NAME>
extern int nsp_type_gframe_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_gframe</NAME>
extern NspTypeGFrame *nsp_type_gframe;
</VARIABLE>
<FUNCTION>
<NAME>new_type_gframe</NAME>
<RETURNS>NspTypeGFrame *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_gframe</NAME>
<RETURNS>NspGFrame *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLGFRAME</NAME>
#define NULLGFRAME (NspGFrame*) 0
</MACRO>
<FUNCTION>
<NAME>IsGFrameObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGFrameCopy</NAME>
<RETURNS>NspGFrame *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGFrame</NAME>
<RETURNS>NspGFrame *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsGFrame</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_gframe_create</NAME>
<RETURNS>NspGFrame *</RETURNS>
char *name,BCG *Xgc,int init_objs,const double scale[],double r[],NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_gframe_draw</NAME>
<RETURNS>void </RETURNS>
NspGFrame *R
</FUNCTION>
<FUNCTION>
<NAME>nsp_gframe_select_obj</NAME>
<RETURNS>int </RETURNS>
NspGFrame *R, const double *pt, NspObject **Objs,NspObject *exclude
</FUNCTION>
<FUNCTION>
<NAME>nsp_gframe_select_lock</NAME>
<RETURNS>int </RETURNS>
NspGFrame *F,double pt[2], NspObject **O, int *cp, int *lock_c
</FUNCTION>
<FUNCTION>
<NAME>nsp_gframe_select_and_move</NAME>
<RETURNS>int </RETURNS>
NspGFrame *R, const double *pt, int mask
</FUNCTION>
<FUNCTION>
<NAME>nsp_gframe_select_and_hilite</NAME>
<RETURNS>int </RETURNS>
NspGFrame *R,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>nsp_gframe_select_and_toggle_hilite</NAME>
<RETURNS>int </RETURNS>
NspGFrame *R,const double pt[2]
</FUNCTION>
<STRUCT>
<NAME>NspSharedlib</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSharedlib</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSharedlib</NAME>
struct _NspTypeSharedlib {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 47 "./sharedlib.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_sharedlib</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_sharedlib</NAME>
struct _nsp_sharedlib {
  void* shd;
  int id;
  char* path;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspSharedlib</NAME>
struct _NspSharedlib {
  /*< private >*/
  NspObject father;
  NspTypeSharedlib*type;
  /*< public >*/
  nsp_sharedlib *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_sharedlib_id</NAME>
extern int nsp_type_sharedlib_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_sharedlib</NAME>
extern NspTypeSharedlib *nsp_type_sharedlib;
</VARIABLE>
<FUNCTION>
<NAME>new_type_sharedlib</NAME>
<RETURNS>NspTypeSharedlib *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_sharedlib</NAME>
<RETURNS>NspSharedlib *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSHAREDLIB</NAME>
#define NULLSHAREDLIB (NspSharedlib*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_sharedlib_create</NAME>
<RETURNS>NspSharedlib *</RETURNS>
const char *name,void* shd,int id,char* path,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_create_default</NAME>
<RETURNS>NspSharedlib *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_copy</NAME>
<RETURNS>NspSharedlib *</RETURNS>
NspSharedlib *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_destroy</NAME>
<RETURNS>void </RETURNS>
NspSharedlib *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_info</NAME>
<RETURNS>int </RETURNS>
NspSharedlib *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_print</NAME>
<RETURNS>int </RETURNS>
NspSharedlib *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_latex</NAME>
<RETURNS>int </RETURNS>
NspSharedlib *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_object</NAME>
<RETURNS>NspSharedlib *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSharedlibObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSharedlib</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSharedlibCopy</NAME>
<RETURNS>NspSharedlib *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSharedlib</NAME>
<RETURNS>NspSharedlib *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_create_partial</NAME>
<RETURNS>int </RETURNS>
NspSharedlib *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspSharedlib *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_copy_partial</NAME>
<RETURNS>NspSharedlib *</RETURNS>
NspSharedlib *H,NspSharedlib *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_full_copy_partial</NAME>
<RETURNS>NspSharedlib *</RETURNS>
NspSharedlib *H,NspSharedlib *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_full_copy</NAME>
<RETURNS>NspSharedlib *</RETURNS>
NspSharedlib *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_check_values</NAME>
<RETURNS>int </RETURNS>
NspSharedlib *H
</FUNCTION>
<FUNCTION>
<NAME>int_sharedlib_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_xdr_load_partial</NAME>
<RETURNS>NspSharedlib *</RETURNS>
XDR *xdrs, NspSharedlib *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspSharedlib *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_table_find</NAME>
<RETURNS>NspSharedlib *</RETURNS>
 int id
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_table_remove_lib</NAME>
<RETURNS>void </RETURNS>
int id
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_table_find_by_path</NAME>
<RETURNS>NspSharedlib *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_table_insert</NAME>
<RETURNS>NspSharedlib *</RETURNS>
 void *shd,unsigned int id, const  char *path
</FUNCTION>
<FUNCTION>
<NAME>nsp_sharedlib_table_show</NAME>
<RETURNS>void </RETURNS>

</FUNCTION>
<STRUCT>
<NAME>NspTypeSpColMatrix</NAME>
typedef struct _NspTypeSpColMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeSpColMatrix;
</STRUCT>
<TYPEDEF>
<NAME>SpCol</NAME>
typedef struct _spcol SpCol ;
</TYPEDEF>
<STRUCT>
<NAME>spcol</NAME>
struct _spcol {
  int size,iw ; /* size of a row, iw : used for working storage*/
  int *J   ; /* pointer to an int array giving the columns or row i 
		in increasing order */
  union { 
    double *R;     /* Pointer on real values */
    doubleC *C;    /* Pointer on complex values */
    int *I;        /* Pointer on integer values */
  };
} ;
  
</STRUCT>
<STRUCT>
<NAME>NspSpColmatrix</NAME>
struct _NspSpColmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeSpColMatrix *type; 
  /*< public >*/
  char rc_type;        /* 'r' or 'i' : real or complex matrix */
  int m,n;   /* mn should be removed since m*n can be bigger than int */
  SpCol **D; /* array of size m giving the Rows datas */
  char convert; /* 't' : the matrix is stored in triplet , 'n': triplet not used   */
  nsp_sparse_triplet triplet; 
} ;

</STRUCT>
<VARIABLE>
<NAME>nsp_type_spcolmatrix_id</NAME>
extern int nsp_type_spcolmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_spcolmatrix</NAME>
extern NspTypeSpColMatrix *nsp_type_spcolmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_spcolmatrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_spcolmatrix</NAME>
<RETURNS>NspTypeSpColMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_spcolmatrix</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSPCOL</NAME>
#define NULLSPCOL (  NspSpColMatrix *) 0
</MACRO>
<MACRO>
<NAME>NULLSPCOLMAT</NAME>
#define NULLSPCOLMAT (  NspSpColMatrix *) 0
</MACRO>
<FUNCTION>
<NAME>SpColObj</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSpColMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSpColMat</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSpColCopy</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSpCol</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealSpCol</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_col_destroy</NAME>
<RETURNS>void </RETURNS>
SpCol *Col
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_nnz</NAME>
<RETURNS>int </RETURNS>
const NspSpColMatrix *HMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_info</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *Sp, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_print</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *Sp, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_copy</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_object</NAME>
<RETURNS>NspSpColMatrix   *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_create</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
char *name, char type, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sparse</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
char *name,NspMatrix *RC, NspMatrix *Values, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_get</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspMatrix **RC, NspMatrix **Values
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_resize_col</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *Sp, int i, int n
</FUNCTION>
<FUNCTION>
<NAME>SpColRowDestroy</NAME>
<RETURNS>void </RETURNS>
SpCol *Row
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_redim</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, int m, int n, Boolean inplace
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_enlarge_cols</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *Sp, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_concatr</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_concatd</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_concatdiag</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_store</NAME>
<RETURNS>void  </RETURNS>
NspSpColMatrix *A, int r, int c, int col, NspSpColMatrix *B, int r1, int c1
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_insert_elt</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int i, int j, NspSpColMatrix *B, int rb, int cb
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_delete_elt</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int row, int col, int amin, int amax
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_get_elt</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *B, int i, int j
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_set_rowcol</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspObject *Rows, NspObject *Cols, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_set_row</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspObject *Inds, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_delete_cols</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspObject *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_compress_col</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_compress_col_simple</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_delete_rows</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspObject *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_extract</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspObject *Rows, NspObject *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_extract_elts</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspObject *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_extract_cols</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspObject *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_extract_rows</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspObject *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_diag_extract</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_set_diag</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspObject *ODiag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_diag_create</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult_sp_m</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A, NspMatrix *B, NspMatrix *Res
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_pmult_sp_m</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A, NspMatrix *B, NspMatrix *Res
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult_m_sp</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *X,NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult_scalar</NAME>
<RETURNS>int </RETURNS>
double *val, char val_type, NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult_scal</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_complexify</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_setr</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_seti</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_from_mat</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_from_mat_transpose</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_to_mat</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *Sp
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_to_mat_transpose</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *Sp
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_transpose</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
const NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_add</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sub</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_multtt</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_divel</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_and</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_or</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult_scal</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_op_scal</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B, int *flag, char op
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_clean</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int rhs, double epsa, double epsr
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_maximinitt_g</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B, int flag, int minmaxflag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_maxitt</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B, int flag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_minitt</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B, int flag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_triu</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A,int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_tril</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A,int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_ones</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_spones</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_eye</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_zeros</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_realpart</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_imagpart</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_isreal</NAME>
<RETURNS>int </RETURNS>
const NspSpColMatrix *A, int strict
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sum</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_maxi</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, int dim, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mini</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, int dim, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_eye</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_ones</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_zeros</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_acos</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_acosh</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_asin</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_asinh</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_atan</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_atanh</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_ceil</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_int</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_floor</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_round</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sign</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_tan</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_tanh</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_abs</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_erf</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_arg</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_conj</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_cos</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_cosh</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_expel</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_logel</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sin</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sinh</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sqrtel</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_minus</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_find</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int lhs, NspMatrix **Res1, NspMatrix **Res2,NspMatrix **V
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_rand</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m,int n,double sparsity,char crand
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcol_update_from_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcol_set_triplet_from_m</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *M,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcol_alloc_col_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *M,int nzmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcol_realloc_col_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *M,int nzmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcol_free_triplet</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_norm</NAME>
<RETURNS>double </RETURNS>
NspSpColMatrix *A, char c
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_vnorm</NAME>
<RETURNS>double </RETURNS>
NspSpColMatrix *A, double p
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_div_scal_tt</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_div_zero_tt</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_scal_div_tt</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_isnan</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_isinf</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_is_lower_triangular</NAME>
<RETURNS>Boolean </RETURNS>
const NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_is_upper_triangular</NAME>
<RETURNS>Boolean </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_is_symmetric</NAME>
<RETURNS>Boolean </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_lower_and_upper_bandwidth</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int *Kl, int *Ku
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_to_lapack_band_format</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A, int kl, int ku, Boolean enlarge
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_solve_utri</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *U, NspMatrix *x, NspMatrix *b
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_solve_ltri</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *L, NspMatrix *x, NspMatrix *b
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_scale_rows</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspMatrix *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_scale_cols</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspMatrix *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_locate</NAME>
<RETURNS>int </RETURNS>
SpCol *Col,int j
</FUNCTION>
<FUNCTION>
<NAME>GenericMatSeRo</NAME>
<RETURNS>int </RETURNS>
void *A, int Am, int An, int Amn,   index_vector *index,void *B, int Bm, int Bn, int Bmn, F_Enlarge F, int *Bscal
</FUNCTION>
<STRUCT>
<NAME>NspGrImage</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGrImage</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGrImage</NAME>
struct _NspTypeGrImage {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 49 "./grimage.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_grimage</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_grimage</NAME>
struct _nsp_grimage {
  double x;
  double y;
  double w;
  double h;
  gboolean border;
  int thickness;
  char* fname;
  void* image;
  int color;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspGrImage</NAME>
struct _NspGrImage {
  /*< private >*/
  NspGraphic father;
  NspTypeGrImage*type;
  /*< public >*/
  nsp_grimage *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_grimage_id</NAME>
extern int nsp_type_grimage_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_grimage</NAME>
extern NspTypeGrImage *nsp_type_grimage;
</VARIABLE>
<FUNCTION>
<NAME>new_type_grimage</NAME>
<RETURNS>NspTypeGrImage *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_grimage</NAME>
<RETURNS>NspGrImage *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLGRIMAGE</NAME>
#define NULLGRIMAGE (NspGrImage*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_grimage_create</NAME>
<RETURNS>NspGrImage *</RETURNS>
const char *name,double x,double y,double w,double h,gboolean border,int thickness,char* fname,void* image,int color,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_create_default</NAME>
<RETURNS>NspGrImage *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_copy</NAME>
<RETURNS>NspGrImage *</RETURNS>
NspGrImage *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_destroy</NAME>
<RETURNS>void </RETURNS>
NspGrImage *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_info</NAME>
<RETURNS>int </RETURNS>
NspGrImage *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_print</NAME>
<RETURNS>int </RETURNS>
NspGrImage *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_latex</NAME>
<RETURNS>int </RETURNS>
NspGrImage *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_object</NAME>
<RETURNS>NspGrImage *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGrImageObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsGrImage</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetGrImageCopy</NAME>
<RETURNS>NspGrImage *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGrImage</NAME>
<RETURNS>NspGrImage *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_create_partial</NAME>
<RETURNS>int </RETURNS>
NspGrImage *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspGrImage *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_copy_partial</NAME>
<RETURNS>NspGrImage *</RETURNS>
NspGrImage *H,NspGrImage *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_full_copy_partial</NAME>
<RETURNS>NspGrImage *</RETURNS>
NspGrImage *H,NspGrImage *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_full_copy</NAME>
<RETURNS>NspGrImage *</RETURNS>
NspGrImage *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_check_values</NAME>
<RETURNS>int </RETURNS>
NspGrImage *H
</FUNCTION>
<FUNCTION>
<NAME>int_grimage_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_xdr_load_partial</NAME>
<RETURNS>NspGrImage *</RETURNS>
XDR *xdrs, NspGrImage *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_grimage_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspGrImage *M
</FUNCTION>
<STRUCT>
<NAME>NspTypeFunction</NAME>
typedef struct _NspTypeFunction { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeFunction;
</STRUCT>
<STRUCT>
<NAME>NspFunction</NAME>
struct _NspFunction {
  /*< private >*/
  NspObject father; 
  NspTypeFunction *type; 
  /*< public >*/
  char *fname; /* function name */
  int  pos;/* function position inside interface */
  int  iface;/* Interface number in which the function is stored */
  int  status;/* status of the function */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_function_id</NAME>
extern int nsp_type_function_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_function</NAME>
extern NspTypeFunction *nsp_type_function;
</VARIABLE>
<FUNCTION>
<NAME>new_type_function</NAME>
<RETURNS>NspTypeFunction *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_function</NAME>
<RETURNS>NspFunction *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLFUNC</NAME>
#define NULLFUNC (NspFunction*) 0
</MACRO>
<FUNCTION>
<NAME>function_create</NAME>
<RETURNS>NspFunction *</RETURNS>
const char *name,const char *fname,int iface,int pos,int status,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>function_copy</NAME>
<RETURNS>NspFunction *</RETURNS>
NspFunction *H
</FUNCTION>
<FUNCTION>
<NAME>function_destroy</NAME>
<RETURNS>void </RETURNS>
NspFunction *H
</FUNCTION>
<FUNCTION>
<NAME>function_info</NAME>
<RETURNS>int </RETURNS>
NspFunction *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>function_print</NAME>
<RETURNS>int </RETURNS>
NspFunction *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>function_object</NAME>
<RETURNS>NspFunction *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsFunctionObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsFunction</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetFunctionCopy</NAME>
<RETURNS>NspFunction *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetFunction</NAME>
<RETURNS>NspFunction *</RETURNS>
Stack stack, int i
</FUNCTION>
<STRUCT>
<NAME>NspTypeIMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeIMatrix</NAME>
struct _NspTypeIMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};

</STRUCT>
<MACRO>
<NAME>NSP_ITYPE_FORMATS</NAME>
#define NSP_ITYPE_FORMATS(names)				\
  char *(fmt)[]={"%*d","%*ud", "%*d", "%*u","%*d",		\
		 "%*u", "%*d", "%*u", "%*d",			\
		 "%*d", "%*d", "%*u", "%*"G_GINT64_FORMAT,	\
		 "%*"G_GUINT64_FORMAT,NULL};			
</MACRO>
<MACRO>
<NAME>NSP_ITYPE_NAMES</NAME>
#define NSP_ITYPE_NAMES(names)				       \
  char *(names)[]={"int", "uint", "short", "ushort", "long",	\
                   "ulong", "int8", "uint8", "int16",           \
                   "uint16", "int32", "uint32", "int64",        \
                   "uint64",NULL};
</MACRO>
<STRUCT>
<NAME>NspIMatrix</NAME>
struct _NspIMatrix {
  /*< private >*/
  NspObject father; 
  NspTypeIMatrix *type; 
  /*< public >*/
  int m,n,mn;
  union { 
    void *    Iv;
    gint *    Gint;
    guint *    Guint;
    gshort *    Gshort;
    gushort *    Gushort;
    glong *    Glong;
    gulong *    Gulong;
    gint8 *    Gint8;
    guint8 *    Guint8;
    gint16 *    Gint16;
    guint16 *    Guint16;
    gint32 *    Gint32;
    guint32 *    Guint32;
    gint64 *    Gint64;
    guint64 *    Guint64;
  };
  int itype;
  int eltsize;
};

</STRUCT>
<MACRO>
<NAME>NSP_MAX_ITYPE</NAME>
#define NSP_MAX_ITYPE(xx,itype)						\
  switch(itype) {							\
  case nsp_gint: xx.Gint= G_MAXINT; break;				\
  case nsp_guint: xx.Guint= G_MAXUINT; break;				\
  case  nsp_gshort: xx.Gshort= G_MAXSHORT; break;			\
  case nsp_gushort: xx.Gushort= G_MAXUSHORT; break;			\
  case  nsp_glong: xx.Glong= G_MAXLONG ;  break;			\
  case nsp_gulong: xx.Gulong= G_MAXULONG; break;			\
  case  nsp_gint8: xx.Gint8= G_MAXINT8; break;				\
  case nsp_guint8: xx.Guint8= G_MAXUINT8; break;			\
  case  nsp_gint16: xx.Gint16= G_MAXINT16; break;			\
  case nsp_guint16: xx.Guint16= G_MAXUINT16; break;			\
  case  nsp_gint32: xx.Gint32= G_MAXINT32; break;			\
  case nsp_guint32: xx.Guint32= G_MAXUINT32; break;			\
  case  nsp_gint64: xx.Gint64= G_MAXINT64; break;			\
  case  nsp_guint64: xx.Guint64= G_MAXUINT64; break;}
</MACRO>
<MACRO>
<NAME>NSP_MIN_ITYPE</NAME>
#define NSP_MIN_ITYPE(xx,itype)						\
  switch(itype) {							\
  case nsp_gint: xx.Gint= G_MININT; break;				\
  case nsp_guint: xx.Guint= 0; break;				\
  case  nsp_gshort: xx.Gshort= G_MINSHORT; break;			\
  case nsp_gushort: xx.Gushort= 0; break;			\
  case  nsp_glong: xx.Glong= G_MINLONG ;  break;			\
  case nsp_gulong: xx.Gulong= 0; break;			\
  case  nsp_gint8: xx.Gint8= G_MININT8; break;				\
  case nsp_guint8: xx.Guint8= 0; break;			\
  case  nsp_gint16: xx.Gint16= G_MININT16; break;			\
  case nsp_guint16: xx.Guint16= 0; break;			\
  case  nsp_gint32: xx.Gint32= G_MININT32; break;			\
  case nsp_guint32: xx.Guint32= 0; break;			\
  case  nsp_gint64: xx.Gint64= G_MININT64; break;			\
  case  nsp_guint64: xx.Guint64= 0; break;}
</MACRO>
<MACRO>
<NAME>NSP_ITYPE_SWITCH</NAME>
#define NSP_ITYPE_SWITCH(itype,X,arg)		\
  switch (itype ) {				\
  case nsp_gint: X(Gint,gint,arg);		\
  case nsp_guint: X(Guint,guint,arg);		\
  case nsp_gshort: X(Gshort,gshort,arg);	\
  case nsp_gushort: X(Gushort,gushort,arg);	\
  case nsp_glong : X(Glong,glong,arg );		\
  case nsp_gulong: X(Gulong,gulong,arg);	\
  case nsp_gint8: X(Gint8,gint8,arg);		\
  case nsp_guint8: X(Guint8,guint8,arg);	\
  case nsp_gint16: X(Gint16,gint16,arg);	\
  case nsp_guint16: X(Guint16,guint16,arg);	\
  case nsp_gint32: X(Gint32,gint32,arg);	\
  case nsp_guint32: X(Guint32,guint32,arg);	\
  case nsp_gint64 : X(Gint64,gint64,arg );	\
  case nsp_guint64 : X(Guint64,guint64,arg );}
</MACRO>
<MACRO>
<NAME>NSP_ITYPE_SIZE</NAME>
#define NSP_ITYPE_SIZE(s,itype)	NSP_ITYPE_SWITCH(itype,__NSP_ITYPE_SIZE,"") 
</MACRO>
<MACRO>
<NAME>NSP_COPY_ITYPE_TO_ITYPE</NAME>
#define NSP_COPY_ITYPE_TO_ITYPE(name,offset,itype,i,min,step,max,old,itype_old) \
  switch (itype ) {							\
  case nsp_gint: __NSP_COPY_ITYPE_TO_ITYPE(name,offset,Gint,gint,i,min,step,max,old,itype_old) ; break; \
  case nsp_guint: __NSP_COPY_ITYPE_TO_ITYPE(name,offset,Guint,guint,i,min,step,max,old,itype_old) ; break; \
  case nsp_gshort: __NSP_COPY_ITYPE_TO_ITYPE(name,offset,Gshort,gshort,i,min,step,max,old,itype_old) ; break; \
  case nsp_gushort:__NSP_COPY_ITYPE_TO_ITYPE(name,offset,Gushort,gushort,i,min,step,max,old,itype_old) ; break; \
  case nsp_glong : __NSP_COPY_ITYPE_TO_ITYPE(name,offset,Glong,glong,i,min,step,max,old,itype_old) ; break; \
  case nsp_gulong: __NSP_COPY_ITYPE_TO_ITYPE(name,offset,Gulong,gulong,i,min,step,max,old,itype_old) ; break; \
  case nsp_gint8: __NSP_COPY_ITYPE_TO_ITYPE(name,offset,Gint8,gint8,i,min,step,max,old,itype_old) ; break; \
  case nsp_guint8:__NSP_COPY_ITYPE_TO_ITYPE(name,offset,Guint8,guint8,i,min,step,max,old,itype_old) ; break; \
  case nsp_gint16:__NSP_COPY_ITYPE_TO_ITYPE(name,offset,Gint16,gint16,i,min,step,max,old,itype_old) ; break; \
  case nsp_guint16:__NSP_COPY_ITYPE_TO_ITYPE(name,offset,Guint16,guint16,i,min,step,max,old,itype_old) ; break; \
  case nsp_gint32: __NSP_COPY_ITYPE_TO_ITYPE(name,offset,Gint32,gint32,i,min,step,max,old,itype_old) ; break; \
  case nsp_guint32:__NSP_COPY_ITYPE_TO_ITYPE(name,offset,Guint32,guint32,i,min,step,max,old,itype_old) ; break; \
  case nsp_gint64:__NSP_COPY_ITYPE_TO_ITYPE(name,offset,Gint64,gint64,i,min,step,max,old,itype_old) ; break; \
  case nsp_guint64:__NSP_COPY_ITYPE_TO_ITYPE(name,offset,Guint64,guint64,i,min,step,max,old,itype_old) ; break; \
  }
</MACRO>
<MACRO>
<NAME>NSP_ITYPE_NAME</NAME>
#define NSP_ITYPE_NAME(names,itype) (names)[itype] 
</MACRO>
<MACRO>
<NAME>NSP_COPY_ITYPES</NAME>
#define NSP_COPY_ITYPES(iter,name,expl,rhs,itype_rhs,expr)			\
  switch ( (name)->itype ) {						\
  case nsp_gint: __NSP_COPY_ITYPES(iter,name,Gint,expl,gint,rhs,itype_rhs,expr) ; break; \
  case nsp_guint: __NSP_COPY_ITYPES(iter,name, Guint,expl,guint,rhs,itype_rhs,expr) ; break; \
  case nsp_gshort: __NSP_COPY_ITYPES(iter,name,Gshort,expl,gshort,rhs,itype_rhs,expr) ; break; \
  case nsp_gushort:__NSP_COPY_ITYPES(iter,name,Gushort,expl,gushort,rhs,itype_rhs,expr) ; break; \
  case nsp_glong : __NSP_COPY_ITYPES(iter,name,Glong,expl,glong,rhs,itype_rhs,expr) ; break; \
  case nsp_gulong: __NSP_COPY_ITYPES(iter,name,Gulong,expl,gulong,rhs,itype_rhs,expr) ; break; \
  case nsp_gint8: __NSP_COPY_ITYPES(iter,name,Gint8,expl,gint8,rhs,itype_rhs,expr) ; break; \
  case nsp_guint8:__NSP_COPY_ITYPES(iter,name,Guint8,expl,guint8,rhs,itype_rhs,expr) ; break; \
  case nsp_gint16:__NSP_COPY_ITYPES(iter,name,Gint16,expl,gint16,rhs,itype_rhs,expr) ; break; \
  case nsp_guint16:__NSP_COPY_ITYPES(iter,name,Guint16,expl,guint16,rhs,itype_rhs,expr) ; break; \
  case nsp_gint32: __NSP_COPY_ITYPES(iter,name,Gint32,expl,gint32,rhs,itype_rhs,expr) ; break; \
  case nsp_guint32:__NSP_COPY_ITYPES(iter,name,Guint32,expl,guint32,rhs,itype_rhs,expr) ; break; \
  case nsp_gint64:__NSP_COPY_ITYPES(iter,name,Gint64,expl,gint64,rhs,itype_rhs,expr) ; break; \
  case nsp_guint64:__NSP_COPY_ITYPES(iter,name,Guint64,expl,guint64,rhs,itype_rhs,expr) ; break; \
  }
</MACRO>
<VARIABLE>
<NAME>nsp_type_imatrix_id</NAME>
extern int nsp_type_imatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_imatrix</NAME>
extern NspTypeIMatrix *nsp_type_imatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_imatrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_imatrix</NAME>
<RETURNS>NspTypeIMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_imatrix_init</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_imatrix_set</NAME>
<RETURNS>void </RETURNS>
NspIMatrix *imatrix, NspTypeIMatrix *type
</FUNCTION>
<FUNCTION>
<NAME>new_imatrix</NAME>
<RETURNS>NspIMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLIMAT</NAME>
#define NULLIMAT (NspIMatrix*) 0
</MACRO>
<FUNCTION>
<NAME>IMatObj</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsIMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsIMat</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetIMatCopy</NAME>
<RETURNS>NspIMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetIMat</NAME>
<RETURNS>NspIMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetScalarIMat</NAME>
<RETURNS>NspIMatrix  *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>BoolScalar</NAME>
<RETURNS>int </RETURNS>
NspObject *O, Boolean *val
</FUNCTION>
<FUNCTION>
<NAME>GetScalarBool</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i, int *val
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_create</NAME>
<RETURNS>NspIMatrix *</RETURNS>
const char *name, int m, int n, nsp_itype itype
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_create_int_impl</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *First, NspIMatrix *Step,NspIMatrix *Last
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_clone</NAME>
<RETURNS>NspIMatrix *</RETURNS>
const char *name, NspIMatrix *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_copy</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_fill_with</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, const NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_resize</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_scalar_to_mn</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspIMatrix *IMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_info</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *IMat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_print</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *IMat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_latex_print</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *IMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_latex_tab_print</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *IMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_redim</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_concat_right</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_add_columns</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_concat_down</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_concat_diag</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_add_rows</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_set_suimatrix</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_set_rows</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspMatrix *Rows, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_extract</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_extract_elements</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_extract_columns</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_extract_rows</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>IMatLoopCol</NAME>
<RETURNS>NspIMatrix *</RETURNS>
char *str, NspIMatrix *Col, NspIMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_extract_diag</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_set_diag</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_create_diag</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_transpose</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_imatrix</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspMatrix *M,nsp_itype itype
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_imatrix_with_bounds</NAME>
<RETURNS>NspIMatrix  *</RETURNS>
NspMatrix *M, nsp_itype itype
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_to_matrix</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspIMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>MatIsTrue</NAME>
<RETURNS>int </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_and</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A,const NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_scalar_and</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A,const NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_or</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A,const NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_scalar_or</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A,const NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_not</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>IMatIsTrue</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_count_true</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_find</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, int lhs, NspObject **Res1, NspObject **Res2, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_find_2</NAME>
<RETURNS>int </RETURNS>
const NspIMatrix *A, int lhs, NspMatrix **Res1, NspMatrix **Res2
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_comp</NAME>
<RETURNS>NspBMatrix *</RETURNS>
const NspIMatrix *A, const NspIMatrix *B,const char *op
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_fullcomp</NAME>
<RETURNS>int </RETURNS>
const NspIMatrix *A,const  NspIMatrix *B, const char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_change_itype</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A,nsp_itype itype
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_array_ixx</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, void *nx,nsp_itype itye, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_array_ixx</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, void *nx,nsp_itype itype, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_scale_rows</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_scale_cols</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_diff</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, int order, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_mult_scalar_bis</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_add_scalar_bis</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_add_mat</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_sub_scalar_bis</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalar_sub_imatrix_bis</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_sub_mat</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_set_rval</NAME>
<RETURNS>void </RETURNS>
NspIMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_set_ival</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_mult</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, NspIMatrix *B, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_add</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_dadd</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *Mat1, NspIMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_dadd_maxplus</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *Mat1, NspIMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_add_scalar</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *Mat1, NspIMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_sub</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_dsub</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *Mat1, NspIMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_sub_scalar</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *Mat1, NspIMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_subs_calarm</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *Mat1, NspIMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_maxitt1</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B, NspMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_minitt1</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B, NspMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_minmax</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, int dim, NspIMatrix **Amin, NspMatrix **Imin,NspIMatrix **Amax, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_slec</NAME>
<RETURNS>NspIMatrix **</RETURNS>
char *file, int *Count
</FUNCTION>
<FUNCTION>
<NAME>nsp_csetd</NAME>
<RETURNS>void </RETURNS>
const int *n,const double *z,doubleC *tab,const int *inc
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_inv_el</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_kron</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_sum</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_prod</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_cum_prod</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A,  int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_cum_sum</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A,  int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_maxi</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, int dim_flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_mini</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, int dim_flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_createinit</NAME>
<RETURNS>NspIMatrix *</RETURNS>
char *name, nsp_itype type, int m, int n, int (*func)(int,int)
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_triu</NAME>
<RETURNS>void </RETURNS>
NspIMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_tril</NAME>
<RETURNS>void </RETURNS>
NspIMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_eye</NAME>
<RETURNS>NspIMatrix *</RETURNS>
int m, int n,nsp_itype itype
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_ones</NAME>
<RETURNS>NspIMatrix *</RETURNS>
int m, int n,nsp_itype itype
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_zeros</NAME>
<RETURNS>NspIMatrix *</RETURNS>
int m, int n,nsp_itype itype
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_pow_matscalar</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_pow_matmat</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_pow_scalarmat</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_pow_tt</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_pow_el</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_pow_scalar</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_pow_scalarm</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_div_tt</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_div_el</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_div_scalar</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_bdiv_tt</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_bdiv_el</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_bdiv_scalar</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_mult_tt</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_mult_el</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_mult_scalar</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *Mat1, NspIMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_modulo</NAME>
<RETURNS>void </RETURNS>
NspIMatrix *A,NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_idiv</NAME>
<RETURNS>void </RETURNS>
NspIMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_mod</NAME>
<RETURNS>void </RETURNS>
NspIMatrix *x, NspIMatrix *y
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_int</NAME>
<RETURNS>void </RETURNS>
NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_sign</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_abs</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_iand</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_ior</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A, NspIMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_ior_unary</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_iand_unary</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_ishift</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A,int shift,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_minus</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_mfind</NAME>
<RETURNS>int </RETURNS>
const NspIMatrix *x, int m,const char **ops,const double *scalars, NspIMatrix **Ind
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_ndind2ind</NAME>
<RETURNS>int </RETURNS>
int *dims, int nd, NspIMatrix **ndind, NspIMatrix **Ind
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_sub2ind</NAME>
<RETURNS>int </RETURNS>
int *dims, int nd, NspIMatrix **ndind, int nb_ind, NspIMatrix **Ind
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_nnz</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_unique</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *x, NspObject **Ind, NspMatrix **Occ, Boolean first_ind, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_unique_columns</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *x, NspObject **Ind, NspMatrix **Occ, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_unique_rows</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *x, NspObject **Ind, NspMatrix **Occ, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_dot</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *A, NspIMatrix *B, int dim_flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_cross</NAME>
<RETURNS>NspIMatrix *</RETURNS>
NspIMatrix *X, NspIMatrix *Y, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_issorted</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspIMatrix *A, int dim_flag, Boolean strict_order
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_has</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspIMatrix *A, NspIMatrix *x, int lhs, NspMatrix **ind, NspMatrix **ind2
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_intmax</NAME>
<RETURNS>nsp_int_union </RETURNS>
const NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_intmin</NAME>
<RETURNS>nsp_int_union </RETURNS>
const NspIMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_euclide</NAME>
<RETURNS>void </RETURNS>
gint32 a, gint32 b, gint32 res[]
</FUNCTION>
<STRUCT>
<NAME>NspTypeSpRowMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSpRowMatrix</NAME>
struct _NspTypeSpRowMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};

</STRUCT>
<TYPEDEF>
<NAME>SpRow</NAME>
typedef struct _sprow  SpRow ;
</TYPEDEF>
<STRUCT>
<NAME>sprow</NAME>
struct _sprow {
  int size,iw ; /* size of a row, iw : used for working storage*/
  int *J   ; /* pointer to an int array giving the columns or row i 
		in increasing order */
  union { 
    double *R;     /* Pointer on real values */
    doubleC *C;    /* Pointer on complex values */
    int *I;        /* Pointer on integer values */
  };
};
  
</STRUCT>
<STRUCT>
<NAME>NspSpRowmatrix</NAME>
struct _NspSpRowmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeSpRowMatrix *type; 
  /*< public >*/
  char rc_type;        /* 'r' or 'i' : real or complex matrix */
  int n,m;   /* mn should be removed since m*n can be bigger than int 
		 * Warning: the order n,m should be the inverse to the 
		 * one implemented in _NspSpColmatrix. Thus we can cast 
		 * from _NspSpColmatrix to _NspSpRowmatrix
		 */
  SpRow **D; /* array of size m giving the Rows datas */
  char convert; /* 't' : the matrix is stored in triplet , 'n': triplet not used   */
  nsp_sparse_triplet triplet; 
} ;

</STRUCT>
<VARIABLE>
<NAME>nsp_type_sprowmatrix_id</NAME>
extern int nsp_type_sprowmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_sprowmatrix</NAME>
extern NspTypeSpRowMatrix *nsp_type_sprowmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_sprowmatrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_sprowmatrix</NAME>
<RETURNS>NspTypeSpRowMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_sprowmatrix</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSPROW</NAME>
#define NULLSPROW (  NspSpRowMatrix *) 0
</MACRO>
<FUNCTION>
<NAME>SpRowObj</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSpRowMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSpMat</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSpRowCopy</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSpRow</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealSpRow</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_row_destroy</NAME>
<RETURNS>void </RETURNS>
SpRow *Row
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_nnz</NAME>
<RETURNS>int </RETURNS>
const NspSpRowMatrix *HMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_info</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *Sp, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_print</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *Sp, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_copy</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_object</NAME>
<RETURNS>NspSpRowMatrix   *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_create</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
char *name, char type, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sparse</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
char *name,NspMatrix *RC, NspMatrix *Values, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_get</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspMatrix **RC, NspMatrix **Values
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_resize_row</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *Sp, int i, int n
</FUNCTION>
<FUNCTION>
<NAME>SpRowRowDestroy</NAME>
<RETURNS>void </RETURNS>
SpRow *Row
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_redim</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_enlarge_rows</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *Sp, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_concatr</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_concatd</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_concatdiag</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_store</NAME>
<RETURNS>void  </RETURNS>
NspSpRowMatrix *A, int r, int c, int col, NspSpRowMatrix *B, int r1, int c1
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_insert_elt</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int i, int j, NspSpRowMatrix *B, int rb, int cb
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_delete_elt</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int row, int col, int amin, int amax
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_get_elt</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *B, int i, int j
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_set_rowcol</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspObject *Rows, NspObject *Cols, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_set_row</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspObject *Inds, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_delete_cols</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspObject *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_compress_row</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_compress_row_simple</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_delete_rows</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspObject *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_extract</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspObject *Rows, NspObject *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_extract_elts</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspObject *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_extract_cols</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspObject *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_extract_rows</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspObject *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_diag_extract</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_set_diag</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_diag_create</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mult</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mult_sp_m</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A, NspMatrix *X, NspMatrix *Res
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mult_m_sp</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *X,NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mult_scal</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_complexify</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_setr</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_seti</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_from_mat</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_to_mat</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *Sp
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_transpose</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
const NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_add</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sub</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_multtt</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mult_scal</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_op_scal</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B, int *flag, char op
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_clean</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int rhs, double epsa, double epsr
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_maximinitt_g</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B, int flag, int minmaxflag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_maxitt</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B, int flag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_minitt</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B, int flag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_triu</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A,int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_tril</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A,int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_ones</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_eye</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_zeros</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_realpart</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_imagpart</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_isreal</NAME>
<RETURNS>int </RETURNS>
const NspSpRowMatrix *A, int strict
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sum</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_maxi</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, int dim, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mini</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, int dim, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_eye</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_ones</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_zeros</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_acos</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_acosh</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_asin</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_asinh</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_atan</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_atanh</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_ceil</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_int</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_floor</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_round</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sign</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_tan</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_tanh</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_abs</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_erf</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_arg</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_conj</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_cos</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_cosh</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_expel</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_logel</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sin</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sinh</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sqrtel</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_minus</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_find</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int lhs, NspMatrix **Res1, NspMatrix **Res2, NspMatrix **V
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_rand</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m,int n,double sparsity,char crand
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprow_update_from_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprow_set_triplet_from_m</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *M,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprow_alloc_col_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *M,int nzmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprow_realloc_col_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *M,int nzmax
</FUNCTION>
<MACRO>
<NAME>SHREXT_NAME</NAME>
#define SHREXT_NAME ".dll"
</MACRO>
<MACRO>
<NAME>SHREXT_NAME</NAME>
#define SHREXT_NAME ".so"
</MACRO>
<MACRO>
<NAME>COMPLETED</NAME>
#define COMPLETED 0
</MACRO>
<MACRO>
<NAME>MORE_THAN_MAXSTEP_NEEDED</NAME>
#define MORE_THAN_MAXSTEP_NEEDED 1
</MACRO>
<MACRO>
<NAME>EXCESS_ACCURACY_REQUESTED</NAME>
#define EXCESS_ACCURACY_REQUESTED 2
</MACRO>
<MACRO>
<NAME>ILLEGAL_INPUT_DETECTED</NAME>
#define ILLEGAL_INPUT_DETECTED 3    /* this one should leads to an error and so should not be used */
</MACRO>
<MACRO>
<NAME>REPEATED_ERROR_TEST_FAILURE</NAME>
#define REPEATED_ERROR_TEST_FAILURE 4 /* same remark ? */
</MACRO>
<MACRO>
<NAME>REPEATED_CONVERGENCE_FAILURE</NAME>
#define REPEATED_CONVERGENCE_FAILURE 5
</MACRO>
<MACRO>
<NAME>ERROR_WEIGHT_BECAME_ZERO</NAME>
#define ERROR_WEIGHT_BECAME_ZERO 6
</MACRO>
<MACRO>
<NAME>STIFFNESS_DETECTED</NAME>
#define STIFFNESS_DETECTED 7
</MACRO>
<MACRO>
<NAME>TIME_STEP_BECOME_TOO_SMALL</NAME>
#define TIME_STEP_BECOME_TOO_SMALL 8
</MACRO>
<MACRO>
<NAME>FCT_EVAL_FAIL</NAME>
#define FCT_EVAL_FAIL 9
</MACRO>
<MACRO>
<NAME>MALLOC_FAIL</NAME>
#define MALLOC_FAIL 10
</MACRO>
<USER_FUNCTION>
<NAME>ode_f</NAME>
<RETURNS>int </RETURNS>
const int *neq,const double *t ,const double *y,double *yd, void *param
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>ode_jac</NAME>
<RETURNS>int </RETURNS>
const int *neq,const double * t,const double * y,const int* ml,
		       const int *mu, double *pd, const int *nrpd, void *param
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_dopri5</NAME>
<RETURNS>int </RETURNS>
int n, ode_f fcn, void *param, double x, double *y, double xend, double hmax,double *h0, double rtol, const double *atol, int itol, int maxstep,int nstiff, double safe, double beta, double fac1, double fac2,int task, Boolean warning, double *yout, double *xout, int nout, int *noutrel
</FUNCTION>
<FUNCTION>
<NAME>C2F</NAME>
<RETURNS>int </RETURNS>
lsoda)(ode_f f,int *neq, double *y, double *t, double *tout, int *itol,double *rtol, const double *atol, int *itask, int *istate, int *iopt,double *rwork, int *lrw, int *iwork, int *liw, ode_jac jac, int *jt,void *param
</FUNCTION>
<FUNCTION>
<NAME>C2F</NAME>
<RETURNS>int </RETURNS>
lsode)(ode_f f,int *neq, double *y, double *t, double *tout, int *itol,double *rtol, const double *atol, int *itask, int *istate, int *iopt,double *rwork, int *lrw, int *iwork, int *liw, ode_jac jac, int *mf, void *param
</FUNCTION>
<STRUCT>
<NAME>NspGraphic</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGraphic</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGraphic</NAME>
struct _NspTypeGraphic {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 45 "codegen/graphic.override"

  draw_func *draw; 
  translate_func *translate;
  rotate_func *rotate;
  scale_func *scale;
  bounds_func *bounds;
  link_figure_func *link_figure;
  unlink_figure_func *unlink_figure;
  children_func *children;
  zmean_func *zmean; 
  n_faces_func *n_faces;
  invalidate_func *invalidate;


#line 78 "./graphic.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_graphic</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_graphic</NAME>
struct _nsp_graphic {
  gboolean hilited;
  gboolean show;
  void* Fig;
  void* Axe;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspGraphic</NAME>
struct _NspGraphic {
  /*< private >*/
  NspObject father;
  NspTypeGraphic*type;
  /*< public >*/
  nsp_graphic *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_graphic_id</NAME>
extern int nsp_type_graphic_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_graphic</NAME>
extern NspTypeGraphic *nsp_type_graphic;
</VARIABLE>
<FUNCTION>
<NAME>new_type_graphic</NAME>
<RETURNS>NspTypeGraphic *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_graphic</NAME>
<RETURNS>NspGraphic *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLGRAPHIC</NAME>
#define NULLGRAPHIC (NspGraphic*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_graphic_create</NAME>
<RETURNS>NspGraphic *</RETURNS>
const char *name,gboolean hilited,gboolean show,void* Fig,void* Axe,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_create_default</NAME>
<RETURNS>NspGraphic *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_copy</NAME>
<RETURNS>NspGraphic *</RETURNS>
NspGraphic *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_destroy</NAME>
<RETURNS>void </RETURNS>
NspGraphic *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_info</NAME>
<RETURNS>int </RETURNS>
NspGraphic *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_print</NAME>
<RETURNS>int </RETURNS>
NspGraphic *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_latex</NAME>
<RETURNS>int </RETURNS>
NspGraphic *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_object</NAME>
<RETURNS>NspGraphic *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGraphicObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsGraphic</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetGraphicCopy</NAME>
<RETURNS>NspGraphic *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGraphic</NAME>
<RETURNS>NspGraphic *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_create_partial</NAME>
<RETURNS>int </RETURNS>
NspGraphic *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspGraphic *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_copy_partial</NAME>
<RETURNS>NspGraphic *</RETURNS>
NspGraphic *H,NspGraphic *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_full_copy_partial</NAME>
<RETURNS>NspGraphic *</RETURNS>
NspGraphic *H,NspGraphic *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_full_copy</NAME>
<RETURNS>NspGraphic *</RETURNS>
NspGraphic *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_check_values</NAME>
<RETURNS>int </RETURNS>
NspGraphic *H
</FUNCTION>
<FUNCTION>
<NAME>int_graphic_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_xdr_load_partial</NAME>
<RETURNS>NspGraphic *</RETURNS>
XDR *xdrs, NspGraphic *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspGraphic *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_invalidate</NAME>
<RETURNS>void </RETURNS>
NspGraphic *G
</FUNCTION>
<FUNCTION>
<NAME>nsp_graphic_intersect_rectangle</NAME>
<RETURNS>int </RETURNS>
NspGraphic *G,const GdkRectangle *rect
</FUNCTION>
<STRUCT>
<NAME>NspCurve</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeCurve</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeCurve</NAME>
struct _NspTypeCurve {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./curve.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_curve</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_curve</NAME>
struct _nsp_curve {
  int mark;
  int width;
  int style;
  int color;
  int mode;
  NspMatrix* Pts;
  char* legend;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspCurve</NAME>
struct _NspCurve {
  /*< private >*/
  NspGraphic father;
  NspTypeCurve*type;
  /*< public >*/
  nsp_curve *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_curve_id</NAME>
extern int nsp_type_curve_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_curve</NAME>
extern NspTypeCurve *nsp_type_curve;
</VARIABLE>
<FUNCTION>
<NAME>new_type_curve</NAME>
<RETURNS>NspTypeCurve *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_curve</NAME>
<RETURNS>NspCurve *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCURVE</NAME>
#define NULLCURVE (NspCurve*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_curve_create</NAME>
<RETURNS>NspCurve *</RETURNS>
const char *name,int mark,int width,int style,int color,int mode,NspMatrix* Pts,char* legend,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_create_default</NAME>
<RETURNS>NspCurve *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_copy</NAME>
<RETURNS>NspCurve *</RETURNS>
NspCurve *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_destroy</NAME>
<RETURNS>void </RETURNS>
NspCurve *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_info</NAME>
<RETURNS>int </RETURNS>
NspCurve *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_print</NAME>
<RETURNS>int </RETURNS>
NspCurve *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_latex</NAME>
<RETURNS>int </RETURNS>
NspCurve *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_object</NAME>
<RETURNS>NspCurve *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsCurveObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsCurve</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetCurveCopy</NAME>
<RETURNS>NspCurve *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetCurve</NAME>
<RETURNS>NspCurve *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_create_partial</NAME>
<RETURNS>int </RETURNS>
NspCurve *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspCurve *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_copy_partial</NAME>
<RETURNS>NspCurve *</RETURNS>
NspCurve *H,NspCurve *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_full_copy_partial</NAME>
<RETURNS>NspCurve *</RETURNS>
NspCurve *H,NspCurve *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_full_copy</NAME>
<RETURNS>NspCurve *</RETURNS>
NspCurve *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_check_values</NAME>
<RETURNS>int </RETURNS>
NspCurve *H
</FUNCTION>
<FUNCTION>
<NAME>int_curve_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_xdr_load_partial</NAME>
<RETURNS>NspCurve *</RETURNS>
XDR *xdrs, NspCurve *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_curve_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspCurve *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_libdir</NAME>
<RETURNS>const char *</RETURNS>
int num
</FUNCTION>
<FUNCTION>
<NAME>nsp_enter_macros</NAME>
<RETURNS>int </RETURNS>
const char *dir_name,int recursive,int compile
</FUNCTION>
<FUNCTION>
<NAME>nsp_delete_macros</NAME>
<RETURNS>int </RETURNS>
const char *dirname
</FUNCTION>
<FUNCTION>
<NAME>nsp_find_macro</NAME>
<RETURNS>NspObject *</RETURNS>
const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_init_macro_table</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_macro_table_reset_cache</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_enter_function</NAME>
<RETURNS>int </RETURNS>
const char *str, int Int, int Num
</FUNCTION>
<FUNCTION>
<NAME>nsp_delete_function</NAME>
<RETURNS>void </RETURNS>
const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_find_function</NAME>
<RETURNS>int </RETURNS>
const char *str, int *Int, int *Num
</FUNCTION>
<FUNCTION>
<NAME>nsp_init_function_table</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_find_function_by_id</NAME>
<RETURNS>int </RETURNS>
char *key, int Int, int Num
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_function_table</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_delete_interface_functions</NAME>
<RETURNS>void </RETURNS>
int Int
</FUNCTION>
<STRUCT>
<NAME>NspGrArc</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGrArc</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGrArc</NAME>
struct _NspTypeGrArc {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./grarc.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_grarc</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_grarc</NAME>
struct _nsp_grarc {
  double x;
  double y;
  double w;
  double h;
  double a1;
  double a2;
  int fill_color;
  int thickness;
  int color;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspGrArc</NAME>
struct _NspGrArc {
  /*< private >*/
  NspGraphic father;
  NspTypeGrArc*type;
  /*< public >*/
  nsp_grarc *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_grarc_id</NAME>
extern int nsp_type_grarc_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_grarc</NAME>
extern NspTypeGrArc *nsp_type_grarc;
</VARIABLE>
<FUNCTION>
<NAME>new_type_grarc</NAME>
<RETURNS>NspTypeGrArc *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_grarc</NAME>
<RETURNS>NspGrArc *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLGRARC</NAME>
#define NULLGRARC (NspGrArc*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_grarc_create</NAME>
<RETURNS>NspGrArc *</RETURNS>
const char *name,double x,double y,double w,double h,double a1,double a2,int fill_color,int thickness,int color,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_create_default</NAME>
<RETURNS>NspGrArc *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_copy</NAME>
<RETURNS>NspGrArc *</RETURNS>
NspGrArc *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_destroy</NAME>
<RETURNS>void </RETURNS>
NspGrArc *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_info</NAME>
<RETURNS>int </RETURNS>
NspGrArc *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_print</NAME>
<RETURNS>int </RETURNS>
NspGrArc *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_latex</NAME>
<RETURNS>int </RETURNS>
NspGrArc *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_object</NAME>
<RETURNS>NspGrArc *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGrArcObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsGrArc</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetGrArcCopy</NAME>
<RETURNS>NspGrArc *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGrArc</NAME>
<RETURNS>NspGrArc *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_create_partial</NAME>
<RETURNS>int </RETURNS>
NspGrArc *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspGrArc *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_copy_partial</NAME>
<RETURNS>NspGrArc *</RETURNS>
NspGrArc *H,NspGrArc *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_full_copy_partial</NAME>
<RETURNS>NspGrArc *</RETURNS>
NspGrArc *H,NspGrArc *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_full_copy</NAME>
<RETURNS>NspGrArc *</RETURNS>
NspGrArc *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_check_values</NAME>
<RETURNS>int </RETURNS>
NspGrArc *H
</FUNCTION>
<FUNCTION>
<NAME>int_grarc_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_xdr_load_partial</NAME>
<RETURNS>NspGrArc *</RETURNS>
XDR *xdrs, NspGrArc *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_grarc_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspGrArc *M
</FUNCTION>
<VARIABLE>
<NAME>int_bmatrix_b2m</NAME>
extern function int_bmatrix_b2m;
</VARIABLE>
<VARIABLE>
<NAME>int_bmatrix_setrc</NAME>
extern function int_bmatrix_setrc;
</VARIABLE>
<STRUCT>
<NAME>NspTypeIVect</NAME>
typedef struct _NspTypeIVect { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeIVect;
</STRUCT>
<STRUCT>
<NAME>NspIvect</NAME>
struct _NspIvect {
  /*< private >*/
  NspObject father; 
  NspTypeIVect *type; 
  /*< public >*/
  int first,step,last ; /* implicit bounds  */
  int flag ;               /* set to 1 if 1:$ or : else set to 0 */
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_ivect_id</NAME>
extern int nsp_type_ivect_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_ivect</NAME>
extern NspTypeIVect *nsp_type_ivect;
</VARIABLE>
<FUNCTION>
<NAME>new_type_ivect</NAME>
<RETURNS>NspTypeIVect *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_ivect</NAME>
<RETURNS>NspIVect *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLIVECT</NAME>
#define NULLIVECT (NspIVect*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_ivect_object</NAME>
<RETURNS>NspIVect *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_loop</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject * O, NspObject * O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_create</NAME>
<RETURNS>NspIVect *</RETURNS>
char *name, int first, int step, int last, int flag
</FUNCTION>
<FUNCTION>
<NAME>IsIVectF</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_copy</NAME>
<RETURNS>NspIVect *</RETURNS>
NspIVect *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_destroy</NAME>
<RETURNS>void </RETURNS>
NspIVect *IV
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_info</NAME>
<RETURNS>int </RETURNS>
NspIVect *IV, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_print</NAME>
<RETURNS>int </RETURNS>
NspIVect *IV, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_2_mat</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspIVect *IV
</FUNCTION>
<FUNCTION>
<NAME>IsIVect</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_count</NAME>
<RETURNS>int </RETURNS>
NspIVect *iv
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_count_with_min_max</NAME>
<RETURNS>int </RETURNS>
NspIVect *iv, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>IsIVectObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetIVect</NAME>
<RETURNS>NspIVect *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_gsort</NAME>
<RETURNS>int </RETURNS>
int *xI, double *xD, int *ind, int *iflag, int *m, int *n,nsp_const_string type,nsp_const_string iord
</FUNCTION>
<ENUM>
<NAME>nsp_sort</NAME>
typedef enum {sort_g,sort_gs,sort_gm,sort_c,sort_r,sort_lr ,sort_lc ,sort_ldc,sort_ldr, sort_gb,sort_gd} nsp_sort;
</ENUM>
<ENUM>
<NAME>nsp_test_sort</NAME>
typedef enum {test_sort_g, test_sort_c, test_sort_r, test_sort_lc , test_sort_lr} nsp_test_sort;
</ENUM>
<FUNCTION>
<NAME>nsp_matrix_sort</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspObject **Index,int ind_flag,char dir, nsp_sort type, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_column_sort</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspObject **Index,int ind_flag,char dir, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_row_sort</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspObject **Index,int ind_flag,char dir, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_lexical_column_sort</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspObject **Index,int ind_flag,char dir,char mode, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_lexical_row_sort</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspObject **Index,int ind_flag,char dir,char mode, char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_sort</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspObject **Index,int ind_flag,char dir, int type,char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_column_sort</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspObject **Index,int ind_flag,char dir,char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_row_sort</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspObject **Index,int ind_flag,char dir,char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_lexical_column_sort</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspObject **Index,int ind_flag,char dir,char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_lexical_row_sort</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspObject **Index,int ind_flag,char dir,char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_sort</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A,NspObject **Index,int ind_flag,char dir, nsp_sort type,char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_column_sort</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A,NspObject **Index,int ind_flag,char dir,char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_row_sort</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A,NspObject **Index,int ind_flag,char dir,char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_lexical_column_sort</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A,NspObject **Index,int ind_flag,char dir,char mode,char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_imatrix_lexical_row_sort</NAME>
<RETURNS>int </RETURNS>
NspIMatrix *A,NspObject **Index,int ind_flag,char dir,char mode,char ind_type
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_col_sort_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_col_sort_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_col_sort_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<MACRO>
<NAME>NSP_ITYPE_DECLARE</NAME>
#define NSP_ITYPE_DECLARE(name)						\
  extern void name##gint(gint *a,int *ind,int flag,int n,int p,char dir); \
  extern void name##guint(guint *a,int *ind,int flag,int n,int p,char dir); \
  extern void name##gshort(gshort *a,int *ind,int flag,int n,int p,char dir); \
  extern void name##gushort(gushort *a,int *ind,int flag,int n,int p,char dir);	\
  extern void name##glong(glong *a,int *ind,int flag,int n,int p,char dir); \
  extern void name##gulong(gulong *a,int *ind,int flag,int n,int p,char dir); \
  extern void name##gint8(gint8 *a,int *ind,int flag,int n,int p,char dir); \
  extern void name##guint8(guint8 *a,int *ind,int flag,int n,int p,char dir); \
  extern void name##gint16(gint16 *a,int *ind,int flag,int n,int p,char dir); \
  extern void name##guint16(guint16 *a,int *ind,int flag,int n,int p,char dir);	\
  extern void name##gint32(gint32 *a,int *ind,int flag,int n,int p,char dir); \
  extern void name##guint32(guint32 *a,int *ind,int flag,int n,int p,char dir);	\
  extern void name##gint64(gint64 *a,int *ind,int flag,int n,int p,char dir); \
  extern void name##guint64(guint64 *a,int *ind,int flag,int n,int p,char dir)	
</MACRO>
<FUNCTION>
<NAME>nsp_qsort_gen_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexicol_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexicol_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexicol_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexirow_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexirow_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexirow_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_row_sort_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_row_sort_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_row_sort_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gint</NAME>
<RETURNS>void </RETURNS>
gint *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_guint</NAME>
<RETURNS>void </RETURNS>
guint *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gshort</NAME>
<RETURNS>void </RETURNS>
gshort *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gushort</NAME>
<RETURNS>void </RETURNS>
gushort *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_glong</NAME>
<RETURNS>void </RETURNS>
glong *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gulong</NAME>
<RETURNS>void </RETURNS>
gulong *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gint8</NAME>
<RETURNS>void </RETURNS>
gint8 *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_guint8</NAME>
<RETURNS>void </RETURNS>
guint8 *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gint16</NAME>
<RETURNS>void </RETURNS>
gint16 *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_guint16</NAME>
<RETURNS>void </RETURNS>
guint16 *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gint32</NAME>
<RETURNS>void </RETURNS>
gint32 *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_guint32</NAME>
<RETURNS>void </RETURNS>
guint32 *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gint64</NAME>
<RETURNS>void </RETURNS>
gint64 *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_guint64</NAME>
<RETURNS>void </RETURNS>
guint64 *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_int</NAME>
<RETURNS>void </RETURNS>
int x[], int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_double</NAME>
<RETURNS>void </RETURNS>
double x[], int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_gint</NAME>
<RETURNS>void </RETURNS>
gint *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_guint</NAME>
<RETURNS>void </RETURNS>
guint *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_gshort</NAME>
<RETURNS>void </RETURNS>
gshort *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_gushort</NAME>
<RETURNS>void </RETURNS>
gushort *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_glong</NAME>
<RETURNS>void </RETURNS>
glong *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_gulong</NAME>
<RETURNS>void </RETURNS>
gulong *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_gint8</NAME>
<RETURNS>void </RETURNS>
gint8 *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_guint8</NAME>
<RETURNS>void </RETURNS>
guint8 *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_gint16</NAME>
<RETURNS>void </RETURNS>
gint16 *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_guint16</NAME>
<RETURNS>void </RETURNS>
guint16 *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_gint32</NAME>
<RETURNS>void </RETURNS>
gint32 *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_guint32</NAME>
<RETURNS>void </RETURNS>
guint32 *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_gint64</NAME>
<RETURNS>void </RETURNS>
gint64 *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_guint64</NAME>
<RETURNS>void </RETURNS>
guint64 *a, int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_int</NAME>
<RETURNS>void </RETURNS>
int x[], int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_double</NAME>
<RETURNS>void </RETURNS>
double x[], int n, int p[], char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string x[], int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_gint</NAME>
<RETURNS>void </RETURNS>
gint *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_guint</NAME>
<RETURNS>void </RETURNS>
guint *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_gshort</NAME>
<RETURNS>void </RETURNS>
gshort *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_gushort</NAME>
<RETURNS>void </RETURNS>
gushort *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_glong</NAME>
<RETURNS>void </RETURNS>
glong *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_gulong</NAME>
<RETURNS>void </RETURNS>
gulong *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_gint8</NAME>
<RETURNS>void </RETURNS>
gint8 *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_guint8</NAME>
<RETURNS>void </RETURNS>
guint8 *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_gint16</NAME>
<RETURNS>void </RETURNS>
gint16 *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_guint16</NAME>
<RETURNS>void </RETURNS>
guint16 *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_gint32</NAME>
<RETURNS>void </RETURNS>
gint32 *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_guint32</NAME>
<RETURNS>void </RETURNS>
guint32 *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_gint64</NAME>
<RETURNS>void </RETURNS>
gint64 *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqsort_bp_guint64</NAME>
<RETURNS>void </RETURNS>
guint64 *a,int n, int p[],char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_int</NAME>
<RETURNS>int </RETURNS>
int *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_double</NAME>
<RETURNS>int </RETURNS>
double *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_gint</NAME>
<RETURNS>int </RETURNS>
gint *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_guint</NAME>
<RETURNS>int </RETURNS>
guint *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_gshort</NAME>
<RETURNS>int </RETURNS>
gshort *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_gushort</NAME>
<RETURNS>int </RETURNS>
gushort *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_glong</NAME>
<RETURNS>int </RETURNS>
glong *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_gulong</NAME>
<RETURNS>int </RETURNS>
gulong *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_gint8</NAME>
<RETURNS>int </RETURNS>
gint8 *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_guint8</NAME>
<RETURNS>int </RETURNS>
guint8 *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_gint16</NAME>
<RETURNS>int </RETURNS>
gint16 *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_guint16</NAME>
<RETURNS>int </RETURNS>
guint16 *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_gint32</NAME>
<RETURNS>int </RETURNS>
gint32 *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_guint32</NAME>
<RETURNS>int </RETURNS>
guint32 *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_gint64</NAME>
<RETURNS>int </RETURNS>
gint64 *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_guint64</NAME>
<RETURNS>int </RETURNS>
guint64 *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_incr_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_decr_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_incr_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_decr_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_incr_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_decr_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<MACRO>
<NAME>ELT_TYPE</NAME>
#define ELT_TYPE int 
</MACRO>
<STRUCT>
<NAME>NspClassARef</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeClassARef</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeClassARef</NAME>
struct _NspTypeClassARef {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 43 "./classaref.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_classaref</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_classaref</NAME>
struct _nsp_classaref {
  int cla_color;
  int cla_thickness;
  NspMatrix* cla_val;
  NspBMatrix* cla_bval;
  NspList* cla_lval;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspClassARef</NAME>
struct _NspClassARef {
  /*< private >*/
  NspObject father;
  NspTypeClassARef*type;
  /*< public >*/
  nsp_classaref *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_classaref_id</NAME>
extern int nsp_type_classaref_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_classaref</NAME>
extern NspTypeClassARef *nsp_type_classaref;
</VARIABLE>
<FUNCTION>
<NAME>new_type_classaref</NAME>
<RETURNS>NspTypeClassARef *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_classaref</NAME>
<RETURNS>NspClassARef *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCLASSAREF</NAME>
#define NULLCLASSAREF (NspClassARef*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_classaref_create</NAME>
<RETURNS>NspClassARef *</RETURNS>
const char *name,int cla_color,int cla_thickness,NspMatrix* cla_val,NspBMatrix* cla_bval,NspList* cla_lval,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_create_default</NAME>
<RETURNS>NspClassARef *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_copy</NAME>
<RETURNS>NspClassARef *</RETURNS>
NspClassARef *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_destroy</NAME>
<RETURNS>void </RETURNS>
NspClassARef *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_info</NAME>
<RETURNS>int </RETURNS>
NspClassARef *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_print</NAME>
<RETURNS>int </RETURNS>
NspClassARef *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_latex</NAME>
<RETURNS>int </RETURNS>
NspClassARef *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_object</NAME>
<RETURNS>NspClassARef *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsClassARefObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsClassARef</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetClassARefCopy</NAME>
<RETURNS>NspClassARef *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetClassARef</NAME>
<RETURNS>NspClassARef *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_create_partial</NAME>
<RETURNS>int </RETURNS>
NspClassARef *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspClassARef *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_copy_partial</NAME>
<RETURNS>NspClassARef *</RETURNS>
NspClassARef *H,NspClassARef *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_full_copy_partial</NAME>
<RETURNS>NspClassARef *</RETURNS>
NspClassARef *H,NspClassARef *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_full_copy</NAME>
<RETURNS>NspClassARef *</RETURNS>
NspClassARef *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_check_values</NAME>
<RETURNS>int </RETURNS>
NspClassARef *H
</FUNCTION>
<FUNCTION>
<NAME>int_classaref_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_xdr_load_partial</NAME>
<RETURNS>NspClassARef *</RETURNS>
XDR *xdrs, NspClassARef *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_classaref_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspClassARef *M
</FUNCTION>
<STRUCT>
<NAME>NspTypeSerial</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>serial_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspSerial *M
</USER_FUNCTION>
<STRUCT>
<NAME>NspTypeSerial</NAME>
struct _NspTypeSerial { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};

</STRUCT>
<STRUCT>
<NAME>NspSerial</NAME>
struct _NspSerial {
  /*< private >*/
  NspObject father; 
  NspTypeSerial *type; 
  /*< public >*/
  char *val;
  int nbytes;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_serial_id</NAME>
extern int nsp_type_serial_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_serial</NAME>
extern NspTypeSerial *nsp_type_serial;
</VARIABLE>
<FUNCTION>
<NAME>new_type_serial</NAME>
<RETURNS>NspTypeSerial *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_serial</NAME>
<RETURNS>NspSerial *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSERIAL</NAME>
#define NULLSERIAL (NspSerial*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_serial_create</NAME>
<RETURNS>NspSerial *</RETURNS>
const char *name,const char *buf,int nbytes
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_copy</NAME>
<RETURNS>NspSerial *</RETURNS>
const NspSerial *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_destroy</NAME>
<RETURNS>void </RETURNS>
NspSerial *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_info</NAME>
<RETURNS>int </RETURNS>
NspSerial *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_print</NAME>
<RETURNS>int </RETURNS>
NspSerial *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_object</NAME>
<RETURNS>NspSerial *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSerialObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSerial</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSerialCopy</NAME>
<RETURNS>NspSerial *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSerial</NAME>
<RETURNS>NspSerial *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_unserialize</NAME>
<RETURNS>NspObject *</RETURNS>
const NspSerial *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_serialize</NAME>
<RETURNS>NspObject *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_to_matrix</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspSerial *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_serial</NAME>
<RETURNS>NspSerial *</RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_compress</NAME>
<RETURNS>NspSerial *</RETURNS>
const NspSerial *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_uncompress</NAME>
<RETURNS>NspSerial *</RETURNS>
const NspSerial *Sz
</FUNCTION>
<STRUCT>
<NAME>NspFigureData</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeFigureData</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeFigureData</NAME>
struct _NspTypeFigureData {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 43 "./figuredata.h"
};

</STRUCT>
<STRUCT>
<NAME>NspFigureData</NAME>
struct _NspFigureData {
  /*< private >*/
  NspObject father;
  NspTypeFigureData*type;
  /*< public >*/
    int color;
  int background;
  NspMatrix* colormap;
  int dashes;
  int font;
  int font_size;
  int foreground;
  int hidden3d;
  int line_mode;
  int line_style;
  int mark;
  int mark_size;
  int pattern;
  int pixmap;
  int thickness;
  int use_color;
  gboolean auto_clear;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_figuredata_id</NAME>
extern int nsp_type_figuredata_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_figuredata</NAME>
extern NspTypeFigureData *nsp_type_figuredata;
</VARIABLE>
<FUNCTION>
<NAME>new_type_figuredata</NAME>
<RETURNS>NspTypeFigureData *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_figuredata</NAME>
<RETURNS>NspFigureData *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLFIGUREDATA</NAME>
#define NULLFIGUREDATA (NspFigureData*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_figuredata_create</NAME>
<RETURNS>NspFigureData *</RETURNS>
const char *name,int color,int background,NspMatrix* colormap,int dashes,int font,int font_size,int foreground,int hidden3d,int line_mode,int line_style,int mark,int mark_size,int pattern,int pixmap,int thickness,int use_color,gboolean auto_clear,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_create_default</NAME>
<RETURNS>NspFigureData *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_copy</NAME>
<RETURNS>NspFigureData *</RETURNS>
NspFigureData *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_destroy</NAME>
<RETURNS>void </RETURNS>
NspFigureData *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_info</NAME>
<RETURNS>int </RETURNS>
NspFigureData *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_print</NAME>
<RETURNS>int </RETURNS>
NspFigureData *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_latex</NAME>
<RETURNS>int </RETURNS>
NspFigureData *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_object</NAME>
<RETURNS>NspFigureData *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsFigureDataObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsFigureData</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetFigureDataCopy</NAME>
<RETURNS>NspFigureData *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetFigureData</NAME>
<RETURNS>NspFigureData *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_create_partial</NAME>
<RETURNS>int </RETURNS>
NspFigureData *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspFigureData *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_copy_partial</NAME>
<RETURNS>NspFigureData *</RETURNS>
NspFigureData *H,NspFigureData *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_full_copy_partial</NAME>
<RETURNS>NspFigureData *</RETURNS>
NspFigureData *H,NspFigureData *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_full_copy</NAME>
<RETURNS>NspFigureData *</RETURNS>
NspFigureData *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_check_values</NAME>
<RETURNS>int </RETURNS>
NspFigureData *H
</FUNCTION>
<FUNCTION>
<NAME>int_figuredata_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_xdr_load_partial</NAME>
<RETURNS>NspFigureData *</RETURNS>
XDR *xdrs, NspFigureData *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_figuredata_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspFigureData *M
</FUNCTION>
<STRUCT>
<NAME>NspPolyline3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePolyline3d</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePolyline3d</NAME>
struct _NspTypePolyline3d {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./polyline3d.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_polyline3d</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_polyline3d</NAME>
struct _nsp_polyline3d {
  NspMatrix* Mcoord;
  void* Mcoord_l;
  NspMatrix* Mcolor;
  int* pos;  int pos_length;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspPolyline3d</NAME>
struct _NspPolyline3d {
  /*< private >*/
  NspGraphic father;
  NspTypePolyline3d*type;
  /*< public >*/
  nsp_polyline3d *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_polyline3d_id</NAME>
extern int nsp_type_polyline3d_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_polyline3d</NAME>
extern NspTypePolyline3d *nsp_type_polyline3d;
</VARIABLE>
<FUNCTION>
<NAME>new_type_polyline3d</NAME>
<RETURNS>NspTypePolyline3d *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_polyline3d</NAME>
<RETURNS>NspPolyline3d *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLPOLYLINE3D</NAME>
#define NULLPOLYLINE3D (NspPolyline3d*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_polyline3d_create</NAME>
<RETURNS>NspPolyline3d *</RETURNS>
const char *name,NspMatrix* Mcoord,void* Mcoord_l,NspMatrix* Mcolor,int* pos, int pos_length,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_create_default</NAME>
<RETURNS>NspPolyline3d *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_copy</NAME>
<RETURNS>NspPolyline3d *</RETURNS>
NspPolyline3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_destroy</NAME>
<RETURNS>void </RETURNS>
NspPolyline3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_info</NAME>
<RETURNS>int </RETURNS>
NspPolyline3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_print</NAME>
<RETURNS>int </RETURNS>
NspPolyline3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_latex</NAME>
<RETURNS>int </RETURNS>
NspPolyline3d *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_object</NAME>
<RETURNS>NspPolyline3d *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsPolyline3dObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsPolyline3d</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetPolyline3dCopy</NAME>
<RETURNS>NspPolyline3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetPolyline3d</NAME>
<RETURNS>NspPolyline3d *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_create_partial</NAME>
<RETURNS>int </RETURNS>
NspPolyline3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspPolyline3d *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_copy_partial</NAME>
<RETURNS>NspPolyline3d *</RETURNS>
NspPolyline3d *H,NspPolyline3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_full_copy_partial</NAME>
<RETURNS>NspPolyline3d *</RETURNS>
NspPolyline3d *H,NspPolyline3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_full_copy</NAME>
<RETURNS>NspPolyline3d *</RETURNS>
NspPolyline3d *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_check_values</NAME>
<RETURNS>int </RETURNS>
NspPolyline3d *H
</FUNCTION>
<FUNCTION>
<NAME>int_polyline3d_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_xdr_load_partial</NAME>
<RETURNS>NspPolyline3d *</RETURNS>
XDR *xdrs, NspPolyline3d *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_polyline3d_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspPolyline3d *M
</FUNCTION>
<FUNCTION>
<NAME>drawsegments3D</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double *x,double *y,double *z, int n, int *style, int iflag
</FUNCTION>
<MACRO>
<NAME>LOCK_DIR_FLAG</NAME>
#define LOCK_DIR_FLAG 0x0f 
</MACRO>
<MACRO>
<NAME>LOCK_TYPE_FLAG</NAME>
#define LOCK_TYPE_FLAG 0xf0
</MACRO>
<ENUM>
<NAME>lock_dir</NAME>
typedef  enum { LD_NORTH=0, LD_SOUTH=1, LD_EAST=2, LD_WEST=3, LD_ANY=4 } lock_dir;
</ENUM>
<ENUM>
<NAME>lock_type</NAME>
typedef  enum { L_IN=0 <<4 ,L_OUT=1 <<4 ,L_EVIN=2 << 4,L_EVOUT=3 <<4 , L_SQP=4 <<4, L_SQM=5 <<4  } lock_type;
</ENUM>
<STRUCT>
<NAME>gr_port</NAME>
</STRUCT>
<STRUCT>
<NAME>gr_port</NAME>
struct _gr_port {
  NspObject *object_id ; /* object connected to the associated port or NULL */  
  void *object_sid;      /* used to keep track of connections while copying or saving */
  int lock;              /* object is connected through his lock point lock */
  int port;              /* and port number port */
};

</STRUCT>
<STRUCT>
<NAME>NspTypeGRint</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGRint</NAME>
struct _NspTypeGRint { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
  gr_get_hilited *get_hilited ;		     
  gr_set_hilited *set_hilited ;		     
  gr_get_show *get_show ;		     
  gr_set_show *set_show ;		     
  gr_set_pos *set_pos ;		     
  gr_get_pos *get_pos ;		     
  gr_resize *resize ;			     
  gr_update_locks *update_locks ;	     
  gr_contains_pt *contains_pt ;		     
  gr_control_near_pt *control_near_pt ;	     
  gr_lock_near_pt *lock_near_pt ;	     
  gr_move_control_init *move_control_init ;  
  gr_move_control *move_control ;	     

  gr_get_number_of_locks * get_number_of_locks;
  gr_get_number_of_ports * get_number_of_ports;
  gr_get_lock_connection * get_lock_connection;
  gr_get_lock_pos * get_lock_pos;
  gr_get_lock_dir * get_lock_dir;
  gr_set_lock_connection * set_lock_connection;
  gr_unset_lock_connection * unset_lock_connection;
  gr_is_lock_connectable * is_lock_connectable;
  gr_is_lock_connected * is_lock_connected;
  gr_set_lock_pos * set_lock_pos;
  gr_unlock *unlock ; 
};

</STRUCT>
<MACRO>
<NAME>GR_INT</NAME>
#define GR_INT(t) ((NspTypeGRint *) t)
</MACRO>
<VARIABLE>
<NAME>nsp_type_grint_id</NAME>
extern int nsp_type_grint_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_grint</NAME>
extern NspTypeGRint *nsp_type_grint;
</VARIABLE>
<FUNCTION>
<NAME>new_type_grint</NAME>
<RETURNS>NspTypeGRint *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval</NAME>
<RETURNS>int </RETURNS>
PList L1,Stack, int first, int rhs,int lhs,int display
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_arg</NAME>
<RETURNS>int </RETURNS>
PList L,Stack *stack, int i,int rhs,int lhs,int display
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_func</NAME>
<RETURNS>int </RETURNS>
NspObject *O,const char *str,int msuffix, Stack, int first, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_maybe_accelerated_op</NAME>
<RETURNS>int </RETURNS>
char *opname, int msuffix, accelerated_ops tab_id,Stack stack, int first, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_maybe_accelerated_binop</NAME>
<RETURNS>int </RETURNS>
const char *opname, int opcode, Stack stack, int first, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_dotplus</NAME>
<RETURNS>int </RETURNS>
Stack, int first, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_macro</NAME>
<RETURNS>int </RETURNS>
NspObject *OF,Stack,int first,int rhs,int opt,int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_method</NAME>
<RETURNS>int </RETURNS>
char *str, Stack stack, int first, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_macro_body</NAME>
<RETURNS>int </RETURNS>
NspObject *OF, Stack stack, int first, int rhs, int opt, int lhs,int display
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_extract</NAME>
<RETURNS>int </RETURNS>
Stack,int first,int rhs,int opt,int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_extract_cells</NAME>
<RETURNS>int </RETURNS>
Stack stack, int first, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_store_result</NAME>
<RETURNS>int </RETURNS>
char *str,Stack stack, int first
</FUNCTION>
<FUNCTION>
<NAME>nsp_interfaces</NAME>
<RETURNS>int </RETURNS>
int i, int num, Stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_stack</NAME>
<RETURNS>int </RETURNS>
Stack, int rhs, int opt, int lhs,char *message,char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_build_funcname</NAME>
<RETURNS>void </RETURNS>
const char *str,Stack *stack,int first,int rhs,char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_build_funcnameij</NAME>
<RETURNS>void </RETURNS>
const char *str,Stack *stack,int first,int i,int j,char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_void_seq_object_destroy</NAME>
<RETURNS>void </RETURNS>
Stack stack,int from, int to
</FUNCTION>
<FUNCTION>
<NAME>reorder_stack</NAME>
<RETURNS>int </RETURNS>
Stack stack, int ret
</FUNCTION>
<FUNCTION>
<NAME>nsp_parser_get_line</NAME>
<RETURNS>int </RETURNS>
PList L
</FUNCTION>
<USER_FUNCTION>
<NAME>Scig_command_handler</NAME>
<RETURNS>int </RETURNS>
char *
</USER_FUNCTION>
<FUNCTION>
<NAME>scig_command_handler_none</NAME>
<RETURNS>int </RETURNS>
char *command
</FUNCTION>
<FUNCTION>
<NAME>set_scig_command_handler</NAME>
<RETURNS>Scig_command_handler </RETURNS>
Scig_command_handler f
</FUNCTION>
<FUNCTION>
<NAME>reset_scig_command_handler</NAME>
<RETURNS>void </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>enqueue_nsp_command</NAME>
<RETURNS>int </RETURNS>
char *command
</FUNCTION>
<FUNCTION>
<NAME>checkqueue_nsp_command</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>lockqueue_nsp_command</NAME>
<RETURNS>void </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>unlockqueue_nsp_command</NAME>
<RETURNS>void </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>dequeue_nsp_command</NAME>
<RETURNS>int </RETURNS>
char *buf,int buf_len
</FUNCTION>
<ENUM>
<NAME>matint_copy_style</NAME>
typedef enum {
  nsp_matint_basic_copy_pointer, 
  nsp_matint_basic_copy_mat,     
  nsp_matint_basic_copy_int,     
  nsp_matint_basic_copy          
} matint_copy_style;
</ENUM>
<STRUCT>
<NAME>NspTypeMatint</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeMatint</NAME>
struct _NspTypeMatint {
  NSP_TYPE_OBJECT__
  /* added */
  matint_redim *redim; 
  matint_resize *resize;
  matint_free_elt *free_elt;
  matint_elt_size *elt_size;
  matint_clone *clone;
  matint_copy_elt *copy_elt;
  matint_enlarge *enlarge;
  matint_canonic *canonic;
  matint_copy_style copy_ind;
};

</STRUCT>
<MACRO>
<NAME>MAT_INT</NAME>
#define MAT_INT(t) ((NspTypeMatint *) t)
</MACRO>
<VARIABLE>
<NAME>nsp_type_matint_id</NAME>
extern int nsp_type_matint_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_matint</NAME>
extern NspTypeMatint *nsp_type_matint;
</VARIABLE>
<FUNCTION>
<NAME>new_type_matint</NAME>
<RETURNS>NspTypeMatint *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>matint_get_methods</NAME>
<RETURNS>NspMethods *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_tozero</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_delete_columns</NAME>
<RETURNS>int </RETURNS>
NspObject  *Obj,index_vector *index
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_delete_rows</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj, index_vector *index
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_delete_elements</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj, index_vector *index
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_delete_elements2</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj,int *indrow, int nr, int rmin, int rmax,int *indcol, int nc, int cmin, int cmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_extract_elements1</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *Obj,NspObject *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_extract_columns1</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *Obj,NspObject *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_extract_rows1</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *Obj,NspObject *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_extract1</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *Obj,NspObject *Rows, NspObject *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA, index_vector *index_r, index_vector *index_c, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_set_elts</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA, index_vector *index,  NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_set_elts1</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA, NspObject *Elts, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_concat_right</NAME>
<RETURNS>NspObject *</RETURNS>
 NspObject *ObjA, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_concat_right_bis</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_repmat</NAME>
<RETURNS>NspObject *</RETURNS>
const NspObject *ObjA, int m, int n
</FUNCTION>
<USER_FUNCTION>
<NAME>Fconcat_d</NAME>
<RETURNS>NspObject *</RETURNS>
const NspObject *, const NspObject *
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_matint_concat_down</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *ObjA, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_redim</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_concat_down_bis</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_concat_diag</NAME>
<RETURNS>NspObject *</RETURNS>
 NspObject *ObjA, NspObject *ObjB
</FUNCTION>
<ENUM>
<NAME>matint_workid</NAME>
typedef enum { matint_iwork1=0, matint_iwork2=1} matint_workid;
</ENUM>
<FUNCTION>
<NAME>get_index_vector_from_object</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj, index_vector *index
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_set_submatrix1</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA,NspObject *Row, NspObject *Col, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_perm_elem</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA, int p, int q, int dim_flag
</FUNCTION>
<FUNCTION>
<NAME>int_matint_cells_setrowscols</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_concat_diag</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_concat_down</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs, Fconcat_d F
</FUNCTION>
<FUNCTION>
<NAME>int_matint_concat_emptymat_and_mat</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_concatd</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_concatr</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_deletecols</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_deleteelts</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_deleteelts2</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_deleterows</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extract</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extractcols</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extractelts</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extractrows</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extractrows_mat</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extractrows_int</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extractrows_gen</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extractrows_pointer</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_redim</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_repmat</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_resize2vect</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_setrowscols</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_tozero</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_canonic</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *obj
</FUNCTION>
<FUNCTION>
<NAME>int_matint_isvector</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<STRUCT>
<NAME>NspSPolyhedron</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSPolyhedron</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSPolyhedron</NAME>
struct _NspTypeSPolyhedron {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 48 "./spolyhedron.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_spolyhedron</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_spolyhedron</NAME>
struct _nsp_spolyhedron {
  NspMatrix* Mcoord;
  NspMatrix* Mface;
  NspMatrix* Mval;
  double vmin;
  double vmax;
  int colmin;
  int colmax;
  int coloutmin;
  int coloutmax;
  gboolean mesh;
  gboolean mesh_only;
  int back_color;
  gboolean shade;
  void* Mcoord_l;
  int* pos;  int pos_length;
  int* fill;  int fill_length;
  double* vlevel;  int vlevel_length;
  int coldef;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspSPolyhedron</NAME>
struct _NspSPolyhedron {
  /*< private >*/
  NspGraphic father;
  NspTypeSPolyhedron*type;
  /*< public >*/
  nsp_spolyhedron *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_spolyhedron_id</NAME>
extern int nsp_type_spolyhedron_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_spolyhedron</NAME>
extern NspTypeSPolyhedron *nsp_type_spolyhedron;
</VARIABLE>
<FUNCTION>
<NAME>new_type_spolyhedron</NAME>
<RETURNS>NspTypeSPolyhedron *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_spolyhedron</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSPOLYHEDRON</NAME>
#define NULLSPOLYHEDRON (NspSPolyhedron*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_spolyhedron_create</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
const char *name,NspMatrix* Mcoord,NspMatrix* Mface,NspMatrix* Mval,double vmin,double vmax,int colmin,int colmax,int coloutmin,int coloutmax,gboolean mesh,gboolean mesh_only,int back_color,gboolean shade,void* Mcoord_l,int* pos, int pos_length,int* fill, int fill_length,double* vlevel, int vlevel_length,int coldef,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_create_default</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_copy</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
NspSPolyhedron *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_destroy</NAME>
<RETURNS>void </RETURNS>
NspSPolyhedron *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_info</NAME>
<RETURNS>int </RETURNS>
NspSPolyhedron *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_print</NAME>
<RETURNS>int </RETURNS>
NspSPolyhedron *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_latex</NAME>
<RETURNS>int </RETURNS>
NspSPolyhedron *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_object</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSPolyhedronObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSPolyhedron</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSPolyhedronCopy</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSPolyhedron</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_create_partial</NAME>
<RETURNS>int </RETURNS>
NspSPolyhedron *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspSPolyhedron *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_copy_partial</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
NspSPolyhedron *H,NspSPolyhedron *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_full_copy_partial</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
NspSPolyhedron *H,NspSPolyhedron *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_full_copy</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
NspSPolyhedron *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_check_values</NAME>
<RETURNS>int </RETURNS>
NspSPolyhedron *H
</FUNCTION>
<FUNCTION>
<NAME>int_spolyhedron_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_xdr_load_partial</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
XDR *xdrs, NspSPolyhedron *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspSPolyhedron *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_create_from_facets</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
char *name,double *xx,double *yy,double *zz,int m,int n,int *colors, int ncol ,int cmap_ncol
</FUNCTION>
<FUNCTION>
<NAME>nsp_spolyhedron_create_from_triplet</NAME>
<RETURNS>NspSPolyhedron *</RETURNS>
char *name,double *x,double *y,double *z,int m,int n, double *col,int ncol
</FUNCTION>
<STRUCT>
<NAME>grl_lock</NAME>
</STRUCT>
<STRUCT>
<NAME>grl_lock</NAME>
struct _grl_lock {
  gr_port port;  /* Only one port */
};

</STRUCT>
<STRUCT>
<NAME>NspLink</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeLink</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeLink</NAME>
struct _NspTypeLink {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
 
#line 93 "./link.h"
};

</STRUCT>
<STRUCT>
<NAME>nsp_link</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_link</NAME>
struct _nsp_link {
  void* object_sid;
  int color;
  int thickness;
  int background;
  NspMatrix* poly;
  grl_lock lock1;
  grl_lock lock2;
  int ref_count;
};

</STRUCT>
<STRUCT>
<NAME>NspLink</NAME>
struct _NspLink {
  /*< private >*/
  NspGraphic father;
  NspTypeLink*type;
  /*< public >*/
  nsp_link *obj;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_type_link_id</NAME>
extern int nsp_type_link_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_link</NAME>
extern NspTypeLink *nsp_type_link;
</VARIABLE>
<FUNCTION>
<NAME>new_type_link</NAME>
<RETURNS>NspTypeLink *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_link</NAME>
<RETURNS>NspLink *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLLINK</NAME>
#define NULLLINK (NspLink*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_link_create</NAME>
<RETURNS>NspLink *</RETURNS>
const char *name,void* object_sid,int color,int thickness,int background,NspMatrix* poly,grl_lock lock1,grl_lock lock2,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_create_default</NAME>
<RETURNS>NspLink *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_copy</NAME>
<RETURNS>NspLink *</RETURNS>
NspLink *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_destroy</NAME>
<RETURNS>void </RETURNS>
NspLink *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_info</NAME>
<RETURNS>int </RETURNS>
NspLink *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_print</NAME>
<RETURNS>int </RETURNS>
NspLink *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_latex</NAME>
<RETURNS>int </RETURNS>
NspLink *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_object</NAME>
<RETURNS>NspLink *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsLinkObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsLink</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetLinkCopy</NAME>
<RETURNS>NspLink *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetLink</NAME>
<RETURNS>NspLink *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_create_partial</NAME>
<RETURNS>int </RETURNS>
NspLink *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_destroy_partial</NAME>
<RETURNS>void </RETURNS>
NspLink *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_copy_partial</NAME>
<RETURNS>NspLink *</RETURNS>
NspLink *H,NspLink *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_full_copy_partial</NAME>
<RETURNS>NspLink *</RETURNS>
NspLink *H,NspLink *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_full_copy</NAME>
<RETURNS>NspLink *</RETURNS>
NspLink *self
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_check_values</NAME>
<RETURNS>int </RETURNS>
NspLink *H
</FUNCTION>
<FUNCTION>
<NAME>int_link_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_xdr_load_partial</NAME>
<RETURNS>NspLink *</RETURNS>
XDR *xdrs, NspLink *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_link_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspLink *M
</FUNCTION>
<FUNCTION>
<NAME>link_add_control</NAME>
<RETURNS>int </RETURNS>
NspLink *L,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>link_remove_control</NAME>
<RETURNS>int </RETURNS>
NspLink *L,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>link_create_n</NAME>
<RETURNS>NspLink *</RETURNS>
const char *name,int n,int color,int thickness
</FUNCTION>
<TYPEDEF>
<NAME>bool_t</NAME>
typedef unsigned int bool_t;
</TYPEDEF>
<TYPEDEF>
<NAME>int32_t</NAME>
typedef int int32_t;
</TYPEDEF>
<TYPEDEF>
<NAME>int8_t</NAME>
typedef signed char int8_t;
</TYPEDEF>
<TYPEDEF>
<NAME>uint8_t</NAME>
typedef unsigned char uint8_t;
</TYPEDEF>
<TYPEDEF>
<NAME>int16_t</NAME>
typedef signed short int16_t;
</TYPEDEF>
<TYPEDEF>
<NAME>uint16_t</NAME>
typedef unsigned short uint16_t;
</TYPEDEF>
<TYPEDEF>
<NAME>int64_t</NAME>
typedef __int64 int64_t;
</TYPEDEF>
<TYPEDEF>
<NAME>uint64_t</NAME>
typedef unsigned __int64 uint64_t;
</TYPEDEF>
<TYPEDEF>
<NAME>int64_t</NAME>
typedef long long int int64_t;
</TYPEDEF>
<TYPEDEF>
<NAME>uint64_t</NAME>
typedef unsigned long long int uint64_t;
</TYPEDEF>
<MACRO>
<NAME>BYTES_PER_XDR_UNIT</NAME>
#define BYTES_PER_XDR_UNIT	(4)
</MACRO>
<MACRO>
<NAME>RNDUP</NAME>
#define RNDUP(x)  ((((x) + BYTES_PER_XDR_UNIT - 1) / BYTES_PER_XDR_UNIT) \
		   * BYTES_PER_XDR_UNIT)
</MACRO>
<USER_FUNCTION>
<NAME>xdrproc_t</NAME>
<RETURNS>bool_t </RETURNS>

</USER_FUNCTION>
<TYPEDEF>
<NAME>XDR</NAME>
typedef struct XDR XDR;
</TYPEDEF>
<FUNCTION>
<NAME>x_getlong</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, long *__lp
</FUNCTION>
<FUNCTION>
<NAME>x_putlong</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, __const long *__lp
</FUNCTION>
<FUNCTION>
<NAME>x_getbytes</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, caddr_t __addr, u_int __len
</FUNCTION>
<FUNCTION>
<NAME>x_putbytes</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, __const char *__addr, u_int __len
</FUNCTION>
<FUNCTION>
<NAME>x_getpostn</NAME>
<RETURNS>u_int </RETURNS>
__const XDR *__xdrs
</FUNCTION>
<FUNCTION>
<NAME>x_setpostn</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, u_int __pos
</FUNCTION>
<FUNCTION>
<NAME>x_inline</NAME>
<RETURNS>int32_t *</RETURNS>
XDR *__xdrs, u_int __len
</FUNCTION>
<FUNCTION>
<NAME>x_destroy</NAME>
<RETURNS>void </RETURNS>
XDR *__xdrs
</FUNCTION>
<FUNCTION>
<NAME>x_getint32</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, int32_t *__ip
</FUNCTION>
<FUNCTION>
<NAME>x_putint32</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, __const int32_t *__ip
</FUNCTION>
<MACRO>
<NAME>XDR_GETINT32</NAME>
#define XDR_GETINT32(xdrs, int32p)		\
  (*(xdrs)->x_ops->x_getint32)(xdrs, int32p)
</MACRO>
<MACRO>
<NAME>xdr_getint32</NAME>
#define xdr_getint32(xdrs, int32p)		\
  (*(xdrs)->x_ops->x_getint32)(xdrs, int32p)
</MACRO>
<MACRO>
<NAME>XDR_PUTINT32</NAME>
#define XDR_PUTINT32(xdrs, int32p)		\
  (*(xdrs)->x_ops->x_putint32)(xdrs, int32p)
</MACRO>
<MACRO>
<NAME>xdr_putint32</NAME>
#define xdr_putint32(xdrs, int32p)		\
  (*(xdrs)->x_ops->x_putint32)(xdrs, int32p)
</MACRO>
<MACRO>
<NAME>XDR_GETLONG</NAME>
#define XDR_GETLONG(xdrs, longp)		\
  (*(xdrs)->x_ops->x_getlong)(xdrs, longp)
</MACRO>
<MACRO>
<NAME>xdr_getlong</NAME>
#define xdr_getlong(xdrs, longp)		\
  (*(xdrs)->x_ops->x_getlong)(xdrs, longp)
</MACRO>
<MACRO>
<NAME>XDR_PUTLONG</NAME>
#define XDR_PUTLONG(xdrs, longp)		\
  (*(xdrs)->x_ops->x_putlong)(xdrs, longp)
</MACRO>
<MACRO>
<NAME>xdr_putlong</NAME>
#define xdr_putlong(xdrs, longp)		\
  (*(xdrs)->x_ops->x_putlong)(xdrs, longp)
</MACRO>
<MACRO>
<NAME>XDR_GETBYTES</NAME>
#define XDR_GETBYTES(xdrs, addr, len)		\
  (*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
</MACRO>
<MACRO>
<NAME>xdr_getbytes</NAME>
#define xdr_getbytes(xdrs, addr, len)		\
  (*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
</MACRO>
<MACRO>
<NAME>XDR_PUTBYTES</NAME>
#define XDR_PUTBYTES(xdrs, addr, len)		\
  (*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
</MACRO>
<MACRO>
<NAME>xdr_putbytes</NAME>
#define xdr_putbytes(xdrs, addr, len)		\
  (*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
</MACRO>
<MACRO>
<NAME>XDR_GETPOS</NAME>
#define XDR_GETPOS(xdrs)			\
  (*(xdrs)->x_ops->x_getpostn)(xdrs)
</MACRO>
<MACRO>
<NAME>xdr_getpos</NAME>
#define xdr_getpos(xdrs)			\
  (*(xdrs)->x_ops->x_getpostn)(xdrs)
</MACRO>
<MACRO>
<NAME>XDR_SETPOS</NAME>
#define XDR_SETPOS(xdrs, pos)			\
  (*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
</MACRO>
<MACRO>
<NAME>xdr_setpos</NAME>
#define xdr_setpos(xdrs, pos)			\
  (*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
</MACRO>
<MACRO>
<NAME>XDR_INLINE</NAME>
#define	XDR_INLINE(xdrs, len)			\
  (*(xdrs)->x_ops->x_inline)(xdrs, len)
</MACRO>
<MACRO>
<NAME>xdr_inline</NAME>
#define	xdr_inline(xdrs, len)			\
  (*(xdrs)->x_ops->x_inline)(xdrs, len)
</MACRO>
<MACRO>
<NAME>XDR_DESTROY</NAME>
#define	XDR_DESTROY(xdrs)			\
  if ((xdrs)->x_ops->x_destroy)			\
    (*(xdrs)->x_ops->x_destroy)(xdrs)
</MACRO>
<MACRO>
<NAME>xdr_destroy</NAME>
#define	xdr_destroy(xdrs)			\
  if ((xdrs)->x_ops->x_destroy)			\
    (*(xdrs)->x_ops->x_destroy)(xdrs)
</MACRO>
<MACRO>
<NAME>NULL_xdrproc_t</NAME>
#define NULL_xdrproc_t ((xdrproc_t)0)
</MACRO>
<MACRO>
<NAME>IXDR_GET_INT32</NAME>
#define IXDR_GET_INT32(buf)           ((int32_t)ntohl((uint32_t)*(buf)++))
</MACRO>
<MACRO>
<NAME>IXDR_PUT_INT32</NAME>
#define IXDR_PUT_INT32(buf, v)        (*(buf)++ = (int32_t)htonl((uint32_t)(v)))
</MACRO>
<MACRO>
<NAME>IXDR_GET_U_INT32</NAME>
#define IXDR_GET_U_INT32(buf)         ((uint32_t)IXDR_GET_INT32(buf))
</MACRO>
<MACRO>
<NAME>IXDR_PUT_U_INT32</NAME>
#define IXDR_PUT_U_INT32(buf, v)      IXDR_PUT_INT32(buf, (int32_t)(v))
</MACRO>
<MACRO>
<NAME>IXDR_GET_LONG</NAME>
#define IXDR_GET_LONG(buf) ((long)IXDR_GET_U_INT32(buf))
</MACRO>
<MACRO>
<NAME>IXDR_PUT_LONG</NAME>
#define IXDR_PUT_LONG(buf, v) ((long)IXDR_PUT_INT32(buf, (long)(v)))
</MACRO>
<MACRO>
<NAME>IXDR_GET_U_LONG</NAME>
#define IXDR_GET_U_LONG(buf)	      ((u_long)IXDR_GET_LONG(buf))
</MACRO>
<MACRO>
<NAME>IXDR_PUT_U_LONG</NAME>
#define IXDR_PUT_U_LONG(buf, v)	      IXDR_PUT_LONG(buf, (long)(v))
</MACRO>
<MACRO>
<NAME>IXDR_GET_BOOL</NAME>
#define IXDR_GET_BOOL(buf)		((bool_t)IXDR_GET_LONG(buf))
</MACRO>
<MACRO>
<NAME>IXDR_GET_ENUM</NAME>
#define IXDR_GET_ENUM(buf, t)		((t)IXDR_GET_LONG(buf))
</MACRO>
<MACRO>
<NAME>IXDR_GET_SHORT</NAME>
#define IXDR_GET_SHORT(buf)		((short)IXDR_GET_LONG(buf))
</MACRO>
<MACRO>
<NAME>IXDR_GET_U_SHORT</NAME>
#define IXDR_GET_U_SHORT(buf)		((u_short)IXDR_GET_LONG(buf))
</MACRO>
<MACRO>
<NAME>IXDR_PUT_BOOL</NAME>
#define IXDR_PUT_BOOL(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
</MACRO>
<MACRO>
<NAME>IXDR_PUT_ENUM</NAME>
#define IXDR_PUT_ENUM(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
</MACRO>
<MACRO>
<NAME>IXDR_PUT_SHORT</NAME>
#define IXDR_PUT_SHORT(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
</MACRO>
<MACRO>
<NAME>IXDR_PUT_U_SHORT</NAME>
#define IXDR_PUT_U_SHORT(buf, v)	IXDR_PUT_LONG((buf), ((long)(v)))
</MACRO>
<FUNCTION>
<NAME>xdr_void</NAME>
<RETURNS>bool_t	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>xdr_short</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, short *
</FUNCTION>
<FUNCTION>
<NAME>xdr_u_short</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, u_short *
</FUNCTION>
<FUNCTION>
<NAME>xdr_int</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, int *
</FUNCTION>
<FUNCTION>
<NAME>xdr_u_int</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, u_int *
</FUNCTION>
<FUNCTION>
<NAME>xdr_long</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, long *
</FUNCTION>
<FUNCTION>
<NAME>xdr_u_long</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, u_long *
</FUNCTION>
<FUNCTION>
<NAME>xdr_bool</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, bool_t *
</FUNCTION>
<FUNCTION>
<NAME>xdr_enum</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, enum_t *
</FUNCTION>
<FUNCTION>
<NAME>xdr_array</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, char **, u_int *, u_int, u_int, xdrproc_t
</FUNCTION>
<FUNCTION>
<NAME>xdr_bytes</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, char **, u_int *, u_int
</FUNCTION>
<FUNCTION>
<NAME>xdr_opaque</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, caddr_t, u_int
</FUNCTION>
<FUNCTION>
<NAME>xdr_string</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, char **, u_int
</FUNCTION>
<FUNCTION>
<NAME>xdr_union</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, enum_t *, char *, struct xdr_discrim *, xdrproc_t
</FUNCTION>
<FUNCTION>
<NAME>xdr_char</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, char *
</FUNCTION>
<FUNCTION>
<NAME>xdr_u_char</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, char *
</FUNCTION>
<FUNCTION>
<NAME>xdr_vector</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, char *, u_int, u_int, xdrproc_t
</FUNCTION>
<FUNCTION>
<NAME>xdr_float</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, float *
</FUNCTION>
<FUNCTION>
<NAME>xdr_double</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, double *
</FUNCTION>
<FUNCTION>
<NAME>xdr_reference</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, caddr_t *, u_int, xdrproc_t
</FUNCTION>
<FUNCTION>
<NAME>xdr_pointer</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, caddr_t *, u_int, xdrproc_t
</FUNCTION>
<FUNCTION>
<NAME>xdr_wrapstring</NAME>
<RETURNS>bool_t	</RETURNS>
XDR *, char **
</FUNCTION>
<FUNCTION>
<NAME>xdr_free</NAME>
<RETURNS>void	</RETURNS>
xdrproc_t, char *
</FUNCTION>
<FUNCTION>
<NAME>xdr_int8_t</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, int8_t *__ip
</FUNCTION>
<FUNCTION>
<NAME>xdr_uint8_t</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, uint8_t *__up
</FUNCTION>
<FUNCTION>
<NAME>xdr_int16_t</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, int16_t *__ip
</FUNCTION>
<FUNCTION>
<NAME>xdr_uint16_t</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, uint16_t *__up
</FUNCTION>
<FUNCTION>
<NAME>xdr_int32_t</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, int32_t *__ip
</FUNCTION>
<FUNCTION>
<NAME>xdr_uint32_t</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, uint32_t *__up
</FUNCTION>
<FUNCTION>
<NAME>xdr_int64_t</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, int64_t *__ip
</FUNCTION>
<FUNCTION>
<NAME>xdr_uint64_t</NAME>
<RETURNS>bool_t </RETURNS>
XDR *__xdrs, uint64_t *__up
</FUNCTION>
<MACRO>
<NAME>MAX_NETOBJ_SZ</NAME>
#define MAX_NETOBJ_SZ 1024
</MACRO>
<TYPEDEF>
<NAME>netobj</NAME>
typedef struct netobj netobj;
</TYPEDEF>
<FUNCTION>
<NAME>xdr_netobj</NAME>
<RETURNS>bool_t   </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>xdrmem_create</NAME>
<RETURNS>void   </RETURNS>
XDR *, char *, u_int, enum xdr_op
</FUNCTION>
<FUNCTION>
<NAME>xdrstdio_create</NAME>
<RETURNS>void   </RETURNS>
XDR *, FILE *, enum xdr_op
</FUNCTION>
<FUNCTION>
<NAME>xdrrec_create</NAME>
<RETURNS>void   </RETURNS>
XDR *, u_int, u_int, char *, int (*)(), int (*)()
</FUNCTION>
<FUNCTION>
<NAME>xdrrec_endofrecord</NAME>
<RETURNS>bool_t </RETURNS>
XDR *, int
</FUNCTION>
<FUNCTION>
<NAME>xdrrec_skiprecord</NAME>
<RETURNS>bool_t </RETURNS>
XDR *
</FUNCTION>
<FUNCTION>
<NAME>xdrrec_eof</NAME>
<RETURNS>bool_t </RETURNS>
XDR *
</FUNCTION>
<MACRO>
<NAME>bool_t</NAME>
#define	bool_t	int
</MACRO>
<MACRO>
<NAME>enum_t</NAME>
#define	enum_t	int
</MACRO>
<MACRO>
<NAME>NULL</NAME>
#	define NULL	0
</MACRO>
<MACRO>
<NAME>mem_alloc</NAME>
#define mem_alloc(bsize)	malloc(bsize)
</MACRO>
<MACRO>
<NAME>mem_free</NAME>
#define mem_free(ptr, bsize)	free(ptr)
</MACRO>
<TYPEDEF>
<NAME>caddr_t</NAME>
typedef char * caddr_t;
</TYPEDEF>
<MACRO>
<NAME>bzero</NAME>
#define bzero(x,n) memset(x,0,n)
</MACRO>
<MACRO>
<NAME>bcopy</NAME>
#define bcopy(x,y,n) memcpy(x,y,n)
</MACRO>
<MACRO>
<NAME>IEEEFP</NAME>
#define IEEEFP
</MACRO>
<MACRO>
<NAME>INADDR_LOOPBACK</NAME>
#define	INADDR_LOOPBACK		(u_long)0x7F000001
</MACRO>
<TYPEDEF>
<NAME>window_scale_list</NAME>
typedef struct wcscalelist window_scale_list;
</TYPEDEF>
<TYPEDEF>
<NAME>nsp_gcscale</NAME>
typedef struct wcscalelist nsp_gcscale;
</TYPEDEF>
<FUNCTION>
<NAME>nsp_scale_copy</NAME>
<RETURNS>void </RETURNS>
nsp_gcscale *scale1,nsp_gcscale *scale2
</FUNCTION>
<FUNCTION>
<NAME>nsp_scale_default</NAME>
<RETURNS>void </RETURNS>
nsp_gcscale *scale1
</FUNCTION>
<TYPEDEF>
<NAME>gui_private</NAME>
typedef void gui_private ;
</TYPEDEF>
<MACRO>
<NAME>CoordModePrevious</NAME>
#define CoordModePrevious 0
</MACRO>
<MACRO>
<NAME>CoordModeOrigin</NAME>
#define CoordModeOrigin 1
</MACRO>
<MACRO>
<NAME>GXclear</NAME>
#define GXclear 0
</MACRO>
<MACRO>
<NAME>GXand</NAME>
#define GXand 1
</MACRO>
<MACRO>
<NAME>GXandReverse</NAME>
#define GXandReverse 2
</MACRO>
<MACRO>
<NAME>GXcopy</NAME>
#define GXcopy 3
</MACRO>
<MACRO>
<NAME>GXandInverted</NAME>
#define GXandInverted 4
</MACRO>
<MACRO>
<NAME>GXnoop</NAME>
#define GXnoop 5
</MACRO>
<MACRO>
<NAME>GXxor</NAME>
#define GXxor 6
</MACRO>
<MACRO>
<NAME>GXor</NAME>
#define GXor 7
</MACRO>
<MACRO>
<NAME>GXnor</NAME>
#define GXnor 8
</MACRO>
<MACRO>
<NAME>GXequiv</NAME>
#define GXequiv 9
</MACRO>
<MACRO>
<NAME>GXinvert</NAME>
#define GXinvert 10
</MACRO>
<MACRO>
<NAME>GXorReverse</NAME>
#define GXorReverse 11
</MACRO>
<MACRO>
<NAME>GXcopyInverted</NAME>
#define GXcopyInverted 12
</MACRO>
<MACRO>
<NAME>GXorInverted</NAME>
#define GXorInverted 13
</MACRO>
<MACRO>
<NAME>GXnand</NAME>
#define GXnand 14
</MACRO>
<MACRO>
<NAME>GXset</NAME>
#define GXset 15
</MACRO>
<MACRO>
<NAME>GUI_PRIVATE</NAME>
#define  GUI_PRIVATE
</MACRO>
<VARIABLE>
<NAME>nsp_gengine1</NAME>
extern Gengine1 nsp_gengine1 ;
</VARIABLE>
<VARIABLE>
<NAME>XFig_gengine</NAME>
extern Gengine XFig_gengine ;
</VARIABLE>
<MACRO>
<NAME>sciprint</NAME>
#define  sciprint Sciprintf
</MACRO>
<MACRO>
<NAME>sciprint_nd</NAME>
#define  sciprint_nd Sciprintf
</MACRO>
<MACRO>
<NAME>Scistring</NAME>
#define  Scistring Sciprintf
</MACRO>
<USER_FUNCTION>
<NAME>Scig_deletegwin_handler</NAME>
<RETURNS>void </RETURNS>
int
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_gr_set_deletegwin_handler</NAME>
<RETURNS>Scig_deletegwin_handler </RETURNS>
Scig_deletegwin_handler f
</FUNCTION>
<USER_FUNCTION>
<NAME>Scig_handler</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,int winnum
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_gr_set_handler</NAME>
<RETURNS>Scig_handler </RETURNS>
 Scig_handler f
</FUNCTION>
<VARIABLE>
<NAME>nsp_gr_handler</NAME>
extern Scig_handler nsp_gr_handler;
</VARIABLE>
<FUNCTION>
<NAME>nsp_gr_change</NAME>
<RETURNS>int  </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_2dzoom</NAME>
<RETURNS>void </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_3drot</NAME>
<RETURNS>void </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_delete</NAME>
<RETURNS>void </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_erase</NAME>
<RETURNS>void </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_export</NAME>
<RETURNS>void </RETURNS>
const char *fname, int iwin, int color,const char *driver,char option,int figure_export
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_expose</NAME>
<RETURNS>void </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_loadsg</NAME>
<RETURNS>void </RETURNS>
int ,char *
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_raise</NAME>
<RETURNS>void </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_replay</NAME>
<RETURNS>void </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_resize</NAME>
<RETURNS>void </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_resize_pixmap</NAME>
<RETURNS>void </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_savesg</NAME>
<RETURNS>void </RETURNS>
char *filename, int win_num
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_sel</NAME>
<RETURNS>void </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_tops</NAME>
<RETURNS>void </RETURNS>
int ,int colored,char *bufname,char *driver,char option
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_unzoom</NAME>
<RETURNS>void </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>check_graphic_window</NAME>
<RETURNS>BCG *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>check_graphic_window_new</NAME>
<RETURNS>BCG *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>window_list_get_first</NAME>
<RETURNS>BCG *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>window_list_search</NAME>
<RETURNS>BCG *</RETURNS>
int winnum
</FUNCTION>
<FUNCTION>
<NAME>window_list_search_new</NAME>
<RETURNS>BCG *</RETURNS>
int winnum
</FUNCTION>
<FUNCTION>
<NAME>set_graphic_window</NAME>
<RETURNS>BCG *</RETURNS>
int num
</FUNCTION>
<FUNCTION>
<NAME>set_graphic_window_new</NAME>
<RETURNS>BCG *</RETURNS>
int num
</FUNCTION>
<FUNCTION>
<NAME>Nsetscale2d</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double WRect[4],double ARect[4],double FRect[4],char *logscale
</FUNCTION>
<FUNCTION>
<NAME>getscale2d</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double WRect[4],double FRect[4],char *logscale,double ARect[4]
</FUNCTION>
<FUNCTION>
<NAME>window_list_get_ids</NAME>
<RETURNS>void </RETURNS>
int *Num, int *Ids, int flag
</FUNCTION>
<FUNCTION>
<NAME>window_list_get_max_id</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>window_list_new</NAME>
<RETURNS>BCG *</RETURNS>
void *privated
</FUNCTION>
<FUNCTION>
<NAME>window_list_win_to_front</NAME>
<RETURNS>BCG *</RETURNS>
int win
</FUNCTION>
<FUNCTION>
<NAME>window_list_remove</NAME>
<RETURNS>void </RETURNS>
int num
</FUNCTION>
<FUNCTION>
<NAME>window_list_search_toplevel</NAME>
<RETURNS>int </RETURNS>
void *win
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_win_counter</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_win_counter</NAME>
<RETURNS>void </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>frame_clip_on</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>frame_clip_off</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>set_scale</NAME>
<RETURNS>void </RETURNS>
nsp_gcscale *scale,const int wdim[2],const double subwin[4],const double frame_values[4], const int aaint[4],const char logflag[2],const double axis_values[4]
</FUNCTION>
<FUNCTION>
<NAME>xgc_add_default_scale</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>xgc_reset_scales_to_default</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>move_subwindow_scale_to_front</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,const double *subwin
</FUNCTION>
<FUNCTION>
<NAME>setscale2d</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double WRect[4],double FRect[4],char *logscale
</FUNCTION>
<FUNCTION>
<NAME>nsp_gr_set_graphic_eventhandler</NAME>
<RETURNS>void </RETURNS>
int *win_num,char *name,int *ierr
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_cursor</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,int id
</FUNCTION>
<FUNCTION>
<NAME>getcolordef</NAME>
<RETURNS>void </RETURNS>
int *
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_graphics</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>clip_line</NAME>
<RETURNS>void </RETURNS>
int,int,int ,int,int *,int *,int *,int *,int *, int xleft,int xright,int ybot,int ytop
</FUNCTION>
<FUNCTION>
<NAME>graphic_alloc</NAME>
<RETURNS>void *</RETURNS>
int indice,int n,unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>graphic_alloc_info</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>graphic_alloc_free</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_axis_old</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,char,char,double *,int *,double *,int*,char *str[],int subtics,char *format,int fontsize,int textcolor,int ticscolor,char logflag,int seg_flag ,int grid_color
</FUNCTION>
<FUNCTION>
<NAME>axis_draw</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc, char mode, char scale, int grid_color
</FUNCTION>
<FUNCTION>
<NAME>nsp_grformat_e</NAME>
<RETURNS>void </RETURNS>
char *fmt,double xmin,double xmax,double xpas
</FUNCTION>
<FUNCTION>
<NAME>nsp_grformat_e1</NAME>
<RETURNS>void </RETURNS>
char *fmt,double *x,int nx
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_level_curves</NAME>
<RETURNS>int </RETURNS>
double **x,double **y,int *mm,int *n
</FUNCTION>
<FUNCTION>
<NAME>nsp_gcontour</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *,int *,int *,int *,double *,double *,double *,char *,int *,double *,double *,int
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour2</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *,int *,int *,int *,double *,int *,char *,char *,double *,int *
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour_if</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *,int *,int *,int *,double *,int *
</FUNCTION>
<FUNCTION>
<NAME>nsp_contour2d_draw</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *x, double *y, double *z,int n1, int n2, int nz,  double *zz, int *style
</FUNCTION>
<FUNCTION>
<NAME>Mini</NAME>
<RETURNS>double </RETURNS>
const double vect[],int
</FUNCTION>
<FUNCTION>
<NAME>Maxi</NAME>
<RETURNS>double </RETURNS>
const double vect[],int
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot2d</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double x[],double y[],int *n1,int *n2,int style[],char *strflag,const char *legend,int leg_pos,double brect[],int aaint[]
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot2d_1</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,char *,double *,double *,int *,int *,int *,char *,const char *,int,double *,int *
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot2d_2</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,char *,double *,double *,int *,int *,int *,char *,const char *,int,double *,int *
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot2d_3</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,char *,double *,double *,int *,int *,int *,char *,const char *,int,double *,int *
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot2d_4</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,char *,double *,double *,int *,int *,int *,char *,const char *,int,double *,int *
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot_grid</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,int *
</FUNCTION>
<FUNCTION>
<NAME>CheckxfParam</NAME>
<RETURNS>int </RETURNS>
char *
</FUNCTION>
<ENUM>
<NAME>legends_pos</NAME>
typedef enum { legend_dl, legend_dr ,legend_drm, legend_ul,legend_ur,legend_urm } legends_pos;
</ENUM>
<FUNCTION>
<NAME>nsp_legends</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,legends_pos pos,int n1,const int *style,const char * legend,const char *sep
</FUNCTION>
<FUNCTION>
<NAME>graduate</NAME>
<RETURNS>int </RETURNS>
const double *,const double *,double *,double *,int *,int *,int *,int *,int *
</FUNCTION>
<FUNCTION>
<NAME>update_frame_bounds</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc, int cflag, char *xf, double *x,double *y, int *n1, int *n2, int *aaint,char *strflag,double FRect[4]
</FUNCTION>
<FUNCTION>
<NAME>ellipse2d</NAME>
<RETURNS>void </RETURNS>
nsp_gcscale *,double *,int *,int *,char *
</FUNCTION>
<FUNCTION>
<NAME>axis2d</NAME>
<RETURNS>void </RETURNS>
nsp_gcscale *scales,double *,double *,double *,int *,double *
</FUNCTION>
<FUNCTION>
<NAME>rect2d_f2i</NAME>
<RETURNS>void </RETURNS>
nsp_gcscale *scales,const double x[],int x1[], int n
</FUNCTION>
<FUNCTION>
<NAME>scale_i2f</NAME>
<RETURNS>void </RETURNS>
nsp_gcscale *scales, double x[], double y[],const int x1[],const int y1[],int n
</FUNCTION>
<FUNCTION>
<NAME>scale_f2i</NAME>
<RETURNS>void </RETURNS>
nsp_gcscale *scales,const double x[],const double y[],int x1[],int y1[],int n
</FUNCTION>
<FUNCTION>
<NAME>length_scale_i2f</NAME>
<RETURNS>void </RETURNS>
nsp_gcscale *scales,double *x, double *y, const int *x1, const int *y1, int n
</FUNCTION>
<FUNCTION>
<NAME>length_scale_f2i</NAME>
<RETURNS>void </RETURNS>
nsp_gcscale *scales,const double *x,const double *y, int *x1, int *y1, int n
</FUNCTION>
<FUNCTION>
<NAME>scale_f2wrect</NAME>
<RETURNS>void </RETURNS>
nsp_gcscale *scales,const double x[],double x1[]
</FUNCTION>
<FUNCTION>
<NAME>Gr_Rescale_new</NAME>
<RETURNS>void </RETURNS>
char *,double *,int *,int *,int *,int *
</FUNCTION>
<FUNCTION>
<NAME>zoom</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>unzoom</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>GetEch3d1</NAME>
<RETURNS>void </RETURNS>
 double (*m1)[3],double *,double *,double *,double *
</FUNCTION>
<FUNCTION>
<NAME>GetEch3d</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>MaxiInd</NAME>
<RETURNS>void </RETURNS>
double *,int,int *,double
</FUNCTION>
<FUNCTION>
<NAME>UpNext</NAME>
<RETURNS>void </RETURNS>
int ,int *,int *
</FUNCTION>
<FUNCTION>
<NAME>DownNext</NAME>
<RETURNS>void </RETURNS>
int ,int *,int *
</FUNCTION>
<FUNCTION>
<NAME>TDAxis</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,int flag,double FPval,double LPval,int *nax,int *FPoint,int *LPoint,int *Ticsdir
</FUNCTION>
<FUNCTION>
<NAME>C2F</NAME>
<RETURNS>void </RETURNS>
TDdrawaxis)  (BCG *Xgc,double ,double FPval,double LPval,int *nax,int *FPoint,int *LPoint,int *Ticsdir
</FUNCTION>
<FUNCTION>
<NAME>nsp_3d_rotation</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>DPoints1</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,int *polyx,int *polyy,int *fill,int whiteid,double zmin,double zmax,double *,double *,double *,int i,int j,int jj1,int *p,int dc,int fg
</FUNCTION>
<FUNCTION>
<NAME>DPoints</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,int *polyx,int *polyy,int *fill,int whiteid,double zmin,double zmax,double *,double *,double *,int i,int j,int jj1,int *p,int dc,int fg
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot3d</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *p,int *q,double *teta,double *,const char *,int *,double *
</FUNCTION>
<FUNCTION>
<NAME>nsp_draw_3d_obj_old</NAME>
<RETURNS>void </RETURNS>
 BCG *Xgc,void *Lo,double *theta,double *alpha,const char *legend,int *flag,double *ebox,int with_mesh,int with_box,int box_color,int box_style
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot3d_1</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *p,int *q,double *teta,double *,const char *,int *,double *
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot_fac3d</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *cvect,int *p,int *q,double *teta,double *,const char *,int *,double *
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot_fac3d_1</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *cvect,int *p,int *q,double *teta,double *,const char *,int *,double *
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot_fac3d_2</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *cvect,int *p,int *q,double *teta,double *,const char *,int *,double *
</FUNCTION>
<FUNCTION>
<NAME>nsp_plot_fac3d_3</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *cvect,int *p,int *q,double *teta,double *,const char *,int *,double *
</FUNCTION>
<FUNCTION>
<NAME>nsp_param3d</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *,double *teta,double *,const char *,int *,double *
</FUNCTION>
<FUNCTION>
<NAME>nsp_param3d_1</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *,int *,int *,int *colors,double *teta,double *,const char *,int *,double *
</FUNCTION>
<FUNCTION>
<NAME>nsp_geom3d_new</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,double *,double *,double *,int *n
</FUNCTION>
<FUNCTION>
<NAME>SetEch3d</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double *,double *,double *,double *,double *teta,double *
</FUNCTION>
<FUNCTION>
<NAME>DrawAxis</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,const nsp_box_3d *box,char flag, int style
</FUNCTION>
<FUNCTION>
<NAME>Convex_Box</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc, nsp_box_3d *box,const char *legend, int flag
</FUNCTION>
<FUNCTION>
<NAME>tape_new_angles_plots</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,double theta,double alpha,const int *pt
</FUNCTION>
<FUNCTION>
<NAME>tape_check_recorded_3D</NAME>
<RETURNS>int  </RETURNS>
BCG *Xgc,int winnumber
</FUNCTION>
<FUNCTION>
<NAME>tape_clean_plots</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,int winnumber
</FUNCTION>
<FUNCTION>
<NAME>tape_replay_undo_scale</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>tape_replay_new_scale</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,int winnumber, int *flag, int *aaint,double *bbox,int *ibbox
</FUNCTION>
<FUNCTION>
<NAME>tape_replay_new_angles</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>tape_replay</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,const GdkRectangle *rect
</FUNCTION>
<FUNCTION>
<NAME>tape_replay_mix</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,BCG *Xgc1, int winnumber
</FUNCTION>
<ENUM>
<NAME>nsp_plot3d_type</NAME>
typedef enum {plot3d_t ,facettes_t , param3d_t} nsp_plot3d_type;
</ENUM>
<FUNCTION>
<NAME>nsp_remap_colors</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,int remap,int *colmin,int *colmax,double *zmin,double *zmax,double *coeff,const int *colminmax,const double *zminmax,const double z[],int zn
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_colormap_constants</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,int m
</FUNCTION>
<TYPEDEF>
<NAME>gui_private</NAME>
typedef void gui_private ;
</TYPEDEF>
<MACRO>
<NAME>CoordModePrevious</NAME>
#define CoordModePrevious 0
</MACRO>
<MACRO>
<NAME>CoordModeOrigin</NAME>
#define CoordModeOrigin 1
</MACRO>
<MACRO>
<NAME>GXclear</NAME>
#define GXclear 0
</MACRO>
<MACRO>
<NAME>GXand</NAME>
#define GXand 1
</MACRO>
<MACRO>
<NAME>GXandReverse</NAME>
#define GXandReverse 2
</MACRO>
<MACRO>
<NAME>GXcopy</NAME>
#define GXcopy 3
</MACRO>
<MACRO>
<NAME>GXandInverted</NAME>
#define GXandInverted 4
</MACRO>
<MACRO>
<NAME>GXnoop</NAME>
#define GXnoop 5
</MACRO>
<MACRO>
<NAME>GXxor</NAME>
#define GXxor 6
</MACRO>
<MACRO>
<NAME>GXor</NAME>
#define GXor 7
</MACRO>
<MACRO>
<NAME>GXnor</NAME>
#define GXnor 8
</MACRO>
<MACRO>
<NAME>GXequiv</NAME>
#define GXequiv 9
</MACRO>
<MACRO>
<NAME>GXinvert</NAME>
#define GXinvert 10
</MACRO>
<MACRO>
<NAME>GXorReverse</NAME>
#define GXorReverse 11
</MACRO>
<MACRO>
<NAME>GXcopyInverted</NAME>
#define GXcopyInverted 12
</MACRO>
<MACRO>
<NAME>GXorInverted</NAME>
#define GXorInverted 13
</MACRO>
<MACRO>
<NAME>GXnand</NAME>
#define GXnand 14
</MACRO>
<MACRO>
<NAME>GXset</NAME>
#define GXset 15
</MACRO>
<MACRO>
<NAME>GUI_PRIVATE</NAME>
#define  GUI_PRIVATE
</MACRO>
<VARIABLE>
<NAME>nsp_gengine1</NAME>
extern Gengine1 nsp_gengine1 ;
</VARIABLE>
<VARIABLE>
<NAME>Pos_gengine</NAME>
extern Gengine Pos_gengine ;
</VARIABLE>
<TYPEDEF>
<NAME>BCG</NAME>
typedef struct __BCG BCG;
</TYPEDEF>
<TYPEDEF>
<NAME>Gengine</NAME>
typedef struct nsp_gengine Gengine;    /* drawing */
</TYPEDEF>
<STRUCT>
<NAME></NAME>
typedef struct _plot_code {
  int code; 
} plot_code ; 

typedef struct _listplot {
  /* int  window; */
  void *theplot; 
  struct _listplot   *next;
  struct _listplot   *previous;
} list_plot ;

extern void window_scale_delete(int win);

/*
 * a queue for storing mouse events in drivers 
 */

typedef struct _nsp_gwin_event nsp_gwin_event ;

struct _nsp_gwin_event {
  int win,x,y,ibutton,mask,motion,release;
};
</STRUCT>
<ENUM>
<NAME>_nsp_ev_code</NAME>
typedef enum { 
  nsp_ev_motion = 0x1 , 
  nsp_ev_release = 0x10, 
  nsp_ev_getkey = 0x100, 
  nsp_ev_getmenu = 0x1000 } _nsp_ev_code;
</ENUM>
<MACRO>
<NAME>MaxCB</NAME>
#define MaxCB 50
</MACRO>
<STRUCT>
<NAME>nsp_event_queue</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_event_queue</NAME>
struct  _nsp_event_queue {
  int in , out, size;
  nsp_gwin_event elems[MaxCB];
};

</STRUCT>
<MACRO>
<NAME>BCG_PRIVATE</NAME>
#define BCG_PRIVATE  gui_private 
</MACRO>
<MACRO>
<NAME>BCG_PRIVATE</NAME>
#define BCG_PRIVATE  void 
</MACRO>
<STRUCT>
<NAME>_BCG</NAME>
struct __BCG 
{ 
  Gengine *graphic_engine; /* the graphic engine associated to this graphic window */
  Nsp_gc_actions *actions; /* a set of actions */
  int CurWindow ;          /* Id of window */
  int CWindowWidth ;       /* graphic window width */
  int CWindowHeight ;      /* graphic window height */
  int fontId ;
  int fontSize ;
  int CurHardSymb;
  int CurHardSymbSize;
  int CurLineWidth;
  int CurPattern;
  int CurColor;
  int CurPixmapStatus;
  int CurResizeStatus;
  int CurVectorStyle;
  int CurDrawFunction;
  int ClipRegionSet;
  GdkRectangle CurClipRegion;/* same as gint CurClipRegion[4]; */
  int CurDashStyle;
  char CurNumberDispFormat[32];
  int CurColorStatus;
  int IDLastPattern; /* number of last pattern or color  in color mode = Numcolors - 1 */
  int CmapFlag ; /* set to 1 if the Cmap has default colors */
  int Numcolors; /* number of colors */
  int NumBackground;  /* number of Background in the color table */
  int NumForeground; /* number of Foreground in the color table */
  int NumHidden3d;  /* color for hidden 3d facets **/
  char EventHandler[NAME_MAXL+1]; /* name of window event handler XXXX */
  char fp_format[32]; 
  int Autoclear;
  window_scale_list *scales; /* scales associated to graphic window subwins */

  int zz_record_flag ; /* unused but we must keep the same size as in old perigen.h */
  void *figure;    /* list of recorded plots */
  void *zz_last_plot;  /* unused but we must keep the same size as in old perigen.h */
  void *xdrs;            /* used to pass a xdr structure for saving data */
  int zrect[4];          /* rectangle to be superposed on graphic window 
			  * used for zoom 
			  */

#ifdef __cplusplus
  /* private is a reserved keyword in C++ */
  BCG_PRIVATE *private_gc ;  /* only visible when inside a specific driver */ 
#else 
  BCG_PRIVATE *private ;  /* only visible when inside a specific driver */ 
#endif 
  nsp_event_queue queue; /* a queue for storing event when outside xclick */
  int figure_bg_draw;   /* used in exporting: if true draw the figure background 
			 * if false do not so as to obtain transparent icons 
			 * used for creating icons from graphics.
			 */
} ;
</STRUCT>
<FUNCTION>
<NAME>nsp_drawpolyline_clip</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,int *vx, int *vy,int n, int *clip_box , int onemore
</FUNCTION>
<MACRO>
<NAME>CoordModeOrigin</NAME>
#define CoordModeOrigin 0
</MACRO>
<MACRO>
<NAME>CoordModePrevious</NAME>
#define CoordModePrevious 1
</MACRO>
<FUNCTION>
<NAME>graphic_initial_menu</NAME>
<RETURNS>void *</RETURNS>
int winid
</FUNCTION>
<FUNCTION>
<NAME>CheckClickQueue</NAME>
<RETURNS>int </RETURNS>
int *,int *x,int *y,int *ibut
</FUNCTION>
<FUNCTION>
<NAME>ClearClickQueue</NAME>
<RETURNS>int </RETURNS>
int
</FUNCTION>
<FUNCTION>
<NAME>PushClickQueue</NAME>
<RETURNS>int </RETURNS>
int,int ,int y,int ibut,int m,int r
</FUNCTION>
<FUNCTION>
<NAME>C2F</NAME>
<RETURNS>int </RETURNS>
ismenu) (void
</FUNCTION>
<FUNCTION>
<NAME>C2F</NAME>
<RETURNS>int </RETURNS>
getmen) (char *btn_cmd,int *lb,int *entry
</FUNCTION>
<FUNCTION>
<NAME>MenuFixCurrentWin</NAME>
<RETURNS>void </RETURNS>
 int ivalue
</FUNCTION>
<FUNCTION>
<NAME>GetWindowXgcNumber</NAME>
<RETURNS>BCG *</RETURNS>
int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_initialize_gc</NAME>
<RETURNS>void </RETURNS>
 BCG *Xgc
</FUNCTION>
<STRUCT>
<NAME>nsp_box_3d</NAME>
typedef struct _nsp_box_3d {
  double bbox[6];             /* {xmin,xmax,ymin,ymax,zmin,zmax} FIXME: redondant avec Xgc->scales */
  double x_r[8],y_r[8],z_r[8];/* coordinates of the bounding box in real space  */
  double x[8],y[8],z[8];      /* coordinates of the bounding box after rotation */
  int xind[6];                /* indices of convex hull */
  int ix[7],iy[7];            /* coordinates of convex hull ( point 6 == point 0 )
			       * after ratation and scaling */
  double xh[7],yh[7],zh[7];   /* coordinates of convex hull in in real space */
  int InsideU[4],InsideD[4];  /* indices of internal and external <<triedres>> */
} nsp_box_3d; 
</STRUCT>
<MACRO>
<NAME>XScale_d</NAME>
#define XScale_d(Scale,x)    ( Scale->Wscx1*((x) -Scale->frect[0]) + Scale->Wxofset1) 
</MACRO>
<MACRO>
<NAME>XLogScale_d</NAME>
#define XLogScale_d(Scale,x) ( Scale->Wscx1*(log10(x) -Scale->frect[0]) + Scale->Wxofset1)
</MACRO>
<MACRO>
<NAME>YScale_d</NAME>
#define YScale_d(Scale,y)    ( Scale->Wscy1*(-(y)+Scale->frect[3]) + Scale->Wyofset1)
</MACRO>
<MACRO>
<NAME>YLogScale_d</NAME>
#define YLogScale_d(Scale,y) ( Scale->Wscy1*(-log10(y)+Scale->frect[3]) + Scale->Wyofset1)
</MACRO>
<MACRO>
<NAME>XScaleR_d</NAME>
#define XScaleR_d(Scale,x,y) ((Scale->cosa==1.0) ? ( Scale->Wscx1*((x) -Scale->frect[0]) + Scale->Wxofset1) : \
			  ( Scale->cosa*Scale->Wscx1*((x) -Scale->frect[0]) - Scale->sina*Scale->Wscy1*(-(y)+Scale->frect[3])) + Scale->Wxofset1) 
</MACRO>
<MACRO>
<NAME>YScaleR_d</NAME>
#define YScaleR_d(Scale,x,y) ((Scale->cosa==1.0) ? ( Scale->Wscy1*(-(y)+Scale->frect[3]) + Scale->Wyofset1): \
			  ( Scale->sina*Scale->Wscx1*((x) -Scale->frect[0]) + Scale->cosa*Scale->Wscy1*(-(y)+Scale->frect[3])) + Scale->Wyofset1)
</MACRO>
<MACRO>
<NAME>XScale</NAME>
#define XScale(Scale,x)    inint( XScale_d(Scale,x) )
</MACRO>
<MACRO>
<NAME>XLogScale</NAME>
#define XLogScale(Scale,x) inint( XLogScale_d(Scale,x))
</MACRO>
<MACRO>
<NAME>YScale</NAME>
#define YScale(Scale,y)    inint( YScale_d(Scale,y)   )
</MACRO>
<MACRO>
<NAME>YLogScale</NAME>
#define YLogScale(Scale,y) inint( YLogScale_d(Scale,y))
</MACRO>
<MACRO>
<NAME>XDouble2Pixel_d</NAME>
#define XDouble2Pixel_d(Scale,x) ((Scale->logflag[0] == 'n') ? ( XScale_d(Scale,x)) : ( XLogScale_d(Scale,x)))
</MACRO>
<MACRO>
<NAME>YDouble2Pixel_d</NAME>
#define YDouble2Pixel_d(Scale,y) ((Scale->logflag[1] == 'n') ? ( YScale_d(Scale,y)) : ( YLogScale_d(Scale,y)))
</MACRO>
<MACRO>
<NAME>XDouble2Pixel</NAME>
#define XDouble2Pixel(Scale,x) ((Scale->logflag[0] == 'n') ? ( XScale_d(Scale,x)) : ( XLogScale_d(Scale,x)))
</MACRO>
<MACRO>
<NAME>YDouble2Pixel</NAME>
#define YDouble2Pixel(Scale,y) ((Scale->logflag[1] == 'n') ? ( YScale_d(Scale,y)) : ( YLogScale_d(Scale,y)))
</MACRO>
<MACRO>
<NAME>XPi2R</NAME>
#define XPi2R(Scale,x)  Scale->frect[0] + (1.0/Scale->Wscx1)*((x) - Scale->Wxofset1)
</MACRO>
<MACRO>
<NAME>YPi2R</NAME>
#define YPi2R(Scale,y)  Scale->frect[3] - (1.0/Scale->Wscy1)*((y) - Scale->Wyofset1)
</MACRO>
<MACRO>
<NAME>XPi2LogR</NAME>
#define XPi2LogR(Scale,x)  exp10( XPi2R(Scale,x))
</MACRO>
<MACRO>
<NAME>YPi2LogR</NAME>
#define YPi2LogR(Scale,y)  exp10( YPi2R(y))
</MACRO>
<MACRO>
<NAME>XPixel2Double</NAME>
#define XPixel2Double(Scale,x)  (( Scale->logflag[0] == 'l') ? XPi2LogR(Scale,x) : XPi2R(Scale,x))
</MACRO>
<MACRO>
<NAME>YPixel2Double</NAME>
#define YPixel2Double(Scale,y)  (( Scale->logflag[1] == 'l') ? YPi2LogR(Scale,y) : YPi2R(Scale,y))
</MACRO>
<MACRO>
<NAME>TRX</NAME>
#define TRX(Scale,x1,y1,z1) ( Scale->m[0][0]*(x1-Scale->c[0]) +Scale->m[0][1]*(y1-Scale->c[1]) +Scale->m[0][2]*(z1-Scale->c[2]))
</MACRO>
<MACRO>
<NAME>TRY</NAME>
#define TRY(Scale,x1,y1,z1) ( Scale->m[1][0]*(x1-Scale->c[0]) +Scale->m[1][1]*(y1-Scale->c[1]) +Scale->m[1][2]*(z1-Scale->c[2]))
</MACRO>
<MACRO>
<NAME>TRZ</NAME>
#define TRZ(Scale,x1,y1,z1) ( Scale->m[2][0]*(x1-Scale->c[0]) +Scale->m[2][1]*(y1-Scale->c[1]) +Scale->m[2][2]*(z1-Scale->c[2]))
</MACRO>
<MACRO>
<NAME>GEOX</NAME>
#define GEOX(Scale,x1,y1,z1)  XScale(Scale,TRX(Scale,x1,y1,z1))
</MACRO>
<MACRO>
<NAME>GEOY</NAME>
#define GEOY(Scale,x1,y1,z1)  YScale(Scale,TRY(Scale,x1,y1,z1))
</MACRO>
<MACRO>
<NAME>GEOZ</NAME>
#define GEOZ(Scale,x1,y1,z1)  TRZ(Scale,x1,y1,z1)
</MACRO>
<FUNCTION>
<NAME>show_scales</NAME>
<RETURNS>void </RETURNS>
 BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>nsp_ogl_set_2dview</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>nsp_ogl_set_3dview</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>nsp_ogl_set_view</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>nsp_enqueue</NAME>
<RETURNS>int </RETURNS>
nsp_event_queue *q, nsp_gwin_event *ev
</FUNCTION>
<FUNCTION>
<NAME>nsp_dequeue</NAME>
<RETURNS>nsp_gwin_event </RETURNS>
nsp_event_queue *q
</FUNCTION>
<FUNCTION>
<NAME>nsp_peekqueue</NAME>
<RETURNS>nsp_gwin_event </RETURNS>
nsp_event_queue *q
</FUNCTION>
<FUNCTION>
<NAME>nsp_queue_empty</NAME>
<RETURNS>int </RETURNS>
nsp_event_queue *q
</FUNCTION>
<FUNCTION>
<NAME>nsp_clear_queue</NAME>
<RETURNS>void </RETURNS>
nsp_event_queue *q
</FUNCTION>
<FUNCTION>
<NAME>window_list_check_queue</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,nsp_gwin_event *ev
</FUNCTION>
<FUNCTION>
<NAME>window_list_clear_queue</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>window_list_search_from_drawing</NAME>
<RETURNS>int </RETURNS>
void *win
</FUNCTION>
<TYPEDEF>
<NAME>Nsp_gc_actions</NAME>
typedef struct _nsp_gc_actions Nsp_gc_actions ;
</TYPEDEF>
<STRUCT>
<NAME>nsp_gc_actions</NAME>
struct _nsp_gc_actions {
  driver_gc_change *change ;
  driver_gc_2dzoom *zoom ;
  driver_gc_3drot  *rotation ;
  driver_gc_delete *destroy ;
  driver_gc_erase  *erase ;
  driver_gc_expose *expose ;
  driver_gc_loadsg *loadsg; 
  driver_gc_raise  *raise ;
  driver_gc_replay *replay ;
  driver_gc_resize *resize ;
  driver_gc_resize_pixmap *resize_pixmap ;
  driver_gc_savesg *savesg ;
  driver_gc_select *select ;
  driver_gc_tops   *tops ;
  driver_gc_unzoom *unzoom ;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_gc_actions</NAME>
extern Nsp_gc_actions nsp_gc_actions ;
</VARIABLE>
<STRUCT>
<NAME>Nsp_gengine_store</NAME>
</STRUCT>
<STRUCT>
<NAME>Nsp_gengine_store</NAME>
struct _Nsp_gengine_store {
 fn_store_initialize_gc *store_initialize_gc;
 fn_store_clipping_p *store_clipping_p;
 fn_store_clipgrf *store_clipgrf ;
 fn_store_alufunction1 *store_alufunction1;
 fn_store_background *store_background;
 fn_store_unclip *store_unclip;
 fn_store_test *store_test;
 fn_store_clip *store_clip;
 fn_store_pattern *store_pattern;
 fn_store_font_size *store_font_size;
 fn_store_font *store_font;
 fn_store_foreground *store_foreground;
 fn_store_hidden3d *store_hidden3d;
 fn_store_absourel *store_absourel;
 fn_store_dash *store_dash;
 fn_store_mark_size *store_mark_size;
 fn_store_mark *store_mark;
 fn_store_pixmapOn *store_pixmapOn;
 fn_store_thickness *store_thickness;
 fn_store_usecolor *store_usecolor;
 fn_store_show *store_show;
 fn_store_pixmapclear *store_pixmapclear;
 fn_store_fpf_def *store_fpf_def;
 fn_store_fpf *store_fpf;
 fn_store_fillarcs_1 *store_fillarcs_1;
 fn_store_drawarcs_1 *store_drawarcs_1;
 fn_store_fillpolyline_1 *store_fillpolyline_1;
 fn_store_drawarrows_1 *store_drawarrows_1;
 fn_store_drawaxis_1 *store_drawaxis_1;
 fn_store_cleararea_1 *store_cleararea_1;
 fn_store_fillarc_1 *store_fillarc_1;
 fn_store_fillrectangle_1 *store_fillrectangle_1;
 fn_store_drawpolyline_1 *store_drawpolyline_1;
 fn_store_fillpolylines_1 *store_fillpolylines_1;
 fn_store_drawpolymark_1 *store_drawpolymark_1;
 fn_store_displaynumbers_1 *store_displaynumbers_1;
 fn_store_drawpolylines_1 *store_drawpolylines_1;
 fn_store_drawrectangle_1 *store_drawrectangle_1;
 fn_store_drawrectangles_1 *store_drawrectangles_1;
 fn_store_drawsegments_1 *store_drawsegments_1;
 fn_store_displaystring_1 *store_displaystring_1;
 fn_store_displaystringa_1 *store_displaystringa_1;
 fn_store_xstringb_1 *store_xstringb_1;
 fn_store_Ech *store_Ech;
 fn_store_NEch *store_NEch;
 fn_store_Plot *store_Plot;
 fn_store_Plot1 *store_Plot1;
 fn_store_Plot2 *store_Plot2;
 fn_store_Plot3 *store_Plot3;
 fn_store_Plot4 *store_Plot4;
 fn_store_SciAxis *store_SciAxis;
 fn_store_Grid *store_Grid;
 fn_store_Param3D *store_Param3D;
 fn_store_Param3D1 *store_Param3D1;
 fn_store_Plot3D *store_Plot3D;
 fn_store_Plot3D1 *store_Plot3D1;
 fn_store_3dobj *store_3dobj;
 fn_store_pixbuf *store_pixbuf;
 fn_store_pixbuf_from_file *store_pixbuf_from_file;
 fn_store_Fac3D *store_Fac3D;
 fn_store_Fac3D1 *store_Fac3D1;
 fn_store_Fac3D2 *store_Fac3D2;
 fn_store_Fac3D3 *store_Fac3D3;
 fn_store_Fec *store_Fec;
 fn_store_Contour *store_Contour; 
 fn_store_Contour2D *store_Contour2D;
 fn_store_Gray *store_Gray;
 fn_store_Gray2 *store_Gray2;
 fn_store_Gray1 *store_Gray1;
 fn_store_Champ *store_Champ;
 fn_store_Champ1 *store_Champ1;
  fn_store_graphic_object *store_graphic_object;
  fn_store_colormap *store_colormap;
  fn_store_default_colormap *store_default_colormap;
  fn_store_drawarc_1 *store_drawarc_1;
  fn_store_record *store_record;
};

</STRUCT>
<VARIABLE>
<NAME>nsp_gengine_record_old</NAME>
extern Nsp_gengine_store nsp_gengine_record_old;
</VARIABLE>
<MACRO>
<NAME>WITH_PANGO</NAME>
#define WITH_PANGO
</MACRO>
<MACRO>
<NAME>HAVE_FREETYPE</NAME>
#define HAVE_FREETYPE
</MACRO>
<MACRO>
<NAME>PANGO_DISABLE_DEPRECATED</NAME>
#define PANGO_DISABLE_DEPRECATED 
</MACRO>
<MACRO>
<NAME>TAILLE_CHAR</NAME>
#define TAILLE_CHAR 16
</MACRO>
<MACRO>
<NAME>TRANSLATE_CHAR</NAME>
#define TRANSLATE_CHAR 10
</MACRO>
<MACRO>
<NAME>ECHELLE_CHAR</NAME>
#define ECHELLE_CHAR 0.6
</MACRO>
<MACRO>
<NAME>bool</NAME>
#define bool char
</MACRO>
<MACRO>
<NAME>true</NAME>
#define true 1
</MACRO>
<MACRO>
<NAME>false</NAME>
#define false 0
</MACRO>
<MACRO>
<NAME>INIT_DISTANCE_CLIPPING_LOIN</NAME>
#define INIT_DISTANCE_CLIPPING_LOIN 2000.0
</MACRO>
<MACRO>
<NAME>INIT_DISTANCE_CLIPPING_PROCHE</NAME>
#define INIT_DISTANCE_CLIPPING_PROCHE 0.01
</MACRO>
<STRUCT>
<NAME>GTK_locator_info</NAME>
</STRUCT>
<STRUCT>
<NAME>GTK_locator_info</NAME>
struct _GTK_locator_info {
  guint win, x,y, ok;
  int getrelease,getmotion,getmen,getkey, button, mask ;
  int sci_click_activated; /* TRUE when we are in a xclick or xclick_any function */
  guint timer;
  char *str;
  int  lstr;
};

</STRUCT>
<TYPEDEF>
<NAME>menu_entry</NAME>
typedef struct s_menu_entry menu_entry;
</TYPEDEF>
<STRUCT>
<NAME></NAME>
typedef struct  _gtk_data {
  void     *colors;                     /* an array of colors in a NspMatrix  */
  GQueue   *q_colors;                   /* an queue for storing colors        */
  GdkColormap *colormap ;               /* used to keep track of drawing colormap */
  GtkWidget *window;			/* Graphics frame */
  GtkWidget *drawing;                   /* gtk drawing area used for drawing */
  GtkWidget *scrolled;                  /* scrolled window which contains the drawing area*/
  GtkWidget *CinfoW ;                   /* info widget */
  GtkWidget *vbox;                      /* vbox */
  GtkWidget *menubar;
  menu_entry *menu_entries;             /* */
  GdkPixmap *pixmap;                    /* backing store pixmap */
  GdkPixmap *extra_pixmap;              /* extra backing store pixmap used when pixmap mode is on  */
  GdkDrawable *drawable;                /* can be set to drawing->window, pixmap or extra_pixmap */
  GdkGC *wgc;
  GdkGC *stdgc;
  GdkColor gcol_bg; 
  GdkColor gcol_fg; 
  GdkRectangle clip;
  GdkCursor *gcursor;                   /* xclick cursor */ 
  GdkCursor *ccursor;                   /* standard cursor */
  GdkCursor *extra_cursor;              /* extra cursor */
  GdkFont *font;
  int resize;				/* Window resized */
  int zzin_expose;                      /* we are in an expose_event action*/
  int draw;                             /* when true need to redraw  */
  int protect;                          /* when true window cannot be deleted */
  PangoLayout *layout;
  PangoLayout *mark_layout;
  PangoContext *context;
  PangoContext *ft2_context;
  PangoFontDescription *desc;
  PangoFontDescription *mark_desc;
#ifdef PERI_PRIVATE_CAIRO
  GtkWidget *cairo_drawing;             /* Drawable window for cairo */
  cairo_t *cairo_cr;                    /* used to draw on the private */
#endif
#ifdef PERIGL 
  int gdk_only;                         /* when true only gdk draw  */
  int gl_only;                          /* when true only gl draw  */
  TextureImage  tab_textures_font[2];   /* caracters as textures */
  GLuint   fonte_encours;
  GLuint   tab_base[2];
  GLuint  base_encours;
  t_camera camera;             /*   opengl camera */
  GdkGLContext *glcontext ;
  GdkGLDrawable *gldrawable;
#endif 
  GdkRectangle invalidated;             /* used for expose_event */
} gui_private ;


extern void menu_entry_delete(menu_entry *me);

/*-----------------------------------------------------------------
 * mix with generic data 
 *-----------------------------------------------------------------*/

#define  GUI_PRIVATE
#include "Graphics.h" 

#ifdef PERI_PRIVATE

extern Gengine1 nsp_gengine1 ;

/*-----------------------------------------------------------------
 * private functions for drivers
 *-----------------------------------------------------------------*/

#ifdef PERIGTK 
#define xx__gengine Gtk_gengine 
#endif 

#ifdef PERICAIRO  
#define xx__gengine Cairo_gengine 
#endif 

#ifdef PERIGL
#define xx__gengine GL_gengine 
#endif

Gengine xx__gengine = {
  &nsp_peri_generic, 
  "X11",
  0,
  &nsp_gengine1,
  fill_grid_rectangles ,
  fill_grid_rectangles1 ,
  boundingbox,
  cleararea,
  clearwindow,
  displaynumbers,
  displaystring,
  drawarc,
  drawarcs,
  drawarrows,
  drawaxis,
  drawpolyline,
  nsp_drawpolyline_clip,
  drawpolylines,
  drawpolymark,
  drawrectangle,
  drawrectangles,
  drawsegments,
  drawline,
  fillarc,
  fillarcs,
  fillpolyline,
  fillpolylines,
  fillrectangle,
  window_list_get_ids ,
  initgraphic,
  loadfamily,
  queryfamily,
  setpopupname,
  xclick,
  xclick_any,
  xend,
  xgetmouse,
  xinfo,
  xpause,
  xselgraphic ,
  sedeco,

  tape_replay,
  tape_clean_plots,
  tape_replay_new_angles,
  tape_replay_new_scale,
  tape_replay_undo_scale,
  tape_check_recorded_3D,
  
  xget_windowpos,
  xset_windowpos,
  xget_windowdim,
  xset_windowdim,
  xget_popupdim,
  xset_popupdim,
  xget_viewport,
  xset_viewport,
  xset_curwin,
  xget_curwin,
  xset_clip,
  xset_unclip,
  xset_test,
  xget_clip,
  xset_absourel,
  xget_absourel,
  xset_alufunction1,
  xget_alufunction,
  xset_thickness,
  xget_thickness,
  xset_pattern,
  xget_pattern,
  xget_last,
  xset_dash,
  xset_line_style,
  xset_dashstyle,
  xget_dash,
  xset_usecolor,
  xget_usecolor,
  xset_pixmapOn,
  xget_pixmapOn,
  xset_wresize,
  xget_wresize,
  xset_colormap,
  xset_default_colormap,
  xget_colormap,
  xset_background,
  xget_background,
  xset_foreground,
  xget_foreground,
  xset_hidden3d,
  xget_hidden3d,
  xset_mark,
  xget_mark,
  xset_font,
  xget_font,
  xset_autoclear,
  xset_autoclear_def,
  xget_autoclear,
  xget_fpf,
  xset_fpf,
  xset_fpf_def,

  xset_pixmapclear,
  xset_show,
  xset_default,
  pixmap_resize,

  xget_recording,
  xset_recording,
  xset_win_protect,
  delete_window,
  invalidate,
  process_updates,

  draw_pixbuf,
  draw_pixbuf_from_file,

  xpush_colormap,
  xpop_colormap,

  xstring_pango

};
</STRUCT>
<VARIABLE>
<NAME>Gtk_gengine</NAME>
extern Gengine Gtk_gengine ;
</VARIABLE>
<FUNCTION>
<NAME>nsp_ogl_set_view</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc
</FUNCTION>
<FUNCTION>
<NAME>create_graphic_window_menu</NAME>
<RETURNS>void </RETURNS>
 BCG *dd
</FUNCTION>
<FUNCTION>
<NAME>start_sci_gtk</NAME>
<RETURNS>void </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>change_camera</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,const double *val
</FUNCTION>
<FUNCTION>
<NAME>create_graphic_window_menu</NAME>
<RETURNS>void </RETURNS>
 BCG *dd
</FUNCTION>
<FUNCTION>
<NAME>start_sci_gtk</NAME>
<RETURNS>void </RETURNS>

</FUNCTION>
<TYPEDEF>
<NAME>Gengine1</NAME>
typedef struct _nsp_gengine1 Gengine1; 
</TYPEDEF>
<STRUCT>
<NAME>nsp_gengine1</NAME>
struct _nsp_gengine1 {
  driver_s_boundingbox *boundingbox;
  driver_s_cleararea *cleararea;
  driver_s_displaynumbers *displaynumbers;
  driver_s_displaystring *displaystring;
  driver_s_displaystringa *displaystringa;
  driver_s_draw_pixbuf *draw_pixbuf;
  driver_s_draw_pixbuf_from_file *draw_pixbuf_from_file;
  driver_s_drawarc *drawarc;
  driver_s_drawarcs *drawarcs;
  driver_s_drawarrows *drawarrows;
  driver_s_drawaxis *drawaxis;
  driver_s_drawpolyline *drawpolyline;
  driver_s_drawpolyline_clip *drawpolyline_clip;
  driver_s_drawpolylines *drawpolylines;
  driver_s_drawpolymark *drawpolymark;
  driver_s_drawrectangle *drawrectangle;
  driver_s_drawrectangles *drawrectangles;
  driver_s_drawsegments *drawsegments;
  driver_s_fillarc *fillarc;
  driver_s_fillarcs *fillarcs;
  driver_s_fillpolyline *fillpolyline;
  driver_s_fillpolylines *zzfillpolylines; /* no more used */
  driver_s_fillrectangle *fillrectangle;
  driver_s_initialize_gc *initialize_gc;
  driver_s_xclick *xclick;
  driver_s_xclick_any *xclick_any;
  driver_s_xgetmouse *xgetmouse;
  driver_s_xset_clip *xset_clip;
  driver_s_xset_clipgrf *xset_clipgrf;
  driver_s_xset_clipping_p *xset_clipping_p;
  driver_s_xset_default *xset_default;
  driver_s_xset_font_size *xset_font_size;
  driver_s_xset_mark_size *xset_mark_size;
  driver_s_xstringb *xstringb;
};

</STRUCT>
<ENUM>
<NAME>gr_str_posx</NAME>
typedef enum { GR_STR_XLEFT ,GR_STR_XCENTER , GR_STR_XRIGHT} gr_str_posx;
</ENUM>
<ENUM>
<NAME>gr_str_posy</NAME>
typedef enum { GR_STR_YBOTTOM ,GR_STR_YCENTER , GR_STR_YBASELINE, GR_STR_YUP } gr_str_posy;
</ENUM>
<ENUM>
<NAME>gr_str_box</NAME>
typedef enum { GR_in_box, GR_fill_box, GR_no_box} gr_str_box;
</ENUM>
<FUNCTION>
<NAME>nsp_drawpolyline_clip</NAME>
<RETURNS>void </RETURNS>
BCG *Xgc,int *vx, int *vy,int n, int *clip_box , int onemore
</FUNCTION>
<STRUCT>
<NAME></NAME>
typedef struct _nsp_gengine_generic {
  driver_fill_grid_rectangles *fill_grid_rectangles;
  driver_fill_grid_rectangles1 *fill_grid_rectangles1 ;
  driver_drawarrows *drawarrows;
  driver_drawsegments *drawsegments;
  driver_drawrectangles *drawrectangles;
  driver_drawarcs *drawarcs;
  driver_fillarcs *fillarcs;
  driver_drawpolylines *drawpolylines;
  driver_fillpolylines *fillpolylines;
  driver_displaynumbers *displaynumbers;
  driver_drawaxis *drawaxis;
  driver_drawarc *drawarc;
  driver_fillarc *fillarc;
  driver_draw_pixbuf *draw_pixbuf;
  driver_draw_pixbuf_from_file *draw_pixbuf_from_file;
  driver_xset_test *xset_test;

} nsp_gengine_generic ;

extern nsp_gengine_generic nsp_peri_generic; 

struct nsp_gengine {
  nsp_gengine_generic *generic; /* A set of generic functions hidden here */
  char *name;
  int id;
  Gengine1 *scale;  /* */
  driver_fill_grid_rectangles *fill_grid_rectangles;
  driver_fill_grid_rectangles1 *fill_grid_rectangles1 ;
  driver_boundingbox *boundingbox;
  driver_cleararea *cleararea;
  driver_clearwindow *clearwindow;
  driver_displaynumbers *displaynumbers;
  driver_displaystring *displaystring;
  driver_drawarc *drawarc;
  driver_drawarcs *drawarcs;
  driver_drawarrows *drawarrows;
  driver_drawaxis *drawaxis;
  driver_drawpolyline *drawpolyline;
  driver_drawpolyline_clip *drawpolyline_clip;
  driver_drawpolylines *drawpolylines;
  driver_drawpolymark *drawpolymark;
  driver_drawrectangle *drawrectangle;
  driver_drawrectangles *drawrectangles;
  driver_drawsegments *drawsegments;
  driver_drawline *drawline;
  driver_fillarc *fillarc;
  driver_fillarcs *fillarcs;
  driver_fillpolyline *fillpolyline;
  driver_fillpolylines *fillpolylines;
  driver_fillrectangle *fillrectangle;
  driver_window_list_get_ids *window_list_get_ids;
  driver_initgraphic *initgraphic;
  driver_loadfamily *loadfamily;
  driver_queryfamily *queryfamily;
  driver_setpopupname *setpopupname;
  driver_xclick *xclick;
  driver_xclick_any *xclick_any;
  driver_xend *xend;
  driver_xgetmouse *xgetmouse;
  driver_xinfo *xinfo;
  driver_xpause *xpause;
  driver_xselgraphic  *xselgraphic ;
  driver_sedeco *sedeco;
  driver_tape_replay *tape_replay;
  driver_tape_clean_plots *tape_clean_plots;
  driver_tape_replay_new_angles *tape_replay_new_angles;
  driver_tape_replay_new_scale *tape_replay_new_scale;
  driver_tape_replay_undo_scale *tape_replay_undo_scale;
  driver_tape_check_recorded_3D *tape_check_recorded_3D;
  driver_xget_windowpos *xget_windowpos;
  driver_xset_windowpos *xset_windowpos;
  driver_xget_windowdim *xget_windowdim;
  driver_xset_windowdim *xset_windowdim;
  driver_xget_popupdim *xget_popupdim;
  driver_xset_popupdim *xset_popupdim;
  driver_xget_viewport *xget_viewport;
  driver_xset_viewport *xset_viewport;
  driver_xset_curwin *xset_curwin;
  driver_xget_curwin *xget_curwin;
  driver_xset_clip *xset_clip;
  driver_xset_unclip *xset_unclip;
  driver_xset_test *xset_test;
  driver_xget_clip *xget_clip;
  driver_xset_absourel *xset_absourel;
  driver_xget_absourel *xget_absourel;
  driver_xset_alufunction1 *xset_alufunction1;
  driver_xget_alufunction *xget_alufunction;
  driver_xset_thickness *xset_thickness;
  driver_xget_thickness *xget_thickness;
  driver_xset_pattern *xset_pattern;
  driver_xget_pattern *xget_pattern;
  driver_xget_last *xget_last;
  driver_xset_dash *xset_dash;
  driver_xset_line_style *xset_line_style;
  driver_xset_dashstyle *xset_dashstyle;
  driver_xget_dash *xget_dash;
  driver_xset_usecolor *xset_usecolor;
  driver_xget_usecolor *xget_usecolor;
  driver_xset_pixmapOn *xset_pixmapOn;
  driver_xget_pixmapOn *xget_pixmapOn;
  driver_xset_wresize *xset_wresize;
  driver_xget_wresize *xget_wresize;
  driver_xset_colormap *xset_colormap;
  driver_xset_default_colormap *xset_default_colormap;
  driver_xget_colormap *xget_colormap;
  driver_xset_background *xset_background;
  driver_xget_background * xget_background;
  driver_xset_foreground *xset_foreground;
  driver_xget_foreground *xget_foreground;
  driver_xset_hidden3d *xset_hidden3d;
  driver_xget_hidden3d *xget_hidden3d;
  driver_xset_mark *xset_mark;
  driver_xget_mark *xget_mark;
  driver_xset_font *xset_font;
  driver_xget_font * xget_font;
  driver_xset_autoclear *xset_autoclear;
  driver_xset_autoclear_def *xset_autoclear_def;
  driver_xget_autoclear *xget_autoclear;
  driver_xget_fpf *xget_fpf;
  driver_xset_fpf *xset_fpf;
  driver_xset_fpf_def *xset_fpf_def;
  driver_xset_pixmapclear *xset_pixmapclear;
  driver_xset_show *xset_show;
  driver_xset_default *xset_default;
  driver_pixmap_resize *pixmap_resize;
  driver_xget_recording *xget_recording;
  driver_xset_recording *xset_recording;
  driver_xset_win_protect *xset_win_protect;
  driver_delete_window *delete_window;
  driver_invalidate *invalidate;
  driver_process_updates *process_updates;
  driver_draw_pixbuf *draw_pixbuf;
  driver_draw_pixbuf_from_file *draw_pixbuf_from_file;

  driver_xpush_colormap *xpush_colormap;
  driver_xpop_colormap *xpop_colormap;

  driver_xstring_pango *xstring_pango;
};
</STRUCT>
<VARIABLE>
<NAME>use_new_graphics</NAME>
extern int use_new_graphics;
</VARIABLE>
<MACRO>
<NAME>GREYNUMBER</NAME>
#define GREYNUMBER 17
</MACRO>
<MACRO>
<NAME>DEFAULTNUMCOLORS</NAME>
#define DEFAULTNUMCOLORS 32
</MACRO>
<MACRO>
<NAME>DEFAULTBLACK</NAME>
#define DEFAULTBLACK 0
</MACRO>
<MACRO>
<NAME>DEFAULTWHITE</NAME>
#define DEFAULTWHITE 7
</MACRO>
<STRUCT>
<NAME>PoissonStruct</NAME>
</STRUCT>
<MACRO>
<NAME>SMALL_MEAN_POISSON_DIRECT_ALGO</NAME>
#define SMALL_MEAN_POISSON_DIRECT_ALGO 15  /* 15 is the minimum value */
</MACRO>
<MACRO>
<NAME>SMALL_MEAN_POISSON</NAME>
#define SMALL_MEAN_POISSON 35
</MACRO>
<STRUCT>
<NAME>PoissonStruct</NAME>
struct _PoissonStruct
{
  double mu;   /* main parameter */
  /* parameters used for mu <= SMALL_MEAN_POISSON */
  double cumpr[SMALL_MEAN_POISSON+4]; 
  int taille;
  int K;
  /* parameters used for mu > SMALL_MEAN_POISSON */
  double smu;
  double a;
  double aa;
  double b;
  double c;
  double invalpha;
  double vr;
  double urvr;
  double invvr;
} ;
</STRUCT>
<STRUCT>
<NAME>BinomialStruct</NAME>
</STRUCT>
<MACRO>
<NAME>SMALL_MEAN_BINOMIAL_DIRECT_ALGO</NAME>
#define SMALL_MEAN_BINOMIAL_DIRECT_ALGO 15
</MACRO>
<MACRO>
<NAME>SMALL_MEAN_BINOMIAL</NAME>
#define SMALL_MEAN_BINOMIAL 25
</MACRO>
<STRUCT>
<NAME>BinomialStruct</NAME>
struct _BinomialStruct
{
  int n;
  double p;
  int flipped;
  double r;
  /* parameters used for np <= SMALL_MEAN_BINOMIAL */
  double cumpr[SMALL_MEAN_BINOMIAL+4];
  int taille;
  int K;
  /* parameters used for np > SMALL_MEAN_BINOMIAL */
  int m;
  double npq;
  double a;
  double aa;
  double b;
  double c;
  double alpha;
  double vr;
  double urvr;
  double invvr;
  double h;
} ;
</STRUCT>
<STRUCT>
<NAME>GammaStruct</NAME>
</STRUCT>
<STRUCT>
<NAME>GammaStruct</NAME>
struct _GammaStruct
{
  double a;   /* main parameter */
  double c;
  double d;
} ;
</STRUCT>
<STRUCT>
<NAME>BetaStruct</NAME>
</STRUCT>
<STRUCT>
<NAME>BetaStruct</NAME>
struct _BetaStruct
{  
  GammaStruct a;
  GammaStruct b;
} ;
</STRUCT>
<STRUCT>
<NAME>NbnStruct</NAME>
</STRUCT>
<STRUCT>
<NAME>NbnStruct</NAME>
struct _NbnStruct
{
  double r;   /* main parameter */
  double p;   /* main parameter */
  double coef;
  GammaStruct G;
} ;
</STRUCT>
<STRUCT>
<NAME>Chi2Struct</NAME>
</STRUCT>
<STRUCT>
<NAME>Chi2Struct</NAME>
struct _Chi2Struct
{
  double nu;   /* main parameter */
  GammaStruct G;
} ;
</STRUCT>
<STRUCT>
<NAME>NcChi2Struct</NAME>
</STRUCT>
<STRUCT>
<NAME>NcChi2Struct</NAME>
struct _NcChi2Struct
{
  double nu;     /* main parameter */
  double xnonc;  /* main parameter */
  double sqrt_xnonc;
  GammaStruct G;
} ;
</STRUCT>
<STRUCT>
<NAME>FStruct</NAME>
</STRUCT>
<STRUCT>
<NAME>FStruct</NAME>
struct _FStruct
{  
  double nu1;
  double nu2;
  GammaStruct G1;
  GammaStruct G2;
} ;
</STRUCT>
<STRUCT>
<NAME>NcFStruct</NAME>
</STRUCT>
<STRUCT>
<NAME>NcFStruct</NAME>
struct _NcFStruct
{  
  NcChi2Struct X;
  Chi2Struct Y;
} ;
</STRUCT>
<STRUCT>
<NAME>GeomStruct</NAME>
</STRUCT>
<STRUCT>
<NAME>GeomStruct</NAME>
struct _GeomStruct
{
  double p;    /* main parameter */
  double inv_ln_1_m_p; 
} ;
</STRUCT>
<FUNCTION>
<NAME>pow_di</NAME>
<RETURNS>double </RETURNS>
double *ap, int *bp
</FUNCTION>
<MACRO>
<NAME>D_SIGN</NAME>
#define D_SIGN(a,b) ( b >= 0 ? (a >= 0 ? a : - a) : -(a >= 0 ? a : -a))
</MACRO>
<MACRO>
<NAME>D_INT</NAME>
#define D_INT(x) ( (x>0) ? floor(x) : -floor(- x) )
</MACRO>
<FUNCTION>
<NAME>nsp_set_current_gen</NAME>
<RETURNS>void </RETURNS>
int new_id
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_current_gen</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_geom_init</NAME>
<RETURNS>int </RETURNS>
double p, GeomStruct *G
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_geom</NAME>
<RETURNS>unsigned int </RETURNS>
GeomStruct *G
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_geom_direct</NAME>
<RETURNS>unsigned int </RETURNS>
double p
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_ncchi2_init</NAME>
<RETURNS>int </RETURNS>
double nu, double xnonc, NcChi2Struct *C
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_ncchi2</NAME>
<RETURNS>double </RETURNS>
NcChi2Struct *C
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_ncchi2_direct</NAME>
<RETURNS>double </RETURNS>
double nu, double xnonc
</FUNCTION>
<FUNCTION>
<NAME>rand_ignuin</NAME>
<RETURNS>int </RETURNS>
int a, int b
</FUNCTION>
<FUNCTION>
<NAME>rand_ranf</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_exp_core</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_exp</NAME>
<RETURNS>double </RETURNS>
double tau
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_nor_core</NAME>
<RETURNS>double </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_nor</NAME>
<RETURNS>double </RETURNS>
double mu, double sigma
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_gamma_init</NAME>
<RETURNS>int </RETURNS>
double a, GammaStruct *G
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_gamma</NAME>
<RETURNS>double </RETURNS>
GammaStruct *G
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_gamma_direct</NAME>
<RETURNS>double </RETURNS>
double a
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_beta_init</NAME>
<RETURNS>int </RETURNS>
double a, double b, BetaStruct *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_beta</NAME>
<RETURNS>double </RETURNS>
BetaStruct *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_beta_direct</NAME>
<RETURNS>double </RETURNS>
double a, double b
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_chi2_init</NAME>
<RETURNS>int </RETURNS>
double nu, Chi2Struct *C
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_chi2</NAME>
<RETURNS>double </RETURNS>
Chi2Struct *C
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_chi2_direct</NAME>
<RETURNS>double </RETURNS>
double nu
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_F_init</NAME>
<RETURNS>int </RETURNS>
double nu1, double nu2, FStruct *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_F</NAME>
<RETURNS>double </RETURNS>
FStruct *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_F_direct</NAME>
<RETURNS>double </RETURNS>
double nu1, double nu2
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_ncF_init</NAME>
<RETURNS>int </RETURNS>
double nu1, double nu2, double xnonc, NcFStruct *E
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_ncF</NAME>
<RETURNS>double </RETURNS>
NcFStruct *E
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_ncF_direct</NAME>
<RETURNS>double </RETURNS>
double nu1, double nu2, double xnonc
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_prm_array</NAME>
<RETURNS>int </RETURNS>
NspObject *Objarray
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_prm</NAME>
<RETURNS>void </RETURNS>
int *array, int n, int base
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_smpl_bis</NAME>
<RETURNS>void </RETURNS>
int *p, int n, int N, int base
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_smpl</NAME>
<RETURNS>void </RETURNS>
int *p, int n, int N, int base, int *head, int *next
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_poisson_init</NAME>
<RETURNS>int </RETURNS>
double mu, PoissonStruct *P
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_poisson</NAME>
<RETURNS>int </RETURNS>
PoissonStruct *P
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_poisson_direct</NAME>
<RETURNS>int </RETURNS>
double mu
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_binomial_init</NAME>
<RETURNS>int </RETURNS>
int n, double p, BinomialStruct *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_binomial</NAME>
<RETURNS>int </RETURNS>
BinomialStruct *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_binomial_direct</NAME>
<RETURNS>int </RETURNS>
int n, double p
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_nbn_init</NAME>
<RETURNS>int </RETURNS>
double r, double p, NbnStruct *N
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_nbn</NAME>
<RETURNS>int </RETURNS>
NbnStruct *N
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_nbn_direct</NAME>
<RETURNS>int </RETURNS>
double r, double p
</FUNCTION>
<FUNCTION>
<NAME>rand_phrtsd</NAME>
<RETURNS>int </RETURNS>
char *phrase,int *seed1, int *seed2
</FUNCTION>
<FUNCTION>
<NAME>nsp_alias_method</NAME>
<RETURNS>int </RETURNS>
double *p, double *q, int *j, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_guide_table_method</NAME>
<RETURNS>int </RETURNS>
double *p, int inc, double *q, int *key, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_guide_table_method_bis</NAME>
<RETURNS>int </RETURNS>
double *p, double *q, int *key, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_discrete_guide</NAME>
<RETURNS>int </RETURNS>
double *q, int *key, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_discrete_alias</NAME>
<RETURNS>int </RETURNS>
double *q, int *j, int n
</FUNCTION>
<FUNCTION>
<NAME>rand_unf_01_and_uin_0_127_and_sign</NAME>
<RETURNS>void </RETURNS>
double *u, int *k_7bits, int *k_1bits
</FUNCTION>
<FUNCTION>
<NAME>rand_unf_01_and_uin_0_127</NAME>
<RETURNS>void </RETURNS>
double *u, int *k_7bits
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_multinomial_bis</NAME>
<RETURNS>void </RETURNS>
double *q, int *key, int *ix, int ncat, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_multinomial</NAME>
<RETURNS>void </RETURNS>
double *p, int *ix, int ncat, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_markov_setup</NAME>
<RETURNS>int </RETURNS>
double *p, double *q, int *key, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_markov</NAME>
<RETURNS>void </RETURNS>
double *q, int *key, double *X0, double *X, int n, int X0mn, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_ndgauss</NAME>
<RETURNS>void </RETURNS>
double *Mean, double *C, double *res, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_sphere</NAME>
<RETURNS>void </RETURNS>
double *res, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_in_sphere</NAME>
<RETURNS>void </RETURNS>
double *res, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_simplex</NAME>
<RETURNS>void </RETURNS>
double *res, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_cauchy</NAME>
<RETURNS>double </RETURNS>
double sigma
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_pareto</NAME>
<RETURNS>double </RETURNS>
double a, double b
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_logistic</NAME>
<RETURNS>double </RETURNS>
double a, double b
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_rayleigh</NAME>
<RETURNS>double </RETURNS>
double sigma
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_tailrayleigh</NAME>
<RETURNS>double </RETURNS>
double sigma, double a
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_weibull</NAME>
<RETURNS>double </RETURNS>
double a, double b
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_laplace</NAME>
<RETURNS>double </RETURNS>
double a
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_lognormal</NAME>
<RETURNS>double </RETURNS>
double mu, double sigma
</FUNCTION>
<FUNCTION>
<NAME>nsp_rand_t</NAME>
<RETURNS>double </RETURNS>
double nu, double delta
</FUNCTION>
<MACRO>
<NAME>NbGenInNsp</NAME>
#define NbGenInNsp 6
</MACRO>
<STRUCT>
<NAME>NspRandomGen</NAME>
</STRUCT>
<STRUCT>
<NAME>NspRandomGen</NAME>
struct _NspRandomGen
{
  int id_gen;
  unsigned long (*gen)();
  const char *name_gen;
  int dim_state;
  unsigned long max_int; 
  double factor;              /* 1.0/(rng_max_int+1) */
  void (*get_state)(double *);
  int (*set_state)(double *);
  int (*set_state_simple)(double);
} ;
</STRUCT>
<VARIABLE>
<NAME>MersenneTwister</NAME>
extern NspRandomGen MersenneTwister;
</VARIABLE>
<VARIABLE>
<NAME>Kiss</NAME>
extern NspRandomGen Kiss;
</VARIABLE>
<VARIABLE>
<NAME>Fsultra</NAME>
extern NspRandomGen Fsultra;
</VARIABLE>
<VARIABLE>
<NAME>Well1024a</NAME>
extern NspRandomGen Well1024a;
</VARIABLE>
<VARIABLE>
<NAME>Clcg4</NAME>
extern NspRandomGen Clcg4;
</VARIABLE>
<VARIABLE>
<NAME>Clcg2</NAME>
extern NspRandomGen Clcg2;
</VARIABLE>
<FUNCTION>
<NAME>randmt</NAME>
<RETURNS>unsigned long </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>randbcpl</NAME>
<RETURNS>unsigned long </RETURNS>
unsigned long s
</FUNCTION>
<MACRO>
<NAME>Maxgen</NAME>
#define Maxgen  100
</MACRO>
<ENUM>
<NAME>SeedType</NAME>
typedef  enum {InitialSeed, LastSeed, NewSeed}  SeedType;
</ENUM>
<FUNCTION>
<NAME>set_current_clcg4</NAME>
<RETURNS>int </RETURNS>
int new_clcg4_gen
</FUNCTION>
<FUNCTION>
<NAME>get_current_clcg4</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>init_generator_clcg4</NAME>
<RETURNS>void </RETURNS>
SeedType Where
</FUNCTION>
<FUNCTION>
<NAME>set_initial_seed_clcg4</NAME>
<RETURNS>int </RETURNS>
double s[]
</FUNCTION>
<FUNCTION>
<NAME>advance_state_clcg4</NAME>
<RETURNS>void </RETURNS>
int k
</FUNCTION>
<MACRO>
<NAME>INTERSIZ</NAME>
#define INTERSIZ 256
</MACRO>
<TYPEDEF>
<NAME>mxArray</NAME>
typedef NspObject mxArray ;
</TYPEDEF>
<TYPEDEF>
<NAME>mxLogical</NAME>
typedef int mxLogical; /* should be int on Nsp */
</TYPEDEF>
<TYPEDEF>
<NAME>mxChar</NAME>
typedef char mxChar;
</TYPEDEF>
<ENUM>
<NAME>mxComplexity</NAME>
typedef enum { mxREAL, mxCOMPLEX } mxComplexity; 
</ENUM>
<TYPEDEF>
<NAME>bool</NAME>
typedef int bool;
</TYPEDEF>
<MACRO>
<NAME>true</NAME>
#define true TRUE 
</MACRO>
<MACRO>
<NAME>false</NAME>
#define false FALSE
</MACRO>
<MACRO>
<NAME>mxAssert</NAME>
#define mxAssert(cond,mess) if ( !(cond) ) _mxAssert(mess,__LINE__,__FILE__) ;
</MACRO>
<FUNCTION>
<NAME>nsp_mex_wrapper</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs,mexfun *mexFunction
</FUNCTION>
<FUNCTION>
<NAME>mxGetPr</NAME>
<RETURNS>double *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetPi</NAME>
<RETURNS>double *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetM</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetN</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsString</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsNumeric</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsFull</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsSparse</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsComplex</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetScalar</NAME>
<RETURNS>double </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mexErrMsgTxt</NAME>
<RETURNS>void </RETURNS>
const char *error_msg
</FUNCTION>
<FUNCTION>
<NAME>mexErrMsgIdAndTxt</NAME>
<RETURNS>void </RETURNS>
const char *id,const char *error_msg
</FUNCTION>
<FUNCTION>
<NAME>mexWarnMsgIdAndTxt</NAME>
<RETURNS>void </RETURNS>
const char *id,const char *error_msg
</FUNCTION>
<FUNCTION>
<NAME>mxCreateFull</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n, int it
</FUNCTION>
<FUNCTION>
<NAME>mxCreateDoubleMatrix</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n,  mxComplexity it
</FUNCTION>
<FUNCTION>
<NAME>mxCalloc</NAME>
<RETURNS>void *</RETURNS>
unsigned int n, unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>mxGetString</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr, char *str, int strl
</FUNCTION>
<FUNCTION>
<NAME>mxFreeMatrix</NAME>
<RETURNS>void </RETURNS>
mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxFree</NAME>
<RETURNS>void </RETURNS>
void *ptr
</FUNCTION>
<FUNCTION>
<NAME>mexAtExit</NAME>
<RETURNS>int </RETURNS>
void (*ExitFcn)(void)
</FUNCTION>
<FUNCTION>
<NAME>mxCreateSparse</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n, int nzmax,mxComplexity ComplexFlag
</FUNCTION>
<FUNCTION>
<NAME>mxCreateString</NAME>
<RETURNS>mxArray *</RETURNS>
const char *string
</FUNCTION>
<FUNCTION>
<NAME>mxGetJc</NAME>
<RETURNS>int *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetIr</NAME>
<RETURNS>int *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsChar</NAME>
<RETURNS>bool </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetNumberOfDimensions</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetNumberOfFields</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetNumberOfElements</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsStruct</NAME>
<RETURNS>bool </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateStructMatrix</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n, int nfields, const char **field_names
</FUNCTION>
<FUNCTION>
<NAME>mxGetInf</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxGetNaN</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxGetEps</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxIsInf</NAME>
<RETURNS>bool </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>mxIsFinite</NAME>
<RETURNS>bool </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>mxIsNaN</NAME>
<RETURNS>bool </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>mxGetScalar</NAME>
<RETURNS>double </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetField</NAME>
<RETURNS>mxArray *</RETURNS>
const mxArray *pa, int i,const char *fieldname
</FUNCTION>
<FUNCTION>
<NAME>mxSetField</NAME>
<RETURNS>void </RETURNS>
mxArray *pa, int i, const char *fieldname, mxArray *value
</FUNCTION>
<FUNCTION>
<NAME>mexWarnMsgTxt</NAME>
<RETURNS>void </RETURNS>
const char *error_msg
</FUNCTION>
<FUNCTION>
<NAME>mxIsCell</NAME>
<RETURNS>bool </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetCell</NAME>
<RETURNS>mxArray *</RETURNS>
const mxArray *ptr, int index
</FUNCTION>
<FUNCTION>
<NAME>mxSetCell</NAME>
<RETURNS>void </RETURNS>
mxArray *ptr, int index, mxArray *value
</FUNCTION>
<FUNCTION>
<NAME>mxCreateCellMatrix</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>mxArrayToString</NAME>
<RETURNS>char *</RETURNS>
const mxArray *ptr
</FUNCTION>
<MACRO>
<NAME>mexPrintf</NAME>
#define mexPrintf Sciprintf
</MACRO>
<TYPEDEF>
<NAME>mxClassID</NAME>
typedef int  mxClassID;
</TYPEDEF>
<FUNCTION>
<NAME>mxGetClassID</NAME>
<RETURNS>mxClassID </RETURNS>
const mxArray *ptr
</FUNCTION>
<MACRO>
<NAME>mxUNKNOWN_CLASS</NAME>
#define  mxUNKNOWN_CLASS 0
</MACRO>
<MACRO>
<NAME>mxCELL_CLASS</NAME>
#define  mxCELL_CLASS  nsp_type_cells_id
</MACRO>
<MACRO>
<NAME>mxSTRUCT_CLASS</NAME>
#define  mxSTRUCT_CLASS  nsp_type_hash_id 
</MACRO>
<MACRO>
<NAME>mxCHAR_CLASS</NAME>
#define  mxCHAR_CLASS  nsp_type_smatrix_id
</MACRO>
<MACRO>
<NAME>mxLOGICAL_CLASS</NAME>
#define  mxLOGICAL_CLASS  nsp_type_bmatrix_id
</MACRO>
<MACRO>
<NAME>mxDOUBLE_CLASS</NAME>
#define  mxDOUBLE_CLASS  nsp_type_matrix_id
</MACRO>
<MACRO>
<NAME>mxOBJECT_CLASS</NAME>
#define  mxOBJECT_CLASS  nsp_type_object_id
</MACRO>
<MACRO>
<NAME>mxSPARSE_CLASS</NAME>
#define  mxSPARSE_CLASS  nsp_type_spcolmatrix_id
</MACRO>
<MACRO>
<NAME>mxSINGLE_CLASS</NAME>
#define  mxSINGLE_CLASS  -1 
</MACRO>
<MACRO>
<NAME>mxINT8_CLASS</NAME>
#define  mxINT8_CLASS  -2
</MACRO>
<MACRO>
<NAME>mxUINT8_CLASS</NAME>
#define  mxUINT8_CLASS  -3
</MACRO>
<MACRO>
<NAME>mxINT16_CLASS</NAME>
#define  mxINT16_CLASS  -4
</MACRO>
<MACRO>
<NAME>mxUINT16_CLASS</NAME>
#define  mxUINT16_CLASS  -5
</MACRO>
<MACRO>
<NAME>mxINT32_CLASS</NAME>
#define  mxINT32_CLASS  -6
</MACRO>
<MACRO>
<NAME>mxUINT32_CLASS</NAME>
#define  mxUINT32_CLASS  -7
</MACRO>
<MACRO>
<NAME>mxINT64_CLASS</NAME>
#define  mxINT64_CLASS  -8
</MACRO>
<MACRO>
<NAME>mxUINT64_CLASS</NAME>
#define  mxUINT64_CLASS  -9
</MACRO>
<MACRO>
<NAME>mxOPAQUE_CLASS</NAME>
#define  mxOPAQUE_CLASS  -10
</MACRO>
<MACRO>
<NAME>mxFUNCTION_CLASS</NAME>
#define  mxFUNCTION_CLASS  nsp_type_plist_id 
</MACRO>
<FUNCTION>
<NAME>mxMalloc</NAME>
<RETURNS>void *</RETURNS>
size_t n
</FUNCTION>
<FUNCTION>
<NAME>mxDestroyArray</NAME>
<RETURNS>void </RETURNS>
mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxDestroyNamedArray</NAME>
<RETURNS>void </RETURNS>
mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateCellArray</NAME>
<RETURNS>mxArray *</RETURNS>
int ndim, const int *dims
</FUNCTION>
<FUNCTION>
<NAME>mxCalcSingleSubscript</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr, int nsubs,const int *subs
</FUNCTION>
<FUNCTION>
<NAME>mexPutVariable</NAME>
<RETURNS>int </RETURNS>
const char *workspace, const char *var_name,mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateCharMatrixFromStrings</NAME>
<RETURNS>mxArray *</RETURNS>
int m, const char **str
</FUNCTION>
<FUNCTION>
<NAME>mexCallMATLAB</NAME>
<RETURNS>int </RETURNS>
int nlhs, mxArray *plhs[], int nrhs,mxArray *prhs[],const char *command_name
</FUNCTION>
<MACRO>
<NAME>mexCallNsp</NAME>
#define mexCallNsp mexCallMATLAB
</MACRO>
<MACRO>
<NAME>mexCallScilab</NAME>
#define mexCallScilab mexCallMATLAB
</MACRO>
<FUNCTION>
<NAME>mxDuplicateArray</NAME>
<RETURNS>mxArray *</RETURNS>
const mxArray *in
</FUNCTION>
<FUNCTION>
<NAME>mxSetName</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr,const char *var_name
</FUNCTION>
<FUNCTION>
<NAME>mexPutArray</NAME>
<RETURNS>int </RETURNS>
 mxArray *array_ptr,const char *workspace
</FUNCTION>
<FUNCTION>
<NAME>mexEvalString</NAME>
<RETURNS>int </RETURNS>
 char *command
</FUNCTION>
<FUNCTION>
<NAME>mxGetDimensions</NAME>
<RETURNS>int *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxSetNzmax</NAME>
<RETURNS>int </RETURNS>
 mxArray *array_ptr,int n
</FUNCTION>
<FUNCTION>
<NAME>mxGetNzmax</NAME>
<RETURNS>int </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateScalarDouble</NAME>
<RETURNS>mxArray *</RETURNS>
double value
</FUNCTION>
<FUNCTION>
<NAME>mxCreateDoubleScalar</NAME>
<RETURNS>mxArray *</RETURNS>
double value
</FUNCTION>
<FUNCTION>
<NAME>mxIsEmpty</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mexMakeArrayPersistent</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateLogicalScalar</NAME>
<RETURNS>mxArray *</RETURNS>
mxLogical value
</FUNCTION>
<FUNCTION>
<NAME>mexMakeMemoryPersistent</NAME>
<RETURNS>void </RETURNS>
void *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsLogicalScalarTrue</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mexLock</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mexUnlock</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mexIsLocked</NAME>
<RETURNS>bool </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxIsLogicalScalar</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsLogical</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetFieldNameByNumber</NAME>
<RETURNS>const char *</RETURNS>
const mxArray *array_ptr,int field_number
</FUNCTION>
<FUNCTION>
<NAME>mxGetData</NAME>
<RETURNS>void *</RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateCharArray</NAME>
<RETURNS>mxArray *</RETURNS>
int ndim, const int *dims
</FUNCTION>
<FUNCTION>
<NAME>mxGetFieldByNumber</NAME>
<RETURNS>mxArray *</RETURNS>
const mxArray *array_ptr, int index,int field_number
</FUNCTION>
<FUNCTION>
<NAME>mxGetElementSize</NAME>
<RETURNS>int </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetChars</NAME>
<RETURNS>mxChar *</RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetLogicals</NAME>
<RETURNS>mxLogical *</RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetClassName</NAME>
<RETURNS>const char *</RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsSharedArray</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxUnshareArray</NAME>
<RETURNS>void </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateLogicalArray</NAME>
<RETURNS>mxArray *</RETURNS>
int ndim, const int *dims
</FUNCTION>
<FUNCTION>
<NAME>mxCreateLogicalMatrix</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>mxIsDouble</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsInt8</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsInt16</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsInt32</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsInt64</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsUint8</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsUint16</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsUint32</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsUint64</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateStructArray</NAME>
<RETURNS>mxArray *</RETURNS>
int ndim, const int *dims, int nfields,const char **field_names
</FUNCTION>
<FUNCTION>
<NAME>mexGetVariable</NAME>
<RETURNS>mxArray *</RETURNS>
const char *workspace, const char *var_name
</FUNCTION>
<FUNCTION>
<NAME>mexGetVariablePtr</NAME>
<RETURNS>mxArray *</RETURNS>
const char *workspace, const char *var_name
</FUNCTION>
<FUNCTION>
<NAME>mexGetArray</NAME>
<RETURNS>mxArray *</RETURNS>
const char *name, const char *workspace
</FUNCTION>
<FUNCTION>
<NAME>mxSetLogical</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxSetData</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr, void *pr
</FUNCTION>
<FUNCTION>
<NAME>mxSetPr</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr, double *pr
</FUNCTION>
<FUNCTION>
<NAME>mxSetJc</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr, int *jc
</FUNCTION>
<FUNCTION>
<NAME>mxSetIr</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr,int *ir
</FUNCTION>
<FUNCTION>
<NAME>mxRealloc</NAME>
<RETURNS>void *</RETURNS>
void *ptr, size_t size
</FUNCTION>
<FUNCTION>
<NAME>mxSetPi</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr, double *pi
</FUNCTION>
<TYPEDEF>
<NAME>mwSize</NAME>
typedef int mwSize; 
</TYPEDEF>
<TYPEDEF>
<NAME>mwIndex</NAME>
typedef int mwIndex; 
</TYPEDEF>
<FUNCTION>
<NAME>mxSetN</NAME>
<RETURNS>void </RETURNS>
mxArray *ptr, mwSize n
</FUNCTION>
<FUNCTION>
<NAME>mxSetM</NAME>
<RETURNS>void </RETURNS>
mxArray *ptr, mwSize m
</FUNCTION>
<FUNCTION>
<NAME>mxCreateSparseLogicalMatrix</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n, int nzmax
</FUNCTION>
<FUNCTION>
<NAME>mxCreateNumericArray</NAME>
<RETURNS>mxArray *</RETURNS>
int ndim, const int *dims,mxClassID xclass,mxComplexity ComplexFlag
</FUNCTION>
<FUNCTION>
<NAME>mxSetFieldByNumber</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr, int index,int field_number, mxArray *value
</FUNCTION>
<FUNCTION>
<NAME>mxFreeSparseMtlbTriplet</NAME>
<RETURNS>void </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxSparseMtlbTripletTonsp</NAME>
<RETURNS>void </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mexSetTrapFlag</NAME>
<RETURNS>void </RETURNS>
int trapflag
</FUNCTION>
<FUNCTION>
<NAME>mexCheck</NAME>
<RETURNS>int </RETURNS>
const char *str,int nbvars
</FUNCTION>
<FUNCTION>
<NAME>mat2fort</NAME>
<RETURNS>void *</RETURNS>
const mxArray *ptr, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>fort2mat</NAME>
<RETURNS>mxArray *</RETURNS>
void *data,int lda, int m, int n
</FUNCTION>
