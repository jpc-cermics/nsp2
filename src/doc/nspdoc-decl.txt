<MACRO>
<NAME>VERSION</NAME>
#define VERSION "scilab-2.7-CVS-2002-11-04"
</MACRO>
<MACRO>
<NAME>DEFAULT_MES</NAME>
#define DEFAULT_MES "scilab-2.7-CVS-2002-11-04 Scilab Group (Inria, Enpc)"
</MACRO>
<STRUCT>
<NAME>NspBlock</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeBlock</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeBlock</NAME>
struct _NspTypeBlock { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<TYPEDEF>
<NAME>grb_lock</NAME>
typedef struct b_lock grb_lock ; 
</TYPEDEF>
<STRUCT>
<NAME>b_lock</NAME>
struct b_lock {
  gr_port port;  /* Only one port */
  double pt[2]; /* lock position in the frame*/
  double ptr[2]; /* lock position (relative position in the block)*/
  int type ; /* type of the lock point */
};
</STRUCT>
<STRUCT>
<NAME>nsp_block</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_block</NAME>
struct _nsp_block {
  nsp_gframe *frame;/* a block must be in a frame to be drawn */
  void *object_sid;
  double r[4]; 		
  int color;
  int thickness;
  int background;
  int n_locks ; /* number of lock points */
  grb_lock *locks; 
  int hilited ; 
  int show    ;   
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspBlock</NAME>
struct _NspBlock {
  /*< private >*/
  NspObject father; 
  NspTypeBlock *type; 
  /*< public >*/
  nsp_block *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_block_id</NAME>
extern int nsp_type_block_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_block</NAME>
extern NspTypeBlock *nsp_type_block;
</VARIABLE>
<FUNCTION>
<NAME>new_type_block</NAME>
<RETURNS>NspTypeBlock *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_block</NAME>
<RETURNS>NspBlock *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>IsBlockObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetBlockCopy</NAME>
<RETURNS>NspBlock *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetBlock</NAME>
<RETURNS>NspBlock *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsBlock</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>block_create</NAME>
<RETURNS>NspBlock *</RETURNS>
char *name,double rect[],int color,int thickness,int background, NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_block_create</NAME>
<RETURNS>NspBlock *</RETURNS>
NspBlock *H,double *rect,int color,int thickness,int background
</FUNCTION>
<MACRO>
<NAME>NULLBLOCK</NAME>
#define NULLBLOCK (NspBlock*) 0
</MACRO>
<MACRO>
<NAME>HAVE_INLINE</NAME>
#define HAVE_INLINE 1
</MACRO>
<MACRO>
<NAME>HAVE_VALUES_H</NAME>
#define HAVE_VALUES_H 1
</MACRO>
<MACRO>
<NAME>HAVE_FLOAT_H</NAME>
#define HAVE_FLOAT_H 1
</MACRO>
<MACRO>
<NAME>HAVE_LIMITS_H</NAME>
#define HAVE_LIMITS_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_TIME_H</NAME>
#define HAVE_SYS_TIME_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_RESOURCE_H</NAME>
#define HAVE_SYS_RESOURCE_H 1
</MACRO>
<MACRO>
<NAME>WTU</NAME>
#define WTU 1
</MACRO>
<MACRO>
<NAME>USE_SHARP_SIGN</NAME>
#define USE_SHARP_SIGN 1
</MACRO>
<MACRO>
<NAME>HAVE_EXP10</NAME>
#define HAVE_EXP10 1
</MACRO>
<MACRO>
<NAME>HAVE_TGAMMA</NAME>
#define HAVE_TGAMMA 1
</MACRO>
<MACRO>
<NAME>HAVE_LGAMMA</NAME>
#define HAVE_LGAMMA 1
</MACRO>
<MACRO>
<NAME>HAVE_GETWD</NAME>
#define HAVE_GETWD 1
</MACRO>
<MACRO>
<NAME>HAVE_GETCWD</NAME>
#define HAVE_GETCWD 1
</MACRO>
<MACRO>
<NAME>HAVE_MKSTEMP</NAME>
#define HAVE_MKSTEMP 1
</MACRO>
<MACRO>
<NAME>HAVE_SLEEP</NAME>
#define HAVE_SLEEP 1
</MACRO>
<MACRO>
<NAME>HAVE_STRERROR</NAME>
#define HAVE_STRERROR 1
</MACRO>
<MACRO>
<NAME>HAVE_TERMCAP</NAME>
#define HAVE_TERMCAP 1
</MACRO>
<MACRO>
<NAME>HAVE_USLEEP</NAME>
#define HAVE_USLEEP 1
</MACRO>
<MACRO>
<NAME>HAVE_GETRUSAGE</NAME>
#define HAVE_GETRUSAGE 1
</MACRO>
<MACRO>
<NAME>HAVE_CLOCK</NAME>
#define HAVE_CLOCK 1
</MACRO>
<MACRO>
<NAME>HAVE_TIMES</NAME>
#define HAVE_TIMES 1
</MACRO>
<MACRO>
<NAME>HAVE_ISINF</NAME>
#define HAVE_ISINF 1
</MACRO>
<MACRO>
<NAME>HAVE_ISNAN</NAME>
#define HAVE_ISNAN 1
</MACRO>
<MACRO>
<NAME>HAVE_FINITE</NAME>
#define HAVE_FINITE 1
</MACRO>
<MACRO>
<NAME>WITH_PVM</NAME>
#define WITH_PVM 1
</MACRO>
<MACRO>
<NAME>WITH_GTKGLEXT</NAME>
#define WITH_GTKGLEXT 1
</MACRO>
<MACRO>
<NAME>WITH_GTKHTML</NAME>
#define WITH_GTKHTML 1
</MACRO>
<MACRO>
<NAME>WITH_UMFPACK</NAME>
#define WITH_UMFPACK 1
</MACRO>
<MACRO>
<NAME>WITH_CHOLMOD</NAME>
#define WITH_CHOLMOD 1
</MACRO>
<MACRO>
<NAME>WITH_FFTW3</NAME>
#define WITH_FFTW3 1
</MACRO>
<MACRO>
<NAME>WITH_SNDFILE</NAME>
#define WITH_SNDFILE 1
</MACRO>
<MACRO>
<NAME>WITH_ASOUND</NAME>
#define WITH_ASOUND 1
</MACRO>
<MACRO>
<NAME>WITH_GMP</NAME>
#define WITH_GMP 1
</MACRO>
<MACRO>
<NAME>POINTER_INT</NAME>
#define POINTER_INT 1
</MACRO>
<MACRO>
<NAME>NSP_INT_TO_POINTER</NAME>
#define NSP_INT_TO_POINTER(i) ((int *) (i))
</MACRO>
<MACRO>
<NAME>NSP_POINTER_TO_INT</NAME>
#define NSP_POINTER_TO_INT(i) ((int) (i))
</MACRO>
<MACRO>
<NAME>NSP_INT_TO_POINTER</NAME>
#define NSP_INT_TO_POINTER(i) ((int *) (long) (i))
</MACRO>
<MACRO>
<NAME>NSP_POINTER_TO_INT</NAME>
#define NSP_POINTER_TO_INT(i) ((int) (long) (i))
</MACRO>
<MACRO>
<NAME>CNAME</NAME>
#define CNAME(name1,name2) name1##name2
</MACRO>
<MACRO>
<NAME>CNAME</NAME>
#define CNAME(name1,name2) name1/**/name2
</MACRO>
<MACRO>
<NAME>C2F</NAME>
#define C2F(name) name##_
</MACRO>
<MACRO>
<NAME>F2C</NAME>
#define F2C(name) name##_
</MACRO>
<MACRO>
<NAME>C2F</NAME>
#define C2F(name) name/**/_
</MACRO>
<MACRO>
<NAME>F2C</NAME>
#define F2C(name) name/**/_
</MACRO>
<MACRO>
<NAME>C2F</NAME>
#define C2F(name) name
</MACRO>
<MACRO>
<NAME>F2C</NAME>
#define F2C(name) name
</MACRO>
<MACRO>
<NAME>exp10</NAME>
#define exp10(x) pow((double) 10.0,x)
</MACRO>
<FUNCTION>
<NAME>exp10</NAME>
<RETURNS>double </RETURNS>
double
</FUNCTION>
<MACRO>
<NAME>getwd</NAME>
#define getwd(x) getcwd(x,1024) /* you must define char x[1024] */
</MACRO>
<TYPEDEF>
<NAME>integer</NAME>
typedef int integer;
</TYPEDEF>
<MACRO>
<NAME>DBL_EPSILON</NAME>
#   define  DBL_EPSILON             2.2204460492503131e-16
</MACRO>
<MACRO>
<NAME>DBL_MAX</NAME>
#   define  DBL_MAX                 1.7976931348623158e+308
</MACRO>
<MACRO>
<NAME>DBL_MIN</NAME>
#   define  DBL_MIN                 2.2250738585072014e-308
</MACRO>
<MACRO>
<NAME>SHRT_MAX</NAME>
#   define  SHRT_MAX                32767
</MACRO>
<MACRO>
<NAME>LONG_MAX</NAME>
#   define  LONG_MAX                2147483647
</MACRO>
<MACRO>
<NAME>MACHINE_RESOLUTION</NAME>
#   define  MACHINE_RESOLUTION      DBL_EPSILON
</MACRO>
<MACRO>
<NAME>LARGEST_REAL</NAME>
#   define  LARGEST_REAL            DBL_MAX
</MACRO>
<MACRO>
<NAME>SMALLEST_REAL</NAME>
#   define  SMALLEST_REAL           DBL_MIN
</MACRO>
<MACRO>
<NAME>LARGEST_SHORT_INTEGER</NAME>
#   define  LARGEST_SHORT_INTEGER   SHRT_MAX
</MACRO>
<MACRO>
<NAME>LARGEST_LONG_INTEGER</NAME>
#   define  LARGEST_LONG_INTEGER    LONG_MAX
</MACRO>
<MACRO>
<NAME>WITH_SYMB_TABLE</NAME>
#define WITH_SYMB_TABLE 1
</MACRO>
<MACRO>
<NAME>MTLB_MODE</NAME>
#define MTLB_MODE 1
</MACRO>
<MACRO>
<NAME>UPDATE_EXEC_DIR</NAME>
#define UPDATE_EXEC_DIR 1
</MACRO>
<STRUCT>
<NAME>NspCells</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeCells</NAME>
typedef struct _NspTypeCells { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeCells;
</STRUCT>
<STRUCT>
<NAME>NspCells</NAME>
struct _NspCells {
  /*< private >*/
  NspObject father; 
  NspTypeCells *type; 
  /*< public >*/
  int m,n,mn;
  NspObject **objs;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_cells_id</NAME>
extern int nsp_type_cells_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_cells</NAME>
extern NspTypeCells *nsp_type_cells;
</VARIABLE>
<FUNCTION>
<NAME>new_type_cells</NAME>
<RETURNS>NspTypeCells *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_cells</NAME>
<RETURNS>NspCells *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_object</NAME>
<RETURNS>NspCells *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsCellsObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsCells</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetCellsCopy</NAME>
<RETURNS>NspCells *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetCells</NAME>
<RETURNS>NspCells *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_create</NAME>
<RETURNS>NspCells *</RETURNS>
const char *name, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_clone</NAME>
<RETURNS>NspCells *</RETURNS>
const char *name, NspCells *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_create_from_table</NAME>
<RETURNS>NspCells *</RETURNS>
const char *name,NspObject **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_create_from_array</NAME>
<RETURNS>NspCells *</RETURNS>
const char *name,int n, NspObject **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_copy</NAME>
<RETURNS>NspCells *</RETURNS>
const NspCells *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_resize</NAME>
<RETURNS>int </RETURNS>
NspCells *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspCells *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_destroy</NAME>
<RETURNS>void </RETURNS>
NspCells *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_info</NAME>
<RETURNS>int </RETURNS>
const NspCells *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_print</NAME>
<RETURNS>int </RETURNS>
const NspCells *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_redim</NAME>
<RETURNS>int </RETURNS>
NspCells *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_enlarge</NAME>
<RETURNS>int </RETURNS>
NspCells *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_concat_right</NAME>
<RETURNS>int </RETURNS>
NspCells *A,const NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_add_columns</NAME>
<RETURNS>int </RETURNS>
NspCells *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_concat_down</NAME>
<RETURNS>NspCells *</RETURNS>
const NspCells *A,const NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_add_rows</NAME>
<RETURNS>int </RETURNS>
NspCells *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspCells *A,const NspMatrix *Rows,const NspMatrix *Cols,const NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_set_rows</NAME>
<RETURNS>int </RETURNS>
NspCells *A, NspMatrix *Rows, NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract_elements</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *A, NspMatrix *Elts, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract_columns</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>CellsLoopCol</NAME>
<RETURNS>NspCells *</RETURNS>
char *str, NspCells *Col, NspCells *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_extract_rows</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_set_element</NAME>
<RETURNS>int </RETURNS>
NspCells *A,int index, NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_unique</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *C, NspMatrix **Ind, NspMatrix **Occ
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_has</NAME>
<RETURNS>Boolean </RETURNS>
NspCells *C, NspObject *Obj, int *ind
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_map</NAME>
<RETURNS>NspCells *</RETURNS>
NspCells *C, NspPList *PL, NspList *args
</FUNCTION>
<MACRO>
<NAME>NULLCELLS</NAME>
#define NULLCELLS (NspCells *) NULL
</MACRO>
<FUNCTION>
<NAME>nsp_cells_strcmp</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspCells *A, NspCells *B
</FUNCTION>
<FUNCTION>
<NAME>CellsCompOp</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspCells *A, NspCells *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>CellsFullComp</NAME>
<RETURNS>int </RETURNS>
NspCells *A, NspCells *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_cells_transpose</NAME>
<RETURNS>NspCells *</RETURNS>
const NspCells *A
</FUNCTION>
<STRUCT>
<NAME>NspLmo</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeLmo</NAME>
typedef struct _NspTypeLmo { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeLmo;
</STRUCT>
<STRUCT>
<NAME>NspLmo</NAME>
struct _NspLmo {
  /*< private >*/
  NspObject father; 
  NspTypeLmo *type; 
  /*< public >*/
  char *path;  
  char *module;
} ;
</STRUCT>
<VARIABLE>
<NAME>nsp_type_lmo_id</NAME>
extern int nsp_type_lmo_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_lmo</NAME>
extern NspTypeLmo *nsp_type_lmo;
</VARIABLE>
<FUNCTION>
<NAME>new_type_lmo</NAME>
<RETURNS>NspTypeLmo *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_lmo</NAME>
<RETURNS>NspLmo *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>LmoType</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>LmoShType</NAME>
<RETURNS>char *</RETURNS>
NspLmo *M
</FUNCTION>
<FUNCTION>
<NAME>LmoLoopExtract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>LmoObjEq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>LmoObjNeq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLLMO</NAME>
#define NULLLMO ( NspLmo *) 0 
</MACRO>
<FUNCTION>
<NAME>module_path_search_name</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,NspSMatrix *Sm,char **oname
</FUNCTION>
<FUNCTION>
<NAME>module_path_search_object</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,NspSMatrix *Sm,char **oname
</FUNCTION>
<STRUCT>
<NAME>NspConnector</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeConnector</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeConnector</NAME>
struct _NspTypeConnector { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
}; 
</STRUCT>
<STRUCT>
<NAME>gr_lock</NAME>
</STRUCT>
<STRUCT>
<NAME>gr_lock</NAME>
struct _gr_lock {
  int n_ports ;
  int fixed ;   /* flag: if fixed == TRUE the number of ports cannot be changed 
		 * after creation
		 */
  gr_port *ports; 
  double pt[2]; /* lock position */
};
</STRUCT>
<STRUCT>
<NAME>nsp_connector</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_connector</NAME>
struct _nsp_connector {
  nsp_gframe *frame; /* a link must be in a frame to be drawn */
  void *object_sid;
  double r[4];
  int color; 
  int thickness;
  int background;
  gr_lock lock; /* Only one lock point for a connector */
  int hilited ; 
  int show    ;   
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspConnector</NAME>
struct _NspConnector {
  /*< private >*/
  NspObject father; 
  NspTypeConnector *type; 
  /*< public >*/
  nsp_connector *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_connector_id</NAME>
extern int nsp_type_connector_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_connector</NAME>
extern NspTypeConnector *nsp_type_connector;
</VARIABLE>
<FUNCTION>
<NAME>new_type_connector</NAME>
<RETURNS>NspTypeConnector *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_connector</NAME>
<RETURNS>NspConnector *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCONNECTOR</NAME>
#define NULLCONNECTOR (NspConnector*) 0
</MACRO>
<FUNCTION>
<NAME>connector_object</NAME>
<RETURNS>NspConnector *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsConnectorObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetConnectorCopy</NAME>
<RETURNS>NspConnector *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetConnector</NAME>
<RETURNS>NspConnector *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsConnector</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>connector_create</NAME>
<RETURNS>NspConnector *</RETURNS>
char *name,double rect[],int color,int thickness,int background,NspTypeBase *type
</FUNCTION>
<TYPEDEF>
<NAME>nsp_string</NAME>
typedef char * nsp_string ; /* a string i.e char * */
</TYPEDEF>
<TYPEDEF>
<NAME>nsp_const_string</NAME>
typedef const char *nsp_const_string ;  /* a constant string */
</TYPEDEF>
<FUNCTION>
<NAME>new_nsp_string</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_basic_to_string</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_copy</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_destroy</NAME>
<RETURNS>void </RETURNS>
nsp_string *str
</FUNCTION>
<FUNCTION>
<NAME>new_nsp_string_n</NAME>
<RETURNS>nsp_string </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_resize</NAME>
<RETURNS>int </RETURNS>
nsp_string *hstr, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_to_utf8</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_string</NAME>
<RETURNS>nsp_string </RETURNS>
nsp_const_string bytes,int length
</FUNCTION>
<STRUCT>
<NAME>NspClassA</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeClassA</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>classa_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspClassA *M
</USER_FUNCTION>
<STRUCT>
<NAME>NspTypeClassA</NAME>
struct _NspTypeClassA { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>NspClassA</NAME>
struct _NspClassA {
  /*< private >*/
  NspObject father; 
  NspTypeClassA *type; 
  /*< public >*/
  int classa_color;
  int classa_thickness;
  NspMatrix *classa_val;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_classa_id</NAME>
extern int nsp_type_classa_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_classa</NAME>
extern NspTypeClassA *nsp_type_classa;
</VARIABLE>
<FUNCTION>
<NAME>new_type_classa</NAME>
<RETURNS>NspTypeClassA *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_classa</NAME>
<RETURNS>NspClassA *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCLA</NAME>
#define NULLCLA (NspClassA*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_classa_create</NAME>
<RETURNS>NspClassA *</RETURNS>
char *name,int color,int thickness,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_copy</NAME>
<RETURNS>NspClassA *</RETURNS>
NspClassA *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_destroy</NAME>
<RETURNS>void </RETURNS>
NspClassA *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_info</NAME>
<RETURNS>int </RETURNS>
NspClassA *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_print</NAME>
<RETURNS>int </RETURNS>
NspClassA *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classa_object</NAME>
<RETURNS>NspClassA *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsClassAObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsClassA</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetClassACopy</NAME>
<RETURNS>NspClassA *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetClassA</NAME>
<RETURNS>NspClassA *</RETURNS>
Stack stack, int i
</FUNCTION>
<STRUCT>
<NAME>nsp_file</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_file</NAME>
struct _nsp_file {
  FILE *file ;   /* the file */
  XDR  xdrs[1];  /* xdr struture */
  int  flag;     /* flag for special open (xdr) */
  char openf[4]; /* flags used in fopen */
  char *fname;  /* file name */
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspFile</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSciFile</NAME>
typedef struct _NspTypeSciFile { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeSciFile;
</STRUCT>
<STRUCT>
<NAME>NspFile</NAME>
struct _NspFile {
  /*< private >*/
  NspObject father; 
  NspTypeSciFile *type; 
  /*< public >*/
  nsp_file *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_file_id</NAME>
extern int nsp_type_file_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_file</NAME>
extern NspTypeSciFile *nsp_type_file;
</VARIABLE>
<FUNCTION>
<NAME>new_type_file</NAME>
<RETURNS>NspTypeSciFile *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_file</NAME>
<RETURNS>NspFile *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>nsp_file_create</NAME>
<RETURNS>NspFile *</RETURNS>
char *name, char *fname, char *str, int flag, FILE *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_copy</NAME>
<RETURNS>NspFile *</RETURNS>
NspFile *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_destroy</NAME>
<RETURNS>void </RETURNS>
NspFile *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_info</NAME>
<RETURNS>int </RETURNS>
NspFile *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_print</NAME>
<RETURNS>int </RETURNS>
NspFile *H, int indent,char *name, int rec_level
</FUNCTION>
<MACRO>
<NAME>OPEN_MASK</NAME>
#define OPEN_MASK 0x000f 
</MACRO>
<MACRO>
<NAME>XDR_MASK</NAME>
#define XDR_MASK 0x00f0 
</MACRO>
<MACRO>
<NAME>SWAP_MASK</NAME>
#define SWAP_MASK 0x0f00 
</MACRO>
<MACRO>
<NAME>SWAP_ON</NAME>
#define SWAP_ON(flag) (flag |= (1 << 8) )
</MACRO>
<MACRO>
<NAME>SWAP_OFF</NAME>
#define SWAP_OFF(flag) (flag &= ~SWAP_MASK )
</MACRO>
<MACRO>
<NAME>XDR_ON</NAME>
#define XDR_ON(flag)  (flag |= (1 << 4 ) )
</MACRO>
<MACRO>
<NAME>XDR_OFF</NAME>
#define XDR_OFF(flag)  (flag &= ~XDR_MASK )
</MACRO>
<MACRO>
<NAME>OPEN_ON</NAME>
#define OPEN_ON(flag)  (flag |= (1  ) )
</MACRO>
<MACRO>
<NAME>OPEN_OFF</NAME>
#define OPEN_OFF(flag)  (flag &= ~OPEN_MASK )
</MACRO>
<MACRO>
<NAME>IS_OPENED</NAME>
#define IS_OPENED(flag) ( flag & OPEN_MASK )
</MACRO>
<MACRO>
<NAME>IS_XDR</NAME>
#define IS_XDR(flag) ( flag & XDR_MASK)
</MACRO>
<MACRO>
<NAME>USE_SWAP</NAME>
#define USE_SWAP(flag) ( flag & SWAP_MASK) 
</MACRO>
<MACRO>
<NAME>NULLSCIFILE</NAME>
#define NULLSCIFILE (NspFile *) 0
</MACRO>
<FUNCTION>
<NAME>nsp_file_object</NAME>
<RETURNS>NspFile *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSciFileObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSciFileCopy</NAME>
<RETURNS>NspFile *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSciFile</NAME>
<RETURNS>NspFile *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_open</NAME>
<RETURNS>NspFile *</RETURNS>
char *fname, char *mode,int xdr_on,int swap_on
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_close</NAME>
<RETURNS>int </RETURNS>
NspFile *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_open_xdr_r</NAME>
<RETURNS>NspFile *</RETURNS>
char *fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_close_xdr_r</NAME>
<RETURNS>int </RETURNS>
NspFile *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_open_xdr_w</NAME>
<RETURNS>NspFile *</RETURNS>
char *fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_file_close_xdr_w</NAME>
<RETURNS>int </RETURNS>
NspFile *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_d</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, double x
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_d</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, double *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_i</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, int ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_i</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, int *ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_c</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, char c
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_c</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, char *c
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_array_i</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, int *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_array_i</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, int *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_array_c</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs,char *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_array_c</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs,char *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_array_d</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, double *nx, int l
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_array_d</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, double *nx, int mn
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_load_string</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, char *buf, int buf_len
</FUNCTION>
<FUNCTION>
<NAME>is_little_endian</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_feof</NAME>
<RETURNS>int </RETURNS>
NspFile *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_ferror</NAME>
<RETURNS>int </RETURNS>
NspFile *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_clearerr</NAME>
<RETURNS>void </RETURNS>
NspFile *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_fseek</NAME>
<RETURNS>int </RETURNS>
NspFile *F,long int offset,const char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_ftell</NAME>
<RETURNS>int </RETURNS>
NspFile *F,long int *offset
</FUNCTION>
<FUNCTION>
<NAME>nsp_mput</NAME>
<RETURNS>int </RETURNS>
NspFile *F,void *x,int n, char *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_mget</NAME>
<RETURNS>int </RETURNS>
NspFile *F,void *x,int n,const char *type, int *items_read
</FUNCTION>
<FUNCTION>
<NAME>nsp_mgetstr</NAME>
<RETURNS>int </RETURNS>
NspFile *F, char **start, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mgetstr1</NAME>
<RETURNS>int </RETURNS>
NspFile *F, char *start, int n, int *n_read
</FUNCTION>
<FUNCTION>
<NAME>nsp_putstr</NAME>
<RETURNS>int </RETURNS>
NspFile *F, char *str
</FUNCTION>
<FUNCTION>
<NAME>do_printf</NAME>
<RETURNS>int </RETURNS>
char *fname, FILE *fp, char *format, Stack stack,int nargs, int arg_cnt, int line, char **strv
</FUNCTION>
<FUNCTION>
<NAME>do_scanf</NAME>
<RETURNS>int </RETURNS>
char *command,FILE *fp,char *format,Stack stack,int iline, int *nargs,char *strv,int *retval
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_string</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs,char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_xdr_save_string</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs,const char *str
</FUNCTION>
<MACRO>
<NAME>LINEMAXSIZE</NAME>
#define LINEMAXSIZE 4096 
</MACRO>
<TYPEDEF>
<NAME>Curline</NAME>
typedef struct _curline Curline; 
</TYPEDEF>
<STRUCT>
<NAME>curline</NAME>
struct _curline {
    int lpt1; /* position of the begining of the before last recognised token */
    int lpt2; /* position of the begining of the last recognised token */
    int lpt3; /* current char position in buf */
    char buf[LINEMAXSIZE];
} ;
</STRUCT>
<MACRO>
<NAME>TBUF</NAME>
#define TBUF 1024
</MACRO>
<STRUCT>
<NAME>token</NAME>
</STRUCT>
<STRUCT>
<NAME>token</NAME>
struct _token 
{
  char buf[TBUF];
  char syn[NAME_MAXL];
  double syv;
  char NextC;
  int id;
  int FlagEqu;
  int Line;
};
</STRUCT>
<TYPEDEF>
<NAME>Tokenizer</NAME>
typedef struct _tokenizer Tokenizer; 
</TYPEDEF>
<TYPEDEF>
<NAME>SciReadFunction</NAME>
typedef SciReadFunc *SciReadFunction;
</TYPEDEF>
<VARIABLE>
<NAME>nsp_defscireadline_rl</NAME>
extern SciReadFunc nsp_defscireadline_rl;
</VARIABLE>
<VARIABLE>
<NAME>DefSciReadLine_textview</NAME>
extern SciReadFunc DefSciReadLine_textview;
</VARIABLE>
<VARIABLE>
<NAME>DefSciReadLine</NAME>
extern SciReadFunction DefSciReadLine;
</VARIABLE>
<STRUCT>
<NAME>smat_tokenizer</NAME>
</STRUCT>
<STRUCT>
<NAME>smat_tokenizer</NAME>
struct _smat_tokenizer { 
  char **S;
  int ind;
  int pos;
  char *line;
} ;
</STRUCT>
<STRUCT>
<NAME>string_tokenizer</NAME>
</STRUCT>
<STRUCT>
<NAME>string_tokenizer</NAME>
struct _string_tokenizer { 
  char *str;
  int pos;
} ;
</STRUCT>
<STRUCT>
<NAME>tokenizer</NAME>
struct _tokenizer {
  /* data */
  Curline curline; 
  token  tokenv;
  FILE *file; /* used when the tokenizer uses a File as input */
  smat_tokenizer strings; /* used when the tokenizer uses a string matrix as input */
  string_tokenizer string; /* used when the tokenizer uses a string matrix as input */
  int mtlb; /* is % a comment or not */
  /* methods */
  SciReadFunction token_readline;
  token_NextToken *NextToken;
  token_ParseCommandArg *ParseCommandArg;
  token_ParseString *ParseString;
  token_GetChar *GetChar;
  token_ForceNextChar *ForceNextChar;
  token_FuncForceNextChar *FuncForceNextChar;
  token_IgnoreWSpaces *IgnoreWSpaces;
  token_viewch *viewch;
  token_backch *backch;
  token_IsDotDotDot *IsDotDotDot;
  token_IsDotDot *IsDotDot;
  token_IsDotStarStar *IsDotStarStar;
  token_IsDotAlphaOld *IsDotAlphaOld;
  token_IsDotAlpha *IsDotAlpha;
  token_IsTranspose *IsTranspose;
  token_ParseShowLine *ParseShowLine;
  token_Getlin *Getlin;
  token_TokenLineSet *TokenLineSet;
  token_ParseOperators *ParseOperators;
  token_ParseNumber *ParseNumber;
  token_ParseSymb *ParseSymb;
  token_ParseComment *ParseComment;
  token_ParseError *ParseError;
  token_code2name *code2name;
};
</STRUCT>
<FUNCTION>
<NAME>nsp_init_tokenizer</NAME>
<RETURNS>void </RETURNS>
Tokenizer *T
</FUNCTION>
<FUNCTION>
<NAME>nsp_tokeniser_file</NAME>
<RETURNS>void </RETURNS>
Tokenizer *T,FILE *f
</FUNCTION>
<FUNCTION>
<NAME>nsp_tokeniser_string</NAME>
<RETURNS>void </RETURNS>
Tokenizer *T,char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_tokeniser_strings</NAME>
<RETURNS>void </RETURNS>
Tokenizer *T,char **S
</FUNCTION>
<USER_FUNCTION>
<NAME>MoreFun</NAME>
<RETURNS>void </RETURNS>
int *n
</USER_FUNCTION>
<VARIABLE>
<NAME>scimore</NAME>
extern MoreFun scimore ;
</VARIABLE>
<FUNCTION>
<NAME>scimore_void</NAME>
<RETURNS>void </RETURNS>
int *n
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_nsp_more</NAME>
<RETURNS>MoreFun </RETURNS>
MoreFun F
</FUNCTION>
<STRUCT>
<NAME>nsp_sparse_triplet</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_sparse_triplet</NAME>
struct _nsp_sparse_triplet { /* used in mexlib */
  int *Jc; /* Ap;*/ /* m+ 1 */
  int *Ir; /* Ai;*/ /* Aisize */
  double *Pr; /* Ax;*/ /* Aisize */
  double *Pi; /* Ax;*/ /* Aisize */
  int m,n,Aisize;
};
</STRUCT>
<VARIABLE>
<NAME>debug</NAME>
extern int debug; 
</VARIABLE>
<VARIABLE>
<NAME>debugI</NAME>
extern int debugI;
</VARIABLE>
<MACRO>
<NAME>TBUF</NAME>
#define TBUF 1024
</MACRO>
<VARIABLE>
<NAME>Token</NAME>
extern Token_Obj Token ;
</VARIABLE>
<FUNCTION>
<NAME>nsp_astcode_to_nickname</NAME>
<RETURNS>const char *</RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_astcode_to_name</NAME>
<RETURNS>const char *</RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_nsp_keyword</NAME>
<RETURNS>int </RETURNS>
const char *id
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_code_keyword</NAME>
<RETURNS>int </RETURNS>
int keyc
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_opname</NAME>
<RETURNS>int </RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_ast_hash_create</NAME>
<RETURNS>NspHash *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_gsort</NAME>
<RETURNS>int </RETURNS>
int *xI, double *xD, int *ind, int *iflag, int *m, int *n,nsp_const_string type,nsp_const_string iord
</FUNCTION>
<ENUM>
<NAME>nsp_sort</NAME>
typedef enum {sort_g,sort_gs,sort_gm,sort_c,sort_r,sort_lr ,sort_lc ,sort_ldc,sort_ldr, sort_gb,sort_gd} nsp_sort;
</ENUM>
<FUNCTION>
<NAME>nsp_matrix_sort</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **Index,int ind_flag,char dir, nsp_sort type
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_column_sort</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **Index,int ind_flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_row_sort</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **Index,int ind_flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_lexical_column_sort</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **Index,int ind_flag,char dir,char mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_lexical_row_sort</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **Index,int ind_flag,char dir,char mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_sort</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspMatrix **Index,int ind_flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_column_sort</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspMatrix **Index,int ind_flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_row_sort</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspMatrix **Index,int ind_flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_lexical_column_sort</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspMatrix **Index,int ind_flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_lexical_row_sort</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspMatrix **Index,int ind_flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_col_sort_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_col_sort_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_col_sort_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexicol_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexicol_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexicol_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexirow_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexirow_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_lexirow_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_row_sort_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_row_sort_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_gen_row_sort_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *ind,int flag,int n,int p,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *tab, int flag, int n,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_int</NAME>
<RETURNS>void </RETURNS>
int x[], int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_bp_double</NAME>
<RETURNS>void </RETURNS>
double x[], int n, int p[],int flag,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_int</NAME>
<RETURNS>int </RETURNS>
int *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mergesort_double</NAME>
<RETURNS>int </RETURNS>
double *a,int *p,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_incr_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_decr_int</NAME>
<RETURNS>void </RETURNS>
int *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_incr_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_decr_double</NAME>
<RETURNS>void </RETURNS>
double *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_incr_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_qsort_stable_decr_nsp_string</NAME>
<RETURNS>void </RETURNS>
nsp_string *a,int *index,int flag, int fromIndex, int toIndex,char dir
</FUNCTION>
<STRUCT>
<NAME>NspModule</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeModule</NAME>
typedef struct _NspTypeModule { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeModule;
</STRUCT>
<STRUCT>
<NAME>NspModule</NAME>
struct _NspModule {
  /*< private >*/
  NspObject father; 
  NspTypeModule *type; 
  /*< public >*/
  char *path ; /* absolute XXX path of the module */
  char *mname;  /* module name */
  NspHash *T;      /* hash table to store module objects of type me (module elts) */
  NspList *L;       /* List of submodules */
  int flag;     /* are we a copy ? */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_module_id</NAME>
extern int nsp_type_module_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_module</NAME>
extern NspTypeModule *nsp_type_module;
</VARIABLE>
<FUNCTION>
<NAME>new_type_module</NAME>
<RETURNS>NspTypeModule *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_module</NAME>
<RETURNS>NspModule *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLMODULE</NAME>
#define NULLMODULE (NspModule*) 0
</MACRO>
<FUNCTION>
<NAME>module_create</NAME>
<RETURNS>NspModule *</RETURNS>
char *name,const char *path,const char *mname,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>module_copy</NAME>
<RETURNS>NspModule *</RETURNS>
NspModule *H
</FUNCTION>
<FUNCTION>
<NAME>module_destroy</NAME>
<RETURNS>void </RETURNS>
NspModule *H
</FUNCTION>
<FUNCTION>
<NAME>module_info</NAME>
<RETURNS>int </RETURNS>
NspModule *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>module_print</NAME>
<RETURNS>int </RETURNS>
NspModule *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>module_object</NAME>
<RETURNS>NspModule *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsModuleObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsModule</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetModuleCopy</NAME>
<RETURNS>NspModule *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetModule</NAME>
<RETURNS>NspModule *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>module_copy_ref</NAME>
<RETURNS>NspModule *</RETURNS>
NspModule *Mod
</FUNCTION>
<FUNCTION>
<NAME>nsp_module_search_name</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,char **Mname
</FUNCTION>
<FUNCTION>
<NAME>nsp_insert_module_last</NAME>
<RETURNS>int </RETURNS>
NspList *L,char *dir,char **Mname
</FUNCTION>
<FUNCTION>
<NAME>nsp_module_import</NAME>
<RETURNS>int </RETURNS>
NspList *L,char *dir,char **Mname
</FUNCTION>
<STRUCT>
<NAME>BHash_Entry</NAME>
</STRUCT>
<STRUCT>
<NAME>BHash_Entry</NAME>
struct _BHash_Entry { 
  unsigned int used; /* used to detect if data is present */
  char *key;
  int val;
};
</STRUCT>
<STRUCT>
<NAME>NspTypeBHash</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeBHash</NAME>
struct _NspTypeBHash { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>NspBHash</NAME>
</STRUCT>
<STRUCT>
<NAME>NspBHash</NAME>
struct _NspBHash {
  /*< private >*/
  NspObject father; 
  NspTypeBHash *type; 
  /*< public >*/
  unsigned int hsize,filled; /* size of bhash table and number of present entries */
  BHash_Entry *htable; /* an array of size hsize+1 */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_bhash_id</NAME>
extern int nsp_type_bhash_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_bhash</NAME>
extern NspTypeBHash *nsp_type_bhash;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_bhash_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_bhash</NAME>
<RETURNS>NspTypeBHash *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_bhash</NAME>
<RETURNS>NspBHash *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLBHASH</NAME>
#define NULLBHASH (NspBHash*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_bhash_create</NAME>
<RETURNS>NspBHash *</RETURNS>
const char *name, unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_copy</NAME>
<RETURNS>NspBHash *</RETURNS>
const NspBHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_destroy</NAME>
<RETURNS>void </RETURNS>
NspBHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_info</NAME>
<RETURNS>int </RETURNS>
NspBHash *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_print</NAME>
<RETURNS>int </RETURNS>
NspBHash *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_object</NAME>
<RETURNS>NspBHash *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsBHashObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsBHash</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetBHashCopy</NAME>
<RETURNS>NspBHash *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetBHash</NAME>
<RETURNS>NspBHash *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_resize</NAME>
<RETURNS>int </RETURNS>
NspBHash *H, unsigned int new_size
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_merge</NAME>
<RETURNS>int </RETURNS>
NspBHash *H1, NspBHash *H2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_get_next_object</NAME>
<RETURNS>int </RETURNS>
NspBHash *H,int *i,char **str,int *val
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_enter_pos_i</NAME>
<RETURNS>void </RETURNS>
NspBHash *H, int i,int val
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_enter_copy</NAME>
<RETURNS>int </RETURNS>
NspBHash *H, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_enter</NAME>
<RETURNS>int </RETURNS>
NspBHash *H,const char *str,int val
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_remove</NAME>
<RETURNS>void </RETURNS>
NspBHash *H, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_find_and_copy</NAME>
<RETURNS>int </RETURNS>
NspBHash *H, char *str, NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_find</NAME>
<RETURNS>int </RETURNS>
NspBHash *H,const char *str,int *val
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_equal</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBHash *L1, NspBHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_not_equal</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspBHash *L1, NspBHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_full_equal</NAME>
<RETURNS>int </RETURNS>
NspBHash *L1, NspBHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_full_not_equal</NAME>
<RETURNS>int </RETURNS>
NspBHash *L1, NspBHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhash_get_keys</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const char *name,NspBHash *Hv
</FUNCTION>
<ENUM>
<NAME>BHashOperation</NAME>
typedef enum {
  BH_FIND,
  BH_ENTER,
  BH_REMOVE 
} BHashOperation;
</ENUM>
<FUNCTION>
<NAME>nsp_bhcreate_from_list</NAME>
<RETURNS>NspBHash *</RETURNS>
char *name,unsigned int nel, NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhcreate</NAME>
<RETURNS>NspBHash *</RETURNS>
const char *name, unsigned int nel
</FUNCTION>
<FUNCTION>
<NAME>nsp_bhdestroy</NAME>
<RETURNS>void </RETURNS>
NspBHash *H
</FUNCTION>
<FUNCTION>
<NAME>scig_click_handler_none</NAME>
<RETURNS>int </RETURNS>
int win, int x, int y, int ibut, int motion, int release
</FUNCTION>
<FUNCTION>
<NAME>scig_click_handler_sci</NAME>
<RETURNS>int </RETURNS>
int win, int x, int y, int ibut, int motion, int release
</FUNCTION>
<USER_FUNCTION>
<NAME>Scig_click_handler</NAME>
<RETURNS>int </RETURNS>
int,int,int,int,int,int
</USER_FUNCTION>
<FUNCTION>
<NAME>set_scig_click_handler</NAME>
<RETURNS>Scig_click_handler </RETURNS>
Scig_click_handler f
</FUNCTION>
<FUNCTION>
<NAME>reset_scig_click_handler</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>PushClickQueue</NAME>
<RETURNS>int </RETURNS>
int win, int x, int y, int ibut, int motion, int release
</FUNCTION>
<FUNCTION>
<NAME>CheckClickQueue</NAME>
<RETURNS>int </RETURNS>
int *win, int *x, int *y, int *ibut
</FUNCTION>
<FUNCTION>
<NAME>ClearClickQueue</NAME>
<RETURNS>int </RETURNS>
int win
</FUNCTION>
<FUNCTION>
<NAME>Sci_Help</NAME>
<RETURNS>int </RETURNS>
char *mandir, char *locale, char *help_file
</FUNCTION>
<FUNCTION>
<NAME>Scisncr</NAME>
<RETURNS>void </RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>sciprint2</NAME>
<RETURNS>int </RETURNS>
int iv, char *fmt, ...
</FUNCTION>
<FUNCTION>
<NAME>nsp_in_gtk_window</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_gtk_window</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_activate_gtk_events_check</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_events_activated</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>write_scilab</NAME>
<RETURNS>void </RETURNS>
char *s
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_gtk_events</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>sci_winch_signal</NAME>
<RETURNS>void </RETURNS>
int n
</FUNCTION>
<USER_FUNCTION>
<NAME>Get_char</NAME>
<RETURNS>int </RETURNS>
void
</USER_FUNCTION>
<VARIABLE>
<NAME>Xorgetchar</NAME>
extern Get_char Xorgetchar;
</VARIABLE>
<FUNCTION>
<NAME>nsp_gtk_init</NAME>
<RETURNS>void </RETURNS>
int argc, char **argv,int no_window,int use_textview
</FUNCTION>
<FUNCTION>
<NAME>start_sci_gtk</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>sci_clear_and_exit</NAME>
<RETURNS>void </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>sci_usr1_signal</NAME>
<RETURNS>void </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>sci_sig_tstp</NAME>
<RETURNS>void </RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>kill_process_group</NAME>
<RETURNS>int </RETURNS>
int pid, int sig
</FUNCTION>
<FUNCTION>
<NAME>getcolordef</NAME>
<RETURNS>void </RETURNS>
int *screenc
</FUNCTION>
<FUNCTION>
<NAME>setcolordef</NAME>
<RETURNS>void </RETURNS>
int screenc
</FUNCTION>
<FUNCTION>
<NAME>using_readline</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>get_one_char</NAME>
<RETURNS>int </RETURNS>
char *prompt
</FUNCTION>
<FUNCTION>
<NAME>SciGtkReadLine</NAME>
<RETURNS>void </RETURNS>
char *prompt, char *buffer, int *buf_size, int *len_line, int *eof
</FUNCTION>
<FUNCTION>
<NAME>nsp_read_history</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_write_history</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>create_plugged_main_menu</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>MenuFixCurrentWin</NAME>
<RETURNS>void </RETURNS>
int ivalue
</FUNCTION>
<FUNCTION>
<NAME>graphic_initial_menu</NAME>
<RETURNS>void *</RETURNS>
int winid
</FUNCTION>
<FUNCTION>
<NAME>scig_print</NAME>
<RETURNS>void </RETURNS>
int winid
</FUNCTION>
<STRUCT>
<NAME>doubleC</NAME>
typedef struct { double r, i; } doubleC;
</STRUCT>
<STRUCT>
<NAME>NspMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeMatrix</NAME>
typedef struct _NspTypeMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeMatrix;
</STRUCT>
<STRUCT>
<NAME>NspMatrix</NAME>
struct _NspMatrix {
  /*< private >*/
  NspObject father; 
  NspTypeMatrix *type; 
  /*< public >*/
  int m,n,mn;/* NspMatrix dimensions */
  union { 
    double *R;     /* Pointer on real values */
    doubleC *C;    /* Pointer on complex values */
    int *I;        /* Pointer on integer values */
    int *F;        /* Pointer on float values */
  };
  char rc_type;    /* 'r' : real or  'c' : complex  */
  char convert;    /* 'd','i','f','c' : double, int, float, old_complex
		    * used to remember array converted in place */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_matrix_id</NAME>
extern int nsp_type_matrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_matrix</NAME>
extern NspTypeMatrix *nsp_type_matrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_matrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_matrix</NAME>
<RETURNS>NspTypeMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_matrix</NAME>
<RETURNS>NspMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLMAT</NAME>
#define NULLMAT (NspMatrix*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_alloc_doubles</NAME>
<RETURNS>double *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_realloc_doubles</NAME>
<RETURNS>double *</RETURNS>
double *dp, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_int</NAME>
<RETURNS>int *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_realloc_int</NAME>
<RETURNS>int *</RETURNS>
int *dp, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_doubleC</NAME>
<RETURNS>doubleC *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_realloc_doubleC</NAME>
<RETURNS>doubleC *</RETURNS>
doubleC *dp, unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_work_doubles</NAME>
<RETURNS>double *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_work_int</NAME>
<RETURNS>int *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_alloc_work_doubleC</NAME>
<RETURNS>doubleC *</RETURNS>
unsigned int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_info</NAME>
<RETURNS>int </RETURNS>
 NspMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_copy</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_print</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>matrix_loop_extract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>matrix_object</NAME>
<RETURNS>NspMatrix  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_fullcomp</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, char *op,int *err
</FUNCTION>
<FUNCTION>
<NAME>matrix_object</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsMat</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetMatCopyInt</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMatInt</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMatCopyFloat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMatFloat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopy_G</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMat_G</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopy</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopyInt</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatInt</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatCopyFloat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMatFloat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMtlbMatCopy</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMtlbMat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IntScalar</NAME>
<RETURNS>int </RETURNS>
NspObject *O, int *val
</FUNCTION>
<FUNCTION>
<NAME>GetScalarInt</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i, int *val
</FUNCTION>
<FUNCTION>
<NAME>DoubleScalar</NAME>
<RETURNS>int </RETURNS>
NspObject *O, double *val
</FUNCTION>
<FUNCTION>
<NAME>GetScalarDouble</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i, double *val
</FUNCTION>
<FUNCTION>
<NAME>Matd2i</NAME>
<RETURNS>int *</RETURNS>
NspMatrix *A, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>Bounds</NAME>
<RETURNS>void </RETURNS>
const NspMatrix *A, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_boundster</NAME>
<RETURNS>void </RETURNS>
const NspMatrix *A, int *ind, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>Mat2double</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>Mat2int</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>Mat2float</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>Mat2mtlb_cplx</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix * A
</FUNCTION>
<USER_FUNCTION>
<NAME>F_Enlarge</NAME>
<RETURNS>int </RETURNS>
void *A,int m,int n
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name, char type, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_clone</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name, NspMatrix *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_impl</NAME>
<RETURNS>NspMatrix *</RETURNS>
double first, double step, double last
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_linspace</NAME>
<RETURNS>NspMatrix *</RETURNS>
const double first[],const double last[],int r,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_logspace</NAME>
<RETURNS>NspMatrix *</RETURNS>
const double first[],const double last[],int r,int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_from_doubles</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name,int m,int n,...
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_from_array</NAME>
<RETURNS>NspMatrix *</RETURNS>
const char *name,int m,int n,const double valr[],const double valc[]
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_fill_with</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_resize</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_scalar_to_mn</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_latex_print</NAME>
<RETURNS>int </RETURNS>
const NspMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_latex_tab_print</NAME>
<RETURNS>int </RETURNS>
const NspMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_redim</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_concat_right</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_add_columns</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_concat_down</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_concat_diag</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_add_rows</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>GenericMatSeRo</NAME>
<RETURNS>int </RETURNS>
void *A, int Am, int An, int Amn, NspMatrix *Rows, void *B, int Bm, int Bn, int Bmn, F_Enlarge F, int *Bscal
</FUNCTION>
<FUNCTION>
<NAME>GenericMatSeRoBis</NAME>
<RETURNS>int </RETURNS>
void *A, int Am, int An, int Amn, int nb_ind, int rmin, int rmax,void *B, int Bm, int Bn, int Bmn, F_Enlarge F, int *Bscal
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_set_rows</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *Rows, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>mat_is_increasing</NAME>
<RETURNS>int </RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const  NspMatrix *Rows,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_elements</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const  NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_columns</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_rows</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A,const  NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>MatLoopCol</NAME>
<RETURNS>NspMatrix *</RETURNS>
char *str, NspMatrix *Col, NspMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_extract_diag</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_set_diag</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_create_diag</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_transpose</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_scale_rows</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_scale_cols</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_diff</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, int order, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult_scalar_bis</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add_scalar_bis</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add_mat</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub_scalar_bis</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalar_sub_mat_bis</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub_mat</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_set_rval</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_copy_and_complexify</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_set_ival</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_dadd</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_dadd_maxplus</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_add_scalar_maxplus</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_dsub</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sub_scalar_maxplus</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_subs_calarm</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_clean</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, int rhs, double epsa, double epsr
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxitt1</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, NspMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minitt1</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, NspMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minmax</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int dim, NspMatrix **Amin, NspMatrix **Imin,NspMatrix **Amax, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_slec</NAME>
<RETURNS>NspMatrix **</RETURNS>
char *file, int *Count
</FUNCTION>
<FUNCTION>
<NAME>fopen</NAME>
<RETURNS>FILE *</RETURNS>
const char *, const char *
</FUNCTION>
<FUNCTION>
<NAME>MatLec</NAME>
<RETURNS>NspMatrix *</RETURNS>
FILE *fd
</FUNCTION>
<FUNCTION>
<NAME>fooBOU</NAME>
<RETURNS>NspMatrix *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_csetd</NAME>
<RETURNS>void </RETURNS>
const int *n,const double *z,doubleC *tab,const int *inc
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_complexify</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_get_real</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_get_imag</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_isreal</NAME>
<RETURNS>int </RETURNS>
const NspMatrix *A, int strict
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_inv_el</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_kron</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sort</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, int flag, char *str1, char *str2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sum</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_prod</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cum_prod</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A,  int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cum_sum</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A,  int dim
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxi</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, char *flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mini</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, char *flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_createinit</NAME>
<RETURNS>NspMatrix *</RETURNS>
char *name, char type, int m, int n, double (*func) ()
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_triu</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tril</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_eye</NAME>
<RETURNS>NspMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ones</NAME>
<RETURNS>NspMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_zeros</NAME>
<RETURNS>NspMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_rand</NAME>
<RETURNS>NspMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_urandseed</NAME>
<RETURNS>void </RETURNS>
int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_urandseed</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_urandtype</NAME>
<RETURNS>void </RETURNS>
int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_urandtype</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_matscalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_matmat</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_scalarmat</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_tt</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_el</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_pow_scalarm</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_div_tt</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_div_el</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_div_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_tt</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_el</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult_tt</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult_el</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mult_scalar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *Mat1, NspMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_acos</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_acosh</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_asin</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_asinh</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_atan</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_atan2</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_atanh</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ceil</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_modulo</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_idiv</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mod</NAME>
<RETURNS>void </RETURNS>
NspMatrix *x, NspMatrix *y
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_int</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_floor</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_round</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sign</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tan</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tanh</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_abs</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_erf</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_erfc</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_lgamma</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_tgamma</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_arg</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_polar</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_iand</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_iandu</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ior</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ioru</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_ishift</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,int shift,char dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_conj</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cos</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_cosh</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_expel</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_logel</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sin</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sinh</NAME>
<RETURNS>void </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_sqrtel</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minus</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minus_maxplus</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_magic</NAME>
<RETURNS>NspMatrix *</RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_franck</NAME>
<RETURNS>NspMatrix *</RETURNS>
int n, int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_hilbert</NAME>
<RETURNS>NspMatrix *</RETURNS>
int n,int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_fullcomp</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_find</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int lhs, NspMatrix **Res1, NspMatrix **Res2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_mfind</NAME>
<RETURNS>int </RETURNS>
const NspMatrix *x, int m,const char **ops,const double *scalars, NspMatrix **Ind
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_nnz</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxplus_add</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_maxplus_mult</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_minplus_mult</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_array_maxi</NAME>
<RETURNS>int </RETURNS>
int n,const double *A, int incr, double *amax
</FUNCTION>
<FUNCTION>
<NAME>nsp_array_mini</NAME>
<RETURNS>int </RETURNS>
int n,const double *A, int incr, double *amax
</FUNCTION>
<FUNCTION>
<NAME>GetMatCopy</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMat</NAME>
<RETURNS>NspMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<STRUCT>
<NAME>nsp_num_formats</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_num_formats</NAME>
struct _nsp_num_formats {
  char curr_real_fmt[128];/* Current format string for real numbers and the real part of complex numbers. */
  int curr_real_fw; 
  char curr_imag_fmt[128];/*Current format string for the imaginary part of complex numbers. */
  int  curr_imag_fw;  /*Nonzero means don't do any fancy formatting. */
  int free_format;   /*Nonzero means print plus sign for nonzero, blank for zero. */
  int plus_format;   /*Nonzero means always print like dollars and cents. */
  int bank_format;   /*Nonzero means always print in latex syntax */
  int latex_format;  /* used with latex_format to add the fact that output is for texmacs */
  int latex_texmacs_format;  /*Nonzero means use an e format. */
  int print_e;   /*Nonzero means print E instead of e for exponent field. */
  int print_big_e;
};
</STRUCT>
<USER_FUNCTION>
<NAME>nsp_it_next</NAME>
<RETURNS>int </RETURNS>
const void *,double *,doubleC *,int *
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>nsp_it_init</NAME>
<RETURNS>char </RETURNS>
const void *,int *
</USER_FUNCTION>
<FUNCTION>
<NAME>gen_any_element_is_negative</NAME>
<RETURNS>int </RETURNS>
const void *M, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<FUNCTION>
<NAME>gen_any_element_is_inf_or_nan</NAME>
<RETURNS>int </RETURNS>
const void *M, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<FUNCTION>
<NAME>gen_all_elements_are_int_or_inf_or_nan</NAME>
<RETURNS>int </RETURNS>
const void *M, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<FUNCTION>
<NAME>gen_pr_min_max_internal</NAME>
<RETURNS>void </RETURNS>
const void *M, char flag, double *dmin, double *dmax, nsp_it_init Init, nsp_it_next Next
</FUNCTION>
<USER_FUNCTION>
<NAME>Mijfloat</NAME>
<RETURNS>void </RETURNS>
const nsp_num_formats *fmt,const void *,int i,int j
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_gen_matrix_as_read_syntax</NAME>
<RETURNS>void </RETURNS>
const nsp_num_formats *fmt,const void *m, int nr, int nc, int inc,int indent, Mijfloat F
</FUNCTION>
<USER_FUNCTION>
<NAME>it_gen_f</NAME>
<RETURNS>int </RETURNS>
const void *
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>pr_mima</NAME>
<RETURNS>void </RETURNS>
const void *,char,double *,double *
</USER_FUNCTION>
<FUNCTION>
<NAME>gen_set_format</NAME>
<RETURNS>void </RETURNS>
nsp_num_formats *fmt,void *M, it_gen_f is_neg, it_gen_f is_inf_or_nan, pr_mima min_max,it_gen_f all_iin, nsp_it_init Init
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_float</NAME>
<RETURNS>void </RETURNS>
const nsp_num_formats *fmt,double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_imag_float</NAME>
<RETURNS>void </RETURNS>
const nsp_num_formats *fmt,double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_complex</NAME>
<RETURNS>void </RETURNS>
const nsp_num_formats *fmt,doubleC c
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_white</NAME>
<RETURNS>void </RETURNS>
int fw
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_empty_matrix</NAME>
<RETURNS>void </RETURNS>
int nr, int nc
</FUNCTION>
<FUNCTION>
<NAME>nsp_pr_any_float</NAME>
<RETURNS>void </RETURNS>
const char *fmt, double d, int fw
</FUNCTION>
<FUNCTION>
<NAME>nsp_init_pr_format</NAME>
<RETURNS>void </RETURNS>
nsp_num_formats *fmt
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_set_format</NAME>
<RETURNS>void </RETURNS>
nsp_num_formats *fmt,NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_string_as_read</NAME>
<RETURNS>void </RETURNS>
const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_real_matrix_print_internal</NAME>
<RETURNS>int </RETURNS>
nsp_num_formats *fmt,NspMatrix *m, int indent
</FUNCTION>
<FUNCTION>
<NAME>nsp_complex_matrix_print_internal</NAME>
<RETURNS>int </RETURNS>
nsp_num_formats *fmt,NspMatrix *cm, int indent
</FUNCTION>
<USER_FUNCTION>
<NAME>Mijplus</NAME>
<RETURNS>void </RETURNS>
const void *,int i,int j
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_plus_format</NAME>
<RETURNS>void </RETURNS>
const void *m, int nr, int nc, Mijplus F, int indent
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_general</NAME>
<RETURNS>int </RETURNS>
const nsp_num_formats *fmt,void *m, int nr, int nc, int inc, int total_width, int max_width, int winrows, int indent, Mijfloat F
</FUNCTION>
<STRUCT>
<NAME>NspLink</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeLink</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeLink</NAME>
struct _NspTypeLink { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>grl_lock</NAME>
</STRUCT>
<STRUCT>
<NAME>grl_lock</NAME>
struct _grl_lock {
  gr_port port;  /* Only one port */
};
</STRUCT>
<STRUCT>
<NAME>nsp_link</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_link</NAME>
struct _nsp_link {
  nsp_gframe *frame; /* a link must be in a frame to be drawn */
  void *object_sid;
  int color; 
  int thickness;
  NspMatrix *poly ;       /* the polyline */
  grl_lock locks[2];      /* two lock points */
  int hilited ; 
  int show    ; 
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspLink</NAME>
struct _NspLink {
  /*< private >*/
  NspObject father; 
  NspTypeLink *type; 
  /*< public >*/
  /* specific*/
  nsp_link *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_link_id</NAME>
extern int nsp_type_link_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_link</NAME>
extern NspTypeLink *nsp_type_link;
</VARIABLE>
<FUNCTION>
<NAME>new_type_link</NAME>
<RETURNS>NspTypeLink *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_link</NAME>
<RETURNS>NspLink *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLLINK</NAME>
#define NULLLINK (NspLink*) 0
</MACRO>
<FUNCTION>
<NAME>IsLinkObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetLinkCopy</NAME>
<RETURNS>NspLink *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetLink</NAME>
<RETURNS>NspLink *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>link_create_n</NAME>
<RETURNS>NspLink *</RETURNS>
char *name,int n,int color,int thickness
</FUNCTION>
<FUNCTION>
<NAME>link_lock_update</NAME>
<RETURNS>void </RETURNS>
NspGFrame *F, NspLink *L,int lp,double ptnew[2]
</FUNCTION>
<FUNCTION>
<NAME>link_split</NAME>
<RETURNS>int </RETURNS>
NspGFrame *F,NspLink *L,NspLink **L1,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>link_check</NAME>
<RETURNS>void </RETURNS>
NspGFrame *F,NspLink *L
</FUNCTION>
<FUNCTION>
<NAME>IsLink</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>link_add_control</NAME>
<RETURNS>int </RETURNS>
NspLink *L,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>link_remove_control</NAME>
<RETURNS>int </RETURNS>
NspLink *L,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>link_create</NAME>
<RETURNS>NspLink *</RETURNS>
char *name,NspMatrix *D,int color,int thickness, NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>eval_piecewise_hermite</NAME>
<RETURNS>void </RETURNS>
double *t, double *st, double *dst, double *d2st,double *d3st, int m, double *x, double *y, double *d,int n, int outmode
</FUNCTION>
<FUNCTION>
<NAME>dpchim</NAME>
<RETURNS>void </RETURNS>
double *x, double *u, double *d, int n, int inc
</FUNCTION>
<FUNCTION>
<NAME>cubic_spline</NAME>
<RETURNS>void </RETURNS>
double *x, double *y, double *d, int n, int type,double *A_d, double *A_sd, double *qdy, double *lll
</FUNCTION>
<FUNCTION>
<NAME>derivd</NAME>
<RETURNS>void </RETURNS>
double *x, double *u, double *du, int n, int inc, int type
</FUNCTION>
<FUNCTION>
<NAME>nlinear_interp</NAME>
<RETURNS>void </RETURNS>
double **x , double val[], int dim[], int n,double **xp, double yp[], int np, int outmode,double u[], double v[], int ad[], int k[]
</FUNCTION>
<STRUCT>
<NAME>NspAstNode</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeAstNode</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeAstNode</NAME>
struct _NspTypeAstNode {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>nsp_astnode</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_astnode</NAME>
struct _nsp_astnode {
  int op;
  int arity; /* arity for operators or tag for names etc.. */
  void *obj; /* used to store a string pointer, 
	      * an object pointer a parse_double
	      * an int. Maybe an union could help.
	      */
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspAstNode</NAME>
struct _NspAstNode {
  /*< private >*/
  NspObject father;
  NspTypeAstNode*type;
  /*< public >*/
  nsp_astnode *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_astnode_id</NAME>
extern int nsp_type_astnode_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_astnode</NAME>
extern NspTypeAstNode *nsp_type_astnode;
</VARIABLE>
<FUNCTION>
<NAME>new_type_astnode</NAME>
<RETURNS>NspTypeAstNode *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_astnode</NAME>
<RETURNS>NspAstNode *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLASTNODE</NAME>
#define NULLASTNODE (NspAstNode*) 0
</MACRO>
<FUNCTION>
<NAME>astnode_create</NAME>
<RETURNS>NspAstNode *</RETURNS>
char *name,int op,int arity,void *data,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_astnode_copy</NAME>
<RETURNS>NspAstNode *</RETURNS>
NspAstNode *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_astnode_destroy</NAME>
<RETURNS>void </RETURNS>
NspAstNode *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_astnode_info</NAME>
<RETURNS>int </RETURNS>
NspAstNode *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_astnode_print</NAME>
<RETURNS>int </RETURNS>
NspAstNode *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_astnode_object</NAME>
<RETURNS>NspAstNode *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsAstNodeObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsAstNode</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetAstNodeCopy</NAME>
<RETURNS>NspAstNode *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetAstNode</NAME>
<RETURNS>NspAstNode *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>int_astnode_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<STRUCT>
<NAME>NspUmfpack</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeUmfpack</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeUmfpack</NAME>
struct _NspTypeUmfpack {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>nsp_umfpack</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_umfpack</NAME>
struct _nsp_umfpack {
  char rc_type;
  char* data;
  nsp_sparse_triplet mtlb_T;
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspUmfpack</NAME>
struct _NspUmfpack {
  /*< private >*/
  NspObject father;
  NspTypeUmfpack*type;
  /*< public >*/
  nsp_umfpack *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_umfpack_id</NAME>
extern int nsp_type_umfpack_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_umfpack</NAME>
extern NspTypeUmfpack *nsp_type_umfpack;
</VARIABLE>
<FUNCTION>
<NAME>new_type_umfpack</NAME>
<RETURNS>NspTypeUmfpack *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_umfpack</NAME>
<RETURNS>NspUmfpack *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLUMFPACK</NAME>
#define NULLUMFPACK (NspUmfpack*) 0
</MACRO>
<FUNCTION>
<NAME>umfpack_create</NAME>
<RETURNS>NspUmfpack *</RETURNS>
char *name,char rc_type,char* data,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_umfpack_copy</NAME>
<RETURNS>NspUmfpack *</RETURNS>
NspUmfpack *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_umfpack_destroy</NAME>
<RETURNS>void </RETURNS>
NspUmfpack *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_umfpack_info</NAME>
<RETURNS>int </RETURNS>
NspUmfpack *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_umfpack_print</NAME>
<RETURNS>int </RETURNS>
NspUmfpack *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_umfpack_object</NAME>
<RETURNS>NspUmfpack *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsUmfpackObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsUmfpack</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetUmfpackCopy</NAME>
<RETURNS>NspUmfpack *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetUmfpack</NAME>
<RETURNS>NspUmfpack *</RETURNS>
Stack stack, int i
</FUNCTION>
<VARIABLE>
<NAME>VoidPt_Type</NAME>
extern SciFType * VoidPt_Type;
</VARIABLE>
<VARIABLE>
<NAME>GtkE_Type</NAME>
extern SciFType * GtkE_Type ;
</VARIABLE>
<VARIABLE>
<NAME>BMatrix_Type</NAME>
extern SciFType * BMatrix_Type ;
</VARIABLE>
<VARIABLE>
<NAME>SciFile_Type</NAME>
extern SciFType * SciFile_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Func_Type</NAME>
extern SciFType * Func_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Hash_Type</NAME>
extern SciFType * Hash_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Hobj_Type</NAME>
extern SciFType * Hobj_Type ;
</VARIABLE>
<VARIABLE>
<NAME>IVect_Type</NAME>
extern SciFType * IVect_Type;
</VARIABLE>
<VARIABLE>
<NAME>List_Type</NAME>
extern SciFType * List_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Matrix_Type</NAME>
extern SciFType * Matrix_Type ;
</VARIABLE>
<VARIABLE>
<NAME>PMatrix_Type</NAME>
extern SciFType * PMatrix_Type;
</VARIABLE>
<VARIABLE>
<NAME>P_PList_Type</NAME>
extern SciFType * P_PList_Type ;
</VARIABLE>
<VARIABLE>
<NAME>SMatrix_Type</NAME>
extern SciFType * SMatrix_Type;
</VARIABLE>
<VARIABLE>
<NAME>Sp_Type</NAME>
extern SciFType * Sp_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Array_Type</NAME>
extern SciFType * Array_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Mod_Type</NAME>
extern SciFType * Mod_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Me_Type</NAME>
extern SciFType * Me_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Lmo_Type</NAME>
extern SciFType * Lmo_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Rect_Type</NAME>
extern SciFType * Rect_Type ;
</VARIABLE>
<VARIABLE>
<NAME>GFrame_Type</NAME>
extern SciFType * GFrame_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Block_Type</NAME>
extern SciFType * Block_Type ;
</VARIABLE>
<VARIABLE>
<NAME>Link_Type</NAME>
extern SciFType * Link_Type ;
</VARIABLE>
<STRUCT>
<NAME>NspList</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeList</NAME>
typedef struct _NspTypeList { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeList;
</STRUCT>
<TYPEDEF>
<NAME>Cell</NAME>
typedef struct cell Cell ;
</TYPEDEF>
<STRUCT>
<NAME>cell</NAME>
struct cell {
  struct cell *prev;  /* points to the previous cell or 0 */
  struct cell *next;  /* points to the next cell or 0 */
  NspObject *O;             /* points to the stored object */
} ;
</STRUCT>
<STRUCT>
<NAME>NspList</NAME>
struct _NspList {
  /*< private >*/
  NspObject father; 
  NspTypeList *type; 
  /*< public >*/
  Cell *first;        /* pointer to the first cell */
  Cell *last;         /* pointer to the last cell */
  Cell *current;      /* pointer to the current cell */
  int nel;            /* number of list elements */
  int icurrent;       /* index of the current cell */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_list_id</NAME>
extern int nsp_type_list_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_list</NAME>
extern NspTypeList *nsp_type_list;
</VARIABLE>
<FUNCTION>
<NAME>new_type_list</NAME>
<RETURNS>NspTypeList *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_list</NAME>
<RETURNS>NspList *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLLIST</NAME>
#define NULLLIST ( NspList *) 0 
</MACRO>
<MACRO>
<NAME>NULLCELL</NAME>
#define NULLCELL ( Cell *) 0 
</MACRO>
<MACRO>
<NAME>NULLOBJ</NAME>
#define NULLOBJ  ( NspObject *) 0 
</MACRO>
<FUNCTION>
<NAME>nsp_list_path_extract</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,int n, NspObject **Objs
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_object</NAME>
<RETURNS>NspList *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsListObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsList</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetListCopy</NAME>
<RETURNS>NspList *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetList</NAME>
<RETURNS>NspList *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>ListFollowExtract</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_eval_macro_code</NAME>
<RETURNS>NspObject *</RETURNS>
NspPList *, NspObject **, NspList *, int *
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_create</NAME>
<RETURNS>NspList *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_cell_create</NAME>
<RETURNS>Cell *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_cell_destroy</NAME>
<RETURNS>void </RETURNS>
Cell **c
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_destroy</NAME>
<RETURNS>void </RETURNS>
NspList *l
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_destroy_bis</NAME>
<RETURNS>void </RETURNS>
NspList *l
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_copy</NAME>
<RETURNS>NspList *</RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_extract</NAME>
<RETURNS>NspList *</RETURNS>
NspList *L, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_insert</NAME>
<RETURNS>int </RETURNS>
NspList *L, NspObject *O, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_get_element</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_begin_insert</NAME>
<RETURNS>int </RETURNS>
NspList *L, NspObject *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_end_insert</NAME>
<RETURNS>int </RETURNS>
NspList *L, NspObject *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_remove_first</NAME>
<RETURNS>void  </RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_remove_last</NAME>
<RETURNS>void  </RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_store</NAME>
<RETURNS>int </RETURNS>
NspList *L, NspObject *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_delete_elt_by_name</NAME>
<RETURNS>void </RETURNS>
NspList *L, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_delete_elt</NAME>
<RETURNS>int </RETURNS>
NspList *L, int nel
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_delete_cell</NAME>
<RETURNS>int </RETURNS>
NspList *L, int nel
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_length</NAME>
<RETURNS>int </RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_concat</NAME>
<RETURNS>int </RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_info</NAME>
<RETURNS>int </RETURNS>
NspList *L, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_print</NAME>
<RETURNS>int </RETURNS>
NspList *L, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_latex_print</NAME>
<RETURNS>void </RETURNS>
NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_cell_only_destroy</NAME>
<RETURNS>void </RETURNS>
Cell **c
</FUNCTION>
<FUNCTION>
<NAME>nsp_sorted_list_search</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L, nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_sorted_list_search_and_remove</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_sorted_list_insert</NAME>
<RETURNS>int </RETURNS>
NspList *L, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_map</NAME>
<RETURNS>NspList *</RETURNS>
NspList *L, NspPList *PL, NspList *args
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_fold_right</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L,NspObject *x, NspPList *PL, NspList *args
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_fold_left</NAME>
<RETURNS>NspObject *</RETURNS>
NspList *L, NspObject *x,NspPList *PL, NspList *largs
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_equal</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_not_equal</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_full_equal</NAME>
<RETURNS>int </RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_full_not_equal</NAME>
<RETURNS>int </RETURNS>
NspList *L1, NspList *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_compact</NAME>
<RETURNS>int </RETURNS>
NspList *L1, char flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_get_cell_pointer</NAME>
<RETURNS>Cell *</RETURNS>
NspList *L, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_unique</NAME>
<RETURNS>NspList *</RETURNS>
NspList *L, NspMatrix **Ind, NspMatrix **Occ
</FUNCTION>
<FUNCTION>
<NAME>nsp_list_has</NAME>
<RETURNS>Boolean </RETURNS>
NspList *L, NspObject *Obj, int *ind
</FUNCTION>
<STRUCT>
<NAME>NspMe</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeMe</NAME>
typedef struct _NspTypeMe { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeMe;
</STRUCT>
<STRUCT>
<NAME>NspMe</NAME>
struct _NspMe {
  /*< private >*/
  NspObject father; 
  NspTypeMe *type; 
  /*< public >*/
  char *path;  
  char *module;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_me_id</NAME>
extern int nsp_type_me_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_me</NAME>
extern NspTypeMe *nsp_type_me;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_me_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_me</NAME>
<RETURNS>NspTypeMe *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_me</NAME>
<RETURNS>NspMe *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>MeType</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>MeShType</NAME>
<RETURNS>char *</RETURNS>
NspMe *M
</FUNCTION>
<FUNCTION>
<NAME>MeLoopExtract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>MeObjEq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>MeObjNeq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLXME</NAME>
#define NULLXME (NspMe *) 0
</MACRO>
<FUNCTION>
<NAME>MeFullComp</NAME>
<RETURNS>int </RETURNS>
NspMe * A,NspMe * B,char *op,int *err
</FUNCTION>
<FUNCTION>
<NAME>MeCreate</NAME>
<RETURNS>NspMe *</RETURNS>
char *name
</FUNCTION>
<FUNCTION>
<NAME>MeCopy</NAME>
<RETURNS>NspMe *</RETURNS>
NspMe *H
</FUNCTION>
<FUNCTION>
<NAME>MeDestroy</NAME>
<RETURNS>void </RETURNS>
NspMe *H
</FUNCTION>
<FUNCTION>
<NAME>MeInfo</NAME>
<RETURNS>void </RETURNS>
NspMe *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>MePrint</NAME>
<RETURNS>void </RETURNS>
NspMe *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>MeObj</NAME>
<RETURNS>NspMe  *</RETURNS>
 NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_qr</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **q,NspMatrix **r,NspMatrix **E,NspMatrix **Rank,NspMatrix **Sval,double *tol,char mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_lsq</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, double *Rcond, int *Rank
</FUNCTION>
<FUNCTION>
<NAME>nsp_det</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A,char mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_spec</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix **d,NspMatrix **v
</FUNCTION>
<FUNCTION>
<NAME>nsp_spec_sym</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **d,char flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_gspec</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, NspMatrix **Vl, NspMatrix **Vr,NspMatrix **alpha, NspMatrix **beta
</FUNCTION>
<FUNCTION>
<NAME>nsp_rcond</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,double *rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholesky</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, int *minor
</FUNCTION>
<FUNCTION>
<NAME>nsp_lu</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **L,NspMatrix **E, NspMatrix **Rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_svd</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **S,NspMatrix **U,NspMatrix **V,char flag,NspMatrix **Rank,double *tol
</FUNCTION>
<FUNCTION>
<NAME>nsp_inv</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_norm</NAME>
<RETURNS>double </RETURNS>
NspMatrix *A, char flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_vector_norm</NAME>
<RETURNS>double </RETURNS>
NspMatrix *A, double p
</FUNCTION>
<FUNCTION>
<NAME>nsp_balanc</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **D
</FUNCTION>
<FUNCTION>
<NAME>nsp_gbalanc</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix *B,NspMatrix **X,NspMatrix **Y
</FUNCTION>
<FUNCTION>
<NAME>nsp_hess</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A,NspMatrix **U
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_is_symmetric</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_is_upper_triangular</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_is_lower_triangular</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_have_nan_or_inf</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_expm</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_bdiv</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B, double tol_rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_lsq</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, double tol_rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_square</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, double *rcond, double tol_rcond
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_triangular</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, char tri_type, int *info
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_bdiv_diagonal</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, int *info
</FUNCTION>
<FUNCTION>
<NAME>nsp_solve_banded</NAME>
<RETURNS>int </RETURNS>
NspMatrix *A, NspMatrix *B, NspMatrix **X
</FUNCTION>
<USER_FUNCTION>
<NAME>Scig_command_handler</NAME>
<RETURNS>int </RETURNS>
char *
</USER_FUNCTION>
<FUNCTION>
<NAME>scig_command_handler_none</NAME>
<RETURNS>int </RETURNS>
char *command
</FUNCTION>
<FUNCTION>
<NAME>set_scig_command_handler</NAME>
<RETURNS>Scig_command_handler </RETURNS>
Scig_command_handler f
</FUNCTION>
<FUNCTION>
<NAME>reset_scig_command_handler</NAME>
<RETURNS>void </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>enqueue_nsp_command</NAME>
<RETURNS>int </RETURNS>
char *command
</FUNCTION>
<FUNCTION>
<NAME>checkqueue_nsp_command</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>lockqueue_nsp_command</NAME>
<RETURNS>void </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>unlockqueue_nsp_command</NAME>
<RETURNS>void </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>dequeue_nsp_command</NAME>
<RETURNS>int </RETURNS>
char *buf,int buf_len
</FUNCTION>
<TYPEDEF>
<NAME>NspSMatrix</NAME>
typedef struct _NspSmatrix NspSMatrix ;
</TYPEDEF>
<STRUCT>
<NAME>NspTypeSMatrix</NAME>
typedef struct _NspTypeSMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeSMatrix;
</STRUCT>
<STRUCT>
<NAME>NspSmatrix</NAME>
struct _NspSmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeSMatrix *type; 
  /*< public >*/
  int m,n,mn;
  nsp_string *S;  /* a table of mn+1 strings the last one is NULL */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_smatrix_id</NAME>
extern int nsp_type_smatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_smatrix</NAME>
extern NspTypeSMatrix *nsp_type_smatrix;
</VARIABLE>
<FUNCTION>
<NAME>new_type_smatrix</NAME>
<RETURNS>NspTypeSMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_smatrix</NAME>
<RETURNS>NspSMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSTRING</NAME>
#define NULLSTRING (nsp_string) 0
</MACRO>
<MACRO>
<NAME>NULLSMAT</NAME>
#define NULLSMAT   (NspSMatrix *) 0
</MACRO>
<FUNCTION>
<NAME>nsp_smatrix_object</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_object</NAME>
<RETURNS>char *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSMat</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsString</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSMatCopy</NAME>
<RETURNS>NspSMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSMat</NAME>
<RETURNS>NspSMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetString</NAME>
<RETURNS>char *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetStringInArray</NAME>
<RETURNS>int </RETURNS>
Stack stack, int ith, char **Table, int flag
</FUNCTION>
<FUNCTION>
<NAME>GetStringInStruct</NAME>
<RETURNS>int </RETURNS>
Stack stack, int ith,void *T,unsigned int size, int flag
</FUNCTION>
<FUNCTION>
<NAME>is_string_in_array</NAME>
<RETURNS>int </RETURNS>
const char *key, char **Table, int flag
</FUNCTION>
<FUNCTION>
<NAME>string_not_in_array</NAME>
<RETURNS>void </RETURNS>
Stack stack,const char *key, char **Table,char *message
</FUNCTION>
<FUNCTION>
<NAME>is_string_in_struct</NAME>
<RETURNS>int </RETURNS>
const char *key,void **Table,unsigned int size, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create</NAME>
<RETURNS>NspSMatrix *</RETURNS>
nsp_const_string name,int m,int n,nsp_const_string str,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_clone</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const char *name, NspSMatrix *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_with_length</NAME>
<RETURNS>NspSMatrix *</RETURNS>
nsp_const_string name, int m, int n, int strl
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_from_table</NAME>
<RETURNS>NspSMatrix *</RETURNS>
char **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_from_array</NAME>
<RETURNS>NspSMatrix *</RETURNS>
nsp_const_string name,int n,const char **T
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_create_from_struct</NAME>
<RETURNS>NspSMatrix*</RETURNS>
nsp_const_string name,const void *T,unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_copy</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_resize</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_info</NAME>
<RETURNS>int </RETURNS>
const NspSMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_print</NAME>
<RETURNS>int </RETURNS>
const NspSMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_redim</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_right</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,const NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>Scopy</NAME>
<RETURNS>int </RETURNS>
int n, nsp_string *s1, nsp_string *s2
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_add_columns</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>Sset</NAME>
<RETURNS>int </RETURNS>
int n, nsp_string s1, nsp_string *s2
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_down</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const NspSMatrix *A,const NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_down1</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,NspSMatrix *B,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_add_rows</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A,const NspMatrix *Rows,const NspMatrix *Cols,const NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_set_rows</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, NspMatrix *Rows, NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract_elements</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, NspMatrix *Elts, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract_columns</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>SMatLoopCol</NAME>
<RETURNS>NspSMatrix *</RETURNS>
char *str, NspSMatrix *Col, NspSMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_extract_rows</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_strings</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, NspSMatrix *B,nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_string_right</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, NspSMatrix *B, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_concat_string_left</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, NspSMatrix *B, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strcmp</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSMatrix *A, NspSMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_column_concat_padded</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_column_concat</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_row_concat</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_elts_concat</NAME>
<RETURNS>nsp_string </RETURNS>
const NspSMatrix *A, nsp_const_string rstr, int rflag, nsp_const_string cstr, int cflag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_part</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *A, NspMatrix *Ind
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_elts_length</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_smatrix</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_tolower</NAME>
<RETURNS>void </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_toupper</NAME>
<RETURNS>void </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_capitalize</NAME>
<RETURNS>void </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strstr</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSMatrix *A, nsp_const_string Str
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strindex</NAME>
<RETURNS>NspMatrix *</RETURNS>
nsp_const_string Str,nsp_const_string Motif
</FUNCTION>
<FUNCTION>
<NAME>nsp_ascii_to_smatrix</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_string_to_ascii</NAME>
<RETURNS>NspMatrix *</RETURNS>
nsp_const_string S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_sort_old</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSMatrix *A,int flag,nsp_const_string  str1,nsp_const_string str2
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_split_string</NAME>
<RETURNS>NspSMatrix *</RETURNS>
nsp_const_string string, nsp_const_string splitChars, int msep
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_split</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspSMatrix *Src, nsp_const_string splitChars, int msep
</FUNCTION>
<FUNCTION>
<NAME>nsp_row_smatrix_append_string</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>SMatCompOp</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspSMatrix *A, NspSMatrix *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>SMatFullComp</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A, NspSMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_transpose</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_subst</NAME>
<RETURNS>NspSMatrix *</RETURNS>
const NspSMatrix *A,nsp_const_string needle,nsp_const_string  replace
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strip_blanks</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_read_lines</NAME>
<RETURNS>int </RETURNS>
NspFile *F,NspSMatrix **S,int nlines
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_convert</NAME>
<RETURNS>NspSMatrix*</RETURNS>
const char *name,NspSMatrix *A,const char *to_codeset,const char *from_codeset
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_to_utf8</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_utf8_validate</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_utf8_from_unichar</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_latex_print</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *SMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_latex_tab_print</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *SMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_fscanf_matrix</NAME>
<RETURNS>int </RETURNS>
NspFile *F,char *format,NspMatrix **M,int flag,NspSMatrix **S
</FUNCTION>
<FUNCTION>
<NAME>nsp_read_lines</NAME>
<RETURNS>int </RETURNS>
NspFile *F,NspSMatrix **S,int nlines
</FUNCTION>
<FUNCTION>
<NAME>nsp_fscanf_smatrix</NAME>
<RETURNS>int </RETURNS>
NspFile *F,NspSMatrix **S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_strtod</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspSMatrix *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_type_as_string</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_type_short_string</NAME>
<RETURNS>char *</RETURNS>
NspObject *v
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_loop_extract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_eq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_neq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_is_true</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_xdr_load</NAME>
<RETURNS>NspSMatrix *</RETURNS>
XDR  *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_smatrix_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR  *F, NspSMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_double2int</NAME>
<RETURNS>int </RETURNS>
int *n, double *dx, int *ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_float2int</NAME>
<RETURNS>int </RETURNS>
int *n, float *dx, int *ix
</FUNCTION>
<FUNCTION>
<NAME>nsp_double2float</NAME>
<RETURNS>int </RETURNS>
int *n, double *dx, float *rx
</FUNCTION>
<FUNCTION>
<NAME>nsp_int2double</NAME>
<RETURNS>int </RETURNS>
int *n, int *idx, int *incx, double *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_int2float</NAME>
<RETURNS>int </RETURNS>
int *n, int *idx, int *incx, float *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_float2double</NAME>
<RETURNS>int </RETURNS>
int *n, float *rdx, int *incx, double *dy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_convert_double_to_type</NAME>
<RETURNS>int </RETURNS>
double *x, int n, const char *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_convert_type_to_double</NAME>
<RETURNS>int </RETURNS>
double *x, int n, const char *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_dset</NAME>
<RETURNS>int </RETURNS>
const int *n, const double *dx, double *dy, const int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dadd</NAME>
<RETURNS>int </RETURNS>
const int n, const double *dx,const int incx, double *dy,const int incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dsub</NAME>
<RETURNS>int </RETURNS>
const int n,const  double *dx,const int incx, double *dy,const  int incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dadd_maxplus</NAME>
<RETURNS>int </RETURNS>
const int n, const double *dx, const  int incx, double *dy, const  int incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dsub_maxplus</NAME>
<RETURNS>int </RETURNS>
const int n,const double *dx,const int incx, double *dy,const int incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dsum</NAME>
<RETURNS>double </RETURNS>
int *n, double *dx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_dvmul</NAME>
<RETURNS>int </RETURNS>
const int n,const  double *dx,const  int incx, double *dy,const  int incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_icopy</NAME>
<RETURNS>int </RETURNS>
const int *n, const int *idx, const int *incx, int *idy, const int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_iset</NAME>
<RETURNS>int </RETURNS>
int *n, int *idx, int *idy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_iadd</NAME>
<RETURNS>int </RETURNS>
int *n, int *ival, int *idy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dzcopy</NAME>
<RETURNS>int </RETURNS>
const int *n, const double *zx, const int *incx, doubleC *zy, const int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_dzscal</NAME>
<RETURNS>int </RETURNS>
int *n, double *da, doubleC *zx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_dzset</NAME>
<RETURNS>int </RETURNS>
int *n, double *dx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zadd</NAME>
<RETURNS>int </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zadd_maxplus</NAME>
<RETURNS>int </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>myzabs</NAME>
<RETURNS>double </RETURNS>
double real, double imag
</FUNCTION>
<FUNCTION>
<NAME>nsp_zasum</NAME>
<RETURNS>double </RETURNS>
int *n, doubleC *zx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_zsub</NAME>
<RETURNS>int </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zsub_maxplus</NAME>
<RETURNS>int </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_zsum</NAME>
<RETURNS>void </RETURNS>
doubleC *ret_val, int *n, doubleC *zx, int *incx
</FUNCTION>
<FUNCTION>
<NAME>nsp_zvmul</NAME>
<RETURNS>int </RETURNS>
int *n, doubleC *zx, int *incx, doubleC *zy, int *incy
</FUNCTION>
<FUNCTION>
<NAME>nsp_urand</NAME>
<RETURNS>double </RETURNS>
int *iy
</FUNCTION>
<FUNCTION>
<NAME>nsp_magic_matrix_fill</NAME>
<RETURNS>void </RETURNS>
double *m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_franck_matrix</NAME>
<RETURNS>void </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_franck_inverse_matrix</NAME>
<RETURNS>void </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_hilbert_matrix</NAME>
<RETURNS>void </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_hilbert_inverse_matrix</NAME>
<RETURNS>void </RETURNS>
double *a, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_complex2double</NAME>
<RETURNS>void </RETURNS>
double *tab, int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_double2complex</NAME>
<RETURNS>void </RETURNS>
 double *tab, int size
</FUNCTION>
<ENUM>
<NAME>accelerated_ops</NAME>
typedef enum { 
  undef_tab=-1,
  concatr_tab=0, 
  concatd_tab=1,
  extract_tab=2,
  extractelts_tab=3,
  extractcols_tab=4,
  extractrows_tab=5,
  resize2vect_tab=6,
  deleteelts_tab=7,
  deletecols_tab=8,
  deleterows_tab=9,
  tozero_tab=10,
  setrowscols_tab=11} accelerated_ops;
</ENUM>
<STRUCT>
<NAME>AcceleratedTab</NAME>
</STRUCT>
<STRUCT>
<NAME>AcceleratedTab</NAME>
struct _AcceleratedTab
{
  int ops_id; /* this should be equal to the indice in table */
  const char *opname;
  int arity;
  const char **accelerated_types;
  int length;
  function **func;
} ;
</STRUCT>
<FUNCTION>
<NAME>nsp_get_fast_function</NAME>
<RETURNS>function *</RETURNS>
AcceleratedTab *tab, int type_id
</FUNCTION>
<FUNCTION>
<NAME>nsp_init_accelerated_tabs</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>NspPList</NAME>
typedef struct _NspPlist  NspPList;
</TYPEDEF>
<STRUCT>
<NAME>NspTypePList</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePList</NAME>
struct _NspTypePList { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<TYPEDEF>
<NAME>PCell</NAME>
typedef struct parse_cell PCell;
</TYPEDEF>
<TYPEDEF>
<NAME>PList</NAME>
typedef struct parse_cell *PList;
</TYPEDEF>
<STRUCT>
<NAME>parse_cell</NAME>
struct parse_cell {
  struct parse_cell *prev;  /* points to the previous cell or 0 */
  struct parse_cell *next;  /* points to the next cell or 0 */
  void *O;                  /* points to the stored object or can be used to store line number
			       for operators */
  int   type;               /* type of object */
  short int arity ;         /* used to store arity of operators */
};
</STRUCT>
<STRUCT>
<NAME>parse_double</NAME>
</STRUCT>
<STRUCT>
<NAME>parse_double</NAME>
struct _parse_double {
  double val ; /* the value of the parsed double */
  nsp_string str;
};
</STRUCT>
<STRUCT>
<NAME>NspPlist</NAME>
struct _NspPlist {
  /*< private >*/
  NspObject father; 
  NspTypePList *type; 
  /*< public >*/
  char *file_name;  /* NULL or points to the function source file-name */
  PList D;          /* points to the parsed expression */
  int dir;          /* indice in directory array or -1 */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_plist_id</NAME>
extern int nsp_type_plist_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_plist</NAME>
extern NspTypePList *nsp_type_plist;
</VARIABLE>
<FUNCTION>
<NAME>new_type_plist</NAME>
<RETURNS>NspTypePList *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_plist</NAME>
<RETURNS>NspPList *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>NspPListSize</NAME>
<RETURNS>int </RETURNS>
NspPList *Mat, int flag
</FUNCTION>
<FUNCTION>
<NAME>NspPListType</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>NspPListShType</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>NspPListLoopExtract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>NspPListObjEq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>NspPListObjNeq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>NspPListXdrLoad</NAME>
<RETURNS>NspPList *</RETURNS>
XDR *xdrs
</FUNCTION>
<FUNCTION>
<NAME>NspPListXdrSave</NAME>
<RETURNS>int </RETURNS>
XDR *xdrs, NspPList *M
</FUNCTION>
<MACRO>
<NAME>NULLP_PLIST</NAME>
#define NULLP_PLIST (NspPList*) 0 
</MACRO>
<MACRO>
<NAME>NULLPLIST</NAME>
#define NULLPLIST (PList) 0 
</MACRO>
<FUNCTION>
<NAME>NspPListObj</NAME>
<RETURNS>NspPList *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsNspPListObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsNspPList</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetNspPListCopy</NAME>
<RETURNS>NspPList *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetNspPList</NAME>
<RETURNS>NspPList *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>NspPListCreate</NAME>
<RETURNS>NspPList *</RETURNS>
char *name, PList L, char *filename
</FUNCTION>
<FUNCTION>
<NAME>NspPListCopy</NAME>
<RETURNS>NspPList *</RETURNS>
NspPList *A
</FUNCTION>
<FUNCTION>
<NAME>NspPListCopy_no_local_vars</NAME>
<RETURNS>NspPList *</RETURNS>
NspPList *A
</FUNCTION>
<FUNCTION>
<NAME>NspPListDestroy</NAME>
<RETURNS>void </RETURNS>
NspPList *P_L
</FUNCTION>
<FUNCTION>
<NAME>NspPListPrInt</NAME>
<RETURNS>void </RETURNS>
NspPList *P_L
</FUNCTION>
<FUNCTION>
<NAME>NspPListInfo</NAME>
<RETURNS>void </RETURNS>
NspPList *P_L, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>NspPListPrint</NAME>
<RETURNS>void </RETURNS>
NspPList *P_L, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>NspPListSave</NAME>
<RETURNS>int </RETURNS>
NspPList *P_L
</FUNCTION>
<FUNCTION>
<NAME>NspPList2SMatrix</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspPList *P_L, int indent
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add</NAME>
<RETURNS>int </RETURNS>
PList *plist, int op, int arity, int line
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_last</NAME>
<RETURNS>int </RETURNS>
PList *plist, int op, int arity, int line
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_name</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_name1</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str, int arity
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_string</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_comment</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_list</NAME>
<RETURNS>int </RETURNS>
PList *plist, PList *l
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_append</NAME>
<RETURNS>int </RETURNS>
PList *plist, PList *l
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_list1</NAME>
<RETURNS>int </RETURNS>
PList *plist, PList *l
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_doublei</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_opname</NAME>
<RETURNS>int </RETURNS>
PList *plist, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_add_object</NAME>
<RETURNS>int </RETURNS>
PList *plist, NspObject *obj
</FUNCTION>
<FUNCTION>
<NAME>ParseAddDouble</NAME>
<RETURNS>int </RETURNS>
PList *plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_eplist_create</NAME>
<RETURNS>PList </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_destroy</NAME>
<RETURNS>void </RETURNS>
PList *List
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_copy</NAME>
<RETURNS>PList </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_copy_no_local_vars</NAME>
<RETURNS>PList </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_last</NAME>
<RETURNS>PList </RETURNS>
PList plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_print_internal</NAME>
<RETURNS>void </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_firstel</NAME>
<RETURNS>PList </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_pretty_print_opname</NAME>
<RETURNS>int </RETURNS>
int type, int indent, int pos
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_pretty_print</NAME>
<RETURNS>void </RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>nsp_arg_pretty_print</NAME>
<RETURNS>int </RETURNS>
PList L, int i, int pos, int posret
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_print</NAME>
<RETURNS>void </RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_info</NAME>
<RETURNS>void </RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>ShowLine</NAME>
<RETURNS>void </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_save</NAME>
<RETURNS>int </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist_load</NAME>
<RETURNS>int </RETURNS>
PList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_plist2smatrix</NAME>
<RETURNS>NspSMatrix *</RETURNS>
PList L, int indent
</FUNCTION>
<FUNCTION>
<NAME>plist_get_nargs</NAME>
<RETURNS>void </RETURNS>
PList List,int *lhs , int *rhsp1
</FUNCTION>
<STRUCT>
<NAME>NspRect</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeRect</NAME>
typedef struct _NspTypeRect { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeRect;
</STRUCT>
<STRUCT>
<NAME>NspRect</NAME>
struct _NspRect {
  /*< private >*/
  NspObject father; 
  NspTypeRect *type; 
  /*< public >*/
  BCG *Xgc;
  double r[4];
  int color; 
  int thickness;
  int background;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_rect_id</NAME>
extern int nsp_type_rect_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_rect</NAME>
extern NspTypeRect *nsp_type_rect;
</VARIABLE>
<FUNCTION>
<NAME>new_type_rect</NAME>
<RETURNS>NspTypeRect *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_rect</NAME>
<RETURNS>NspRect *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLRECT</NAME>
#define NULLRECT (NspRect*) 0
</MACRO>
<FUNCTION>
<NAME>IsRectObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRectCopy</NAME>
<RETURNS>NspRect *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRect</NAME>
<RETURNS>NspRect *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsRect</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>rect_create</NAME>
<RETURNS>NspRect *</RETURNS>
char *name,BCG *Xgc, double *rect, int color, int thickness, int background,NspTypeBase *
</FUNCTION>
<FUNCTION>
<NAME>RectDraw</NAME>
<RETURNS>void </RETURNS>
NspRect *R
</FUNCTION>
<FUNCTION>
<NAME>RectTranslate</NAME>
<RETURNS>void </RETURNS>
NspRect *R,const double pt[2]
</FUNCTION>
<FUNCTION>
<NAME>RectResize</NAME>
<RETURNS>void </RETURNS>
NspRect *R,const double size[2]
</FUNCTION>
<STRUCT>
<NAME>Hash_Entry</NAME>
</STRUCT>
<STRUCT>
<NAME>Hash_Entry</NAME>
struct _Hash_Entry { 
  unsigned int used; /* used to detect if data is present */
  NspObject *data;  
};
</STRUCT>
<STRUCT>
<NAME>NspTypeHash</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeHash</NAME>
struct _NspTypeHash { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>NspHash</NAME>
</STRUCT>
<STRUCT>
<NAME>NspHash</NAME>
struct _NspHash {
  /*< private >*/
  NspObject father; 
  NspTypeHash *type; 
  /*< public >*/
  unsigned int hsize,filled; /* size of hash table and number of present entries */
  void  *htable; /* an array of size hsize+1 */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_hash_id</NAME>
extern int nsp_type_hash_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_hash</NAME>
extern NspTypeHash *nsp_type_hash;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_hash_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_hash</NAME>
<RETURNS>NspTypeHash *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_hash</NAME>
<RETURNS>NspHash *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLHASH</NAME>
#define NULLHASH (NspHash*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_hash_create</NAME>
<RETURNS>NspHash *</RETURNS>
char *name, unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_copy</NAME>
<RETURNS>NspHash *</RETURNS>
NspHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_destroy</NAME>
<RETURNS>void </RETURNS>
NspHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_info</NAME>
<RETURNS>int </RETURNS>
NspHash *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_print</NAME>
<RETURNS>int </RETURNS>
NspHash *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_object</NAME>
<RETURNS>NspHash *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsHashObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsHash</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetHashCopy</NAME>
<RETURNS>NspHash *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetHash</NAME>
<RETURNS>NspHash *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_resize</NAME>
<RETURNS>int </RETURNS>
NspHash *H, unsigned int new_size
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_merge</NAME>
<RETURNS>int </RETURNS>
NspHash *H1, NspHash *H2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_get_next_object</NAME>
<RETURNS>int </RETURNS>
NspHash *H, int *i, NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_enter_copy</NAME>
<RETURNS>int </RETURNS>
NspHash *H, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_enter</NAME>
<RETURNS>int </RETURNS>
NspHash *H, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_remove</NAME>
<RETURNS>void </RETURNS>
NspHash *H, char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_find_and_copy</NAME>
<RETURNS>int </RETURNS>
NspHash *H, char *str, NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_find</NAME>
<RETURNS>int </RETURNS>
NspHash *H,const char *str, NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_equal</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_not_equal</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_full_equal</NAME>
<RETURNS>int </RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_full_not_equal</NAME>
<RETURNS>int </RETURNS>
NspHash *L1, NspHash *L2
</FUNCTION>
<ENUM>
<NAME>HashOperation</NAME>
typedef enum {
  H_FIND,
  H_FIND_COPY,
  H_ENTER,
  H_ENTER_COPY,
  H_REMOVE 
} HashOperation;
</ENUM>
<FUNCTION>
<NAME>nsp_hsearch</NAME>
<RETURNS>int </RETURNS>
NspHash *H,const char *key, NspObject **data,HashOperation action
</FUNCTION>
<FUNCTION>
<NAME>nsp_hcreate_from_list</NAME>
<RETURNS>NspHash *</RETURNS>
char *name,unsigned int nel, NspList *L
</FUNCTION>
<FUNCTION>
<NAME>nsp_hcreate</NAME>
<RETURNS>NspHash *</RETURNS>
char *name, unsigned int nel
</FUNCTION>
<FUNCTION>
<NAME>nsp_hdestroy</NAME>
<RETURNS>void </RETURNS>
NspHash *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_current_frame_to_hash</NAME>
<RETURNS>NspHash *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_hash_get_keys</NAME>
<RETURNS>NspSMatrix *</RETURNS>
NspHash *H
</FUNCTION>
<STRUCT>
<NAME>NspFunction</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeFunction</NAME>
typedef struct _NspTypeFunction { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeFunction;
</STRUCT>
<STRUCT>
<NAME>NspFunction</NAME>
struct _NspFunction {
  /*< private >*/
  NspObject father; 
  NspTypeFunction *type; 
  /*< public >*/
  char *fname; /* function name */
  int  pos;/* function position inside interface */
  int  iface;/* Interface number in which the function is stored */
  int  status;/* status of the function */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_function_id</NAME>
extern int nsp_type_function_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_function</NAME>
extern NspTypeFunction *nsp_type_function;
</VARIABLE>
<FUNCTION>
<NAME>new_type_function</NAME>
<RETURNS>NspTypeFunction *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_function</NAME>
<RETURNS>NspFunction *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLFUNC</NAME>
#define NULLFUNC (NspFunction*) 0
</MACRO>
<FUNCTION>
<NAME>function_create</NAME>
<RETURNS>NspFunction *</RETURNS>
char *name,char *fname,int iface,int pos,int status,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>function_copy</NAME>
<RETURNS>NspFunction *</RETURNS>
NspFunction *H
</FUNCTION>
<FUNCTION>
<NAME>function_destroy</NAME>
<RETURNS>void </RETURNS>
NspFunction *H
</FUNCTION>
<FUNCTION>
<NAME>function_info</NAME>
<RETURNS>int </RETURNS>
NspFunction *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>function_print</NAME>
<RETURNS>int </RETURNS>
NspFunction *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>function_object</NAME>
<RETURNS>NspFunction *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsFunctionObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsFunction</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetFunctionCopy</NAME>
<RETURNS>NspFunction *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetFunction</NAME>
<RETURNS>NspFunction *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_file</NAME>
<RETURNS>int </RETURNS>
char *Str, int display,int echo, int errcatch, int pause,int mtlb
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_from_string</NAME>
<RETURNS>int </RETURNS>
char *Str,int display,int echo, int errcatch,int pause
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_from_smat</NAME>
<RETURNS>int </RETURNS>
NspSMatrix *M,int display,int echo, int errcatch,int pause
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_from_std</NAME>
<RETURNS>int </RETURNS>
int display
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_dir</NAME>
<RETURNS>int </RETURNS>
const char *Dir, char *Fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_eval_dir_full</NAME>
<RETURNS>int </RETURNS>
const char *Dir
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse</NAME>
<RETURNS>int </RETURNS>
Tokenizer *T,NspBHash *symb_table,PList *plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_top</NAME>
<RETURNS>int </RETURNS>
Tokenizer *T,NspBHash *symb_table,PList *plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_parse_expr</NAME>
<RETURNS>PList </RETURNS>
NspSMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_function_name</NAME>
<RETURNS>char *</RETURNS>
PList plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_simple_mlhs</NAME>
<RETURNS>int </RETURNS>
PList L
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_simple_listeval</NAME>
<RETURNS>int </RETURNS>
PList plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_simple_listeval</NAME>
<RETURNS>int </RETURNS>
PList plist
</FUNCTION>
<FUNCTION>
<NAME>nsp_check_is_mlhs</NAME>
<RETURNS>int </RETURNS>
PList plist, PList *plist1, int *kount
</FUNCTION>
<FUNCTION>
<NAME>nsp_astcode_to_nickname</NAME>
<RETURNS>const char *</RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_astcode_to_name</NAME>
<RETURNS>const char *</RETURNS>
int code
</FUNCTION>
<FUNCTION>
<NAME>nsp_astcode_to_string</NAME>
<RETURNS>char *</RETURNS>
int type
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_nsp_keyword</NAME>
<RETURNS>int </RETURNS>
const char *id
</FUNCTION>
<FUNCTION>
<NAME>nsp_is_code_keyword</NAME>
<RETURNS>int </RETURNS>
int keyc
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_opname</NAME>
<RETURNS>int </RETURNS>
int code
</FUNCTION>
<STRUCT>
<NAME>NspClassB</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeClassB</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>classb_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspClassB *M
</USER_FUNCTION>
<STRUCT>
<NAME>NspTypeClassB</NAME>
struct _NspTypeClassB { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>NspClassB</NAME>
struct _NspClassB {
  /*< private >*/
  NspClassA father; 
  NspTypeClassB *type; 
  /*< public >*/
  int classb_color;
  int classb_thickness;
  NspMatrix *classb_val;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_classb_id</NAME>
extern int nsp_type_classb_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_classb</NAME>
extern NspTypeClassB *nsp_type_classb;
</VARIABLE>
<FUNCTION>
<NAME>new_type_classb</NAME>
<RETURNS>NspTypeClassB *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_classb</NAME>
<RETURNS>NspClassB *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCLB</NAME>
#define NULLCLB (NspClassB*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_classb_create</NAME>
<RETURNS>NspClassB *</RETURNS>
char *name,int color,int thickness,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_copy</NAME>
<RETURNS>NspClassB *</RETURNS>
NspClassB *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_destroy</NAME>
<RETURNS>void </RETURNS>
NspClassB *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_info</NAME>
<RETURNS>int </RETURNS>
NspClassB *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_print</NAME>
<RETURNS>int </RETURNS>
NspClassB *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_classb_object</NAME>
<RETURNS>NspClassB *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsClassBObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsClassB</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetClassBCopy</NAME>
<RETURNS>NspClassB *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetClassB</NAME>
<RETURNS>NspClassB *</RETURNS>
Stack stack, int i
</FUNCTION>
<ENUM>
<NAME>nsp_basic_types</NAME>
enum nsp_basic_types { 
  NUMBER =-10,
  NAME, 
  STRING, 
  COMMENT,
  OPNAME ,
  OBJECT ,
};
</ENUM>
<MACRO>
<NAME>NAME_MAXL</NAME>
#define NAME_MAXL 52
</MACRO>
<ENUM>
<NAME>nsp_ops</NAME>
enum nsp_ops { 
  NOTCODE_OP =129, /* start after standard ascii codes */			    
  QUOTE_OP ,			      
  STAR_OP ,			      
  PLUS_OP ,			      
  HAT_OP ,			      
  COLON_OP ,			      
  OR_OP ,			      
  AND_OP ,			      
  TILDE_OP ,			      
  RETURN_OP ,			      
  COMMA_OP ,			      
  SEMICOLON_OP ,		      
  MINUS_OP ,			      
  SLASH_OP ,			      
  BACKSLASH_OP ,		      
  DOTSTAR   ,			      
  DOTSLASH  ,			      
  DOTBSLASH ,			      
  DOTPLUS   ,			      
  STARDOT   ,			      
  SLASHDOT  ,			      
  BSLASHDOT ,			      
  DOTSTARDOT  ,			      
  DOTSLASHDOT  ,		      
  DOTBSLASHDOT ,		      
  DOTHAT ,			      
  EQ     ,			      
  LEQ    ,			      
  GEQ    ,			      
  NEQ    ,			      
  DOTEQ     ,			      
  DOTLEQ    ,			      
  DOTLT    ,			      
  DOTGEQ    ,			      
  DOTGT    ,			      
  DOTNEQ    ,			      
  DOTPRIM ,			      
  MOINS   ,   /* unary minus */	      
  SEQAND   ,   /* sequential and */   
  SEQOR ,   /* sequential or */	      
  LT_OP,
  GT_OP,
  LASTCODE_OP                         
};
</ENUM>
<ENUM>
<NAME>nsp_codes</NAME>
enum nsp_codes {
  FEVAL = -200, /* must be the fisrt and such that LASTCODE_NEG_OP is negative <= nsp_basic */
  ROWCONCAT ,
  COLCONCAT ,
  LASTCASE ,
  MLHS ,
  P_MATRIX,
  STATEMENTS ,
  STATEMENTS1 ,
  OPT ,
  DIAGCONCAT ,
  LISTEVAL ,
  ARGS ,
  PARENTH ,
  DOTARGS ,
  METARGS ,
  CELLROWCONCAT ,
  CELLCOLCONCAT ,
  CELLDIAGCONCAT ,
  P_CELL,
  CELLARGS ,
  CALLEVAL ,
  EQUAL_OP ,
  EMPTYCELL,
  EMPTYMAT,
  PLIST, 
  /* language keywords the first must be ABORT */
  ABORT ,   
  APROPOS,
  BREAK , 
  CASE ,  
  CATCH ,  
  CLEAR,  
  CLEARGLOBAL,  
  CONTINUE,  
  DO  ,   
  ELSE,   
  ELSEIF, 
  END,    
  ENDFUNCTION,
  EXEC,
  NSP_EXIT,
  FINALLY,
  FOR,    
  FUNCTION,
  GLOBAL,
  HELP  , 
  IF,     
  PAUSE,  
  QUIT ,  
  PRETURN,
  SELECT, 
  THEN,
  TRYCATCH,
  WHAT ,  
  WHILE,  
  WHO ,   
  /* guard */
  LASTCODE_NEG_OP  
};
</ENUM>
<VARIABLE>
<NAME>int_bmatrix_b2m</NAME>
extern function int_bmatrix_b2m;
</VARIABLE>
<VARIABLE>
<NAME>int_bmatrix_setrc</NAME>
extern function int_bmatrix_setrc;
</VARIABLE>
<TYPEDEF>
<NAME>NspMaxpMatrix</NAME>
typedef struct _NspMpmatrix NspMaxpMatrix;
</TYPEDEF>
<STRUCT>
<NAME>NspTypeMaxpMatrix</NAME>
typedef struct _NspTypeMaxpMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeMaxpMatrix;
</STRUCT>
<STRUCT>
<NAME>NspMpmatrix</NAME>
struct _NspMpmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeMaxpMatrix *type; 
  /*< public >*/
  int m,n,mn;/* NspMaxpMatrix dimensions */
  union { 
    double *R;     /* Pointer on real values */
    doubleC *C;    /* Pointer on complex values */
    int *I;        /* Pointer on integer values */
    float *F;      /* Pointer on float values */
  };
  char rc_type;    /* 'r' : real or  'c' : complex  */
  char convert;    /* 'd','i','f' : double, int, float
		    * used to remember array converted in place */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_mpmatrix_id</NAME>
extern int nsp_type_mpmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_mpmatrix</NAME>
extern NspTypeMaxpMatrix *nsp_type_mpmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_mpmatrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_mpmatrix</NAME>
<RETURNS>NspTypeMaxpMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_mpmatrix</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLMAXPMAT</NAME>
#define NULLMAXPMAT (NspMaxpMatrix*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_mpmatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_info</NAME>
<RETURNS>int </RETURNS>
 NspMaxpMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_copy</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_print</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_loop_extract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_copy</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_object</NAME>
<RETURNS>NspMaxpMatrix  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_fullcomp</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>mpmatrix_object</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsMpMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsMpMat</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatCopy</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatCopyInt</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatInt</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatCopyFloat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetMpMatFloat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopy_G</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMat_G</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopy</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopyInt</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatInt</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatCopyFloat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealMpMatFloat</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>MpMatd2i</NAME>
<RETURNS>int *</RETURNS>
NspMaxpMatrix *A, int *imin, int *imax
</FUNCTION>
<FUNCTION>
<NAME>MpMat2double</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>MpMat2int</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>MpMat2float</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mp_matrix_from_m</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const char *name,NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const char *name, char type, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_clone</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const char *name, NspMatrix *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create_impl</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
double first, double step, double last
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create_from_doubles</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const char *name,int m,int n,...
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_fill_with</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_resize</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_scalar_to_mn</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_latex_print</NAME>
<RETURNS>int </RETURNS>
const NspMaxpMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_latex_tab_print</NAME>
<RETURNS>int </RETURNS>
const NspMaxpMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_redim</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_concat_right</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_add_columns</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_concat_down</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_concat_diag</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_add_rows</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_set_rows</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMatrix *Rows, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Rows,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_elements</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_columns</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_rows</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A,const  NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>MpMatLoopCol</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
char *str, NspMaxpMatrix *Col, NspMaxpMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_extract_diag</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_set_diag</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_create_diag</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_transpose</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
const NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_set_rval</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_set_ival</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_add</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_dadd</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_add_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sub</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_dsub</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sub_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_subs_calarm</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_clean</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, int rhs, double epsa, double epsr
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_maxitt1</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B, NspMaxpMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_minitt1</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B, NspMaxpMatrix *Ind, int j, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_slec</NAME>
<RETURNS>NspMaxpMatrix **</RETURNS>
char *file, int *Count
</FUNCTION>
<FUNCTION>
<NAME>MaxpMatLec</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
FILE *fd
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_readline</NAME>
<RETURNS>int </RETURNS>
FILE *fd
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_complexify</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_get_real</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_get_imag</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_inv_el</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_kron</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sort</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, int flag, char *str1, char *str2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sum</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_prod</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cum_prod</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cum_sum</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_maxi</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag, NspMaxpMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mini</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMaxpMatrix *A, char *flag, NspMaxpMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_createinit</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
char *name, char type, int m, int n, double (*func) ()
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_triu</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_tril</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_eye</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ones</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_zeros</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_rand</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_tt</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_el</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_pow_scalarm</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_div_tt</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_div_el</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_div_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_bdiv_tt</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_bdiv_el</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_bdiv_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult_tt</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult_el</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_mult_scalar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *Mat1, NspMaxpMatrix *Mat2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_acos</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_acosh</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_asin</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_asinh</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_atan</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_atan2</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A,NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_atanh</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ceil</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_modulo</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_idiv</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_int</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_floor</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_round</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sign</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_tan</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_tanh</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_abs</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_erf</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_erfc</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_arg</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_polar</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_iand</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_iandu</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ior</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_ioru</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, unsigned int *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_conj</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cos</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_cosh</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_expel</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_logel</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sin</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sinh</NAME>
<RETURNS>void </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_sqrtel</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_minus</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_magic</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_franck</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int n, int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_hilbert</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
int n,int job
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_fullcomp</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, NspMaxpMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmat_find</NAME>
<RETURNS>int </RETURNS>
NspMaxpMatrix *A, int lhs, NspMaxpMatrix **Res1, NspMaxpMatrix **Res2
</FUNCTION>
<FUNCTION>
<NAME>nsp_mpmatrix_cast_to_matrix</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMaxpMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_cast_to_mpmatrix</NAME>
<RETURNS>NspMaxpMatrix *</RETURNS>
NspMatrix *M
</FUNCTION>
<STRUCT>
<NAME>NspType</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeType</NAME>
typedef struct _NspTypeType { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeType;
</STRUCT>
<STRUCT>
<NAME>NspType</NAME>
struct _NspType {
  /*< private >*/
  NspObject father; 
  NspTypeType *type; 
  /*< public >*/
  NspTypeBase *nsp_type;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_type_id</NAME>
extern int nsp_type_type_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_type</NAME>
extern NspTypeType *nsp_type_type;
</VARIABLE>
<FUNCTION>
<NAME>new_type_type</NAME>
<RETURNS>NspTypeType *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_type</NAME>
<RETURNS>NspType *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLTYPE</NAME>
#define NULLTYPE (NspType*) 0
</MACRO>
<FUNCTION>
<NAME>type_create</NAME>
<RETURNS>NspType *</RETURNS>
char *name,NspTypeBase *type,NspTypeBase *derived_type
</FUNCTION>
<FUNCTION>
<NAME>type_copy</NAME>
<RETURNS>NspType *</RETURNS>
NspType *H
</FUNCTION>
<FUNCTION>
<NAME>type_destroy</NAME>
<RETURNS>void </RETURNS>
NspType *H
</FUNCTION>
<FUNCTION>
<NAME>type_info</NAME>
<RETURNS>int </RETURNS>
NspType *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>type_print</NAME>
<RETURNS>int </RETURNS>
NspType *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>type_object</NAME>
<RETURNS>NspType *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsTypeObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsType</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetTypeCopy</NAME>
<RETURNS>NspType *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetType</NAME>
<RETURNS>NspType *</RETURNS>
Stack stack, int i
</FUNCTION>
<VARIABLE>
<NAME>nsp_types_hash_table</NAME>
extern NspHash *nsp_types_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_gtk_hash_table</NAME>
extern NspHash *nsp_gtk_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_atk_hash_table</NAME>
extern NspHash *nsp_atk_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_gdk_hash_table</NAME>
extern NspHash *nsp_gdk_hash_table; 
</VARIABLE>
<VARIABLE>
<NAME>nsp_pango_hash_table</NAME>
extern NspHash *nsp_pango_hash_table; 
</VARIABLE>
<FUNCTION>
<NAME>nsp_get_type_from_name</NAME>
<RETURNS>void *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>type_get_name</NAME>
<RETURNS>char *</RETURNS>
void *type
</FUNCTION>
<STRUCT>
<NAME>OpTab</NAME>
</STRUCT>
<STRUCT>
<NAME>OpTab</NAME>
struct _OpTab  {
  char *name;
  function *fonc;
};
</STRUCT>
<STRUCT>
<NAME>OpWrapTab</NAME>
</STRUCT>
<STRUCT>
<NAME>OpWrapTab</NAME>
struct _OpWrapTab  {
  char *name;
  function *fonc;
  function_wrapper *wrapper;
};
</STRUCT>
<FUNCTION>
<NAME>SMatCreateFromAttrsTable</NAME>
<RETURNS>NspSMatrix *</RETURNS>
AttrTab *T
</FUNCTION>
<MACRO>
<NAME>NthObj</NAME>
#define NthObj(x) (stack.val->S[stack.first+x-1])
</MACRO>
<MACRO>
<NAME>NspFname</NAME>
#define NspFname(x) (x).fname 
</MACRO>
<MACRO>
<NAME>NspFnameH</NAME>
#define NspFnameH(x) (x)->fname 
</MACRO>
<MACRO>
<NAME>NspFileName</NAME>
#define NspFileName(x) (x).file_name
</MACRO>
<MACRO>
<NAME>CheckRhs</NAME>
#define CheckRhs(x,y) if ( rhs < x || rhs > y )				\
    { Scierror("Error: %d arguments is incorrect for function %s\n",rhs,stack.fname);return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckLhs</NAME>
#define CheckLhs(x,y) if ( lhs != -1 && ( lhs < x || lhs > y ))		\
    { Scierror("Error %d returned values is incorrect for function %s\n",lhs,stack.fname);return RET_BUG;}
</MACRO>
<MACRO>
<NAME>CheckStdRhs</NAME>
#define CheckStdRhs(x,y) if ( rhs -opt < x || rhs -opt > y )		\
  { Scierror("Error: %d arguments is incorrect for function %s\n",rhs-opt,stack.fname);return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckOptRhs</NAME>
#define CheckOptRhs(x,y) if ( opt < x || opt > y )			\
  { Scierror("Error: %d optional arguments is incorrect for function %s\n",opt,stack.fname);return RET_BUG;} 
</MACRO>
<ENUM>
<NAME>int_types</NAME>
typedef enum _int_types{ 
  s_int,        /* scalar int */
  s_double,     /* scalar double */
  s_bool,       /* scalar bool   */
  string,       /* string */
  stringcopy,   /* string copy */
  mat,          /* matrix */
  matcopy,      /* copy of matrix */
  realmat,      /* real matrix */
  realmatcopy,  /* copy of real matrix */
  smat,         /* string  matrix */
  smatcopy,     /* copy of string matrix */
  bmat,         /* boolean  matrix */
  bmatcopy,     /* copy of boolean matrix */
  mat_int,      /* matrix converted to int */
  matcopy_int,  /* copy of a matrix + int conversion */
  list,         /* a list */
  list_begin,   /* used to start a list description */
  list_end,     /* used to stop  a list description */
  obj,          /* an object */
  objcopy,      /* copy of object */
  obj_check,    /* an object preceeded by its type */
  hash,         /* a hash table */
  hashcopy,     /* a hash table copy*/
  opts,         /* optional arguments follow */ 
  new_opts,         /* optional arguments follow */ 
  t_end         /* end of type table  */ 
} int_types;
</ENUM>
<STRUCT>
<NAME>nsp_option</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_option</NAME>
struct _nsp_option { 
  char *name;  /* options names */
  int_types type; /* types associated to each optional name */
  NspObject *obj;    /* array to store pointers to selected optional arguments 
		  * (set to NULL) if optional argument is not found */
  int  position;     /* stack position of arguments */
};
</STRUCT>
<FUNCTION>
<NAME>RetArgs</NAME>
<RETURNS>int </RETURNS>
Stack stack,int lhs,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>GetArgs</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int rhs,int opt,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>GetListArgs</NAME>
<RETURNS>int  </RETURNS>
NspList *L,int pos,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>BuildListFromArgs</NAME>
<RETURNS>NspList *</RETURNS>
const char *name,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>GetFromTable</NAME>
<RETURNS>int  </RETURNS>
NspObject **Objs,int_types *T,...
</FUNCTION>
<FUNCTION>
<NAME>get_optional_args</NAME>
<RETURNS>int  </RETURNS>
Stack stack,int rhs,int opt,nsp_option opts[],...
</FUNCTION>
<FUNCTION>
<NAME>get_optional_args_from_hash</NAME>
<RETURNS>int  </RETURNS>
Stack stack,NspHash *H,nsp_option opts[],...
</FUNCTION>
<FUNCTION>
<NAME>get_args_from_hash</NAME>
<RETURNS>int  </RETURNS>
Stack stack,NspHash *H,nsp_option opts[],...
</FUNCTION>
<FUNCTION>
<NAME>PutLhsObj</NAME>
<RETURNS>void </RETURNS>
Stack stack,int nv,int ind[]
</FUNCTION>
<FUNCTION>
<NAME>OptCheck</NAME>
<RETURNS>void </RETURNS>
NspObject **Os,NspObject **DefO,char **Names,int n,Stack ,int nopt
</FUNCTION>
<FUNCTION>
<NAME>ArgPosition</NAME>
<RETURNS>char *</RETURNS>
int i
</FUNCTION>
<FUNCTION>
<NAME>ArgName</NAME>
<RETURNS>void </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>SwapObjs</NAME>
<RETURNS>void </RETURNS>
Stack stack,int i,int j
</FUNCTION>
<FUNCTION>
<NAME>MoveObj</NAME>
<RETURNS>void </RETURNS>
Stack stack ,int j,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>StackStore</NAME>
<RETURNS>void </RETURNS>
Stack stack,NspObject * o,int pos
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_string</NAME>
<RETURNS>int </RETURNS>
Stack stack,int n,const char *bytes,int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_string_obj</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,const char *bytes,int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_double</NAME>
<RETURNS>int </RETURNS>
Stack stack,int n,double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_doubles</NAME>
<RETURNS>int </RETURNS>
Stack stack,int pos, int m,int n,...
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_double_obj</NAME>
<RETURNS>NspObject *</RETURNS>
double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_move_boolean</NAME>
<RETURNS>int </RETURNS>
Stack stack,int n,int ival
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_boolean_obj</NAME>
<RETURNS>NspObject *</RETURNS>
int ival
</FUNCTION>
<FUNCTION>
<NAME>ObjConvert</NAME>
<RETURNS>void </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>ModObj</NAME>
<RETURNS>NspMod  *</RETURNS>
 NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetModCopy</NAME>
<RETURNS>NspMod *</RETURNS>
Stack S,int i
</FUNCTION>
<FUNCTION>
<NAME>GetMod</NAME>
<RETURNS>NspMod *</RETURNS>
Stack S,int i
</FUNCTION>
<FUNCTION>
<NAME>GetMe</NAME>
<RETURNS>NspMe *</RETURNS>
Stack stack,int i
</FUNCTION>
<FUNCTION>
<NAME>GetMeCopy</NAME>
<RETURNS>NspMe *</RETURNS>
Stack stack,int i
</FUNCTION>
<FUNCTION>
<NAME>GetLmoCopy</NAME>
<RETURNS>NspLmo *</RETURNS>
Stack S,int  i
</FUNCTION>
<FUNCTION>
<NAME>GetLmo</NAME>
<RETURNS>NspLmo *</RETURNS>
Stack S,int i
</FUNCTION>
<MACRO>
<NAME>DIM_STD</NAME>
#define  DIM_STD  0x1
</MACRO>
<MACRO>
<NAME>DIM_DOT</NAME>
#define  DIM_DOT  0x2
</MACRO>
<MACRO>
<NAME>DIM_MTLB</NAME>
#define  DIM_MTLB 0x4 
</MACRO>
<FUNCTION>
<NAME>GetDimArg</NAME>
<RETURNS>int </RETURNS>
Stack stack, int pos, int *dim, int flag
</FUNCTION>
<MACRO>
<NAME>CheckSameDims</NAME>
#define CheckSameDims(fname,pos1,pos2,o1,o2) if ( o1->m != o2->m || o1->n != o2->n ) \
   { Scierror("%s: arguments %d and %d should have the same size\n",fname,pos1,pos2); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckDims</NAME>
#define CheckDims(fname,pos1,o1,m1,n1) if ( o1->m != m1 || o1->n != n1 ) \
   { Scierror("%s: arguments %d should be of size %dx%d\n",fname,pos1,m1,n1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckDimProp</NAME>
#define CheckDimProp(fname,pos1,pos2,log_exp) if ( log_exp )		\
    { Scierror("%s: arguments %d and %d have incompatible size\n",fname,pos1,pos2); \
      return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckSquare</NAME>
#define CheckSquare(fname,pos1,o1) if ( o1->m != o1->n ) \
   { Scierror("%s: arguments %d should be square\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckRows</NAME>
#define CheckRows(fname,pos1,o1,value) if ( o1->m != value ) \
   { Scierror("%s: arguments %d has an incorrect row dimension\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckCols</NAME>
#define CheckCols(fname,pos1,o1,value) if ( o1->n != value ) \
   { Scierror("%s: arguments %d has an incorrect col dimension\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckLength</NAME>
#define CheckLength(fname,pos1,o1,value) if ( o1->mn != value ) \
   { Scierror("%s: arguments %d should be of length %d\n",fname,pos1,value); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckScalar</NAME>
#define CheckScalar(fname,pos1,o1) if ( o1->mn != 1 ) \
   { Scierror("%s: arguments %d should be scalar\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckVector</NAME>
#define CheckVector(fname,pos1,o1) if ( o1->mn != 0 && o1->m != 1 && o1->n != 1 ) \
   { Scierror("%s: arguments %d should be a vector \n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckReal</NAME>
#define CheckReal(fname,pos,o1) if ( o1->rc_type != 'r' ) \
   { Scierror("%s: arguments %d should be a real matrix\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckComplex</NAME>
#define CheckComplex(fname,pos,o1) if ( o1->rc_type != 'r' ) \
   { Scierror("%s: arguments %d should be a complex  matrix\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<MACRO>
<NAME>CheckNonNegative</NAME>
#define CheckNonNegative(fname, k, pos1) if ( k < 0 ) \
   { Scierror("%s: argument %d must be non negative\n",fname,pos1); \
     return RET_BUG;} 
</MACRO>
<FUNCTION>
<NAME>call_interf</NAME>
<RETURNS>int </RETURNS>
function *f, Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>AllInterf</NAME>
<RETURNS>int </RETURNS>
int i, int num, Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<TYPEDEF>
<NAME>NspModuleElt</NAME>
typedef struct _NspModulelt NspModuleElt;
</TYPEDEF>
<STRUCT>
<NAME>NspTypeModuleElt</NAME>
typedef struct _NspTypeModuleElt { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeModuleElt;
</STRUCT>
<STRUCT>
<NAME>NspModulelt</NAME>
struct _NspModulelt {
  /*< private >*/
  NspObject father; 
  NspTypeModuleElt *type; 
  /*< public >*/
  char *path ;
  char *module;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_modulelt_id</NAME>
extern int nsp_type_modulelt_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_modulelt</NAME>
extern NspTypeModuleElt *nsp_type_modulelt;
</VARIABLE>
<FUNCTION>
<NAME>new_type_modulelt</NAME>
<RETURNS>NspTypeModuleElt *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_modulelt</NAME>
<RETURNS>NspModuleElt *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLME</NAME>
#define NULLME (NspModuleElt*) 0
</MACRO>
<FUNCTION>
<NAME>modulelt_create</NAME>
<RETURNS>NspModuleElt *</RETURNS>
char *name,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>modulelt_copy</NAME>
<RETURNS>NspModuleElt *</RETURNS>
NspModuleElt *H
</FUNCTION>
<FUNCTION>
<NAME>modulelt_destroy</NAME>
<RETURNS>void </RETURNS>
NspModuleElt *H
</FUNCTION>
<FUNCTION>
<NAME>modulelt_info</NAME>
<RETURNS>int </RETURNS>
NspModuleElt *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>modulelt_print</NAME>
<RETURNS>int </RETURNS>
NspModuleElt *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>modulelt_object</NAME>
<RETURNS>NspModuleElt *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsModuleEltObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsModuleElt</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetModuleEltCopy</NAME>
<RETURNS>NspModuleElt *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetModuleElt</NAME>
<RETURNS>NspModuleElt *</RETURNS>
Stack stack, int i
</FUNCTION>
<STRUCT>
<NAME>NspNone</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeNone</NAME>
typedef struct _NspTypeNone { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeNone;
</STRUCT>
<STRUCT>
<NAME>NspNone</NAME>
struct _NspNone {
  /*< private >*/
  NspObject father; 
  NspTypeNone *type; 
  /*< public >*/
  
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_none_id</NAME>
extern int nsp_type_none_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_none</NAME>
extern NspTypeNone *nsp_type_none;
</VARIABLE>
<FUNCTION>
<NAME>new_type_none</NAME>
<RETURNS>NspTypeNone *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_none</NAME>
<RETURNS>NspNone *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLNONE</NAME>
#define NULLNONE (NspNone*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_none_create</NAME>
<RETURNS>NspNone *</RETURNS>
char *name,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_none_copy</NAME>
<RETURNS>NspNone *</RETURNS>
NspNone *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_none_destroy</NAME>
<RETURNS>void </RETURNS>
NspNone *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_none_info</NAME>
<RETURNS>int </RETURNS>
NspNone *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_none_print</NAME>
<RETURNS>int </RETURNS>
NspNone *H, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_none_object</NAME>
<RETURNS>NspNone *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsNoneObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsNone</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetNoneCopy</NAME>
<RETURNS>NspNone *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetNone</NAME>
<RETURNS>NspNone *</RETURNS>
Stack stack, int i
</FUNCTION>
<VARIABLE>
<NAME>int_sprowmatrix_minus</NAME>
extern function int_sprowmatrix_minus;
</VARIABLE>
<STRUCT>
<NAME>NspCholmod</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeCholmod</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeCholmod</NAME>
struct _NspTypeCholmod {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>nsp_cholmod</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_cholmod</NAME>
struct _nsp_cholmod {
  cholmod_factor *L ;
  cholmod_common Common;
  int m,n;
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspCholmod</NAME>
struct _NspCholmod {
  /*< private >*/
  NspObject father;
  NspTypeCholmod*type;
  /*< public >*/
  nsp_cholmod *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_cholmod_id</NAME>
extern int nsp_type_cholmod_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_cholmod</NAME>
extern NspTypeCholmod *nsp_type_cholmod;
</VARIABLE>
<FUNCTION>
<NAME>new_type_cholmod</NAME>
<RETURNS>NspTypeCholmod *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_cholmod</NAME>
<RETURNS>NspCholmod *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLCHOLMOD</NAME>
#define NULLCHOLMOD (NspCholmod*) 0
</MACRO>
<FUNCTION>
<NAME>cholmod_create</NAME>
<RETURNS>NspCholmod *</RETURNS>
char *name,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholmod_copy</NAME>
<RETURNS>NspCholmod *</RETURNS>
NspCholmod *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholmod_destroy</NAME>
<RETURNS>void </RETURNS>
NspCholmod *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholmod_info</NAME>
<RETURNS>int </RETURNS>
NspCholmod *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholmod_print</NAME>
<RETURNS>int </RETURNS>
NspCholmod *Mat, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_cholmod_object</NAME>
<RETURNS>NspCholmod *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsCholmodObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsCholmod</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetCholmodCopy</NAME>
<RETURNS>NspCholmod *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetCholmod</NAME>
<RETURNS>NspCholmod *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>int_cholmod_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<STRUCT>
<NAME>NspScalExp</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeScalExp</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeScalExp</NAME>
struct _NspTypeScalExp {
  /*< private >*/
  NSP_TYPE_OBJECT__
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>NspScalExp</NAME>
struct _NspScalExp {
  /*< private >*/
  NspObject father;
  NspTypeScalExp*type;
  /*< public >*/
  PList code;
  NspSMatrix *expr;
  NspSMatrix *vars;
  NspSMatrix *extra_vars;
  NspMatrix *bcode;
  NspMatrix *values;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_scalexp_id</NAME>
extern int nsp_type_scalexp_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_scalexp</NAME>
extern NspTypeScalExp *nsp_type_scalexp;
</VARIABLE>
<FUNCTION>
<NAME>new_type_scalexp</NAME>
<RETURNS>NspTypeScalExp *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_scalexp</NAME>
<RETURNS>NspScalExp *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSCALEXP</NAME>
#define NULLSCALEXP (NspScalExp*) 0
</MACRO>
<FUNCTION>
<NAME>scalexp_create</NAME>
<RETURNS>NspScalExp *</RETURNS>
char *name,NspSMatrix *expr,NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalexp_copy</NAME>
<RETURNS>NspScalExp *</RETURNS>
NspScalExp *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalexp_destroy</NAME>
<RETURNS>void </RETURNS>
NspScalExp *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalexp_info</NAME>
<RETURNS>int </RETURNS>
NspScalExp *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalexp_print</NAME>
<RETURNS>int </RETURNS>
NspScalExp *M, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_scalexp_object</NAME>
<RETURNS>NspScalExp *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsScalExpObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsScalExp</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetScalExpCopy</NAME>
<RETURNS>NspScalExp *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetScalExp</NAME>
<RETURNS>NspScalExp *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>int_scalexp_create</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<ENUM>
<NAME>f_enum</NAME>
typedef enum { 
  f_sin, f_cos, f_tan, f_exp, f_log, f_sinh, f_cosh, f_tanh,
  f_int, f_round, f_ceil, f_floor, f_sign, f_abs, f_max, f_min,
  f_asin, f_acos, f_atan, f_asinh, f_acosh, f_atanh,
  f_atan2, f_log10, f_gamma
} f_enum;
</ENUM>
<STRUCT>
<NAME>expr_func</NAME>
</STRUCT>
<STRUCT>
<NAME>expr_func</NAME>
struct _expr_func {
  const char *name;
  f_enum id;
  double (*f1)(double);
  double (*f2)(double,double);
  int logical;
};
</STRUCT>
<STRUCT>
<NAME>NspTypeMatint</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeMatint</NAME>
struct _NspTypeMatint {
  NSP_TYPE_OBJECT__
  /* added */
  matint_redim *redim; 
  matint_resize *resize;
  matint_free_elt *free_elt;
  matint_elt_size *elt_size;
  matint_clone *clone;
  matint_copy_elt *copy_elt;
  matint_enlarge *enlarge;
  matint_canonic *canonic;
};
</STRUCT>
<MACRO>
<NAME>MAT_INT</NAME>
#define MAT_INT(t) ((NspTypeMatint *) t)
</MACRO>
<VARIABLE>
<NAME>nsp_type_matint_id</NAME>
extern int nsp_type_matint_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_matint</NAME>
extern NspTypeMatint *nsp_type_matint;
</VARIABLE>
<FUNCTION>
<NAME>new_type_matint</NAME>
<RETURNS>NspTypeMatint *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>matint_get_methods</NAME>
<RETURNS>NspMethods *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_tozero</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_delete_columns</NAME>
<RETURNS>int </RETURNS>
NspObject  *Obj, int *ind, int nb_elts, int cmin, int cmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_delete_rows</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj, int *ind, int nb_elts, int rmin, int rmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_delete_elements</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj, int *ind, int nb_elts, int rmin, int rmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_delete_elements2</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj,int *indrow, int nr, int rmin, int rmax,int *indcol, int nc, int cmin, int cmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_extract_elements1</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *Obj,NspObject *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_extract_columns1</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *Obj,NspObject *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_extract_rows1</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *Obj,NspObject *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_extract</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *Obj,const int *row, int nr, int rmin, int rmax,const int *col, int nc, int cmin, int cmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_extract1</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *Obj,NspObject *Rows, NspObject *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA,const int *row, int nr, int rmin, int rmax,const int *col, int nc, int cmin, int cmax,NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_set_elts</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA, const int *ind, int nb_elts, int imin, int imax, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_set_elts1</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA, NspObject *Elts, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_concat_right</NAME>
<RETURNS>NspObject *</RETURNS>
 NspObject *ObjA, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_concat_right_bis</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_repmat</NAME>
<RETURNS>NspObject *</RETURNS>
const NspObject *ObjA, int m, int n
</FUNCTION>
<USER_FUNCTION>
<NAME>Fconcat_d</NAME>
<RETURNS>NspObject *</RETURNS>
const NspObject *, const NspObject *
</USER_FUNCTION>
<FUNCTION>
<NAME>nsp_matint_concat_down</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *ObjA, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_redim</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_concat_down_bis</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_concat_diag</NAME>
<RETURNS>NspObject *</RETURNS>
 NspObject *ObjA, NspObject *ObjB
</FUNCTION>
<ENUM>
<NAME>matint_workid</NAME>
typedef enum { matint_iwork1=0, matint_iwork2=1} matint_workid;
</ENUM>
<FUNCTION>
<NAME>get_index_vector_from_object</NAME>
<RETURNS>int *</RETURNS>
NspObject *Obj, int *Nb_elts, int *Rmin, int *Rmax,matint_workid iwork
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_set_submatrix1</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA,NspObject *Row, NspObject *Col, NspObject *ObjB
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_perm_elem</NAME>
<RETURNS>int </RETURNS>
NspObject *ObjA, int p, int q, int dim_flag
</FUNCTION>
<FUNCTION>
<NAME>int_matint_cells_setrowscols</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_concat_diag</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_concat_down</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs, Fconcat_d F
</FUNCTION>
<FUNCTION>
<NAME>int_matint_concat_emptymat_and_mat</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_concatd</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_concatr</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_deletecols</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_deleteelts</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_deleteelts2</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_deleterows</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extract</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extractcols</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extractelts</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_extractrows</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_redim</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_repmat</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_resize2vect</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_setrowscols</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_matint_tozero</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_matint_canonic</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *obj
</FUNCTION>
<MACRO>
<NAME>Widget</NAME>
#define Widget int
</MACRO>
<ENUM>
<NAME>menu_answer</NAME>
typedef enum { menu_ok , menu_cancel, menu_fail, menu_bad_argument} menu_answer; 
</ENUM>
<FUNCTION>
<NAME>nsp_choose</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *Items,NspSMatrix *Title,NspSMatrix *button,int *nrep
</FUNCTION>
<FUNCTION>
<NAME>nsp_choose_</NAME>
<RETURNS>menu_answer </RETURNS>
const char *title,char **Items,int nItems,char **but_names,int n_but,int *choice
</FUNCTION>
<FUNCTION>
<NAME>nsp_message</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *Message,NspSMatrix *Buttons,int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_message_modeless</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *Message,NspSMatrix *Buttons
</FUNCTION>
<FUNCTION>
<NAME>nsp_message_</NAME>
<RETURNS>menu_answer </RETURNS>
char *message,char **buttons,int n_buttons,int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_message_modeless_</NAME>
<RETURNS>menu_answer </RETURNS>
char *message
</FUNCTION>
<FUNCTION>
<NAME>nsp_choices_with_combobox</NAME>
<RETURNS>menu_answer </RETURNS>
char *title,NspList *L,NspList **Res,int use_table
</FUNCTION>
<FUNCTION>
<NAME>nsp_print_dialog</NAME>
<RETURNS>int </RETURNS>
char **print_command,int *type,int *orientation,int *format
</FUNCTION>
<FUNCTION>
<NAME>nsp_export_dialog</NAME>
<RETURNS>int </RETURNS>
char **file,int *type,int *orientation,int *format
</FUNCTION>
<FUNCTION>
<NAME>nsp_dialog</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *title,NspSMatrix *init,NspObject **answer
</FUNCTION>
<FUNCTION>
<NAME>nsp_dialog1</NAME>
<RETURNS>menu_answer </RETURNS>
const char *title,const char *init,char **answer
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_file_window</NAME>
<RETURNS>menu_answer </RETURNS>
const char *title,const char *dirname,int action,char **file
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_filename_open</NAME>
<RETURNS>char *</RETURNS>
const char *title,const char *dirname,char **filters
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_filename_save</NAME>
<RETURNS>char *</RETURNS>
const char *title,const char *dirname
</FUNCTION>
<FUNCTION>
<NAME>nsp_multi_dialog_</NAME>
<RETURNS>menu_answer </RETURNS>
const char *title,char **pszTitle, char **pszName,int nv
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_dialog</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *Title,NspSMatrix *Labels_v,NspSMatrix *Labels_h,NspSMatrix *Init_matrix,int menu_type,int entry_size
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_set</NAME>
<RETURNS>void </RETURNS>
int win_num,const char *button_name,int ne
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_unset</NAME>
<RETURNS>void </RETURNS>
int win_num,const char *button_name,int ne
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_delete_button</NAME>
<RETURNS>int </RETURNS>
int win_num,const char *button_name
</FUNCTION>
<FUNCTION>
<NAME>nsp_menus_add</NAME>
<RETURNS>int </RETURNS>
int win_num,const char * button_name,char ** entries,int ne,int typ,char *fname
</FUNCTION>
<FUNCTION>
<NAME>nsp_gtkcombobox_colormap_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
 BCG *Xgc,int init_color
</FUNCTION>
<FUNCTION>
<NAME>gtkcombobox_select_color_in_table</NAME>
<RETURNS>int </RETURNS>
NspMatrix *table,int init_color
</FUNCTION>
<FUNCTION>
<NAME>gtkcombobox_select_color</NAME>
<RETURNS>int </RETURNS>
BCG *Xgc,int init_color
</FUNCTION>
<FUNCTION>
<NAME>nsp_multi_dialog</NAME>
<RETURNS>menu_answer </RETURNS>
NspSMatrix *Title,NspSMatrix *Labels,NspSMatrix *Init_values
</FUNCTION>
<FUNCTION>
<NAME>nsp_multi_dialog_</NAME>
<RETURNS>menu_answer </RETURNS>
const char *title,char **pszTitle, char **pszName,int nv
</FUNCTION>
<FUNCTION>
<NAME>nsp_dialogs_insert_title</NAME>
<RETURNS>void </RETURNS>
const char *title,GtkWidget *vbox
</FUNCTION>
<MACRO>
<NAME>ELT_TYPE</NAME>
#define ELT_TYPE double
</MACRO>
<MACRO>
<NAME>LOCK_DIR_FLAG</NAME>
#define LOCK_DIR_FLAG 0x0f 
</MACRO>
<MACRO>
<NAME>LOCK_TYPE_FLAG</NAME>
#define LOCK_TYPE_FLAG 0xf0
</MACRO>
<ENUM>
<NAME>lock_dir</NAME>
typedef  enum { LD_NORTH=0, LD_SOUTH=1, LD_EAST=2, LD_WEST=3, LD_ANY=4 } lock_dir;
</ENUM>
<ENUM>
<NAME>lock_type</NAME>
typedef  enum { L_IN=0 <<4 ,L_OUT=1 <<4 ,L_EVIN=2 << 4,L_EVOUT=3 <<4 , L_SQP=4 <<4, L_SQM=5 <<4  } lock_type;
</ENUM>
<STRUCT>
<NAME>gr_port</NAME>
</STRUCT>
<STRUCT>
<NAME>gr_port</NAME>
struct _gr_port {
  NspObject *object_id ; /* object connected to the associated port or NULL */  
  void *object_sid;      /* used to keep track of connections while copying or saving */
  int lock;              /* object is connected through his lock point lock */
  int port;              /* and port number port */
};
</STRUCT>
<STRUCT>
<NAME>NspTypeGRint</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeGRint</NAME>
struct _NspTypeGRint { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
  gr_get_hilited *get_hilited ;		     
  gr_set_hilited *set_hilited ;		     
  gr_get_show *get_show ;		     
  gr_set_show *set_show ;		     
  gr_draw *draw ;			     
  gr_translate *translate ;		     
  gr_set_pos *set_pos ;		     
  gr_resize *resize ;			     
  gr_update_locks *update_locks ;	     
  gr_contains_pt *contains_pt ;		     
  gr_control_near_pt *control_near_pt ;	     
  gr_lock_near_pt *lock_near_pt ;	     
  gr_move_control_init *move_control_init ;  
  gr_move_control *move_control ;	     

  gr_get_number_of_locks * get_number_of_locks;
  gr_get_number_of_ports * get_number_of_ports;
  gr_get_lock_connection * get_lock_connection;
  gr_get_lock_pos * get_lock_pos;
  gr_get_lock_dir * get_lock_dir;
  gr_set_lock_connection * set_lock_connection;
  gr_unset_lock_connection * unset_lock_connection;
  gr_is_lock_connectable * is_lock_connectable;
  gr_is_lock_connected * is_lock_connected;
  gr_set_lock_pos * set_lock_pos;
  gr_full_copy * full_copy;
  gr_unlock *unlock ; 
};
</STRUCT>
<MACRO>
<NAME>GR_INT</NAME>
#define GR_INT(t) ((NspTypeGRint *) t)
</MACRO>
<VARIABLE>
<NAME>nsp_type_grint_id</NAME>
extern int nsp_type_grint_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_grint</NAME>
extern NspTypeGRint *nsp_type_grint;
</VARIABLE>
<FUNCTION>
<NAME>new_type_grint</NAME>
<RETURNS>NspTypeGRint *</RETURNS>
type_mode mode
</FUNCTION>
<TYPEDEF>
<NAME>NspPMatrix</NAME>
typedef struct _NspPmatrix  NspPMatrix;
</TYPEDEF>
<STRUCT>
<NAME>NspTypePMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypePMatrix</NAME>
struct _NspTypePMatrix { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} ;
</STRUCT>
<TYPEDEF>
<NAME>nsp_polynom</NAME>
typedef NspMatrix * nsp_polynom;
</TYPEDEF>
<STRUCT>
<NAME>NspPmatrix</NAME>
struct _NspPmatrix {
  /*< private >*/
  NspObject father; 
  NspTypePMatrix *type; 
  /*< public >*/
  int m,n,mn;       /* matrix dimension (m,n,m*n) */
  nsp_polynom *S;     /* Each polynom is a Matrix **/
  char rc_type  ;   /* type 'r' or 'i' */
  char *var  ;   /* name of polynom variable */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_pmatrix_id</NAME>
extern int nsp_type_pmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_pmatrix</NAME>
extern NspTypePMatrix *nsp_type_pmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_pmatrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_pmatrix</NAME>
<RETURNS>NspTypePMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_pmatrix</NAME>
<RETURNS>NspPMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLPMAT</NAME>
#define NULLPMAT (NspPMatrix *) 0
</MACRO>
<MACRO>
<NAME>NULLPOLY</NAME>
#define NULLPOLY (nsp_polynom) 0
</MACRO>
<FUNCTION>
<NAME>nsp_pmatrix_object</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_length</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_pmatrix</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspMatrix *A, nsp_const_string str, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_polynom</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_concat_down</NAME>
<RETURNS>NspPMatrix *</RETURNS>
const NspPMatrix *A,const NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_copy</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_create</NAME>
<RETURNS>NspPMatrix *</RETURNS>
char *name, int m, int n, doubleC *cval, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_clone</NAME>
<RETURNS>NspPMatrix *</RETURNS>
char *name, NspPMatrix *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract_columns</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract_elements</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspMatrix *Elts, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_extract_rows</NAME>
<RETURNS>NspPMatrix *</RETURNS>
NspPMatrix *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_transpose</NAME>
<RETURNS>NspPMatrix *</RETURNS>
const NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_pcopy_polynom</NAME>
<RETURNS>int </RETURNS>
int n, nsp_polynom *s1, nsp_polynom *s2
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_add_columns</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_add_rows</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_concat_right</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A,const NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_redim</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_resize</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_set_rows</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, NspMatrix *Rows, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A,const NspMatrix *Rows,const NspMatrix *Cols,const NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_setrc</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspPMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pset_polynom</NAME>
<RETURNS>int </RETURNS>
int n, doubleC *s1, nsp_polynom *s2
</FUNCTION>
<FUNCTION>
<NAME>nsp_basic_to_polynom</NAME>
<RETURNS>nsp_polynom </RETURNS>
doubleC *d, char type
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_copy</NAME>
<RETURNS>nsp_polynom </RETURNS>
nsp_polynom P
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspPMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspPMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_info</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_print</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *Mat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_destroy</NAME>
<RETURNS>void </RETURNS>
nsp_polynom *P
</FUNCTION>
<FUNCTION>
<NAME>IsPMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsPMat</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetPMatCopy</NAME>
<RETURNS>NspPMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetPMat</NAME>
<RETURNS>NspPMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetPolynom</NAME>
<RETURNS>nsp_polynom </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>PMatCompOp</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspPMatrix *A, NspPMatrix *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>PMatFullComp</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *A, NspPMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_companion</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_polynom_roots</NAME>
<RETURNS>NspMatrix *</RETURNS>
nsp_polynom poly
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_size</NAME>
<RETURNS>int </RETURNS>
NspPMatrix *Mat, int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_type_as_string</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_type_short_string</NAME>
<RETURNS>char *</RETURNS>
NspObject *v
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_loop_extract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_eq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_pmatrix_neq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<STRUCT>
<NAME>NspObject</NAME>
</STRUCT>
<STRUCT>
<NAME>AttrTab</NAME>
</STRUCT>
<STRUCT>
<NAME>NspMethods</NAME>
</STRUCT>
<TYPEDEF>
<NAME>NspTypeId</NAME>
typedef unsigned int NspTypeId ;   
</TYPEDEF>
<STRUCT>
<NAME>NspTypeBase</NAME>
</STRUCT>
<MACRO>
<NAME>NSP_TYPE_OBJECT__</NAME>
#define NSP_TYPE_OBJECT__					      \
  NspTypeId id ;                      /* each type has a unique id */ \
  NspTypeBase *surtype;               /* type of parent */		\
  NspTypeBase *interface ;  	      /* chained types for interfaces */ \
  init_func *init ;		      /* initializer */			\
  new_func *newf ;		      /* allocations */			\
  AttrTab *attrs; 		      /* attribute table */		\
  attrs_func *get_attrs;	      /* get attribute wrapper */	\
  attrs_func *set_attrs;	      /* get attribute wrapper */	\
  methods_func *methods;	      /* methods */		
</MACRO>
<MACRO>
<NAME>NSP_TYPE_OBJECT__</NAME>
#define NSP_TYPE_OBJECT__					      \
  NspTypeId id ;                      /* each type has a unique id */ \
  NspTypeBase *surtype;               /* type of parent */		\
  NspTypeBase *interface ;  	      /* chained types for interfaces */ \
  init_func *init ;		      /* initializer */			\
  new_func *new ;		      /* allocations */			\
  AttrTab *attrs; 		      /* attribute table */		\
  attrs_func *get_attrs;	      /* get attribute wrapper */	\
  attrs_func *set_attrs;	      /* get attribute wrapper */	\
  methods_func *methods;	      /* methods */		
</MACRO>
<STRUCT>
<NAME>NspTypeBase</NAME>
struct _NspTypeBase {
  NSP_TYPE_OBJECT__ 
} ;
</STRUCT>
<STRUCT>
<NAME>NspTypeObject</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeObject</NAME>
struct _NspTypeObject {
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
  print_func *pr ;		      /* printing*/   
  dealloc_func *dealloc;              /* dealloc */  
  copy_func *copy ;                   /* copy object */  
  size_func *size ;                   /* m,n or m*n  */  
  s_type_func *s_type;                /* type as a String */  
  sh_type_func *sh_type;              /* type as a short string */  
  info_func *info;                    /* info */  
  set_name_func *set_name;            /* set name */  
  get_name_func *get_name;            /* get name */  
  is_true_func  *is_true;             /* check if object can be considered as true */  
  loop_func     *loop;                /* for loops */  
  path_func     *path_extract;        /* used for x(1)(2)(...) */  
  get_from_obj_func *get_from_obj;    /* get object stored in SciObj */  
  eq_func *eq ;                       /* equality check */  
  eq_func *neq ;                      /* non-equality check */
  save_func *save;                    /* file save */
  load_func *load;                    /* file load */
  create_func *create;	      	      /* creates a new object  */ 
  print_func *latex;                  /* print in latex syntax */
};
</STRUCT>
<MACRO>
<NAME>NSP_TYPE_OBJECT</NAME>
#define NSP_TYPE_OBJECT(t) ((NspTypeObject *) t) 
</MACRO>
<MACRO>
<NAME>NSP_TYPE_BASE</NAME>
#define NSP_TYPE_BASE(t) ((NspTypeBase *) t) 
</MACRO>
<FUNCTION>
<NAME>nsp_new_type_id</NAME>
<RETURNS>NspTypeId  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>registered_types</NAME>
</STRUCT>
<STRUCT>
<NAME>registered_types</NAME>
struct _registered_types {
  NspTypeObject  *type;
  struct _registered_types *next;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_types</NAME>
extern registered_types *nsp_types;
</VARIABLE>
<FUNCTION>
<NAME>nsp_register_type</NAME>
<RETURNS>int </RETURNS>
void *type
</FUNCTION>
<VARIABLE>
<NAME>nsp_no_type_id</NAME>
extern const int nsp_no_type_id; /* this can no be a type id : used in save/load */
</VARIABLE>
<FUNCTION>
<NAME>nsp_get_type_from_id</NAME>
<RETURNS>void *</RETURNS>
NspTypeId id
</FUNCTION>
<ENUM>
<NAME>type_mode</NAME>
typedef enum { T_BASE, T_DERIVED } type_mode;
</ENUM>
<STRUCT>
<NAME>NspObject</NAME>
struct  _NspObject {
  nsp_const_string name;	/* object name: must be first */
  NspTypeObject *type;
  NspTypeBase *basetype;        /* type of base child  */
  int  ret_pos ;                /* used to store return position from an interface */ 
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_object_id</NAME>
extern int nsp_type_object_id ;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_object</NAME>
extern NspTypeObject  *nsp_type_object;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_object_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<MACRO>
<NAME>NSP_OBJECT</NAME>
#define NSP_OBJECT(o) ((NspObject *) o) 
</MACRO>
<FUNCTION>
<NAME>new_type_object</NAME>
<RETURNS>NspTypeObject *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_object_set</NAME>
<RETURNS>void </RETURNS>
NspObject *o,NspTypeObject *type
</FUNCTION>
<FUNCTION>
<NAME>new_object</NAME>
<RETURNS>NspObject  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_object_init</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>check_cast</NAME>
<RETURNS>int </RETURNS>
void *obj,NspTypeId id
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_id_from_object</NAME>
<RETURNS>int </RETURNS>
NspObject *Obj
</FUNCTION>
<MACRO>
<NAME>NSP_OBJECT_INLINED</NAME>
#define NSP_OBJECT_INLINED static inline 
</MACRO>
<FUNCTION>
<NAME>check_implements</NAME>
<RETURNS>NspTypeBase *</RETURNS>
const void *obj,NspTypeId id
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_load_def</NAME>
<RETURNS>NspObject *</RETURNS>
void * F
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_save_def</NAME>
<RETURNS>int  </RETURNS>
void * F, NspObject * M
</FUNCTION>
<STRUCT>
<NAME>Stack</NAME>
</STRUCT>
<STRUCT>
<NAME>Stack_ref</NAME>
</STRUCT>
<STRUCT>
<NAME>Stack_ref</NAME>
struct _Stack_ref {
  NspObject **D;     /* D is dynamically changed so that D[1] is the first Objet used XXX **/
  NspObject **L;     /* Last position */
  NspObject **S;     /* points to the whole stack */
  NspObject *error_msg; 
  stack_error *error;
  int errcatch; 
  int pause; 
  NspObject *symbols; /* table of symbols of functions */
  char *current_exec_dir ; /* current exec directory */
} ;
</STRUCT>
<STRUCT>
<NAME>Stack</NAME>
struct _Stack {
  int first;   /* position of first argument to be used */
  const char *fname; /* function currently evaluated */
  Stack_ref *val;    /* this part is transmited by ref */
  char *file_name ; /*  function currently evaluated is in file_name */
} ;
</STRUCT>
<MACRO>
<NAME>STACK_SIZE</NAME>
#define STACK_SIZE 50000
</MACRO>
<VARIABLE>
<NAME>SciStack</NAME>
extern Stack SciStack ;
</VARIABLE>
<FUNCTION>
<NAME>StackInfo</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>InitStack</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_init_stack</NAME>
<RETURNS>void </RETURNS>
Stack *stack,NspObject **S
</FUNCTION>
<FUNCTION>
<NAME>int_get_failed</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *self, char *attr
</FUNCTION>
<FUNCTION>
<NAME>int_get_object_failed</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *self, char *attr
</FUNCTION>
<FUNCTION>
<NAME>int_set_failed</NAME>
<RETURNS>int </RETURNS>
NspObject *self,char *attr, NspObject *val
</FUNCTION>
<STRUCT>
<NAME>AttrTab</NAME>
struct _AttrTab {
  char *name;
  attr_get_function *get;
  attr_set_function *set;
  attr_get_object_function *get_object;
};
</STRUCT>
<FUNCTION>
<NAME>attr_search</NAME>
<RETURNS>int </RETURNS>
const char *key,AttrTab Table[]
</FUNCTION>
<FUNCTION>
<NAME>int_check_attr</NAME>
<RETURNS>int </RETURNS>
char *key,AttrTab attrs[],Stack stack,int rhs,int opt,int lhs
</FUNCTION>
<FUNCTION>
<NAME>attrs_to_stack</NAME>
<RETURNS>int </RETURNS>
char *key,AttrTab attrs[],Stack stack,int pos
</FUNCTION>
<FUNCTION>
<NAME>set_attribute_util</NAME>
<RETURNS>int </RETURNS>
NspObject *ob, NspTypeBase *type, char *attr,NspObject *val
</FUNCTION>
<FUNCTION>
<NAME>int_set_attribute</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_set_attributes</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_set_attributes1</NAME>
<RETURNS>int </RETURNS>
void *Ob,Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>int_create_with_attributes</NAME>
<RETURNS>int </RETURNS>
NspObject *ob,Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_attribute_util</NAME>
<RETURNS>int </RETURNS>
NspObject *ob, NspTypeBase *type,const char *attr,NspObject *val
</FUNCTION>
<FUNCTION>
<NAME>int_get_attribute</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_attribute_util</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *ob,NspTypeBase *type,char *attr
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_attribute_object</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *ob,NspTypeBase *type, char *attr
</FUNCTION>
<FUNCTION>
<NAME>object_path_extract</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *a,int n, NspObject **ob
</FUNCTION>
<STRUCT>
<NAME>NspMethods</NAME>
struct _NspMethods {
  char *name;
  nsp_method *meth; 
};
</STRUCT>
<FUNCTION>
<NAME>method_search</NAME>
<RETURNS>int </RETURNS>
char *key, NspMethods *Table
</FUNCTION>
<FUNCTION>
<NAME>nsp_exec_method_util</NAME>
<RETURNS>int </RETURNS>
NspObject *ob,NspTypeBase *type,char *method, Stack stack, int rhs, int opt, int lhs
</FUNCTION>
<FUNCTION>
<NAME>ArgMessage</NAME>
<RETURNS>void </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>MaybeObjCopy</NAME>
<RETURNS>void *</RETURNS>
NspObject **Obj
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_search_object</NAME>
<RETURNS>NspObject *</RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_void_object_destroy</NAME>
<RETURNS>void </RETURNS>
NspObject **O
</FUNCTION>
<MACRO>
<NAME>Ocheckname</NAME>
#define Ocheckname(x,y) ( strcmp( NSP_OBJECT(x)->name,y)==0 ) 
</MACRO>
<FUNCTION>
<NAME>nsp_object_xdr_save</NAME>
<RETURNS>int </RETURNS>
XDR *F, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_xdr_load</NAME>
<RETURNS>NspObject *</RETURNS>
XDR *F
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_destroy</NAME>
<RETURNS>void </RETURNS>
NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_void_object_destroy</NAME>
<RETURNS>void </RETURNS>
NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_copy</NAME>
<RETURNS>NspObject *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_get_size</NAME>
<RETURNS>int </RETURNS>
const NspObject *O, int j
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_copy_with_name</NAME>
<RETURNS>NspObject *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_copy_and_name</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name, NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_type_as_string</NAME>
<RETURNS>char *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_type_short</NAME>
<RETURNS>char *</RETURNS>
 NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_type</NAME>
<RETURNS>int </RETURNS>
const NspObject *O, NspTypeId id
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_implements</NAME>
<RETURNS>int </RETURNS>
NspObject *O, NspTypeId id
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_info</NAME>
<RETURNS>int </RETURNS>
NspObject *O, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_print</NAME>
<RETURNS>int </RETURNS>
NspObject *O, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_latex</NAME>
<RETURNS>void </RETURNS>
NspObject *O, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_is_true</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_loop_extract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>def_loop</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_object</NAME>
<RETURNS>NspObject *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_object_copy</NAME>
<RETURNS>NspObject *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_double</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name, double dval
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_complex</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,const doubleC *d
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_int</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name, int ival
</FUNCTION>
<FUNCTION>
<NAME>nsp_complexi_object_</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_str</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_str_and_size</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,const char *str, int lstr
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_object_from_doubles</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,int m, int n,double *rtab, double *itab
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_empty_matrix_object</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_true_object</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_boolean_object</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name,int val
</FUNCTION>
<FUNCTION>
<NAME>nsp_create_false_object</NAME>
<RETURNS>NspObject *</RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_get_name</NAME>
<RETURNS>const char *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_set_name</NAME>
<RETURNS>int </RETURNS>
NspObject *O,const char *str
</FUNCTION>
<FUNCTION>
<NAME>print_count_rows</NAME>
<RETURNS>int </RETURNS>
Stack stack,int first_arg,int last_arg
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_set_initial_name</NAME>
<RETURNS>const char *</RETURNS>
NspObject *ob,const char *name
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_destroy_name</NAME>
<RETURNS>void </RETURNS>
NspObject *ob
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_short_string_from_id</NAME>
<RETURNS>const char *</RETURNS>
int id
</FUNCTION>
<STRUCT>
<NAME>NspHobj</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeHobj</NAME>
typedef struct _NspTypeHobj { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeHobj;
</STRUCT>
<STRUCT>
<NAME>NspHobj</NAME>
struct _NspHobj {
  /*< private >*/
  NspObject father; 
  NspTypeHobj *type; 
  /*< public >*/
  char htype  ;   /* 'o' : optional argument 
		  * 'h' : handler 
		  * 'g' : global variable pointer 
		  */
  NspObject *O;        /* pointed object */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_hobj_id</NAME>
extern int nsp_type_hobj_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_hobj</NAME>
extern NspTypeHobj *nsp_type_hobj;
</VARIABLE>
<FUNCTION>
<NAME>new_type_hobj</NAME>
<RETURNS>NspTypeHobj *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_hobj</NAME>
<RETURNS>NspHobj *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLHOBJ</NAME>
#define NULLHOBJ (NspHobj *) 0
</MACRO>
<MACRO>
<NAME>NULLHOPT</NAME>
#define NULLHOPT (NspHobj *) 0
</MACRO>
<FUNCTION>
<NAME>HobjCreate</NAME>
<RETURNS>NspHobj *</RETURNS>
const char *name,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>HoptCreate</NAME>
<RETURNS>NspHobj *</RETURNS>
const char *name,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GobjCreate</NAME>
<RETURNS>NspHobj *</RETURNS>
const char *name,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_copy</NAME>
<RETURNS>NspHobj *</RETURNS>
NspHobj *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_destroy</NAME>
<RETURNS>void </RETURNS>
NspHobj *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_info</NAME>
<RETURNS>int </RETURNS>
NspHobj *H,int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_print</NAME>
<RETURNS>int </RETURNS>
NspHobj *H,int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>IsHobj</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsHopt</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_hobj_object</NAME>
<RETURNS>NspHobj  *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsGlobal</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<MACRO>
<NAME>HOBJ_GET_OBJECT</NAME>
#define HOBJ_GET_OBJECT(Obj,rep)					\
  if (check_cast (Obj, nsp_type_hobj_id) == TRUE)			\
    {									\
      if (((NspHobj *)Obj)->htype != 'g') Obj = ((NspHobj *) Obj)->O;	\
      else {								\
	if ((Obj= nsp_global_frame_search_object(NSP_OBJECT(Obj)->name)) == NULLOBJ) \
	  {								\
	    Scierror("Pointer to a global non existant variable\n");	\
	    return rep;							\
	  }								\
      }									\
    } 
</MACRO>
<TYPEDEF>
<NAME>NspIVect</NAME>
typedef struct _NspIvect  NspIVect;
</TYPEDEF>
<STRUCT>
<NAME>NspTypeIVect</NAME>
typedef struct _NspTypeIVect { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeIVect;
</STRUCT>
<STRUCT>
<NAME>NspIvect</NAME>
struct _NspIvect {
  /*< private >*/
  NspObject father; 
  NspTypeIVect *type; 
  /*< public >*/
  double first,step,last ; /* implicit bounds  */
  int flag ;               /* set to 1 if 1:$ or : else set to 0 */
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_ivect_id</NAME>
extern int nsp_type_ivect_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_ivect</NAME>
extern NspTypeIVect *nsp_type_ivect;
</VARIABLE>
<FUNCTION>
<NAME>new_type_ivect</NAME>
<RETURNS>NspTypeIVect *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_ivect</NAME>
<RETURNS>NspIVect *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLIVECT</NAME>
#define NULLIVECT (NspIVect*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_ivect_object</NAME>
<RETURNS>NspIVect *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_create</NAME>
<RETURNS>NspIVect *</RETURNS>
char *name, double first, double step, double last, int flag
</FUNCTION>
<FUNCTION>
<NAME>IsIVectF</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_copy</NAME>
<RETURNS>NspIVect *</RETURNS>
NspIVect *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_destroy</NAME>
<RETURNS>void </RETURNS>
NspIVect *IV
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_info</NAME>
<RETURNS>int </RETURNS>
NspIVect *IV, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_print</NAME>
<RETURNS>int </RETURNS>
NspIVect *IV, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_ivect_2_mat</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspIVect *IV
</FUNCTION>
<FUNCTION>
<NAME>IsIVect</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<TYPEDEF>
<NAME>NspSpRowMatrix</NAME>
typedef struct _NspSpRowmatrix NspSpRowMatrix;
</TYPEDEF>
<STRUCT>
<NAME>NspTypeSpRowMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSpRowMatrix</NAME>
struct _NspTypeSpRowMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<TYPEDEF>
<NAME>SpRow</NAME>
typedef struct _sprow  SpRow ;
</TYPEDEF>
<STRUCT>
<NAME>sprow</NAME>
struct _sprow {
  int size,iw ; /* size of a row, iw : used for working storage*/
  int *J   ; /* pointer to an int array giving the columns or row i 
		in increasing order */
  union { 
    double *R;     /* Pointer on real values */
    doubleC *C;    /* Pointer on complex values */
    int *I;        /* Pointer on integer values */
  };
};
</STRUCT>
<STRUCT>
<NAME>NspSpRowmatrix</NAME>
struct _NspSpRowmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeSpRowMatrix *type; 
  /*< public >*/
  char rc_type;        /* 'r' or 'i' : real or complex matrix */
  int n,m,mn;   /* mn should be removed since m*n can be bigger than int 
		 * Warning: the order n,m should be the inverse to the 
		 * one implemented in _NspSpColmatrix. Thus we can cast 
		 * from _NspSpColmatrix to _NspSpRowmatrix
		 */
  SpRow **D; /* array of size m giving the Rows datas */
  char convert; /* 't' : the matrix is stored in triplet , 'n': triplet not used   */
  nsp_sparse_triplet triplet; 
} ;
</STRUCT>
<VARIABLE>
<NAME>nsp_type_sprowmatrix_id</NAME>
extern int nsp_type_sprowmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_sprowmatrix</NAME>
extern NspTypeSpRowMatrix *nsp_type_sprowmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_sprowmatrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_sprowmatrix</NAME>
<RETURNS>NspTypeSpRowMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_sprowmatrix</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSPROW</NAME>
#define NULLSPROW (  NspSpRowMatrix *) 0
</MACRO>
<FUNCTION>
<NAME>SpRowObj</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSpRowMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSpRowMat</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSpRowCopy</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSpRow</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealSpRow</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_row_destroy</NAME>
<RETURNS>void </RETURNS>
SpRow *Row
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_nnz</NAME>
<RETURNS>int </RETURNS>
const NspSpRowMatrix *HMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_info</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *Sp, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_print</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *Sp, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_copy</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_object</NAME>
<RETURNS>NspSpRowMatrix   *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_create</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
char *name, char type, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sparse</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
char *name,NspMatrix *RC, NspMatrix *Values, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_get</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspMatrix **RC, NspMatrix **Values
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_resize_row</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *Sp, int i, int n
</FUNCTION>
<FUNCTION>
<NAME>SpRowRowDestroy</NAME>
<RETURNS>void </RETURNS>
SpRow *Row
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_redim</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_enlarge_rows</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *Sp, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_concatr</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_concatd</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_concatdiag</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_store</NAME>
<RETURNS>void  </RETURNS>
NspSpRowMatrix *A, int r, int c, int col, NspSpRowMatrix *B, int r1, int c1
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_insert_elt</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int i, int j, NspSpRowMatrix *B, int rb, int cb
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_delete_elt</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int row, int col, int amin, int amax
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_get_elt</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *B, int i, int j
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_set_rowcol</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_set_row</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspMatrix *Inds, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_delete_cols</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_compress_row</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_compress_row_simple</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_delete_rows</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_extract</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_extract_elts</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_extract_cols</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_extract_rows</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_diag_extract</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_diag_set</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_diag_create</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mult</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mult_sp_m</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A, NspMatrix *X
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mult_m_sp</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *X,NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mult_scal</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_complexify</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_setr</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_seti</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_from_mat</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_to_mat</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *Sp
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_transpose</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
const NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_add</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sub</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_multtt</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mult_scal</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_op_scal</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B, int *flag, char op
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_clean</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int rhs, double epsa, double epsr
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_maximinitt_g</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B, int flag, int minmaxflag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_maxitt</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B, int flag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_minitt</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, NspSpRowMatrix *B, int flag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_triu</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A,int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_tril</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A,int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_ones</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_eye</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_zeros</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_realpart</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_imagpart</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_isreal</NAME>
<RETURNS>int </RETURNS>
const NspSpRowMatrix *A, int strict
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sum</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_maxi</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, char *flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_mini</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
NspSpRowMatrix *A, char *flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_eye</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_ones</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_zeros</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_acos</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_acosh</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_asin</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_asinh</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_atan</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_atanh</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_ceil</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_int</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_floor</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_round</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sign</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_tan</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_tanh</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_abs</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_erf</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_arg</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_conj</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_cos</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_cosh</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_expel</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_logel</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sin</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sinh</NAME>
<RETURNS>void </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_sqrtel</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_minus</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_find</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *A, int lhs, NspMatrix **Res1, NspMatrix **Res2
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprowmatrix_rand</NAME>
<RETURNS>NspSpRowMatrix *</RETURNS>
int m,int n,double sparsity,char crand
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprow_update_from_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprow_set_triplet_from_m</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *M,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprow_alloc_col_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *M,int nzmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_sprow_realloc_col_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpRowMatrix *M,int nzmax
</FUNCTION>
<MACRO>
<NAME>ELT_TYPE</NAME>
#define ELT_TYPE int 
</MACRO>
<MACRO>
<NAME>XCNAME</NAME>
#define XCNAME(x,y) CNAME(x,y)
</MACRO>
<FUNCTION>
<NAME>sizeof</NAME>
<RETURNS>n*</RETURNS>
ELT_TYPE),n*sizeof(int),(dir == 'i' ) ? XCNAME(compareC,ELT_TYPE):XCNAME(compareD,ELT_TYPE),XCNAME(swapcode,ELT_TYPE),swapcodeind
</FUNCTION>
<FUNCTION>
<NAME>sizeof</NAME>
<RETURNS>n*</RETURNS>
ELT_TYPE),sizeof(int),(dir == 'i' ) ? XCNAME(LexiColcompareC,ELT_TYPE):XCNAME(LexiColcompareD,ELT_TYPE),XCNAME(LexiColswapcode,ELT_TYPE),swapcodeind
</FUNCTION>
<FUNCTION>
<NAME>update_exec_dir</NAME>
<RETURNS>void </RETURNS>
char *filename,char *exec_dir,char *filename_exec,unsigned int length
</FUNCTION>
<FUNCTION>
<NAME>update_exec_dir_from_dir</NAME>
<RETURNS>void </RETURNS>
char *dirname,char *exec_dir,unsigned int length
</FUNCTION>
<FUNCTION>
<NAME>nsp_expand_file_with_exec_dir</NAME>
<RETURNS>void </RETURNS>
Stack *stack,char *filename,char *filename_exec
</FUNCTION>
<FUNCTION>
<NAME>nsp_expand_file_and_update_exec_dir</NAME>
<RETURNS>void </RETURNS>
Stack *stack,char *old,char *filename,char *filename_exec
</FUNCTION>
<FUNCTION>
<NAME>nsp_reset_exec_dir</NAME>
<RETURNS>void </RETURNS>
Stack *stack,char *old
</FUNCTION>
<FUNCTION>
<NAME>nsp_expand_dir_and_update_exec_dir</NAME>
<RETURNS>void </RETURNS>
Stack *stack,char *old,char *dirname,char *dirname_exec
</FUNCTION>
<STRUCT>
<NAME>NspMod</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeMod</NAME>
typedef struct _NspTypeMod { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeMod;
</STRUCT>
<TYPEDEF>
<NAME>Lmo</NAME>
typedef NspList Lmo ; /* Lmo is a List */
</TYPEDEF>
<STRUCT>
<NAME>NspMod</NAME>
struct _NspMod {
  /*< private >*/
  NspObject father; 
  NspTypeMod *type; 
  /*< public >*/
  char *path;   /* absolute XXX path of the module */ 
  char *mname;  /* module name */ 
  NspHash *T;      /* hash table to store module objects of type me 
		   (module elts) */
  Lmo *L;       /* List of submodules */
  int flag;     /* are we a copy ? */ 
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_mod_id</NAME>
extern int nsp_type_mod_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_mod</NAME>
extern NspTypeMod *nsp_type_mod;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_mod_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_mod</NAME>
<RETURNS>NspTypeMod *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_mod</NAME>
<RETURNS>NspMod *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>ModSize</NAME>
<RETURNS>int </RETURNS>
NspMod *Mat, int flag
</FUNCTION>
<FUNCTION>
<NAME>ModType</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ModShType</NAME>
<RETURNS>char *</RETURNS>
NspMod *M
</FUNCTION>
<FUNCTION>
<NAME>ModLoopExtract</NAME>
<RETURNS>NspObject *</RETURNS>
char *str, NspObject *O, NspObject *O1, int i, int *rep
</FUNCTION>
<FUNCTION>
<NAME>ModObjEq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<FUNCTION>
<NAME>ModObjNeq</NAME>
<RETURNS>int </RETURNS>
NspObject *A,NspObject *B
</FUNCTION>
<MACRO>
<NAME>NULLMOD</NAME>
#define NULLMOD (NspMod *) 0
</MACRO>
<FUNCTION>
<NAME>ModFullComp</NAME>
<RETURNS>int </RETURNS>
NspMod * A,NspMod * B,char *op,int *err
</FUNCTION>
<FUNCTION>
<NAME>ModCreate</NAME>
<RETURNS>NspMod *</RETURNS>
char *name,char *dir,char *mname
</FUNCTION>
<FUNCTION>
<NAME>ModCopy</NAME>
<RETURNS>NspMod *</RETURNS>
NspMod *H
</FUNCTION>
<FUNCTION>
<NAME>ModDestroy</NAME>
<RETURNS>void </RETURNS>
NspMod *H
</FUNCTION>
<FUNCTION>
<NAME>ModInfo</NAME>
<RETURNS>void </RETURNS>
NspMod *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>ModPrint</NAME>
<RETURNS>void </RETURNS>
NspMod *H,int indent
</FUNCTION>
<FUNCTION>
<NAME>ModEnter</NAME>
<RETURNS>int </RETURNS>
NspMod *H,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>ModEnterCopy</NAME>
<RETURNS>int </RETURNS>
NspMod *H,NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>ModDelete</NAME>
<RETURNS>void </RETURNS>
NspMod *H,char *str
</FUNCTION>
<FUNCTION>
<NAME>ModFind</NAME>
<RETURNS>int </RETURNS>
NspMod *H,char *str,NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>ModFindCopy</NAME>
<RETURNS>int </RETURNS>
NspMod *H,char *str,NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>ModMerge</NAME>
<RETURNS>int </RETURNS>
NspMod *H1,NspMod*H2
</FUNCTION>
<FUNCTION>
<NAME>ModNextObj</NAME>
<RETURNS>int </RETURNS>
NspMod *H,int *i,  NspObject **O
</FUNCTION>
<FUNCTION>
<NAME>ModFill</NAME>
<RETURNS>int </RETURNS>
NspMod *Mo
</FUNCTION>
<MACRO>
<NAME>STRING_ONLY</NAME>
#define STRING_ONLY 
</MACRO>
<MACRO>
<NAME>ELT_TYPE</NAME>
#define ELT_TYPE nsp_string
</MACRO>
<FUNCTION>
<NAME>nsp_qsort</NAME>
<RETURNS>void </RETURNS>
char *a, char *tab,int flag, int n, int es, int es1,int (*cmp) (), int (*swapcode) (), int (*swapcodeind) ()
</FUNCTION>
<MACRO>
<NAME>swapcodeind</NAME>
#define swapcodeind CNAME(swapcode,int)
</MACRO>
<USER_FUNCTION>
<NAME>IOVFun</NAME>
<RETURNS>int </RETURNS>
const char *fmt, va_list ap
</USER_FUNCTION>
<FUNCTION>
<NAME>SetScilabIO</NAME>
<RETURNS>IOVFun </RETURNS>
IOVFun F
</FUNCTION>
<FUNCTION>
<NAME>Sciprintf1</NAME>
<RETURNS>int </RETURNS>
int indent,const char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>Sciprintf</NAME>
<RETURNS>int </RETURNS>
const char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>Sciprint2string_reset</NAME>
<RETURNS>NspObject *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>Sciprint2string</NAME>
<RETURNS>int  </RETURNS>
const char *fmt, va_list ap
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_set_diary</NAME>
<RETURNS>FILE *</RETURNS>
FILE *f,int diary_echo
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_diary_on</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_diary</NAME>
<RETURNS>int </RETURNS>
const char *fmt, va_list ap
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_diary_only</NAME>
<RETURNS>int </RETURNS>
const char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>Sciprint_file</NAME>
<RETURNS>FILE *</RETURNS>
FILE *f
</FUNCTION>
<FUNCTION>
<NAME>Sciprint2file</NAME>
<RETURNS>int </RETURNS>
const char *fmt, va_list ap
</FUNCTION>
<TYPEDEF>
<NAME>IOFun</NAME>
typedef iofun *IOFun;
</TYPEDEF>
<USER_FUNCTION>
<NAME>IOFun1</NAME>
<RETURNS>int </RETURNS>
int indent,const char *fmt,...
</USER_FUNCTION>
<VARIABLE>
<NAME>Scierror</NAME>
extern iofun Scierror ;
</VARIABLE>
<FUNCTION>
<NAME>ParseError</NAME>
<RETURNS>int  </RETURNS>
char *fmt,...
</FUNCTION>
<FUNCTION>
<NAME>scidebug</NAME>
<RETURNS>int </RETURNS>
int indent,char *fmt,...
</FUNCTION>
<USER_FUNCTION>
<NAME>IOFun2</NAME>
<RETURNS>int </RETURNS>
FILE *f,const char *fmt,...
</USER_FUNCTION>
<VARIABLE>
<NAME>Scifprintf</NAME>
extern IOFun2 Scifprintf ;
</VARIABLE>
<USER_FUNCTION>
<NAME>SciGetC</NAME>
<RETURNS>int </RETURNS>
void
</USER_FUNCTION>
<VARIABLE>
<NAME>Scigetchar</NAME>
extern SciGetC Scigetchar ;
</VARIABLE>
<FUNCTION>
<NAME>nsp_set_nsp_getchar</NAME>
<RETURNS>SciGetC </RETURNS>
SciGetC F
</FUNCTION>
<FUNCTION>
<NAME>SciReadClean</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_readline_clear_line</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>set_echo_mode</NAME>
<RETURNS>void </RETURNS>
int mode
</FUNCTION>
<FUNCTION>
<NAME>get_echo_mode</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>set_is_reading</NAME>
<RETURNS>void </RETURNS>
int mode
</FUNCTION>
<FUNCTION>
<NAME>get_is_reading</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_error_message_show</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_error_message_to_lasterror</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_error_message_clear</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_set_echo_input_line</NAME>
<RETURNS>int </RETURNS>
int val
</FUNCTION>
<FUNCTION>
<NAME>nsp_get_echo_input_line</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>nsp_error_vprintf</NAME>
extern IOVFun nsp_error_vprintf;
</VARIABLE>
<FUNCTION>
<NAME>sci_get_screen_size</NAME>
<RETURNS>void </RETURNS>
int *rows, int *cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_intialize_reader</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_from_texmacs</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>NspSpColMatrix</NAME>
typedef struct _NspSpColmatrix NspSpColMatrix;
</TYPEDEF>
<STRUCT>
<NAME>NspTypeSpColMatrix</NAME>
typedef struct _NspTypeSpColMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeSpColMatrix;
</STRUCT>
<TYPEDEF>
<NAME>SpCol</NAME>
typedef struct _spcol SpCol ;
</TYPEDEF>
<STRUCT>
<NAME>spcol</NAME>
struct _spcol {
  int size,iw ; /* size of a row, iw : used for working storage*/
  int *J   ; /* pointer to an int array giving the columns or row i 
		in increasing order */
  union { 
    double *R;     /* Pointer on real values */
    doubleC *C;    /* Pointer on complex values */
    int *I;        /* Pointer on integer values */
  };
} ;
</STRUCT>
<STRUCT>
<NAME>NspSpColmatrix</NAME>
struct _NspSpColmatrix {
  /*< private >*/
  NspObject father; 
  NspTypeSpColMatrix *type; 
  /*< public >*/
  char rc_type;        /* 'r' or 'i' : real or complex matrix */
  int m,n,mn;   /* mn should be removed since m*n can be bigger than int */
  SpCol **D; /* array of size m giving the Rows datas */
  char convert; /* 't' : the matrix is stored in triplet , 'n': triplet not used   */
  nsp_sparse_triplet triplet; 
} ;
</STRUCT>
<VARIABLE>
<NAME>nsp_type_spcolmatrix_id</NAME>
extern int nsp_type_spcolmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_spcolmatrix</NAME>
extern NspTypeSpColMatrix *nsp_type_spcolmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_spcolmatrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_spcolmatrix</NAME>
<RETURNS>NspTypeSpColMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_spcolmatrix</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSPCOL</NAME>
#define NULLSPCOL (  NspSpColMatrix *) 0
</MACRO>
<FUNCTION>
<NAME>SpColObj</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSpColMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSpColMat</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSpColCopy</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSpCol</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetRealSpCol</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *Mat
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_col_destroy</NAME>
<RETURNS>void </RETURNS>
SpCol *Col
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_nnz</NAME>
<RETURNS>int </RETURNS>
const NspSpColMatrix *HMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_info</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *Sp, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_print</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *Sp, int indent,char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_copy</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_object</NAME>
<RETURNS>NspSpColMatrix   *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_create</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
char *name, char type, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sparse</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
char *name,NspMatrix *RC, NspMatrix *Values, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_get</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspMatrix **RC, NspMatrix **Values
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_resize_col</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *Sp, int i, int n
</FUNCTION>
<FUNCTION>
<NAME>SpColRowDestroy</NAME>
<RETURNS>void </RETURNS>
SpCol *Row
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_redim</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_enlarge_cols</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *Sp, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_concatr</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_concatd</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_concatdiag</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_store</NAME>
<RETURNS>void  </RETURNS>
NspSpColMatrix *A, int r, int c, int col, NspSpColMatrix *B, int r1, int c1
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_insert_elt</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int i, int j, NspSpColMatrix *B, int rb, int cb
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_delete_elt</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int row, int col, int amin, int amax
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_get_elt</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *B, int i, int j
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_set_rowcol</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_set_row</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspMatrix *Inds, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_delete_cols</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_compress_col</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_compress_col_simple</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_delete_rows</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_extract</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_extract_elts</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_extract_cols</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspMatrix *Cols, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_extract_rows</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspMatrix *Rows, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_diag_extract</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_diag_set</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_diag_create</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult_sp_m</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A, NspMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult_m_sp</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspMatrix *X,NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult_scalar</NAME>
<RETURNS>int </RETURNS>
double *val, char val_type, NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult_scal</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_complexify</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_setr</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_seti</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, double d
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_from_mat</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_from_mat_transpose</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_to_mat</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *Sp
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_to_mat_transpose</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *Sp
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_transpose</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
const NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_add</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sub</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_multtt</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_divel</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_and</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_or</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mult_scal</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_op_scal</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B, int *flag, char op
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_clean</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int rhs, double epsa, double epsr
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_maximinitt_g</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B, int flag, int minmaxflag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_maxitt</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B, int flag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_minitt</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B, int flag, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_triu</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A,int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_tril</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A,int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_ones</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_spones</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_eye</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_zeros</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_realpart</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_imagpart</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_isreal</NAME>
<RETURNS>int </RETURNS>
const NspSpColMatrix *A, int strict
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sum</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, char *flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_maxi</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, char *flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_mini</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, char *flag, NspMatrix **Imax, int lhs
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_eye</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_ones</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_zeros</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_acos</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_acosh</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_asin</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_asinh</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_atan</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_atanh</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_ceil</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_int</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_floor</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_round</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sign</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_tan</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_tanh</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_abs</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_erf</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_arg</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_conj</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_cos</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_cosh</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_expel</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_logel</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sin</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sinh</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_sqrtel</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_minus</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_find</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, int lhs, NspMatrix **Res1, NspMatrix **Res2
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_rand</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
int m,int n,double sparsity,char crand
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcol_update_from_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcol_set_triplet_from_m</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *M,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcol_alloc_col_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *M,int nzmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcol_realloc_col_triplet</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *M,int nzmax
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcol_free_triplet</NAME>
<RETURNS>void </RETURNS>
NspSpColMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_norm</NAME>
<RETURNS>double </RETURNS>
NspSpColMatrix *A, char c
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_vnorm</NAME>
<RETURNS>double </RETURNS>
NspSpColMatrix *A, double p
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_div_scal_tt</NAME>
<RETURNS>int </RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_div_zero_tt</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_scal_div_tt</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A, NspSpColMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_isnan</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A,int flag
</FUNCTION>
<FUNCTION>
<NAME>nsp_spcolmatrix_isinf</NAME>
<RETURNS>NspSpColMatrix *</RETURNS>
NspSpColMatrix *A,int flag
</FUNCTION>
<ENUM>
<NAME>nsp_print_mode</NAME>
typedef enum { print_std, print_latex, print_latextab } nsp_print_mode;
</ENUM>
<STRUCT>
<NAME>user_preferences</NAME>
</STRUCT>
<STRUCT>
<NAME>user_preferences</NAME>
struct _user_preferences
{
  int output_max_field_width;	/* */
  int output_precision;		/* */
  int split_long_rows;		/* */
  int print_empty_dimensions;	/* */
  int pr_as_read_syntax;	/* print in read syntax */
  int pr_depth ;        /* stop printing at given depth for recursive objects */
  int list_as_tree;     /* flag for list display */
  nsp_print_mode mode;  /* std, latex or latex tables */
  int active ;          /* only print if active is true */
};
</STRUCT>
<VARIABLE>
<NAME>user_pref</NAME>
extern user_preferences user_pref;
</VARIABLE>
<FUNCTION>
<NAME>nsp_abs_c</NAME>
<RETURNS>double </RETURNS>
const  doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_arg_c</NAME>
<RETURNS>double </RETURNS>
 const doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_polar_c</NAME>
<RETURNS>void </RETURNS>
 double r,double t,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_conj_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_norm_c</NAME>
<RETURNS>double </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_cos_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_cosh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_exp_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_log_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_di</NAME>
<RETURNS>double </RETURNS>
double x, int p
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_cc</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,const doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_cd</NAME>
<RETURNS>void </RETURNS>
 const doubleC *x, double y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_cd_or_ci</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x, double y, doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_dc</NAME>
<RETURNS>void </RETURNS>
 double x, const doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_pow_ci</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x, int p,doubleC *y
</FUNCTION>
<FUNCTION>
<NAME>nsp_sin_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_sinh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_div_cc</NAME>
<RETURNS>void </RETURNS>
 const doubleC *x,const doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_div_dc</NAME>
<RETURNS>void </RETURNS>
 double x,const doubleC *y,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_sqrt_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_prod_c</NAME>
<RETURNS>void </RETURNS>
 doubleC *x,const doubleC *y
</FUNCTION>
<FUNCTION>
<NAME>nsp_isnan_c</NAME>
<RETURNS>double </RETURNS>
const  doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_isinf_c</NAME>
<RETURNS>double </RETURNS>
const  doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_finite_c</NAME>
<RETURNS>double </RETURNS>
 const doubleC *x
</FUNCTION>
<FUNCTION>
<NAME>nsp_acos_c</NAME>
<RETURNS>void </RETURNS>
 const doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_acosh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_asin_c</NAME>
<RETURNS>void </RETURNS>
 const doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_asinh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_atan_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_atanh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_ceil_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_aint_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_floor_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_log10_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_round_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_signum_c</NAME>
<RETURNS>void </RETURNS>
 const doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_tan_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<FUNCTION>
<NAME>nsp_tanh_c</NAME>
<RETURNS>void </RETURNS>
const  doubleC *x,doubleC *res
</FUNCTION>
<STRUCT>
<NAME>NspSerial</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeSerial</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>serial_save</NAME>
<RETURNS>int </RETURNS>
XDR  *xdrs, NspSerial *M
</USER_FUNCTION>
<STRUCT>
<NAME>NspTypeSerial</NAME>
struct _NspTypeSerial { 
  /*< private >*/
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>NspSerial</NAME>
struct _NspSerial {
  /*< private >*/
  NspObject father; 
  NspTypeSerial *type; 
  /*< public >*/
  char *val;
  int nbytes;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_serial_id</NAME>
extern int nsp_type_serial_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_serial</NAME>
extern NspTypeSerial *nsp_type_serial;
</VARIABLE>
<FUNCTION>
<NAME>new_type_serial</NAME>
<RETURNS>NspTypeSerial *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_serial</NAME>
<RETURNS>NspSerial *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLSERIAL</NAME>
#define NULLSERIAL (NspSerial*) 0
</MACRO>
<FUNCTION>
<NAME>nsp_serial_create</NAME>
<RETURNS>NspSerial *</RETURNS>
const char *name,const char *buf,int nbytes
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_copy</NAME>
<RETURNS>NspSerial *</RETURNS>
NspSerial *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_destroy</NAME>
<RETURNS>void </RETURNS>
NspSerial *H
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_info</NAME>
<RETURNS>int </RETURNS>
NspSerial *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_print</NAME>
<RETURNS>int </RETURNS>
NspSerial *H, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_object</NAME>
<RETURNS>NspSerial *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsSerialObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsSerial</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetSerialCopy</NAME>
<RETURNS>NspSerial *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetSerial</NAME>
<RETURNS>NspSerial *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_unserialize</NAME>
<RETURNS>NspObject *</RETURNS>
const NspSerial *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_object_serialize</NAME>
<RETURNS>NspObject *</RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_serial_to_matrix</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspSerial *S
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_serial</NAME>
<RETURNS>NspSerial *</RETURNS>
const NspMatrix *A
</FUNCTION>
<TYPEDEF>
<NAME>NspGFrame</NAME>
typedef struct _NspGframe NspGFrame;
</TYPEDEF>
<STRUCT>
<NAME>NspTypeGFrame</NAME>
typedef struct _NspTypeGFrame { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
} NspTypeGFrame;
</STRUCT>
<STRUCT>
<NAME>nsp_gframe</NAME>
</STRUCT>
<STRUCT>
<NAME>nsp_gframe</NAME>
struct _nsp_gframe {
  NspList *objs ;   /* Object of type list: list of internal objects */
  BCG *Xgc;         /* graphic context to ne used */
  double scale[4];  /* the scales */
  double r[4] ;     /* frame position in its father as relative numbers */
  int top;
  int ref_count;
};
</STRUCT>
<STRUCT>
<NAME>NspGframe</NAME>
struct _NspGframe {
  /*< private >*/
  NspObject father; 
  NspTypeGFrame *type; 
  /*< public >*/
  nsp_gframe *obj;
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_gframe_id</NAME>
extern int nsp_type_gframe_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_gframe</NAME>
extern NspTypeGFrame *nsp_type_gframe;
</VARIABLE>
<FUNCTION>
<NAME>new_type_gframe</NAME>
<RETURNS>NspTypeGFrame *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>new_gframe</NAME>
<RETURNS>NspGFrame *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLGFRAME</NAME>
#define NULLGFRAME (NspGFrame*) 0
</MACRO>
<FUNCTION>
<NAME>IsGFrameObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGFrameCopy</NAME>
<RETURNS>NspGFrame *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetGFrame</NAME>
<RETURNS>NspGFrame *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsGFrame</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>gframe_create</NAME>
<RETURNS>NspGFrame *</RETURNS>
char *name,BCG *Xgc,int init_objs,const double scale[],double r[],NspTypeBase *type
</FUNCTION>
<FUNCTION>
<NAME>gframe_draw</NAME>
<RETURNS>void </RETURNS>
NspGFrame *R
</FUNCTION>
<FUNCTION>
<NAME>gframe_select_obj</NAME>
<RETURNS>int </RETURNS>
NspGFrame *R, const double *pt, NspObject **Objs,NspObject *exclude
</FUNCTION>
<FUNCTION>
<NAME>gframe_select_lock</NAME>
<RETURNS>int </RETURNS>
NspGFrame *F,double pt[2], NspObject **O, int *cp, int *lock_c
</FUNCTION>
<FUNCTION>
<NAME>gframe_select_and_move</NAME>
<RETURNS>int </RETURNS>
NspGFrame *R, const double *pt
</FUNCTION>
<FUNCTION>
<NAME>gframe_select_and_hilite</NAME>
<RETURNS>int </RETURNS>
NspGFrame *R,const double pt[2]
</FUNCTION>
<MACRO>
<NAME>OK</NAME>
#define OK 0
</MACRO>
<MACRO>
<NAME>FAIL</NAME>
#define FAIL 1
</MACRO>
<MACRO>
<NAME>finite</NAME>
#define finite(x) _finite(x) 
</MACRO>
<MACRO>
<NAME>finite</NAME>
#define finite(x) FINITE_IS_UNDEFINED
</MACRO>
<MACRO>
<NAME>isnan</NAME>
#define isnan(x) _isnan(x)
</MACRO>
<MACRO>
<NAME>isnan</NAME>
#define isnan(x)  ISNAN_IS_UNDEFINED
</MACRO>
<MACRO>
<NAME>ISNAN</NAME>
#define ISNAN(x) isnan(x)
</MACRO>
<MACRO>
<NAME>Abs</NAME>
#define Abs(x) ( ( (x) >= 0) ? (x) : -( x) )
</MACRO>
<MACRO>
<NAME>Min</NAME>
#define Min(x,y)	(((x)<(y))?(x):(y))
</MACRO>
<MACRO>
<NAME>Max</NAME>
#define Max(x,y)	(((x)>(y))?(x):(y))
</MACRO>
<FUNCTION>
<NAME>Mini</NAME>
<RETURNS>double </RETURNS>
const double vect[],int
</FUNCTION>
<FUNCTION>
<NAME>Maxi</NAME>
<RETURNS>double </RETURNS>
const double vect[],int
</FUNCTION>
<MACRO>
<NAME>PI0</NAME>
#define PI0 (int *) 0
</MACRO>
<MACRO>
<NAME>PD0</NAME>
#define PD0 (double *) 0
</MACRO>
<MACRO>
<NAME>SMDOUBLE</NAME>
#define SMDOUBLE 1.e-200 /* Smalest number to avoid dividing by zero */
</MACRO>
<MACRO>
<NAME>linint</NAME>
#define linint(x) ((int) floor(x + 0.5 )) 
</MACRO>
<MACRO>
<NAME>inint</NAME>
#define inint(x) ((int) floor(x + 0.5 ))  
</MACRO>
<MACRO>
<NAME>anint</NAME>
#define anint(x) rint(x) 
</MACRO>
<MACRO>
<NAME>aint</NAME>
#define aint(x) ((x>= 0 ) ? floor(x)  : ceil(x))
</MACRO>
<MACRO>
<NAME>d_nint</NAME>
#define d_nint(x) (x)>=0 ? floor(x + .5) : -floor(.5 - x)
</MACRO>
<FUNCTION>
<NAME>tgamma</NAME>
<RETURNS>double </RETURNS>
double
</FUNCTION>
<MACRO>
<NAME>int16max</NAME>
#define int16max   0x7FFF
</MACRO>
<MACRO>
<NAME>uns16max</NAME>
#define uns16max   0xFFFF
</MACRO>
<MACRO>
<NAME>MALLOC</NAME>
#define MALLOC(x) malloc(((size_t) x))
</MACRO>
<MACRO>
<NAME>FREE</NAME>
#define FREE(x) {if (x  != NULL) { free((void *) x); x= NULL;};}
</MACRO>
<MACRO>
<NAME>REALLOC</NAME>
#define REALLOC(x,y) realloc((void *) x,(size_t) y)
</MACRO>
<MACRO>
<NAME>MALLOC</NAME>
#define MALLOC(x) malloc(((unsigned) x))
</MACRO>
<MACRO>
<NAME>FREE</NAME>
#define FREE(x) {if (x  != NULL) {free((char *) x); x = NULL;}}
</MACRO>
<MACRO>
<NAME>REALLOC</NAME>
#define REALLOC(x,y) realloc((char *) x,(unsigned) y)
</MACRO>
<MACRO>
<NAME>NVOID</NAME>
#define NVOID ""
</MACRO>
<MACRO>
<NAME>HAS_STDARG</NAME>
#  define HAS_STDARG
</MACRO>
<MACRO>
<NAME>M_PI</NAME>
#define M_PI    3.14159265358979323846 
</MACRO>
<MACRO>
<NAME>M_E</NAME>
#define M_E     2.7182818284590452354
</MACRO>
<MACRO>
<NAME>M_LOG10E</NAME>
#define M_LOG10E 0.43429448190325182765
</MACRO>
<FUNCTION>
<NAME>acosh</NAME>
<RETURNS>double </RETURNS>
double
</FUNCTION>
<FUNCTION>
<NAME>asinh</NAME>
<RETURNS>double </RETURNS>
double
</FUNCTION>
<FUNCTION>
<NAME>atanh</NAME>
<RETURNS>double </RETURNS>
double
</FUNCTION>
<FUNCTION>
<NAME>nsp_dlamch</NAME>
<RETURNS>double </RETURNS>
char *cmach
</FUNCTION>
<VARIABLE>
<NAME>int_column</NAME>
extern function int_column;
</VARIABLE>
<VARIABLE>
<NAME>int_mx2latexmat</NAME>
extern function int_mx2latexmat;
</VARIABLE>
<VARIABLE>
<NAME>int_mx2latextab</NAME>
extern function int_mx2latextab;
</VARIABLE>
<VARIABLE>
<NAME>int_mx_finite</NAME>
extern function int_mx_finite;
</VARIABLE>
<VARIABLE>
<NAME>int_mx_isinf</NAME>
extern function int_mx_isinf;
</VARIABLE>
<VARIABLE>
<NAME>int_mx_isnan</NAME>
extern function int_mx_isnan;
</VARIABLE>
<VARIABLE>
<NAME>int_mxabs</NAME>
extern function int_mxabs;
</VARIABLE>
<VARIABLE>
<NAME>int_mxacos</NAME>
extern function int_mxacos;
</VARIABLE>
<VARIABLE>
<NAME>int_mxacosh</NAME>
extern function int_mxacosh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxaddcols</NAME>
extern function int_mxaddcols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxaddrows</NAME>
extern function int_mxaddrows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxarg</NAME>
extern function int_mxarg;
</VARIABLE>
<VARIABLE>
<NAME>int_mxasin</NAME>
extern function int_mxasin;
</VARIABLE>
<VARIABLE>
<NAME>int_mxasinh</NAME>
extern function int_mxasinh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatan2</NAME>
extern function int_mxatan2;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatan</NAME>
extern function int_mxatan;
</VARIABLE>
<VARIABLE>
<NAME>int_mxatanh</NAME>
extern function int_mxatanh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxbackdivel</NAME>
extern function int_mxbackdivel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxceil</NAME>
extern function int_mxceil;
</VARIABLE>
<VARIABLE>
<NAME>int_mxclean</NAME>
extern function int_mxclean;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcomplexify</NAME>
extern function int_mxcomplexify;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatd</NAME>
extern function int_mxconcatd;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatdiag</NAME>
extern function int_mxconcatdiag;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatr</NAME>
extern function int_mxconcatr;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconcatr_mb</NAME>
extern function int_mxconcatr_mb;
</VARIABLE>
<VARIABLE>
<NAME>int_mxconj</NAME>
extern function int_mxconj;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcopy</NAME>
extern function int_mxcopy;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcos</NAME>
extern function int_mxcos;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcosh</NAME>
extern function int_mxcosh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcreate</NAME>
extern function int_mxcreate;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcuprod</NAME>
extern function int_mxcuprod;
</VARIABLE>
<VARIABLE>
<NAME>int_mxcusum</NAME>
extern function int_mxcusum;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdadd</NAME>
extern function int_mxdadd;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeletecols</NAME>
extern function int_mxdeletecols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeleteelts</NAME>
extern function int_mxdeleteelts;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdeleterows</NAME>
extern function int_mxdeleterows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdestroy</NAME>
extern function int_mxdestroy;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiag</NAME>
extern function int_mxdiag;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiagcre</NAME>
extern function int_mxdiagcre;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiage</NAME>
extern function int_mxdiage;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiagset</NAME>
extern function int_mxdiagset;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdivel</NAME>
extern function int_mxdivel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdquote</NAME>
extern function int_mxdquote;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdsub</NAME>
extern function int_mxdsub;
</VARIABLE>
<VARIABLE>
<NAME>int_mxeq</NAME>
extern function int_mxeq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxerf</NAME>
extern function int_mxerf;
</VARIABLE>
<VARIABLE>
<NAME>int_mxerfc</NAME>
extern function int_mxerfc;
</VARIABLE>
<VARIABLE>
<NAME>int_mxexpel</NAME>
extern function int_mxexpel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextract</NAME>
extern function int_mxextract;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractcols</NAME>
extern function int_mxextractcols;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractelts</NAME>
extern function int_mxextractelts;
</VARIABLE>
<VARIABLE>
<NAME>int_mxextractrows</NAME>
extern function int_mxextractrows;
</VARIABLE>
<VARIABLE>
<NAME>int_mxeye</NAME>
extern function int_mxeye;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfeq</NAME>
extern function int_mxfeq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfge</NAME>
extern function int_mxfge;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfgt</NAME>
extern function int_mxfgt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfind</NAME>
extern function int_mxfind;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfle</NAME>
extern function int_mxfle;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfloor</NAME>
extern function int_mxfloor;
</VARIABLE>
<VARIABLE>
<NAME>int_mxflt</NAME>
extern function int_mxflt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxfneq</NAME>
extern function int_mxfneq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxge</NAME>
extern function int_mxge;
</VARIABLE>
<VARIABLE>
<NAME>int_mxgt</NAME>
extern function int_mxgt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxiand</NAME>
extern function int_mxiand;
</VARIABLE>
<VARIABLE>
<NAME>int_mxidiv</NAME>
extern function int_mxidiv;
</VARIABLE>
<VARIABLE>
<NAME>int_mximagpart</NAME>
extern function int_mximagpart;
</VARIABLE>
<VARIABLE>
<NAME>int_mximpl</NAME>
extern function int_mximpl;
</VARIABLE>
<VARIABLE>
<NAME>int_mxinfo</NAME>
extern function int_mxinfo;
</VARIABLE>
<VARIABLE>
<NAME>int_mxint</NAME>
extern function int_mxint;
</VARIABLE>
<VARIABLE>
<NAME>int_mxior</NAME>
extern function int_mxior;
</VARIABLE>
<VARIABLE>
<NAME>int_mxkron</NAME>
extern function int_mxkron;
</VARIABLE>
<VARIABLE>
<NAME>int_mxle</NAME>
extern function int_mxle;
</VARIABLE>
<VARIABLE>
<NAME>int_mxlogel</NAME>
extern function int_mxlogel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxlt</NAME>
extern function int_mxlt;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmat2vect</NAME>
extern function int_mxmat2vect;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmatrix</NAME>
extern function int_mxmatrix;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmaxi</NAME>
extern function int_mxmaxi;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmini</NAME>
extern function int_mxmini;
</VARIABLE>
<VARIABLE>
<NAME>int_mxminus</NAME>
extern function int_mxminus;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmodulo</NAME>
extern function int_mxmodulo;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmultel</NAME>
extern function int_mxmultel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxmult</NAME>
extern function int_mxmult;
</VARIABLE>
<VARIABLE>
<NAME>int_mxneq</NAME>
extern function int_mxneq;
</VARIABLE>
<VARIABLE>
<NAME>int_mxones</NAME>
extern function int_mxones;
</VARIABLE>
<VARIABLE>
<NAME>int_mxpolar</NAME>
extern function int_mxpolar;
</VARIABLE>
<VARIABLE>
<NAME>int_mxpowel</NAME>
extern function int_mxpowel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxprint_xxx</NAME>
extern function int_mxprint_xxx;
</VARIABLE>
<VARIABLE>
<NAME>int_mxprod</NAME>
extern function int_mxprod;
</VARIABLE>
<VARIABLE>
<NAME>int_mxquote</NAME>
extern function int_mxquote;
</VARIABLE>
<VARIABLE>
<NAME>int_mxrand</NAME>
extern function int_mxrand;
</VARIABLE>
<VARIABLE>
<NAME>int_mxrealpart</NAME>
extern function int_mxrealpart;
</VARIABLE>
<VARIABLE>
<NAME>int_mxredim</NAME>
extern function int_mxredim;
</VARIABLE>
<VARIABLE>
<NAME>int_mxresize</NAME>
extern function int_mxresize;
</VARIABLE>
<VARIABLE>
<NAME>int_mxround</NAME>
extern function int_mxround;
</VARIABLE>
<VARIABLE>
<NAME>int_mxseti</NAME>
extern function int_mxseti;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsetr</NAME>
extern function int_mxsetr;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsetrc</NAME>
extern function int_mxsetrc;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsign</NAME>
extern function int_mxsign;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsin</NAME>
extern function int_mxsin;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsinh</NAME>
extern function int_mxsinh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsort</NAME>
extern function int_mxsort;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsqrtel</NAME>
extern function int_mxsqrtel;
</VARIABLE>
<VARIABLE>
<NAME>int_mxsum</NAME>
extern function int_mxsum;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtan</NAME>
extern function int_mxtan;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtanh</NAME>
extern function int_mxtanh;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtestmatrix</NAME>
extern function int_mxtestmatrix;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtril</NAME>
extern function int_mxtril;
</VARIABLE>
<VARIABLE>
<NAME>int_mxtriu</NAME>
extern function int_mxtriu;
</VARIABLE>
<VARIABLE>
<NAME>int_mxzeros</NAME>
extern function int_mxzeros;
</VARIABLE>
<VARIABLE>
<NAME>int_mxdiv</NAME>
extern function int_mxdiv; 
</VARIABLE>
<VARIABLE>
<NAME>int_mxbdiv</NAME>
extern function int_mxbdiv; 
</VARIABLE>
<FUNCTION>
<NAME>nsp_timer</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_cputime</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_realtime</NAME>
<RETURNS>int </RETURNS>
double *t
</FUNCTION>
<FUNCTION>
<NAME>nsp_realtime_init</NAME>
<RETURNS>int </RETURNS>
 double *t,  double *scale
</FUNCTION>
<FUNCTION>
<NAME>nsp_stimer</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_tictoc</NAME>
<RETURNS>int </RETURNS>
double *etime
</FUNCTION>
<TYPEDEF>
<NAME>Boolean</NAME>
typedef int Boolean;
</TYPEDEF>
<STRUCT>
<NAME>NspBMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeBMatrix</NAME>
</STRUCT>
<STRUCT>
<NAME>NspTypeBMatrix</NAME>
struct _NspTypeBMatrix { 
  NSP_TYPE_OBJECT__ 
  /*< public >*/
};
</STRUCT>
<STRUCT>
<NAME>NspBMatrix</NAME>
struct _NspBMatrix {
  /*< private >*/
  NspObject father; 
  NspTypeBMatrix *type; 
  /*< public >*/
  int m,n,mn;
  Boolean *B;	
};
</STRUCT>
<VARIABLE>
<NAME>nsp_type_bmatrix_id</NAME>
extern int nsp_type_bmatrix_id;
</VARIABLE>
<VARIABLE>
<NAME>nsp_type_bmatrix</NAME>
extern NspTypeBMatrix *nsp_type_bmatrix;
</VARIABLE>
<FUNCTION>
<NAME>nsp_type_bmatrix_init</NAME>
<RETURNS>int </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>new_type_bmatrix</NAME>
<RETURNS>NspTypeBMatrix *</RETURNS>
type_mode mode
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_bmatrix_init</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_type_bmatrix_set</NAME>
<RETURNS>void </RETURNS>
NspBMatrix *bmatrix, NspTypeBMatrix *type
</FUNCTION>
<FUNCTION>
<NAME>new_bmatrix</NAME>
<RETURNS>NspBMatrix *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>NULLBMAT</NAME>
#define NULLBMAT (NspBMatrix*) 0
</MACRO>
<FUNCTION>
<NAME>BMatObj</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>IsBMatObj</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>IsBMat</NAME>
<RETURNS>int </RETURNS>
const NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>GetBMatCopy</NAME>
<RETURNS>NspBMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>GetBMat</NAME>
<RETURNS>NspBMatrix *</RETURNS>
Stack stack, int i
</FUNCTION>
<FUNCTION>
<NAME>BoolScalar</NAME>
<RETURNS>int </RETURNS>
NspObject *O, Boolean *val
</FUNCTION>
<FUNCTION>
<NAME>GetScalarBool</NAME>
<RETURNS>int </RETURNS>
Stack stack, int i, int *val
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_create</NAME>
<RETURNS>NspBMatrix *</RETURNS>
const char *name, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_clone</NAME>
<RETURNS>NspBMatrix *</RETURNS>
const char *name, NspBMatrix *A, int m, int n, int init
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_copy</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_elt_size</NAME>
<RETURNS>unsigned int  </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_resize</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_destroy</NAME>
<RETURNS>void </RETURNS>
NspBMatrix *BMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_info</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *BMat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_print</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *BMat, int indent,const char *name, int rec_level
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_latex_print</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *BMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_latex_tab_print</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *BMat
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_redim</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_enlarge</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, int m, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_concat_right</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_add_columns</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, int n
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_concat_down</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_concat_diag</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_add_rows</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, int m
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_set_submatrix</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, NspMatrix *Rows, NspMatrix *Cols, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_set_rows</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, NspMatrix *Rows, NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspMatrix *Rows, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_elements</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspMatrix *Elts
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_columns</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspMatrix *Cols
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_rows</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, NspMatrix *Rows
</FUNCTION>
<FUNCTION>
<NAME>BMatLoopCol</NAME>
<RETURNS>NspBMatrix *</RETURNS>
char *str, NspBMatrix *Col, NspBMatrix *A, int icol, int *rep
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_extract_diag</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_set_diag</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A, NspBMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_create_diag</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *Diag, int k
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_transpose</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_matrix_to_bmatrix</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_to_matrix</NAME>
<RETURNS>NspMatrix *</RETURNS>
NspBMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>MatIsTrue</NAME>
<RETURNS>int </RETURNS>
NspMatrix *M
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_and</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_scalar_and</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_or</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_scalar_or</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A,const NspBMatrix *B
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_not</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>BMatIsTrue</NAME>
<RETURNS>int </RETURNS>
NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_count_true</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_find</NAME>
<RETURNS>NspMatrix *</RETURNS>
const NspBMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_find_2</NAME>
<RETURNS>int </RETURNS>
const NspBMatrix *A, int lhs, NspMatrix **Res1, NspMatrix **Res2
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_compare</NAME>
<RETURNS>NspBMatrix *</RETURNS>
const NspBMatrix *A, const NspBMatrix *B, char *op
</FUNCTION>
<FUNCTION>
<NAME>nsp_bmatrix_full_compare</NAME>
<RETURNS>int </RETURNS>
const NspBMatrix *A,const  NspBMatrix *B, char *op, int *err
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_comp</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B,const char *op
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_comp_real</NAME>
<RETURNS>NspBMatrix *</RETURNS>
NspMatrix *A, NspMatrix *B,const char *op
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_isinf</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_isnan</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_mat_finite</NAME>
<RETURNS>NspBMatrix  *</RETURNS>
NspMatrix *A
</FUNCTION>
<MACRO>
<NAME>SHREXT_NAME</NAME>
#define SHREXT_NAME ".dll"
</MACRO>
<MACRO>
<NAME>SHREXT_NAME</NAME>
#define SHREXT_NAME ".so"
</MACRO>
<VARIABLE>
<NAME>Datas</NAME>
extern NspList *Datas ;
</VARIABLE>
<FUNCTION>
<NAME>nsp_init_frames</NAME>
<RETURNS>int </RETURNS>
int argc, char **argv
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_frame</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_new_frame_with_local_vars</NAME>
<RETURNS>int </RETURNS>
NspCells *table
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_delete</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frames_info</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frames_print</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_replace_object</NAME>
<RETURNS>int </RETURNS>
 NspObject *A,int local_id
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_replace_object</NAME>
<RETURNS>int </RETURNS>
NspObject *A
</FUNCTION>
<FUNCTION>
<NAME>nsp_frames_search_object</NAME>
<RETURNS>NspObject *</RETURNS>
const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frames_search_local_in_calling</NAME>
<RETURNS>NspObject *</RETURNS>
const char *str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_search_object</NAME>
<RETURNS>NspObject *</RETURNS>
nsp_const_string  str
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_search_object</NAME>
<RETURNS>NspObject *</RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_remove_object</NAME>
<RETURNS>void </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_global_frame_remove_all_objects</NAME>
<RETURNS>int </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_search_and_remove_object</NAME>
<RETURNS>NspObject *</RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_remove_object</NAME>
<RETURNS>void </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_search_and_move_up_object</NAME>
<RETURNS>int </RETURNS>
nsp_const_string str
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_move_up_object</NAME>
<RETURNS>int </RETURNS>
NspObject *O
</FUNCTION>
<FUNCTION>
<NAME>nsp_declare_global</NAME>
<RETURNS>int </RETURNS>
char *name,int id
</FUNCTION>
<FUNCTION>
<NAME>nsp_frame_insert_hash_contents</NAME>
<RETURNS>int </RETURNS>
NspHash *H
</FUNCTION>
<MACRO>
<NAME>INTERSIZ</NAME>
#define INTERSIZ 256
</MACRO>
<TYPEDEF>
<NAME>mxArray</NAME>
typedef NspObject mxArray ;
</TYPEDEF>
<TYPEDEF>
<NAME>mxLogical</NAME>
typedef int mxLogical; /* should be int on Nsp */
</TYPEDEF>
<TYPEDEF>
<NAME>mxChar</NAME>
typedef char mxChar;
</TYPEDEF>
<ENUM>
<NAME>mxComplexity</NAME>
typedef enum { mxREAL, mxCOMPLEX } mxComplexity; 
</ENUM>
<TYPEDEF>
<NAME>bool</NAME>
typedef int bool;
</TYPEDEF>
<MACRO>
<NAME>true</NAME>
#define true TRUE 
</MACRO>
<MACRO>
<NAME>false</NAME>
#define false FALSE
</MACRO>
<MACRO>
<NAME>mxAssert</NAME>
#define mxAssert(cond,mess) if ( !(cond) ) _mxAssert(mess,__LINE__,__FILE__) ;
</MACRO>
<FUNCTION>
<NAME>nsp_mex_wrapper</NAME>
<RETURNS>int </RETURNS>
Stack stack, int rhs, int opt, int lhs,mexfun *mexFunction
</FUNCTION>
<FUNCTION>
<NAME>mxGetPr</NAME>
<RETURNS>double *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetPi</NAME>
<RETURNS>double *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetM</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetN</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsString</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsNumeric</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsFull</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsSparse</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsComplex</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetScalar</NAME>
<RETURNS>double </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mexErrMsgTxt</NAME>
<RETURNS>void </RETURNS>
char *error_msg
</FUNCTION>
<FUNCTION>
<NAME>mxCreateFull</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n, int it
</FUNCTION>
<FUNCTION>
<NAME>mxCreateDoubleMatrix</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n,  mxComplexity it
</FUNCTION>
<FUNCTION>
<NAME>mxCalloc</NAME>
<RETURNS>void *</RETURNS>
unsigned int n, unsigned int size
</FUNCTION>
<FUNCTION>
<NAME>mxGetString</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr, char *str, int strl
</FUNCTION>
<FUNCTION>
<NAME>mxFreeMatrix</NAME>
<RETURNS>void </RETURNS>
mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxFree</NAME>
<RETURNS>void </RETURNS>
void *ptr
</FUNCTION>
<FUNCTION>
<NAME>mexAtExit</NAME>
<RETURNS>int </RETURNS>
void (*ExitFcn)(void)
</FUNCTION>
<FUNCTION>
<NAME>mxCreateSparse</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n, int nzmax,mxComplexity ComplexFlag
</FUNCTION>
<FUNCTION>
<NAME>mxCreateString</NAME>
<RETURNS>mxArray *</RETURNS>
const char *string
</FUNCTION>
<FUNCTION>
<NAME>mxGetJc</NAME>
<RETURNS>int *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetIr</NAME>
<RETURNS>int *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsChar</NAME>
<RETURNS>bool </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetNumberOfDimensions</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetNumberOfFields</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetNumberOfElements</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsStruct</NAME>
<RETURNS>bool </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateStructMatrix</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n, int nfields, const char **field_names
</FUNCTION>
<FUNCTION>
<NAME>mxGetInf</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxGetNaN</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxGetEps</NAME>
<RETURNS>double </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxIsInf</NAME>
<RETURNS>bool </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>mxIsFinite</NAME>
<RETURNS>bool </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>mxIsNaN</NAME>
<RETURNS>bool </RETURNS>
double x
</FUNCTION>
<FUNCTION>
<NAME>mxGetScalar</NAME>
<RETURNS>double </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetField</NAME>
<RETURNS>mxArray *</RETURNS>
const mxArray *pa, int i,const char *fieldname
</FUNCTION>
<FUNCTION>
<NAME>mxSetField</NAME>
<RETURNS>void </RETURNS>
mxArray *pa, int i, const char *fieldname, mxArray *value
</FUNCTION>
<FUNCTION>
<NAME>mexWarnMsgTxt</NAME>
<RETURNS>void </RETURNS>
const char *error_msg
</FUNCTION>
<FUNCTION>
<NAME>mxIsCell</NAME>
<RETURNS>bool </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetCell</NAME>
<RETURNS>mxArray *</RETURNS>
const mxArray *ptr, int index
</FUNCTION>
<FUNCTION>
<NAME>mxSetCell</NAME>
<RETURNS>void </RETURNS>
mxArray *ptr, int index, mxArray *value
</FUNCTION>
<FUNCTION>
<NAME>mxCreateCellMatrix</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>mxArrayToString</NAME>
<RETURNS>char *</RETURNS>
const mxArray *ptr
</FUNCTION>
<MACRO>
<NAME>mexPrintf</NAME>
#define mexPrintf Sciprintf
</MACRO>
<TYPEDEF>
<NAME>mxClassID</NAME>
typedef int  mxClassID;
</TYPEDEF>
<FUNCTION>
<NAME>mxGetClassID</NAME>
<RETURNS>mxClassID </RETURNS>
const mxArray *ptr
</FUNCTION>
<MACRO>
<NAME>mxUNKNOWN_CLASS</NAME>
#define  mxUNKNOWN_CLASS 0
</MACRO>
<MACRO>
<NAME>mxCELL_CLASS</NAME>
#define  mxCELL_CLASS  nsp_type_cells_id
</MACRO>
<MACRO>
<NAME>mxSTRUCT_CLASS</NAME>
#define  mxSTRUCT_CLASS  nsp_type_hash_id 
</MACRO>
<MACRO>
<NAME>mxCHAR_CLASS</NAME>
#define  mxCHAR_CLASS  nsp_type_smatrix_id
</MACRO>
<MACRO>
<NAME>mxLOGICAL_CLASS</NAME>
#define  mxLOGICAL_CLASS  nsp_type_bmatrix_id
</MACRO>
<MACRO>
<NAME>mxDOUBLE_CLASS</NAME>
#define  mxDOUBLE_CLASS  nsp_type_matrix_id
</MACRO>
<MACRO>
<NAME>mxOBJECT_CLASS</NAME>
#define  mxOBJECT_CLASS  nsp_type_object_id
</MACRO>
<MACRO>
<NAME>mxSPARSE_CLASS</NAME>
#define  mxSPARSE_CLASS  nsp_type_spcolmatrix_id
</MACRO>
<MACRO>
<NAME>mxSINGLE_CLASS</NAME>
#define  mxSINGLE_CLASS  -1 
</MACRO>
<MACRO>
<NAME>mxINT8_CLASS</NAME>
#define  mxINT8_CLASS  -2
</MACRO>
<MACRO>
<NAME>mxUINT8_CLASS</NAME>
#define  mxUINT8_CLASS  -3
</MACRO>
<MACRO>
<NAME>mxINT16_CLASS</NAME>
#define  mxINT16_CLASS  -4
</MACRO>
<MACRO>
<NAME>mxUINT16_CLASS</NAME>
#define  mxUINT16_CLASS  -5
</MACRO>
<MACRO>
<NAME>mxINT32_CLASS</NAME>
#define  mxINT32_CLASS  -6
</MACRO>
<MACRO>
<NAME>mxUINT32_CLASS</NAME>
#define  mxUINT32_CLASS  -7
</MACRO>
<MACRO>
<NAME>mxINT64_CLASS</NAME>
#define  mxINT64_CLASS  -8
</MACRO>
<MACRO>
<NAME>mxUINT64_CLASS</NAME>
#define  mxUINT64_CLASS  -9
</MACRO>
<MACRO>
<NAME>mxOPAQUE_CLASS</NAME>
#define  mxOPAQUE_CLASS  -10
</MACRO>
<MACRO>
<NAME>mxFUNCTION_CLASS</NAME>
#define  mxFUNCTION_CLASS  nsp_type_plist_id 
</MACRO>
<FUNCTION>
<NAME>mxMalloc</NAME>
<RETURNS>void *</RETURNS>
size_t n
</FUNCTION>
<FUNCTION>
<NAME>mxDestroyArray</NAME>
<RETURNS>void </RETURNS>
mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateCellArray</NAME>
<RETURNS>mxArray *</RETURNS>
int ndim, const int *dims
</FUNCTION>
<FUNCTION>
<NAME>mxCalcSingleSubscript</NAME>
<RETURNS>int </RETURNS>
const mxArray *ptr, int nsubs,const int *subs
</FUNCTION>
<FUNCTION>
<NAME>mexPutVariable</NAME>
<RETURNS>int </RETURNS>
const char *workspace, const char *var_name,mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateCharMatrixFromStrings</NAME>
<RETURNS>mxArray *</RETURNS>
int m, const char **str
</FUNCTION>
<FUNCTION>
<NAME>mexCallMATLAB</NAME>
<RETURNS>int </RETURNS>
int nlhs, mxArray *plhs[], int nrhs,mxArray *prhs[],char *command_name
</FUNCTION>
<MACRO>
<NAME>mexCallNsp</NAME>
#define mexCallNsp mexCallMATLAB
</MACRO>
<MACRO>
<NAME>mexCallScilab</NAME>
#define mexCallScilab mexCallMATLAB
</MACRO>
<FUNCTION>
<NAME>mxDuplicateArray</NAME>
<RETURNS>mxArray *</RETURNS>
const mxArray *in
</FUNCTION>
<FUNCTION>
<NAME>mxSetName</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr,const char *var_name
</FUNCTION>
<FUNCTION>
<NAME>mexPutArray</NAME>
<RETURNS>int </RETURNS>
 mxArray *array_ptr,const char *workspace
</FUNCTION>
<FUNCTION>
<NAME>mexEvalString</NAME>
<RETURNS>int </RETURNS>
 char *command
</FUNCTION>
<FUNCTION>
<NAME>mxGetDimensions</NAME>
<RETURNS>int *</RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxSetNzmax</NAME>
<RETURNS>int </RETURNS>
 mxArray *array_ptr,int n
</FUNCTION>
<FUNCTION>
<NAME>mxGetNzmax</NAME>
<RETURNS>int </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateScalarDouble</NAME>
<RETURNS>mxArray *</RETURNS>
double value
</FUNCTION>
<FUNCTION>
<NAME>mxCreateDoubleScalar</NAME>
<RETURNS>mxArray *</RETURNS>
double value
</FUNCTION>
<FUNCTION>
<NAME>mxIsEmpty</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mexMakeArrayPersistent</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateLogicalScalar</NAME>
<RETURNS>mxArray *</RETURNS>
mxLogical value
</FUNCTION>
<FUNCTION>
<NAME>mexMakeMemoryPersistent</NAME>
<RETURNS>void </RETURNS>
void *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsLogicalScalarTrue</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mexLock</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mexUnlock</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mexIsLocked</NAME>
<RETURNS>bool </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxIsLogicalScalar</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsLogical</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetFieldNameByNumber</NAME>
<RETURNS>const char *</RETURNS>
const mxArray *array_ptr,int field_number
</FUNCTION>
<FUNCTION>
<NAME>mxGetData</NAME>
<RETURNS>void *</RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateCharArray</NAME>
<RETURNS>mxArray *</RETURNS>
int ndim, const int *dims
</FUNCTION>
<FUNCTION>
<NAME>mxGetFieldByNumber</NAME>
<RETURNS>mxArray *</RETURNS>
const mxArray *array_ptr, int index,int field_number
</FUNCTION>
<FUNCTION>
<NAME>mxGetElementSize</NAME>
<RETURNS>int </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetChars</NAME>
<RETURNS>mxChar *</RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetLogicals</NAME>
<RETURNS>mxLogical *</RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxGetClassName</NAME>
<RETURNS>const char *</RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxIsSharedArray</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxUnshareArray</NAME>
<RETURNS>void </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateLogicalArray</NAME>
<RETURNS>mxArray *</RETURNS>
int ndim, const int *dims
</FUNCTION>
<FUNCTION>
<NAME>mxCreateLogicalMatrix</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n
</FUNCTION>
<FUNCTION>
<NAME>mxIsDouble</NAME>
<RETURNS>bool </RETURNS>
const mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxCreateStructArray</NAME>
<RETURNS>mxArray *</RETURNS>
int ndim, const int *dims, int nfields,const char **field_names
</FUNCTION>
<FUNCTION>
<NAME>mexGetVariable</NAME>
<RETURNS>mxArray *</RETURNS>
const char *workspace, const char *var_name
</FUNCTION>
<FUNCTION>
<NAME>mexGetArray</NAME>
<RETURNS>mxArray *</RETURNS>
const char *name, const char *workspace
</FUNCTION>
<FUNCTION>
<NAME>mxSetLogical</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr
</FUNCTION>
<FUNCTION>
<NAME>mxSetData</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr, void *pr
</FUNCTION>
<FUNCTION>
<NAME>mxSetPr</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr, double *pr
</FUNCTION>
<FUNCTION>
<NAME>mxSetJc</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr, int *jc
</FUNCTION>
<FUNCTION>
<NAME>mxSetIr</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr,int *ir
</FUNCTION>
<FUNCTION>
<NAME>mxRealloc</NAME>
<RETURNS>void *</RETURNS>
void *ptr, size_t size
</FUNCTION>
<FUNCTION>
<NAME>mxSetPi</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr, double *pi
</FUNCTION>
<TYPEDEF>
<NAME>mwSize</NAME>
typedef int mwSize; 
</TYPEDEF>
<FUNCTION>
<NAME>mxSetN</NAME>
<RETURNS>void </RETURNS>
mxArray *ptr, mwSize n
</FUNCTION>
<FUNCTION>
<NAME>mxSetM</NAME>
<RETURNS>void </RETURNS>
mxArray *ptr, mwSize m
</FUNCTION>
<FUNCTION>
<NAME>mxCreateSparseLogicalMatrix</NAME>
<RETURNS>mxArray *</RETURNS>
int m, int n, int nzmax
</FUNCTION>
<FUNCTION>
<NAME>mxCreateNumericArray</NAME>
<RETURNS>mxArray *</RETURNS>
int ndim, const int *dims,mxClassID class, mxComplexity ComplexFlag
</FUNCTION>
<FUNCTION>
<NAME>mxSetFieldByNumber</NAME>
<RETURNS>void </RETURNS>
mxArray *array_ptr, int index,int field_number, mxArray *value
</FUNCTION>
<FUNCTION>
<NAME>mxFreeSparseMtlbTriplet</NAME>
<RETURNS>void </RETURNS>
const mxArray *ptr
</FUNCTION>
<FUNCTION>
<NAME>mxSparseMtlbTripletTonsp</NAME>
<RETURNS>void </RETURNS>
const mxArray *ptr
</FUNCTION>
