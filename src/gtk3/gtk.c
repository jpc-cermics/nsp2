/* -*- Mode: C -*- */

/* This file is generated, please do not edit */
/* Nsp
 * Copyright (C) 1998-2015 Jean-Philippe Chancelier Enpc/Cermics
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */





#line 4 "codegen-3.0/gtk.override"
#include <gdk/gdk.h>
#include <gtk/gtk.h>
#include <gtk/gtkx.h>
#include <cairo/cairo.h>
#include <cairo/cairo-gobject.h>

#include <nsp/nsp.h>
#include <nsp/objects.h>
#include <nsp/smatrix.h>
#include <nsp/cells.h>
#include <nsp/plist.h>
#include <nsp/none.h>
#include <nsp/file.h>
#include <nsp/type.h>
#include <nsp/hobj.h>
#include <nsp/interf.h>
#include <nsp/eval.h>
#include <nsp/gtk/gboxed.h>
#include <nsp/gtk/gobject.h>
#include <nsp/gtk/gobject-util.h>
#define  GtkCellEditable_Private
#include <nsp/gtk/gtkcelleditable.h>

#include <nsp/all-glib.h>
#include <nsp/gvariant.h>
#include <nsp/gvarianttype.h>

#include <nsp/gtk/cairo_t.h>
#include <nsp/gtk/cairo_surface_t.h>
#include <nsp/gtk/cairo_region_t.h>

#include <nsp/gtk/pangofontmap.h>
/* XXXX */
extern int nsp_graphic_new(GtkWidget *win,GtkWidget *box, int v2,int *wdim,int *wpdim,double *viewport_pos,int *wpos);
extern int nsp_graphic_new_gl(GtkWidget *win,GtkWidget *box, int v2,int *wdim,int *wpdim,double *viewport_pos,int *wpos);

static void
nspgtk_cell_data_func_marshal (GtkTreeViewColumn *tree_column,
			       GtkCellRenderer *cell,
			       GtkTreeModel *tree_model,
			       GtkTreeIter *iter, gpointer data);

static void gtk_drag_set_icon_gicon_redef (GdkDragContext *context,
					   GIcon          *icon,
					   gint            hot_x,
					   gint            hot_y);

#line 76 "gtk.c"
/* ---------- types from other modules ---------- */
#include <nsp/gtk/gdkatom.h>
#include <nsp/gtk/gdkpixmap.h>
#include <nsp/gtk/gdkwindow.h>
#include <nsp/gtk/gdkgc.h>
#include <nsp/gtk/gdkfont.h>
#include <nsp/gtk/gdkpixbuf.h>
#include <nsp/gtk/gdkbitmap.h>
#include <nsp/gtk/gdkpixbufanimation.h>
#include <nsp/gtk/gdkdragcontext.h>
#include <nsp/gtk/gdkcolormap.h>
#include <nsp/gtk/gdkcolor.h>
#include <nsp/gtk/gdkimage.h>
#include <nsp/gtk/gdkvisual.h>
#include <nsp/gtk/gdkrectangle.h>
#include <nsp/gtk/gdkevent.h>
#include <nsp/gtk/gdkscreen.h>
#include <nsp/gtk/gdkdisplay.h>
#include <nsp/gtk/gdkdevice.h>
#include <nsp/gtk/gdkframeclock.h>
#include <nsp/gtk/gdkrgba.h>
#include <nsp/gtk/gtktreemodel.h>
#include <nsp/gtk/pangolayout.h>
#include <nsp/gtk/pangolanguage.h>
#include <nsp/gtk/pangofontdescription.h>
#include <nsp/gtk/pangofontfamily.h>
#include <nsp/gtk/pangofontface.h>
#include <nsp/gtk/pangoattrlist.h>
#include <nsp/gtk/pangotabarray.h>
#include <nsp/gtk/pangocontext.h>
/* ---------- forward type declarations ---------- */
#include <nsp/gtk/gtktextiter.h>
#include <nsp/gtk/gtkborder.h>
#include <nsp/gtk/gtkiconinfo.h>
#include <nsp/gtk/gtkrequisition.h>
#include <nsp/gtk/gtkselectiondata.h>
#include <nsp/gtk/gtktextattributes.h>
#include <nsp/gtk/gtktreeiter.h>
#include <nsp/gtk/gtktreerowreference.h>
#include <nsp/gtk/gtktreepath.h>
#include <nsp/gtk/gtkcsssection.h>
#include <nsp/gtk/gtkapplication.h>
#include <nsp/gtk/gtkapplicationwindow.h>
#include <nsp/gtk/gtkbuilder.h>
#include <nsp/gtk/gtkwindow.h>
#include <nsp/gtk/gtkdialog.h>
#include <nsp/gtk/gtkmessagedialog.h>
#include <nsp/gtk/gtkaboutdialog.h>
#include <nsp/gtk/gtkassistant.h>
#include <nsp/gtk/gtkinvisible.h>
#include <nsp/gtk/gtkoffscreenwindow.h>
#include <nsp/gtk/gtkwindowgroup.h>
#include <nsp/gtk/gtkbox.h>
#include <nsp/gtk/gtkgrid.h>
#include <nsp/gtk/gtkrevealer.h>
#include <nsp/gtk/gtklistbox.h>
#include <nsp/gtk/gtkflowbox.h>
#include <nsp/gtk/gtkstack.h>
#include <nsp/gtk/gtkstackswitcher.h>
#include <nsp/gtk/gtkstacksidebar.h>
#include <nsp/gtk/gtkactionbar.h>
#include <nsp/gtk/gtkheaderbar.h>
#include <nsp/gtk/gtkoverlay.h>
#include <nsp/gtk/gtkbuttonbox.h>
#include <nsp/gtk/gtkpaned.h>
#include <nsp/gtk/gtklayout.h>
#include <nsp/gtk/gtknotebook.h>
#include <nsp/gtk/gtkexpander.h>
#include <nsp/gtk/gtkaspectframe.h>
#include <nsp/gtk/gtkfixed.h>
#include <nsp/gtk/gtklabel.h>
#include <nsp/gtk/gtkimage.h>
#include <nsp/gtk/gtkspinner.h>
#include <nsp/gtk/gtkinfobar.h>
#include <nsp/gtk/gtkprogressbar.h>
#include <nsp/gtk/gtklevelbar.h>
#include <nsp/gtk/gtkstatusbar.h>
#include <nsp/gtk/gtkaccellabel.h>
#include <nsp/gtk/gtkbutton.h>
#include <nsp/gtk/gtkcheckbutton.h>
#include <nsp/gtk/gtkradiobutton.h>
#include <nsp/gtk/gtktogglebutton.h>
#include <nsp/gtk/gtklinkbutton.h>
#include <nsp/gtk/gtkmenubutton.h>
#include <nsp/gtk/gtkswitch.h>
#include <nsp/gtk/gtkscalebutton.h>
#include <nsp/gtk/gtkvolumebutton.h>
#include <nsp/gtk/gtklockbutton.h>
#include <nsp/gtk/gtkmodelbutton.h>
#include <nsp/gtk/gtkentry.h>
#include <nsp/gtk/gtkentrybuffer.h>
#include <nsp/gtk/gtkentrycompletion.h>
#include <nsp/gtk/gtkscale.h>
#include <nsp/gtk/gtkspinbutton.h>
#include <nsp/gtk/gtksearchentry.h>
#include <nsp/gtk/gtksearchbar.h>
#include <nsp/gtk/gtktextmark.h>
#include <nsp/gtk/gtktextbuffer.h>
#include <nsp/gtk/gtktexttag.h>
#include <nsp/gtk/gtktexttagtable.h>
#include <nsp/gtk/gtktextview.h>
#include <nsp/gtk/gtktextchildanchor.h>
#include <nsp/gtk/gtktreeselection.h>
#include <nsp/gtk/gtktreeviewcolumn.h>
#include <nsp/gtk/gtktreeview.h>
#include <nsp/gtk/gtkcellview.h>
#include <nsp/gtk/gtkiconview.h>
#include <nsp/gtk/gtktreemodelsort.h>
#include <nsp/gtk/gtktreemodelfilter.h>
#include <nsp/gtk/gtkcellarea.h>
#include <nsp/gtk/gtkcellareabox.h>
#include <nsp/gtk/gtkcellareacontext.h>
#include <nsp/gtk/gtkcellrenderer.h>
#include <nsp/gtk/gtkcellrendereraccel.h>
#include <nsp/gtk/gtkcellrenderercombo.h>
#include <nsp/gtk/gtkcellrendererpixbuf.h>
#include <nsp/gtk/gtkcellrendererprogress.h>
#include <nsp/gtk/gtkcellrendererspin.h>
#include <nsp/gtk/gtkcellrenderertext.h>
#include <nsp/gtk/gtkcellrenderertoggle.h>
#include <nsp/gtk/gtkcellrendererspinner.h>
#include <nsp/gtk/gtkliststore.h>
#include <nsp/gtk/gtktreestore.h>
#include <nsp/gtk/gtkcombobox.h>
#include <nsp/gtk/gtkcomboboxtext.h>
#include <nsp/gtk/gtkmenu.h>
#include <nsp/gtk/gtkmenubar.h>
#include <nsp/gtk/gtkmenuitem.h>
#include <nsp/gtk/gtkradiomenuitem.h>
#include <nsp/gtk/gtkcheckmenuitem.h>
#include <nsp/gtk/gtkseparatormenuitem.h>
#include <nsp/gtk/gtktoolbar.h>
#include <nsp/gtk/gtktoolitem.h>
#include <nsp/gtk/gtktoolpalette.h>
#include <nsp/gtk/gtktoolitemgroup.h>
#include <nsp/gtk/gtkseparatortoolitem.h>
#include <nsp/gtk/gtktoolbutton.h>
#include <nsp/gtk/gtkmenutoolbutton.h>
#include <nsp/gtk/gtktoggletoolbutton.h>
#include <nsp/gtk/gtkradiotoolbutton.h>
#include <nsp/gtk/gtkpopover.h>
#include <nsp/gtk/gtkpopovermenu.h>
#include <nsp/gtk/gtkcolorbutton.h>
#include <nsp/gtk/gtkcolorchooserwidget.h>
#include <nsp/gtk/gtkcolorchooserdialog.h>
#include <nsp/gtk/gtkfilechooserbutton.h>
#include <nsp/gtk/gtkfilechooserdialog.h>
#include <nsp/gtk/gtkfilechooserwidget.h>
#include <nsp/gtk/gtkfilefilter.h>
#include <nsp/gtk/gtkfontbutton.h>
#include <nsp/gtk/gtkfontchooserwidget.h>
#include <nsp/gtk/gtkfontchooserdialog.h>
#include <nsp/gtk/gtkplacessidebar.h>
#include <nsp/gtk/gtkframe.h>
#include <nsp/gtk/gtkseparator.h>
#include <nsp/gtk/gtkscrollbar.h>
#include <nsp/gtk/gtkscrolledwindow.h>
#include <nsp/gtk/gtkprintoperation.h>
#include <nsp/gtk/gtkprintoperationpreview.h>
#include <nsp/gtk/gtkprintcontext.h>
#include <nsp/gtk/gtkadjustment.h>
#include <nsp/gtk/gtkcalendar.h>
#include <nsp/gtk/gtkdrawingarea.h>
#include <nsp/gtk/gtkeventbox.h>
#include <nsp/gtk/gtkimcontextsimple.h>
#include <nsp/gtk/gtkimmulticontext.h>
#include <nsp/gtk/gtksizegroup.h>
#include <nsp/gtk/gtktooltip.h>
#include <nsp/gtk/gtkviewport.h>
#include <nsp/gtk/gtkaccessible.h>
#include <nsp/gtk/gtkwidget.h>
#include <nsp/gtk/gtkcontainer.h>
#include <nsp/gtk/gtkbin.h>
#include <nsp/gtk/gtkmenushell.h>
#include <nsp/gtk/gtkrange.h>
#include <nsp/gtk/gtkimcontext.h>
#include <nsp/gtk/gtkrecentmanager.h>
#include <nsp/gtk/gtkrecentchooserdialog.h>
#include <nsp/gtk/gtkrecentchooserwidget.h>
#include <nsp/gtk/gtkrecentfilter.h>
#include <nsp/gtk/gtkappchooserbutton.h>
#include <nsp/gtk/gtkappchooserdialog.h>
#include <nsp/gtk/gtkappchooserwidget.h>
#include <nsp/gtk/gtksettings.h>
#include <nsp/gtk/gtkstylecontext.h>
#include <nsp/gtk/gtkuimanager.h>
#include <nsp/gtk/gtkactiongroup.h>
#include <nsp/gtk/gtkaction.h>
#include <nsp/gtk/gtktoggleaction.h>
#include <nsp/gtk/gtkradioaction.h>
#include <nsp/gtk/gtkimagemenuitem.h>
#include <nsp/gtk/gtkmisc.h>
#include <nsp/gtk/gtkalignment.h>
#include <nsp/gtk/gtkicontheme.h>
#include <nsp/gtk/gtkaccelgroup.h>
#include <nsp/gtk/gtkcssprovider.h>
#include <nsp/gtk/gtkstyleprovider.h>
#include <nsp/gtk/gtkclipboard.h>
#include <nsp/gtk/gtkactionable.h>
#include <nsp/gtk/gtkbuildable.h>
#include <nsp/gtk/gtkorientable.h>
#include <nsp/gtk/gtkeditable.h>
#include <nsp/gtk/gtktreemodel.h>
#include <nsp/gtk/gtktreesortable.h>
#include <nsp/gtk/gtkcelllayout.h>
#include <nsp/gtk/gtkcelleditable.h>
#include <nsp/gtk/gtktoolshell.h>
#include <nsp/gtk/gtkcolorchooser.h>
#include <nsp/gtk/gtkfilechooser.h>
#include <nsp/gtk/gtkfontchooser.h>
#include <nsp/gtk/gtkscrollable.h>
#include <nsp/gtk/gtkrecentchooser.h>
#include <nsp/gtk/gtkappchooser.h>
#include <nsp/gtk/gtktreedragdest.h>
#include <nsp/gtk/gtktreedragsource.h>


/* -----------NspGtkTextIter ----------- */


#define  NspGtkTextIter_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktextiter.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTextIter inherits from GBoxed 
 */

int nsp_type_gtktextiter_id=0;
NspTypeGtkTextIter *nsp_type_gtktextiter=NULL;

/*
 * Type object for NspGtkTextIter 
 * all the instance of NspTypeGtkTextIter share the same id. 
 * nsp_type_gtktextiter: is an instance of NspTypeGtkTextIter 
 *    used for objects of NspGtkTextIter type (i.e built with new_gtktextiter) 
 * other instances are used for derived classes 
 */
NspTypeGtkTextIter *new_type_gtktextiter(type_mode mode)
{
  NspTypeGtkTextIter *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextiter != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextiter;
    }
  if (( type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextiter_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktextiter_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktextiter;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktextiter */ 

  top->s_type =  (s_type_func *) nsp_gtktextiter_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktextiter_type_short_string;
  /* top->create = (create_func*) int_gtktextiter_create;*/

  /* specific methods for gtktextiter */

  type->init = (init_func *) init_gtktextiter;

  /* 
   * NspGtkTextIter interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktextiter_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextIter called nsp_type_gtktextiter
       */
      type->id =  nsp_type_gtktextiter_id = nsp_new_type_id();
      nsp_type_gtktextiter = type;
      if ( nsp_register_type(nsp_type_gtktextiter) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextiter, GTK_TYPE_TEXT_ITER);
      return ( mode == T_BASE ) ? type : new_type_gtktextiter(mode);
    }
  else 
    {
      type->id = nsp_type_gtktextiter_id;
      return type;
    }
}

/*
 * initialize NspGtkTextIter instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextiter(NspGtkTextIter *Obj,NspTypeGtkTextIter *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTextIter 
 */

NspGtkTextIter *new_gtktextiter() 
{
  NspGtkTextIter *loc;
  /* type must exists */
  nsp_type_gtktextiter = new_type_gtktextiter(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextIter)))== NULLGTKTEXTITER) return loc;
  /* initialize object */
  if ( init_gtktextiter(loc,nsp_type_gtktextiter) == FAIL) return NULLGTKTEXTITER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTextIter 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktextiter_type_name[]="GtkTextIter";
static char gtktextiter_short_type_name[]="GtkTextIter";

static char *nsp_gtktextiter_type_as_string(void)
{
  return(gtktextiter_type_name);
}

static char *nsp_gtktextiter_type_short_string(NspObject *v)
{
  return(gtktextiter_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTextIter objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTextIter   *nsp_gtktextiter_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktextiter_id)  == TRUE  ) return ((NspGtkTextIter *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextiter));
  return NULL;
}

int IsGtkTextIterObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktextiter_id);
}

int IsGtkTextIter(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextiter_id);
}

NspGtkTextIter  *GetGtkTextIterCopy(Stack stack, int i)
{
  if (  GetGtkTextIter(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextIter  *GetGtkTextIter(Stack stack, int i)
{
  NspGtkTextIter *M;
  if (( M = nsp_gtktextiter_object(NthObj(i))) == NULLGTKTEXTITER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkTextIter *gtktextiter_copy(NspGtkTextIter *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtktextiter);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextIter
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_text_iter_get_buffer(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextBuffer *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_buffer(NSP_GBOXED_GET(self, GtkTextIter));
  nsp_type_gtktextbuffer = new_type_gtktextbuffer(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextbuffer))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 5553 "codegen-3.0/gtk.override"
static NspObject *
_wrap_gtk_text_iter_copy(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  return (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, nspg_boxed_get(self, GtkTextIter), TRUE, TRUE,NULL);
}
#line 503 "gtk.c"


#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_text_iter_assign(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextIter *other = NULL;
  NspObject *nsp_other = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_other) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_other, GTK_TYPE_TEXT_ITER))
      other = nspg_boxed_get(nsp_other, GtkTextIter);
  else {
      Scierror( "Error: other should be a GtkTextIter\n");
      return RET_BUG;
  }
  gtk_text_iter_assign(NSP_GBOXED_GET(self, GtkTextIter),other);
  return 0;
}

#else
int _wrap_gtk_text_iter_assign(Stack stack, int rhs, int opt, int lhs) /* assign */
{
  Scierror("Error: function gtk_text_iter_assign not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_text_iter_get_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_offset(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_line_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_line_offset(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_line_index(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_line_index(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_visible_line_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_visible_line_offset(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_visible_line_index(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_visible_line_index(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_char(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  gunichar ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_char(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)== FAIL)return RET_BUG;
  return 1;
}

#line 5560 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_iter_get_slice(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "end", NULL };*/
  int_types T[] = {obj, t_end} ;
  NspObject *g_end;
  gchar *text;

  if (GetArgs(stack,rhs,opt,T, &g_end)  == FAIL) return RET_BUG;
  if (!nspg_boxed_check(g_end, GTK_TYPE_TEXT_ITER)) {
    Scierror( "end must be a GtkTextIter");
    return RET_BUG;
  }
  text = gtk_text_iter_get_slice(nspg_boxed_get(self, GtkTextIter),
				 nspg_boxed_get(g_end, GtkTextIter));
  if ( nsp_move_string(stack,1,(gchar *) text,-1)== FAIL)
    {
      g_free(text);
      return RET_BUG;
    }
  g_free(text);
  return 1;
}
#line 617 "gtk.c"


#line 5585 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_iter_get_text(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "end", NULL };*/
  int_types T[] = {obj, t_end} ;
  NspObject *end;
  gchar *text;

  if (GetArgs(stack,rhs,opt,T, &end) == FAIL) return RET_BUG;;
  if (!nspg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
    Scierror( "end must be a GtkTextIter");
    return RET_BUG;
  }
  text = gtk_text_iter_get_text(nspg_boxed_get(self, GtkTextIter),
				nspg_boxed_get(end, GtkTextIter));
  if ( nsp_move_string(stack,1,(gchar *) text,-1)== FAIL)
    {
      g_free(text);
      return RET_BUG;
    }
  g_free(text);
  return 1;
}

#line 645 "gtk.c"


#line 5611 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_iter_get_visible_slice(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "end", NULL };*/
  int_types T[] = {obj, t_end} ;

  NspObject *end;
  gchar *text;

  if (GetArgs(stack,rhs,opt,T,&end)  == FAIL) return RET_BUG;;
  if (!nspg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
    Scierror( "end must be a GtkTextIter");
    return RET_BUG;
  }
  text = gtk_text_iter_get_visible_slice(nspg_boxed_get(self, GtkTextIter),
					 nspg_boxed_get(end, GtkTextIter));
  if ( nsp_move_string(stack,1,(gchar *) text,-1)== FAIL)
    {
      g_free(text);
      return RET_BUG;
    }
  g_free(text);
  return 1;
}
#line 673 "gtk.c"


#line 5637 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_iter_get_visible_text(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "end", NULL };*/
  int_types T[] = { t_end} ;
  NspObject *end;
  gchar *text;

  if (GetArgs(stack,rhs,opt,T,&end)  == FAIL) return RET_BUG;
  if (!nspg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
    Scierror( "end must be a GtkTextIter");
    return RET_BUG;
  }
  text = gtk_text_iter_get_visible_text(nspg_boxed_get(self, GtkTextIter),
					nspg_boxed_get(end, GtkTextIter));
  if ( nsp_move_string(stack,1,(gchar *) text,-1)== FAIL)
    {
      g_free(text);
      return RET_BUG;
    }
  g_free(text);
  return 1;

}
#line 701 "gtk.c"


static int _wrap_gtk_text_iter_get_pixbuf(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_pixbuf(NSP_GBOXED_GET(self, GtkTextIter));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 5663 "codegen-3.0/gtk.override"

static int _wrap_gtk_text_iter_get_marks(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *list, *tmp;
  NspList *nsp_list;
  list = gtk_text_iter_get_marks(nspg_boxed_get(self, GtkTextIter));
  NSP_LIST_FROM_GLIST(list,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);
}
#line 725 "gtk.c"


static int _wrap_gtk_text_iter_get_child_anchor(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextChildAnchor *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_child_anchor(NSP_GBOXED_GET(self, GtkTextIter));
  nsp_type_gtktextchildanchor = new_type_gtktextchildanchor(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextchildanchor))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 5673 "codegen-3.0/gtk.override"

static int
_wrap_gtk_text_iter_get_toggled_tags(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end} ;
  /* static char *kwlist[] = { "toggled_on", NULL };*/
  int toggled_on;
  GSList *list, *tmp;
  NspList *nsp_list;

  if (GetArgs(stack,rhs,opt,T,&toggled_on) == FAIL) return RET_BUG;;
  list = gtk_text_iter_get_toggled_tags(nspg_boxed_get(self, GtkTextIter), toggled_on);

  NSP_LIST_FROM_GLIST(list,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);
}
#line 756 "gtk.c"


static int _wrap_gtk_text_iter_begins_tag(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"tag",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTextTag *tag = NULL;
  NspGObject *nsp_tag = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_tag) == FAIL) return RET_BUG;
  if ( nsp_tag != NULL ) {
    if ( IsGtkTextTag((NspObject *)nsp_tag))
      tag = GTK_TEXT_TAG(nsp_tag->obj);
    else if (! IsNone((NspObject *)nsp_tag)) {
         Scierror( "Error: tag should be a GtkTextTag or None\n");
         return RET_BUG;
    }
  }
  ret =gtk_text_iter_begins_tag(NSP_GBOXED_GET(self, GtkTextIter),tag);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_ends_tag(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"tag",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTextTag *tag = NULL;
  NspGObject *nsp_tag = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_tag) == FAIL) return RET_BUG;
  if ( nsp_tag != NULL ) {
    if ( IsGtkTextTag((NspObject *)nsp_tag))
      tag = GTK_TEXT_TAG(nsp_tag->obj);
    else if (! IsNone((NspObject *)nsp_tag)) {
         Scierror( "Error: tag should be a GtkTextTag or None\n");
         return RET_BUG;
    }
  }
  ret =gtk_text_iter_ends_tag(NSP_GBOXED_GET(self, GtkTextIter),tag);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_toggles_tag(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"tag",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTextTag *tag = NULL;
  NspGObject *nsp_tag = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_tag) == FAIL) return RET_BUG;
  if ( nsp_tag != NULL ) {
    if ( IsGtkTextTag((NspObject *)nsp_tag))
      tag = GTK_TEXT_TAG(nsp_tag->obj);
    else if (! IsNone((NspObject *)nsp_tag)) {
         Scierror( "Error: tag should be a GtkTextTag or None\n");
         return RET_BUG;
    }
  }
  ret =gtk_text_iter_toggles_tag(NSP_GBOXED_GET(self, GtkTextIter),tag);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_has_tag(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *tag;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktexttag, &tag) == FAIL) return RET_BUG;
  ret =gtk_text_iter_has_tag(NSP_GBOXED_GET(self, GtkTextIter),GTK_TEXT_TAG(tag->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 5690 "codegen-3.0/gtk.override"

static int 
_wrap_gtk_text_iter_get_tags(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *list, *tmp;
  NspList *nsp_list;
  list = gtk_text_iter_get_tags(nspg_boxed_get(self, GtkTextIter));
  NSP_LIST_FROM_GLIST(list,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);
}
#line 849 "gtk.c"


static int _wrap_gtk_text_iter_editable(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int default_setting, ret;
  if ( GetArgs(stack,rhs,opt,T,&default_setting) == FAIL) return RET_BUG;
  ret =gtk_text_iter_editable(NSP_GBOXED_GET(self, GtkTextIter),default_setting);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_can_insert(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int default_editability, ret;
  if ( GetArgs(stack,rhs,opt,T,&default_editability) == FAIL) return RET_BUG;
  ret =gtk_text_iter_can_insert(NSP_GBOXED_GET(self, GtkTextIter),default_editability);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_starts_word(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_starts_word(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_ends_word(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_ends_word(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_inside_word(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_inside_word(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_starts_sentence(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_starts_sentence(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_ends_sentence(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_ends_sentence(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_inside_sentence(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_inside_sentence(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_starts_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_starts_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_ends_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_ends_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_is_cursor_position(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_is_cursor_position(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_chars_in_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_chars_in_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_bytes_in_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_bytes_in_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_attributes(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextAttributes *values = NULL;
  NspObject *nsp_values = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_values) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_values, GTK_TYPE_TEXT_ATTRIBUTES))
      values = nspg_boxed_get(nsp_values, GtkTextAttributes);
  else {
      Scierror( "Error: values should be a GtkTextAttributes\n");
      return RET_BUG;
  }
  ret =gtk_text_iter_get_attributes(NSP_GBOXED_GET(self, GtkTextIter),values);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_get_language(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoLanguage *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_get_language(NSP_GBOXED_GET(self, GtkTextIter));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,PANGO_TYPE_LANGUAGE, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_pangolanguage))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_iter_is_end(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_is_end(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_is_start(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_is_start(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_char(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_forward_char(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_char(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_backward_char(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_chars(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_forward_chars(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_chars(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_backward_chars(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_forward_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_backward_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_lines(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_forward_lines(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_lines(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_backward_lines(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_word_end(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_forward_word_end(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_word_start(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_backward_word_start(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_word_ends(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_forward_word_ends(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_word_starts(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_backward_word_starts(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_visible_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_forward_visible_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_visible_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_backward_visible_line(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_visible_lines(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_forward_visible_lines(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_visible_lines(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_backward_visible_lines(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_visible_word_end(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_forward_visible_word_end(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_visible_word_start(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_backward_visible_word_start(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_visible_word_ends(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_forward_visible_word_ends(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_visible_word_starts(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_backward_visible_word_starts(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_sentence_end(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_forward_sentence_end(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_sentence_start(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_backward_sentence_start(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_sentence_ends(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_forward_sentence_ends(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_sentence_starts(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_backward_sentence_starts(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_cursor_position(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_forward_cursor_position(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_cursor_position(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_backward_cursor_position(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_cursor_positions(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_forward_cursor_positions(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_cursor_positions(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_backward_cursor_positions(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_visible_cursor_position(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_forward_visible_cursor_position(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_visible_cursor_position(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_backward_visible_cursor_position(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_forward_visible_cursor_positions(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_forward_visible_cursor_positions(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_visible_cursor_positions(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&count) == FAIL) return RET_BUG;
  ret =gtk_text_iter_backward_visible_cursor_positions(NSP_GBOXED_GET(self, GtkTextIter),count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_set_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int char_offset;
  if ( GetArgs(stack,rhs,opt,T,&char_offset) == FAIL) return RET_BUG;
  gtk_text_iter_set_offset(NSP_GBOXED_GET(self, GtkTextIter),char_offset);
  return 0;
}

static int _wrap_gtk_text_iter_set_line(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int line_number;
  if ( GetArgs(stack,rhs,opt,T,&line_number) == FAIL) return RET_BUG;
  gtk_text_iter_set_line(NSP_GBOXED_GET(self, GtkTextIter),line_number);
  return 0;
}

static int _wrap_gtk_text_iter_set_line_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int char_on_line;
  if ( GetArgs(stack,rhs,opt,T,&char_on_line) == FAIL) return RET_BUG;
  gtk_text_iter_set_line_offset(NSP_GBOXED_GET(self, GtkTextIter),char_on_line);
  return 0;
}

static int _wrap_gtk_text_iter_set_line_index(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int byte_on_line;
  if ( GetArgs(stack,rhs,opt,T,&byte_on_line) == FAIL) return RET_BUG;
  gtk_text_iter_set_line_index(NSP_GBOXED_GET(self, GtkTextIter),byte_on_line);
  return 0;
}

static int _wrap_gtk_text_iter_forward_to_end(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
  gtk_text_iter_forward_to_end(NSP_GBOXED_GET(self, GtkTextIter));
  return 0;
}

static int _wrap_gtk_text_iter_forward_to_line_end(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_text_iter_forward_to_line_end(NSP_GBOXED_GET(self, GtkTextIter));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_set_visible_line_offset(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int char_on_line;
  if ( GetArgs(stack,rhs,opt,T,&char_on_line) == FAIL) return RET_BUG;
  gtk_text_iter_set_visible_line_offset(NSP_GBOXED_GET(self, GtkTextIter),char_on_line);
  return 0;
}

static int _wrap_gtk_text_iter_set_visible_line_index(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int byte_on_line;
  if ( GetArgs(stack,rhs,opt,T,&byte_on_line) == FAIL) return RET_BUG;
  gtk_text_iter_set_visible_line_index(NSP_GBOXED_GET(self, GtkTextIter),byte_on_line);
  return 0;
}

static int _wrap_gtk_text_iter_forward_to_tag_toggle(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *tag;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktexttag, &tag) == FAIL) return RET_BUG;
  ret =gtk_text_iter_forward_to_tag_toggle(NSP_GBOXED_GET(self, GtkTextIter),GTK_TEXT_TAG(tag->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_backward_to_tag_toggle(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *tag;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktexttag, &tag) == FAIL) return RET_BUG;
  ret =gtk_text_iter_backward_to_tag_toggle(NSP_GBOXED_GET(self, GtkTextIter),GTK_TEXT_TAG(tag->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 5701 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_iter_forward_search(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "str", "flags", "limit", NULL };*/
  gchar *str;
  NspObject *nsp_limit = NULLOBJ;
  GtkTextIter match_start, match_end, *limit = NULL;
  GtkTextSearchFlags flags;

  CheckRhs(2,3);
  if ( rhs == 2 )
    {
      int_types T2[] = { string,s_int,obj, t_end} ;
      if (GetArgs(stack,rhs,opt,T2, &str, &flags) == FAIL) return RET_BUG;;
    }
  else
    {
      int_types T3[] = { string,s_int, t_end} ;
      if (GetArgs(stack,rhs,opt,T3, &str, &flags, &nsp_limit)     == FAIL) return RET_BUG;;
      if (nspg_boxed_check(nsp_limit, GTK_TYPE_TEXT_ITER))
	limit = nspg_boxed_get(nsp_limit, GtkTextIter);
    }
  if (gtk_text_iter_forward_search(nspg_boxed_get(self, GtkTextIter), str,
				   flags, &match_start, &match_end, limit))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_start,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_end,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,2,ret);
      return 2;
    }
  return 0;
}
#line 1451 "gtk.c"


#line 5737 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_iter_backward_search(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "str", "flags", "limit", NULL };*/
  gchar *str;
  NspObject *nsp_limit = NULL;
  GtkTextIter match_start, match_end, *limit = NULL;
  GtkTextSearchFlags flags;

  CheckRhs(2,3);
  if ( rhs == 2 )
    {
      int_types T2[] = { string,s_int,obj, t_end} ;
      if (GetArgs(stack,rhs,opt,T2, &str, &flags) == FAIL) return RET_BUG;;
    }
  else
    {
      int_types T3[] = { string,s_int, t_end} ;
      if (GetArgs(stack,rhs,opt,T3, &str, &flags, &nsp_limit)     == FAIL) return RET_BUG;;
      if (nspg_boxed_check(nsp_limit, GTK_TYPE_TEXT_ITER))
	limit = nspg_boxed_get(nsp_limit, GtkTextIter);
    }
  if (gtk_text_iter_backward_search(nspg_boxed_get(self, GtkTextIter), str,
				    flags, &match_start, &match_end, limit))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_start,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &match_end,TRUE, TRUE, NULL))== NULL) return RET_BUG;
      MoveObj(stack,2,ret);
      return 2;
    }
  return 0;
}
#line 1489 "gtk.c"


static int _wrap_gtk_text_iter_equal(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextIter *g_rhs = NULL;
  NspObject *nsp_g_rhs = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_g_rhs) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_g_rhs, GTK_TYPE_TEXT_ITER))
      g_rhs = nspg_boxed_get(nsp_g_rhs, GtkTextIter);
  else {
      Scierror( "Error: g_rhs should be a GtkTextIter\n");
      return RET_BUG;
  }
  ret =gtk_text_iter_equal(NSP_GBOXED_GET(self, GtkTextIter),g_rhs);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_compare(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextIter *g_rhs = NULL;
  NspObject *nsp_g_rhs = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_g_rhs) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_g_rhs, GTK_TYPE_TEXT_ITER))
      g_rhs = nspg_boxed_get(nsp_g_rhs, GtkTextIter);
  else {
      Scierror( "Error: g_rhs should be a GtkTextIter\n");
      return RET_BUG;
  }
  ret =gtk_text_iter_compare(NSP_GBOXED_GET(self, GtkTextIter),g_rhs);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_in_range(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTextIter *start = NULL, *end = NULL;
  NspObject *nsp_start = NULL, *nsp_end = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "Error: start should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "Error: end should be a GtkTextIter\n");
      return RET_BUG;
  }
  ret =gtk_text_iter_in_range(NSP_GBOXED_GET(self, GtkTextIter),start,end);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_iter_order(NspGtkTextIter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextIter *second = NULL;
  NspObject *nsp_second = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_second) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_second, GTK_TYPE_TEXT_ITER))
      second = nspg_boxed_get(nsp_second, GtkTextIter);
  else {
      Scierror( "Error: second should be a GtkTextIter\n");
      return RET_BUG;
  }
  gtk_text_iter_order(NSP_GBOXED_GET(self, GtkTextIter),second);
  return 0;
}

static NspMethods gtktextiter_methods[] = {
  {"get_buffer",(nsp_method *) _wrap_gtk_text_iter_get_buffer},
  {"copy",(nsp_method *) _wrap_gtk_text_iter_copy},
  {"assign",(nsp_method *) _wrap_gtk_text_iter_assign},
  {"get_offset",(nsp_method *) _wrap_gtk_text_iter_get_offset},
  {"get_line",(nsp_method *) _wrap_gtk_text_iter_get_line},
  {"get_line_offset",(nsp_method *) _wrap_gtk_text_iter_get_line_offset},
  {"get_line_index",(nsp_method *) _wrap_gtk_text_iter_get_line_index},
  {"get_visible_line_offset",(nsp_method *) _wrap_gtk_text_iter_get_visible_line_offset},
  {"get_visible_line_index",(nsp_method *) _wrap_gtk_text_iter_get_visible_line_index},
  {"get_char",(nsp_method *) _wrap_gtk_text_iter_get_char},
  {"get_slice",(nsp_method *) _wrap_gtk_text_iter_get_slice},
  {"get_text",(nsp_method *) _wrap_gtk_text_iter_get_text},
  {"get_visible_slice",(nsp_method *) _wrap_gtk_text_iter_get_visible_slice},
  {"get_visible_text",(nsp_method *) _wrap_gtk_text_iter_get_visible_text},
  {"get_pixbuf",(nsp_method *) _wrap_gtk_text_iter_get_pixbuf},
  {"get_marks",(nsp_method *) _wrap_gtk_text_iter_get_marks},
  {"get_child_anchor",(nsp_method *) _wrap_gtk_text_iter_get_child_anchor},
  {"get_toggled_tags",(nsp_method *) _wrap_gtk_text_iter_get_toggled_tags},
  {"begins_tag",(nsp_method *) _wrap_gtk_text_iter_begins_tag},
  {"ends_tag",(nsp_method *) _wrap_gtk_text_iter_ends_tag},
  {"toggles_tag",(nsp_method *) _wrap_gtk_text_iter_toggles_tag},
  {"has_tag",(nsp_method *) _wrap_gtk_text_iter_has_tag},
  {"get_tags",(nsp_method *) _wrap_gtk_text_iter_get_tags},
  {"editable",(nsp_method *) _wrap_gtk_text_iter_editable},
  {"can_insert",(nsp_method *) _wrap_gtk_text_iter_can_insert},
  {"starts_word",(nsp_method *) _wrap_gtk_text_iter_starts_word},
  {"ends_word",(nsp_method *) _wrap_gtk_text_iter_ends_word},
  {"inside_word",(nsp_method *) _wrap_gtk_text_iter_inside_word},
  {"starts_sentence",(nsp_method *) _wrap_gtk_text_iter_starts_sentence},
  {"ends_sentence",(nsp_method *) _wrap_gtk_text_iter_ends_sentence},
  {"inside_sentence",(nsp_method *) _wrap_gtk_text_iter_inside_sentence},
  {"starts_line",(nsp_method *) _wrap_gtk_text_iter_starts_line},
  {"ends_line",(nsp_method *) _wrap_gtk_text_iter_ends_line},
  {"is_cursor_position",(nsp_method *) _wrap_gtk_text_iter_is_cursor_position},
  {"get_chars_in_line",(nsp_method *) _wrap_gtk_text_iter_get_chars_in_line},
  {"get_bytes_in_line",(nsp_method *) _wrap_gtk_text_iter_get_bytes_in_line},
  {"get_attributes",(nsp_method *) _wrap_gtk_text_iter_get_attributes},
  {"get_language",(nsp_method *) _wrap_gtk_text_iter_get_language},
  {"is_end",(nsp_method *) _wrap_gtk_text_iter_is_end},
  {"is_start",(nsp_method *) _wrap_gtk_text_iter_is_start},
  {"forward_char",(nsp_method *) _wrap_gtk_text_iter_forward_char},
  {"backward_char",(nsp_method *) _wrap_gtk_text_iter_backward_char},
  {"forward_chars",(nsp_method *) _wrap_gtk_text_iter_forward_chars},
  {"backward_chars",(nsp_method *) _wrap_gtk_text_iter_backward_chars},
  {"forward_line",(nsp_method *) _wrap_gtk_text_iter_forward_line},
  {"backward_line",(nsp_method *) _wrap_gtk_text_iter_backward_line},
  {"forward_lines",(nsp_method *) _wrap_gtk_text_iter_forward_lines},
  {"backward_lines",(nsp_method *) _wrap_gtk_text_iter_backward_lines},
  {"forward_word_end",(nsp_method *) _wrap_gtk_text_iter_forward_word_end},
  {"backward_word_start",(nsp_method *) _wrap_gtk_text_iter_backward_word_start},
  {"forward_word_ends",(nsp_method *) _wrap_gtk_text_iter_forward_word_ends},
  {"backward_word_starts",(nsp_method *) _wrap_gtk_text_iter_backward_word_starts},
  {"forward_visible_line",(nsp_method *) _wrap_gtk_text_iter_forward_visible_line},
  {"backward_visible_line",(nsp_method *) _wrap_gtk_text_iter_backward_visible_line},
  {"forward_visible_lines",(nsp_method *) _wrap_gtk_text_iter_forward_visible_lines},
  {"backward_visible_lines",(nsp_method *) _wrap_gtk_text_iter_backward_visible_lines},
  {"forward_visible_word_end",(nsp_method *) _wrap_gtk_text_iter_forward_visible_word_end},
  {"backward_visible_word_start",(nsp_method *) _wrap_gtk_text_iter_backward_visible_word_start},
  {"forward_visible_word_ends",(nsp_method *) _wrap_gtk_text_iter_forward_visible_word_ends},
  {"backward_visible_word_starts",(nsp_method *) _wrap_gtk_text_iter_backward_visible_word_starts},
  {"forward_sentence_end",(nsp_method *) _wrap_gtk_text_iter_forward_sentence_end},
  {"backward_sentence_start",(nsp_method *) _wrap_gtk_text_iter_backward_sentence_start},
  {"forward_sentence_ends",(nsp_method *) _wrap_gtk_text_iter_forward_sentence_ends},
  {"backward_sentence_starts",(nsp_method *) _wrap_gtk_text_iter_backward_sentence_starts},
  {"forward_cursor_position",(nsp_method *) _wrap_gtk_text_iter_forward_cursor_position},
  {"backward_cursor_position",(nsp_method *) _wrap_gtk_text_iter_backward_cursor_position},
  {"forward_cursor_positions",(nsp_method *) _wrap_gtk_text_iter_forward_cursor_positions},
  {"backward_cursor_positions",(nsp_method *) _wrap_gtk_text_iter_backward_cursor_positions},
  {"forward_visible_cursor_position",(nsp_method *) _wrap_gtk_text_iter_forward_visible_cursor_position},
  {"backward_visible_cursor_position",(nsp_method *) _wrap_gtk_text_iter_backward_visible_cursor_position},
  {"forward_visible_cursor_positions",(nsp_method *) _wrap_gtk_text_iter_forward_visible_cursor_positions},
  {"backward_visible_cursor_positions",(nsp_method *) _wrap_gtk_text_iter_backward_visible_cursor_positions},
  {"set_offset",(nsp_method *) _wrap_gtk_text_iter_set_offset},
  {"set_line",(nsp_method *) _wrap_gtk_text_iter_set_line},
  {"set_line_offset",(nsp_method *) _wrap_gtk_text_iter_set_line_offset},
  {"set_line_index",(nsp_method *) _wrap_gtk_text_iter_set_line_index},
  {"forward_to_end",(nsp_method *) _wrap_gtk_text_iter_forward_to_end},
  {"forward_to_line_end",(nsp_method *) _wrap_gtk_text_iter_forward_to_line_end},
  {"set_visible_line_offset",(nsp_method *) _wrap_gtk_text_iter_set_visible_line_offset},
  {"set_visible_line_index",(nsp_method *) _wrap_gtk_text_iter_set_visible_line_index},
  {"forward_to_tag_toggle",(nsp_method *) _wrap_gtk_text_iter_forward_to_tag_toggle},
  {"backward_to_tag_toggle",(nsp_method *) _wrap_gtk_text_iter_backward_to_tag_toggle},
  {"forward_search",(nsp_method *) _wrap_gtk_text_iter_forward_search},
  {"backward_search",(nsp_method *) _wrap_gtk_text_iter_backward_search},
  {"equal",(nsp_method *) _wrap_gtk_text_iter_equal},
  {"compare",(nsp_method *) _wrap_gtk_text_iter_compare},
  {"in_range",(nsp_method *) _wrap_gtk_text_iter_in_range},
  {"order",(nsp_method *) _wrap_gtk_text_iter_order},
  { NULL, NULL}
};

static NspMethods *gtktextiter_get_methods(void) { return gtktextiter_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktextiter_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkBorder ----------- */


#define  NspGtkBorder_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkborder.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkBorder inherits from GBoxed 
 */

int nsp_type_gtkborder_id=0;
NspTypeGtkBorder *nsp_type_gtkborder=NULL;

/*
 * Type object for NspGtkBorder 
 * all the instance of NspTypeGtkBorder share the same id. 
 * nsp_type_gtkborder: is an instance of NspTypeGtkBorder 
 *    used for objects of NspGtkBorder type (i.e built with new_gtkborder) 
 * other instances are used for derived classes 
 */
NspTypeGtkBorder *new_type_gtkborder(type_mode mode)
{
  NspTypeGtkBorder *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkborder != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkborder;
    }
  if (( type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkborder_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkborder_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkborder;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkborder */ 

  top->s_type =  (s_type_func *) nsp_gtkborder_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkborder_type_short_string;
  /* top->create = (create_func*) int_gtkborder_create;*/

  /* specific methods for gtkborder */

  type->init = (init_func *) init_gtkborder;

  /* 
   * NspGtkBorder interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkborder_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkBorder called nsp_type_gtkborder
       */
      type->id =  nsp_type_gtkborder_id = nsp_new_type_id();
      nsp_type_gtkborder = type;
      if ( nsp_register_type(nsp_type_gtkborder) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkborder, GTK_TYPE_BORDER);
      return ( mode == T_BASE ) ? type : new_type_gtkborder(mode);
    }
  else 
    {
      type->id = nsp_type_gtkborder_id;
      return type;
    }
}

/*
 * initialize NspGtkBorder instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkborder(NspGtkBorder *Obj,NspTypeGtkBorder *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkBorder 
 */

NspGtkBorder *new_gtkborder() 
{
  NspGtkBorder *loc;
  /* type must exists */
  nsp_type_gtkborder = new_type_gtkborder(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkBorder)))== NULLGTKBORDER) return loc;
  /* initialize object */
  if ( init_gtkborder(loc,nsp_type_gtkborder) == FAIL) return NULLGTKBORDER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkBorder 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkborder_type_name[]="GtkBorder";
static char gtkborder_short_type_name[]="GtkBorder";

static char *nsp_gtkborder_type_as_string(void)
{
  return(gtkborder_type_name);
}

static char *nsp_gtkborder_type_short_string(NspObject *v)
{
  return(gtkborder_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkBorder objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkBorder   *nsp_gtkborder_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkborder_id)  == TRUE  ) return ((NspGtkBorder *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkborder));
  return NULL;
}

int IsGtkBorderObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkborder_id);
}

int IsGtkBorder(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkborder_id);
}

NspGtkBorder  *GetGtkBorderCopy(Stack stack, int i)
{
  if (  GetGtkBorder(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkBorder  *GetGtkBorder(Stack stack, int i)
{
  NspGtkBorder *M;
  if (( M = nsp_gtkborder_object(NthObj(i))) == NULLGTKBORDER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkBorder *gtkborder_copy(NspGtkBorder *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtkborder);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkBorder
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_border_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_border_new())== NULL) return RET_BUG;

  nsp_type_gtkborder = new_type_gtkborder(T_BASE);
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_BORDER, ret,TRUE,TRUE,(NspTypeBase *) nsp_type_gtkborder);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_border_copy(NspGtkBorder *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkBorder *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_border_copy(NSP_GBOXED_GET(self, GtkBorder));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_BORDER, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkborder))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_border_free(NspGtkBorder *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
  gtk_border_free(NSP_GBOXED_GET(self, GtkBorder));
  return 0;
}

static NspMethods gtkborder_methods[] = {
  {"copy",(nsp_method *) _wrap_gtk_border_copy},
  {"free",(nsp_method *) _wrap_gtk_border_free},
  { NULL, NULL}
};

static NspMethods *gtkborder_get_methods(void) { return gtkborder_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkborder_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkIconInfo ----------- */


#define  NspGtkIconInfo_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkiconinfo.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkIconInfo inherits from GBoxed 
 */

int nsp_type_gtkiconinfo_id=0;
NspTypeGtkIconInfo *nsp_type_gtkiconinfo=NULL;

/*
 * Type object for NspGtkIconInfo 
 * all the instance of NspTypeGtkIconInfo share the same id. 
 * nsp_type_gtkiconinfo: is an instance of NspTypeGtkIconInfo 
 *    used for objects of NspGtkIconInfo type (i.e built with new_gtkiconinfo) 
 * other instances are used for derived classes 
 */
NspTypeGtkIconInfo *new_type_gtkiconinfo(type_mode mode)
{
  NspTypeGtkIconInfo *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkiconinfo != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkiconinfo;
    }
  if (( type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkiconinfo_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkiconinfo_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkiconinfo;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkiconinfo */ 

  top->s_type =  (s_type_func *) nsp_gtkiconinfo_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkiconinfo_type_short_string;
  /* top->create = (create_func*) int_gtkiconinfo_create;*/

  /* specific methods for gtkiconinfo */

  type->init = (init_func *) init_gtkiconinfo;

  /* 
   * NspGtkIconInfo interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkiconinfo_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIconInfo called nsp_type_gtkiconinfo
       */
      type->id =  nsp_type_gtkiconinfo_id = nsp_new_type_id();
      nsp_type_gtkiconinfo = type;
      if ( nsp_register_type(nsp_type_gtkiconinfo) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkiconinfo, GTK_TYPE_ICON_INFO);
      return ( mode == T_BASE ) ? type : new_type_gtkiconinfo(mode);
    }
  else 
    {
      type->id = nsp_type_gtkiconinfo_id;
      return type;
    }
}

/*
 * initialize NspGtkIconInfo instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkiconinfo(NspGtkIconInfo *Obj,NspTypeGtkIconInfo *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkIconInfo 
 */

NspGtkIconInfo *new_gtkiconinfo() 
{
  NspGtkIconInfo *loc;
  /* type must exists */
  nsp_type_gtkiconinfo = new_type_gtkiconinfo(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIconInfo)))== NULLGTKICONINFO) return loc;
  /* initialize object */
  if ( init_gtkiconinfo(loc,nsp_type_gtkiconinfo) == FAIL) return NULLGTKICONINFO;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkIconInfo 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkiconinfo_type_name[]="GtkIconInfo";
static char gtkiconinfo_short_type_name[]="GtkIconInfo";

static char *nsp_gtkiconinfo_type_as_string(void)
{
  return(gtkiconinfo_type_name);
}

static char *nsp_gtkiconinfo_type_short_string(NspObject *v)
{
  return(gtkiconinfo_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkIconInfo objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkIconInfo   *nsp_gtkiconinfo_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkiconinfo_id)  == TRUE  ) return ((NspGtkIconInfo *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkiconinfo));
  return NULL;
}

int IsGtkIconInfoObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkiconinfo_id);
}

int IsGtkIconInfo(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkiconinfo_id);
}

NspGtkIconInfo  *GetGtkIconInfoCopy(Stack stack, int i)
{
  if (  GetGtkIconInfo(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIconInfo  *GetGtkIconInfo(Stack stack, int i)
{
  NspGtkIconInfo *M;
  if (( M = nsp_gtkiconinfo_object(NthObj(i))) == NULLGTKICONINFO)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkIconInfo *gtkiconinfo_copy(NspGtkIconInfo *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtkiconinfo);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIconInfo
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_icon_info_new_for_pixbuf (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *icon_theme, *pixbuf;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkicontheme, &icon_theme, &nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_icon_info_new_for_pixbuf(GTK_ICON_THEME(icon_theme->obj),GDK_PIXBUF(pixbuf->obj)))== NULL) return RET_BUG;

  nsp_type_gtkiconinfo = new_type_gtkiconinfo(T_BASE);
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_INFO, ret,TRUE,TRUE,(NspTypeBase *) nsp_type_gtkiconinfo);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_icon_info_get_base_size(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_icon_info_get_base_size(NSP_GBOXED_GET(self, GtkIconInfo));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_icon_info_get_base_scale(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_icon_info_get_base_scale(NSP_GBOXED_GET(self, GtkIconInfo));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_icon_info_get_base_scale(Stack stack, int rhs, int opt, int lhs) /* get_base_scale */
{
  Scierror("Error: function gtk_icon_info_get_base_scale not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_icon_info_get_filename(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
  ret =gtk_icon_info_get_filename(NSP_GBOXED_GET(self, GtkIconInfo));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_icon_info_get_builtin_pixbuf(Stack stack, int rhs, int opt, int lhs) /* get_builtin_pixbuf */
{
  Scierror("Error: function gtk_icon_info_get_builtin_pixbuf is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_icon_info_get_builtin_pixbuf(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_icon_info_get_builtin_pixbuf(NSP_GBOXED_GET(self, GtkIconInfo));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_icon_info_is_symbolic(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_icon_info_is_symbolic(NSP_GBOXED_GET(self, GtkIconInfo));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_icon_info_is_symbolic(Stack stack, int rhs, int opt, int lhs) /* is_symbolic */
{
  Scierror("Error: function gtk_icon_info_is_symbolic not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_icon_info_load_icon(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  GError *error = NULL;
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_icon_info_load_icon(NSP_GBOXED_GET(self, GtkIconInfo),&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_icon_info_load_surface(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *for_window;
  GError *error = NULL;
  cairo_surface_t *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &for_window) == FAIL) return RET_BUG;
  ret =gtk_icon_info_load_surface(NSP_GBOXED_GET(self, GtkIconInfo),GDK_WINDOW(for_window->obj),&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,CAIRO_GOBJECT_TYPE_SURFACE, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_cairo_surface_t))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_icon_info_load_surface(Stack stack, int rhs, int opt, int lhs) /* load_surface */
{
  Scierror("Error: function gtk_icon_info_load_surface not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_icon_info_load_icon_finish(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *res;
  GError *error = NULL;
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gasyncresult, &res) == FAIL) return RET_BUG;
  ret =gtk_icon_info_load_icon_finish(NSP_GBOXED_GET(self, GtkIconInfo),G_ASYNC_RESULT(res->obj),&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_icon_info_load_icon_finish(Stack stack, int rhs, int opt, int lhs) /* load_icon_finish */
{
  Scierror("Error: function gtk_icon_info_load_icon_finish not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_icon_info_load_symbolic_for_context(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *context;
  int was_symbolic;
  GError *error = NULL;
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &was_symbolic) == FAIL) return RET_BUG;
  ret =gtk_icon_info_load_symbolic_for_context(NSP_GBOXED_GET(self, GtkIconInfo),GTK_STYLE_CONTEXT(context->obj),&was_symbolic,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_icon_info_set_raw_coordinates(Stack stack, int rhs, int opt, int lhs) /* set_raw_coordinates */
{
  Scierror("Error: function gtk_icon_info_set_raw_coordinates is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_icon_info_set_raw_coordinates(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int raw_coordinates;
  if ( GetArgs(stack,rhs,opt,T,&raw_coordinates) == FAIL) return RET_BUG;
  gtk_icon_info_set_raw_coordinates(NSP_GBOXED_GET(self, GtkIconInfo),raw_coordinates);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_icon_info_get_embedded_rect(Stack stack, int rhs, int opt, int lhs) /* get_embedded_rect */
{
  Scierror("Error: function gtk_icon_info_get_embedded_rect is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_icon_info_get_embedded_rect(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkRectangle rectangle = { 0, 0, 0, 0 };
  NspObject *nsp_rectangle;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_rectangle) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_rectangle, &rectangle))
      return RET_BUG;
  ret =gtk_icon_info_get_embedded_rect(NSP_GBOXED_GET(self, GtkIconInfo),&rectangle);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_icon_info_get_display_name(Stack stack, int rhs, int opt, int lhs) /* get_display_name */
{
  Scierror("Error: function gtk_icon_info_get_display_name is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_icon_info_get_display_name(NspGtkIconInfo *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
  ret =gtk_icon_info_get_display_name(NSP_GBOXED_GET(self, GtkIconInfo));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#endif
static NspMethods gtkiconinfo_methods[] = {
  {"get_base_size",(nsp_method *) _wrap_gtk_icon_info_get_base_size},
  {"get_base_scale",(nsp_method *) _wrap_gtk_icon_info_get_base_scale},
  {"get_filename",(nsp_method *) _wrap_gtk_icon_info_get_filename},
  {"get_builtin_pixbuf",(nsp_method *) _wrap_gtk_icon_info_get_builtin_pixbuf},
  {"is_symbolic",(nsp_method *) _wrap_gtk_icon_info_is_symbolic},
  {"load_icon",(nsp_method *) _wrap_gtk_icon_info_load_icon},
  {"load_surface",(nsp_method *) _wrap_gtk_icon_info_load_surface},
  {"load_icon_finish",(nsp_method *) _wrap_gtk_icon_info_load_icon_finish},
  {"load_symbolic_for_context",(nsp_method *) _wrap_gtk_icon_info_load_symbolic_for_context},
  {"set_raw_coordinates",(nsp_method *) _wrap_gtk_icon_info_set_raw_coordinates},
  {"get_embedded_rect",(nsp_method *) _wrap_gtk_icon_info_get_embedded_rect},
  {"get_display_name",(nsp_method *) _wrap_gtk_icon_info_get_display_name},
  { NULL, NULL}
};

static NspMethods *gtkiconinfo_get_methods(void) { return gtkiconinfo_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkiconinfo_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRequisition ----------- */


#define  NspGtkRequisition_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkrequisition.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRequisition inherits from GBoxed 
 */

int nsp_type_gtkrequisition_id=0;
NspTypeGtkRequisition *nsp_type_gtkrequisition=NULL;

/*
 * Type object for NspGtkRequisition 
 * all the instance of NspTypeGtkRequisition share the same id. 
 * nsp_type_gtkrequisition: is an instance of NspTypeGtkRequisition 
 *    used for objects of NspGtkRequisition type (i.e built with new_gtkrequisition) 
 * other instances are used for derived classes 
 */
NspTypeGtkRequisition *new_type_gtkrequisition(type_mode mode)
{
  NspTypeGtkRequisition *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkrequisition != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkrequisition;
    }
  if (( type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkrequisition_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkrequisition_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkrequisition;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkrequisition */ 

  top->s_type =  (s_type_func *) nsp_gtkrequisition_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkrequisition_type_short_string;
  /* top->create = (create_func*) int_gtkrequisition_create;*/

  /* specific methods for gtkrequisition */

  type->init = (init_func *) init_gtkrequisition;

  /* 
   * NspGtkRequisition interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkrequisition_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRequisition called nsp_type_gtkrequisition
       */
      type->id =  nsp_type_gtkrequisition_id = nsp_new_type_id();
      nsp_type_gtkrequisition = type;
      if ( nsp_register_type(nsp_type_gtkrequisition) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkrequisition, GTK_TYPE_REQUISITION);
      return ( mode == T_BASE ) ? type : new_type_gtkrequisition(mode);
    }
  else 
    {
      type->id = nsp_type_gtkrequisition_id;
      return type;
    }
}

/*
 * initialize NspGtkRequisition instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkrequisition(NspGtkRequisition *Obj,NspTypeGtkRequisition *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRequisition 
 */

NspGtkRequisition *new_gtkrequisition() 
{
  NspGtkRequisition *loc;
  /* type must exists */
  nsp_type_gtkrequisition = new_type_gtkrequisition(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRequisition)))== NULLGTKREQUISITION) return loc;
  /* initialize object */
  if ( init_gtkrequisition(loc,nsp_type_gtkrequisition) == FAIL) return NULLGTKREQUISITION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRequisition 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkrequisition_type_name[]="GtkRequisition";
static char gtkrequisition_short_type_name[]="GtkRequisition";

static char *nsp_gtkrequisition_type_as_string(void)
{
  return(gtkrequisition_type_name);
}

static char *nsp_gtkrequisition_type_short_string(NspObject *v)
{
  return(gtkrequisition_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRequisition objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRequisition   *nsp_gtkrequisition_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkrequisition_id)  == TRUE  ) return ((NspGtkRequisition *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkrequisition));
  return NULL;
}

int IsGtkRequisitionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkrequisition_id);
}

int IsGtkRequisition(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkrequisition_id);
}

NspGtkRequisition  *GetGtkRequisitionCopy(Stack stack, int i)
{
  if (  GetGtkRequisition(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRequisition  *GetGtkRequisition(Stack stack, int i)
{
  NspGtkRequisition *M;
  if (( M = nsp_gtkrequisition_object(NthObj(i))) == NULLGTKREQUISITION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkRequisition *gtkrequisition_copy(NspGtkRequisition *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtkrequisition);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRequisition
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_requisition_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_requisition_new())== NULL) return RET_BUG;

  nsp_type_gtkrequisition = new_type_gtkrequisition(T_BASE);
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_REQUISITION, ret,TRUE,TRUE,(NspTypeBase *) nsp_type_gtkrequisition);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_requisition_copy(NspGtkRequisition *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkRequisition *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_requisition_copy(NSP_GBOXED_GET(self, GtkRequisition));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_REQUISITION, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkrequisition))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_requisition_free(NspGtkRequisition *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
  gtk_requisition_free(NSP_GBOXED_GET(self, GtkRequisition));
  return 0;
}

static NspMethods gtkrequisition_methods[] = {
  {"copy",(nsp_method *) _wrap_gtk_requisition_copy},
  {"free",(nsp_method *) _wrap_gtk_requisition_free},
  { NULL, NULL}
};

static NspMethods *gtkrequisition_get_methods(void) { return gtkrequisition_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

#line 4833 "codegen-3.0/gtk.override"
static int
_wrap_gtk_requisition__set_width(NspGBoxed *self, char *attr, NspObject *value)
{
  int val;/* XXXXX gint */
  if ( IntScalar(value,&val) == FAIL) return FAIL;
  nspg_boxed_get(self, GtkRequisition)->width = val;
  return OK;
}
#line 2603 "gtk.c"
static NspObject *_wrap_gtk_requisition__get_width(NspObject *self,char *attr)
{
  int ret;
  ret = NSP_GBOXED_GET(self, GtkRequisition)->width;
  return nsp_new_double_obj((double) ret);
}

#line 4843 "codegen-3.0/gtk.override"
static int
_wrap_gtk_requisition__set_height(NspGBoxed *self, char *attr, NspObject *value)
{
  int val; /* XXXXX gint */
  if ( IntScalar(value,&val) == FAIL) return FAIL;
  nspg_boxed_get(self, GtkRequisition)->height = val;
  return 0;
}
#line 2620 "gtk.c"
static NspObject *_wrap_gtk_requisition__get_height(NspObject *self,char *attr)
{
  int ret;
  ret = NSP_GBOXED_GET(self, GtkRequisition)->height;
  return nsp_new_double_obj((double) ret);
}

static AttrTab gtkrequisition_attrs[] = {
  { "width", (attr_get_function * )_wrap_gtk_requisition__get_width, (attr_set_function * )_wrap_gtk_requisition__set_width, (attr_get_object_function * )int_get_object_failed, NULL },
  { "height", (attr_get_function * )_wrap_gtk_requisition__get_height, (attr_set_function * )_wrap_gtk_requisition__set_height, (attr_get_object_function * )int_get_object_failed, NULL },
  { NULL,NULL,NULL,NULL,NULL },
};



/* -----------NspGtkSelectionData ----------- */


#define  NspGtkSelectionData_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkselectiondata.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkSelectionData inherits from GBoxed 
 */

int nsp_type_gtkselectiondata_id=0;
NspTypeGtkSelectionData *nsp_type_gtkselectiondata=NULL;

/*
 * Type object for NspGtkSelectionData 
 * all the instance of NspTypeGtkSelectionData share the same id. 
 * nsp_type_gtkselectiondata: is an instance of NspTypeGtkSelectionData 
 *    used for objects of NspGtkSelectionData type (i.e built with new_gtkselectiondata) 
 * other instances are used for derived classes 
 */
NspTypeGtkSelectionData *new_type_gtkselectiondata(type_mode mode)
{
  NspTypeGtkSelectionData *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkselectiondata != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkselectiondata;
    }
  if (( type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkselectiondata_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkselectiondata_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkselectiondata;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkselectiondata */ 

  top->s_type =  (s_type_func *) nsp_gtkselectiondata_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkselectiondata_type_short_string;
  /* top->create = (create_func*) int_gtkselectiondata_create;*/

  /* specific methods for gtkselectiondata */

  type->init = (init_func *) init_gtkselectiondata;

  /* 
   * NspGtkSelectionData interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkselectiondata_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSelectionData called nsp_type_gtkselectiondata
       */
      type->id =  nsp_type_gtkselectiondata_id = nsp_new_type_id();
      nsp_type_gtkselectiondata = type;
      if ( nsp_register_type(nsp_type_gtkselectiondata) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkselectiondata, GTK_TYPE_SELECTION_DATA);
      return ( mode == T_BASE ) ? type : new_type_gtkselectiondata(mode);
    }
  else 
    {
      type->id = nsp_type_gtkselectiondata_id;
      return type;
    }
}

/*
 * initialize NspGtkSelectionData instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkselectiondata(NspGtkSelectionData *Obj,NspTypeGtkSelectionData *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkSelectionData 
 */

NspGtkSelectionData *new_gtkselectiondata() 
{
  NspGtkSelectionData *loc;
  /* type must exists */
  nsp_type_gtkselectiondata = new_type_gtkselectiondata(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSelectionData)))== NULLGTKSELECTIONDATA) return loc;
  /* initialize object */
  if ( init_gtkselectiondata(loc,nsp_type_gtkselectiondata) == FAIL) return NULLGTKSELECTIONDATA;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkSelectionData 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkselectiondata_type_name[]="GtkSelectionData";
static char gtkselectiondata_short_type_name[]="GtkSelectionData";

static char *nsp_gtkselectiondata_type_as_string(void)
{
  return(gtkselectiondata_type_name);
}

static char *nsp_gtkselectiondata_type_short_string(NspObject *v)
{
  return(gtkselectiondata_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkSelectionData objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkSelectionData   *nsp_gtkselectiondata_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkselectiondata_id)  == TRUE  ) return ((NspGtkSelectionData *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkselectiondata));
  return NULL;
}

int IsGtkSelectionDataObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkselectiondata_id);
}

int IsGtkSelectionData(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkselectiondata_id);
}

NspGtkSelectionData  *GetGtkSelectionDataCopy(Stack stack, int i)
{
  if (  GetGtkSelectionData(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSelectionData  *GetGtkSelectionData(Stack stack, int i)
{
  NspGtkSelectionData *M;
  if (( M = nsp_gtkselectiondata_object(NthObj(i))) == NULLGTKSELECTIONDATA)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkSelectionData *gtkselectiondata_copy(NspGtkSelectionData *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtkselectiondata);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSelectionData
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_selection_data_get_selection(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkAtom ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_selection_data_get_selection(NSP_GBOXED_GET(self, GtkSelectionData));
  if (( nsp_ret = (NspObject *) gdkatom_create(NVOID,NULL,ret,NULL))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_selection_data_get_target(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkAtom ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_selection_data_get_target(NSP_GBOXED_GET(self, GtkSelectionData));
  if (( nsp_ret = (NspObject *) gdkatom_create(NVOID,NULL,ret,NULL))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_selection_data_get_data_type(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkAtom ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_selection_data_get_data_type(NSP_GBOXED_GET(self, GtkSelectionData));
  if (( nsp_ret = (NspObject *) gdkatom_create(NVOID,NULL,ret,NULL))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_selection_data_get_format(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_selection_data_get_format(NSP_GBOXED_GET(self, GtkSelectionData));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_selection_data_get_length(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_selection_data_get_length(NSP_GBOXED_GET(self, GtkSelectionData));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_selection_data_get_display(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkDisplay *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_selection_data_get_display(NSP_GBOXED_GET(self, GtkSelectionData));
  nsp_type_gdkdisplay = new_type_gdkdisplay(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkdisplay))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 425 "codegen-3.0/gtk.override"
static int
_wrap_gtk_selection_data_set(NspGBoxed *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,string, t_end} ;
  /* static char *kwlist[] = { "type", "format", "data", NULL };*/
  NspObject *nsp_type;
  GdkAtom type;
  int format, length;
  char *data;

  if (GetArgs(stack,rhs,opt,T,&nsp_type, &format, &data) == FAIL) return RET_BUG;
  length = strlen(data);
  if (nsp_gdk_atom_from_object(nsp_type,&type) == FAIL) return RET_BUG;
  gtk_selection_data_set(nspg_boxed_get(self, GtkSelectionData),
			 type, format,(const guchar *) data, length);
  return 0;
}
#line 2911 "gtk.c"


static int _wrap_gtk_selection_data_set_text(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int, t_end};
  char *str;
  int len, ret;
  if ( GetArgs(stack,rhs,opt,T,&str, &len) == FAIL) return RET_BUG;
  ret =gtk_selection_data_set_text(NSP_GBOXED_GET(self, GtkSelectionData),str,len);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 444 "codegen-3.0/gtk.override"

static int
_wrap_gtk_selection_data_get_text(NspObject *self,Stack stack,int rhs,int opt,int lhs)
{
  guchar *ret =  gtk_selection_data_get_text(nspg_boxed_get(self, GtkSelectionData));
  if ( nsp_move_string(stack,1,(gchar *) ret,-1)== FAIL)
    {
      g_free(ret);
      return RET_BUG;
    }
  g_free(ret);
  return 1;
}

#line 2940 "gtk.c"


static int _wrap_gtk_selection_data_set_pixbuf(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *pixbuf;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
  ret =gtk_selection_data_set_pixbuf(NSP_GBOXED_GET(self, GtkSelectionData),GDK_PIXBUF(pixbuf->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_selection_data_get_pixbuf(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_selection_data_get_pixbuf(NSP_GBOXED_GET(self, GtkSelectionData));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_selection_data_set_uris(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  gchar **uris = NULL;
  NspObject *nsp_uris = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_uris) == FAIL) return RET_BUG;
  if ( IsSMat(nsp_uris))
    { uris =  ((NspSMatrix *) nsp_uris)->S;}
  else
    {
      Scierror("Error: uris should be of type SMat\n");
      return RET_BUG;
    }
  ret =gtk_selection_data_set_uris(NSP_GBOXED_GET(self, GtkSelectionData),uris);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_selection_data_get_uris(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar **ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_selection_data_get_uris(NSP_GBOXED_GET(self, GtkSelectionData));
  nsp_ret = (NspObject *) nsp_smatrix_create_from_table(ret);
  if ( nsp_ret == NULL) return RET_BUG;
  g_strfreev(ret);
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 460 "codegen-3.0/gtk.override"
static int
_wrap_gtk_selection_data_get_targets(NspObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkAtom *targets;
  gint n_atoms;
  gint i;

  NSP_LIST_DEC;

  if ( !gtk_selection_data_get_targets(nspg_boxed_get(self, GtkSelectionData), &targets, &n_atoms))
    return RET_BUG;
  NSP_LIST( for (i = 0; i < n_atoms; i++), nsp_node = (NspObject *) gdkatom_create(NVOID,NULL,targets[i],NULL));
  g_free(targets);
  MoveObj(stack,1,(NspObject *) nsp_list);
  return 1;
  NSP_LIST_CLEAN;
}

#line 3017 "gtk.c"


static int _wrap_gtk_selection_data_targets_include_text(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_selection_data_targets_include_text(NSP_GBOXED_GET(self, GtkSelectionData));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_selection_data_targets_include_rich_text(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *buffer;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextbuffer, &buffer) == FAIL) return RET_BUG;
  ret =gtk_selection_data_targets_include_rich_text(NSP_GBOXED_GET(self, GtkSelectionData),GTK_TEXT_BUFFER(buffer->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_selection_data_targets_include_image(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int writable, ret;
  if ( GetArgs(stack,rhs,opt,T,&writable) == FAIL) return RET_BUG;
  ret =gtk_selection_data_targets_include_image(NSP_GBOXED_GET(self, GtkSelectionData),writable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_selection_data_targets_include_uri(NspGtkSelectionData *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_selection_data_targets_include_uri(NSP_GBOXED_GET(self, GtkSelectionData));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkselectiondata_methods[] = {
  {"get_selection",(nsp_method *) _wrap_gtk_selection_data_get_selection},
  {"get_target",(nsp_method *) _wrap_gtk_selection_data_get_target},
  {"get_data_type",(nsp_method *) _wrap_gtk_selection_data_get_data_type},
  {"get_format",(nsp_method *) _wrap_gtk_selection_data_get_format},
  {"get_length",(nsp_method *) _wrap_gtk_selection_data_get_length},
  {"get_display",(nsp_method *) _wrap_gtk_selection_data_get_display},
  {"set",(nsp_method *) _wrap_gtk_selection_data_set},
  {"set_text",(nsp_method *) _wrap_gtk_selection_data_set_text},
  {"get_text",(nsp_method *) _wrap_gtk_selection_data_get_text},
  {"set_pixbuf",(nsp_method *) _wrap_gtk_selection_data_set_pixbuf},
  {"get_pixbuf",(nsp_method *) _wrap_gtk_selection_data_get_pixbuf},
  {"set_uris",(nsp_method *) _wrap_gtk_selection_data_set_uris},
  {"get_uris",(nsp_method *) _wrap_gtk_selection_data_get_uris},
  {"get_targets",(nsp_method *) _wrap_gtk_selection_data_get_targets},
  {"targets_include_text",(nsp_method *) _wrap_gtk_selection_data_targets_include_text},
  {"targets_include_rich_text",(nsp_method *) _wrap_gtk_selection_data_targets_include_rich_text},
  {"targets_include_image",(nsp_method *) _wrap_gtk_selection_data_targets_include_image},
  {"targets_include_uri",(nsp_method *) _wrap_gtk_selection_data_targets_include_uri},
  { NULL, NULL}
};

static NspMethods *gtkselectiondata_get_methods(void) { return gtkselectiondata_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkselectiondata_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTextAttributes ----------- */


#define  NspGtkTextAttributes_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktextattributes.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTextAttributes inherits from GBoxed 
 */

int nsp_type_gtktextattributes_id=0;
NspTypeGtkTextAttributes *nsp_type_gtktextattributes=NULL;

/*
 * Type object for NspGtkTextAttributes 
 * all the instance of NspTypeGtkTextAttributes share the same id. 
 * nsp_type_gtktextattributes: is an instance of NspTypeGtkTextAttributes 
 *    used for objects of NspGtkTextAttributes type (i.e built with new_gtktextattributes) 
 * other instances are used for derived classes 
 */
NspTypeGtkTextAttributes *new_type_gtktextattributes(type_mode mode)
{
  NspTypeGtkTextAttributes *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextattributes != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextattributes;
    }
  if (( type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextattributes_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktextattributes_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktextattributes;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktextattributes */ 

  top->s_type =  (s_type_func *) nsp_gtktextattributes_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktextattributes_type_short_string;
  /* top->create = (create_func*) int_gtktextattributes_create;*/

  /* specific methods for gtktextattributes */

  type->init = (init_func *) init_gtktextattributes;

  /* 
   * NspGtkTextAttributes interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktextattributes_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextAttributes called nsp_type_gtktextattributes
       */
      type->id =  nsp_type_gtktextattributes_id = nsp_new_type_id();
      nsp_type_gtktextattributes = type;
      if ( nsp_register_type(nsp_type_gtktextattributes) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextattributes, GTK_TYPE_TEXT_ATTRIBUTES);
      return ( mode == T_BASE ) ? type : new_type_gtktextattributes(mode);
    }
  else 
    {
      type->id = nsp_type_gtktextattributes_id;
      return type;
    }
}

/*
 * initialize NspGtkTextAttributes instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextattributes(NspGtkTextAttributes *Obj,NspTypeGtkTextAttributes *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTextAttributes 
 */

NspGtkTextAttributes *new_gtktextattributes() 
{
  NspGtkTextAttributes *loc;
  /* type must exists */
  nsp_type_gtktextattributes = new_type_gtktextattributes(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextAttributes)))== NULLGTKTEXTATTRIBUTES) return loc;
  /* initialize object */
  if ( init_gtktextattributes(loc,nsp_type_gtktextattributes) == FAIL) return NULLGTKTEXTATTRIBUTES;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTextAttributes 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktextattributes_type_name[]="GtkTextAttributes";
static char gtktextattributes_short_type_name[]="GtkTextAttributes";

static char *nsp_gtktextattributes_type_as_string(void)
{
  return(gtktextattributes_type_name);
}

static char *nsp_gtktextattributes_type_short_string(NspObject *v)
{
  return(gtktextattributes_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTextAttributes objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTextAttributes   *nsp_gtktextattributes_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktextattributes_id)  == TRUE  ) return ((NspGtkTextAttributes *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextattributes));
  return NULL;
}

int IsGtkTextAttributesObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktextattributes_id);
}

int IsGtkTextAttributes(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextattributes_id);
}

NspGtkTextAttributes  *GetGtkTextAttributesCopy(Stack stack, int i)
{
  if (  GetGtkTextAttributes(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextAttributes  *GetGtkTextAttributes(Stack stack, int i)
{
  NspGtkTextAttributes *M;
  if (( M = nsp_gtktextattributes_object(NthObj(i))) == NULLGTKTEXTATTRIBUTES)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkTextAttributes *gtktextattributes_copy(NspGtkTextAttributes *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtktextattributes);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextAttributes
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_text_attributes_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_text_attributes_new())== NULL) return RET_BUG;

  nsp_type_gtktextattributes = new_type_gtktextattributes(T_BASE);
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ATTRIBUTES, ret,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktextattributes);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_attributes_copy(NspGtkTextAttributes *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextAttributes *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_text_attributes_copy(NSP_GBOXED_GET(self, GtkTextAttributes));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ATTRIBUTES, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktextattributes))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_attributes_copy_values(NspGtkTextAttributes *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextAttributes *dest = NULL;
  NspObject *nsp_dest = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_dest) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_dest, GTK_TYPE_TEXT_ATTRIBUTES))
      dest = nspg_boxed_get(nsp_dest, GtkTextAttributes);
  else {
      Scierror( "Error: dest should be a GtkTextAttributes\n");
      return RET_BUG;
  }
  gtk_text_attributes_copy_values(NSP_GBOXED_GET(self, GtkTextAttributes),dest);
  return 0;
}

static NspMethods gtktextattributes_methods[] = {
  {"copy",(nsp_method *) _wrap_gtk_text_attributes_copy},
  {"copy_values",(nsp_method *) _wrap_gtk_text_attributes_copy_values},
  { NULL, NULL}
};

static NspMethods *gtktextattributes_get_methods(void) { return gtktextattributes_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktextattributes_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeIter ----------- */


#define  NspGtkTreeIter_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreeiter.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeIter inherits from GBoxed 
 */

int nsp_type_gtktreeiter_id=0;
NspTypeGtkTreeIter *nsp_type_gtktreeiter=NULL;

/*
 * Type object for NspGtkTreeIter 
 * all the instance of NspTypeGtkTreeIter share the same id. 
 * nsp_type_gtktreeiter: is an instance of NspTypeGtkTreeIter 
 *    used for objects of NspGtkTreeIter type (i.e built with new_gtktreeiter) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeIter *new_type_gtktreeiter(type_mode mode)
{
  NspTypeGtkTreeIter *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreeiter != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreeiter;
    }
  if (( type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreeiter_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreeiter_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreeiter;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreeiter */ 

  top->s_type =  (s_type_func *) nsp_gtktreeiter_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreeiter_type_short_string;
  /* top->create = (create_func*) int_gtktreeiter_create;*/

  /* specific methods for gtktreeiter */

  type->init = (init_func *) init_gtktreeiter;

  /* 
   * NspGtkTreeIter interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktreeiter_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeIter called nsp_type_gtktreeiter
       */
      type->id =  nsp_type_gtktreeiter_id = nsp_new_type_id();
      nsp_type_gtktreeiter = type;
      if ( nsp_register_type(nsp_type_gtktreeiter) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreeiter, GTK_TYPE_TREE_ITER);
      return ( mode == T_BASE ) ? type : new_type_gtktreeiter(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreeiter_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeIter instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreeiter(NspGtkTreeIter *Obj,NspTypeGtkTreeIter *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeIter 
 */

NspGtkTreeIter *new_gtktreeiter() 
{
  NspGtkTreeIter *loc;
  /* type must exists */
  nsp_type_gtktreeiter = new_type_gtktreeiter(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeIter)))== NULLGTKTREEITER) return loc;
  /* initialize object */
  if ( init_gtktreeiter(loc,nsp_type_gtktreeiter) == FAIL) return NULLGTKTREEITER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeIter 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreeiter_type_name[]="GtkTreeIter";
static char gtktreeiter_short_type_name[]="GtkTreeIter";

static char *nsp_gtktreeiter_type_as_string(void)
{
  return(gtktreeiter_type_name);
}

static char *nsp_gtktreeiter_type_short_string(NspObject *v)
{
  return(gtktreeiter_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeIter objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeIter   *nsp_gtktreeiter_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktreeiter_id)  == TRUE  ) return ((NspGtkTreeIter *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreeiter));
  return NULL;
}

int IsGtkTreeIterObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktreeiter_id);
}

int IsGtkTreeIter(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreeiter_id);
}

NspGtkTreeIter  *GetGtkTreeIterCopy(Stack stack, int i)
{
  if (  GetGtkTreeIter(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeIter  *GetGtkTreeIter(Stack stack, int i)
{
  NspGtkTreeIter *M;
  if (( M = nsp_gtktreeiter_object(NthObj(i))) == NULLGTKTREEITER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkTreeIter *gtktreeiter_copy(NspGtkTreeIter *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtktreeiter);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeIter
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_tree_iter_copy(NspGtkTreeIter *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_tree_iter_copy(NSP_GBOXED_GET(self, GtkTreeIter));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreeiter))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_iter_free(NspGtkTreeIter *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
  gtk_tree_iter_free(NSP_GBOXED_GET(self, GtkTreeIter));
  return 0;
}

static NspMethods gtktreeiter_methods[] = {
  {"copy",(nsp_method *) _wrap_gtk_tree_iter_copy},
  {"free",(nsp_method *) _wrap_gtk_tree_iter_free},
  { NULL, NULL}
};

static NspMethods *gtktreeiter_get_methods(void) { return gtktreeiter_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreeiter_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeRowReference ----------- */


#define  NspGtkTreeRowReference_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreerowreference.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeRowReference inherits from GBoxed 
 */

int nsp_type_gtktreerowreference_id=0;
NspTypeGtkTreeRowReference *nsp_type_gtktreerowreference=NULL;

/*
 * Type object for NspGtkTreeRowReference 
 * all the instance of NspTypeGtkTreeRowReference share the same id. 
 * nsp_type_gtktreerowreference: is an instance of NspTypeGtkTreeRowReference 
 *    used for objects of NspGtkTreeRowReference type (i.e built with new_gtktreerowreference) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeRowReference *new_type_gtktreerowreference(type_mode mode)
{
  NspTypeGtkTreeRowReference *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreerowreference != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreerowreference;
    }
  if (( type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreerowreference_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreerowreference_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreerowreference;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreerowreference */ 

  top->s_type =  (s_type_func *) nsp_gtktreerowreference_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreerowreference_type_short_string;
  /* top->create = (create_func*) int_gtktreerowreference_create;*/

  /* specific methods for gtktreerowreference */

  type->init = (init_func *) init_gtktreerowreference;

  /* 
   * NspGtkTreeRowReference interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktreerowreference_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeRowReference called nsp_type_gtktreerowreference
       */
      type->id =  nsp_type_gtktreerowreference_id = nsp_new_type_id();
      nsp_type_gtktreerowreference = type;
      if ( nsp_register_type(nsp_type_gtktreerowreference) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreerowreference, GTK_TYPE_TREE_ROW_REFERENCE);
      return ( mode == T_BASE ) ? type : new_type_gtktreerowreference(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreerowreference_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeRowReference instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreerowreference(NspGtkTreeRowReference *Obj,NspTypeGtkTreeRowReference *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeRowReference 
 */

NspGtkTreeRowReference *new_gtktreerowreference() 
{
  NspGtkTreeRowReference *loc;
  /* type must exists */
  nsp_type_gtktreerowreference = new_type_gtktreerowreference(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeRowReference)))== NULLGTKTREEROWREFERENCE) return loc;
  /* initialize object */
  if ( init_gtktreerowreference(loc,nsp_type_gtktreerowreference) == FAIL) return NULLGTKTREEROWREFERENCE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeRowReference 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreerowreference_type_name[]="GtkTreeRowReference";
static char gtktreerowreference_short_type_name[]="GtkTreeRowReference";

static char *nsp_gtktreerowreference_type_as_string(void)
{
  return(gtktreerowreference_type_name);
}

static char *nsp_gtktreerowreference_type_short_string(NspObject *v)
{
  return(gtktreerowreference_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeRowReference objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeRowReference   *nsp_gtktreerowreference_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktreerowreference_id)  == TRUE  ) return ((NspGtkTreeRowReference *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreerowreference));
  return NULL;
}

int IsGtkTreeRowReferenceObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktreerowreference_id);
}

int IsGtkTreeRowReference(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreerowreference_id);
}

NspGtkTreeRowReference  *GetGtkTreeRowReferenceCopy(Stack stack, int i)
{
  if (  GetGtkTreeRowReference(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeRowReference  *GetGtkTreeRowReference(Stack stack, int i)
{
  NspGtkTreeRowReference *M;
  if (( M = nsp_gtktreerowreference_object(NthObj(i))) == NULLGTKTREEROWREFERENCE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkTreeRowReference *gtktreerowreference_copy(NspGtkTreeRowReference *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtktreerowreference);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeRowReference
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_tree_row_reference_new_proxy (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,obj_check,obj, t_end};
  NspGObject *proxy = NULL, *model;
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gobject, &proxy, &nsp_type_gtktreemodel, &model, &nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if ((ret = (GObject *)gtk_tree_row_reference_new_proxy(G_OBJECT(proxy->obj),GTK_TREE_MODEL(model->obj),path))== NULL) return RET_BUG;

  nsp_type_gtktreerowreference = new_type_gtktreerowreference(T_BASE);
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ROW_REFERENCE, ret,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreerowreference);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_tree_row_reference_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *model;
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreemodel, &model, &nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if ((ret = (GObject *)gtk_tree_row_reference_new(GTK_TREE_MODEL(model->obj),path))== NULL) return RET_BUG;

  nsp_type_gtktreerowreference = new_type_gtktreerowreference(T_BASE);
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ROW_REFERENCE, ret,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreerowreference);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_row_reference_get_path(NspGtkTreeRowReference *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreePath *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_tree_row_reference_get_path(NSP_GBOXED_GET(self, GtkTreeRowReference));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreepath))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_row_reference_get_model(NspGtkTreeRowReference *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_tree_row_reference_get_model(NSP_GBOXED_GET(self, GtkTreeRowReference));
  nsp_type_gtktreemodel = new_type_gtktreemodel(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreemodel))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_row_reference_valid(NspGtkTreeRowReference *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_tree_row_reference_valid(NSP_GBOXED_GET(self, GtkTreeRowReference));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_row_reference_copy(NspGtkTreeRowReference *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeRowReference *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_tree_row_reference_copy(NSP_GBOXED_GET(self, GtkTreeRowReference));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ROW_REFERENCE, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreerowreference))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_row_reference_free(NspGtkTreeRowReference *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
  gtk_tree_row_reference_free(NSP_GBOXED_GET(self, GtkTreeRowReference));
  return 0;
}

static NspMethods gtktreerowreference_methods[] = {
  {"get_path",(nsp_method *) _wrap_gtk_tree_row_reference_get_path},
  {"get_model",(nsp_method *) _wrap_gtk_tree_row_reference_get_model},
  {"valid",(nsp_method *) _wrap_gtk_tree_row_reference_valid},
  {"copy",(nsp_method *) _wrap_gtk_tree_row_reference_copy},
  {"free",(nsp_method *) _wrap_gtk_tree_row_reference_free},
  { NULL, NULL}
};

static NspMethods *gtktreerowreference_get_methods(void) { return gtktreerowreference_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreerowreference_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreePath ----------- */


#define  NspGtkTreePath_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreepath.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreePath inherits from GBoxed 
 */

int nsp_type_gtktreepath_id=0;
NspTypeGtkTreePath *nsp_type_gtktreepath=NULL;

/*
 * Type object for NspGtkTreePath 
 * all the instance of NspTypeGtkTreePath share the same id. 
 * nsp_type_gtktreepath: is an instance of NspTypeGtkTreePath 
 *    used for objects of NspGtkTreePath type (i.e built with new_gtktreepath) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreePath *new_type_gtktreepath(type_mode mode)
{
  NspTypeGtkTreePath *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreepath != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreepath;
    }
  if (( type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreepath_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreepath_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreepath;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreepath */ 

  top->s_type =  (s_type_func *) nsp_gtktreepath_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreepath_type_short_string;
  /* top->create = (create_func*) int_gtktreepath_create;*/

  /* specific methods for gtktreepath */

  type->init = (init_func *) init_gtktreepath;

  /* 
   * NspGtkTreePath interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktreepath_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreePath called nsp_type_gtktreepath
       */
      type->id =  nsp_type_gtktreepath_id = nsp_new_type_id();
      nsp_type_gtktreepath = type;
      if ( nsp_register_type(nsp_type_gtktreepath) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreepath, GTK_TYPE_TREE_PATH);
      return ( mode == T_BASE ) ? type : new_type_gtktreepath(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreepath_id;
      return type;
    }
}

/*
 * initialize NspGtkTreePath instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreepath(NspGtkTreePath *Obj,NspTypeGtkTreePath *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreePath 
 */

NspGtkTreePath *new_gtktreepath() 
{
  NspGtkTreePath *loc;
  /* type must exists */
  nsp_type_gtktreepath = new_type_gtktreepath(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreePath)))== NULLGTKTREEPATH) return loc;
  /* initialize object */
  if ( init_gtktreepath(loc,nsp_type_gtktreepath) == FAIL) return NULLGTKTREEPATH;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreePath 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreepath_type_name[]="GtkTreePath";
static char gtktreepath_short_type_name[]="GtkTreePath";

static char *nsp_gtktreepath_type_as_string(void)
{
  return(gtktreepath_type_name);
}

static char *nsp_gtktreepath_type_short_string(NspObject *v)
{
  return(gtktreepath_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreePath objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreePath   *nsp_gtktreepath_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktreepath_id)  == TRUE  ) return ((NspGtkTreePath *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreepath));
  return NULL;
}

int IsGtkTreePathObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktreepath_id);
}

int IsGtkTreePath(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreepath_id);
}

NspGtkTreePath  *GetGtkTreePathCopy(Stack stack, int i)
{
  if (  GetGtkTreePath(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreePath  *GetGtkTreePath(Stack stack, int i)
{
  NspGtkTreePath *M;
  if (( M = nsp_gtktreepath_object(NthObj(i))) == NULLGTKTREEPATH)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkTreePath *gtktreepath_copy(NspGtkTreePath *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtktreepath);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreePath
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_tree_path_new_from_indices (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_int, t_end};
  int first_index;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&first_index) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_tree_path_new_from_indices(first_index))== NULL) return RET_BUG;

  nsp_type_gtktreepath = new_type_gtktreepath(T_BASE);
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 99 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_path_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(1,1);
  if ((ret = (GObject *)nsp_gtk_tree_path_from_nspobject(NthObj(1)))== NULL)
    {
      Scierror("Error: enable to create a GtkTreePath\n");
      return RET_BUG;
    }
  nsp_type_gtktreepath = new_type_gtktreepath(T_BASE);
  /* no need to copy ret here */
  nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret,FALSE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

NspObject *nsp_gtk_tree_path_to_nspobject(GtkTreePath *path)
{
  gint len, i, *indices;
  NspObject *ret;
  len = gtk_tree_path_get_depth(path);
  indices = gtk_tree_path_get_indices(path);
  if ((ret = (NspObject *) nsp_matrix_create(NVOID,'r',1,len))== NULL) return NULL;
  for (i = 0; i < len; i++) ((NspMatrix *) ret)->R[i]= indices[i];
  return ret;
}

GtkTreePath *nsp_gtk_tree_path_from_nspobject(NspObject *object)
{
  GtkTreePath *path;
  /* Follow pointer **/
  HOBJ_GET_OBJECT(object,NULL);

  if ( IsGtkTreePath(object) )
    {
      return g_boxed_copy(GTK_TYPE_TREE_PATH,nspg_boxed_get(object,GtkTreePath));
    }

  if ( IsString(object))
    {
      path = gtk_tree_path_new_from_string(((NspSMatrix *) object)->S[0]);
      return path;
    }
  else if (IsMat(object) && ((NspMatrix *) object)->rc_type == 'r')
    {
      int i;
      NspMatrix *M = (NspMatrix *) object;
      M= Mat2double (M);
      path = gtk_tree_path_new();
      for (i = 0; i < M->mn; i++)  gtk_tree_path_append_index(path,(gint) M->R[i]);
      return path;
    }
  return NULL;
}
#line 4136 "gtk.c"


static int _wrap_gtk_tree_path_to_string(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
  ret =gtk_tree_path_to_string(NSP_GBOXED_GET(self, GtkTreePath));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_tree_path_append_index(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int index_;
  if ( GetArgs(stack,rhs,opt,T,&index_) == FAIL) return RET_BUG;
  gtk_tree_path_append_index(NSP_GBOXED_GET(self, GtkTreePath),index_);
  return 0;
}

static int _wrap_gtk_tree_path_prepend_index(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int index_;
  if ( GetArgs(stack,rhs,opt,T,&index_) == FAIL) return RET_BUG;
  gtk_tree_path_prepend_index(NSP_GBOXED_GET(self, GtkTreePath),index_);
  return 0;
}

static int _wrap_gtk_tree_path_get_depth(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_tree_path_get_depth(NSP_GBOXED_GET(self, GtkTreePath));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 157 "codegen-3.0/gtk.override"

static int
_wrap_gtk_tree_path_get_indices(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreePath *path = NSP_GBOXED_GET(self, GtkTreePath);
  NspObject *ret;
  if ((ret = nsp_gtk_tree_path_to_nspobject(path))== NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 4187 "gtk.c"


static int _wrap_gtk_tree_path_get_indices_with_depth(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int depth, *ret;
  if ( GetArgs(stack,rhs,opt,T,&depth) == FAIL) return RET_BUG;
  ret =gtk_tree_path_get_indices_with_depth(NSP_GBOXED_GET(self, GtkTreePath),&depth);
  if ( nsp_move_double(stack,1,(double) *ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_path_compare(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *b = NULL;
  NspObject *nsp_b = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_b) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_b, GTK_TYPE_TREE_PATH))
      b = nspg_boxed_get(nsp_b, GtkTreePath);
  else {
      Scierror( "Error: b should be a GtkTreePath\n");
      return RET_BUG;
  }
  ret =gtk_tree_path_compare(NSP_GBOXED_GET(self, GtkTreePath),b);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_path_next(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
  gtk_tree_path_next(NSP_GBOXED_GET(self, GtkTreePath));
  return 0;
}

static int _wrap_gtk_tree_path_prev(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_tree_path_prev(NSP_GBOXED_GET(self, GtkTreePath));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_path_up(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_tree_path_up(NSP_GBOXED_GET(self, GtkTreePath));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_path_down(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
  gtk_tree_path_down(NSP_GBOXED_GET(self, GtkTreePath));
  return 0;
}

static int _wrap_gtk_tree_path_is_ancestor(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *descendant = NULL;
  NspObject *nsp_descendant = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_descendant) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_descendant, GTK_TYPE_TREE_PATH))
      descendant = nspg_boxed_get(nsp_descendant, GtkTreePath);
  else {
      Scierror( "Error: descendant should be a GtkTreePath\n");
      return RET_BUG;
  }
  ret =gtk_tree_path_is_ancestor(NSP_GBOXED_GET(self, GtkTreePath),descendant);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_path_is_descendant(NspGtkTreePath *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *ancestor = NULL;
  NspObject *nsp_ancestor = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_ancestor) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_ancestor, GTK_TYPE_TREE_PATH))
      ancestor = nspg_boxed_get(nsp_ancestor, GtkTreePath);
  else {
      Scierror( "Error: ancestor should be a GtkTreePath\n");
      return RET_BUG;
  }
  ret =gtk_tree_path_is_descendant(NSP_GBOXED_GET(self, GtkTreePath),ancestor);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktreepath_methods[] = {
  {"to_string",(nsp_method *) _wrap_gtk_tree_path_to_string},
  {"append_index",(nsp_method *) _wrap_gtk_tree_path_append_index},
  {"prepend_index",(nsp_method *) _wrap_gtk_tree_path_prepend_index},
  {"get_depth",(nsp_method *) _wrap_gtk_tree_path_get_depth},
  {"get_indices",(nsp_method *) _wrap_gtk_tree_path_get_indices},
  {"get_indices_with_depth",(nsp_method *) _wrap_gtk_tree_path_get_indices_with_depth},
  {"compare",(nsp_method *) _wrap_gtk_tree_path_compare},
  {"next",(nsp_method *) _wrap_gtk_tree_path_next},
  {"prev",(nsp_method *) _wrap_gtk_tree_path_prev},
  {"up",(nsp_method *) _wrap_gtk_tree_path_up},
  {"down",(nsp_method *) _wrap_gtk_tree_path_down},
  {"is_ancestor",(nsp_method *) _wrap_gtk_tree_path_is_ancestor},
  {"is_descendant",(nsp_method *) _wrap_gtk_tree_path_is_descendant},
  { NULL, NULL}
};

static NspMethods *gtktreepath_get_methods(void) { return gtktreepath_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreepath_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCssSection ----------- */


#define  NspGtkCssSection_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcsssection.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCssSection inherits from GBoxed 
 */

int nsp_type_gtkcsssection_id=0;
NspTypeGtkCssSection *nsp_type_gtkcsssection=NULL;

/*
 * Type object for NspGtkCssSection 
 * all the instance of NspTypeGtkCssSection share the same id. 
 * nsp_type_gtkcsssection: is an instance of NspTypeGtkCssSection 
 *    used for objects of NspGtkCssSection type (i.e built with new_gtkcsssection) 
 * other instances are used for derived classes 
 */
NspTypeGtkCssSection *new_type_gtkcsssection(type_mode mode)
{
  NspTypeGtkCssSection *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcsssection != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcsssection;
    }
  if (( type =  malloc(sizeof(NspTypeGBoxed))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gboxed(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcsssection_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcsssection_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcsssection;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcsssection */ 

  top->s_type =  (s_type_func *) nsp_gtkcsssection_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcsssection_type_short_string;
  /* top->create = (create_func*) int_gtkcsssection_create;*/

  /* specific methods for gtkcsssection */

  type->init = (init_func *) init_gtkcsssection;

  /* 
   * NspGtkCssSection interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcsssection_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCssSection called nsp_type_gtkcsssection
       */
      type->id =  nsp_type_gtkcsssection_id = nsp_new_type_id();
      nsp_type_gtkcsssection = type;
      if ( nsp_register_type(nsp_type_gtkcsssection) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcsssection, GTK_TYPE_CSS_SECTION);
      return ( mode == T_BASE ) ? type : new_type_gtkcsssection(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcsssection_id;
      return type;
    }
}

/*
 * initialize NspGtkCssSection instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcsssection(NspGtkCssSection *Obj,NspTypeGtkCssSection *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCssSection 
 */

NspGtkCssSection *new_gtkcsssection() 
{
  NspGtkCssSection *loc;
  /* type must exists */
  nsp_type_gtkcsssection = new_type_gtkcsssection(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCssSection)))== NULLGTKCSSSECTION) return loc;
  /* initialize object */
  if ( init_gtkcsssection(loc,nsp_type_gtkcsssection) == FAIL) return NULLGTKCSSSECTION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCssSection 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcsssection_type_name[]="GtkCssSection";
static char gtkcsssection_short_type_name[]="GtkCssSection";

static char *nsp_gtkcsssection_type_as_string(void)
{
  return(gtkcsssection_type_name);
}

static char *nsp_gtkcsssection_type_short_string(NspObject *v)
{
  return(gtkcsssection_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCssSection objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCssSection   *nsp_gtkcsssection_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcsssection_id)  == TRUE  ) return ((NspGtkCssSection *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcsssection));
  return NULL;
}

int IsGtkCssSectionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcsssection_id);
}

int IsGtkCssSection(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcsssection_id);
}

NspGtkCssSection  *GetGtkCssSectionCopy(Stack stack, int i)
{
  if (  GetGtkCssSection(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCssSection  *GetGtkCssSection(Stack stack, int i)
{
  NspGtkCssSection *M;
  if (( M = nsp_gtkcsssection_object(NthObj(i))) == NULLGTKCSSSECTION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for boxed 
 */

NspGtkCssSection *gtkcsssection_copy(NspGtkCssSection *self)
{
  return gboxed_create(NVOID,((NspGBoxed *) self)->gtype,((NspGBoxed *) self)->boxed, TRUE, TRUE,
                              (NspTypeBase *) nsp_type_gtkcsssection);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCssSection
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_css_section_get_section_type(NspGtkCssSection *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
  ret =gtk_css_section_get_section_type(NSP_GBOXED_GET(self, GtkCssSection));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_css_section_get_section_type(Stack stack, int rhs, int opt, int lhs) /* get_section_type */
{
  Scierror("Error: function gtk_css_section_get_section_type not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_css_section_get_parent(NspGtkCssSection *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkCssSection *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_css_section_get_parent(NSP_GBOXED_GET(self, GtkCssSection));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_CSS_SECTION, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkcsssection))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_css_section_get_parent(Stack stack, int rhs, int opt, int lhs) /* get_parent */
{
  Scierror("Error: function gtk_css_section_get_parent not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_css_section_get_file(NspGtkCssSection *self,Stack stack,int rhs,int opt,int lhs)
{
  GFile *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret =gtk_css_section_get_file(NSP_GBOXED_GET(self, GtkCssSection));
  nsp_type_gfile = new_type_gfile(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gfile))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_css_section_get_file(Stack stack, int rhs, int opt, int lhs) /* get_file */
{
  Scierror("Error: function gtk_css_section_get_file not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_css_section_get_start_line(NspGtkCssSection *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_css_section_get_start_line(NSP_GBOXED_GET(self, GtkCssSection));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_css_section_get_start_line(Stack stack, int rhs, int opt, int lhs) /* get_start_line */
{
  Scierror("Error: function gtk_css_section_get_start_line not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_css_section_get_start_position(NspGtkCssSection *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_css_section_get_start_position(NSP_GBOXED_GET(self, GtkCssSection));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_css_section_get_start_position(Stack stack, int rhs, int opt, int lhs) /* get_start_position */
{
  Scierror("Error: function gtk_css_section_get_start_position not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_css_section_get_end_line(NspGtkCssSection *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_css_section_get_end_line(NSP_GBOXED_GET(self, GtkCssSection));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_css_section_get_end_line(Stack stack, int rhs, int opt, int lhs) /* get_end_line */
{
  Scierror("Error: function gtk_css_section_get_end_line not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_css_section_get_end_position(NspGtkCssSection *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
  ret =gtk_css_section_get_end_position(NSP_GBOXED_GET(self, GtkCssSection));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_css_section_get_end_position(Stack stack, int rhs, int opt, int lhs) /* get_end_position */
{
  Scierror("Error: function gtk_css_section_get_end_position not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkcsssection_methods[] = {
  {"get_section_type",(nsp_method *) _wrap_gtk_css_section_get_section_type},
  {"get_parent",(nsp_method *) _wrap_gtk_css_section_get_parent},
  {"get_file",(nsp_method *) _wrap_gtk_css_section_get_file},
  {"get_start_line",(nsp_method *) _wrap_gtk_css_section_get_start_line},
  {"get_start_position",(nsp_method *) _wrap_gtk_css_section_get_start_position},
  {"get_end_line",(nsp_method *) _wrap_gtk_css_section_get_end_line},
  {"get_end_position",(nsp_method *) _wrap_gtk_css_section_get_end_position},
  { NULL, NULL}
};

static NspMethods *gtkcsssection_get_methods(void) { return gtkcsssection_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcsssection_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkActionable ----------- */


#define  NspGtkActionable_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkactionable.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkActionable inherits from GObject 
 */

int nsp_type_gtkactionable_id=0;
NspTypeGtkActionable *nsp_type_gtkactionable=NULL;

/*
 * Type object for NspGtkActionable 
 * all the instance of NspTypeGtkActionable share the same id. 
 * nsp_type_gtkactionable: is an instance of NspTypeGtkActionable 
 *    used for objects of NspGtkActionable type (i.e built with new_gtkactionable) 
 * other instances are used for derived classes 
 */
NspTypeGtkActionable *new_type_gtkactionable(type_mode mode)
{
  NspTypeGtkActionable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkactionable != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkactionable;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkactionable_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkactionable_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkactionable;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkactionable */ 

  top->s_type =  (s_type_func *) nsp_gtkactionable_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkactionable_type_short_string;
  /* top->create = (create_func*) int_gtkactionable_create;*/

  /* specific methods for gtkactionable */

  type->init = (init_func *) init_gtkactionable;

  /* 
   * NspGtkActionable interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkactionable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkActionable called nsp_type_gtkactionable
       */
      type->id =  nsp_type_gtkactionable_id = nsp_new_type_id();
      nsp_type_gtkactionable = type;
      if ( nsp_register_type(nsp_type_gtkactionable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkactionable, GTK_TYPE_ACTIONABLE);
      return ( mode == T_BASE ) ? type : new_type_gtkactionable(mode);
    }
  else 
    {
      type->id = nsp_type_gtkactionable_id;
      return type;
    }
}

/*
 * initialize NspGtkActionable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkactionable(NspGtkActionable *Obj,NspTypeGtkActionable *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkActionable 
 */

NspGtkActionable *new_gtkactionable() 
{
  NspGtkActionable *loc;
  /* type must exists */
  nsp_type_gtkactionable = new_type_gtkactionable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkActionable)))== NULLGTKACTIONABLE) return loc;
  /* initialize object */
  if ( init_gtkactionable(loc,nsp_type_gtkactionable) == FAIL) return NULLGTKACTIONABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkActionable 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkactionable_type_name[]="GtkActionable";
static char gtkactionable_short_type_name[]="GtkActionable";

static char *nsp_gtkactionable_type_as_string(void)
{
  return(gtkactionable_type_name);
}

static char *nsp_gtkactionable_type_short_string(NspObject *v)
{
  return(gtkactionable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkActionable objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkActionable   *nsp_gtkactionable_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkactionable_id)   ) return ((NspGtkActionable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkactionable));
  return NULL;
}

int IsGtkActionableObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkactionable_id);
}

int IsGtkActionable(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkactionable_id);
}

NspGtkActionable  *GetGtkActionableCopy(Stack stack, int i)
{
  if (  GetGtkActionable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkActionable  *GetGtkActionable(Stack stack, int i)
{
  NspGtkActionable *M;
  if (( M = nsp_gtkactionable_object(NthObj(i))) == NULLGTKACTIONABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkActionable *gtkactionable_copy(NspGtkActionable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkactionable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkactionable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkActionable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_actionable_get_action_name(NspGtkActionable *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_actionable_get_action_name(GTK_ACTIONABLE(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_actionable_get_action_name(Stack stack, int rhs, int opt, int lhs) /* get_action_name */
{
  Scierror("Error: function gtk_actionable_get_action_name not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_actionable_set_action_name(NspGtkActionable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *action_name;
  if ( GetArgs(stack,rhs,opt,T,&action_name) == FAIL) return RET_BUG;
    gtk_actionable_set_action_name(GTK_ACTIONABLE(self->obj),action_name);
  return 0;
}

#else
int _wrap_gtk_actionable_set_action_name(Stack stack, int rhs, int opt, int lhs) /* set_action_name */
{
  Scierror("Error: function gtk_actionable_set_action_name not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_actionable_get_action_target_value(NspGtkActionable *self,Stack stack,int rhs,int opt,int lhs)
{
  GVariant *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_actionable_get_action_target_value(GTK_ACTIONABLE(self->obj));
  nsp_type_gvariant= new_type_gvariant(T_BASE);
  if((ret = nsp_copy_GVariant(ret))==NULL) return RET_BUG;
  nsp_ret =(NspObject*) nsp_gvariant_create(NVOID,ret,(NspTypeBase *) nsp_type_gvariant);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_actionable_get_action_target_value(Stack stack, int rhs, int opt, int lhs) /* get_action_target_value */
{
  Scierror("Error: function gtk_actionable_get_action_target_value not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_actionable_set_action_target_value(NspGtkActionable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GVariant *target_value = NULL;
  NspObject *nsp_target_value = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_target_value) == FAIL) return RET_BUG;
  if ( IsGVariant(nsp_target_value))
    { target_value = ((NspGVariant *) nsp_target_value)->obj->value;
      if((target_value = nsp_copy_GVariant(target_value))==NULL) return RET_BUG;
    }
  else
    {
      Scierror("Error: target_value should be of type GVariant\n");
      return RET_BUG;
    }
    gtk_actionable_set_action_target_value(GTK_ACTIONABLE(self->obj),target_value);
  return 0;
}

#else
int _wrap_gtk_actionable_set_action_target_value(Stack stack, int rhs, int opt, int lhs) /* set_action_target_value */
{
  Scierror("Error: function gtk_actionable_set_action_target_value not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_actionable_set_action_target(NspGtkActionable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *format_string;
  if ( GetArgs(stack,rhs,opt,T,&format_string) == FAIL) return RET_BUG;
    gtk_actionable_set_action_target(GTK_ACTIONABLE(self->obj),format_string);
  return 0;
}

#else
int _wrap_gtk_actionable_set_action_target(Stack stack, int rhs, int opt, int lhs) /* set_action_target */
{
  Scierror("Error: function gtk_actionable_set_action_target not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_actionable_set_detailed_action_name(NspGtkActionable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *detailed_action_name;
  if ( GetArgs(stack,rhs,opt,T,&detailed_action_name) == FAIL) return RET_BUG;
    gtk_actionable_set_detailed_action_name(GTK_ACTIONABLE(self->obj),detailed_action_name);
  return 0;
}

#else
int _wrap_gtk_actionable_set_detailed_action_name(Stack stack, int rhs, int opt, int lhs) /* set_detailed_action_name */
{
  Scierror("Error: function gtk_actionable_set_detailed_action_name not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkactionable_methods[] = {
  {"get_action_name",(nsp_method *) _wrap_gtk_actionable_get_action_name},
  {"set_action_name",(nsp_method *) _wrap_gtk_actionable_set_action_name},
  {"get_action_target_value",(nsp_method *) _wrap_gtk_actionable_get_action_target_value},
  {"set_action_target_value",(nsp_method *) _wrap_gtk_actionable_set_action_target_value},
  {"set_action_target",(nsp_method *) _wrap_gtk_actionable_set_action_target},
  {"set_detailed_action_name",(nsp_method *) _wrap_gtk_actionable_set_detailed_action_name},
  { NULL, NULL}
};

static NspMethods *gtkactionable_get_methods(void) { return gtkactionable_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkactionable_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkBuildable ----------- */


#define  NspGtkBuildable_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkbuildable.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkBuildable inherits from GObject 
 */

int nsp_type_gtkbuildable_id=0;
NspTypeGtkBuildable *nsp_type_gtkbuildable=NULL;

/*
 * Type object for NspGtkBuildable 
 * all the instance of NspTypeGtkBuildable share the same id. 
 * nsp_type_gtkbuildable: is an instance of NspTypeGtkBuildable 
 *    used for objects of NspGtkBuildable type (i.e built with new_gtkbuildable) 
 * other instances are used for derived classes 
 */
NspTypeGtkBuildable *new_type_gtkbuildable(type_mode mode)
{
  NspTypeGtkBuildable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkbuildable != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkbuildable;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkbuildable_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkbuildable_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkbuildable;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkbuildable */ 

  top->s_type =  (s_type_func *) nsp_gtkbuildable_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkbuildable_type_short_string;
  /* top->create = (create_func*) int_gtkbuildable_create;*/

  /* specific methods for gtkbuildable */

  type->init = (init_func *) init_gtkbuildable;

  /* 
   * NspGtkBuildable interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkbuildable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkBuildable called nsp_type_gtkbuildable
       */
      type->id =  nsp_type_gtkbuildable_id = nsp_new_type_id();
      nsp_type_gtkbuildable = type;
      if ( nsp_register_type(nsp_type_gtkbuildable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkbuildable, GTK_TYPE_BUILDABLE);
      return ( mode == T_BASE ) ? type : new_type_gtkbuildable(mode);
    }
  else 
    {
      type->id = nsp_type_gtkbuildable_id;
      return type;
    }
}

/*
 * initialize NspGtkBuildable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkbuildable(NspGtkBuildable *Obj,NspTypeGtkBuildable *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkBuildable 
 */

NspGtkBuildable *new_gtkbuildable() 
{
  NspGtkBuildable *loc;
  /* type must exists */
  nsp_type_gtkbuildable = new_type_gtkbuildable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkBuildable)))== NULLGTKBUILDABLE) return loc;
  /* initialize object */
  if ( init_gtkbuildable(loc,nsp_type_gtkbuildable) == FAIL) return NULLGTKBUILDABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkBuildable 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkbuildable_type_name[]="GtkBuildable";
static char gtkbuildable_short_type_name[]="GtkBuildable";

static char *nsp_gtkbuildable_type_as_string(void)
{
  return(gtkbuildable_type_name);
}

static char *nsp_gtkbuildable_type_short_string(NspObject *v)
{
  return(gtkbuildable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkBuildable objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkBuildable   *nsp_gtkbuildable_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkbuildable_id)   ) return ((NspGtkBuildable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkbuildable));
  return NULL;
}

int IsGtkBuildableObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkbuildable_id);
}

int IsGtkBuildable(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkbuildable_id);
}

NspGtkBuildable  *GetGtkBuildableCopy(Stack stack, int i)
{
  if (  GetGtkBuildable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkBuildable  *GetGtkBuildable(Stack stack, int i)
{
  NspGtkBuildable *M;
  if (( M = nsp_gtkbuildable_object(NthObj(i))) == NULLGTKBUILDABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkBuildable *gtkbuildable_copy(NspGtkBuildable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbuildable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbuildable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkBuildable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_buildable_set_name(NspGtkBuildable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_buildable_set_name(GTK_BUILDABLE(self->obj),name);
  return 0;
}

static int _wrap_gtk_buildable_get_name(NspGtkBuildable *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_buildable_get_name(GTK_BUILDABLE(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_buildable_add_child(NspGtkBuildable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check,string, t_end};
  NspGObject *builder, *child = NULL;
  char *type;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkbuilder, &builder, &nsp_type_gobject, &child, &type) == FAIL) return RET_BUG;
    gtk_buildable_add_child(GTK_BUILDABLE(self->obj),GTK_BUILDER(builder->obj),G_OBJECT(child->obj),type);
  return 0;
}

static int _wrap_gtk_buildable_construct_child(NspGtkBuildable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *builder;
  char *name;
  GObject *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkbuilder, &builder, &name) == FAIL) return RET_BUG;
    ret =gtk_buildable_construct_child(GTK_BUILDABLE(self->obj),GTK_BUILDER(builder->obj),name);
  if (ret == NULL ) return RET_BUG;
  MoveObj(stack,1,NSP_OBJECT(ret));
  return 1;
}

static int _wrap_gtk_buildable_parser_finished(NspGtkBuildable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *builder;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkbuilder, &builder) == FAIL) return RET_BUG;
    gtk_buildable_parser_finished(GTK_BUILDABLE(self->obj),GTK_BUILDER(builder->obj));
  return 0;
}

static int _wrap_gtk_buildable_get_internal_child(NspGtkBuildable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *builder;
  char *childname;
  GObject *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkbuilder, &builder, &childname) == FAIL) return RET_BUG;
    ret =gtk_buildable_get_internal_child(GTK_BUILDABLE(self->obj),GTK_BUILDER(builder->obj),childname);
  if (ret == NULL ) return RET_BUG;
  MoveObj(stack,1,NSP_OBJECT(ret));
  return 1;
}

static NspMethods gtkbuildable_methods[] = {
  {"set_name",(nsp_method *) _wrap_gtk_buildable_set_name},
  {"get_name",(nsp_method *) _wrap_gtk_buildable_get_name},
  {"add_child",(nsp_method *) _wrap_gtk_buildable_add_child},
  {"construct_child",(nsp_method *) _wrap_gtk_buildable_construct_child},
  {"parser_finished",(nsp_method *) _wrap_gtk_buildable_parser_finished},
  {"get_internal_child",(nsp_method *) _wrap_gtk_buildable_get_internal_child},
  { NULL, NULL}
};

static NspMethods *gtkbuildable_get_methods(void) { return gtkbuildable_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkbuildable_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkOrientable ----------- */


#define  NspGtkOrientable_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkorientable.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkOrientable inherits from GObject 
 */

int nsp_type_gtkorientable_id=0;
NspTypeGtkOrientable *nsp_type_gtkorientable=NULL;

/*
 * Type object for NspGtkOrientable 
 * all the instance of NspTypeGtkOrientable share the same id. 
 * nsp_type_gtkorientable: is an instance of NspTypeGtkOrientable 
 *    used for objects of NspGtkOrientable type (i.e built with new_gtkorientable) 
 * other instances are used for derived classes 
 */
NspTypeGtkOrientable *new_type_gtkorientable(type_mode mode)
{
  NspTypeGtkOrientable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkorientable != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkorientable;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkorientable_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkorientable_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkorientable;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkorientable */ 

  top->s_type =  (s_type_func *) nsp_gtkorientable_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkorientable_type_short_string;
  /* top->create = (create_func*) int_gtkorientable_create;*/

  /* specific methods for gtkorientable */

  type->init = (init_func *) init_gtkorientable;

  /* 
   * NspGtkOrientable interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkorientable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkOrientable called nsp_type_gtkorientable
       */
      type->id =  nsp_type_gtkorientable_id = nsp_new_type_id();
      nsp_type_gtkorientable = type;
      if ( nsp_register_type(nsp_type_gtkorientable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkorientable, GTK_TYPE_ORIENTABLE);
      return ( mode == T_BASE ) ? type : new_type_gtkorientable(mode);
    }
  else 
    {
      type->id = nsp_type_gtkorientable_id;
      return type;
    }
}

/*
 * initialize NspGtkOrientable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkorientable(NspGtkOrientable *Obj,NspTypeGtkOrientable *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkOrientable 
 */

NspGtkOrientable *new_gtkorientable() 
{
  NspGtkOrientable *loc;
  /* type must exists */
  nsp_type_gtkorientable = new_type_gtkorientable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkOrientable)))== NULLGTKORIENTABLE) return loc;
  /* initialize object */
  if ( init_gtkorientable(loc,nsp_type_gtkorientable) == FAIL) return NULLGTKORIENTABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkOrientable 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkorientable_type_name[]="GtkOrientable";
static char gtkorientable_short_type_name[]="GtkOrientable";

static char *nsp_gtkorientable_type_as_string(void)
{
  return(gtkorientable_type_name);
}

static char *nsp_gtkorientable_type_short_string(NspObject *v)
{
  return(gtkorientable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkOrientable objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkOrientable   *nsp_gtkorientable_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkorientable_id)   ) return ((NspGtkOrientable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkorientable));
  return NULL;
}

int IsGtkOrientableObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkorientable_id);
}

int IsGtkOrientable(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkorientable_id);
}

NspGtkOrientable  *GetGtkOrientableCopy(Stack stack, int i)
{
  if (  GetGtkOrientable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkOrientable  *GetGtkOrientable(Stack stack, int i)
{
  NspGtkOrientable *M;
  if (( M = nsp_gtkorientable_object(NthObj(i))) == NULLGTKORIENTABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkOrientable *gtkorientable_copy(NspGtkOrientable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkorientable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkorientable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkOrientable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_orientable_set_orientation(NspGtkOrientable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
    gtk_orientable_set_orientation(GTK_ORIENTABLE(self->obj),orientation);
  return 0;
}

static int _wrap_gtk_orientable_get_orientation(NspGtkOrientable *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_orientable_get_orientation(GTK_ORIENTABLE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkorientable_methods[] = {
  {"set_orientation",(nsp_method *) _wrap_gtk_orientable_set_orientation},
  {"get_orientation",(nsp_method *) _wrap_gtk_orientable_get_orientation},
  { NULL, NULL}
};

static NspMethods *gtkorientable_get_methods(void) { return gtkorientable_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkorientable_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkEditable ----------- */


#define  NspGtkEditable_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkeditable.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkEditable inherits from GObject 
 */

int nsp_type_gtkeditable_id=0;
NspTypeGtkEditable *nsp_type_gtkeditable=NULL;

/*
 * Type object for NspGtkEditable 
 * all the instance of NspTypeGtkEditable share the same id. 
 * nsp_type_gtkeditable: is an instance of NspTypeGtkEditable 
 *    used for objects of NspGtkEditable type (i.e built with new_gtkeditable) 
 * other instances are used for derived classes 
 */
NspTypeGtkEditable *new_type_gtkeditable(type_mode mode)
{
  NspTypeGtkEditable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkeditable != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkeditable;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkeditable_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkeditable_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkeditable;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkeditable */ 

  top->s_type =  (s_type_func *) nsp_gtkeditable_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkeditable_type_short_string;
  /* top->create = (create_func*) int_gtkeditable_create;*/

  /* specific methods for gtkeditable */

  type->init = (init_func *) init_gtkeditable;

  /* 
   * NspGtkEditable interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkeditable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkEditable called nsp_type_gtkeditable
       */
      type->id =  nsp_type_gtkeditable_id = nsp_new_type_id();
      nsp_type_gtkeditable = type;
      if ( nsp_register_type(nsp_type_gtkeditable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkeditable, GTK_TYPE_EDITABLE);
      return ( mode == T_BASE ) ? type : new_type_gtkeditable(mode);
    }
  else 
    {
      type->id = nsp_type_gtkeditable_id;
      return type;
    }
}

/*
 * initialize NspGtkEditable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkeditable(NspGtkEditable *Obj,NspTypeGtkEditable *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkEditable 
 */

NspGtkEditable *new_gtkeditable() 
{
  NspGtkEditable *loc;
  /* type must exists */
  nsp_type_gtkeditable = new_type_gtkeditable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkEditable)))== NULLGTKEDITABLE) return loc;
  /* initialize object */
  if ( init_gtkeditable(loc,nsp_type_gtkeditable) == FAIL) return NULLGTKEDITABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkEditable 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkeditable_type_name[]="GtkEditable";
static char gtkeditable_short_type_name[]="GtkEditable";

static char *nsp_gtkeditable_type_as_string(void)
{
  return(gtkeditable_type_name);
}

static char *nsp_gtkeditable_type_short_string(NspObject *v)
{
  return(gtkeditable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkEditable objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkEditable   *nsp_gtkeditable_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkeditable_id)   ) return ((NspGtkEditable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkeditable));
  return NULL;
}

int IsGtkEditableObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkeditable_id);
}

int IsGtkEditable(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkeditable_id);
}

NspGtkEditable  *GetGtkEditableCopy(Stack stack, int i)
{
  if (  GetGtkEditable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkEditable  *GetGtkEditable(Stack stack, int i)
{
  NspGtkEditable *M;
  if (( M = nsp_gtkeditable_object(NthObj(i))) == NULLGTKEDITABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkEditable *gtkeditable_copy(NspGtkEditable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkeditable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkeditable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkEditable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_editable_select_region(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int start_pos, end_pos;
  if ( GetArgs(stack,rhs,opt,T,&start_pos, &end_pos) == FAIL) return RET_BUG;
    gtk_editable_select_region(GTK_EDITABLE(self->obj),start_pos,end_pos);
  return 0;
}

#line 3863 "codegen-3.0/gtk.override"
static int
_wrap_gtk_editable_get_selection_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int start=0, end=0;   /* n= 0; */
  CheckRhs(0,0);
  CheckLhs(0,1);
  gtk_editable_get_selection_bounds(GTK_EDITABLE(self->obj), &start, &end);
  if ( nsp_move_doubles(stack,1,1,2,(double) start,(double) end) == FAIL) return RET_BUG;
  return 1;
}

#line 5683 "gtk.c"


#line 3844 "codegen-3.0/gtk.override"

static int _wrap_gtk_editable_insert_text(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,new_opts,t_end};
  nsp_option opts[] = {
    {"position",s_int,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1}};
  char *new_text;
  int new_text_length;
  int position = 0;

  if ( GetArgs(stack,rhs,opt,T, &new_text, opts, &position) == FAIL) return RET_BUG;
  new_text_length= strlen(new_text);
  gtk_editable_insert_text(GTK_EDITABLE(self->obj), new_text,new_text_length , &position);
  if ( nsp_move_double(stack,1,(double)position) == FAIL) return RET_BUG;
  return 1;
}
#line 5704 "gtk.c"


static int _wrap_gtk_editable_delete_text(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int start_pos, end_pos;
  if ( GetArgs(stack,rhs,opt,T,&start_pos, &end_pos) == FAIL) return RET_BUG;
    gtk_editable_delete_text(GTK_EDITABLE(self->obj),start_pos,end_pos);
  return 0;
}

static int _wrap_gtk_editable_get_chars(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int start_pos, end_pos;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&start_pos, &end_pos) == FAIL) return RET_BUG;
    ret =gtk_editable_get_chars(GTK_EDITABLE(self->obj),start_pos,end_pos);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_editable_cut_clipboard(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_editable_cut_clipboard(GTK_EDITABLE(self->obj));
  return 0;
}

static int _wrap_gtk_editable_copy_clipboard(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_editable_copy_clipboard(GTK_EDITABLE(self->obj));
  return 0;
}

static int _wrap_gtk_editable_paste_clipboard(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_editable_paste_clipboard(GTK_EDITABLE(self->obj));
  return 0;
}

static int _wrap_gtk_editable_delete_selection(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_editable_delete_selection(GTK_EDITABLE(self->obj));
  return 0;
}

static int _wrap_gtk_editable_set_position(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int position;
  if ( GetArgs(stack,rhs,opt,T,&position) == FAIL) return RET_BUG;
    gtk_editable_set_position(GTK_EDITABLE(self->obj),position);
  return 0;
}

static int _wrap_gtk_editable_get_position(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_editable_get_position(GTK_EDITABLE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_editable_set_editable(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int is_editable;
  if ( GetArgs(stack,rhs,opt,T,&is_editable) == FAIL) return RET_BUG;
    gtk_editable_set_editable(GTK_EDITABLE(self->obj),is_editable);
  return 0;
}

static int _wrap_gtk_editable_get_editable(NspGtkEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_editable_get_editable(GTK_EDITABLE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkeditable_methods[] = {
  {"select_region",(nsp_method *) _wrap_gtk_editable_select_region},
  {"get_selection_bounds",(nsp_method *) _wrap_gtk_editable_get_selection_bounds},
  {"insert_text",(nsp_method *) _wrap_gtk_editable_insert_text},
  {"delete_text",(nsp_method *) _wrap_gtk_editable_delete_text},
  {"get_chars",(nsp_method *) _wrap_gtk_editable_get_chars},
  {"cut_clipboard",(nsp_method *) _wrap_gtk_editable_cut_clipboard},
  {"copy_clipboard",(nsp_method *) _wrap_gtk_editable_copy_clipboard},
  {"paste_clipboard",(nsp_method *) _wrap_gtk_editable_paste_clipboard},
  {"delete_selection",(nsp_method *) _wrap_gtk_editable_delete_selection},
  {"set_position",(nsp_method *) _wrap_gtk_editable_set_position},
  {"get_position",(nsp_method *) _wrap_gtk_editable_get_position},
  {"set_editable",(nsp_method *) _wrap_gtk_editable_set_editable},
  {"get_editable",(nsp_method *) _wrap_gtk_editable_get_editable},
  { NULL, NULL}
};

static NspMethods *gtkeditable_get_methods(void) { return gtkeditable_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkeditable_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeModel ----------- */


#define  NspGtkTreeModel_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreemodel.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeModel inherits from GObject 
 */

int nsp_type_gtktreemodel_id=0;
NspTypeGtkTreeModel *nsp_type_gtktreemodel=NULL;

/*
 * Type object for NspGtkTreeModel 
 * all the instance of NspTypeGtkTreeModel share the same id. 
 * nsp_type_gtktreemodel: is an instance of NspTypeGtkTreeModel 
 *    used for objects of NspGtkTreeModel type (i.e built with new_gtktreemodel) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeModel *new_type_gtktreemodel(type_mode mode)
{
  NspTypeGtkTreeModel *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreemodel != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreemodel;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreemodel_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreemodel_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreemodel;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreemodel */ 

  top->s_type =  (s_type_func *) nsp_gtktreemodel_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreemodel_type_short_string;
  /* top->create = (create_func*) int_gtktreemodel_create;*/

  /* specific methods for gtktreemodel */

  type->init = (init_func *) init_gtktreemodel;

  /* 
   * NspGtkTreeModel interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktreemodel_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeModel called nsp_type_gtktreemodel
       */
      type->id =  nsp_type_gtktreemodel_id = nsp_new_type_id();
      nsp_type_gtktreemodel = type;
      if ( nsp_register_type(nsp_type_gtktreemodel) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreemodel, GTK_TYPE_TREE_MODEL);
      return ( mode == T_BASE ) ? type : new_type_gtktreemodel(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreemodel_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeModel instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreemodel(NspGtkTreeModel *Obj,NspTypeGtkTreeModel *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeModel 
 */

NspGtkTreeModel *new_gtktreemodel() 
{
  NspGtkTreeModel *loc;
  /* type must exists */
  nsp_type_gtktreemodel = new_type_gtktreemodel(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeModel)))== NULLGTKTREEMODEL) return loc;
  /* initialize object */
  if ( init_gtktreemodel(loc,nsp_type_gtktreemodel) == FAIL) return NULLGTKTREEMODEL;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeModel 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreemodel_type_name[]="GtkTreeModel";
static char gtktreemodel_short_type_name[]="GtkTreeModel";

static char *nsp_gtktreemodel_type_as_string(void)
{
  return(gtktreemodel_type_name);
}

static char *nsp_gtktreemodel_type_short_string(NspObject *v)
{
  return(gtktreemodel_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeModel objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeModel   *nsp_gtktreemodel_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtktreemodel_id)   ) return ((NspGtkTreeModel *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreemodel));
  return NULL;
}

int IsGtkTreeModelObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtktreemodel_id);
}

int IsGtkTreeModel(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtktreemodel_id);
}

NspGtkTreeModel  *GetGtkTreeModelCopy(Stack stack, int i)
{
  if (  GetGtkTreeModel(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeModel  *GetGtkTreeModel(Stack stack, int i)
{
  NspGtkTreeModel *M;
  if (( M = nsp_gtktreemodel_object(NthObj(i))) == NULLGTKTREEMODEL)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeModel *gtktreemodel_copy(NspGtkTreeModel *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreemodel);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreemodel);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeModel
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_tree_model_get_flags(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_tree_model_get_flags(GTK_TREE_MODEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_model_get_n_columns(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 1492 "codegen-3.0/gtk.override"
/* changed so as to return a NspType */
static int _wrap_gtk_tree_model_get_column_type(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  NspTypeBase *type;
  int_types T[] = {s_int,t_end};
  int index;
  GType ret;
  if ( GetArgs(stack,rhs,opt,T,&index) == FAIL) return RET_BUG;
  ret = gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj), index);
  type = nsp_type_from_gtype(ret);
  if ( type == NULL)
    {
      Scierror("get type in gtype failed for gtype %s \n",g_type_name(ret));
      return RET_BUG;
    }
  if ((nsp_ret = (NspObject *) type_create(NVOID,type ,NULL))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 6048 "gtk.c"


#line 1515 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_model_get_iter(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "path", NULL };*/
  int_types T[] = {obj, t_end} ;
  NspObject *nsp_path;
  GtkTreeIter iter;
  GtkTreePath *path;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T,&nsp_path)== FAIL) return RET_BUG;

  path = nsp_gtk_tree_path_from_nspobject(nsp_path);
  if (!path) {
    Scierror( "GtkTreeModel.get_iter requires a tree path as its argument");
    return RET_BUG;
  }

  if (gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter, path)) {
    gtk_tree_path_free(path);
    if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL) return RET_BUG;
    MoveObj(stack,1,ret);
    return 1;
  } else {
    gtk_tree_path_free(path);
    Scierror("invalid tree path");
    return RET_BUG;
  }
}
#line 6081 "gtk.c"


#line 1546 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_model_get_iter_from_string(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end} ;
  /* static char *kwlist[] = { "path_string", NULL };*/
  const gchar *path_string;
  GtkTreeIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &path_string)== FAIL) return RET_BUG;

  if (gtk_tree_model_get_iter_from_string(GTK_TREE_MODEL(self->obj), &iter,
					  path_string)) {
    if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
    MoveObj(stack,1,ret);
    return 1;
  } else {
    Scierror("invalid tree path");
    return RET_BUG;
  }
}
#line 6106 "gtk.c"


static int _wrap_gtk_tree_model_get_string_from_iter(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_model_get_string_from_iter(GTK_TREE_MODEL(self->obj),iter);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

#line 2352 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_model_get_iter_first(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  NspObject *ret;
  if (gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->obj), &iter))
    {
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
	return RET_BUG;
      MoveObj(stack,1,ret);
    }
  else
    {
      if ((ret= (NspObject *) nsp_none_create(NVOID,NULL))  == NULL)
	return RET_BUG;
      MoveObj(stack,1,ret);
    }
  return 1;
}
#line 6148 "gtk.c"


static int _wrap_gtk_tree_model_get_path(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL, *nsp_ret;
  GtkTreePath *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_model_get_path(GTK_TREE_MODEL(self->obj),iter);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreepath))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 1569 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_model_get_value(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { obj_check,s_int, t_end} ;
  /* static char *kwlist[] = { "iter", "column", NULL };*/
  NspObject *iter, *ret;
  gint column;
  GValue value = { 0, };

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeiter, &iter, &column)== FAIL) return RET_BUG;
  if (column < 0 ||
      column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
    Scierror("column number is out of range");
    return RET_BUG;
  }

  gtk_tree_model_get_value(GTK_TREE_MODEL(self->obj),
			   nspg_boxed_get(iter, GtkTreeIter), column, &value);
  ret = nspg_value_as_nspobject(&value, TRUE);
  g_value_unset(&value);
  if ( ret == NULLOBJ )
    {
      Scierror("Error: get_value method return a NULL Object \n");
      return RET_BUG;
    }
  MoveObj(stack,1,ret);
  return 1;
}
#line 6201 "gtk.c"


static int _wrap_gtk_tree_model_iter_previous(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_model_iter_previous(GTK_TREE_MODEL(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 2373 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_model_iter_next(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end} ;
  int rep;
  /* static char *kwlist[] = { "iter", NULL };*/
  NspObject *nsp_iter;
  GtkTreeIter *iter;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeiter, &nsp_iter)== FAIL) return RET_BUG;
  iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  if ( iter->user_data == NULL)
    rep = FALSE;
  else
    rep =  gtk_tree_model_iter_next(GTK_TREE_MODEL(self->obj), iter);
  if ( nsp_move_boolean(stack,1,rep)==FAIL) return RET_BUG;
  return 1;
}
#line 6241 "gtk.c"


#line 2393 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_model_iter_children(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "parent", NULL };*/
  NspGtkTreeIter *nsp_parent;
  GtkTreeIter iter, *parent = NULL;

  if (GetArgs(stack,rhs,opt,T, &nsp_parent) == FAIL) return RET_BUG;
  if (nspg_boxed_check((NspObject *) nsp_parent, GTK_TYPE_TREE_ITER))
    parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
  else {
    Scierror( "parent should be a GtkTreeIter");
    return RET_BUG;
  }

  if (gtk_tree_model_iter_children(GTK_TREE_MODEL(self->obj),
				   &iter, parent))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  else {
    return RET_BUG;
  }
}
#line 6273 "gtk.c"


static int _wrap_gtk_tree_model_iter_has_child(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_model_iter_has_child(GTK_TREE_MODEL(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_model_iter_n_children(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"iter",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_iter) == FAIL) return RET_BUG;
  if ( nsp_iter != NULL ) {
    if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
    else if (! IsNone(nsp_iter)) {
      Scierror("Error: iter should be a GtkTreeIter or None\n");
      return RET_BUG;
    }
  }
    ret =gtk_tree_model_iter_n_children(GTK_TREE_MODEL(self->obj),iter);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 2423 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_model_iter_nth_child(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int, t_end} ;
  /* static char *kwlist[] = { "parent", "n", NULL };*/
  NspObject *nsp_parent;
  gint n;
  GtkTreeIter iter, *parent = NULL;
  if (GetArgs(stack,rhs,opt,T,&nsp_parent, &n) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_parent, GTK_TYPE_TREE_ITER))
    parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
  else if ( IsNone(nsp_parent))
    parent = NULL;
  else {
    Scierror( "parent should be a GtkTreeIter or None");
    return RET_BUG;
  }

  if (gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(self->obj),
				    &iter, parent, n))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  else
    return RET_BUG;
}
#line 6347 "gtk.c"


#line 2454 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_model_iter_parent(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "child", NULL };*/
  NspObject *nsp_child;
  GtkTreeIter iter, *child = NULL;

  if (GetArgs(stack,rhs,opt,T, &nsp_child)== FAIL ) return RET_BUG;

  if (nspg_boxed_check(nsp_child, GTK_TYPE_TREE_ITER))
    child = nspg_boxed_get(nsp_child, GtkTreeIter);
  else {
    Scierror( "child should be a GtkTreeIter");
    return RET_BUG;
  }

  if (gtk_tree_model_iter_parent(GTK_TREE_MODEL(self->obj),
				 &iter, child))
    {
      NspObject *ret;
      if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  else {
    return RET_BUG;
  }
}
#line 6380 "gtk.c"


static int _wrap_gtk_tree_model_ref_node(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_model_ref_node(GTK_TREE_MODEL(self->obj),iter);
  return 0;
}

static int _wrap_gtk_tree_model_unref_node(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_model_unref_node(GTK_TREE_MODEL(self->obj),iter);
  return 0;
}

static int _wrap_gtk_tree_model_get(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_model_get(GTK_TREE_MODEL(self->obj),iter);
  return 0;
}

#line 2485 "codegen-3.0/gtk.override"

static gboolean
nspgtk_tree_foreach_marshal(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter,  gpointer data)
{
  NspObject *args[4];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 0,nargs = 3;
  gboolean ret = FALSE;

  nspg_block_threads();
  /* Il faut ici proteger les args avec des noms et
   * viter de les construire a chaque itration .... XXXXXX
   */

  args[0] = (NspObject *) gobject_create("model",(GObject *)model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[1] = (NspObject *) gboxed_create("path",GTK_TYPE_TREE_PATH,path,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
  args[2] = (NspObject *) gboxed_create("iter",GTK_TYPE_TREE_ITER, iter,TRUE, TRUE,nsp_type_gtktreeiter);
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL ) goto end;
  if (cunote->data)
    {
      args[3]= cunote->data;
      nargs= 4;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL)
    goto end;

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  goto end;
 end:
  {
    nspg_unblock_threads();
    return ret;
  }
}

static int
_wrap_gtk_tree_model_foreach(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify cunote;

  CheckRhs(1,2);

  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /* extra arguments **/
  if ( rhs == 2 )
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }
  cunote.func = func;
  cunote.data = arg;
  gtk_tree_model_foreach(GTK_TREE_MODEL(self->obj), nspgtk_tree_foreach_marshal, &cunote);
  /* XXXX detecter les erreurs ? */
  return 0;
}
#line 6491 "gtk.c"


static int _wrap_gtk_tree_model_row_changed(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_iter = NULL;
  GtkTreeIter *iter = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_model_row_changed(GTK_TREE_MODEL(self->obj),path,iter);
  return 0;
}

static int _wrap_gtk_tree_model_row_inserted(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_iter = NULL;
  GtkTreeIter *iter = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_model_row_inserted(GTK_TREE_MODEL(self->obj),path,iter);
  return 0;
}

static int _wrap_gtk_tree_model_row_has_child_toggled(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_iter = NULL;
  GtkTreeIter *iter = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_model_row_has_child_toggled(GTK_TREE_MODEL(self->obj),path,iter);
  return 0;
}

static int _wrap_gtk_tree_model_row_deleted(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_tree_model_row_deleted(GTK_TREE_MODEL(self->obj),path);
  return 0;
}

static int _wrap_gtk_tree_model_rows_reordered(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj,s_int, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_iter = NULL;
  GtkTreeIter *iter = NULL;
  int new_order;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_iter, &new_order) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_model_rows_reordered(GTK_TREE_MODEL(self->obj),path,iter,&new_order);
  return 0;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_tree_model_rows_reordered_with_length(NspGtkTreeModel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj,s_int,s_int, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_iter = NULL;
  GtkTreeIter *iter = NULL;
  int new_order, length;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_iter, &new_order, &length) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_model_rows_reordered_with_length(GTK_TREE_MODEL(self->obj),path,iter,&new_order,length);
  return 0;
}

#else
int _wrap_gtk_tree_model_rows_reordered_with_length(Stack stack, int rhs, int opt, int lhs) /* rows_reordered_with_length */
{
  Scierror("Error: function gtk_tree_model_rows_reordered_with_length not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtktreemodel_methods[] = {
  {"get_flags",(nsp_method *) _wrap_gtk_tree_model_get_flags},
  {"get_n_columns",(nsp_method *) _wrap_gtk_tree_model_get_n_columns},
  {"get_column_type",(nsp_method *) _wrap_gtk_tree_model_get_column_type},
  {"get_iter",(nsp_method *) _wrap_gtk_tree_model_get_iter},
  {"get_iter_from_string",(nsp_method *) _wrap_gtk_tree_model_get_iter_from_string},
  {"get_string_from_iter",(nsp_method *) _wrap_gtk_tree_model_get_string_from_iter},
  {"get_iter_first",(nsp_method *) _wrap_gtk_tree_model_get_iter_first},
  {"get_path",(nsp_method *) _wrap_gtk_tree_model_get_path},
  {"get_value",(nsp_method *) _wrap_gtk_tree_model_get_value},
  {"iter_previous",(nsp_method *) _wrap_gtk_tree_model_iter_previous},
  {"iter_next",(nsp_method *) _wrap_gtk_tree_model_iter_next},
  {"iter_children",(nsp_method *) _wrap_gtk_tree_model_iter_children},
  {"iter_has_child",(nsp_method *) _wrap_gtk_tree_model_iter_has_child},
  {"iter_n_children",(nsp_method *) _wrap_gtk_tree_model_iter_n_children},
  {"iter_nth_child",(nsp_method *) _wrap_gtk_tree_model_iter_nth_child},
  {"iter_parent",(nsp_method *) _wrap_gtk_tree_model_iter_parent},
  {"ref_node",(nsp_method *) _wrap_gtk_tree_model_ref_node},
  {"unref_node",(nsp_method *) _wrap_gtk_tree_model_unref_node},
  {"get",(nsp_method *) _wrap_gtk_tree_model_get},
  {"foreach",(nsp_method *) _wrap_gtk_tree_model_foreach},
  {"row_changed",(nsp_method *) _wrap_gtk_tree_model_row_changed},
  {"row_inserted",(nsp_method *) _wrap_gtk_tree_model_row_inserted},
  {"row_has_child_toggled",(nsp_method *) _wrap_gtk_tree_model_row_has_child_toggled},
  {"row_deleted",(nsp_method *) _wrap_gtk_tree_model_row_deleted},
  {"rows_reordered",(nsp_method *) _wrap_gtk_tree_model_rows_reordered},
  {"rows_reordered_with_length",(nsp_method *) _wrap_gtk_tree_model_rows_reordered_with_length},
  { NULL, NULL}
};

static NspMethods *gtktreemodel_get_methods(void) { return gtktreemodel_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreemodel_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeSortable ----------- */


#define  NspGtkTreeSortable_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreesortable.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeSortable inherits from GObject 
 */

int nsp_type_gtktreesortable_id=0;
NspTypeGtkTreeSortable *nsp_type_gtktreesortable=NULL;

/*
 * Type object for NspGtkTreeSortable 
 * all the instance of NspTypeGtkTreeSortable share the same id. 
 * nsp_type_gtktreesortable: is an instance of NspTypeGtkTreeSortable 
 *    used for objects of NspGtkTreeSortable type (i.e built with new_gtktreesortable) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeSortable *new_type_gtktreesortable(type_mode mode)
{
  NspTypeGtkTreeSortable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreesortable != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreesortable;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreesortable_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreesortable_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreesortable;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreesortable */ 

  top->s_type =  (s_type_func *) nsp_gtktreesortable_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreesortable_type_short_string;
  /* top->create = (create_func*) int_gtktreesortable_create;*/

  /* specific methods for gtktreesortable */

  type->init = (init_func *) init_gtktreesortable;

  /* 
   * NspGtkTreeSortable interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktreesortable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeSortable called nsp_type_gtktreesortable
       */
      type->id =  nsp_type_gtktreesortable_id = nsp_new_type_id();
      nsp_type_gtktreesortable = type;
      if ( nsp_register_type(nsp_type_gtktreesortable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreesortable, GTK_TYPE_TREE_SORTABLE);
      return ( mode == T_BASE ) ? type : new_type_gtktreesortable(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreesortable_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeSortable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreesortable(NspGtkTreeSortable *Obj,NspTypeGtkTreeSortable *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeSortable 
 */

NspGtkTreeSortable *new_gtktreesortable() 
{
  NspGtkTreeSortable *loc;
  /* type must exists */
  nsp_type_gtktreesortable = new_type_gtktreesortable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeSortable)))== NULLGTKTREESORTABLE) return loc;
  /* initialize object */
  if ( init_gtktreesortable(loc,nsp_type_gtktreesortable) == FAIL) return NULLGTKTREESORTABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeSortable 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreesortable_type_name[]="GtkTreeSortable";
static char gtktreesortable_short_type_name[]="GtkTreeSortable";

static char *nsp_gtktreesortable_type_as_string(void)
{
  return(gtktreesortable_type_name);
}

static char *nsp_gtktreesortable_type_short_string(NspObject *v)
{
  return(gtktreesortable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeSortable objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeSortable   *nsp_gtktreesortable_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtktreesortable_id)   ) return ((NspGtkTreeSortable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreesortable));
  return NULL;
}

int IsGtkTreeSortableObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtktreesortable_id);
}

int IsGtkTreeSortable(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtktreesortable_id);
}

NspGtkTreeSortable  *GetGtkTreeSortableCopy(Stack stack, int i)
{
  if (  GetGtkTreeSortable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeSortable  *GetGtkTreeSortable(Stack stack, int i)
{
  NspGtkTreeSortable *M;
  if (( M = nsp_gtktreesortable_object(NthObj(i))) == NULLGTKTREESORTABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeSortable *gtktreesortable_copy(NspGtkTreeSortable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreesortable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreesortable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeSortable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_tree_sortable_sort_column_changed(NspGtkTreeSortable *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_sortable_sort_column_changed(GTK_TREE_SORTABLE(self->obj));
  return 0;
}

#line 1685 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_sortable_get_sort_column_id(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gboolean ret;
  gint sort_column_id, n=0;
  GtkSortType order;

  ret = gtk_tree_sortable_get_sort_column_id(GTK_TREE_SORTABLE(self->obj),
					     &sort_column_id, &order);
  if (ret) n = 2;
  if ( nsp_move_doubles(stack,1,1,n,(double) sort_column_id,(double) order) == FAIL) return RET_BUG;
  return 1;
}
#line 6885 "gtk.c"


static int _wrap_gtk_tree_sortable_set_sort_column_id(NspGtkTreeSortable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,obj, t_end};
  int sort_column_id;
  GtkSortType order;
  NspObject *nsp_order = NULL;
  if ( GetArgs(stack,rhs,opt,T,&sort_column_id, &nsp_order) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SORT_TYPE, nsp_order, &order)== FAIL)
      return RET_BUG;
    gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->obj),sort_column_id,order);
  return 0;
}

#line 1700 "codegen-3.0/gtk.override"
static gint
nspgtk_tree_sortable_sort_cb(GtkTreeModel *model, GtkTreeIter *iter1,
			     GtkTreeIter *iter2, gpointer user_data)
{
  NspObject *args[4];
  NspGtkCustomNotify *cunote = user_data;
  NspObject *nsp_ret;
  int nret = 0,nargs = 3;
  gint ret = 0;

  nspg_block_threads();

  args[0] = (NspObject *) gobject_create("model",(GObject *)model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[1] = (NspObject *) gboxed_create("iter1",GTK_TYPE_TREE_ITER, iter1,TRUE, TRUE,nsp_type_gtktreeiter);
  args[2] = (NspObject *) gboxed_create("iter2",GTK_TYPE_TREE_ITER, iter2,TRUE, TRUE,nsp_type_gtktreeiter);
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL ) goto end;
  if (cunote->data)
    {
      args[3]= cunote->data;
      nargs= 4;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL)
    goto end;

  if (nret ==1 && IsMat(nsp_ret) && ((NspMatrix *) nsp_ret)->mn==1 && ((NspMatrix *) nsp_ret)->rc_type == 'r' )
    ret =  ((NspMatrix *) nsp_ret)->R[0];
  goto end;
 end:
  {
    nspg_unblock_threads();
    return ret;
  }
}

static int
_wrap_gtk_tree_sortable_set_sort_func(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint column;
  NspObject *nsp_func, *nsp_arg = NULL;
  NspGtkCustomNotify *cunote;
  CheckRhs(2,3);
  if ( GetScalarInt(stack,1,&column) == FAIL) return RET_BUG;
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,2)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"tree_foreach")== FAIL)) return RET_BUG;
  /* extra arguments **/
  if ( rhs == 3 )
    {
      if (( nsp_arg = (NspObject *) GetListCopy(stack,3)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;
  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(self->obj), column,
				  nspgtk_tree_sortable_sort_cb, cunote,
				  nspgtk_custom_destroy_notify);
  return 0;
}

#line 6961 "gtk.c"


#line 1761 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_sortable_set_default_sort_func(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_func, *nsp_arg = NULL;
  NspGtkCustomNotify *cunote;
  CheckRhs(1,2);
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"tree_foreach")== FAIL)) return RET_BUG;
  /* extra arguments **/
  if ( rhs == 2 )
    {
      if (( nsp_arg = (NspObject *) GetListCopy(stack,2)) == NULL) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;
  gtk_tree_sortable_set_default_sort_func(GTK_TREE_SORTABLE(self->obj),
					  nspgtk_tree_sortable_sort_cb,
					  cunote,
					  nspgtk_custom_destroy_notify);
  return 0;
}
#line 6988 "gtk.c"


static int _wrap_gtk_tree_sortable_has_default_sort_func(NspGtkTreeSortable *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_sortable_has_default_sort_func(GTK_TREE_SORTABLE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktreesortable_methods[] = {
  {"sort_column_changed",(nsp_method *) _wrap_gtk_tree_sortable_sort_column_changed},
  {"get_sort_column_id",(nsp_method *) _wrap_gtk_tree_sortable_get_sort_column_id},
  {"set_sort_column_id",(nsp_method *) _wrap_gtk_tree_sortable_set_sort_column_id},
  {"set_sort_func",(nsp_method *) _wrap_gtk_tree_sortable_set_sort_func},
  {"set_default_sort_func",(nsp_method *) _wrap_gtk_tree_sortable_set_default_sort_func},
  {"has_default_sort_func",(nsp_method *) _wrap_gtk_tree_sortable_has_default_sort_func},
  { NULL, NULL}
};

static NspMethods *gtktreesortable_get_methods(void) { return gtktreesortable_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreesortable_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellLayout ----------- */


#define  NspGtkCellLayout_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcelllayout.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellLayout inherits from GObject 
 */

int nsp_type_gtkcelllayout_id=0;
NspTypeGtkCellLayout *nsp_type_gtkcelllayout=NULL;

/*
 * Type object for NspGtkCellLayout 
 * all the instance of NspTypeGtkCellLayout share the same id. 
 * nsp_type_gtkcelllayout: is an instance of NspTypeGtkCellLayout 
 *    used for objects of NspGtkCellLayout type (i.e built with new_gtkcelllayout) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellLayout *new_type_gtkcelllayout(type_mode mode)
{
  NspTypeGtkCellLayout *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcelllayout != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcelllayout;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcelllayout_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcelllayout_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcelllayout;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcelllayout */ 

  top->s_type =  (s_type_func *) nsp_gtkcelllayout_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcelllayout_type_short_string;
  /* top->create = (create_func*) int_gtkcelllayout_create;*/

  /* specific methods for gtkcelllayout */

  type->init = (init_func *) init_gtkcelllayout;

  /* 
   * NspGtkCellLayout interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcelllayout_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellLayout called nsp_type_gtkcelllayout
       */
      type->id =  nsp_type_gtkcelllayout_id = nsp_new_type_id();
      nsp_type_gtkcelllayout = type;
      if ( nsp_register_type(nsp_type_gtkcelllayout) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcelllayout, GTK_TYPE_CELL_LAYOUT);
      return ( mode == T_BASE ) ? type : new_type_gtkcelllayout(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcelllayout_id;
      return type;
    }
}

/*
 * initialize NspGtkCellLayout instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcelllayout(NspGtkCellLayout *Obj,NspTypeGtkCellLayout *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellLayout 
 */

NspGtkCellLayout *new_gtkcelllayout() 
{
  NspGtkCellLayout *loc;
  /* type must exists */
  nsp_type_gtkcelllayout = new_type_gtkcelllayout(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellLayout)))== NULLGTKCELLLAYOUT) return loc;
  /* initialize object */
  if ( init_gtkcelllayout(loc,nsp_type_gtkcelllayout) == FAIL) return NULLGTKCELLLAYOUT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellLayout 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcelllayout_type_name[]="GtkCellLayout";
static char gtkcelllayout_short_type_name[]="GtkCellLayout";

static char *nsp_gtkcelllayout_type_as_string(void)
{
  return(gtkcelllayout_type_name);
}

static char *nsp_gtkcelllayout_type_short_string(NspObject *v)
{
  return(gtkcelllayout_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellLayout objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellLayout   *nsp_gtkcelllayout_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkcelllayout_id)   ) return ((NspGtkCellLayout *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcelllayout));
  return NULL;
}

int IsGtkCellLayoutObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkcelllayout_id);
}

int IsGtkCellLayout(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkcelllayout_id);
}

NspGtkCellLayout  *GetGtkCellLayoutCopy(Stack stack, int i)
{
  if (  GetGtkCellLayout(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellLayout  *GetGtkCellLayout(Stack stack, int i)
{
  NspGtkCellLayout *M;
  if (( M = nsp_gtkcelllayout_object(NthObj(i))) == NULLGTKCELLLAYOUT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellLayout *gtkcelllayout_copy(NspGtkCellLayout *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcelllayout);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcelllayout);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellLayout
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_cell_layout_pack_start(NspGtkCellLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,new_opts, t_end};
  nsp_option opts[] = {
	{"expand",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *cell;
  int expand = TRUE;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell, opts, &expand) == FAIL) return RET_BUG;
    gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(self->obj),GTK_CELL_RENDERER(cell->obj),expand);
  return 0;
}

static int _wrap_gtk_cell_layout_pack_end(NspGtkCellLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,new_opts, t_end};
  nsp_option opts[] = {
	{"expand",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *cell;
  int expand = TRUE;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell, opts, &expand) == FAIL) return RET_BUG;
    gtk_cell_layout_pack_end(GTK_CELL_LAYOUT(self->obj),GTK_CELL_RENDERER(cell->obj),expand);
  return 0;
}

static int _wrap_gtk_cell_layout_get_cells(NspGtkCellLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_cell_layout_get_cells(GTK_CELL_LAYOUT(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

static int _wrap_gtk_cell_layout_clear(NspGtkCellLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_cell_layout_clear(GTK_CELL_LAYOUT(self->obj));
  return 0;
}

#line 6996 "codegen-3.0/gtk.override"
static int
_wrap_gtk_cell_layout_set_attributes(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspHash *h =NULL;
  GtkCellRenderer *cell;
  NspGtkCellRenderer *nsp_cell;
  gint i = 0;

  CheckRhs(2,2) ;
  if ((nsp_cell = GetGtkCellRenderer(stack,1)) == NULL) return RET_BUG;
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));
  if ((h = GetHash(stack,2)) == NULL) return RET_BUG;
  gtk_cell_layout_clear_attributes(GTK_CELL_LAYOUT(self->obj),cell);

  for ( i =0 ; i < h->hsize ; i++)
    {
      Hash_Entry *loc = ((Hash_Entry *) h->htable) + i;
      if ( loc->used )
	{
	  if ( IsMat(loc->data)
	       && (((NspMatrix *) loc->data)->mn == 1)
	       && (((NspMatrix *) loc->data)->rc_type == 'r' ))
	    gtk_cell_layout_add_attribute(GTK_CELL_LAYOUT(self->obj), cell,nsp_object_get_name(loc->data),
					  ((NspMatrix *) loc->data)->R[0]);
	  else
	    {
	      Scierror("%s: attribute %s should be a real scalar\n",NspFname(stack),nsp_object_get_name(loc->data));
	      return RET_BUG;
	    }
	}
    }
  return 0;
}

#line 7287 "gtk.c"


static int _wrap_gtk_cell_layout_add_attribute(NspGtkCellLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string,s_int, t_end};
  NspGObject *cell;
  char *attribute;
  int column;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell, &attribute, &column) == FAIL) return RET_BUG;
    gtk_cell_layout_add_attribute(GTK_CELL_LAYOUT(self->obj),GTK_CELL_RENDERER(cell->obj),attribute,column);
  return 0;
}

#line 7032 "codegen-3.0/gtk.override"

static void
nspgtk_cell_layout_data_func_marshal (GtkCellLayout *tree_column,
				      GtkCellRenderer *cell,
				      GtkTreeModel *tree_model,
				      GtkTreeIter *iter, gpointer data)
{
  NspObject *args[5], *nsp_ret;
  NspGtkCustomNotify *cunote = data;
  int nret = 0,nargs = 4;
  /* gboolean ret = FALSE; */

  g_assert (cunote->func);

  nspg_block_threads();

  args[0] =  (NspObject *) gobject_create("tree_column",(GObject *)tree_column,(NspTypeBase *) nsp_type_gtktreeviewcolumn );
  args[1] = (NspObject *) gobject_create("cell",(GObject *) cell, (NspTypeBase *) nsp_type_gtkcellrenderer);
  args[2] =  (NspObject *) gobject_create("model",(GObject *)tree_model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[3] =  (NspObject *) gboxed_create("iter",GTK_TYPE_TREE_ITER, iter,TRUE, TRUE,(NspTypeBase *)nsp_type_gtktreeiter);

  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL||args[3]== NULL ) goto end;
  if (cunote->data)
    {
      args[4]= cunote->data;
      nargs= 5;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL)
    goto end;

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    {
      /* ret =  ((NspBMatrix *) nsp_ret)->B[0]; */
    }
  nspg_unblock_threads();
 end:
  {
    nspg_unblock_threads();
  }
}

static int
_wrap_gtk_cell_layout_set_cell_data_func (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_func, *nsp_arg = NULL;
  GtkCellRenderer *cell;
  NspGtkCellRenderer *nsp_cell;
  NspGtkCustomNotify *cunote;
  CheckRhs(2,3);
  if ((nsp_cell = GetGtkCellRenderer(stack,1)) == NULL) return RET_BUG;
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,2)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"tree_foreach")== FAIL)) return RET_BUG;
  /* extra arguments **/
  if ( rhs == 3 )
    {
      if (( nsp_arg = (NspObject *) GetListCopy(stack,3)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;

  gtk_cell_layout_set_cell_data_func (GTK_CELL_LAYOUT (self->obj), cell,
				    nspgtk_cell_layout_data_func_marshal,
				    cunote,
				    nspgtk_custom_destroy_notify);
  return 0;
}

#line 7372 "gtk.c"


static int _wrap_gtk_cell_layout_clear_attributes(NspGtkCellLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *cell;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell) == FAIL) return RET_BUG;
    gtk_cell_layout_clear_attributes(GTK_CELL_LAYOUT(self->obj),GTK_CELL_RENDERER(cell->obj));
  return 0;
}

static int _wrap_gtk_cell_layout_reorder(NspGtkCellLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *cell;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell, &position) == FAIL) return RET_BUG;
    gtk_cell_layout_reorder(GTK_CELL_LAYOUT(self->obj),GTK_CELL_RENDERER(cell->obj),position);
  return 0;
}

static int _wrap_gtk_cell_layout_get_area(NspGtkCellLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkCellArea *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_cell_layout_get_area(GTK_CELL_LAYOUT(self->obj));
  nsp_type_gtkcellarea = new_type_gtkcellarea(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellarea))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkcelllayout_methods[] = {
  {"pack_start",(nsp_method *) _wrap_gtk_cell_layout_pack_start},
  {"pack_end",(nsp_method *) _wrap_gtk_cell_layout_pack_end},
  {"get_cells",(nsp_method *) _wrap_gtk_cell_layout_get_cells},
  {"clear",(nsp_method *) _wrap_gtk_cell_layout_clear},
  {"set_attributes",(nsp_method *) _wrap_gtk_cell_layout_set_attributes},
  {"add_attribute",(nsp_method *) _wrap_gtk_cell_layout_add_attribute},
  {"set_cell_data_func",(nsp_method *) _wrap_gtk_cell_layout_set_cell_data_func},
  {"clear_attributes",(nsp_method *) _wrap_gtk_cell_layout_clear_attributes},
  {"reorder",(nsp_method *) _wrap_gtk_cell_layout_reorder},
  {"get_area",(nsp_method *) _wrap_gtk_cell_layout_get_area},
  { NULL, NULL}
};

static NspMethods *gtkcelllayout_get_methods(void) { return gtkcelllayout_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcelllayout_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellEditable ----------- */


#define  NspGtkCellEditable_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcelleditable.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellEditable inherits from GObject 
 */

int nsp_type_gtkcelleditable_id=0;
NspTypeGtkCellEditable *nsp_type_gtkcelleditable=NULL;

/*
 * Type object for NspGtkCellEditable 
 * all the instance of NspTypeGtkCellEditable share the same id. 
 * nsp_type_gtkcelleditable: is an instance of NspTypeGtkCellEditable 
 *    used for objects of NspGtkCellEditable type (i.e built with new_gtkcelleditable) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellEditable *new_type_gtkcelleditable(type_mode mode)
{
  NspTypeGtkCellEditable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcelleditable != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcelleditable;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcelleditable_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcelleditable_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcelleditable;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcelleditable */ 

  top->s_type =  (s_type_func *) nsp_gtkcelleditable_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcelleditable_type_short_string;
  /* top->create = (create_func*) int_gtkcelleditable_create;*/

  /* specific methods for gtkcelleditable */

  type->init = (init_func *) init_gtkcelleditable;

  /* 
   * NspGtkCellEditable interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcelleditable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellEditable called nsp_type_gtkcelleditable
       */
      type->id =  nsp_type_gtkcelleditable_id = nsp_new_type_id();
      nsp_type_gtkcelleditable = type;
      if ( nsp_register_type(nsp_type_gtkcelleditable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcelleditable, GTK_TYPE_CELL_EDITABLE);
      return ( mode == T_BASE ) ? type : new_type_gtkcelleditable(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcelleditable_id;
      return type;
    }
}

/*
 * initialize NspGtkCellEditable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcelleditable(NspGtkCellEditable *Obj,NspTypeGtkCellEditable *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellEditable 
 */

NspGtkCellEditable *new_gtkcelleditable() 
{
  NspGtkCellEditable *loc;
  /* type must exists */
  nsp_type_gtkcelleditable = new_type_gtkcelleditable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellEditable)))== NULLGTKCELLEDITABLE) return loc;
  /* initialize object */
  if ( init_gtkcelleditable(loc,nsp_type_gtkcelleditable) == FAIL) return NULLGTKCELLEDITABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellEditable 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcelleditable_type_name[]="GtkCellEditable";
static char gtkcelleditable_short_type_name[]="GtkCellEditable";

static char *nsp_gtkcelleditable_type_as_string(void)
{
  return(gtkcelleditable_type_name);
}

static char *nsp_gtkcelleditable_type_short_string(NspObject *v)
{
  return(gtkcelleditable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellEditable objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellEditable   *nsp_gtkcelleditable_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkcelleditable_id)   ) return ((NspGtkCellEditable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcelleditable));
  return NULL;
}

int IsGtkCellEditableObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkcelleditable_id);
}

int IsGtkCellEditable(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkcelleditable_id);
}

NspGtkCellEditable  *GetGtkCellEditableCopy(Stack stack, int i)
{
  if (  GetGtkCellEditable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellEditable  *GetGtkCellEditable(Stack stack, int i)
{
  NspGtkCellEditable *M;
  if (( M = nsp_gtkcelleditable_object(NthObj(i))) == NULLGTKCELLEDITABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellEditable *gtkcelleditable_copy(NspGtkCellEditable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcelleditable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcelleditable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellEditable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_cell_editable_start_editing(NspGtkCellEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    gtk_cell_editable_start_editing(GTK_CELL_EDITABLE(self->obj),event);
  return 0;
}

static int _wrap_gtk_cell_editable_editing_done(NspGtkCellEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_cell_editable_editing_done(GTK_CELL_EDITABLE(self->obj));
  return 0;
}

static int _wrap_gtk_cell_editable_remove_widget(NspGtkCellEditable *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_cell_editable_remove_widget(GTK_CELL_EDITABLE(self->obj));
  return 0;
}

static NspMethods gtkcelleditable_methods[] = {
  {"start_editing",(nsp_method *) _wrap_gtk_cell_editable_start_editing},
  {"editing_done",(nsp_method *) _wrap_gtk_cell_editable_editing_done},
  {"remove_widget",(nsp_method *) _wrap_gtk_cell_editable_remove_widget},
  { NULL, NULL}
};

static NspMethods *gtkcelleditable_get_methods(void) { return gtkcelleditable_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcelleditable_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkToolShell ----------- */


#define  NspGtkToolShell_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktoolshell.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkToolShell inherits from GObject 
 */

int nsp_type_gtktoolshell_id=0;
NspTypeGtkToolShell *nsp_type_gtktoolshell=NULL;

/*
 * Type object for NspGtkToolShell 
 * all the instance of NspTypeGtkToolShell share the same id. 
 * nsp_type_gtktoolshell: is an instance of NspTypeGtkToolShell 
 *    used for objects of NspGtkToolShell type (i.e built with new_gtktoolshell) 
 * other instances are used for derived classes 
 */
NspTypeGtkToolShell *new_type_gtktoolshell(type_mode mode)
{
  NspTypeGtkToolShell *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktoolshell != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktoolshell;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktoolshell_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktoolshell_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktoolshell;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktoolshell */ 

  top->s_type =  (s_type_func *) nsp_gtktoolshell_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktoolshell_type_short_string;
  /* top->create = (create_func*) int_gtktoolshell_create;*/

  /* specific methods for gtktoolshell */

  type->init = (init_func *) init_gtktoolshell;

  /* 
   * NspGtkToolShell interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktoolshell_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkToolShell called nsp_type_gtktoolshell
       */
      type->id =  nsp_type_gtktoolshell_id = nsp_new_type_id();
      nsp_type_gtktoolshell = type;
      if ( nsp_register_type(nsp_type_gtktoolshell) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktoolshell, GTK_TYPE_TOOL_SHELL);
      return ( mode == T_BASE ) ? type : new_type_gtktoolshell(mode);
    }
  else 
    {
      type->id = nsp_type_gtktoolshell_id;
      return type;
    }
}

/*
 * initialize NspGtkToolShell instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktoolshell(NspGtkToolShell *Obj,NspTypeGtkToolShell *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkToolShell 
 */

NspGtkToolShell *new_gtktoolshell() 
{
  NspGtkToolShell *loc;
  /* type must exists */
  nsp_type_gtktoolshell = new_type_gtktoolshell(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkToolShell)))== NULLGTKTOOLSHELL) return loc;
  /* initialize object */
  if ( init_gtktoolshell(loc,nsp_type_gtktoolshell) == FAIL) return NULLGTKTOOLSHELL;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkToolShell 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktoolshell_type_name[]="GtkToolShell";
static char gtktoolshell_short_type_name[]="GtkToolShell";

static char *nsp_gtktoolshell_type_as_string(void)
{
  return(gtktoolshell_type_name);
}

static char *nsp_gtktoolshell_type_short_string(NspObject *v)
{
  return(gtktoolshell_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkToolShell objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkToolShell   *nsp_gtktoolshell_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtktoolshell_id)   ) return ((NspGtkToolShell *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktoolshell));
  return NULL;
}

int IsGtkToolShellObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtktoolshell_id);
}

int IsGtkToolShell(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtktoolshell_id);
}

NspGtkToolShell  *GetGtkToolShellCopy(Stack stack, int i)
{
  if (  GetGtkToolShell(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkToolShell  *GetGtkToolShell(Stack stack, int i)
{
  NspGtkToolShell *M;
  if (( M = nsp_gtktoolshell_object(NthObj(i))) == NULLGTKTOOLSHELL)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkToolShell *gtktoolshell_copy(NspGtkToolShell *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolshell);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolshell);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkToolShell
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_tool_shell_get_icon_size(NspGtkToolShell *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_shell_get_icon_size(GTK_TOOL_SHELL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_shell_get_orientation(NspGtkToolShell *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_shell_get_orientation(GTK_TOOL_SHELL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_shell_get_style(NspGtkToolShell *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_shell_get_style(GTK_TOOL_SHELL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_shell_get_relief_style(NspGtkToolShell *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_shell_get_relief_style(GTK_TOOL_SHELL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_shell_rebuild_menu(NspGtkToolShell *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tool_shell_rebuild_menu(GTK_TOOL_SHELL(self->obj));
  return 0;
}

static int _wrap_gtk_tool_shell_get_text_orientation(NspGtkToolShell *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_shell_get_text_orientation(GTK_TOOL_SHELL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_shell_get_text_alignment(NspGtkToolShell *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_tool_shell_get_text_alignment(GTK_TOOL_SHELL(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_shell_get_ellipsize_mode(NspGtkToolShell *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_shell_get_ellipsize_mode(GTK_TOOL_SHELL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_shell_get_text_size_group(NspGtkToolShell *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkSizeGroup *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tool_shell_get_text_size_group(GTK_TOOL_SHELL(self->obj));
  nsp_type_gtksizegroup = new_type_gtksizegroup(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtksizegroup))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtktoolshell_methods[] = {
  {"get_icon_size",(nsp_method *) _wrap_gtk_tool_shell_get_icon_size},
  {"get_orientation",(nsp_method *) _wrap_gtk_tool_shell_get_orientation},
  {"get_style",(nsp_method *) _wrap_gtk_tool_shell_get_style},
  {"get_relief_style",(nsp_method *) _wrap_gtk_tool_shell_get_relief_style},
  {"rebuild_menu",(nsp_method *) _wrap_gtk_tool_shell_rebuild_menu},
  {"get_text_orientation",(nsp_method *) _wrap_gtk_tool_shell_get_text_orientation},
  {"get_text_alignment",(nsp_method *) _wrap_gtk_tool_shell_get_text_alignment},
  {"get_ellipsize_mode",(nsp_method *) _wrap_gtk_tool_shell_get_ellipsize_mode},
  {"get_text_size_group",(nsp_method *) _wrap_gtk_tool_shell_get_text_size_group},
  { NULL, NULL}
};

static NspMethods *gtktoolshell_get_methods(void) { return gtktoolshell_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktoolshell_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkColorChooser ----------- */


#define  NspGtkColorChooser_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcolorchooser.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkColorChooser inherits from GObject 
 */

int nsp_type_gtkcolorchooser_id=0;
NspTypeGtkColorChooser *nsp_type_gtkcolorchooser=NULL;

/*
 * Type object for NspGtkColorChooser 
 * all the instance of NspTypeGtkColorChooser share the same id. 
 * nsp_type_gtkcolorchooser: is an instance of NspTypeGtkColorChooser 
 *    used for objects of NspGtkColorChooser type (i.e built with new_gtkcolorchooser) 
 * other instances are used for derived classes 
 */
NspTypeGtkColorChooser *new_type_gtkcolorchooser(type_mode mode)
{
  NspTypeGtkColorChooser *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcolorchooser != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcolorchooser;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcolorchooser_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcolorchooser_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcolorchooser;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcolorchooser */ 

  top->s_type =  (s_type_func *) nsp_gtkcolorchooser_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcolorchooser_type_short_string;
  /* top->create = (create_func*) int_gtkcolorchooser_create;*/

  /* specific methods for gtkcolorchooser */

  type->init = (init_func *) init_gtkcolorchooser;

  /* 
   * NspGtkColorChooser interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcolorchooser_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkColorChooser called nsp_type_gtkcolorchooser
       */
      type->id =  nsp_type_gtkcolorchooser_id = nsp_new_type_id();
      nsp_type_gtkcolorchooser = type;
      if ( nsp_register_type(nsp_type_gtkcolorchooser) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcolorchooser, GTK_TYPE_COLOR_CHOOSER);
      return ( mode == T_BASE ) ? type : new_type_gtkcolorchooser(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcolorchooser_id;
      return type;
    }
}

/*
 * initialize NspGtkColorChooser instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcolorchooser(NspGtkColorChooser *Obj,NspTypeGtkColorChooser *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkColorChooser 
 */

NspGtkColorChooser *new_gtkcolorchooser() 
{
  NspGtkColorChooser *loc;
  /* type must exists */
  nsp_type_gtkcolorchooser = new_type_gtkcolorchooser(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkColorChooser)))== NULLGTKCOLORCHOOSER) return loc;
  /* initialize object */
  if ( init_gtkcolorchooser(loc,nsp_type_gtkcolorchooser) == FAIL) return NULLGTKCOLORCHOOSER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkColorChooser 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcolorchooser_type_name[]="GtkColorChooser";
static char gtkcolorchooser_short_type_name[]="GtkColorChooser";

static char *nsp_gtkcolorchooser_type_as_string(void)
{
  return(gtkcolorchooser_type_name);
}

static char *nsp_gtkcolorchooser_type_short_string(NspObject *v)
{
  return(gtkcolorchooser_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkColorChooser objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkColorChooser   *nsp_gtkcolorchooser_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkcolorchooser_id)   ) return ((NspGtkColorChooser *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcolorchooser));
  return NULL;
}

int IsGtkColorChooserObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkcolorchooser_id);
}

int IsGtkColorChooser(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkcolorchooser_id);
}

NspGtkColorChooser  *GetGtkColorChooserCopy(Stack stack, int i)
{
  if (  GetGtkColorChooser(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkColorChooser  *GetGtkColorChooser(Stack stack, int i)
{
  NspGtkColorChooser *M;
  if (( M = nsp_gtkcolorchooser_object(NthObj(i))) == NULLGTKCOLORCHOOSER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkColorChooser *gtkcolorchooser_copy(NspGtkColorChooser *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorchooser);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorchooser);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkColorChooser
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_color_chooser_get_rgba(NspGtkColorChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkRGBA *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
GdkRGBA loc;ret=&loc;gtk_color_chooser_get_rgba(GTK_COLOR_CHOOSER(self->obj),ret);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RGBA, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkrgba))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_color_chooser_get_rgba(Stack stack, int rhs, int opt, int lhs) /* get_rgba */
{
  Scierror("Error: function gtk_color_chooser_get_rgba not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_color_chooser_set_rgba(NspGtkColorChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkRGBA *color = NULL;
  NspObject *nsp_color = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_color) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_RGBA))
      color = nspg_boxed_get(nsp_color, GdkRGBA);
  else {
      Scierror( "Error: color should be a GdkRGBA\n");
      return RET_BUG;
  }
    gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(self->obj),color);
  return 0;
}

#else
int _wrap_gtk_color_chooser_set_rgba(Stack stack, int rhs, int opt, int lhs) /* set_rgba */
{
  Scierror("Error: function gtk_color_chooser_set_rgba not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_color_chooser_get_use_alpha(NspGtkColorChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_color_chooser_get_use_alpha(GTK_COLOR_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_color_chooser_get_use_alpha(Stack stack, int rhs, int opt, int lhs) /* get_use_alpha */
{
  Scierror("Error: function gtk_color_chooser_get_use_alpha not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_color_chooser_set_use_alpha(NspGtkColorChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_alpha;
  if ( GetArgs(stack,rhs,opt,T,&use_alpha) == FAIL) return RET_BUG;
    gtk_color_chooser_set_use_alpha(GTK_COLOR_CHOOSER(self->obj),use_alpha);
  return 0;
}

#else
int _wrap_gtk_color_chooser_set_use_alpha(Stack stack, int rhs, int opt, int lhs) /* set_use_alpha */
{
  Scierror("Error: function gtk_color_chooser_set_use_alpha not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_color_chooser_add_palette(NspGtkColorChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int,obj, t_end};
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL, *nsp_colors = NULL;
  int colors_per_line, n_colors;
  GdkRGBA *colors = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation, &colors_per_line, &n_colors, &nsp_colors) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  if (nspg_boxed_check(nsp_colors, GDK_TYPE_RGBA))
      colors = nspg_boxed_get(nsp_colors, GdkRGBA);
  else {
      Scierror( "Error: colors should be a GdkRGBA\n");
      return RET_BUG;
  }
    gtk_color_chooser_add_palette(GTK_COLOR_CHOOSER(self->obj),orientation,colors_per_line,n_colors,colors);
  return 0;
}

#else
int _wrap_gtk_color_chooser_add_palette(Stack stack, int rhs, int opt, int lhs) /* add_palette */
{
  Scierror("Error: function gtk_color_chooser_add_palette not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkcolorchooser_methods[] = {
  {"get_rgba",(nsp_method *) _wrap_gtk_color_chooser_get_rgba},
  {"set_rgba",(nsp_method *) _wrap_gtk_color_chooser_set_rgba},
  {"get_use_alpha",(nsp_method *) _wrap_gtk_color_chooser_get_use_alpha},
  {"set_use_alpha",(nsp_method *) _wrap_gtk_color_chooser_set_use_alpha},
  {"add_palette",(nsp_method *) _wrap_gtk_color_chooser_add_palette},
  { NULL, NULL}
};

static NspMethods *gtkcolorchooser_get_methods(void) { return gtkcolorchooser_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcolorchooser_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkFileChooser ----------- */


#define  NspGtkFileChooser_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkfilechooser.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFileChooser inherits from GObject 
 */

int nsp_type_gtkfilechooser_id=0;
NspTypeGtkFileChooser *nsp_type_gtkfilechooser=NULL;

/*
 * Type object for NspGtkFileChooser 
 * all the instance of NspTypeGtkFileChooser share the same id. 
 * nsp_type_gtkfilechooser: is an instance of NspTypeGtkFileChooser 
 *    used for objects of NspGtkFileChooser type (i.e built with new_gtkfilechooser) 
 * other instances are used for derived classes 
 */
NspTypeGtkFileChooser *new_type_gtkfilechooser(type_mode mode)
{
  NspTypeGtkFileChooser *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfilechooser != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfilechooser;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfilechooser_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkfilechooser_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkfilechooser;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkfilechooser */ 

  top->s_type =  (s_type_func *) nsp_gtkfilechooser_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkfilechooser_type_short_string;
  /* top->create = (create_func*) int_gtkfilechooser_create;*/

  /* specific methods for gtkfilechooser */

  type->init = (init_func *) init_gtkfilechooser;

  /* 
   * NspGtkFileChooser interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkfilechooser_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFileChooser called nsp_type_gtkfilechooser
       */
      type->id =  nsp_type_gtkfilechooser_id = nsp_new_type_id();
      nsp_type_gtkfilechooser = type;
      if ( nsp_register_type(nsp_type_gtkfilechooser) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfilechooser, GTK_TYPE_FILE_CHOOSER);
      return ( mode == T_BASE ) ? type : new_type_gtkfilechooser(mode);
    }
  else 
    {
      type->id = nsp_type_gtkfilechooser_id;
      return type;
    }
}

/*
 * initialize NspGtkFileChooser instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfilechooser(NspGtkFileChooser *Obj,NspTypeGtkFileChooser *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFileChooser 
 */

NspGtkFileChooser *new_gtkfilechooser() 
{
  NspGtkFileChooser *loc;
  /* type must exists */
  nsp_type_gtkfilechooser = new_type_gtkfilechooser(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFileChooser)))== NULLGTKFILECHOOSER) return loc;
  /* initialize object */
  if ( init_gtkfilechooser(loc,nsp_type_gtkfilechooser) == FAIL) return NULLGTKFILECHOOSER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFileChooser 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkfilechooser_type_name[]="GtkFileChooser";
static char gtkfilechooser_short_type_name[]="GtkFileChooser";

static char *nsp_gtkfilechooser_type_as_string(void)
{
  return(gtkfilechooser_type_name);
}

static char *nsp_gtkfilechooser_type_short_string(NspObject *v)
{
  return(gtkfilechooser_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFileChooser objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFileChooser   *nsp_gtkfilechooser_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkfilechooser_id)   ) return ((NspGtkFileChooser *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfilechooser));
  return NULL;
}

int IsGtkFileChooserObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkfilechooser_id);
}

int IsGtkFileChooser(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkfilechooser_id);
}

NspGtkFileChooser  *GetGtkFileChooserCopy(Stack stack, int i)
{
  if (  GetGtkFileChooser(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFileChooser  *GetGtkFileChooser(Stack stack, int i)
{
  NspGtkFileChooser *M;
  if (( M = nsp_gtkfilechooser_object(NthObj(i))) == NULLGTKFILECHOOSER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFileChooser *gtkfilechooser_copy(NspGtkFileChooser *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfilechooser);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfilechooser);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFileChooser
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_file_chooser_set_action(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkFileChooserAction action;
  NspObject *nsp_action = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_action) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_FILE_CHOOSER_ACTION, nsp_action, &action)== FAIL)
      return RET_BUG;
    gtk_file_chooser_set_action(GTK_FILE_CHOOSER(self->obj),action);
  return 0;
}

static int _wrap_gtk_file_chooser_get_action(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_action(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_set_local_only(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int local_only;
  if ( GetArgs(stack,rhs,opt,T,&local_only) == FAIL) return RET_BUG;
    gtk_file_chooser_set_local_only(GTK_FILE_CHOOSER(self->obj),local_only);
  return 0;
}

static int _wrap_gtk_file_chooser_get_local_only(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_local_only(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_set_select_multiple(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int select_multiple;
  if ( GetArgs(stack,rhs,opt,T,&select_multiple) == FAIL) return RET_BUG;
    gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(self->obj),select_multiple);
  return 0;
}

static int _wrap_gtk_file_chooser_get_select_multiple(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_select_multiple(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_set_show_hidden(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_hidden;
  if ( GetArgs(stack,rhs,opt,T,&show_hidden) == FAIL) return RET_BUG;
    gtk_file_chooser_set_show_hidden(GTK_FILE_CHOOSER(self->obj),show_hidden);
  return 0;
}

static int _wrap_gtk_file_chooser_get_show_hidden(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_show_hidden(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_set_do_overwrite_confirmation(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int do_overwrite_confirmation;
  if ( GetArgs(stack,rhs,opt,T,&do_overwrite_confirmation) == FAIL) return RET_BUG;
    gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(self->obj),do_overwrite_confirmation);
  return 0;
}

static int _wrap_gtk_file_chooser_get_do_overwrite_confirmation(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_do_overwrite_confirmation(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_set_create_folders(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int create_folders;
  if ( GetArgs(stack,rhs,opt,T,&create_folders) == FAIL) return RET_BUG;
    gtk_file_chooser_set_create_folders(GTK_FILE_CHOOSER(self->obj),create_folders);
  return 0;
}

static int _wrap_gtk_file_chooser_get_create_folders(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_create_folders(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_set_current_name(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(self->obj),name);
  return 0;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_file_chooser_get_current_name(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_current_name(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

#else
int _wrap_gtk_file_chooser_get_current_name(Stack stack, int rhs, int opt, int lhs) /* get_current_name */
{
  Scierror("Error: function gtk_file_chooser_get_current_name not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_file_chooser_get_filename(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_file_chooser_set_filename(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *filename;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_set_filename(GTK_FILE_CHOOSER(self->obj),filename);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_select_filename(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *filename;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_select_filename(GTK_FILE_CHOOSER(self->obj),filename);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_unselect_filename(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *filename;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    gtk_file_chooser_unselect_filename(GTK_FILE_CHOOSER(self->obj),filename);
  return 0;
}

static int _wrap_gtk_file_chooser_select_all(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_file_chooser_select_all(GTK_FILE_CHOOSER(self->obj));
  return 0;
}

static int _wrap_gtk_file_chooser_unselect_all(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_file_chooser_unselect_all(GTK_FILE_CHOOSER(self->obj));
  return 0;
}

static int _wrap_gtk_file_chooser_get_filenames(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

static int _wrap_gtk_file_chooser_set_current_folder(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *filename;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(self->obj),filename);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_get_current_folder(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_file_chooser_get_uri(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_file_chooser_set_uri(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_set_uri(GTK_FILE_CHOOSER(self->obj),uri);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_select_uri(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_select_uri(GTK_FILE_CHOOSER(self->obj),uri);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_unselect_uri(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    gtk_file_chooser_unselect_uri(GTK_FILE_CHOOSER(self->obj),uri);
  return 0;
}

#line 6390 "codegen-3.0/gtk.override"

static int _wrap_gtk_file_chooser_get_uris(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
  ret =gtk_file_chooser_get_uris(GTK_FILE_CHOOSER(self->obj));
  if (( nsp_list =nsp_list_create(NVOID) ) == NULLLIST) 
    { 
      g_slist_free(ret);		
      return RET_BUG; 
    } 
  for (tmp = ret; tmp != NULL; tmp = tmp->next)  
    { 
      NspObject *gtk_obj = (NspObject*) nsp_smatrix_create_from_string("lel",tmp->data);
      if (gtk_obj == NULL) goto clean ;  
      if ( nsp_list_end_insert(nsp_list, gtk_obj) == FAIL ) goto clean; 
    } 
  MoveObj(stack,1,(NspObject *)nsp_list); 
  return 1; 
 clean :  
  { 
    g_slist_free(ret);		  
    nsp_list_destroy(nsp_list); 
    return RET_BUG; 
  } 
}

#line 8758 "gtk.c"


static int _wrap_gtk_file_chooser_set_current_folder_uri(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_set_current_folder_uri(GTK_FILE_CHOOSER(self->obj),uri);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_get_current_folder_uri(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_current_folder_uri(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_file_chooser_get_file(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GFile *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_file(GTK_FILE_CHOOSER(self->obj));
  nsp_type_gfile = new_type_gfile(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gfile))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_file_chooser_set_file(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *file;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gfile, &file) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_set_file(GTK_FILE_CHOOSER(self->obj),G_FILE(file->obj),&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_select_file(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *file;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gfile, &file) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_select_file(GTK_FILE_CHOOSER(self->obj),G_FILE(file->obj),&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_unselect_file(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *file;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gfile, &file) == FAIL) return RET_BUG;
    gtk_file_chooser_unselect_file(GTK_FILE_CHOOSER(self->obj),G_FILE(file->obj));
  return 0;
}

static int _wrap_gtk_file_chooser_get_files(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_files(GTK_FILE_CHOOSER(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

static int _wrap_gtk_file_chooser_set_current_folder_file(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *file;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gfile, &file) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_set_current_folder_file(GTK_FILE_CHOOSER(self->obj),G_FILE(file->obj),&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_get_current_folder_file(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GFile *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_current_folder_file(GTK_FILE_CHOOSER(self->obj));
  nsp_type_gfile = new_type_gfile(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gfile))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_file_chooser_set_preview_widget(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *preview_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &preview_widget) == FAIL) return RET_BUG;
    gtk_file_chooser_set_preview_widget(GTK_FILE_CHOOSER(self->obj),GTK_WIDGET(preview_widget->obj));
  return 0;
}

static int _wrap_gtk_file_chooser_get_preview_widget(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_preview_widget(GTK_FILE_CHOOSER(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_file_chooser_set_preview_widget_active(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int active;
  if ( GetArgs(stack,rhs,opt,T,&active) == FAIL) return RET_BUG;
    gtk_file_chooser_set_preview_widget_active(GTK_FILE_CHOOSER(self->obj),active);
  return 0;
}

static int _wrap_gtk_file_chooser_get_preview_widget_active(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_preview_widget_active(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_set_use_preview_label(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_label;
  if ( GetArgs(stack,rhs,opt,T,&use_label) == FAIL) return RET_BUG;
    gtk_file_chooser_set_use_preview_label(GTK_FILE_CHOOSER(self->obj),use_label);
  return 0;
}

static int _wrap_gtk_file_chooser_get_use_preview_label(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_use_preview_label(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_get_preview_filename(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_preview_filename(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_file_chooser_get_preview_uri(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_preview_uri(GTK_FILE_CHOOSER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_file_chooser_get_preview_file(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GFile *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_preview_file(GTK_FILE_CHOOSER(self->obj));
  nsp_type_gfile = new_type_gfile(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gfile))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_file_chooser_set_extra_widget(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *extra_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &extra_widget) == FAIL) return RET_BUG;
    gtk_file_chooser_set_extra_widget(GTK_FILE_CHOOSER(self->obj),GTK_WIDGET(extra_widget->obj));
  return 0;
}

static int _wrap_gtk_file_chooser_get_extra_widget(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_extra_widget(GTK_FILE_CHOOSER(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_file_chooser_add_filter(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *filter;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkfilefilter, &filter) == FAIL) return RET_BUG;
    gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(self->obj),GTK_FILE_FILTER(filter->obj));
  return 0;
}

static int _wrap_gtk_file_chooser_remove_filter(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *filter;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkfilefilter, &filter) == FAIL) return RET_BUG;
    gtk_file_chooser_remove_filter(GTK_FILE_CHOOSER(self->obj),GTK_FILE_FILTER(filter->obj));
  return 0;
}

static int _wrap_gtk_file_chooser_list_filters(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_file_chooser_list_filters(GTK_FILE_CHOOSER(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

static int _wrap_gtk_file_chooser_set_filter(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *filter;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkfilefilter, &filter) == FAIL) return RET_BUG;
    gtk_file_chooser_set_filter(GTK_FILE_CHOOSER(self->obj),GTK_FILE_FILTER(filter->obj));
  return 0;
}

static int _wrap_gtk_file_chooser_get_filter(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkFileFilter *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_get_filter(GTK_FILE_CHOOSER(self->obj));
  nsp_type_gtkfilefilter = new_type_gtkfilefilter(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkfilefilter))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_file_chooser_add_shortcut_folder(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *folder;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&folder) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_add_shortcut_folder(GTK_FILE_CHOOSER(self->obj),folder,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_remove_shortcut_folder(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *folder;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&folder) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_remove_shortcut_folder(GTK_FILE_CHOOSER(self->obj),folder,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_list_shortcut_folders(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_file_chooser_list_shortcut_folders(GTK_FILE_CHOOSER(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

static int _wrap_gtk_file_chooser_add_shortcut_folder_uri(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_add_shortcut_folder_uri(GTK_FILE_CHOOSER(self->obj),uri,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_remove_shortcut_folder_uri(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    ret =gtk_file_chooser_remove_shortcut_folder_uri(GTK_FILE_CHOOSER(self->obj),uri,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_list_shortcut_folder_uris(NspGtkFileChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_file_chooser_list_shortcut_folder_uris(GTK_FILE_CHOOSER(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

static NspMethods gtkfilechooser_methods[] = {
  {"set_action",(nsp_method *) _wrap_gtk_file_chooser_set_action},
  {"get_action",(nsp_method *) _wrap_gtk_file_chooser_get_action},
  {"set_local_only",(nsp_method *) _wrap_gtk_file_chooser_set_local_only},
  {"get_local_only",(nsp_method *) _wrap_gtk_file_chooser_get_local_only},
  {"set_select_multiple",(nsp_method *) _wrap_gtk_file_chooser_set_select_multiple},
  {"get_select_multiple",(nsp_method *) _wrap_gtk_file_chooser_get_select_multiple},
  {"set_show_hidden",(nsp_method *) _wrap_gtk_file_chooser_set_show_hidden},
  {"get_show_hidden",(nsp_method *) _wrap_gtk_file_chooser_get_show_hidden},
  {"set_do_overwrite_confirmation",(nsp_method *) _wrap_gtk_file_chooser_set_do_overwrite_confirmation},
  {"get_do_overwrite_confirmation",(nsp_method *) _wrap_gtk_file_chooser_get_do_overwrite_confirmation},
  {"set_create_folders",(nsp_method *) _wrap_gtk_file_chooser_set_create_folders},
  {"get_create_folders",(nsp_method *) _wrap_gtk_file_chooser_get_create_folders},
  {"set_current_name",(nsp_method *) _wrap_gtk_file_chooser_set_current_name},
  {"get_current_name",(nsp_method *) _wrap_gtk_file_chooser_get_current_name},
  {"get_filename",(nsp_method *) _wrap_gtk_file_chooser_get_filename},
  {"set_filename",(nsp_method *) _wrap_gtk_file_chooser_set_filename},
  {"select_filename",(nsp_method *) _wrap_gtk_file_chooser_select_filename},
  {"unselect_filename",(nsp_method *) _wrap_gtk_file_chooser_unselect_filename},
  {"select_all",(nsp_method *) _wrap_gtk_file_chooser_select_all},
  {"unselect_all",(nsp_method *) _wrap_gtk_file_chooser_unselect_all},
  {"get_filenames",(nsp_method *) _wrap_gtk_file_chooser_get_filenames},
  {"set_current_folder",(nsp_method *) _wrap_gtk_file_chooser_set_current_folder},
  {"get_current_folder",(nsp_method *) _wrap_gtk_file_chooser_get_current_folder},
  {"get_uri",(nsp_method *) _wrap_gtk_file_chooser_get_uri},
  {"set_uri",(nsp_method *) _wrap_gtk_file_chooser_set_uri},
  {"select_uri",(nsp_method *) _wrap_gtk_file_chooser_select_uri},
  {"unselect_uri",(nsp_method *) _wrap_gtk_file_chooser_unselect_uri},
  {"get_uris",(nsp_method *) _wrap_gtk_file_chooser_get_uris},
  {"set_current_folder_uri",(nsp_method *) _wrap_gtk_file_chooser_set_current_folder_uri},
  {"get_current_folder_uri",(nsp_method *) _wrap_gtk_file_chooser_get_current_folder_uri},
  {"get_file",(nsp_method *) _wrap_gtk_file_chooser_get_file},
  {"set_file",(nsp_method *) _wrap_gtk_file_chooser_set_file},
  {"select_file",(nsp_method *) _wrap_gtk_file_chooser_select_file},
  {"unselect_file",(nsp_method *) _wrap_gtk_file_chooser_unselect_file},
  {"get_files",(nsp_method *) _wrap_gtk_file_chooser_get_files},
  {"set_current_folder_file",(nsp_method *) _wrap_gtk_file_chooser_set_current_folder_file},
  {"get_current_folder_file",(nsp_method *) _wrap_gtk_file_chooser_get_current_folder_file},
  {"set_preview_widget",(nsp_method *) _wrap_gtk_file_chooser_set_preview_widget},
  {"get_preview_widget",(nsp_method *) _wrap_gtk_file_chooser_get_preview_widget},
  {"set_preview_widget_active",(nsp_method *) _wrap_gtk_file_chooser_set_preview_widget_active},
  {"get_preview_widget_active",(nsp_method *) _wrap_gtk_file_chooser_get_preview_widget_active},
  {"set_use_preview_label",(nsp_method *) _wrap_gtk_file_chooser_set_use_preview_label},
  {"get_use_preview_label",(nsp_method *) _wrap_gtk_file_chooser_get_use_preview_label},
  {"get_preview_filename",(nsp_method *) _wrap_gtk_file_chooser_get_preview_filename},
  {"get_preview_uri",(nsp_method *) _wrap_gtk_file_chooser_get_preview_uri},
  {"get_preview_file",(nsp_method *) _wrap_gtk_file_chooser_get_preview_file},
  {"set_extra_widget",(nsp_method *) _wrap_gtk_file_chooser_set_extra_widget},
  {"get_extra_widget",(nsp_method *) _wrap_gtk_file_chooser_get_extra_widget},
  {"add_filter",(nsp_method *) _wrap_gtk_file_chooser_add_filter},
  {"remove_filter",(nsp_method *) _wrap_gtk_file_chooser_remove_filter},
  {"list_filters",(nsp_method *) _wrap_gtk_file_chooser_list_filters},
  {"set_filter",(nsp_method *) _wrap_gtk_file_chooser_set_filter},
  {"get_filter",(nsp_method *) _wrap_gtk_file_chooser_get_filter},
  {"add_shortcut_folder",(nsp_method *) _wrap_gtk_file_chooser_add_shortcut_folder},
  {"remove_shortcut_folder",(nsp_method *) _wrap_gtk_file_chooser_remove_shortcut_folder},
  {"list_shortcut_folders",(nsp_method *) _wrap_gtk_file_chooser_list_shortcut_folders},
  {"add_shortcut_folder_uri",(nsp_method *) _wrap_gtk_file_chooser_add_shortcut_folder_uri},
  {"remove_shortcut_folder_uri",(nsp_method *) _wrap_gtk_file_chooser_remove_shortcut_folder_uri},
  {"list_shortcut_folder_uris",(nsp_method *) _wrap_gtk_file_chooser_list_shortcut_folder_uris},
  { NULL, NULL}
};

static NspMethods *gtkfilechooser_get_methods(void) { return gtkfilechooser_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfilechooser_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkFontChooser ----------- */


#define  NspGtkFontChooser_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkfontchooser.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFontChooser inherits from GObject 
 */

int nsp_type_gtkfontchooser_id=0;
NspTypeGtkFontChooser *nsp_type_gtkfontchooser=NULL;

/*
 * Type object for NspGtkFontChooser 
 * all the instance of NspTypeGtkFontChooser share the same id. 
 * nsp_type_gtkfontchooser: is an instance of NspTypeGtkFontChooser 
 *    used for objects of NspGtkFontChooser type (i.e built with new_gtkfontchooser) 
 * other instances are used for derived classes 
 */
NspTypeGtkFontChooser *new_type_gtkfontchooser(type_mode mode)
{
  NspTypeGtkFontChooser *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfontchooser != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfontchooser;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfontchooser_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkfontchooser_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkfontchooser;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkfontchooser */ 

  top->s_type =  (s_type_func *) nsp_gtkfontchooser_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkfontchooser_type_short_string;
  /* top->create = (create_func*) int_gtkfontchooser_create;*/

  /* specific methods for gtkfontchooser */

  type->init = (init_func *) init_gtkfontchooser;

  /* 
   * NspGtkFontChooser interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkfontchooser_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFontChooser called nsp_type_gtkfontchooser
       */
      type->id =  nsp_type_gtkfontchooser_id = nsp_new_type_id();
      nsp_type_gtkfontchooser = type;
      if ( nsp_register_type(nsp_type_gtkfontchooser) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfontchooser, GTK_TYPE_FONT_CHOOSER);
      return ( mode == T_BASE ) ? type : new_type_gtkfontchooser(mode);
    }
  else 
    {
      type->id = nsp_type_gtkfontchooser_id;
      return type;
    }
}

/*
 * initialize NspGtkFontChooser instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfontchooser(NspGtkFontChooser *Obj,NspTypeGtkFontChooser *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFontChooser 
 */

NspGtkFontChooser *new_gtkfontchooser() 
{
  NspGtkFontChooser *loc;
  /* type must exists */
  nsp_type_gtkfontchooser = new_type_gtkfontchooser(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFontChooser)))== NULLGTKFONTCHOOSER) return loc;
  /* initialize object */
  if ( init_gtkfontchooser(loc,nsp_type_gtkfontchooser) == FAIL) return NULLGTKFONTCHOOSER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFontChooser 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkfontchooser_type_name[]="GtkFontChooser";
static char gtkfontchooser_short_type_name[]="GtkFontChooser";

static char *nsp_gtkfontchooser_type_as_string(void)
{
  return(gtkfontchooser_type_name);
}

static char *nsp_gtkfontchooser_type_short_string(NspObject *v)
{
  return(gtkfontchooser_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFontChooser objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFontChooser   *nsp_gtkfontchooser_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkfontchooser_id)   ) return ((NspGtkFontChooser *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfontchooser));
  return NULL;
}

int IsGtkFontChooserObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkfontchooser_id);
}

int IsGtkFontChooser(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkfontchooser_id);
}

NspGtkFontChooser  *GetGtkFontChooserCopy(Stack stack, int i)
{
  if (  GetGtkFontChooser(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFontChooser  *GetGtkFontChooser(Stack stack, int i)
{
  NspGtkFontChooser *M;
  if (( M = nsp_gtkfontchooser_object(NthObj(i))) == NULLGTKFONTCHOOSER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFontChooser *gtkfontchooser_copy(NspGtkFontChooser *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontchooser);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontchooser);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFontChooser
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_font_chooser_get_font_family(NspGtkFontChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoFontFamily *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_font_chooser_get_font_family(GTK_FONT_CHOOSER(self->obj));
  nsp_type_pangofontfamily = new_type_pangofontfamily(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangofontfamily))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_font_chooser_get_font_family(Stack stack, int rhs, int opt, int lhs) /* get_font_family */
{
  Scierror("Error: function gtk_font_chooser_get_font_family not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_font_chooser_get_font_face(NspGtkFontChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoFontFace *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_font_chooser_get_font_face(GTK_FONT_CHOOSER(self->obj));
  nsp_type_pangofontface = new_type_pangofontface(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangofontface))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_font_chooser_get_font_face(Stack stack, int rhs, int opt, int lhs) /* get_font_face */
{
  Scierror("Error: function gtk_font_chooser_get_font_face not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_font_chooser_get_font_size(NspGtkFontChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_font_chooser_get_font_size(GTK_FONT_CHOOSER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_font_chooser_get_font_size(Stack stack, int rhs, int opt, int lhs) /* get_font_size */
{
  Scierror("Error: function gtk_font_chooser_get_font_size not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_font_chooser_get_font_desc(NspGtkFontChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoFontDescription *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_font_chooser_get_font_desc(GTK_FONT_CHOOSER(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,PANGO_TYPE_FONT_DESCRIPTION, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_pangofontdescription))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_font_chooser_get_font_desc(Stack stack, int rhs, int opt, int lhs) /* get_font_desc */
{
  Scierror("Error: function gtk_font_chooser_get_font_desc not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_font_chooser_set_font_desc(NspGtkFontChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  PangoFontDescription *font_desc = NULL;
  NspObject *nsp_font_desc = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_font_desc) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_font_desc, PANGO_TYPE_FONT_DESCRIPTION))
      font_desc = nspg_boxed_get(nsp_font_desc, PangoFontDescription);
  else {
      Scierror( "Error: font_desc should be a PangoFontDescription\n");
      return RET_BUG;
  }
    gtk_font_chooser_set_font_desc(GTK_FONT_CHOOSER(self->obj),font_desc);
  return 0;
}

#else
int _wrap_gtk_font_chooser_set_font_desc(Stack stack, int rhs, int opt, int lhs) /* set_font_desc */
{
  Scierror("Error: function gtk_font_chooser_set_font_desc not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_font_chooser_get_font(NspGtkFontChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_font_chooser_get_font(GTK_FONT_CHOOSER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

#else
int _wrap_gtk_font_chooser_get_font(Stack stack, int rhs, int opt, int lhs) /* get_font */
{
  Scierror("Error: function gtk_font_chooser_get_font not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_font_chooser_set_font(NspGtkFontChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *fontname;
  if ( GetArgs(stack,rhs,opt,T,&fontname) == FAIL) return RET_BUG;
    gtk_font_chooser_set_font(GTK_FONT_CHOOSER(self->obj),fontname);
  return 0;
}

#else
int _wrap_gtk_font_chooser_set_font(Stack stack, int rhs, int opt, int lhs) /* set_font */
{
  Scierror("Error: function gtk_font_chooser_set_font not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_font_chooser_get_preview_text(NspGtkFontChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_font_chooser_get_preview_text(GTK_FONT_CHOOSER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

#else
int _wrap_gtk_font_chooser_get_preview_text(Stack stack, int rhs, int opt, int lhs) /* get_preview_text */
{
  Scierror("Error: function gtk_font_chooser_get_preview_text not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_font_chooser_set_preview_text(NspGtkFontChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    gtk_font_chooser_set_preview_text(GTK_FONT_CHOOSER(self->obj),text);
  return 0;
}

#else
int _wrap_gtk_font_chooser_set_preview_text(Stack stack, int rhs, int opt, int lhs) /* set_preview_text */
{
  Scierror("Error: function gtk_font_chooser_set_preview_text not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_font_chooser_get_show_preview_entry(NspGtkFontChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_font_chooser_get_show_preview_entry(GTK_FONT_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_font_chooser_get_show_preview_entry(Stack stack, int rhs, int opt, int lhs) /* get_show_preview_entry */
{
  Scierror("Error: function gtk_font_chooser_get_show_preview_entry not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_font_chooser_set_show_preview_entry(NspGtkFontChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_preview_entry;
  if ( GetArgs(stack,rhs,opt,T,&show_preview_entry) == FAIL) return RET_BUG;
    gtk_font_chooser_set_show_preview_entry(GTK_FONT_CHOOSER(self->obj),show_preview_entry);
  return 0;
}

#else
int _wrap_gtk_font_chooser_set_show_preview_entry(Stack stack, int rhs, int opt, int lhs) /* set_show_preview_entry */
{
  Scierror("Error: function gtk_font_chooser_set_show_preview_entry not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkfontchooser_methods[] = {
  {"get_font_family",(nsp_method *) _wrap_gtk_font_chooser_get_font_family},
  {"get_font_face",(nsp_method *) _wrap_gtk_font_chooser_get_font_face},
  {"get_font_size",(nsp_method *) _wrap_gtk_font_chooser_get_font_size},
  {"get_font_desc",(nsp_method *) _wrap_gtk_font_chooser_get_font_desc},
  {"set_font_desc",(nsp_method *) _wrap_gtk_font_chooser_set_font_desc},
  {"get_font",(nsp_method *) _wrap_gtk_font_chooser_get_font},
  {"set_font",(nsp_method *) _wrap_gtk_font_chooser_set_font},
  {"get_preview_text",(nsp_method *) _wrap_gtk_font_chooser_get_preview_text},
  {"set_preview_text",(nsp_method *) _wrap_gtk_font_chooser_set_preview_text},
  {"get_show_preview_entry",(nsp_method *) _wrap_gtk_font_chooser_get_show_preview_entry},
  {"set_show_preview_entry",(nsp_method *) _wrap_gtk_font_chooser_set_show_preview_entry},
  { NULL, NULL}
};

static NspMethods *gtkfontchooser_get_methods(void) { return gtkfontchooser_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfontchooser_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkScrollable ----------- */


#define  NspGtkScrollable_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkscrollable.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkScrollable inherits from GObject 
 */

int nsp_type_gtkscrollable_id=0;
NspTypeGtkScrollable *nsp_type_gtkscrollable=NULL;

/*
 * Type object for NspGtkScrollable 
 * all the instance of NspTypeGtkScrollable share the same id. 
 * nsp_type_gtkscrollable: is an instance of NspTypeGtkScrollable 
 *    used for objects of NspGtkScrollable type (i.e built with new_gtkscrollable) 
 * other instances are used for derived classes 
 */
NspTypeGtkScrollable *new_type_gtkscrollable(type_mode mode)
{
  NspTypeGtkScrollable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkscrollable != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkscrollable;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkscrollable_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkscrollable_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkscrollable;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkscrollable */ 

  top->s_type =  (s_type_func *) nsp_gtkscrollable_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkscrollable_type_short_string;
  /* top->create = (create_func*) int_gtkscrollable_create;*/

  /* specific methods for gtkscrollable */

  type->init = (init_func *) init_gtkscrollable;

  /* 
   * NspGtkScrollable interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkscrollable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkScrollable called nsp_type_gtkscrollable
       */
      type->id =  nsp_type_gtkscrollable_id = nsp_new_type_id();
      nsp_type_gtkscrollable = type;
      if ( nsp_register_type(nsp_type_gtkscrollable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkscrollable, GTK_TYPE_SCROLLABLE);
      return ( mode == T_BASE ) ? type : new_type_gtkscrollable(mode);
    }
  else 
    {
      type->id = nsp_type_gtkscrollable_id;
      return type;
    }
}

/*
 * initialize NspGtkScrollable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkscrollable(NspGtkScrollable *Obj,NspTypeGtkScrollable *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkScrollable 
 */

NspGtkScrollable *new_gtkscrollable() 
{
  NspGtkScrollable *loc;
  /* type must exists */
  nsp_type_gtkscrollable = new_type_gtkscrollable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkScrollable)))== NULLGTKSCROLLABLE) return loc;
  /* initialize object */
  if ( init_gtkscrollable(loc,nsp_type_gtkscrollable) == FAIL) return NULLGTKSCROLLABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkScrollable 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkscrollable_type_name[]="GtkScrollable";
static char gtkscrollable_short_type_name[]="GtkScrollable";

static char *nsp_gtkscrollable_type_as_string(void)
{
  return(gtkscrollable_type_name);
}

static char *nsp_gtkscrollable_type_short_string(NspObject *v)
{
  return(gtkscrollable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkScrollable objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkScrollable   *nsp_gtkscrollable_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkscrollable_id)   ) return ((NspGtkScrollable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkscrollable));
  return NULL;
}

int IsGtkScrollableObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkscrollable_id);
}

int IsGtkScrollable(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkscrollable_id);
}

NspGtkScrollable  *GetGtkScrollableCopy(Stack stack, int i)
{
  if (  GetGtkScrollable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkScrollable  *GetGtkScrollable(Stack stack, int i)
{
  NspGtkScrollable *M;
  if (( M = nsp_gtkscrollable_object(NthObj(i))) == NULLGTKSCROLLABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkScrollable *gtkscrollable_copy(NspGtkScrollable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscrollable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscrollable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkScrollable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_scrollable_get_hadjustment(NspGtkScrollable *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAdjustment *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scrollable_set_hadjustment(NspGtkScrollable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *hadjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &hadjustment) == FAIL) return RET_BUG;
    gtk_scrollable_set_hadjustment(GTK_SCROLLABLE(self->obj),GTK_ADJUSTMENT(hadjustment->obj));
  return 0;
}

static int _wrap_gtk_scrollable_get_vadjustment(NspGtkScrollable *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAdjustment *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scrollable_set_vadjustment(NspGtkScrollable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *vadjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &vadjustment) == FAIL) return RET_BUG;
    gtk_scrollable_set_vadjustment(GTK_SCROLLABLE(self->obj),GTK_ADJUSTMENT(vadjustment->obj));
  return 0;
}

static int _wrap_gtk_scrollable_get_hscroll_policy(NspGtkScrollable *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_scrollable_get_hscroll_policy(GTK_SCROLLABLE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scrollable_set_hscroll_policy(NspGtkScrollable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkScrollablePolicy policy;
  NspObject *nsp_policy = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_policy) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SCROLLABLE_POLICY, nsp_policy, &policy)== FAIL)
      return RET_BUG;
    gtk_scrollable_set_hscroll_policy(GTK_SCROLLABLE(self->obj),policy);
  return 0;
}

static int _wrap_gtk_scrollable_get_vscroll_policy(NspGtkScrollable *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_scrollable_get_vscroll_policy(GTK_SCROLLABLE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scrollable_set_vscroll_policy(NspGtkScrollable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkScrollablePolicy policy;
  NspObject *nsp_policy = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_policy) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SCROLLABLE_POLICY, nsp_policy, &policy)== FAIL)
      return RET_BUG;
    gtk_scrollable_set_vscroll_policy(GTK_SCROLLABLE(self->obj),policy);
  return 0;
}

#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_scrollable_get_border(NspGtkScrollable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkBorder *border = NULL;
  NspObject *nsp_border = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_border) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_border, GTK_TYPE_BORDER))
      border = nspg_boxed_get(nsp_border, GtkBorder);
  else {
      Scierror( "Error: border should be a GtkBorder\n");
      return RET_BUG;
  }
    ret =gtk_scrollable_get_border(GTK_SCROLLABLE(self->obj),border);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_scrollable_get_border(Stack stack, int rhs, int opt, int lhs) /* get_border */
{
  Scierror("Error: function gtk_scrollable_get_border not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkscrollable_methods[] = {
  {"get_hadjustment",(nsp_method *) _wrap_gtk_scrollable_get_hadjustment},
  {"set_hadjustment",(nsp_method *) _wrap_gtk_scrollable_set_hadjustment},
  {"get_vadjustment",(nsp_method *) _wrap_gtk_scrollable_get_vadjustment},
  {"set_vadjustment",(nsp_method *) _wrap_gtk_scrollable_set_vadjustment},
  {"get_hscroll_policy",(nsp_method *) _wrap_gtk_scrollable_get_hscroll_policy},
  {"set_hscroll_policy",(nsp_method *) _wrap_gtk_scrollable_set_hscroll_policy},
  {"get_vscroll_policy",(nsp_method *) _wrap_gtk_scrollable_get_vscroll_policy},
  {"set_vscroll_policy",(nsp_method *) _wrap_gtk_scrollable_set_vscroll_policy},
  {"get_border",(nsp_method *) _wrap_gtk_scrollable_get_border},
  { NULL, NULL}
};

static NspMethods *gtkscrollable_get_methods(void) { return gtkscrollable_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkscrollable_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRecentChooser ----------- */


#define  NspGtkRecentChooser_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkrecentchooser.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRecentChooser inherits from GObject 
 * and implements GtkBuildable
 */

int nsp_type_gtkrecentchooser_id=0;
NspTypeGtkRecentChooser *nsp_type_gtkrecentchooser=NULL;

/*
 * Type object for NspGtkRecentChooser 
 * all the instance of NspTypeGtkRecentChooser share the same id. 
 * nsp_type_gtkrecentchooser: is an instance of NspTypeGtkRecentChooser 
 *    used for objects of NspGtkRecentChooser type (i.e built with new_gtkrecentchooser) 
 * other instances are used for derived classes 
 */
NspTypeGtkRecentChooser *new_type_gtkrecentchooser(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkRecentChooser *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkrecentchooser != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkrecentchooser;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkrecentchooser_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkrecentchooser_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkrecentchooser;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkrecentchooser */ 

  top->s_type =  (s_type_func *) nsp_gtkrecentchooser_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkrecentchooser_type_short_string;
  /* top->create = (create_func*) int_gtkrecentchooser_create;*/

  /* specific methods for gtkrecentchooser */

  type->init = (init_func *) init_gtkrecentchooser;

  /* 
   * NspGtkRecentChooser interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkrecentchooser_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRecentChooser called nsp_type_gtkrecentchooser
       */
      type->id =  nsp_type_gtkrecentchooser_id = nsp_new_type_id();
      nsp_type_gtkrecentchooser = type;
      if ( nsp_register_type(nsp_type_gtkrecentchooser) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkrecentchooser, GTK_TYPE_RECENT_CHOOSER);
      return ( mode == T_BASE ) ? type : new_type_gtkrecentchooser(mode);
    }
  else 
    {
      type->id = nsp_type_gtkrecentchooser_id;
      return type;
    }
}

/*
 * initialize NspGtkRecentChooser instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkrecentchooser(NspGtkRecentChooser *Obj,NspTypeGtkRecentChooser *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRecentChooser 
 */

NspGtkRecentChooser *new_gtkrecentchooser() 
{
  NspGtkRecentChooser *loc;
  /* type must exists */
  nsp_type_gtkrecentchooser = new_type_gtkrecentchooser(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRecentChooser)))== NULLGTKRECENTCHOOSER) return loc;
  /* initialize object */
  if ( init_gtkrecentchooser(loc,nsp_type_gtkrecentchooser) == FAIL) return NULLGTKRECENTCHOOSER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRecentChooser 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkrecentchooser_type_name[]="GtkRecentChooser";
static char gtkrecentchooser_short_type_name[]="GtkRecentChooser";

static char *nsp_gtkrecentchooser_type_as_string(void)
{
  return(gtkrecentchooser_type_name);
}

static char *nsp_gtkrecentchooser_type_short_string(NspObject *v)
{
  return(gtkrecentchooser_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRecentChooser objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRecentChooser   *nsp_gtkrecentchooser_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkrecentchooser_id)   ) return ((NspGtkRecentChooser *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkrecentchooser));
  return NULL;
}

int IsGtkRecentChooserObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkrecentchooser_id);
}

int IsGtkRecentChooser(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkrecentchooser_id);
}

NspGtkRecentChooser  *GetGtkRecentChooserCopy(Stack stack, int i)
{
  if (  GetGtkRecentChooser(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRecentChooser  *GetGtkRecentChooser(Stack stack, int i)
{
  NspGtkRecentChooser *M;
  if (( M = nsp_gtkrecentchooser_object(NthObj(i))) == NULLGTKRECENTCHOOSER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRecentChooser *gtkrecentchooser_copy(NspGtkRecentChooser *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrecentchooser);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrecentchooser);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRecentChooser
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_recent_chooser_set_show_private(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_private;
  if ( GetArgs(stack,rhs,opt,T,&show_private) == FAIL) return RET_BUG;
    gtk_recent_chooser_set_show_private(GTK_RECENT_CHOOSER(self->obj),show_private);
  return 0;
}

static int _wrap_gtk_recent_chooser_get_show_private(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_get_show_private(GTK_RECENT_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_chooser_set_show_not_found(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_not_found;
  if ( GetArgs(stack,rhs,opt,T,&show_not_found) == FAIL) return RET_BUG;
    gtk_recent_chooser_set_show_not_found(GTK_RECENT_CHOOSER(self->obj),show_not_found);
  return 0;
}

static int _wrap_gtk_recent_chooser_get_show_not_found(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_get_show_not_found(GTK_RECENT_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_chooser_set_select_multiple(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int select_multiple;
  if ( GetArgs(stack,rhs,opt,T,&select_multiple) == FAIL) return RET_BUG;
    gtk_recent_chooser_set_select_multiple(GTK_RECENT_CHOOSER(self->obj),select_multiple);
  return 0;
}

static int _wrap_gtk_recent_chooser_get_select_multiple(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_get_select_multiple(GTK_RECENT_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_chooser_set_limit(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int limit;
  if ( GetArgs(stack,rhs,opt,T,&limit) == FAIL) return RET_BUG;
    gtk_recent_chooser_set_limit(GTK_RECENT_CHOOSER(self->obj),limit);
  return 0;
}

static int _wrap_gtk_recent_chooser_get_limit(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_get_limit(GTK_RECENT_CHOOSER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_chooser_set_local_only(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int local_only;
  if ( GetArgs(stack,rhs,opt,T,&local_only) == FAIL) return RET_BUG;
    gtk_recent_chooser_set_local_only(GTK_RECENT_CHOOSER(self->obj),local_only);
  return 0;
}

static int _wrap_gtk_recent_chooser_get_local_only(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_get_local_only(GTK_RECENT_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_chooser_set_show_tips(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_tips;
  if ( GetArgs(stack,rhs,opt,T,&show_tips) == FAIL) return RET_BUG;
    gtk_recent_chooser_set_show_tips(GTK_RECENT_CHOOSER(self->obj),show_tips);
  return 0;
}

static int _wrap_gtk_recent_chooser_get_show_tips(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_get_show_tips(GTK_RECENT_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_chooser_set_show_icons(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_icons;
  if ( GetArgs(stack,rhs,opt,T,&show_icons) == FAIL) return RET_BUG;
    gtk_recent_chooser_set_show_icons(GTK_RECENT_CHOOSER(self->obj),show_icons);
  return 0;
}

static int _wrap_gtk_recent_chooser_get_show_icons(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_get_show_icons(GTK_RECENT_CHOOSER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_chooser_set_sort_type(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkRecentSortType sort_type;
  NspObject *nsp_sort_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_sort_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_RECENT_SORT_TYPE, nsp_sort_type, &sort_type)== FAIL)
      return RET_BUG;
    gtk_recent_chooser_set_sort_type(GTK_RECENT_CHOOSER(self->obj),sort_type);
  return 0;
}

static int _wrap_gtk_recent_chooser_get_sort_type(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_get_sort_type(GTK_RECENT_CHOOSER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_chooser_set_current_uri(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    ret =gtk_recent_chooser_set_current_uri(GTK_RECENT_CHOOSER(self->obj),uri,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_chooser_get_current_uri(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_get_current_uri(GTK_RECENT_CHOOSER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_recent_chooser_select_uri(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    ret =gtk_recent_chooser_select_uri(GTK_RECENT_CHOOSER(self->obj),uri,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_chooser_unselect_uri(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    gtk_recent_chooser_unselect_uri(GTK_RECENT_CHOOSER(self->obj),uri);
  return 0;
}

static int _wrap_gtk_recent_chooser_select_all(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_recent_chooser_select_all(GTK_RECENT_CHOOSER(self->obj));
  return 0;
}

static int _wrap_gtk_recent_chooser_unselect_all(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_recent_chooser_unselect_all(GTK_RECENT_CHOOSER(self->obj));
  return 0;
}

static int _wrap_gtk_recent_chooser_get_items(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_get_items(GTK_RECENT_CHOOSER(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

static int _wrap_gtk_recent_chooser_add_filter(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *filter;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkrecentfilter, &filter) == FAIL) return RET_BUG;
    gtk_recent_chooser_add_filter(GTK_RECENT_CHOOSER(self->obj),GTK_RECENT_FILTER(filter->obj));
  return 0;
}

static int _wrap_gtk_recent_chooser_remove_filter(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *filter;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkrecentfilter, &filter) == FAIL) return RET_BUG;
    gtk_recent_chooser_remove_filter(GTK_RECENT_CHOOSER(self->obj),GTK_RECENT_FILTER(filter->obj));
  return 0;
}

static int _wrap_gtk_recent_chooser_list_filters(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_list_filters(GTK_RECENT_CHOOSER(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

static int _wrap_gtk_recent_chooser_set_filter(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *filter;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkrecentfilter, &filter) == FAIL) return RET_BUG;
    gtk_recent_chooser_set_filter(GTK_RECENT_CHOOSER(self->obj),GTK_RECENT_FILTER(filter->obj));
  return 0;
}

static int _wrap_gtk_recent_chooser_get_filter(NspGtkRecentChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkRecentFilter *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_recent_chooser_get_filter(GTK_RECENT_CHOOSER(self->obj));
  nsp_type_gtkrecentfilter = new_type_gtkrecentfilter(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkrecentfilter))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkrecentchooser_methods[] = {
  {"set_show_private",(nsp_method *) _wrap_gtk_recent_chooser_set_show_private},
  {"get_show_private",(nsp_method *) _wrap_gtk_recent_chooser_get_show_private},
  {"set_show_not_found",(nsp_method *) _wrap_gtk_recent_chooser_set_show_not_found},
  {"get_show_not_found",(nsp_method *) _wrap_gtk_recent_chooser_get_show_not_found},
  {"set_select_multiple",(nsp_method *) _wrap_gtk_recent_chooser_set_select_multiple},
  {"get_select_multiple",(nsp_method *) _wrap_gtk_recent_chooser_get_select_multiple},
  {"set_limit",(nsp_method *) _wrap_gtk_recent_chooser_set_limit},
  {"get_limit",(nsp_method *) _wrap_gtk_recent_chooser_get_limit},
  {"set_local_only",(nsp_method *) _wrap_gtk_recent_chooser_set_local_only},
  {"get_local_only",(nsp_method *) _wrap_gtk_recent_chooser_get_local_only},
  {"set_show_tips",(nsp_method *) _wrap_gtk_recent_chooser_set_show_tips},
  {"get_show_tips",(nsp_method *) _wrap_gtk_recent_chooser_get_show_tips},
  {"set_show_icons",(nsp_method *) _wrap_gtk_recent_chooser_set_show_icons},
  {"get_show_icons",(nsp_method *) _wrap_gtk_recent_chooser_get_show_icons},
  {"set_sort_type",(nsp_method *) _wrap_gtk_recent_chooser_set_sort_type},
  {"get_sort_type",(nsp_method *) _wrap_gtk_recent_chooser_get_sort_type},
  {"set_current_uri",(nsp_method *) _wrap_gtk_recent_chooser_set_current_uri},
  {"get_current_uri",(nsp_method *) _wrap_gtk_recent_chooser_get_current_uri},
  {"select_uri",(nsp_method *) _wrap_gtk_recent_chooser_select_uri},
  {"unselect_uri",(nsp_method *) _wrap_gtk_recent_chooser_unselect_uri},
  {"select_all",(nsp_method *) _wrap_gtk_recent_chooser_select_all},
  {"unselect_all",(nsp_method *) _wrap_gtk_recent_chooser_unselect_all},
  {"get_items",(nsp_method *) _wrap_gtk_recent_chooser_get_items},
  {"add_filter",(nsp_method *) _wrap_gtk_recent_chooser_add_filter},
  {"remove_filter",(nsp_method *) _wrap_gtk_recent_chooser_remove_filter},
  {"list_filters",(nsp_method *) _wrap_gtk_recent_chooser_list_filters},
  {"set_filter",(nsp_method *) _wrap_gtk_recent_chooser_set_filter},
  {"get_filter",(nsp_method *) _wrap_gtk_recent_chooser_get_filter},
  { NULL, NULL}
};

static NspMethods *gtkrecentchooser_get_methods(void) { return gtkrecentchooser_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkrecentchooser_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAppChooser ----------- */


#define  NspGtkAppChooser_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkappchooser.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAppChooser inherits from GObject 
 */

int nsp_type_gtkappchooser_id=0;
NspTypeGtkAppChooser *nsp_type_gtkappchooser=NULL;

/*
 * Type object for NspGtkAppChooser 
 * all the instance of NspTypeGtkAppChooser share the same id. 
 * nsp_type_gtkappchooser: is an instance of NspTypeGtkAppChooser 
 *    used for objects of NspGtkAppChooser type (i.e built with new_gtkappchooser) 
 * other instances are used for derived classes 
 */
NspTypeGtkAppChooser *new_type_gtkappchooser(type_mode mode)
{
  NspTypeGtkAppChooser *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkappchooser != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkappchooser;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkappchooser_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkappchooser_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkappchooser;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkappchooser */ 

  top->s_type =  (s_type_func *) nsp_gtkappchooser_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkappchooser_type_short_string;
  /* top->create = (create_func*) int_gtkappchooser_create;*/

  /* specific methods for gtkappchooser */

  type->init = (init_func *) init_gtkappchooser;

  /* 
   * NspGtkAppChooser interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkappchooser_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAppChooser called nsp_type_gtkappchooser
       */
      type->id =  nsp_type_gtkappchooser_id = nsp_new_type_id();
      nsp_type_gtkappchooser = type;
      if ( nsp_register_type(nsp_type_gtkappchooser) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkappchooser, GTK_TYPE_APP_CHOOSER);
      return ( mode == T_BASE ) ? type : new_type_gtkappchooser(mode);
    }
  else 
    {
      type->id = nsp_type_gtkappchooser_id;
      return type;
    }
}

/*
 * initialize NspGtkAppChooser instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkappchooser(NspGtkAppChooser *Obj,NspTypeGtkAppChooser *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAppChooser 
 */

NspGtkAppChooser *new_gtkappchooser() 
{
  NspGtkAppChooser *loc;
  /* type must exists */
  nsp_type_gtkappchooser = new_type_gtkappchooser(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAppChooser)))== NULLGTKAPPCHOOSER) return loc;
  /* initialize object */
  if ( init_gtkappchooser(loc,nsp_type_gtkappchooser) == FAIL) return NULLGTKAPPCHOOSER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAppChooser 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkappchooser_type_name[]="GtkAppChooser";
static char gtkappchooser_short_type_name[]="GtkAppChooser";

static char *nsp_gtkappchooser_type_as_string(void)
{
  return(gtkappchooser_type_name);
}

static char *nsp_gtkappchooser_type_short_string(NspObject *v)
{
  return(gtkappchooser_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAppChooser objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAppChooser   *nsp_gtkappchooser_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtkappchooser_id)   ) return ((NspGtkAppChooser *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkappchooser));
  return NULL;
}

int IsGtkAppChooserObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtkappchooser_id);
}

int IsGtkAppChooser(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtkappchooser_id);
}

NspGtkAppChooser  *GetGtkAppChooserCopy(Stack stack, int i)
{
  if (  GetGtkAppChooser(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAppChooser  *GetGtkAppChooser(Stack stack, int i)
{
  NspGtkAppChooser *M;
  if (( M = nsp_gtkappchooser_object(NthObj(i))) == NULLGTKAPPCHOOSER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAppChooser *gtkappchooser_copy(NspGtkAppChooser *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkappchooser);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkappchooser);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAppChooser
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_app_chooser_get_app_info(NspGtkAppChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  GAppInfo *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_get_app_info(GTK_APP_CHOOSER(self->obj));
  nsp_type_gappinfo = new_type_gappinfo(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gappinfo))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_app_chooser_get_content_type(NspGtkAppChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_get_content_type(GTK_APP_CHOOSER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_app_chooser_refresh(NspGtkAppChooser *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_app_chooser_refresh(GTK_APP_CHOOSER(self->obj));
  return 0;
}

static NspMethods gtkappchooser_methods[] = {
  {"get_app_info",(nsp_method *) _wrap_gtk_app_chooser_get_app_info},
  {"get_content_type",(nsp_method *) _wrap_gtk_app_chooser_get_content_type},
  {"refresh",(nsp_method *) _wrap_gtk_app_chooser_refresh},
  { NULL, NULL}
};

static NspMethods *gtkappchooser_get_methods(void) { return gtkappchooser_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkappchooser_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeDragDest ----------- */


#define  NspGtkTreeDragDest_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreedragdest.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeDragDest inherits from GObject 
 */

int nsp_type_gtktreedragdest_id=0;
NspTypeGtkTreeDragDest *nsp_type_gtktreedragdest=NULL;

/*
 * Type object for NspGtkTreeDragDest 
 * all the instance of NspTypeGtkTreeDragDest share the same id. 
 * nsp_type_gtktreedragdest: is an instance of NspTypeGtkTreeDragDest 
 *    used for objects of NspGtkTreeDragDest type (i.e built with new_gtktreedragdest) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeDragDest *new_type_gtktreedragdest(type_mode mode)
{
  NspTypeGtkTreeDragDest *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreedragdest != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreedragdest;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreedragdest_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreedragdest_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreedragdest;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreedragdest */ 

  top->s_type =  (s_type_func *) nsp_gtktreedragdest_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreedragdest_type_short_string;
  /* top->create = (create_func*) int_gtktreedragdest_create;*/

  /* specific methods for gtktreedragdest */

  type->init = (init_func *) init_gtktreedragdest;

  /* 
   * NspGtkTreeDragDest interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktreedragdest_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeDragDest called nsp_type_gtktreedragdest
       */
      type->id =  nsp_type_gtktreedragdest_id = nsp_new_type_id();
      nsp_type_gtktreedragdest = type;
      if ( nsp_register_type(nsp_type_gtktreedragdest) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreedragdest, GTK_TYPE_TREE_DRAG_DEST);
      return ( mode == T_BASE ) ? type : new_type_gtktreedragdest(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreedragdest_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeDragDest instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreedragdest(NspGtkTreeDragDest *Obj,NspTypeGtkTreeDragDest *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeDragDest 
 */

NspGtkTreeDragDest *new_gtktreedragdest() 
{
  NspGtkTreeDragDest *loc;
  /* type must exists */
  nsp_type_gtktreedragdest = new_type_gtktreedragdest(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeDragDest)))== NULLGTKTREEDRAGDEST) return loc;
  /* initialize object */
  if ( init_gtktreedragdest(loc,nsp_type_gtktreedragdest) == FAIL) return NULLGTKTREEDRAGDEST;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeDragDest 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreedragdest_type_name[]="GtkTreeDragDest";
static char gtktreedragdest_short_type_name[]="GtkTreeDragDest";

static char *nsp_gtktreedragdest_type_as_string(void)
{
  return(gtktreedragdest_type_name);
}

static char *nsp_gtktreedragdest_type_short_string(NspObject *v)
{
  return(gtktreedragdest_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeDragDest objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeDragDest   *nsp_gtktreedragdest_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtktreedragdest_id)   ) return ((NspGtkTreeDragDest *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreedragdest));
  return NULL;
}

int IsGtkTreeDragDestObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtktreedragdest_id);
}

int IsGtkTreeDragDest(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtktreedragdest_id);
}

NspGtkTreeDragDest  *GetGtkTreeDragDestCopy(Stack stack, int i)
{
  if (  GetGtkTreeDragDest(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeDragDest  *GetGtkTreeDragDest(Stack stack, int i)
{
  NspGtkTreeDragDest *M;
  if (( M = nsp_gtktreedragdest_object(NthObj(i))) == NULLGTKTREEDRAGDEST)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeDragDest *gtktreedragdest_copy(NspGtkTreeDragDest *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreedragdest);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreedragdest);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeDragDest
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_tree_drag_dest_drag_data_received(NspGtkTreeDragDest *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreePath *dest = NULL;
  NspObject *nsp_dest = NULL, *nsp_selection_data = NULL;
  GtkSelectionData *selection_data = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_dest, &nsp_selection_data) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_dest, GTK_TYPE_TREE_PATH))
      dest = nspg_boxed_get(nsp_dest, GtkTreePath);
  else {
      Scierror( "Error: dest should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_selection_data, GTK_TYPE_SELECTION_DATA))
      selection_data = nspg_boxed_get(nsp_selection_data, GtkSelectionData);
  else {
      Scierror( "Error: selection_data should be a GtkSelectionData\n");
      return RET_BUG;
  }
    ret =gtk_tree_drag_dest_drag_data_received(GTK_TREE_DRAG_DEST(self->obj),dest,selection_data);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_drag_dest_row_drop_possible(NspGtkTreeDragDest *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreePath *dest_path = NULL;
  NspObject *nsp_dest_path = NULL, *nsp_selection_data = NULL;
  GtkSelectionData *selection_data = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_dest_path, &nsp_selection_data) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_dest_path, GTK_TYPE_TREE_PATH))
      dest_path = nspg_boxed_get(nsp_dest_path, GtkTreePath);
  else {
      Scierror( "Error: dest_path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_selection_data, GTK_TYPE_SELECTION_DATA))
      selection_data = nspg_boxed_get(nsp_selection_data, GtkSelectionData);
  else {
      Scierror( "Error: selection_data should be a GtkSelectionData\n");
      return RET_BUG;
  }
    ret =gtk_tree_drag_dest_row_drop_possible(GTK_TREE_DRAG_DEST(self->obj),dest_path,selection_data);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktreedragdest_methods[] = {
  {"drag_data_received",(nsp_method *) _wrap_gtk_tree_drag_dest_drag_data_received},
  {"row_drop_possible",(nsp_method *) _wrap_gtk_tree_drag_dest_row_drop_possible},
  { NULL, NULL}
};

static NspMethods *gtktreedragdest_get_methods(void) { return gtktreedragdest_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreedragdest_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeDragSource ----------- */


#define  NspGtkTreeDragSource_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreedragsource.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeDragSource inherits from GObject 
 */

int nsp_type_gtktreedragsource_id=0;
NspTypeGtkTreeDragSource *nsp_type_gtktreedragsource=NULL;

/*
 * Type object for NspGtkTreeDragSource 
 * all the instance of NspTypeGtkTreeDragSource share the same id. 
 * nsp_type_gtktreedragsource: is an instance of NspTypeGtkTreeDragSource 
 *    used for objects of NspGtkTreeDragSource type (i.e built with new_gtktreedragsource) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeDragSource *new_type_gtktreedragsource(type_mode mode)
{
  NspTypeGtkTreeDragSource *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreedragsource != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreedragsource;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreedragsource_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreedragsource_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreedragsource;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreedragsource */ 

  top->s_type =  (s_type_func *) nsp_gtktreedragsource_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreedragsource_type_short_string;
  /* top->create = (create_func*) int_gtktreedragsource_create;*/

  /* specific methods for gtktreedragsource */

  type->init = (init_func *) init_gtktreedragsource;

  /* 
   * NspGtkTreeDragSource interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktreedragsource_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeDragSource called nsp_type_gtktreedragsource
       */
      type->id =  nsp_type_gtktreedragsource_id = nsp_new_type_id();
      nsp_type_gtktreedragsource = type;
      if ( nsp_register_type(nsp_type_gtktreedragsource) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreedragsource, GTK_TYPE_TREE_DRAG_SOURCE);
      return ( mode == T_BASE ) ? type : new_type_gtktreedragsource(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreedragsource_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeDragSource instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreedragsource(NspGtkTreeDragSource *Obj,NspTypeGtkTreeDragSource *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeDragSource 
 */

NspGtkTreeDragSource *new_gtktreedragsource() 
{
  NspGtkTreeDragSource *loc;
  /* type must exists */
  nsp_type_gtktreedragsource = new_type_gtktreedragsource(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeDragSource)))== NULLGTKTREEDRAGSOURCE) return loc;
  /* initialize object */
  if ( init_gtktreedragsource(loc,nsp_type_gtktreedragsource) == FAIL) return NULLGTKTREEDRAGSOURCE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeDragSource 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreedragsource_type_name[]="GtkTreeDragSource";
static char gtktreedragsource_short_type_name[]="GtkTreeDragSource";

static char *nsp_gtktreedragsource_type_as_string(void)
{
  return(gtktreedragsource_type_name);
}

static char *nsp_gtktreedragsource_type_short_string(NspObject *v)
{
  return(gtktreedragsource_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeDragSource objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeDragSource   *nsp_gtktreedragsource_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_implements (O,nsp_type_gtktreedragsource_id)   ) return ((NspGtkTreeDragSource *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreedragsource));
  return NULL;
}

int IsGtkTreeDragSourceObj(Stack stack, int i)
{
  return nsp_object_implements(NthObj(i),nsp_type_gtktreedragsource_id);
}

int IsGtkTreeDragSource(NspObject *O)
{
  return nsp_object_implements(O,nsp_type_gtktreedragsource_id);
}

NspGtkTreeDragSource  *GetGtkTreeDragSourceCopy(Stack stack, int i)
{
  if (  GetGtkTreeDragSource(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeDragSource  *GetGtkTreeDragSource(Stack stack, int i)
{
  NspGtkTreeDragSource *M;
  if (( M = nsp_gtktreedragsource_object(NthObj(i))) == NULLGTKTREEDRAGSOURCE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeDragSource *gtktreedragsource_copy(NspGtkTreeDragSource *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreedragsource);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreedragsource);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeDragSource
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_tree_drag_source_row_draggable(NspGtkTreeDragSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_drag_source_row_draggable(GTK_TREE_DRAG_SOURCE(self->obj),path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_drag_source_drag_data_delete(NspGtkTreeDragSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_drag_source_drag_data_delete(GTK_TREE_DRAG_SOURCE(self->obj),path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_drag_source_drag_data_get(NspGtkTreeDragSource *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_selection_data = NULL;
  GtkSelectionData *selection_data = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_selection_data) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_selection_data, GTK_TYPE_SELECTION_DATA))
      selection_data = nspg_boxed_get(nsp_selection_data, GtkSelectionData);
  else {
      Scierror( "Error: selection_data should be a GtkSelectionData\n");
      return RET_BUG;
  }
    ret =gtk_tree_drag_source_drag_data_get(GTK_TREE_DRAG_SOURCE(self->obj),path,selection_data);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktreedragsource_methods[] = {
  {"row_draggable",(nsp_method *) _wrap_gtk_tree_drag_source_row_draggable},
  {"drag_data_delete",(nsp_method *) _wrap_gtk_tree_drag_source_drag_data_delete},
  {"drag_data_get",(nsp_method *) _wrap_gtk_tree_drag_source_drag_data_get},
  { NULL, NULL}
};

static NspMethods *gtktreedragsource_get_methods(void) { return gtktreedragsource_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreedragsource_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkApplication ----------- */


#define  NspGtkApplication_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkapplication.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkApplication inherits from GApplication 
 * and implements GActionGroup GActionMap
 */

int nsp_type_gtkapplication_id=0;
NspTypeGtkApplication *nsp_type_gtkapplication=NULL;

/*
 * Type object for NspGtkApplication 
 * all the instance of NspTypeGtkApplication share the same id. 
 * nsp_type_gtkapplication: is an instance of NspTypeGtkApplication 
 *    used for objects of NspGtkApplication type (i.e built with new_gtkapplication) 
 * other instances are used for derived classes 
 */
NspTypeGtkApplication *new_type_gtkapplication(type_mode mode)
{
  NspTypeGActionGroup *t_gactiongroup;
  NspTypeGActionMap *t_gactionmap;
  NspTypeGtkApplication *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkapplication != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkapplication;
    }
  if (( type =  malloc(sizeof(NspTypeGApplication))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gapplication(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkapplication_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkapplication_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkapplication;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkapplication */ 

  top->s_type =  (s_type_func *) nsp_gtkapplication_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkapplication_type_short_string;
  /* top->create = (create_func*) int_gtkapplication_create;*/

  /* specific methods for gtkapplication */

  type->init = (init_func *) init_gtkapplication;

  /* 
   * NspGtkApplication interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gactiongroup = new_type_gactiongroup(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gactiongroup;
  t_gactionmap = new_type_gactionmap(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gactionmap;
  if ( nsp_type_gtkapplication_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkApplication called nsp_type_gtkapplication
       */
      type->id =  nsp_type_gtkapplication_id = nsp_new_type_id();
      nsp_type_gtkapplication = type;
      if ( nsp_register_type(nsp_type_gtkapplication) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkapplication, GTK_TYPE_APPLICATION);
      return ( mode == T_BASE ) ? type : new_type_gtkapplication(mode);
    }
  else 
    {
      type->id = nsp_type_gtkapplication_id;
      return type;
    }
}

/*
 * initialize NspGtkApplication instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkapplication(NspGtkApplication *Obj,NspTypeGtkApplication *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkApplication 
 */

NspGtkApplication *new_gtkapplication() 
{
  NspGtkApplication *loc;
  /* type must exists */
  nsp_type_gtkapplication = new_type_gtkapplication(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkApplication)))== NULLGTKAPPLICATION) return loc;
  /* initialize object */
  if ( init_gtkapplication(loc,nsp_type_gtkapplication) == FAIL) return NULLGTKAPPLICATION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkApplication 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkapplication_type_name[]="GtkApplication";
static char gtkapplication_short_type_name[]="GtkApplication";

static char *nsp_gtkapplication_type_as_string(void)
{
  return(gtkapplication_type_name);
}

static char *nsp_gtkapplication_type_short_string(NspObject *v)
{
  return(gtkapplication_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkApplication objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkApplication   *nsp_gtkapplication_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkapplication_id)  == TRUE  ) return ((NspGtkApplication *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkapplication));
  return NULL;
}

int IsGtkApplicationObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkapplication_id);
}

int IsGtkApplication(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkapplication_id);
}

NspGtkApplication  *GetGtkApplicationCopy(Stack stack, int i)
{
  if (  GetGtkApplication(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkApplication  *GetGtkApplication(Stack stack, int i)
{
  NspGtkApplication *M;
  if (( M = nsp_gtkapplication_object(NthObj(i))) == NULLGTKAPPLICATION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkApplication *gtkapplication_copy(NspGtkApplication *self)
{
  /* return gapplication_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkapplication);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkapplication);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkApplication
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_application_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *application_id;
  GApplicationFlags flags;
  NspObject *nsp_flags = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&application_id, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(G_TYPE_APPLICATION_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_application_new(application_id,flags))== NULL) return RET_BUG;

  nsp_type_gtkapplication = new_type_gtkapplication(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkapplication);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_application_add_window(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &window) == FAIL) return RET_BUG;
    gtk_application_add_window(GTK_APPLICATION(self->obj),GTK_WINDOW(window->obj));
  return 0;
}

static int _wrap_gtk_application_remove_window(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &window) == FAIL) return RET_BUG;
    gtk_application_remove_window(GTK_APPLICATION(self->obj),GTK_WINDOW(window->obj));
  return 0;
}

static int _wrap_gtk_application_get_windows(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_application_get_windows(GTK_APPLICATION(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_application_get_app_menu(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  GMenuModel *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_application_get_app_menu(GTK_APPLICATION(self->obj));
  nsp_type_gmenumodel = new_type_gmenumodel(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gmenumodel))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_application_get_app_menu(Stack stack, int rhs, int opt, int lhs) /* get_app_menu */
{
  Scierror("Error: function gtk_application_get_app_menu not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_application_set_app_menu(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *app_menu;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gmenumodel, &app_menu) == FAIL) return RET_BUG;
    gtk_application_set_app_menu(GTK_APPLICATION(self->obj),G_MENU_MODEL(app_menu->obj));
  return 0;
}

#else
int _wrap_gtk_application_set_app_menu(Stack stack, int rhs, int opt, int lhs) /* set_app_menu */
{
  Scierror("Error: function gtk_application_set_app_menu not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_application_get_menubar(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  GMenuModel *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_application_get_menubar(GTK_APPLICATION(self->obj));
  nsp_type_gmenumodel = new_type_gmenumodel(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gmenumodel))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_application_get_menubar(Stack stack, int rhs, int opt, int lhs) /* get_menubar */
{
  Scierror("Error: function gtk_application_get_menubar not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_application_set_menubar(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *menubar;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gmenumodel, &menubar) == FAIL) return RET_BUG;
    gtk_application_set_menubar(GTK_APPLICATION(self->obj),G_MENU_MODEL(menubar->obj));
  return 0;
}

#else
int _wrap_gtk_application_set_menubar(Stack stack, int rhs, int opt, int lhs) /* set_menubar */
{
  Scierror("Error: function gtk_application_set_menubar not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_application_inhibit(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,string, t_end};
  NspGObject *window;
  GtkApplicationInhibitFlags flags;
  NspObject *nsp_flags = NULL;
  char *reason;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &window, &nsp_flags, &reason) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_APPLICATION_INHIBIT_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    ret =gtk_application_inhibit(GTK_APPLICATION(self->obj),GTK_WINDOW(window->obj),flags,reason);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_application_inhibit(Stack stack, int rhs, int opt, int lhs) /* inhibit */
{
  Scierror("Error: function gtk_application_inhibit not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_application_uninhibit(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int cookie;
  if ( GetArgs(stack,rhs,opt,T,&cookie) == FAIL) return RET_BUG;
    gtk_application_uninhibit(GTK_APPLICATION(self->obj),cookie);
  return 0;
}

#else
int _wrap_gtk_application_uninhibit(Stack stack, int rhs, int opt, int lhs) /* uninhibit */
{
  Scierror("Error: function gtk_application_uninhibit not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_application_is_inhibited(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkApplicationInhibitFlags flags;
  NspObject *nsp_flags = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_APPLICATION_INHIBIT_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    ret =gtk_application_is_inhibited(GTK_APPLICATION(self->obj),flags);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_application_is_inhibited(Stack stack, int rhs, int opt, int lhs) /* is_inhibited */
{
  Scierror("Error: function gtk_application_is_inhibited not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_application_get_window_by_id(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int id;
  GtkWindow *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&id) == FAIL) return RET_BUG;
    ret =gtk_application_get_window_by_id(GTK_APPLICATION(self->obj),id);
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_application_get_window_by_id(Stack stack, int rhs, int opt, int lhs) /* get_window_by_id */
{
  Scierror("Error: function gtk_application_get_window_by_id not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_application_get_active_window(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_application_get_active_window(GTK_APPLICATION(self->obj));
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_application_get_active_window(Stack stack, int rhs, int opt, int lhs) /* get_active_window */
{
  Scierror("Error: function gtk_application_get_active_window not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_application_list_action_descriptions(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar **ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_application_list_action_descriptions(GTK_APPLICATION(self->obj));
  nsp_ret = (NspObject *) nsp_smatrix_create_from_table(ret);
  if ( nsp_ret == NULL) return RET_BUG;
  g_strfreev(ret);
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_application_list_action_descriptions(Stack stack, int rhs, int opt, int lhs) /* list_action_descriptions */
{
  Scierror("Error: function gtk_application_list_action_descriptions not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_application_get_accels_for_action(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *detailed_action_name;
  gchar **ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&detailed_action_name) == FAIL) return RET_BUG;
    ret =gtk_application_get_accels_for_action(GTK_APPLICATION(self->obj),detailed_action_name);
  nsp_ret = (NspObject *) nsp_smatrix_create_from_table(ret);
  if ( nsp_ret == NULL) return RET_BUG;
  g_strfreev(ret);
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_application_get_accels_for_action(Stack stack, int rhs, int opt, int lhs) /* get_accels_for_action */
{
  Scierror("Error: function gtk_application_get_accels_for_action not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_application_get_actions_for_accel(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *accel;
  gchar **ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&accel) == FAIL) return RET_BUG;
    ret =gtk_application_get_actions_for_accel(GTK_APPLICATION(self->obj),accel);
  nsp_ret = (NspObject *) nsp_smatrix_create_from_table(ret);
  if ( nsp_ret == NULL) return RET_BUG;
  g_strfreev(ret);
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_application_get_actions_for_accel(Stack stack, int rhs, int opt, int lhs) /* get_actions_for_accel */
{
  Scierror("Error: function gtk_application_get_actions_for_accel not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_application_prefers_app_menu(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_application_prefers_app_menu(GTK_APPLICATION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_application_prefers_app_menu(Stack stack, int rhs, int opt, int lhs) /* prefers_app_menu */
{
  Scierror("Error: function gtk_application_prefers_app_menu not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_application_get_menu_by_id(NspGtkApplication *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *id;
  GMenu *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&id) == FAIL) return RET_BUG;
    ret =gtk_application_get_menu_by_id(GTK_APPLICATION(self->obj),id);
  nsp_type_gmenu = new_type_gmenu(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gmenu))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_application_get_menu_by_id(Stack stack, int rhs, int opt, int lhs) /* get_menu_by_id */
{
  Scierror("Error: function gtk_application_get_menu_by_id not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkapplication_methods[] = {
  {"add_window",(nsp_method *) _wrap_gtk_application_add_window},
  {"remove_window",(nsp_method *) _wrap_gtk_application_remove_window},
  {"get_windows",(nsp_method *) _wrap_gtk_application_get_windows},
  {"get_app_menu",(nsp_method *) _wrap_gtk_application_get_app_menu},
  {"set_app_menu",(nsp_method *) _wrap_gtk_application_set_app_menu},
  {"get_menubar",(nsp_method *) _wrap_gtk_application_get_menubar},
  {"set_menubar",(nsp_method *) _wrap_gtk_application_set_menubar},
  {"inhibit",(nsp_method *) _wrap_gtk_application_inhibit},
  {"uninhibit",(nsp_method *) _wrap_gtk_application_uninhibit},
  {"is_inhibited",(nsp_method *) _wrap_gtk_application_is_inhibited},
  {"get_window_by_id",(nsp_method *) _wrap_gtk_application_get_window_by_id},
  {"get_active_window",(nsp_method *) _wrap_gtk_application_get_active_window},
  {"list_action_descriptions",(nsp_method *) _wrap_gtk_application_list_action_descriptions},
  {"get_accels_for_action",(nsp_method *) _wrap_gtk_application_get_accels_for_action},
  {"get_actions_for_accel",(nsp_method *) _wrap_gtk_application_get_actions_for_accel},
  {"prefers_app_menu",(nsp_method *) _wrap_gtk_application_prefers_app_menu},
  {"get_menu_by_id",(nsp_method *) _wrap_gtk_application_get_menu_by_id},
  { NULL, NULL}
};

static NspMethods *gtkapplication_get_methods(void) { return gtkapplication_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkapplication_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkApplicationWindow ----------- */


#define  NspGtkApplicationWindow_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkapplicationwindow.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkApplicationWindow inherits from GtkWindow 
 * and implements GtkBuildable GActionGroup GActionMap
 */

int nsp_type_gtkapplicationwindow_id=0;
NspTypeGtkApplicationWindow *nsp_type_gtkapplicationwindow=NULL;

/*
 * Type object for NspGtkApplicationWindow 
 * all the instance of NspTypeGtkApplicationWindow share the same id. 
 * nsp_type_gtkapplicationwindow: is an instance of NspTypeGtkApplicationWindow 
 *    used for objects of NspGtkApplicationWindow type (i.e built with new_gtkapplicationwindow) 
 * other instances are used for derived classes 
 */
NspTypeGtkApplicationWindow *new_type_gtkapplicationwindow(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGActionGroup *t_gactiongroup;
  NspTypeGActionMap *t_gactionmap;
  NspTypeGtkApplicationWindow *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkapplicationwindow != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkapplicationwindow;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWindow))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwindow(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkapplicationwindow_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkapplicationwindow_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkapplicationwindow;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkapplicationwindow */ 

  top->s_type =  (s_type_func *) nsp_gtkapplicationwindow_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkapplicationwindow_type_short_string;
  /* top->create = (create_func*) int_gtkapplicationwindow_create;*/

  /* specific methods for gtkapplicationwindow */

  type->init = (init_func *) init_gtkapplicationwindow;

  /* 
   * NspGtkApplicationWindow interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  t_gactiongroup = new_type_gactiongroup(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gactiongroup;
  t_gactionmap = new_type_gactionmap(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gactionmap;
  if ( nsp_type_gtkapplicationwindow_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkApplicationWindow called nsp_type_gtkapplicationwindow
       */
      type->id =  nsp_type_gtkapplicationwindow_id = nsp_new_type_id();
      nsp_type_gtkapplicationwindow = type;
      if ( nsp_register_type(nsp_type_gtkapplicationwindow) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkapplicationwindow, GTK_TYPE_APPLICATION_WINDOW);
      return ( mode == T_BASE ) ? type : new_type_gtkapplicationwindow(mode);
    }
  else 
    {
      type->id = nsp_type_gtkapplicationwindow_id;
      return type;
    }
}

/*
 * initialize NspGtkApplicationWindow instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkapplicationwindow(NspGtkApplicationWindow *Obj,NspTypeGtkApplicationWindow *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkApplicationWindow 
 */

NspGtkApplicationWindow *new_gtkapplicationwindow() 
{
  NspGtkApplicationWindow *loc;
  /* type must exists */
  nsp_type_gtkapplicationwindow = new_type_gtkapplicationwindow(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkApplicationWindow)))== NULLGTKAPPLICATIONWINDOW) return loc;
  /* initialize object */
  if ( init_gtkapplicationwindow(loc,nsp_type_gtkapplicationwindow) == FAIL) return NULLGTKAPPLICATIONWINDOW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkApplicationWindow 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkapplicationwindow_type_name[]="GtkApplicationWindow";
static char gtkapplicationwindow_short_type_name[]="GtkApplicationWindow";

static char *nsp_gtkapplicationwindow_type_as_string(void)
{
  return(gtkapplicationwindow_type_name);
}

static char *nsp_gtkapplicationwindow_type_short_string(NspObject *v)
{
  return(gtkapplicationwindow_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkApplicationWindow objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkApplicationWindow   *nsp_gtkapplicationwindow_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkapplicationwindow_id)  == TRUE  ) return ((NspGtkApplicationWindow *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkapplicationwindow));
  return NULL;
}

int IsGtkApplicationWindowObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkapplicationwindow_id);
}

int IsGtkApplicationWindow(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkapplicationwindow_id);
}

NspGtkApplicationWindow  *GetGtkApplicationWindowCopy(Stack stack, int i)
{
  if (  GetGtkApplicationWindow(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkApplicationWindow  *GetGtkApplicationWindow(Stack stack, int i)
{
  NspGtkApplicationWindow *M;
  if (( M = nsp_gtkapplicationwindow_object(NthObj(i))) == NULLGTKAPPLICATIONWINDOW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkApplicationWindow *gtkapplicationwindow_copy(NspGtkApplicationWindow *self)
{
  /* return gtkwindow_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkapplicationwindow);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkapplicationwindow);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkApplicationWindow
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_application_window_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *application;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkapplication, &application) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_application_window_new(GTK_APPLICATION(application->obj)))== NULL) return RET_BUG;

  nsp_type_gtkapplicationwindow = new_type_gtkapplicationwindow(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkapplicationwindow);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_application_window_set_show_menubar(NspGtkApplicationWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_menubar;
  if ( GetArgs(stack,rhs,opt,T,&show_menubar) == FAIL) return RET_BUG;
    gtk_application_window_set_show_menubar(GTK_APPLICATION_WINDOW(self->obj),show_menubar);
  return 0;
}

#else
int _wrap_gtk_application_window_set_show_menubar(Stack stack, int rhs, int opt, int lhs) /* set_show_menubar */
{
  Scierror("Error: function gtk_application_window_set_show_menubar not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_application_window_get_show_menubar(NspGtkApplicationWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_application_window_get_show_menubar(GTK_APPLICATION_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_application_window_get_show_menubar(Stack stack, int rhs, int opt, int lhs) /* get_show_menubar */
{
  Scierror("Error: function gtk_application_window_get_show_menubar not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_application_window_get_id(NspGtkApplicationWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_application_window_get_id(GTK_APPLICATION_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_application_window_get_id(Stack stack, int rhs, int opt, int lhs) /* get_id */
{
  Scierror("Error: function gtk_application_window_get_id not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkapplicationwindow_methods[] = {
  {"set_show_menubar",(nsp_method *) _wrap_gtk_application_window_set_show_menubar},
  {"get_show_menubar",(nsp_method *) _wrap_gtk_application_window_get_show_menubar},
  {"get_id",(nsp_method *) _wrap_gtk_application_window_get_id},
  { NULL, NULL}
};

static NspMethods *gtkapplicationwindow_get_methods(void) { return gtkapplicationwindow_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkapplicationwindow_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkBuilder ----------- */


#define  NspGtkBuilder_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkbuilder.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkBuilder inherits from GObject 
 */

int nsp_type_gtkbuilder_id=0;
NspTypeGtkBuilder *nsp_type_gtkbuilder=NULL;

/*
 * Type object for NspGtkBuilder 
 * all the instance of NspTypeGtkBuilder share the same id. 
 * nsp_type_gtkbuilder: is an instance of NspTypeGtkBuilder 
 *    used for objects of NspGtkBuilder type (i.e built with new_gtkbuilder) 
 * other instances are used for derived classes 
 */
NspTypeGtkBuilder *new_type_gtkbuilder(type_mode mode)
{
  NspTypeGtkBuilder *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkbuilder != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkbuilder;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkbuilder_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkbuilder_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkbuilder;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkbuilder */ 

  top->s_type =  (s_type_func *) nsp_gtkbuilder_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkbuilder_type_short_string;
  /* top->create = (create_func*) int_gtkbuilder_create;*/

  /* specific methods for gtkbuilder */

  type->init = (init_func *) init_gtkbuilder;

  /* 
   * NspGtkBuilder interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkbuilder_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkBuilder called nsp_type_gtkbuilder
       */
      type->id =  nsp_type_gtkbuilder_id = nsp_new_type_id();
      nsp_type_gtkbuilder = type;
      if ( nsp_register_type(nsp_type_gtkbuilder) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkbuilder, GTK_TYPE_BUILDER);
      return ( mode == T_BASE ) ? type : new_type_gtkbuilder(mode);
    }
  else 
    {
      type->id = nsp_type_gtkbuilder_id;
      return type;
    }
}

/*
 * initialize NspGtkBuilder instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkbuilder(NspGtkBuilder *Obj,NspTypeGtkBuilder *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkBuilder 
 */

NspGtkBuilder *new_gtkbuilder() 
{
  NspGtkBuilder *loc;
  /* type must exists */
  nsp_type_gtkbuilder = new_type_gtkbuilder(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkBuilder)))== NULLGTKBUILDER) return loc;
  /* initialize object */
  if ( init_gtkbuilder(loc,nsp_type_gtkbuilder) == FAIL) return NULLGTKBUILDER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkBuilder 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkbuilder_type_name[]="GtkBuilder";
static char gtkbuilder_short_type_name[]="GtkBuilder";

static char *nsp_gtkbuilder_type_as_string(void)
{
  return(gtkbuilder_type_name);
}

static char *nsp_gtkbuilder_type_short_string(NspObject *v)
{
  return(gtkbuilder_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkBuilder objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkBuilder   *nsp_gtkbuilder_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkbuilder_id)  == TRUE  ) return ((NspGtkBuilder *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkbuilder));
  return NULL;
}

int IsGtkBuilderObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkbuilder_id);
}

int IsGtkBuilder(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkbuilder_id);
}

NspGtkBuilder  *GetGtkBuilderCopy(Stack stack, int i)
{
  if (  GetGtkBuilder(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkBuilder  *GetGtkBuilder(Stack stack, int i)
{
  NspGtkBuilder *M;
  if (( M = nsp_gtkbuilder_object(NthObj(i))) == NULLGTKBUILDER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkBuilder *gtkbuilder_copy(NspGtkBuilder *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbuilder);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbuilder);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkBuilder
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_builder_new_from_string (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,s_int, t_end};
  char *string;
  int length;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&string, &length) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_builder_new_from_string(string,length))== NULL) return RET_BUG;

  nsp_type_gtkbuilder = new_type_gtkbuilder(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbuilder);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_builder_new_from_resource (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *resource_path;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&resource_path) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_builder_new_from_resource(resource_path))== NULL) return RET_BUG;

  nsp_type_gtkbuilder = new_type_gtkbuilder(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbuilder);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_builder_new_from_file (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *filename;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_builder_new_from_file(filename))== NULL) return RET_BUG;

  nsp_type_gtkbuilder = new_type_gtkbuilder(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbuilder);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_builder_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_builder_new())== NULL) return RET_BUG;

  nsp_type_gtkbuilder = new_type_gtkbuilder(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbuilder);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_builder_add_from_file(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *filename;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    ret =gtk_builder_add_from_file(GTK_BUILDER(self->obj),filename,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_builder_add_from_resource(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *resource_path;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&resource_path) == FAIL) return RET_BUG;
    ret =gtk_builder_add_from_resource(GTK_BUILDER(self->obj),resource_path,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 7952 "codegen-3.0/gtk.override"

static int _wrap_gtk_builder_add_from_string(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  NspSMatrix *S,*S1;
  CheckRhs(1,1);
  CheckLhs(0,0);
  if ((S = GetSMat(stack,1)) == NULLSMAT) return RET_BUG;
  if ((S1= nsp_smatrix_row_concat(S,"\n",1))  == NULLSMAT) return RET_BUG;
  ret =gtk_builder_add_from_string(GTK_BUILDER(self->obj),S1->S[0],-1,NULL);
  nsp_smatrix_destroy(S1);
  if ( ret == 0 )
    {
      Scierror("Error: add_from_string failed for gtk_builder\n");
      return RET_BUG;
    }
  return 0;
}
#line 12340 "gtk.c"


static int _wrap_gtk_builder_add_objects_from_file(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *filename;
  gchar **object_ids = NULL;
  NspObject *nsp_object_ids = NULL;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&filename, &nsp_object_ids) == FAIL) return RET_BUG;
  if ( IsSMat(nsp_object_ids))
    { object_ids =  ((NspSMatrix *) nsp_object_ids)->S;}
  else
    {
      Scierror("Error: object_ids should be of type SMat\n");
      return RET_BUG;
    }
    ret =gtk_builder_add_objects_from_file(GTK_BUILDER(self->obj),filename,object_ids,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_builder_add_objects_from_resource(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *resource_path;
  gchar **object_ids = NULL;
  NspObject *nsp_object_ids = NULL;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&resource_path, &nsp_object_ids) == FAIL) return RET_BUG;
  if ( IsSMat(nsp_object_ids))
    { object_ids =  ((NspSMatrix *) nsp_object_ids)->S;}
  else
    {
      Scierror("Error: object_ids should be of type SMat\n");
      return RET_BUG;
    }
    ret =gtk_builder_add_objects_from_resource(GTK_BUILDER(self->obj),resource_path,object_ids,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_builder_add_objects_from_resource(Stack stack, int rhs, int opt, int lhs) /* add_objects_from_resource */
{
  Scierror("Error: function gtk_builder_add_objects_from_resource not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_builder_add_objects_from_string(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int,obj, t_end};
  char *buffer;
  int length, ret;
  gchar **object_ids = NULL;
  NspObject *nsp_object_ids = NULL;
  GError *error = NULL;
  if ( GetArgs(stack,rhs,opt,T,&buffer, &length, &nsp_object_ids) == FAIL) return RET_BUG;
  if ( IsSMat(nsp_object_ids))
    { object_ids =  ((NspSMatrix *) nsp_object_ids)->S;}
  else
    {
      Scierror("Error: object_ids should be of type SMat\n");
      return RET_BUG;
    }
    ret =gtk_builder_add_objects_from_string(GTK_BUILDER(self->obj),buffer,length,object_ids,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 7778 "codegen-3.0/gtk.override"

/* GObject* in return generate wrong code */
static int _wrap_gtk_builder_get_object(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject* nsp_ret;
  int_types T[] = {string, t_end};
  char *name;
  GObject *ret;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
  ret =gtk_builder_get_object(GTK_BUILDER(self->obj),name);
  if (ret == NULL ) return RET_BUG;
  if ((nsp_ret = (NspObject *) nspgobject_new(NVOID,ret))==NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 12443 "gtk.c"


static int _wrap_gtk_builder_get_objects(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_builder_get_objects(GTK_BUILDER(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_builder_expose_object(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj_check, t_end};
  char *name;
  NspGObject *object = NULL;
  if ( GetArgs(stack,rhs,opt,T,&name, &nsp_type_gobject, &object) == FAIL) return RET_BUG;
    gtk_builder_expose_object(GTK_BUILDER(self->obj),name,G_OBJECT(object->obj));
  return 0;
}

#else
int _wrap_gtk_builder_expose_object(Stack stack, int rhs, int opt, int lhs) /* expose_object */
{
  Scierror("Error: function gtk_builder_expose_object not available\n");
  return RET_BUG;
}
#endif
#line 7807 "codegen-3.0/gtk.override"

typedef struct _builder_connect_infos builder_connect_infos;
 
struct _builder_connect_infos
{
  NspHash *handlers;
  NspObject *args;
};

static void
nsp_gtk_builder_connect_signals_default (GtkBuilder    *builder,
					 GObject       *object,
					 const gchar   *signal_name,
					 const gchar   *handler_name,
					 GObject       *connect_object,
					 GConnectFlags  flags,
					 gpointer       user_data)
{
  builder_connect_infos *info= user_data;
  guint sigid;
  GQuark detail = 0;
  GClosure *closure;
  NspObject *handler;/* a NspPList */
  NspObject *nsp_connect_object=NULL;
  NspObject *extra_args = info->args;

  if ( nsp_hash_find_and_copy(info->handlers, (char *) handler_name, &handler)== FAIL)
    {
      Sciprintf("Error: in connect_signals, failed to find handler %s\n",handler_name);
      return;
    }
  if  (IsNspPList(handler) == FALSE)
    {
      Sciprintf("Error: in connect_signals, handler %s should be a function\n",handler_name);
      return;
    }
  
  if ( extra_args != NULL)
    {
      if ((extra_args = nsp_object_copy_and_name("data", extra_args)) == NULL)
	{
	  Sciprintf("Error: in connect_signals, failed to copy extra argument\n");
	  return;
	}
    }
  
  if (connect_object)
    {
      if ((nsp_connect_object = (NspObject *) nspgobject_new("co_obj",connect_object))== NULL)
	{
	  Sciprintf("Error: in connect_signals, failed to copy object\n");
	  return;
	}
    }
  /* if (( handler =GetNspPListCopy(stack,2)) == NULLP_PLIST) return RET_BUG; */
  if (!g_signal_parse_name(signal_name,G_OBJECT_TYPE(object), &sigid, &detail, TRUE))
    {
      Sciprintf("method connect: unknown signal name (%s)\n",signal_name);
      return;
    }
  closure = nspg_closure_new((NspPList *) handler, (NspList *) extra_args,
			     (connect_object) ? nsp_connect_object : NULL);
  nsp_gobject_watch_closure( object , closure);
  g_signal_connect_closure_by_id(object, sigid, detail, closure, flags);
  return;
}

/* nsp_implementation : first argument is a hash table of handlers
 * second argument is the extra_args argument 
 */

static int _wrap_gtk_builder_connect_signals(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  NspHash *H;
  NspObject *Args;
  builder_connect_infos info;
  CheckStdRhs(1,2);
  CheckLhs(0,0);
  if ((H = GetHash(stack,1)) == NULLHASH) return RET_BUG;
  info.handlers = H;
  if ( rhs == 2 )
    {
      if ((Args= nsp_get_object(stack,2)) == NULL) return RET_BUG;
      info.args = Args;
    }
  else
    {
      info.args = NULL;
    }
  gtk_builder_connect_signals_full (GTK_BUILDER(self->obj),
				    nsp_gtk_builder_connect_signals_default,
				    &info);
  return 0;
}


#line 12571 "gtk.c"


static int _wrap_gtk_builder_set_translation_domain(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *domain;
  if ( GetArgs(stack,rhs,opt,T,&domain) == FAIL) return RET_BUG;
    gtk_builder_set_translation_domain(GTK_BUILDER(self->obj),domain);
  return 0;
}

static int _wrap_gtk_builder_get_translation_domain(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_builder_get_translation_domain(GTK_BUILDER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_builder_get_type_from_name(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *type_name;
  GType ret;
  if ( GetArgs(stack,rhs,opt,T,&type_name) == FAIL) return RET_BUG;
    ret =gtk_builder_get_type_from_name(GTK_BUILDER(self->obj),type_name);
  return nspg_type_wrapper_new(ret);
}

#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_builder_set_application(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *application;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkapplication, &application) == FAIL) return RET_BUG;
    gtk_builder_set_application(GTK_BUILDER(self->obj),GTK_APPLICATION(application->obj));
  return 0;
}

#else
int _wrap_gtk_builder_set_application(Stack stack, int rhs, int opt, int lhs) /* set_application */
{
  Scierror("Error: function gtk_builder_set_application not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_builder_get_application(NspGtkBuilder *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkApplication *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_builder_get_application(GTK_BUILDER(self->obj));
  nsp_type_gtkapplication = new_type_gtkapplication(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkapplication))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_builder_get_application(Stack stack, int rhs, int opt, int lhs) /* get_application */
{
  Scierror("Error: function gtk_builder_get_application not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkbuilder_methods[] = {
  {"add_from_file",(nsp_method *) _wrap_gtk_builder_add_from_file},
  {"add_from_resource",(nsp_method *) _wrap_gtk_builder_add_from_resource},
  {"add_from_string",(nsp_method *) _wrap_gtk_builder_add_from_string},
  {"add_objects_from_file",(nsp_method *) _wrap_gtk_builder_add_objects_from_file},
  {"add_objects_from_resource",(nsp_method *) _wrap_gtk_builder_add_objects_from_resource},
  {"add_objects_from_string",(nsp_method *) _wrap_gtk_builder_add_objects_from_string},
  {"get_object",(nsp_method *) _wrap_gtk_builder_get_object},
  {"get_objects",(nsp_method *) _wrap_gtk_builder_get_objects},
  {"expose_object",(nsp_method *) _wrap_gtk_builder_expose_object},
  {"connect_signals",(nsp_method *) _wrap_gtk_builder_connect_signals},
  {"set_translation_domain",(nsp_method *) _wrap_gtk_builder_set_translation_domain},
  {"get_translation_domain",(nsp_method *) _wrap_gtk_builder_get_translation_domain},
  {"get_type_from_name",(nsp_method *) _wrap_gtk_builder_get_type_from_name},
  {"set_application",(nsp_method *) _wrap_gtk_builder_set_application},
  {"get_application",(nsp_method *) _wrap_gtk_builder_get_application},
  { NULL, NULL}
};

static NspMethods *gtkbuilder_get_methods(void) { return gtkbuilder_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkbuilder_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkWindow ----------- */


#define  NspGtkWindow_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkwindow.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkWindow inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkwindow_id=0;
NspTypeGtkWindow *nsp_type_gtkwindow=NULL;

/*
 * Type object for NspGtkWindow 
 * all the instance of NspTypeGtkWindow share the same id. 
 * nsp_type_gtkwindow: is an instance of NspTypeGtkWindow 
 *    used for objects of NspGtkWindow type (i.e built with new_gtkwindow) 
 * other instances are used for derived classes 
 */
NspTypeGtkWindow *new_type_gtkwindow(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkWindow *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkwindow != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkwindow;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkwindow_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkwindow_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkwindow;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkwindow */ 

  top->s_type =  (s_type_func *) nsp_gtkwindow_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkwindow_type_short_string;
  /* top->create = (create_func*) int_gtkwindow_create;*/

  /* specific methods for gtkwindow */

  type->init = (init_func *) init_gtkwindow;

  /* 
   * NspGtkWindow interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkwindow_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkWindow called nsp_type_gtkwindow
       */
      type->id =  nsp_type_gtkwindow_id = nsp_new_type_id();
      nsp_type_gtkwindow = type;
      if ( nsp_register_type(nsp_type_gtkwindow) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkwindow, GTK_TYPE_WINDOW);
      return ( mode == T_BASE ) ? type : new_type_gtkwindow(mode);
    }
  else 
    {
      type->id = nsp_type_gtkwindow_id;
      return type;
    }
}

/*
 * initialize NspGtkWindow instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkwindow(NspGtkWindow *Obj,NspTypeGtkWindow *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkWindow 
 */

NspGtkWindow *new_gtkwindow() 
{
  NspGtkWindow *loc;
  /* type must exists */
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkWindow)))== NULLGTKWINDOW) return loc;
  /* initialize object */
  if ( init_gtkwindow(loc,nsp_type_gtkwindow) == FAIL) return NULLGTKWINDOW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkWindow 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkwindow_type_name[]="GtkWindow";
static char gtkwindow_short_type_name[]="GtkWindow";

static char *nsp_gtkwindow_type_as_string(void)
{
  return(gtkwindow_type_name);
}

static char *nsp_gtkwindow_type_short_string(NspObject *v)
{
  return(gtkwindow_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkWindow objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkWindow   *nsp_gtkwindow_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkwindow_id)  == TRUE  ) return ((NspGtkWindow *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkwindow));
  return NULL;
}

int IsGtkWindowObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkwindow_id);
}

int IsGtkWindow(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkwindow_id);
}

NspGtkWindow  *GetGtkWindowCopy(Stack stack, int i)
{
  if (  GetGtkWindow(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkWindow  *GetGtkWindow(Stack stack, int i)
{
  NspGtkWindow *M;
  if (( M = nsp_gtkwindow_object(NthObj(i))) == NULLGTKWINDOW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkWindow *gtkwindow_copy(NspGtkWindow *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwindow);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwindow);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkWindow
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_window_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"type",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkWindowType type = GTK_WINDOW_TOPLEVEL;
  NspObject *nsp_type = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_WINDOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_window_new(type))== NULL) return RET_BUG;

  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindow);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_set_title(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *title;
  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
    gtk_window_set_title(GTK_WINDOW(self->obj),title);
  return 0;
}

static int _wrap_gtk_window_get_title(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_window_get_title(GTK_WINDOW(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_wmclass(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,string, t_end};
  char *wmclass_name, *wmclass_class;
  if ( GetArgs(stack,rhs,opt,T,&wmclass_name, &wmclass_class) == FAIL) return RET_BUG;
    gtk_window_set_wmclass(GTK_WINDOW(self->obj),wmclass_name,wmclass_class);
  return 0;
}

static int _wrap_gtk_window_set_role(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *role;
  if ( GetArgs(stack,rhs,opt,T,&role) == FAIL) return RET_BUG;
    gtk_window_set_role(GTK_WINDOW(self->obj),role);
  return 0;
}

static int _wrap_gtk_window_set_startup_id(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *startup_id;
  if ( GetArgs(stack,rhs,opt,T,&startup_id) == FAIL) return RET_BUG;
    gtk_window_set_startup_id(GTK_WINDOW(self->obj),startup_id);
  return 0;
}

static int _wrap_gtk_window_get_role(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_window_get_role(GTK_WINDOW(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_add_accel_group(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *accel_group;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaccelgroup, &accel_group) == FAIL) return RET_BUG;
    gtk_window_add_accel_group(GTK_WINDOW(self->obj),GTK_ACCEL_GROUP(accel_group->obj));
  return 0;
}

static int _wrap_gtk_window_remove_accel_group(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *accel_group;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaccelgroup, &accel_group) == FAIL) return RET_BUG;
    gtk_window_remove_accel_group(GTK_WINDOW(self->obj),GTK_ACCEL_GROUP(accel_group->obj));
  return 0;
}

static int _wrap_gtk_window_set_position(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkWindowPosition position;
  NspObject *nsp_position = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_position) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_WINDOW_POSITION, nsp_position, &position)== FAIL)
      return RET_BUG;
    gtk_window_set_position(GTK_WINDOW(self->obj),position);
  return 0;
}

static int _wrap_gtk_window_activate_focus(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_activate_focus(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_focus(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *focus;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &focus) == FAIL) return RET_BUG;
    gtk_window_set_focus(GTK_WINDOW(self->obj),GTK_WIDGET(focus->obj));
  return 0;
}

static int _wrap_gtk_window_get_focus(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_window_get_focus(GTK_WINDOW(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_set_default(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *default_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &default_widget) == FAIL) return RET_BUG;
    gtk_window_set_default(GTK_WINDOW(self->obj),GTK_WIDGET(default_widget->obj));
  return 0;
}

static int _wrap_gtk_window_get_default_widget(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_window_get_default_widget(GTK_WINDOW(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_activate_default(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_activate_default(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_transient_for(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *parent;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &parent) == FAIL) return RET_BUG;
    gtk_window_set_transient_for(GTK_WINDOW(self->obj),GTK_WINDOW(parent->obj));
  return 0;
}

static int _wrap_gtk_window_get_transient_for(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_window_get_transient_for(GTK_WINDOW(self->obj));
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_window_set_attached_to(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *attach_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &attach_widget) == FAIL) return RET_BUG;
    gtk_window_set_attached_to(GTK_WINDOW(self->obj),GTK_WIDGET(attach_widget->obj));
  return 0;
}

#else
int _wrap_gtk_window_set_attached_to(Stack stack, int rhs, int opt, int lhs) /* set_attached_to */
{
  Scierror("Error: function gtk_window_set_attached_to not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_window_get_attached_to(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_window_get_attached_to(GTK_WINDOW(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_window_get_attached_to(Stack stack, int rhs, int opt, int lhs) /* get_attached_to */
{
  Scierror("Error: function gtk_window_get_attached_to not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_window_set_type_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkWindowTypeHint hint;
  NspObject *nsp_hint = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_hint) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GDK_TYPE_WINDOW_TYPE_HINT, nsp_hint, &hint)== FAIL)
      return RET_BUG;
    gtk_window_set_type_hint(GTK_WINDOW(self->obj),hint);
  return 0;
}

static int _wrap_gtk_window_get_type_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_window_get_type_hint(GTK_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_skip_taskbar_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_skip_taskbar_hint(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_get_skip_taskbar_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_skip_taskbar_hint(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_skip_pager_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_skip_pager_hint(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_get_skip_pager_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_skip_pager_hint(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_urgency_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_urgency_hint(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_get_urgency_hint(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_urgency_hint(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_accept_focus(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_accept_focus(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_get_accept_focus(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_accept_focus(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_focus_on_map(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_focus_on_map(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_get_focus_on_map(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_focus_on_map(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_destroy_with_parent(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_destroy_with_parent(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_get_destroy_with_parent(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_destroy_with_parent(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_window_set_hide_titlebar_when_maximized(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_hide_titlebar_when_maximized(GTK_WINDOW(self->obj),setting);
  return 0;
}

#else
int _wrap_gtk_window_set_hide_titlebar_when_maximized(Stack stack, int rhs, int opt, int lhs) /* set_hide_titlebar_when_maximized */
{
  Scierror("Error: function gtk_window_set_hide_titlebar_when_maximized not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_window_get_hide_titlebar_when_maximized(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_hide_titlebar_when_maximized(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_window_get_hide_titlebar_when_maximized(Stack stack, int rhs, int opt, int lhs) /* get_hide_titlebar_when_maximized */
{
  Scierror("Error: function gtk_window_get_hide_titlebar_when_maximized not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_window_set_mnemonics_visible(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_mnemonics_visible(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_get_mnemonics_visible(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_mnemonics_visible(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_window_set_focus_visible(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_focus_visible(GTK_WINDOW(self->obj),setting);
  return 0;
}

#else
int _wrap_gtk_window_set_focus_visible(Stack stack, int rhs, int opt, int lhs) /* set_focus_visible */
{
  Scierror("Error: function gtk_window_set_focus_visible not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_window_get_focus_visible(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_focus_visible(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_window_get_focus_visible(Stack stack, int rhs, int opt, int lhs) /* get_focus_visible */
{
  Scierror("Error: function gtk_window_get_focus_visible not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_window_set_resizable(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int resizable;
  if ( GetArgs(stack,rhs,opt,T,&resizable) == FAIL) return RET_BUG;
    gtk_window_set_resizable(GTK_WINDOW(self->obj),resizable);
  return 0;
}

static int _wrap_gtk_window_get_resizable(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_resizable(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_gravity(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkGravity gravity;
  NspObject *nsp_gravity = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_gravity) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GDK_TYPE_GRAVITY, nsp_gravity, &gravity)== FAIL)
      return RET_BUG;
    gtk_window_set_gravity(GTK_WINDOW(self->obj),gravity);
  return 0;
}

static int _wrap_gtk_window_get_gravity(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_window_get_gravity(GTK_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 1287 "codegen-3.0/gtk.override"
static int
_wrap_gtk_window_set_geometry_hints(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { new_opts,t_end};
  nsp_option opts[] = {
    
    {"geometry",obj_check,NULLOBJ,-1},
    { "min_width",s_int,NULLOBJ,-1},
    { "min_height",s_int,NULLOBJ,-1},
    { "max_width",s_int,NULLOBJ,-1},
    { "max_height",s_int,NULLOBJ,-1},
    { "base_width",s_int,NULLOBJ,-1},
    { "base_height",s_int,NULLOBJ,-1},
    { "width_inc",s_int,NULLOBJ,-1},
    { "height_inc",s_int,NULLOBJ,-1},
    { "min_aspect",s_int,NULLOBJ,-1},
    { "max_aspect",s_int,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };

  NspObject *nsp_geometry_widget = NULL;
  GtkWidget *geometry_widget = NULL;
  gint min_width = -100, min_height = -100, max_width = -100, max_height = -100;
  gint base_width = -100, base_height = -100, width_inc = -100, height_inc = -100;
  gdouble min_aspect = -1.0, max_aspect = -1.0;
  GdkGeometry geometry = { 0 };
  GdkWindowHints geom_mask = 0;

  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type_gtkwidget,&nsp_geometry_widget,
	      &min_width,  &min_height, &max_width, &max_height,
	      &base_width, &base_height, &width_inc,
	      &height_inc, &min_aspect, &max_aspect)== FAIL)
    return RET_BUG;
  if ( nsp_geometry_widget != NULL)
    geometry_widget = GTK_WIDGET(nspgobject_get(nsp_geometry_widget));

  if (min_width != -100 || min_height != -100 ) 
    {
      geometry.min_width = MAX(min_width, -1);
      geometry.min_height = MAX(min_height, -1);
      geom_mask |= GDK_HINT_MIN_SIZE;
  }
  
  if (max_width != -100 || max_height != -100 )
    {
      geometry.max_width = MAX(max_width, -1);
      geometry.max_height = MAX(max_height, -1);
      geom_mask |= GDK_HINT_MAX_SIZE;
    }

  if (base_width != -100 || base_height != -100)
    {
      geometry.base_width = MAX(base_width, -1);
      geometry.base_height = MAX(base_height, -1);
      geom_mask |= GDK_HINT_BASE_SIZE;
    }

  if (width_inc != -100 || height_inc != -100) 
    {
      geometry.width_inc = MAX(width_inc, -1);
      geometry.height_inc = MAX(height_inc, -1);
      geom_mask |= GDK_HINT_RESIZE_INC;
    }
  if (min_aspect >= 0.0 || max_aspect >= 0.0 ) {
    if (min_aspect <= 0.0 || max_aspect <= 0.0) {
      Scierror( "aspect ratios must be positive\n");
      return RET_BUG;
    }
    geometry.min_aspect = min_aspect;
    geometry.max_aspect = max_aspect;
    geom_mask |= GDK_HINT_ASPECT;
  }
  if ( geom_mask != 0) 
    gtk_window_set_geometry_hints(GTK_WINDOW(self->obj), geometry_widget,
				  &geometry, geom_mask);
  else
    gtk_window_set_geometry_hints(GTK_WINDOW(self->obj), geometry_widget,
				  NULL, geom_mask);
  return 0;
}
#line 13419 "gtk.c"


static int _wrap_gtk_window_set_screen(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *screen;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen) == FAIL) return RET_BUG;
    gtk_window_set_screen(GTK_WINDOW(self->obj),GDK_SCREEN(screen->obj));
  return 0;
}

static int _wrap_gtk_window_get_screen(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkScreen *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_window_get_screen(GTK_WINDOW(self->obj));
  nsp_type_gdkscreen = new_type_gdkscreen(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkscreen))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_is_active(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_is_active(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_has_toplevel_focus(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_has_toplevel_focus(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_decorated(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_decorated(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_get_decorated(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_decorated(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_deletable(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_deletable(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_get_deletable(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_deletable(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 7458 "codegen-3.0/gtk.override"
/* redefine a method for gtk_window icon list is a list of GdkPixbuf */
static int _wrap_gtk_window_set_icon_list(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *icon_list = NULL;
  NspList *L;
  CheckRhs(1,1);
  CheckLhs(0,0);
  if ((L = GetList(stack,1)) == NULLLIST) return RET_BUG;
  /* here we have to convert nsp_list to glist
   * checking that all elements are gdkpixbuf
   */
  icon_list = glist_from_typed_nsp_list(stack,L,(NspTypeBase *) new_type_gdkpixbuf(T_BASE));
  if ( icon_list == NULL) return RET_BUG;
  gtk_window_set_icon_list(GTK_WINDOW(self->obj), icon_list);
  g_list_free(icon_list);
  return 0;
}

#line 13516 "gtk.c"


#line 7447 "codegen-3.0/gtk.override"
/* redefine a method for gtk_window icon list is a list of GdkPixbuf */
static int _wrap_gtk_window_get_icon_list(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list,*tmp;
  NspList *nsp_list;
  list = gtk_window_get_icon_list(GTK_WINDOW(self->obj));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  NSP_LIST_FROM_GLIST(list,gobject_create("lel",(GObject *)tmp->data,(NspTypeBase *) nsp_type_gdkpixbuf), g_list_free);}

#line 13529 "gtk.c"


static int _wrap_gtk_window_set_icon(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *icon;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbuf, &icon) == FAIL) return RET_BUG;
    gtk_window_set_icon(GTK_WINDOW(self->obj),GDK_PIXBUF(icon->obj));
  return 0;
}

static int _wrap_gtk_window_set_icon_name(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_window_set_icon_name(GTK_WINDOW(self->obj),name);
  return 0;
}

static int _wrap_gtk_window_set_icon_from_file(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *filename;
  GError *err = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    ret =gtk_window_set_icon_from_file(GTK_WINDOW(self->obj),filename,&err);
  if ( err != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),err->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_get_icon(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_window_get_icon(GTK_WINDOW(self->obj));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_get_icon_name(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_window_get_icon_name(GTK_WINDOW(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_modal(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int modal;
  if ( GetArgs(stack,rhs,opt,T,&modal) == FAIL) return RET_BUG;
    gtk_window_set_modal(GTK_WINDOW(self->obj),modal);
  return 0;
}

static int _wrap_gtk_window_get_modal(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_modal(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_has_user_ref_count(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_has_user_ref_count(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_add_mnemonic(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,obj_check, t_end};
  int keyval;
  NspGObject *target;
  if ( GetArgs(stack,rhs,opt,T,&keyval, &nsp_type_gtkwidget, &target) == FAIL) return RET_BUG;
    gtk_window_add_mnemonic(GTK_WINDOW(self->obj),keyval,GTK_WIDGET(target->obj));
  return 0;
}

static int _wrap_gtk_window_remove_mnemonic(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,obj_check, t_end};
  int keyval;
  NspGObject *target;
  if ( GetArgs(stack,rhs,opt,T,&keyval, &nsp_type_gtkwidget, &target) == FAIL) return RET_BUG;
    gtk_window_remove_mnemonic(GTK_WINDOW(self->obj),keyval,GTK_WIDGET(target->obj));
  return 0;
}

static int _wrap_gtk_window_mnemonic_activate(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,obj, t_end};
  int keyval, ret;
  GdkModifierType modifier;
  NspObject *nsp_modifier = NULL;
  if ( GetArgs(stack,rhs,opt,T,&keyval, &nsp_modifier) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_modifier, &modifier)==FAIL)
      return RET_BUG;
    ret =gtk_window_mnemonic_activate(GTK_WINDOW(self->obj),keyval,modifier);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_mnemonic_modifier(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkModifierType modifier;
  NspObject *nsp_modifier = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_modifier) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_modifier, &modifier)==FAIL)
      return RET_BUG;
    gtk_window_set_mnemonic_modifier(GTK_WINDOW(self->obj),modifier);
  return 0;
}

static int _wrap_gtk_window_get_mnemonic_modifier(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_window_get_mnemonic_modifier(GTK_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_activate_key(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    ret =gtk_window_activate_key(GTK_WINDOW(self->obj),(GdkEventKey *)event);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_propagate_key_event(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    ret =gtk_window_propagate_key_event(GTK_WINDOW(self->obj),(GdkEventKey *)event);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_present(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_window_present(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_present_with_time(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  gulong timestamp;
  if ( GetArgs(stack,rhs,opt,T,&timestamp) == FAIL) return RET_BUG;
    gtk_window_present_with_time(GTK_WINDOW(self->obj),timestamp);
  return 0;
}

static int _wrap_gtk_window_iconify(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_window_iconify(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_deiconify(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_window_deiconify(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_stick(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_window_stick(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_unstick(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_window_unstick(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_maximize(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_window_maximize(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_unmaximize(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_window_unmaximize(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_fullscreen(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_window_fullscreen(GTK_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_window_unfullscreen(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_window_unfullscreen(GTK_WINDOW(self->obj));
  return 0;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_window_close(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_window_close(GTK_WINDOW(self->obj));
  return 0;
}

#else
int _wrap_gtk_window_close(Stack stack, int rhs, int opt, int lhs) /* close */
{
  Scierror("Error: function gtk_window_close not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_window_set_keep_above(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_keep_above(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_set_keep_below(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_keep_below(GTK_WINDOW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_window_begin_resize_drag(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int,s_int,s_int, t_end};
  GdkWindowEdge edge;
  NspObject *nsp_edge = NULL;
  int button, root_x, root_y;
  gulong timestamp;
  if ( GetArgs(stack,rhs,opt,T,&nsp_edge, &button, &root_x, &root_y, &timestamp) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GDK_TYPE_WINDOW_EDGE, nsp_edge, &edge)== FAIL)
      return RET_BUG;
    gtk_window_begin_resize_drag(GTK_WINDOW(self->obj),edge,button,root_x,root_y,timestamp);
  return 0;
}

static int _wrap_gtk_window_begin_move_drag(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int,s_int, t_end};
  int button, root_x, root_y;
  gulong timestamp;
  if ( GetArgs(stack,rhs,opt,T,&button, &root_x, &root_y, &timestamp) == FAIL) return RET_BUG;
    gtk_window_begin_move_drag(GTK_WINDOW(self->obj),button,root_x,root_y,timestamp);
  return 0;
}

static int _wrap_gtk_window_set_default_size(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int width, height;
  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
    gtk_window_set_default_size(GTK_WINDOW(self->obj),width,height);
  return 0;
}

#line 1393 "codegen-3.0/gtk.override"
static int
_wrap_gtk_window_get_default_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint width, height;
  CheckRhs(0,0);
  gtk_window_get_default_size(GTK_WINDOW(self->obj), &width, &height);
  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL)
    return RET_BUG;
  return 1;
}
#line 13854 "gtk.c"


static int _wrap_gtk_window_resize(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int width, height;
  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
    gtk_window_resize(GTK_WINDOW(self->obj),width,height);
  return 0;
}

#line 1380 "codegen-3.0/gtk.override"
static int
_wrap_gtk_window_get_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint width, height;

  gtk_window_get_size(GTK_WINDOW(self->obj), &width, &height);

  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL)
    return RET_BUG;
  return 1;
}
#line 13878 "gtk.c"


static int _wrap_gtk_window_move(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int x, y;
  if ( GetArgs(stack,rhs,opt,T,&x, &y) == FAIL) return RET_BUG;
    gtk_window_move(GTK_WINDOW(self->obj),x,y);
  return 0;
}

#line 1368 "codegen-3.0/gtk.override"
static int
_wrap_gtk_window_get_position(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint root_x, root_y;

  gtk_window_get_position(GTK_WINDOW(self->obj), &root_x, &root_y);
  if (  nsp_move_doubles(stack,1,1,2,(double) root_x,(double) root_y) == FAIL)
    return RET_BUG;
  return 1;
}
#line 13901 "gtk.c"


static int _wrap_gtk_window_parse_geometry(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *geometry;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&geometry) == FAIL) return RET_BUG;
    ret =gtk_window_parse_geometry(GTK_WINDOW(self->obj),geometry);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_set_default_geometry(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int width, height;
  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
    gtk_window_set_default_geometry(GTK_WINDOW(self->obj),width,height);
  return 0;
}

static int _wrap_gtk_window_resize_to_geometry(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int width, height;
  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
    gtk_window_resize_to_geometry(GTK_WINDOW(self->obj),width,height);
  return 0;
}

static int _wrap_gtk_window_get_group(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWindowGroup *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_window_get_group(GTK_WINDOW(self->obj));
  nsp_type_gtkwindowgroup = new_type_gtkwindowgroup(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindowgroup))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_has_group(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_has_group(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_window_reshow_with_initial_size(Stack stack, int rhs, int opt, int lhs) /* reshow_with_initial_size */
{
  Scierror("Error: function gtk_window_reshow_with_initial_size is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_window_reshow_with_initial_size(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_window_reshow_with_initial_size(GTK_WINDOW(self->obj));
  return 0;
}

#endif
static int _wrap_gtk_window_get_window_type(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_window_get_window_type(GTK_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_window_get_application(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkApplication *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_window_get_application(GTK_WINDOW(self->obj));
  nsp_type_gtkapplication = new_type_gtkapplication(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkapplication))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_set_application(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *application;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkapplication, &application) == FAIL) return RET_BUG;
    gtk_window_set_application(GTK_WINDOW(self->obj),GTK_APPLICATION(application->obj));
  return 0;
}

#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_window_set_has_resize_grip(Stack stack, int rhs, int opt, int lhs) /* set_has_resize_grip */
{
  Scierror("Error: function gtk_window_set_has_resize_grip is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_window_set_has_resize_grip(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int value;
  if ( GetArgs(stack,rhs,opt,T,&value) == FAIL) return RET_BUG;
    gtk_window_set_has_resize_grip(GTK_WINDOW(self->obj),value);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_window_get_has_resize_grip(Stack stack, int rhs, int opt, int lhs) /* get_has_resize_grip */
{
  Scierror("Error: function gtk_window_get_has_resize_grip is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_window_get_has_resize_grip(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_get_has_resize_grip(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_window_resize_grip_is_visible(Stack stack, int rhs, int opt, int lhs) /* resize_grip_is_visible */
{
  Scierror("Error: function gtk_window_resize_grip_is_visible is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_window_resize_grip_is_visible(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_resize_grip_is_visible(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_window_get_resize_grip_area(Stack stack, int rhs, int opt, int lhs) /* get_resize_grip_area */
{
  Scierror("Error: function gtk_window_get_resize_grip_area is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_window_get_resize_grip_area(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkRectangle rect = { 0, 0, 0, 0 };
  NspObject *nsp_rect;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_rect) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_rect, &rect))
      return RET_BUG;
    ret =gtk_window_get_resize_grip_area(GTK_WINDOW(self->obj),&rect);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_window_set_titlebar(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *titlebar;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &titlebar) == FAIL) return RET_BUG;
    gtk_window_set_titlebar(GTK_WINDOW(self->obj),GTK_WIDGET(titlebar->obj));
  return 0;
}

#else
int _wrap_gtk_window_set_titlebar(Stack stack, int rhs, int opt, int lhs) /* set_titlebar */
{
  Scierror("Error: function gtk_window_set_titlebar not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_window_get_titlebar(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_window_get_titlebar(GTK_WINDOW(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_window_get_titlebar(Stack stack, int rhs, int opt, int lhs) /* get_titlebar */
{
  Scierror("Error: function gtk_window_get_titlebar not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_window_is_maximized(NspGtkWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_window_is_maximized(GTK_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_window_is_maximized(Stack stack, int rhs, int opt, int lhs) /* is_maximized */
{
  Scierror("Error: function gtk_window_is_maximized not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkwindow_methods[] = {
  {"set_title",(nsp_method *) _wrap_gtk_window_set_title},
  {"get_title",(nsp_method *) _wrap_gtk_window_get_title},
  {"set_wmclass",(nsp_method *) _wrap_gtk_window_set_wmclass},
  {"set_role",(nsp_method *) _wrap_gtk_window_set_role},
  {"set_startup_id",(nsp_method *) _wrap_gtk_window_set_startup_id},
  {"get_role",(nsp_method *) _wrap_gtk_window_get_role},
  {"add_accel_group",(nsp_method *) _wrap_gtk_window_add_accel_group},
  {"remove_accel_group",(nsp_method *) _wrap_gtk_window_remove_accel_group},
  {"set_position",(nsp_method *) _wrap_gtk_window_set_position},
  {"activate_focus",(nsp_method *) _wrap_gtk_window_activate_focus},
  {"set_focus",(nsp_method *) _wrap_gtk_window_set_focus},
  {"get_focus",(nsp_method *) _wrap_gtk_window_get_focus},
  {"set_default",(nsp_method *) _wrap_gtk_window_set_default},
  {"get_default_widget",(nsp_method *) _wrap_gtk_window_get_default_widget},
  {"activate_default",(nsp_method *) _wrap_gtk_window_activate_default},
  {"set_transient_for",(nsp_method *) _wrap_gtk_window_set_transient_for},
  {"get_transient_for",(nsp_method *) _wrap_gtk_window_get_transient_for},
  {"set_attached_to",(nsp_method *) _wrap_gtk_window_set_attached_to},
  {"get_attached_to",(nsp_method *) _wrap_gtk_window_get_attached_to},
  {"set_type_hint",(nsp_method *) _wrap_gtk_window_set_type_hint},
  {"get_type_hint",(nsp_method *) _wrap_gtk_window_get_type_hint},
  {"set_skip_taskbar_hint",(nsp_method *) _wrap_gtk_window_set_skip_taskbar_hint},
  {"get_skip_taskbar_hint",(nsp_method *) _wrap_gtk_window_get_skip_taskbar_hint},
  {"set_skip_pager_hint",(nsp_method *) _wrap_gtk_window_set_skip_pager_hint},
  {"get_skip_pager_hint",(nsp_method *) _wrap_gtk_window_get_skip_pager_hint},
  {"set_urgency_hint",(nsp_method *) _wrap_gtk_window_set_urgency_hint},
  {"get_urgency_hint",(nsp_method *) _wrap_gtk_window_get_urgency_hint},
  {"set_accept_focus",(nsp_method *) _wrap_gtk_window_set_accept_focus},
  {"get_accept_focus",(nsp_method *) _wrap_gtk_window_get_accept_focus},
  {"set_focus_on_map",(nsp_method *) _wrap_gtk_window_set_focus_on_map},
  {"get_focus_on_map",(nsp_method *) _wrap_gtk_window_get_focus_on_map},
  {"set_destroy_with_parent",(nsp_method *) _wrap_gtk_window_set_destroy_with_parent},
  {"get_destroy_with_parent",(nsp_method *) _wrap_gtk_window_get_destroy_with_parent},
  {"set_hide_titlebar_when_maximized",(nsp_method *) _wrap_gtk_window_set_hide_titlebar_when_maximized},
  {"get_hide_titlebar_when_maximized",(nsp_method *) _wrap_gtk_window_get_hide_titlebar_when_maximized},
  {"set_mnemonics_visible",(nsp_method *) _wrap_gtk_window_set_mnemonics_visible},
  {"get_mnemonics_visible",(nsp_method *) _wrap_gtk_window_get_mnemonics_visible},
  {"set_focus_visible",(nsp_method *) _wrap_gtk_window_set_focus_visible},
  {"get_focus_visible",(nsp_method *) _wrap_gtk_window_get_focus_visible},
  {"set_resizable",(nsp_method *) _wrap_gtk_window_set_resizable},
  {"get_resizable",(nsp_method *) _wrap_gtk_window_get_resizable},
  {"set_gravity",(nsp_method *) _wrap_gtk_window_set_gravity},
  {"get_gravity",(nsp_method *) _wrap_gtk_window_get_gravity},
  {"set_geometry_hints",(nsp_method *) _wrap_gtk_window_set_geometry_hints},
  {"set_screen",(nsp_method *) _wrap_gtk_window_set_screen},
  {"get_screen",(nsp_method *) _wrap_gtk_window_get_screen},
  {"is_active",(nsp_method *) _wrap_gtk_window_is_active},
  {"has_toplevel_focus",(nsp_method *) _wrap_gtk_window_has_toplevel_focus},
  {"set_decorated",(nsp_method *) _wrap_gtk_window_set_decorated},
  {"get_decorated",(nsp_method *) _wrap_gtk_window_get_decorated},
  {"set_deletable",(nsp_method *) _wrap_gtk_window_set_deletable},
  {"get_deletable",(nsp_method *) _wrap_gtk_window_get_deletable},
  {"set_icon_list",(nsp_method *) _wrap_gtk_window_set_icon_list},
  {"get_icon_list",(nsp_method *) _wrap_gtk_window_get_icon_list},
  {"set_icon",(nsp_method *) _wrap_gtk_window_set_icon},
  {"set_icon_name",(nsp_method *) _wrap_gtk_window_set_icon_name},
  {"set_icon_from_file",(nsp_method *) _wrap_gtk_window_set_icon_from_file},
  {"get_icon",(nsp_method *) _wrap_gtk_window_get_icon},
  {"get_icon_name",(nsp_method *) _wrap_gtk_window_get_icon_name},
  {"set_modal",(nsp_method *) _wrap_gtk_window_set_modal},
  {"get_modal",(nsp_method *) _wrap_gtk_window_get_modal},
  {"set_has_user_ref_count",(nsp_method *) _wrap_gtk_window_set_has_user_ref_count},
  {"add_mnemonic",(nsp_method *) _wrap_gtk_window_add_mnemonic},
  {"remove_mnemonic",(nsp_method *) _wrap_gtk_window_remove_mnemonic},
  {"mnemonic_activate",(nsp_method *) _wrap_gtk_window_mnemonic_activate},
  {"set_mnemonic_modifier",(nsp_method *) _wrap_gtk_window_set_mnemonic_modifier},
  {"get_mnemonic_modifier",(nsp_method *) _wrap_gtk_window_get_mnemonic_modifier},
  {"activate_key",(nsp_method *) _wrap_gtk_window_activate_key},
  {"propagate_key_event",(nsp_method *) _wrap_gtk_window_propagate_key_event},
  {"present",(nsp_method *) _wrap_gtk_window_present},
  {"present_with_time",(nsp_method *) _wrap_gtk_window_present_with_time},
  {"iconify",(nsp_method *) _wrap_gtk_window_iconify},
  {"deiconify",(nsp_method *) _wrap_gtk_window_deiconify},
  {"stick",(nsp_method *) _wrap_gtk_window_stick},
  {"unstick",(nsp_method *) _wrap_gtk_window_unstick},
  {"maximize",(nsp_method *) _wrap_gtk_window_maximize},
  {"unmaximize",(nsp_method *) _wrap_gtk_window_unmaximize},
  {"fullscreen",(nsp_method *) _wrap_gtk_window_fullscreen},
  {"unfullscreen",(nsp_method *) _wrap_gtk_window_unfullscreen},
  {"close",(nsp_method *) _wrap_gtk_window_close},
  {"set_keep_above",(nsp_method *) _wrap_gtk_window_set_keep_above},
  {"set_keep_below",(nsp_method *) _wrap_gtk_window_set_keep_below},
  {"begin_resize_drag",(nsp_method *) _wrap_gtk_window_begin_resize_drag},
  {"begin_move_drag",(nsp_method *) _wrap_gtk_window_begin_move_drag},
  {"set_default_size",(nsp_method *) _wrap_gtk_window_set_default_size},
  {"get_default_size",(nsp_method *) _wrap_gtk_window_get_default_size},
  {"resize",(nsp_method *) _wrap_gtk_window_resize},
  {"get_size",(nsp_method *) _wrap_gtk_window_get_size},
  {"move",(nsp_method *) _wrap_gtk_window_move},
  {"get_position",(nsp_method *) _wrap_gtk_window_get_position},
  {"parse_geometry",(nsp_method *) _wrap_gtk_window_parse_geometry},
  {"set_default_geometry",(nsp_method *) _wrap_gtk_window_set_default_geometry},
  {"resize_to_geometry",(nsp_method *) _wrap_gtk_window_resize_to_geometry},
  {"get_group",(nsp_method *) _wrap_gtk_window_get_group},
  {"has_group",(nsp_method *) _wrap_gtk_window_has_group},
  {"reshow_with_initial_size",(nsp_method *) _wrap_gtk_window_reshow_with_initial_size},
  {"get_window_type",(nsp_method *) _wrap_gtk_window_get_window_type},
  {"get_application",(nsp_method *) _wrap_gtk_window_get_application},
  {"set_application",(nsp_method *) _wrap_gtk_window_set_application},
  {"set_has_resize_grip",(nsp_method *) _wrap_gtk_window_set_has_resize_grip},
  {"get_has_resize_grip",(nsp_method *) _wrap_gtk_window_get_has_resize_grip},
  {"resize_grip_is_visible",(nsp_method *) _wrap_gtk_window_resize_grip_is_visible},
  {"get_resize_grip_area",(nsp_method *) _wrap_gtk_window_get_resize_grip_area},
  {"set_titlebar",(nsp_method *) _wrap_gtk_window_set_titlebar},
  {"get_titlebar",(nsp_method *) _wrap_gtk_window_get_titlebar},
  {"is_maximized",(nsp_method *) _wrap_gtk_window_is_maximized},
  { NULL, NULL}
};

static NspMethods *gtkwindow_get_methods(void) { return gtkwindow_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkwindow_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkDialog ----------- */


#define  NspGtkDialog_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkdialog.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkDialog inherits from GtkWindow 
 * and implements GtkBuildable
 */

int nsp_type_gtkdialog_id=0;
NspTypeGtkDialog *nsp_type_gtkdialog=NULL;

/*
 * Type object for NspGtkDialog 
 * all the instance of NspTypeGtkDialog share the same id. 
 * nsp_type_gtkdialog: is an instance of NspTypeGtkDialog 
 *    used for objects of NspGtkDialog type (i.e built with new_gtkdialog) 
 * other instances are used for derived classes 
 */
NspTypeGtkDialog *new_type_gtkdialog(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkdialog != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkdialog;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWindow))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwindow(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkdialog_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkdialog_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkdialog;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkdialog */ 

  top->s_type =  (s_type_func *) nsp_gtkdialog_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkdialog_type_short_string;
  /* top->create = (create_func*) int_gtkdialog_create;*/

  /* specific methods for gtkdialog */

  type->init = (init_func *) init_gtkdialog;

  /* 
   * NspGtkDialog interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkdialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkDialog called nsp_type_gtkdialog
       */
      type->id =  nsp_type_gtkdialog_id = nsp_new_type_id();
      nsp_type_gtkdialog = type;
      if ( nsp_register_type(nsp_type_gtkdialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkdialog, GTK_TYPE_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkdialog(mode);
    }
  else 
    {
      type->id = nsp_type_gtkdialog_id;
      return type;
    }
}

/*
 * initialize NspGtkDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkdialog(NspGtkDialog *Obj,NspTypeGtkDialog *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkDialog 
 */

NspGtkDialog *new_gtkdialog() 
{
  NspGtkDialog *loc;
  /* type must exists */
  nsp_type_gtkdialog = new_type_gtkdialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkDialog)))== NULLGTKDIALOG) return loc;
  /* initialize object */
  if ( init_gtkdialog(loc,nsp_type_gtkdialog) == FAIL) return NULLGTKDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkDialog 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkdialog_type_name[]="GtkDialog";
static char gtkdialog_short_type_name[]="GtkDialog";

static char *nsp_gtkdialog_type_as_string(void)
{
  return(gtkdialog_type_name);
}

static char *nsp_gtkdialog_type_short_string(NspObject *v)
{
  return(gtkdialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkDialog objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkDialog   *nsp_gtkdialog_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkdialog_id)  == TRUE  ) return ((NspGtkDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkdialog));
  return NULL;
}

int IsGtkDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkdialog_id);
}

int IsGtkDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkdialog_id);
}

NspGtkDialog  *GetGtkDialogCopy(Stack stack, int i)
{
  if (  GetGtkDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkDialog  *GetGtkDialog(Stack stack, int i)
{
  NspGtkDialog *M;
  if (( M = nsp_gtkdialog_object(NthObj(i))) == NULLGTKDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkDialog *gtkdialog_copy(NspGtkDialog *self)
{
  /* return gtkwindow_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkdialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkdialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 6175 "codegen-3.0/gtk.override"

/* gtk_dialog_new gtk_dialog_new_with_buttons are mixed here */
static int
_wrap_gtk_dialog_new(Stack stack,int rhs,int opt,int lhs)
{
  gchar *title = NULL;
  NspGObject *nsp_window = NULL;
  GObject *ret;
  NspSMatrix *nsp_buttons = NULL;
  NspObject *nsp_ret;
  GtkDialogFlags flags = 0;
  int i;

  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"title",string,NULLOBJ,-1},
    {"parent",obj,NULLOBJ,-1},
    {"flags",s_int,NULLOBJ,-1},
    {"buttons",smat,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };

  if (GetArgs(stack,rhs,opt,T,&opts, &title, &nsp_window, &flags, &nsp_buttons)== FAIL) return RET_BUG;

  if ( nsp_window != NULL && ! nspgobject_check(nsp_window, nsp_type_gtkwindow)) {
    Scierror("window must be a GtkWindow");
    return RET_BUG;
  }
  ret =(GObject *)  gtk_dialog_new_with_buttons(title, (nsp_window != NULL) ? GTK_WINDOW(nsp_window->obj) : NULL,
						flags, NULL,NULL);
  if ( ret == NULL) {
    Scierror("could not create GtkDialog object");
    return RET_BUG;
  }
  if ( nsp_buttons != NULL)
    {
      for (i = 0; i < nsp_buttons->mn ; i ++)
	{
	  gtk_dialog_add_button(GTK_DIALOG(ret), nsp_buttons->S[i],i+1);
	}
    }
  nspg_block_threads();
  nsp_type_gtkdialog = new_type_gtkdialog(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *) ret,(NspTypeBase *) nsp_type_gtkdialog))== NULL)
    return RET_BUG;
  nspg_unblock_threads();
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 14489 "gtk.c"


static int _wrap_gtk_dialog_add_action_widget(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *child;
  int response_id;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &response_id) == FAIL) return RET_BUG;
    gtk_dialog_add_action_widget(GTK_DIALOG(self->obj),GTK_WIDGET(child->obj),response_id);
  return 0;
}

static int _wrap_gtk_dialog_add_button(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int, t_end};
  char *button_text;
  int response_id;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&button_text, &response_id) == FAIL) return RET_BUG;
    ret =gtk_dialog_add_button(GTK_DIALOG(self->obj),button_text,response_id);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_dialog_set_response_sensitive(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_bool, t_end};
  int response_id, setting;
  if ( GetArgs(stack,rhs,opt,T,&response_id, &setting) == FAIL) return RET_BUG;
    gtk_dialog_set_response_sensitive(GTK_DIALOG(self->obj),response_id,setting);
  return 0;
}

static int _wrap_gtk_dialog_set_default_response(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int response_id;
  if ( GetArgs(stack,rhs,opt,T,&response_id) == FAIL) return RET_BUG;
    gtk_dialog_set_default_response(GTK_DIALOG(self->obj),response_id);
  return 0;
}

static int _wrap_gtk_dialog_get_widget_for_response(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int response_id;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&response_id) == FAIL) return RET_BUG;
    ret =gtk_dialog_get_widget_for_response(GTK_DIALOG(self->obj),response_id);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_dialog_get_response_for_widget(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    ret =gtk_dialog_get_response_for_widget(GTK_DIALOG(self->obj),GTK_WIDGET(widget->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_dialog_set_alternative_button_order(Stack stack, int rhs, int opt, int lhs) /* set_alternative_button_order */
{
  Scierror("Error: function gtk_dialog_set_alternative_button_order is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_dialog_set_alternative_button_order(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int first_response_id;
  if ( GetArgs(stack,rhs,opt,T,&first_response_id) == FAIL) return RET_BUG;
    gtk_dialog_set_alternative_button_order(GTK_DIALOG(self->obj),first_response_id);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_dialog_set_alternative_button_order_from_array(Stack stack, int rhs, int opt, int lhs) /* set_alternative_button_order_from_array */
{
  Scierror("Error: function gtk_dialog_set_alternative_button_order_from_array is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_dialog_set_alternative_button_order_from_array(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int n_params, new_order;
  if ( GetArgs(stack,rhs,opt,T,&n_params, &new_order) == FAIL) return RET_BUG;
    gtk_dialog_set_alternative_button_order_from_array(GTK_DIALOG(self->obj),n_params,&new_order);
  return 0;
}

#endif
static int _wrap_gtk_dialog_response(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int response_id;
  if ( GetArgs(stack,rhs,opt,T,&response_id) == FAIL) return RET_BUG;
    gtk_dialog_response(GTK_DIALOG(self->obj),response_id);
  return 0;
}

#line 6240 "codegen-3.0/gtk.override"
static int
_wrap_gtk_dialog_run(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint retval;

  nspg_unblock_threads();
  retval = gtk_dialog_run(GTK_DIALOG(self->obj));
  nspg_block_threads();
  if ( nsp_move_double(stack,1,(double)retval) == FAIL) return RET_BUG;
  return 1;
}
#line 14615 "gtk.c"


#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_dialog_get_action_area(Stack stack, int rhs, int opt, int lhs) /* get_action_area */
{
  Scierror("Error: function gtk_dialog_get_action_area is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_dialog_get_action_area(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_dialog_get_action_area(GTK_DIALOG(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#endif
static int _wrap_gtk_dialog_get_content_area(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_dialog_get_content_area(GTK_DIALOG(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_dialog_get_header_bar(NspGtkDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_dialog_get_header_bar(GTK_DIALOG(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_dialog_get_header_bar(Stack stack, int rhs, int opt, int lhs) /* get_header_bar */
{
  Scierror("Error: function gtk_dialog_get_header_bar not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkdialog_methods[] = {
  {"add_action_widget",(nsp_method *) _wrap_gtk_dialog_add_action_widget},
  {"add_button",(nsp_method *) _wrap_gtk_dialog_add_button},
  {"set_response_sensitive",(nsp_method *) _wrap_gtk_dialog_set_response_sensitive},
  {"set_default_response",(nsp_method *) _wrap_gtk_dialog_set_default_response},
  {"get_widget_for_response",(nsp_method *) _wrap_gtk_dialog_get_widget_for_response},
  {"get_response_for_widget",(nsp_method *) _wrap_gtk_dialog_get_response_for_widget},
  {"set_alternative_button_order",(nsp_method *) _wrap_gtk_dialog_set_alternative_button_order},
  {"set_alternative_button_order_from_array",(nsp_method *) _wrap_gtk_dialog_set_alternative_button_order_from_array},
  {"response",(nsp_method *) _wrap_gtk_dialog_response},
  {"run",(nsp_method *) _wrap_gtk_dialog_run},
  {"get_action_area",(nsp_method *) _wrap_gtk_dialog_get_action_area},
  {"get_content_area",(nsp_method *) _wrap_gtk_dialog_get_content_area},
  {"get_header_bar",(nsp_method *) _wrap_gtk_dialog_get_header_bar},
  { NULL, NULL}
};

static NspMethods *gtkdialog_get_methods(void) { return gtkdialog_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkdialog_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkMessageDialog ----------- */


#define  NspGtkMessageDialog_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkmessagedialog.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkMessageDialog inherits from GtkDialog 
 * and implements GtkBuildable
 */

int nsp_type_gtkmessagedialog_id=0;
NspTypeGtkMessageDialog *nsp_type_gtkmessagedialog=NULL;

/*
 * Type object for NspGtkMessageDialog 
 * all the instance of NspTypeGtkMessageDialog share the same id. 
 * nsp_type_gtkmessagedialog: is an instance of NspTypeGtkMessageDialog 
 *    used for objects of NspGtkMessageDialog type (i.e built with new_gtkmessagedialog) 
 * other instances are used for derived classes 
 */
NspTypeGtkMessageDialog *new_type_gtkmessagedialog(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkMessageDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmessagedialog != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmessagedialog;
    }
  if (( type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmessagedialog_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkmessagedialog_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkmessagedialog;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkmessagedialog */ 

  top->s_type =  (s_type_func *) nsp_gtkmessagedialog_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkmessagedialog_type_short_string;
  /* top->create = (create_func*) int_gtkmessagedialog_create;*/

  /* specific methods for gtkmessagedialog */

  type->init = (init_func *) init_gtkmessagedialog;

  /* 
   * NspGtkMessageDialog interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkmessagedialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMessageDialog called nsp_type_gtkmessagedialog
       */
      type->id =  nsp_type_gtkmessagedialog_id = nsp_new_type_id();
      nsp_type_gtkmessagedialog = type;
      if ( nsp_register_type(nsp_type_gtkmessagedialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmessagedialog, GTK_TYPE_MESSAGE_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkmessagedialog(mode);
    }
  else 
    {
      type->id = nsp_type_gtkmessagedialog_id;
      return type;
    }
}

/*
 * initialize NspGtkMessageDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmessagedialog(NspGtkMessageDialog *Obj,NspTypeGtkMessageDialog *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkMessageDialog 
 */

NspGtkMessageDialog *new_gtkmessagedialog() 
{
  NspGtkMessageDialog *loc;
  /* type must exists */
  nsp_type_gtkmessagedialog = new_type_gtkmessagedialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMessageDialog)))== NULLGTKMESSAGEDIALOG) return loc;
  /* initialize object */
  if ( init_gtkmessagedialog(loc,nsp_type_gtkmessagedialog) == FAIL) return NULLGTKMESSAGEDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkMessageDialog 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkmessagedialog_type_name[]="GtkMessageDialog";
static char gtkmessagedialog_short_type_name[]="GtkMessageDialog";

static char *nsp_gtkmessagedialog_type_as_string(void)
{
  return(gtkmessagedialog_type_name);
}

static char *nsp_gtkmessagedialog_type_short_string(NspObject *v)
{
  return(gtkmessagedialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkMessageDialog objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkMessageDialog   *nsp_gtkmessagedialog_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkmessagedialog_id)  == TRUE  ) return ((NspGtkMessageDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmessagedialog));
  return NULL;
}

int IsGtkMessageDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkmessagedialog_id);
}

int IsGtkMessageDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmessagedialog_id);
}

NspGtkMessageDialog  *GetGtkMessageDialogCopy(Stack stack, int i)
{
  if (  GetGtkMessageDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMessageDialog  *GetGtkMessageDialog(Stack stack, int i)
{
  NspGtkMessageDialog *M;
  if (( M = nsp_gtkmessagedialog_object(NthObj(i))) == NULLGTKMESSAGEDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMessageDialog *gtkmessagedialog_copy(NspGtkMessageDialog *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmessagedialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmessagedialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMessageDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 6253 "codegen-3.0/gtk.override"
/* XXXXX accepter une matrice pour message a concatener */
static int
_wrap_gtk_message_dialog_new(Stack stack,int rhs,int opt,int lhs)
{
  int markup = FALSE;
  NspObject *nsp_ret;
  GObject *gobj;
  GtkButtonsType buttons = GTK_BUTTONS_NONE;
  int_types T[] = {new_opts, t_end} ;
  nsp_option opts[] = {
    {"parent",obj_check,NULLOBJ,-1},
    {"flags",obj,NULLOBJ,-1},
    {"type",obj,NULLOBJ,-1},
    {"buttons",obj,NULLOBJ,-1},
    {"message",string,NULLOBJ,-1},
    {"markup",s_bool,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };

  /* static char *kwlist[] = { "parent", "flags", "type", "buttons", "message_format", NULL };*/
  NspObject *nsp_flags = NULL, *nsp_type = NULL, *nsp_buttons = NULL;
  GtkDialogFlags flags = 0;
  GtkWindow *parent = NULL;
  GtkMessageType type = GTK_MESSAGE_INFO;
  NspGObject *nsp_parent = NULL;
  char *message_format = NULL;

  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type_gtkwindow, &nsp_parent, &nsp_flags, &nsp_type, &nsp_buttons, &message_format,&markup)== FAIL)
    return RET_BUG;
  if ( nsp_parent != NULL) parent = GTK_WINDOW(nsp_parent->obj);
  if (nspg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, nsp_flags, &flags))
    return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_MESSAGE_TYPE, nsp_type,&type))
    return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_BUTTONS_TYPE, nsp_buttons, &buttons))
    return RET_BUG;
  if ( markup == TRUE )
    {
      gobj = (GObject *)gtk_message_dialog_new_with_markup(parent, flags, type, buttons, NULL);
      if (gobj == NULL ) {
        Scierror( "could not create GtkMessageDialog object");
        return RET_BUG;
      }
      gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (gobj),
				     message_format);
    }
  else
    {
      gobj = (GObject *)gtk_message_dialog_new(parent, flags, type, buttons, "%s", message_format);
      if (gobj == NULL ) {
        Scierror( "could not create GtkMessageDialog object");
        return RET_BUG;
      }
    }
  if ((nsp_ret = (NspObject *) gobject_create(NVOID, gobj,(NspTypeBase *) nsp_type_gtkmessagedialog))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}


#line 14951 "gtk.c"


#if GTK_CHECK_VERSION(3,12,0)
int _wrap_gtk_message_dialog_set_image(Stack stack, int rhs, int opt, int lhs) /* set_image */
{
  Scierror("Error: function gtk_message_dialog_set_image is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_message_dialog_set_image(NspGtkMessageDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *image;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &image) == FAIL) return RET_BUG;
    gtk_message_dialog_set_image(GTK_MESSAGE_DIALOG(self->obj),GTK_WIDGET(image->obj));
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,12,0)
int _wrap_gtk_message_dialog_get_image(Stack stack, int rhs, int opt, int lhs) /* get_image */
{
  Scierror("Error: function gtk_message_dialog_get_image is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_message_dialog_get_image(NspGtkMessageDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_message_dialog_get_image(GTK_MESSAGE_DIALOG(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#endif
static int _wrap_gtk_message_dialog_set_markup(NspGtkMessageDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *str;
  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
    gtk_message_dialog_set_markup(GTK_MESSAGE_DIALOG(self->obj),str);
  return 0;
}

#line 6315 "codegen-3.0/gtk.override"

static int _wrap_gtk_message_dialog_format_secondary_text(NspGtkMessageDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *message_format;
  if ( GetArgs(stack,rhs,opt,T,&message_format) == FAIL) return RET_BUG;
  gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(self->obj),"%s",message_format);
  return 0;
}

#line 15011 "gtk.c"


#line 6327 "codegen-3.0/gtk.override"

static int _wrap_gtk_message_dialog_format_secondary_markup(NspGtkMessageDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *message_format;
  if ( GetArgs(stack,rhs,opt,T,&message_format) == FAIL) return RET_BUG;
  gtk_message_dialog_format_secondary_markup(GTK_MESSAGE_DIALOG(self->obj),"%s",message_format);
  return 0;
}



#line 15027 "gtk.c"


static int _wrap_gtk_message_dialog_get_message_area(NspGtkMessageDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_message_dialog_get_message_area(GTK_MESSAGE_DIALOG(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkmessagedialog_methods[] = {
  {"set_image",(nsp_method *) _wrap_gtk_message_dialog_set_image},
  {"get_image",(nsp_method *) _wrap_gtk_message_dialog_get_image},
  {"set_markup",(nsp_method *) _wrap_gtk_message_dialog_set_markup},
  {"format_secondary_text",(nsp_method *) _wrap_gtk_message_dialog_format_secondary_text},
  {"format_secondary_markup",(nsp_method *) _wrap_gtk_message_dialog_format_secondary_markup},
  {"get_message_area",(nsp_method *) _wrap_gtk_message_dialog_get_message_area},
  { NULL, NULL}
};

static NspMethods *gtkmessagedialog_get_methods(void) { return gtkmessagedialog_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmessagedialog_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAboutDialog ----------- */


#define  NspGtkAboutDialog_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkaboutdialog.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAboutDialog inherits from GtkDialog 
 * and implements GtkBuildable
 */

int nsp_type_gtkaboutdialog_id=0;
NspTypeGtkAboutDialog *nsp_type_gtkaboutdialog=NULL;

/*
 * Type object for NspGtkAboutDialog 
 * all the instance of NspTypeGtkAboutDialog share the same id. 
 * nsp_type_gtkaboutdialog: is an instance of NspTypeGtkAboutDialog 
 *    used for objects of NspGtkAboutDialog type (i.e built with new_gtkaboutdialog) 
 * other instances are used for derived classes 
 */
NspTypeGtkAboutDialog *new_type_gtkaboutdialog(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkAboutDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkaboutdialog != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkaboutdialog;
    }
  if (( type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkaboutdialog_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkaboutdialog_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkaboutdialog;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkaboutdialog */ 

  top->s_type =  (s_type_func *) nsp_gtkaboutdialog_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkaboutdialog_type_short_string;
  /* top->create = (create_func*) int_gtkaboutdialog_create;*/

  /* specific methods for gtkaboutdialog */

  type->init = (init_func *) init_gtkaboutdialog;

  /* 
   * NspGtkAboutDialog interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkaboutdialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAboutDialog called nsp_type_gtkaboutdialog
       */
      type->id =  nsp_type_gtkaboutdialog_id = nsp_new_type_id();
      nsp_type_gtkaboutdialog = type;
      if ( nsp_register_type(nsp_type_gtkaboutdialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkaboutdialog, GTK_TYPE_ABOUT_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkaboutdialog(mode);
    }
  else 
    {
      type->id = nsp_type_gtkaboutdialog_id;
      return type;
    }
}

/*
 * initialize NspGtkAboutDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkaboutdialog(NspGtkAboutDialog *Obj,NspTypeGtkAboutDialog *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAboutDialog 
 */

NspGtkAboutDialog *new_gtkaboutdialog() 
{
  NspGtkAboutDialog *loc;
  /* type must exists */
  nsp_type_gtkaboutdialog = new_type_gtkaboutdialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAboutDialog)))== NULLGTKABOUTDIALOG) return loc;
  /* initialize object */
  if ( init_gtkaboutdialog(loc,nsp_type_gtkaboutdialog) == FAIL) return NULLGTKABOUTDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAboutDialog 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkaboutdialog_type_name[]="GtkAboutDialog";
static char gtkaboutdialog_short_type_name[]="GtkAboutDialog";

static char *nsp_gtkaboutdialog_type_as_string(void)
{
  return(gtkaboutdialog_type_name);
}

static char *nsp_gtkaboutdialog_type_short_string(NspObject *v)
{
  return(gtkaboutdialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAboutDialog objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAboutDialog   *nsp_gtkaboutdialog_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkaboutdialog_id)  == TRUE  ) return ((NspGtkAboutDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkaboutdialog));
  return NULL;
}

int IsGtkAboutDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkaboutdialog_id);
}

int IsGtkAboutDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkaboutdialog_id);
}

NspGtkAboutDialog  *GetGtkAboutDialogCopy(Stack stack, int i)
{
  if (  GetGtkAboutDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAboutDialog  *GetGtkAboutDialog(Stack stack, int i)
{
  NspGtkAboutDialog *M;
  if (( M = nsp_gtkaboutdialog_object(NthObj(i))) == NULLGTKABOUTDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAboutDialog *gtkaboutdialog_copy(NspGtkAboutDialog *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaboutdialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaboutdialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAboutDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_about_dialog_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_about_dialog_new())== NULL) return RET_BUG;

  nsp_type_gtkaboutdialog = new_type_gtkaboutdialog(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkaboutdialog);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_about_dialog_get_program_name(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_program_name(GTK_ABOUT_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_about_dialog_set_program_name(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_about_dialog_set_program_name(GTK_ABOUT_DIALOG(self->obj),name);
  return 0;
}

static int _wrap_gtk_about_dialog_get_version(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_version(GTK_ABOUT_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_about_dialog_set_version(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *version;
  if ( GetArgs(stack,rhs,opt,T,&version) == FAIL) return RET_BUG;
    gtk_about_dialog_set_version(GTK_ABOUT_DIALOG(self->obj),version);
  return 0;
}

static int _wrap_gtk_about_dialog_get_copyright(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_copyright(GTK_ABOUT_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_about_dialog_set_copyright(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *copyright;
  if ( GetArgs(stack,rhs,opt,T,&copyright) == FAIL) return RET_BUG;
    gtk_about_dialog_set_copyright(GTK_ABOUT_DIALOG(self->obj),copyright);
  return 0;
}

static int _wrap_gtk_about_dialog_get_comments(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_comments(GTK_ABOUT_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_about_dialog_set_comments(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *comments;
  if ( GetArgs(stack,rhs,opt,T,&comments) == FAIL) return RET_BUG;
    gtk_about_dialog_set_comments(GTK_ABOUT_DIALOG(self->obj),comments);
  return 0;
}

static int _wrap_gtk_about_dialog_get_license(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_license(GTK_ABOUT_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_about_dialog_set_license(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *license;
  if ( GetArgs(stack,rhs,opt,T,&license) == FAIL) return RET_BUG;
    gtk_about_dialog_set_license(GTK_ABOUT_DIALOG(self->obj),license);
  return 0;
}

static int _wrap_gtk_about_dialog_set_license_type(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkLicense license_type;
  NspObject *nsp_license_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_license_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_LICENSE, nsp_license_type, &license_type)== FAIL)
      return RET_BUG;
    gtk_about_dialog_set_license_type(GTK_ABOUT_DIALOG(self->obj),license_type);
  return 0;
}

static int _wrap_gtk_about_dialog_get_license_type(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_license_type(GTK_ABOUT_DIALOG(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_about_dialog_get_wrap_license(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_wrap_license(GTK_ABOUT_DIALOG(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_about_dialog_set_wrap_license(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int wrap_license;
  if ( GetArgs(stack,rhs,opt,T,&wrap_license) == FAIL) return RET_BUG;
    gtk_about_dialog_set_wrap_license(GTK_ABOUT_DIALOG(self->obj),wrap_license);
  return 0;
}

static int _wrap_gtk_about_dialog_get_website(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_website(GTK_ABOUT_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_about_dialog_set_website(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *website;
  if ( GetArgs(stack,rhs,opt,T,&website) == FAIL) return RET_BUG;
    gtk_about_dialog_set_website(GTK_ABOUT_DIALOG(self->obj),website);
  return 0;
}

static int _wrap_gtk_about_dialog_get_website_label(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_website_label(GTK_ABOUT_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_about_dialog_set_website_label(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *website_label;
  if ( GetArgs(stack,rhs,opt,T,&website_label) == FAIL) return RET_BUG;
    gtk_about_dialog_set_website_label(GTK_ABOUT_DIALOG(self->obj),website_label);
  return 0;
}

static int _wrap_gtk_about_dialog_set_authors(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  const gchar **authors = NULL;
  NspObject *nsp_authors = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_authors) == FAIL) return RET_BUG;
  if ( IsSMat(nsp_authors))
    { authors = (const gchar **) ((NspSMatrix *) nsp_authors)->S;}
  else
    {
      Scierror("Error: authors should be of type SMat\n");
      return RET_BUG;
    }
    gtk_about_dialog_set_authors(GTK_ABOUT_DIALOG(self->obj),authors);
  return 0;
}

static int _wrap_gtk_about_dialog_set_documenters(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  const gchar **documenters = NULL;
  NspObject *nsp_documenters = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_documenters) == FAIL) return RET_BUG;
  if ( IsSMat(nsp_documenters))
    { documenters = (const gchar **) ((NspSMatrix *) nsp_documenters)->S;}
  else
    {
      Scierror("Error: documenters should be of type SMat\n");
      return RET_BUG;
    }
    gtk_about_dialog_set_documenters(GTK_ABOUT_DIALOG(self->obj),documenters);
  return 0;
}

static int _wrap_gtk_about_dialog_set_artists(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  const gchar **artists = NULL;
  NspObject *nsp_artists = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_artists) == FAIL) return RET_BUG;
  if ( IsSMat(nsp_artists))
    { artists = (const gchar **) ((NspSMatrix *) nsp_artists)->S;}
  else
    {
      Scierror("Error: artists should be of type SMat\n");
      return RET_BUG;
    }
    gtk_about_dialog_set_artists(GTK_ABOUT_DIALOG(self->obj),artists);
  return 0;
}

static int _wrap_gtk_about_dialog_get_translator_credits(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_translator_credits(GTK_ABOUT_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_about_dialog_set_translator_credits(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *translator_credits;
  if ( GetArgs(stack,rhs,opt,T,&translator_credits) == FAIL) return RET_BUG;
    gtk_about_dialog_set_translator_credits(GTK_ABOUT_DIALOG(self->obj),translator_credits);
  return 0;
}

static int _wrap_gtk_about_dialog_get_logo(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_logo(GTK_ABOUT_DIALOG(self->obj));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_about_dialog_set_logo(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *logo;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbuf, &logo) == FAIL) return RET_BUG;
    gtk_about_dialog_set_logo(GTK_ABOUT_DIALOG(self->obj),GDK_PIXBUF(logo->obj));
  return 0;
}

static int _wrap_gtk_about_dialog_get_logo_icon_name(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_about_dialog_get_logo_icon_name(GTK_ABOUT_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_about_dialog_set_logo_icon_name(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"icon_name",string,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  char *icon_name = NULL;
  if ( GetArgs(stack,rhs,opt,T,opts, &icon_name) == FAIL) return RET_BUG;
    gtk_about_dialog_set_logo_icon_name(GTK_ABOUT_DIALOG(self->obj),icon_name);
  return 0;
}

#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_about_dialog_add_credit_section(NspGtkAboutDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *section_name;
  const gchar **people = NULL;
  NspObject *nsp_people = NULL;
  if ( GetArgs(stack,rhs,opt,T,&section_name, &nsp_people) == FAIL) return RET_BUG;
  if ( IsSMat(nsp_people))
    { people = (const gchar **) ((NspSMatrix *) nsp_people)->S;}
  else
    {
      Scierror("Error: people should be of type SMat\n");
      return RET_BUG;
    }
    gtk_about_dialog_add_credit_section(GTK_ABOUT_DIALOG(self->obj),section_name,people);
  return 0;
}

#else
int _wrap_gtk_about_dialog_add_credit_section(Stack stack, int rhs, int opt, int lhs) /* add_credit_section */
{
  Scierror("Error: function gtk_about_dialog_add_credit_section not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkaboutdialog_methods[] = {
  {"get_program_name",(nsp_method *) _wrap_gtk_about_dialog_get_program_name},
  {"set_program_name",(nsp_method *) _wrap_gtk_about_dialog_set_program_name},
  {"get_version",(nsp_method *) _wrap_gtk_about_dialog_get_version},
  {"set_version",(nsp_method *) _wrap_gtk_about_dialog_set_version},
  {"get_copyright",(nsp_method *) _wrap_gtk_about_dialog_get_copyright},
  {"set_copyright",(nsp_method *) _wrap_gtk_about_dialog_set_copyright},
  {"get_comments",(nsp_method *) _wrap_gtk_about_dialog_get_comments},
  {"set_comments",(nsp_method *) _wrap_gtk_about_dialog_set_comments},
  {"get_license",(nsp_method *) _wrap_gtk_about_dialog_get_license},
  {"set_license",(nsp_method *) _wrap_gtk_about_dialog_set_license},
  {"set_license_type",(nsp_method *) _wrap_gtk_about_dialog_set_license_type},
  {"get_license_type",(nsp_method *) _wrap_gtk_about_dialog_get_license_type},
  {"get_wrap_license",(nsp_method *) _wrap_gtk_about_dialog_get_wrap_license},
  {"set_wrap_license",(nsp_method *) _wrap_gtk_about_dialog_set_wrap_license},
  {"get_website",(nsp_method *) _wrap_gtk_about_dialog_get_website},
  {"set_website",(nsp_method *) _wrap_gtk_about_dialog_set_website},
  {"get_website_label",(nsp_method *) _wrap_gtk_about_dialog_get_website_label},
  {"set_website_label",(nsp_method *) _wrap_gtk_about_dialog_set_website_label},
  {"set_authors",(nsp_method *) _wrap_gtk_about_dialog_set_authors},
  {"set_documenters",(nsp_method *) _wrap_gtk_about_dialog_set_documenters},
  {"set_artists",(nsp_method *) _wrap_gtk_about_dialog_set_artists},
  {"get_translator_credits",(nsp_method *) _wrap_gtk_about_dialog_get_translator_credits},
  {"set_translator_credits",(nsp_method *) _wrap_gtk_about_dialog_set_translator_credits},
  {"get_logo",(nsp_method *) _wrap_gtk_about_dialog_get_logo},
  {"set_logo",(nsp_method *) _wrap_gtk_about_dialog_set_logo},
  {"get_logo_icon_name",(nsp_method *) _wrap_gtk_about_dialog_get_logo_icon_name},
  {"set_logo_icon_name",(nsp_method *) _wrap_gtk_about_dialog_set_logo_icon_name},
  {"add_credit_section",(nsp_method *) _wrap_gtk_about_dialog_add_credit_section},
  { NULL, NULL}
};

static NspMethods *gtkaboutdialog_get_methods(void) { return gtkaboutdialog_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkaboutdialog_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAssistant ----------- */


#define  NspGtkAssistant_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkassistant.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAssistant inherits from GtkWindow 
 * and implements GtkBuildable
 */

int nsp_type_gtkassistant_id=0;
NspTypeGtkAssistant *nsp_type_gtkassistant=NULL;

/*
 * Type object for NspGtkAssistant 
 * all the instance of NspTypeGtkAssistant share the same id. 
 * nsp_type_gtkassistant: is an instance of NspTypeGtkAssistant 
 *    used for objects of NspGtkAssistant type (i.e built with new_gtkassistant) 
 * other instances are used for derived classes 
 */
NspTypeGtkAssistant *new_type_gtkassistant(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkAssistant *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkassistant != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkassistant;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWindow))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwindow(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkassistant_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkassistant_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkassistant;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkassistant */ 

  top->s_type =  (s_type_func *) nsp_gtkassistant_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkassistant_type_short_string;
  /* top->create = (create_func*) int_gtkassistant_create;*/

  /* specific methods for gtkassistant */

  type->init = (init_func *) init_gtkassistant;

  /* 
   * NspGtkAssistant interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkassistant_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAssistant called nsp_type_gtkassistant
       */
      type->id =  nsp_type_gtkassistant_id = nsp_new_type_id();
      nsp_type_gtkassistant = type;
      if ( nsp_register_type(nsp_type_gtkassistant) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkassistant, GTK_TYPE_ASSISTANT);
      return ( mode == T_BASE ) ? type : new_type_gtkassistant(mode);
    }
  else 
    {
      type->id = nsp_type_gtkassistant_id;
      return type;
    }
}

/*
 * initialize NspGtkAssistant instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkassistant(NspGtkAssistant *Obj,NspTypeGtkAssistant *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAssistant 
 */

NspGtkAssistant *new_gtkassistant() 
{
  NspGtkAssistant *loc;
  /* type must exists */
  nsp_type_gtkassistant = new_type_gtkassistant(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAssistant)))== NULLGTKASSISTANT) return loc;
  /* initialize object */
  if ( init_gtkassistant(loc,nsp_type_gtkassistant) == FAIL) return NULLGTKASSISTANT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAssistant 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkassistant_type_name[]="GtkAssistant";
static char gtkassistant_short_type_name[]="GtkAssistant";

static char *nsp_gtkassistant_type_as_string(void)
{
  return(gtkassistant_type_name);
}

static char *nsp_gtkassistant_type_short_string(NspObject *v)
{
  return(gtkassistant_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAssistant objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAssistant   *nsp_gtkassistant_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkassistant_id)  == TRUE  ) return ((NspGtkAssistant *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkassistant));
  return NULL;
}

int IsGtkAssistantObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkassistant_id);
}

int IsGtkAssistant(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkassistant_id);
}

NspGtkAssistant  *GetGtkAssistantCopy(Stack stack, int i)
{
  if (  GetGtkAssistant(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAssistant  *GetGtkAssistant(Stack stack, int i)
{
  NspGtkAssistant *M;
  if (( M = nsp_gtkassistant_object(NthObj(i))) == NULLGTKASSISTANT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAssistant *gtkassistant_copy(NspGtkAssistant *self)
{
  /* return gtkwindow_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkassistant);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkassistant);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAssistant
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_assistant_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_assistant_new())== NULL) return RET_BUG;

  nsp_type_gtkassistant = new_type_gtkassistant(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkassistant);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_assistant_next_page(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_assistant_next_page(GTK_ASSISTANT(self->obj));
  return 0;
}

static int _wrap_gtk_assistant_previous_page(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_assistant_previous_page(GTK_ASSISTANT(self->obj));
  return 0;
}

static int _wrap_gtk_assistant_get_current_page(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_assistant_get_current_page(GTK_ASSISTANT(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_assistant_set_current_page(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int page_num;
  if ( GetArgs(stack,rhs,opt,T,&page_num) == FAIL) return RET_BUG;
    gtk_assistant_set_current_page(GTK_ASSISTANT(self->obj),page_num);
  return 0;
}

static int _wrap_gtk_assistant_get_n_pages(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_assistant_get_n_pages(GTK_ASSISTANT(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_assistant_get_nth_page(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int page_num;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&page_num) == FAIL) return RET_BUG;
    ret =gtk_assistant_get_nth_page(GTK_ASSISTANT(self->obj),page_num);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_assistant_prepend_page(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *page;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page) == FAIL) return RET_BUG;
    ret =gtk_assistant_prepend_page(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_assistant_append_page(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *page;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page) == FAIL) return RET_BUG;
    ret =gtk_assistant_append_page(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_assistant_insert_page(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *page;
  int position, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page, &position) == FAIL) return RET_BUG;
    ret =gtk_assistant_insert_page(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj),position);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_assistant_remove_page(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int page_num;
  if ( GetArgs(stack,rhs,opt,T,&page_num) == FAIL) return RET_BUG;
    gtk_assistant_remove_page(GTK_ASSISTANT(self->obj),page_num);
  return 0;
}

#else
int _wrap_gtk_assistant_remove_page(Stack stack, int rhs, int opt, int lhs) /* remove_page */
{
  Scierror("Error: function gtk_assistant_remove_page not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_assistant_set_page_type(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *page;
  GtkAssistantPageType type;
  NspObject *nsp_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page, &nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ASSISTANT_PAGE_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
    gtk_assistant_set_page_type(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj),type);
  return 0;
}

static int _wrap_gtk_assistant_get_page_type(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *page;
  gint ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page) == FAIL) return RET_BUG;
    ret =gtk_assistant_get_page_type(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_assistant_set_page_title(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *page;
  char *title;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page, &title) == FAIL) return RET_BUG;
    gtk_assistant_set_page_title(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj),title);
  return 0;
}

static int _wrap_gtk_assistant_get_page_title(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *page;
  const gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page) == FAIL) return RET_BUG;
    ret =gtk_assistant_get_page_title(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,2,0)
int _wrap_gtk_assistant_set_page_header_image(Stack stack, int rhs, int opt, int lhs) /* set_page_header_image */
{
  Scierror("Error: function gtk_assistant_set_page_header_image is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_assistant_set_page_header_image(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *page, *pixbuf;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page, &nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
    gtk_assistant_set_page_header_image(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj),GDK_PIXBUF(pixbuf->obj));
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,2,0)
int _wrap_gtk_assistant_get_page_header_image(Stack stack, int rhs, int opt, int lhs) /* get_page_header_image */
{
  Scierror("Error: function gtk_assistant_get_page_header_image is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_assistant_get_page_header_image(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *page;
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page) == FAIL) return RET_BUG;
    ret =gtk_assistant_get_page_header_image(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,2,0)
int _wrap_gtk_assistant_set_page_side_image(Stack stack, int rhs, int opt, int lhs) /* set_page_side_image */
{
  Scierror("Error: function gtk_assistant_set_page_side_image is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_assistant_set_page_side_image(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *page, *pixbuf;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page, &nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
    gtk_assistant_set_page_side_image(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj),GDK_PIXBUF(pixbuf->obj));
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,2,0)
int _wrap_gtk_assistant_get_page_side_image(Stack stack, int rhs, int opt, int lhs) /* get_page_side_image */
{
  Scierror("Error: function gtk_assistant_get_page_side_image is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_assistant_get_page_side_image(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *page;
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page) == FAIL) return RET_BUG;
    ret =gtk_assistant_get_page_side_image(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#endif
static int _wrap_gtk_assistant_set_page_complete(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *page;
  int complete;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page, &complete) == FAIL) return RET_BUG;
    gtk_assistant_set_page_complete(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj),complete);
  return 0;
}

static int _wrap_gtk_assistant_get_page_complete(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *page;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &page) == FAIL) return RET_BUG;
    ret =gtk_assistant_get_page_complete(GTK_ASSISTANT(self->obj),GTK_WIDGET(page->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_assistant_add_action_widget(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_assistant_add_action_widget(GTK_ASSISTANT(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_assistant_remove_action_widget(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_assistant_remove_action_widget(GTK_ASSISTANT(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_assistant_update_buttons_state(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_assistant_update_buttons_state(GTK_ASSISTANT(self->obj));
  return 0;
}

static int _wrap_gtk_assistant_commit(NspGtkAssistant *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_assistant_commit(GTK_ASSISTANT(self->obj));
  return 0;
}

static NspMethods gtkassistant_methods[] = {
  {"next_page",(nsp_method *) _wrap_gtk_assistant_next_page},
  {"previous_page",(nsp_method *) _wrap_gtk_assistant_previous_page},
  {"get_current_page",(nsp_method *) _wrap_gtk_assistant_get_current_page},
  {"set_current_page",(nsp_method *) _wrap_gtk_assistant_set_current_page},
  {"get_n_pages",(nsp_method *) _wrap_gtk_assistant_get_n_pages},
  {"get_nth_page",(nsp_method *) _wrap_gtk_assistant_get_nth_page},
  {"prepend_page",(nsp_method *) _wrap_gtk_assistant_prepend_page},
  {"append_page",(nsp_method *) _wrap_gtk_assistant_append_page},
  {"insert_page",(nsp_method *) _wrap_gtk_assistant_insert_page},
  {"remove_page",(nsp_method *) _wrap_gtk_assistant_remove_page},
  {"set_page_type",(nsp_method *) _wrap_gtk_assistant_set_page_type},
  {"get_page_type",(nsp_method *) _wrap_gtk_assistant_get_page_type},
  {"set_page_title",(nsp_method *) _wrap_gtk_assistant_set_page_title},
  {"get_page_title",(nsp_method *) _wrap_gtk_assistant_get_page_title},
  {"set_page_header_image",(nsp_method *) _wrap_gtk_assistant_set_page_header_image},
  {"get_page_header_image",(nsp_method *) _wrap_gtk_assistant_get_page_header_image},
  {"set_page_side_image",(nsp_method *) _wrap_gtk_assistant_set_page_side_image},
  {"get_page_side_image",(nsp_method *) _wrap_gtk_assistant_get_page_side_image},
  {"set_page_complete",(nsp_method *) _wrap_gtk_assistant_set_page_complete},
  {"get_page_complete",(nsp_method *) _wrap_gtk_assistant_get_page_complete},
  {"add_action_widget",(nsp_method *) _wrap_gtk_assistant_add_action_widget},
  {"remove_action_widget",(nsp_method *) _wrap_gtk_assistant_remove_action_widget},
  {"update_buttons_state",(nsp_method *) _wrap_gtk_assistant_update_buttons_state},
  {"commit",(nsp_method *) _wrap_gtk_assistant_commit},
  { NULL, NULL}
};

static NspMethods *gtkassistant_get_methods(void) { return gtkassistant_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkassistant_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkInvisible ----------- */


#define  NspGtkInvisible_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkinvisible.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkInvisible inherits from GtkWidget 
 * and implements GtkBuildable
 */

int nsp_type_gtkinvisible_id=0;
NspTypeGtkInvisible *nsp_type_gtkinvisible=NULL;

/*
 * Type object for NspGtkInvisible 
 * all the instance of NspTypeGtkInvisible share the same id. 
 * nsp_type_gtkinvisible: is an instance of NspTypeGtkInvisible 
 *    used for objects of NspGtkInvisible type (i.e built with new_gtkinvisible) 
 * other instances are used for derived classes 
 */
NspTypeGtkInvisible *new_type_gtkinvisible(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkInvisible *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkinvisible != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkinvisible;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkinvisible_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkinvisible_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkinvisible;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkinvisible */ 

  top->s_type =  (s_type_func *) nsp_gtkinvisible_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkinvisible_type_short_string;
  /* top->create = (create_func*) int_gtkinvisible_create;*/

  /* specific methods for gtkinvisible */

  type->init = (init_func *) init_gtkinvisible;

  /* 
   * NspGtkInvisible interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkinvisible_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkInvisible called nsp_type_gtkinvisible
       */
      type->id =  nsp_type_gtkinvisible_id = nsp_new_type_id();
      nsp_type_gtkinvisible = type;
      if ( nsp_register_type(nsp_type_gtkinvisible) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkinvisible, GTK_TYPE_INVISIBLE);
      return ( mode == T_BASE ) ? type : new_type_gtkinvisible(mode);
    }
  else 
    {
      type->id = nsp_type_gtkinvisible_id;
      return type;
    }
}

/*
 * initialize NspGtkInvisible instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkinvisible(NspGtkInvisible *Obj,NspTypeGtkInvisible *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkInvisible 
 */

NspGtkInvisible *new_gtkinvisible() 
{
  NspGtkInvisible *loc;
  /* type must exists */
  nsp_type_gtkinvisible = new_type_gtkinvisible(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkInvisible)))== NULLGTKINVISIBLE) return loc;
  /* initialize object */
  if ( init_gtkinvisible(loc,nsp_type_gtkinvisible) == FAIL) return NULLGTKINVISIBLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkInvisible 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkinvisible_type_name[]="GtkInvisible";
static char gtkinvisible_short_type_name[]="GtkInvisible";

static char *nsp_gtkinvisible_type_as_string(void)
{
  return(gtkinvisible_type_name);
}

static char *nsp_gtkinvisible_type_short_string(NspObject *v)
{
  return(gtkinvisible_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkInvisible objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkInvisible   *nsp_gtkinvisible_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkinvisible_id)  == TRUE  ) return ((NspGtkInvisible *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkinvisible));
  return NULL;
}

int IsGtkInvisibleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkinvisible_id);
}

int IsGtkInvisible(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkinvisible_id);
}

NspGtkInvisible  *GetGtkInvisibleCopy(Stack stack, int i)
{
  if (  GetGtkInvisible(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkInvisible  *GetGtkInvisible(Stack stack, int i)
{
  NspGtkInvisible *M;
  if (( M = nsp_gtkinvisible_object(NthObj(i))) == NULLGTKINVISIBLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkInvisible *gtkinvisible_copy(NspGtkInvisible *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkinvisible);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkinvisible);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkInvisible
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_invisible_new_for_screen (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *screen;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_invisible_new_for_screen(GDK_SCREEN(screen->obj)))== NULL) return RET_BUG;

  nsp_type_gtkinvisible = new_type_gtkinvisible(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkinvisible);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_invisible_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_invisible_new())== NULL) return RET_BUG;

  nsp_type_gtkinvisible = new_type_gtkinvisible(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkinvisible);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_invisible_set_screen(NspGtkInvisible *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *screen;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen) == FAIL) return RET_BUG;
    gtk_invisible_set_screen(GTK_INVISIBLE(self->obj),GDK_SCREEN(screen->obj));
  return 0;
}

static int _wrap_gtk_invisible_get_screen(NspGtkInvisible *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkScreen *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_invisible_get_screen(GTK_INVISIBLE(self->obj));
  nsp_type_gdkscreen = new_type_gdkscreen(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkscreen))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkinvisible_methods[] = {
  {"set_screen",(nsp_method *) _wrap_gtk_invisible_set_screen},
  {"get_screen",(nsp_method *) _wrap_gtk_invisible_get_screen},
  { NULL, NULL}
};

static NspMethods *gtkinvisible_get_methods(void) { return gtkinvisible_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkinvisible_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkOffscreenWindow ----------- */


#define  NspGtkOffscreenWindow_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkoffscreenwindow.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkOffscreenWindow inherits from GtkWindow 
 * and implements GtkBuildable
 */

int nsp_type_gtkoffscreenwindow_id=0;
NspTypeGtkOffscreenWindow *nsp_type_gtkoffscreenwindow=NULL;

/*
 * Type object for NspGtkOffscreenWindow 
 * all the instance of NspTypeGtkOffscreenWindow share the same id. 
 * nsp_type_gtkoffscreenwindow: is an instance of NspTypeGtkOffscreenWindow 
 *    used for objects of NspGtkOffscreenWindow type (i.e built with new_gtkoffscreenwindow) 
 * other instances are used for derived classes 
 */
NspTypeGtkOffscreenWindow *new_type_gtkoffscreenwindow(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkOffscreenWindow *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkoffscreenwindow != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkoffscreenwindow;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWindow))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwindow(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkoffscreenwindow_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkoffscreenwindow_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkoffscreenwindow;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkoffscreenwindow */ 

  top->s_type =  (s_type_func *) nsp_gtkoffscreenwindow_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkoffscreenwindow_type_short_string;
  /* top->create = (create_func*) int_gtkoffscreenwindow_create;*/

  /* specific methods for gtkoffscreenwindow */

  type->init = (init_func *) init_gtkoffscreenwindow;

  /* 
   * NspGtkOffscreenWindow interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkoffscreenwindow_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkOffscreenWindow called nsp_type_gtkoffscreenwindow
       */
      type->id =  nsp_type_gtkoffscreenwindow_id = nsp_new_type_id();
      nsp_type_gtkoffscreenwindow = type;
      if ( nsp_register_type(nsp_type_gtkoffscreenwindow) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkoffscreenwindow, GTK_TYPE_OFFSCREEN_WINDOW);
      return ( mode == T_BASE ) ? type : new_type_gtkoffscreenwindow(mode);
    }
  else 
    {
      type->id = nsp_type_gtkoffscreenwindow_id;
      return type;
    }
}

/*
 * initialize NspGtkOffscreenWindow instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkoffscreenwindow(NspGtkOffscreenWindow *Obj,NspTypeGtkOffscreenWindow *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkOffscreenWindow 
 */

NspGtkOffscreenWindow *new_gtkoffscreenwindow() 
{
  NspGtkOffscreenWindow *loc;
  /* type must exists */
  nsp_type_gtkoffscreenwindow = new_type_gtkoffscreenwindow(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkOffscreenWindow)))== NULLGTKOFFSCREENWINDOW) return loc;
  /* initialize object */
  if ( init_gtkoffscreenwindow(loc,nsp_type_gtkoffscreenwindow) == FAIL) return NULLGTKOFFSCREENWINDOW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkOffscreenWindow 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkoffscreenwindow_type_name[]="GtkOffscreenWindow";
static char gtkoffscreenwindow_short_type_name[]="GtkOffscreenWindow";

static char *nsp_gtkoffscreenwindow_type_as_string(void)
{
  return(gtkoffscreenwindow_type_name);
}

static char *nsp_gtkoffscreenwindow_type_short_string(NspObject *v)
{
  return(gtkoffscreenwindow_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkOffscreenWindow objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkOffscreenWindow   *nsp_gtkoffscreenwindow_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkoffscreenwindow_id)  == TRUE  ) return ((NspGtkOffscreenWindow *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkoffscreenwindow));
  return NULL;
}

int IsGtkOffscreenWindowObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkoffscreenwindow_id);
}

int IsGtkOffscreenWindow(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkoffscreenwindow_id);
}

NspGtkOffscreenWindow  *GetGtkOffscreenWindowCopy(Stack stack, int i)
{
  if (  GetGtkOffscreenWindow(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkOffscreenWindow  *GetGtkOffscreenWindow(Stack stack, int i)
{
  NspGtkOffscreenWindow *M;
  if (( M = nsp_gtkoffscreenwindow_object(NthObj(i))) == NULLGTKOFFSCREENWINDOW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkOffscreenWindow *gtkoffscreenwindow_copy(NspGtkOffscreenWindow *self)
{
  /* return gtkwindow_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkoffscreenwindow);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkoffscreenwindow);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkOffscreenWindow
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_offscreen_window_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_offscreen_window_new())== NULL) return RET_BUG;

  nsp_type_gtkoffscreenwindow = new_type_gtkoffscreenwindow(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkoffscreenwindow);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_offscreen_window_get_surface(NspGtkOffscreenWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  cairo_surface_t *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_offscreen_window_get_surface(GTK_OFFSCREEN_WINDOW(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,CAIRO_GOBJECT_TYPE_SURFACE, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_cairo_surface_t))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_offscreen_window_get_pixbuf(NspGtkOffscreenWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_offscreen_window_get_pixbuf(GTK_OFFSCREEN_WINDOW(self->obj));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkoffscreenwindow_methods[] = {
  {"get_surface",(nsp_method *) _wrap_gtk_offscreen_window_get_surface},
  {"get_pixbuf",(nsp_method *) _wrap_gtk_offscreen_window_get_pixbuf},
  { NULL, NULL}
};

static NspMethods *gtkoffscreenwindow_get_methods(void) { return gtkoffscreenwindow_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkoffscreenwindow_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkWindowGroup ----------- */


#define  NspGtkWindowGroup_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkwindowgroup.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkWindowGroup inherits from GObject 
 */

int nsp_type_gtkwindowgroup_id=0;
NspTypeGtkWindowGroup *nsp_type_gtkwindowgroup=NULL;

/*
 * Type object for NspGtkWindowGroup 
 * all the instance of NspTypeGtkWindowGroup share the same id. 
 * nsp_type_gtkwindowgroup: is an instance of NspTypeGtkWindowGroup 
 *    used for objects of NspGtkWindowGroup type (i.e built with new_gtkwindowgroup) 
 * other instances are used for derived classes 
 */
NspTypeGtkWindowGroup *new_type_gtkwindowgroup(type_mode mode)
{
  NspTypeGtkWindowGroup *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkwindowgroup != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkwindowgroup;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkwindowgroup_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkwindowgroup_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkwindowgroup;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkwindowgroup */ 

  top->s_type =  (s_type_func *) nsp_gtkwindowgroup_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkwindowgroup_type_short_string;
  /* top->create = (create_func*) int_gtkwindowgroup_create;*/

  /* specific methods for gtkwindowgroup */

  type->init = (init_func *) init_gtkwindowgroup;

  /* 
   * NspGtkWindowGroup interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkwindowgroup_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkWindowGroup called nsp_type_gtkwindowgroup
       */
      type->id =  nsp_type_gtkwindowgroup_id = nsp_new_type_id();
      nsp_type_gtkwindowgroup = type;
      if ( nsp_register_type(nsp_type_gtkwindowgroup) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkwindowgroup, GTK_TYPE_WINDOW_GROUP);
      return ( mode == T_BASE ) ? type : new_type_gtkwindowgroup(mode);
    }
  else 
    {
      type->id = nsp_type_gtkwindowgroup_id;
      return type;
    }
}

/*
 * initialize NspGtkWindowGroup instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkwindowgroup(NspGtkWindowGroup *Obj,NspTypeGtkWindowGroup *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkWindowGroup 
 */

NspGtkWindowGroup *new_gtkwindowgroup() 
{
  NspGtkWindowGroup *loc;
  /* type must exists */
  nsp_type_gtkwindowgroup = new_type_gtkwindowgroup(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkWindowGroup)))== NULLGTKWINDOWGROUP) return loc;
  /* initialize object */
  if ( init_gtkwindowgroup(loc,nsp_type_gtkwindowgroup) == FAIL) return NULLGTKWINDOWGROUP;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkWindowGroup 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkwindowgroup_type_name[]="GtkWindowGroup";
static char gtkwindowgroup_short_type_name[]="GtkWindowGroup";

static char *nsp_gtkwindowgroup_type_as_string(void)
{
  return(gtkwindowgroup_type_name);
}

static char *nsp_gtkwindowgroup_type_short_string(NspObject *v)
{
  return(gtkwindowgroup_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkWindowGroup objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkWindowGroup   *nsp_gtkwindowgroup_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkwindowgroup_id)  == TRUE  ) return ((NspGtkWindowGroup *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkwindowgroup));
  return NULL;
}

int IsGtkWindowGroupObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkwindowgroup_id);
}

int IsGtkWindowGroup(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkwindowgroup_id);
}

NspGtkWindowGroup  *GetGtkWindowGroupCopy(Stack stack, int i)
{
  if (  GetGtkWindowGroup(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkWindowGroup  *GetGtkWindowGroup(Stack stack, int i)
{
  NspGtkWindowGroup *M;
  if (( M = nsp_gtkwindowgroup_object(NthObj(i))) == NULLGTKWINDOWGROUP)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkWindowGroup *gtkwindowgroup_copy(NspGtkWindowGroup *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwindowgroup);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwindowgroup);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkWindowGroup
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_window_group_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_window_group_new())== NULL) return RET_BUG;

  nsp_type_gtkwindowgroup = new_type_gtkwindowgroup(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindowgroup);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_group_add_window(NspGtkWindowGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &window) == FAIL) return RET_BUG;
    gtk_window_group_add_window(GTK_WINDOW_GROUP(self->obj),GTK_WINDOW(window->obj));
  return 0;
}

static int _wrap_gtk_window_group_remove_window(NspGtkWindowGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &window) == FAIL) return RET_BUG;
    gtk_window_group_remove_window(GTK_WINDOW_GROUP(self->obj),GTK_WINDOW(window->obj));
  return 0;
}

static int _wrap_gtk_window_group_list_windows(NspGtkWindowGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_window_group_list_windows(GTK_WINDOW_GROUP(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

static int _wrap_gtk_window_group_get_current_grab(NspGtkWindowGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_window_group_get_current_grab(GTK_WINDOW_GROUP(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_window_group_get_current_device_grab(NspGtkWindowGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *device;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdevice, &device) == FAIL) return RET_BUG;
    ret =gtk_window_group_get_current_device_grab(GTK_WINDOW_GROUP(self->obj),GDK_DEVICE(device->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkwindowgroup_methods[] = {
  {"add_window",(nsp_method *) _wrap_gtk_window_group_add_window},
  {"remove_window",(nsp_method *) _wrap_gtk_window_group_remove_window},
  {"list_windows",(nsp_method *) _wrap_gtk_window_group_list_windows},
  {"get_current_grab",(nsp_method *) _wrap_gtk_window_group_get_current_grab},
  {"get_current_device_grab",(nsp_method *) _wrap_gtk_window_group_get_current_device_grab},
  { NULL, NULL}
};

static NspMethods *gtkwindowgroup_get_methods(void) { return gtkwindowgroup_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkwindowgroup_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkBox ----------- */


#define  NspGtkBox_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkbox.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkBox inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtkbox_id=0;
NspTypeGtkBox *nsp_type_gtkbox=NULL;

/*
 * Type object for NspGtkBox 
 * all the instance of NspTypeGtkBox share the same id. 
 * nsp_type_gtkbox: is an instance of NspTypeGtkBox 
 *    used for objects of NspGtkBox type (i.e built with new_gtkbox) 
 * other instances are used for derived classes 
 */
NspTypeGtkBox *new_type_gtkbox(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkbox != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkbox;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkbox_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkbox_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkbox;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkbox */ 

  top->s_type =  (s_type_func *) nsp_gtkbox_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkbox_type_short_string;
  /* top->create = (create_func*) int_gtkbox_create;*/

  /* specific methods for gtkbox */

  type->init = (init_func *) init_gtkbox;

  /* 
   * NspGtkBox interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkBox called nsp_type_gtkbox
       */
      type->id =  nsp_type_gtkbox_id = nsp_new_type_id();
      nsp_type_gtkbox = type;
      if ( nsp_register_type(nsp_type_gtkbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkbox, GTK_TYPE_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkbox(mode);
    }
  else 
    {
      type->id = nsp_type_gtkbox_id;
      return type;
    }
}

/*
 * initialize NspGtkBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkbox(NspGtkBox *Obj,NspTypeGtkBox *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkBox 
 */

NspGtkBox *new_gtkbox() 
{
  NspGtkBox *loc;
  /* type must exists */
  nsp_type_gtkbox = new_type_gtkbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkBox)))== NULLGTKBOX) return loc;
  /* initialize object */
  if ( init_gtkbox(loc,nsp_type_gtkbox) == FAIL) return NULLGTKBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkBox 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkbox_type_name[]="GtkBox";
static char gtkbox_short_type_name[]="GtkBox";

static char *nsp_gtkbox_type_as_string(void)
{
  return(gtkbox_type_name);
}

static char *nsp_gtkbox_type_short_string(NspObject *v)
{
  return(gtkbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkBox objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkBox   *nsp_gtkbox_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkbox_id)  == TRUE  ) return ((NspGtkBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkbox));
  return NULL;
}

int IsGtkBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkbox_id);
}

int IsGtkBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkbox_id);
}

NspGtkBox  *GetGtkBoxCopy(Stack stack, int i)
{
  if (  GetGtkBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkBox  *GetGtkBox(Stack stack, int i)
{
  NspGtkBox *M;
  if (( M = nsp_gtkbox_object(NthObj(i))) == NULLGTKBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkBox *gtkbox_copy(NspGtkBox *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_box_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,new_opts, t_end};
  nsp_option opts[] = {
	{"spacing",s_int,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;
  int spacing = 0;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation, opts, &spacing) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_box_new(orientation,spacing))== NULL) return RET_BUG;

  nsp_type_gtkbox = new_type_gtkbox(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbox);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_box_pack_start(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,new_opts, t_end};
  nsp_option opts[] = {
	{"expand",s_bool,NULLOBJ,-1},
	{"fill",s_bool,NULLOBJ,-1},
	{"padding",s_int,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *child;
  int expand = TRUE, fill = TRUE, padding = 0;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, opts, &expand, &fill, &padding) == FAIL) return RET_BUG;
    gtk_box_pack_start(GTK_BOX(self->obj),GTK_WIDGET(child->obj),expand,fill,padding);
  return 0;
}

static int _wrap_gtk_box_pack_end(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,new_opts, t_end};
  nsp_option opts[] = {
	{"expand",s_bool,NULLOBJ,-1},
	{"fill",s_bool,NULLOBJ,-1},
	{"padding",s_int,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *child;
  int expand = TRUE, fill = TRUE, padding = 0;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, opts, &expand, &fill, &padding) == FAIL) return RET_BUG;
    gtk_box_pack_end(GTK_BOX(self->obj),GTK_WIDGET(child->obj),expand,fill,padding);
  return 0;
}

static int _wrap_gtk_box_set_homogeneous(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int homogeneous;
  if ( GetArgs(stack,rhs,opt,T,&homogeneous) == FAIL) return RET_BUG;
    gtk_box_set_homogeneous(GTK_BOX(self->obj),homogeneous);
  return 0;
}

static int _wrap_gtk_box_get_homogeneous(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_box_get_homogeneous(GTK_BOX(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_box_set_spacing(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int spacing;
  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
    gtk_box_set_spacing(GTK_BOX(self->obj),spacing);
  return 0;
}

static int _wrap_gtk_box_get_spacing(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_box_get_spacing(GTK_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_box_set_baseline_position(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkBaselinePosition position;
  NspObject *nsp_position = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_position) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_BASELINE_POSITION, nsp_position, &position)== FAIL)
      return RET_BUG;
    gtk_box_set_baseline_position(GTK_BOX(self->obj),position);
  return 0;
}

#else
int _wrap_gtk_box_set_baseline_position(Stack stack, int rhs, int opt, int lhs) /* set_baseline_position */
{
  Scierror("Error: function gtk_box_set_baseline_position not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_box_get_baseline_position(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_box_get_baseline_position(GTK_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_box_get_baseline_position(Stack stack, int rhs, int opt, int lhs) /* get_baseline_position */
{
  Scierror("Error: function gtk_box_get_baseline_position not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_box_reorder_child(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *child;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &position) == FAIL) return RET_BUG;
    gtk_box_reorder_child(GTK_BOX(self->obj),GTK_WIDGET(child->obj),position);
  return 0;
}

#line 1405 "codegen-3.0/gtk.override"
static int
_wrap_gtk_box_query_child_packing(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,t_end} ;
  /* static char *kwlist[] = { "child", NULL };*/
  NspGObject *nsp_child;
  GtkWidget *child;
  GList *children;
  gboolean expand, fill;
  guint padding;
  GtkPackType pack_type;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &nsp_child)== FAIL) return RET_BUG;

  child = GTK_WIDGET(nsp_child->obj);
  children = gtk_container_get_children(GTK_CONTAINER(self->obj));
  if (g_list_find(children, child) == NULL) {
    Scierror(
	     "first argument must be a child");
    return RET_BUG;
  }
  gtk_box_query_child_packing(GTK_BOX(self->obj),
			      child, &expand, &fill,
			      &padding, &pack_type);
  if (  nsp_move_doubles(stack,1,4,1,(double) expand,(double) fill,(double) padding, (double)pack_type ) == FAIL)
    return RET_BUG;
  return 1;
}
#line 17281 "gtk.c"


static int _wrap_gtk_box_set_child_packing(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool,s_bool,s_int,obj, t_end};
  NspGObject *child;
  int expand, fill, padding;
  GtkPackType pack_type;
  NspObject *nsp_pack_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &expand, &fill, &padding, &nsp_pack_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_PACK_TYPE, nsp_pack_type, &pack_type)== FAIL)
      return RET_BUG;
    gtk_box_set_child_packing(GTK_BOX(self->obj),GTK_WIDGET(child->obj),expand,fill,padding,pack_type);
  return 0;
}

#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_box_set_center_widget(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_box_set_center_widget(GTK_BOX(self->obj),GTK_WIDGET(widget->obj));
  return 0;
}

#else
int _wrap_gtk_box_set_center_widget(Stack stack, int rhs, int opt, int lhs) /* set_center_widget */
{
  Scierror("Error: function gtk_box_set_center_widget not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_box_get_center_widget(NspGtkBox *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_box_get_center_widget(GTK_BOX(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_box_get_center_widget(Stack stack, int rhs, int opt, int lhs) /* get_center_widget */
{
  Scierror("Error: function gtk_box_get_center_widget not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkbox_methods[] = {
  {"pack_start",(nsp_method *) _wrap_gtk_box_pack_start},
  {"pack_end",(nsp_method *) _wrap_gtk_box_pack_end},
  {"set_homogeneous",(nsp_method *) _wrap_gtk_box_set_homogeneous},
  {"get_homogeneous",(nsp_method *) _wrap_gtk_box_get_homogeneous},
  {"set_spacing",(nsp_method *) _wrap_gtk_box_set_spacing},
  {"get_spacing",(nsp_method *) _wrap_gtk_box_get_spacing},
  {"set_baseline_position",(nsp_method *) _wrap_gtk_box_set_baseline_position},
  {"get_baseline_position",(nsp_method *) _wrap_gtk_box_get_baseline_position},
  {"reorder_child",(nsp_method *) _wrap_gtk_box_reorder_child},
  {"query_child_packing",(nsp_method *) _wrap_gtk_box_query_child_packing},
  {"set_child_packing",(nsp_method *) _wrap_gtk_box_set_child_packing},
  {"set_center_widget",(nsp_method *) _wrap_gtk_box_set_center_widget},
  {"get_center_widget",(nsp_method *) _wrap_gtk_box_get_center_widget},
  { NULL, NULL}
};

static NspMethods *gtkbox_get_methods(void) { return gtkbox_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkbox_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkGrid ----------- */


#define  NspGtkGrid_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkgrid.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkGrid inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtkgrid_id=0;
NspTypeGtkGrid *nsp_type_gtkgrid=NULL;

/*
 * Type object for NspGtkGrid 
 * all the instance of NspTypeGtkGrid share the same id. 
 * nsp_type_gtkgrid: is an instance of NspTypeGtkGrid 
 *    used for objects of NspGtkGrid type (i.e built with new_gtkgrid) 
 * other instances are used for derived classes 
 */
NspTypeGtkGrid *new_type_gtkgrid(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkGrid *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkgrid != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkgrid;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkgrid_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkgrid_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkgrid;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkgrid */ 

  top->s_type =  (s_type_func *) nsp_gtkgrid_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkgrid_type_short_string;
  /* top->create = (create_func*) int_gtkgrid_create;*/

  /* specific methods for gtkgrid */

  type->init = (init_func *) init_gtkgrid;

  /* 
   * NspGtkGrid interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkgrid_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkGrid called nsp_type_gtkgrid
       */
      type->id =  nsp_type_gtkgrid_id = nsp_new_type_id();
      nsp_type_gtkgrid = type;
      if ( nsp_register_type(nsp_type_gtkgrid) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkgrid, GTK_TYPE_GRID);
      return ( mode == T_BASE ) ? type : new_type_gtkgrid(mode);
    }
  else 
    {
      type->id = nsp_type_gtkgrid_id;
      return type;
    }
}

/*
 * initialize NspGtkGrid instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkgrid(NspGtkGrid *Obj,NspTypeGtkGrid *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkGrid 
 */

NspGtkGrid *new_gtkgrid() 
{
  NspGtkGrid *loc;
  /* type must exists */
  nsp_type_gtkgrid = new_type_gtkgrid(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkGrid)))== NULLGTKGRID) return loc;
  /* initialize object */
  if ( init_gtkgrid(loc,nsp_type_gtkgrid) == FAIL) return NULLGTKGRID;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkGrid 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkgrid_type_name[]="GtkGrid";
static char gtkgrid_short_type_name[]="GtkGrid";

static char *nsp_gtkgrid_type_as_string(void)
{
  return(gtkgrid_type_name);
}

static char *nsp_gtkgrid_type_short_string(NspObject *v)
{
  return(gtkgrid_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkGrid objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkGrid   *nsp_gtkgrid_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkgrid_id)  == TRUE  ) return ((NspGtkGrid *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkgrid));
  return NULL;
}

int IsGtkGridObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkgrid_id);
}

int IsGtkGrid(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkgrid_id);
}

NspGtkGrid  *GetGtkGridCopy(Stack stack, int i)
{
  if (  GetGtkGrid(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkGrid  *GetGtkGrid(Stack stack, int i)
{
  NspGtkGrid *M;
  if (( M = nsp_gtkgrid_object(NthObj(i))) == NULLGTKGRID)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkGrid *gtkgrid_copy(NspGtkGrid *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkgrid);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkgrid);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkGrid
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_grid_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_grid_new())== NULL) return RET_BUG;

  nsp_type_gtkgrid = new_type_gtkgrid(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkgrid);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_grid_attach(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int,s_int,s_int, t_end};
  NspGObject *child;
  int left, top, width, height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &left, &top, &width, &height) == FAIL) return RET_BUG;
    gtk_grid_attach(GTK_GRID(self->obj),GTK_WIDGET(child->obj),left,top,width,height);
  return 0;
}

static int _wrap_gtk_grid_attach_next_to(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check,obj,s_int,s_int, t_end};
  NspGObject *child, *sibling;
  GtkPositionType side;
  NspObject *nsp_side = NULL;
  int width, height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &sibling, &nsp_side, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_side, &side)== FAIL)
      return RET_BUG;
    gtk_grid_attach_next_to(GTK_GRID(self->obj),GTK_WIDGET(child->obj),GTK_WIDGET(sibling->obj),side,width,height);
  return 0;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_grid_get_child_at(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int left, top;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&left, &top) == FAIL) return RET_BUG;
    ret =gtk_grid_get_child_at(GTK_GRID(self->obj),left,top);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_grid_get_child_at(Stack stack, int rhs, int opt, int lhs) /* get_child_at */
{
  Scierror("Error: function gtk_grid_get_child_at not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_grid_insert_row(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int position;
  if ( GetArgs(stack,rhs,opt,T,&position) == FAIL) return RET_BUG;
    gtk_grid_insert_row(GTK_GRID(self->obj),position);
  return 0;
}

#else
int _wrap_gtk_grid_insert_row(Stack stack, int rhs, int opt, int lhs) /* insert_row */
{
  Scierror("Error: function gtk_grid_insert_row not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_grid_insert_column(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int position;
  if ( GetArgs(stack,rhs,opt,T,&position) == FAIL) return RET_BUG;
    gtk_grid_insert_column(GTK_GRID(self->obj),position);
  return 0;
}

#else
int _wrap_gtk_grid_insert_column(Stack stack, int rhs, int opt, int lhs) /* insert_column */
{
  Scierror("Error: function gtk_grid_insert_column not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_grid_remove_row(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int position;
  if ( GetArgs(stack,rhs,opt,T,&position) == FAIL) return RET_BUG;
    gtk_grid_remove_row(GTK_GRID(self->obj),position);
  return 0;
}

#else
int _wrap_gtk_grid_remove_row(Stack stack, int rhs, int opt, int lhs) /* remove_row */
{
  Scierror("Error: function gtk_grid_remove_row not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_grid_remove_column(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int position;
  if ( GetArgs(stack,rhs,opt,T,&position) == FAIL) return RET_BUG;
    gtk_grid_remove_column(GTK_GRID(self->obj),position);
  return 0;
}

#else
int _wrap_gtk_grid_remove_column(Stack stack, int rhs, int opt, int lhs) /* remove_column */
{
  Scierror("Error: function gtk_grid_remove_column not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_grid_insert_next_to(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *sibling;
  GtkPositionType side;
  NspObject *nsp_side = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &sibling, &nsp_side) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_side, &side)== FAIL)
      return RET_BUG;
    gtk_grid_insert_next_to(GTK_GRID(self->obj),GTK_WIDGET(sibling->obj),side);
  return 0;
}

#else
int _wrap_gtk_grid_insert_next_to(Stack stack, int rhs, int opt, int lhs) /* insert_next_to */
{
  Scierror("Error: function gtk_grid_insert_next_to not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_grid_set_row_homogeneous(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int homogeneous;
  if ( GetArgs(stack,rhs,opt,T,&homogeneous) == FAIL) return RET_BUG;
    gtk_grid_set_row_homogeneous(GTK_GRID(self->obj),homogeneous);
  return 0;
}

static int _wrap_gtk_grid_get_row_homogeneous(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_grid_get_row_homogeneous(GTK_GRID(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_grid_set_row_spacing(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int spacing;
  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
    gtk_grid_set_row_spacing(GTK_GRID(self->obj),spacing);
  return 0;
}

static int _wrap_gtk_grid_get_row_spacing(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_grid_get_row_spacing(GTK_GRID(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_grid_set_column_homogeneous(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int homogeneous;
  if ( GetArgs(stack,rhs,opt,T,&homogeneous) == FAIL) return RET_BUG;
    gtk_grid_set_column_homogeneous(GTK_GRID(self->obj),homogeneous);
  return 0;
}

static int _wrap_gtk_grid_get_column_homogeneous(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_grid_get_column_homogeneous(GTK_GRID(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_grid_set_column_spacing(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int spacing;
  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
    gtk_grid_set_column_spacing(GTK_GRID(self->obj),spacing);
  return 0;
}

static int _wrap_gtk_grid_get_column_spacing(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_grid_get_column_spacing(GTK_GRID(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_grid_set_row_baseline_position(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,obj, t_end};
  int row;
  GtkBaselinePosition pos;
  NspObject *nsp_pos = NULL;
  if ( GetArgs(stack,rhs,opt,T,&row, &nsp_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_BASELINE_POSITION, nsp_pos, &pos)== FAIL)
      return RET_BUG;
    gtk_grid_set_row_baseline_position(GTK_GRID(self->obj),row,pos);
  return 0;
}

#else
int _wrap_gtk_grid_set_row_baseline_position(Stack stack, int rhs, int opt, int lhs) /* set_row_baseline_position */
{
  Scierror("Error: function gtk_grid_set_row_baseline_position not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_grid_get_row_baseline_position(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int row;
  gint ret;
  if ( GetArgs(stack,rhs,opt,T,&row) == FAIL) return RET_BUG;
    ret =gtk_grid_get_row_baseline_position(GTK_GRID(self->obj),row);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_grid_get_row_baseline_position(Stack stack, int rhs, int opt, int lhs) /* get_row_baseline_position */
{
  Scierror("Error: function gtk_grid_get_row_baseline_position not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_grid_set_baseline_row(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int row;
  if ( GetArgs(stack,rhs,opt,T,&row) == FAIL) return RET_BUG;
    gtk_grid_set_baseline_row(GTK_GRID(self->obj),row);
  return 0;
}

#else
int _wrap_gtk_grid_set_baseline_row(Stack stack, int rhs, int opt, int lhs) /* set_baseline_row */
{
  Scierror("Error: function gtk_grid_set_baseline_row not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_grid_get_baseline_row(NspGtkGrid *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_grid_get_baseline_row(GTK_GRID(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_grid_get_baseline_row(Stack stack, int rhs, int opt, int lhs) /* get_baseline_row */
{
  Scierror("Error: function gtk_grid_get_baseline_row not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkgrid_methods[] = {
  {"attach",(nsp_method *) _wrap_gtk_grid_attach},
  {"attach_next_to",(nsp_method *) _wrap_gtk_grid_attach_next_to},
  {"get_child_at",(nsp_method *) _wrap_gtk_grid_get_child_at},
  {"insert_row",(nsp_method *) _wrap_gtk_grid_insert_row},
  {"insert_column",(nsp_method *) _wrap_gtk_grid_insert_column},
  {"remove_row",(nsp_method *) _wrap_gtk_grid_remove_row},
  {"remove_column",(nsp_method *) _wrap_gtk_grid_remove_column},
  {"insert_next_to",(nsp_method *) _wrap_gtk_grid_insert_next_to},
  {"set_row_homogeneous",(nsp_method *) _wrap_gtk_grid_set_row_homogeneous},
  {"get_row_homogeneous",(nsp_method *) _wrap_gtk_grid_get_row_homogeneous},
  {"set_row_spacing",(nsp_method *) _wrap_gtk_grid_set_row_spacing},
  {"get_row_spacing",(nsp_method *) _wrap_gtk_grid_get_row_spacing},
  {"set_column_homogeneous",(nsp_method *) _wrap_gtk_grid_set_column_homogeneous},
  {"get_column_homogeneous",(nsp_method *) _wrap_gtk_grid_get_column_homogeneous},
  {"set_column_spacing",(nsp_method *) _wrap_gtk_grid_set_column_spacing},
  {"get_column_spacing",(nsp_method *) _wrap_gtk_grid_get_column_spacing},
  {"set_row_baseline_position",(nsp_method *) _wrap_gtk_grid_set_row_baseline_position},
  {"get_row_baseline_position",(nsp_method *) _wrap_gtk_grid_get_row_baseline_position},
  {"set_baseline_row",(nsp_method *) _wrap_gtk_grid_set_baseline_row},
  {"get_baseline_row",(nsp_method *) _wrap_gtk_grid_get_baseline_row},
  { NULL, NULL}
};

static NspMethods *gtkgrid_get_methods(void) { return gtkgrid_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkgrid_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRevealer ----------- */


#define  NspGtkRevealer_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkrevealer.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRevealer inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkrevealer_id=0;
NspTypeGtkRevealer *nsp_type_gtkrevealer=NULL;

/*
 * Type object for NspGtkRevealer 
 * all the instance of NspTypeGtkRevealer share the same id. 
 * nsp_type_gtkrevealer: is an instance of NspTypeGtkRevealer 
 *    used for objects of NspGtkRevealer type (i.e built with new_gtkrevealer) 
 * other instances are used for derived classes 
 */
NspTypeGtkRevealer *new_type_gtkrevealer(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkRevealer *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkrevealer != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkrevealer;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkrevealer_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkrevealer_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkrevealer;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkrevealer */ 

  top->s_type =  (s_type_func *) nsp_gtkrevealer_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkrevealer_type_short_string;
  /* top->create = (create_func*) int_gtkrevealer_create;*/

  /* specific methods for gtkrevealer */

  type->init = (init_func *) init_gtkrevealer;

  /* 
   * NspGtkRevealer interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkrevealer_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRevealer called nsp_type_gtkrevealer
       */
      type->id =  nsp_type_gtkrevealer_id = nsp_new_type_id();
      nsp_type_gtkrevealer = type;
      if ( nsp_register_type(nsp_type_gtkrevealer) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkrevealer, GTK_TYPE_REVEALER);
      return ( mode == T_BASE ) ? type : new_type_gtkrevealer(mode);
    }
  else 
    {
      type->id = nsp_type_gtkrevealer_id;
      return type;
    }
}

/*
 * initialize NspGtkRevealer instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkrevealer(NspGtkRevealer *Obj,NspTypeGtkRevealer *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRevealer 
 */

NspGtkRevealer *new_gtkrevealer() 
{
  NspGtkRevealer *loc;
  /* type must exists */
  nsp_type_gtkrevealer = new_type_gtkrevealer(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRevealer)))== NULLGTKREVEALER) return loc;
  /* initialize object */
  if ( init_gtkrevealer(loc,nsp_type_gtkrevealer) == FAIL) return NULLGTKREVEALER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRevealer 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkrevealer_type_name[]="GtkRevealer";
static char gtkrevealer_short_type_name[]="GtkRevealer";

static char *nsp_gtkrevealer_type_as_string(void)
{
  return(gtkrevealer_type_name);
}

static char *nsp_gtkrevealer_type_short_string(NspObject *v)
{
  return(gtkrevealer_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRevealer objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRevealer   *nsp_gtkrevealer_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkrevealer_id)  == TRUE  ) return ((NspGtkRevealer *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkrevealer));
  return NULL;
}

int IsGtkRevealerObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkrevealer_id);
}

int IsGtkRevealer(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkrevealer_id);
}

NspGtkRevealer  *GetGtkRevealerCopy(Stack stack, int i)
{
  if (  GetGtkRevealer(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRevealer  *GetGtkRevealer(Stack stack, int i)
{
  NspGtkRevealer *M;
  if (( M = nsp_gtkrevealer_object(NthObj(i))) == NULLGTKREVEALER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRevealer *gtkrevealer_copy(NspGtkRevealer *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrevealer);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrevealer);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRevealer
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_revealer_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_revealer_new())== NULL) return RET_BUG;

  nsp_type_gtkrevealer = new_type_gtkrevealer(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkrevealer);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_revealer_get_reveal_child(NspGtkRevealer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_revealer_get_reveal_child(GTK_REVEALER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_revealer_get_reveal_child(Stack stack, int rhs, int opt, int lhs) /* get_reveal_child */
{
  Scierror("Error: function gtk_revealer_get_reveal_child not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_revealer_set_reveal_child(NspGtkRevealer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int reveal_child;
  if ( GetArgs(stack,rhs,opt,T,&reveal_child) == FAIL) return RET_BUG;
    gtk_revealer_set_reveal_child(GTK_REVEALER(self->obj),reveal_child);
  return 0;
}

#else
int _wrap_gtk_revealer_set_reveal_child(Stack stack, int rhs, int opt, int lhs) /* set_reveal_child */
{
  Scierror("Error: function gtk_revealer_set_reveal_child not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_revealer_get_child_revealed(NspGtkRevealer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_revealer_get_child_revealed(GTK_REVEALER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_revealer_get_child_revealed(Stack stack, int rhs, int opt, int lhs) /* get_child_revealed */
{
  Scierror("Error: function gtk_revealer_get_child_revealed not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_revealer_get_transition_duration(NspGtkRevealer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_revealer_get_transition_duration(GTK_REVEALER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_revealer_get_transition_duration(Stack stack, int rhs, int opt, int lhs) /* get_transition_duration */
{
  Scierror("Error: function gtk_revealer_get_transition_duration not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_revealer_set_transition_duration(NspGtkRevealer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int duration;
  if ( GetArgs(stack,rhs,opt,T,&duration) == FAIL) return RET_BUG;
    gtk_revealer_set_transition_duration(GTK_REVEALER(self->obj),duration);
  return 0;
}

#else
int _wrap_gtk_revealer_set_transition_duration(Stack stack, int rhs, int opt, int lhs) /* set_transition_duration */
{
  Scierror("Error: function gtk_revealer_set_transition_duration not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_revealer_set_transition_type(NspGtkRevealer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkRevealerTransitionType transition;
  NspObject *nsp_transition = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_transition) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_REVEALER_TRANSITION_TYPE, nsp_transition, &transition)== FAIL)
      return RET_BUG;
    gtk_revealer_set_transition_type(GTK_REVEALER(self->obj),transition);
  return 0;
}

#else
int _wrap_gtk_revealer_set_transition_type(Stack stack, int rhs, int opt, int lhs) /* set_transition_type */
{
  Scierror("Error: function gtk_revealer_set_transition_type not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_revealer_get_transition_type(NspGtkRevealer *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_revealer_get_transition_type(GTK_REVEALER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_revealer_get_transition_type(Stack stack, int rhs, int opt, int lhs) /* get_transition_type */
{
  Scierror("Error: function gtk_revealer_get_transition_type not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkrevealer_methods[] = {
  {"get_reveal_child",(nsp_method *) _wrap_gtk_revealer_get_reveal_child},
  {"set_reveal_child",(nsp_method *) _wrap_gtk_revealer_set_reveal_child},
  {"get_child_revealed",(nsp_method *) _wrap_gtk_revealer_get_child_revealed},
  {"get_transition_duration",(nsp_method *) _wrap_gtk_revealer_get_transition_duration},
  {"set_transition_duration",(nsp_method *) _wrap_gtk_revealer_set_transition_duration},
  {"set_transition_type",(nsp_method *) _wrap_gtk_revealer_set_transition_type},
  {"get_transition_type",(nsp_method *) _wrap_gtk_revealer_get_transition_type},
  { NULL, NULL}
};

static NspMethods *gtkrevealer_get_methods(void) { return gtkrevealer_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkrevealer_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkListBox ----------- */


#define  NspGtkListBox_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtklistbox.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkListBox inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtklistbox_id=0;
NspTypeGtkListBox *nsp_type_gtklistbox=NULL;

/*
 * Type object for NspGtkListBox 
 * all the instance of NspTypeGtkListBox share the same id. 
 * nsp_type_gtklistbox: is an instance of NspTypeGtkListBox 
 *    used for objects of NspGtkListBox type (i.e built with new_gtklistbox) 
 * other instances are used for derived classes 
 */
NspTypeGtkListBox *new_type_gtklistbox(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkListBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtklistbox != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtklistbox;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtklistbox_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtklistbox_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtklistbox;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtklistbox */ 

  top->s_type =  (s_type_func *) nsp_gtklistbox_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtklistbox_type_short_string;
  /* top->create = (create_func*) int_gtklistbox_create;*/

  /* specific methods for gtklistbox */

  type->init = (init_func *) init_gtklistbox;

  /* 
   * NspGtkListBox interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtklistbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkListBox called nsp_type_gtklistbox
       */
      type->id =  nsp_type_gtklistbox_id = nsp_new_type_id();
      nsp_type_gtklistbox = type;
      if ( nsp_register_type(nsp_type_gtklistbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtklistbox, GTK_TYPE_LIST_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtklistbox(mode);
    }
  else 
    {
      type->id = nsp_type_gtklistbox_id;
      return type;
    }
}

/*
 * initialize NspGtkListBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtklistbox(NspGtkListBox *Obj,NspTypeGtkListBox *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkListBox 
 */

NspGtkListBox *new_gtklistbox() 
{
  NspGtkListBox *loc;
  /* type must exists */
  nsp_type_gtklistbox = new_type_gtklistbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkListBox)))== NULLGTKLISTBOX) return loc;
  /* initialize object */
  if ( init_gtklistbox(loc,nsp_type_gtklistbox) == FAIL) return NULLGTKLISTBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkListBox 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtklistbox_type_name[]="GtkListBox";
static char gtklistbox_short_type_name[]="GtkListBox";

static char *nsp_gtklistbox_type_as_string(void)
{
  return(gtklistbox_type_name);
}

static char *nsp_gtklistbox_type_short_string(NspObject *v)
{
  return(gtklistbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkListBox objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkListBox   *nsp_gtklistbox_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtklistbox_id)  == TRUE  ) return ((NspGtkListBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtklistbox));
  return NULL;
}

int IsGtkListBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtklistbox_id);
}

int IsGtkListBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtklistbox_id);
}

NspGtkListBox  *GetGtkListBoxCopy(Stack stack, int i)
{
  if (  GetGtkListBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkListBox  *GetGtkListBox(Stack stack, int i)
{
  NspGtkListBox *M;
  if (( M = nsp_gtklistbox_object(NthObj(i))) == NULLGTKLISTBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkListBox *gtklistbox_copy(NspGtkListBox *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklistbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklistbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkListBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_list_box_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_list_box_new())== NULL) return RET_BUG;

  nsp_type_gtklistbox = new_type_gtklistbox(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtklistbox);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_prepend(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_list_box_prepend(GTK_LIST_BOX(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

#else
int _wrap_gtk_list_box_prepend(Stack stack, int rhs, int opt, int lhs) /* prepend */
{
  Scierror("Error: function gtk_list_box_prepend not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_insert(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *child;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &position) == FAIL) return RET_BUG;
    gtk_list_box_insert(GTK_LIST_BOX(self->obj),GTK_WIDGET(child->obj),position);
  return 0;
}

#else
int _wrap_gtk_list_box_insert(Stack stack, int rhs, int opt, int lhs) /* insert */
{
  Scierror("Error: function gtk_list_box_insert not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_set_placeholder(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *placeholder;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &placeholder) == FAIL) return RET_BUG;
    gtk_list_box_set_placeholder(GTK_LIST_BOX(self->obj),GTK_WIDGET(placeholder->obj));
  return 0;
}

#else
int _wrap_gtk_list_box_set_placeholder(Stack stack, int rhs, int opt, int lhs) /* set_placeholder */
{
  Scierror("Error: function gtk_list_box_set_placeholder not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_set_adjustment(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *adjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
    gtk_list_box_set_adjustment(GTK_LIST_BOX(self->obj),GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

#else
int _wrap_gtk_list_box_set_adjustment(Stack stack, int rhs, int opt, int lhs) /* set_adjustment */
{
  Scierror("Error: function gtk_list_box_set_adjustment not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_get_adjustment(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAdjustment *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_list_box_get_adjustment(GTK_LIST_BOX(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_list_box_get_adjustment(Stack stack, int rhs, int opt, int lhs) /* get_adjustment */
{
  Scierror("Error: function gtk_list_box_get_adjustment not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_list_box_get_selected_rows(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_list_box_get_selected_rows(GTK_LIST_BOX(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

#else
int _wrap_gtk_list_box_get_selected_rows(Stack stack, int rhs, int opt, int lhs) /* get_selected_rows */
{
  Scierror("Error: function gtk_list_box_get_selected_rows not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_list_box_select_all(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_list_box_select_all(GTK_LIST_BOX(self->obj));
  return 0;
}

#else
int _wrap_gtk_list_box_select_all(Stack stack, int rhs, int opt, int lhs) /* select_all */
{
  Scierror("Error: function gtk_list_box_select_all not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_list_box_unselect_all(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_list_box_unselect_all(GTK_LIST_BOX(self->obj));
  return 0;
}

#else
int _wrap_gtk_list_box_unselect_all(Stack stack, int rhs, int opt, int lhs) /* unselect_all */
{
  Scierror("Error: function gtk_list_box_unselect_all not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_set_selection_mode(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSelectionMode mode;
  NspObject *nsp_mode = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SELECTION_MODE, nsp_mode, &mode)== FAIL)
      return RET_BUG;
    gtk_list_box_set_selection_mode(GTK_LIST_BOX(self->obj),mode);
  return 0;
}

#else
int _wrap_gtk_list_box_set_selection_mode(Stack stack, int rhs, int opt, int lhs) /* set_selection_mode */
{
  Scierror("Error: function gtk_list_box_set_selection_mode not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_get_selection_mode(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_list_box_get_selection_mode(GTK_LIST_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_list_box_get_selection_mode(Stack stack, int rhs, int opt, int lhs) /* get_selection_mode */
{
  Scierror("Error: function gtk_list_box_get_selection_mode not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_invalidate_filter(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_list_box_invalidate_filter(GTK_LIST_BOX(self->obj));
  return 0;
}

#else
int _wrap_gtk_list_box_invalidate_filter(Stack stack, int rhs, int opt, int lhs) /* invalidate_filter */
{
  Scierror("Error: function gtk_list_box_invalidate_filter not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_invalidate_sort(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_list_box_invalidate_sort(GTK_LIST_BOX(self->obj));
  return 0;
}

#else
int _wrap_gtk_list_box_invalidate_sort(Stack stack, int rhs, int opt, int lhs) /* invalidate_sort */
{
  Scierror("Error: function gtk_list_box_invalidate_sort not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_invalidate_headers(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_list_box_invalidate_headers(GTK_LIST_BOX(self->obj));
  return 0;
}

#else
int _wrap_gtk_list_box_invalidate_headers(Stack stack, int rhs, int opt, int lhs) /* invalidate_headers */
{
  Scierror("Error: function gtk_list_box_invalidate_headers not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_set_activate_on_single_click(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int single;
  if ( GetArgs(stack,rhs,opt,T,&single) == FAIL) return RET_BUG;
    gtk_list_box_set_activate_on_single_click(GTK_LIST_BOX(self->obj),single);
  return 0;
}

#else
int _wrap_gtk_list_box_set_activate_on_single_click(Stack stack, int rhs, int opt, int lhs) /* set_activate_on_single_click */
{
  Scierror("Error: function gtk_list_box_set_activate_on_single_click not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_get_activate_on_single_click(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_list_box_get_activate_on_single_click(GTK_LIST_BOX(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_list_box_get_activate_on_single_click(Stack stack, int rhs, int opt, int lhs) /* get_activate_on_single_click */
{
  Scierror("Error: function gtk_list_box_get_activate_on_single_click not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_list_box_drag_unhighlight_row(NspGtkListBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_list_box_drag_unhighlight_row(GTK_LIST_BOX(self->obj));
  return 0;
}

#else
int _wrap_gtk_list_box_drag_unhighlight_row(Stack stack, int rhs, int opt, int lhs) /* drag_unhighlight_row */
{
  Scierror("Error: function gtk_list_box_drag_unhighlight_row not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtklistbox_methods[] = {
  {"prepend",(nsp_method *) _wrap_gtk_list_box_prepend},
  {"insert",(nsp_method *) _wrap_gtk_list_box_insert},
  {"set_placeholder",(nsp_method *) _wrap_gtk_list_box_set_placeholder},
  {"set_adjustment",(nsp_method *) _wrap_gtk_list_box_set_adjustment},
  {"get_adjustment",(nsp_method *) _wrap_gtk_list_box_get_adjustment},
  {"get_selected_rows",(nsp_method *) _wrap_gtk_list_box_get_selected_rows},
  {"select_all",(nsp_method *) _wrap_gtk_list_box_select_all},
  {"unselect_all",(nsp_method *) _wrap_gtk_list_box_unselect_all},
  {"set_selection_mode",(nsp_method *) _wrap_gtk_list_box_set_selection_mode},
  {"get_selection_mode",(nsp_method *) _wrap_gtk_list_box_get_selection_mode},
  {"invalidate_filter",(nsp_method *) _wrap_gtk_list_box_invalidate_filter},
  {"invalidate_sort",(nsp_method *) _wrap_gtk_list_box_invalidate_sort},
  {"invalidate_headers",(nsp_method *) _wrap_gtk_list_box_invalidate_headers},
  {"set_activate_on_single_click",(nsp_method *) _wrap_gtk_list_box_set_activate_on_single_click},
  {"get_activate_on_single_click",(nsp_method *) _wrap_gtk_list_box_get_activate_on_single_click},
  {"drag_unhighlight_row",(nsp_method *) _wrap_gtk_list_box_drag_unhighlight_row},
  { NULL, NULL}
};

static NspMethods *gtklistbox_get_methods(void) { return gtklistbox_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtklistbox_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;

#if GTK_CHECK_VERSION(3,12,0) 

/* -----------NspGtkFlowBox ----------- */


#define  NspGtkFlowBox_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkflowbox.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFlowBox inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtkflowbox_id=0;
NspTypeGtkFlowBox *nsp_type_gtkflowbox=NULL;

/*
 * Type object for NspGtkFlowBox 
 * all the instance of NspTypeGtkFlowBox share the same id. 
 * nsp_type_gtkflowbox: is an instance of NspTypeGtkFlowBox 
 *    used for objects of NspGtkFlowBox type (i.e built with new_gtkflowbox) 
 * other instances are used for derived classes 
 */
NspTypeGtkFlowBox *new_type_gtkflowbox(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkFlowBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkflowbox != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkflowbox;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkflowbox_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkflowbox_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkflowbox;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkflowbox */ 

  top->s_type =  (s_type_func *) nsp_gtkflowbox_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkflowbox_type_short_string;
  /* top->create = (create_func*) int_gtkflowbox_create;*/

  /* specific methods for gtkflowbox */

  type->init = (init_func *) init_gtkflowbox;

  /* 
   * NspGtkFlowBox interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkflowbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFlowBox called nsp_type_gtkflowbox
       */
      type->id =  nsp_type_gtkflowbox_id = nsp_new_type_id();
      nsp_type_gtkflowbox = type;
      if ( nsp_register_type(nsp_type_gtkflowbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkflowbox, GTK_TYPE_FLOW_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkflowbox(mode);
    }
  else 
    {
      type->id = nsp_type_gtkflowbox_id;
      return type;
    }
}

/*
 * initialize NspGtkFlowBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkflowbox(NspGtkFlowBox *Obj,NspTypeGtkFlowBox *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFlowBox 
 */

NspGtkFlowBox *new_gtkflowbox() 
{
  NspGtkFlowBox *loc;
  /* type must exists */
  nsp_type_gtkflowbox = new_type_gtkflowbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFlowBox)))== NULLGTKFLOWBOX) return loc;
  /* initialize object */
  if ( init_gtkflowbox(loc,nsp_type_gtkflowbox) == FAIL) return NULLGTKFLOWBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFlowBox 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkflowbox_type_name[]="GtkFlowBox";
static char gtkflowbox_short_type_name[]="GtkFlowBox";

static char *nsp_gtkflowbox_type_as_string(void)
{
  return(gtkflowbox_type_name);
}

static char *nsp_gtkflowbox_type_short_string(NspObject *v)
{
  return(gtkflowbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFlowBox objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFlowBox   *nsp_gtkflowbox_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkflowbox_id)  == TRUE  ) return ((NspGtkFlowBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkflowbox));
  return NULL;
}

int IsGtkFlowBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkflowbox_id);
}

int IsGtkFlowBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkflowbox_id);
}

NspGtkFlowBox  *GetGtkFlowBoxCopy(Stack stack, int i)
{
  if (  GetGtkFlowBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFlowBox  *GetGtkFlowBox(Stack stack, int i)
{
  NspGtkFlowBox *M;
  if (( M = nsp_gtkflowbox_object(NthObj(i))) == NULLGTKFLOWBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFlowBox *gtkflowbox_copy(NspGtkFlowBox *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkflowbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkflowbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFlowBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
#endif /* GTK_CHECK_VERSION */
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,12,0)
static int
_wrap_gtk_flow_box_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_flow_box_new())== NULL) return RET_BUG;

  nsp_type_gtkflowbox = new_type_gtkflowbox(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkflowbox);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_flow_box_new(Stack stack, int rhs, int opt, int lhs) /* gtk_flow_box_new */
{
  Scierror("Error: function gtk_flow_box_new not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0) 
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_set_homogeneous(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int homogeneous;
  if ( GetArgs(stack,rhs,opt,T,&homogeneous) == FAIL) return RET_BUG;
    gtk_flow_box_set_homogeneous(GTK_FLOW_BOX(self->obj),homogeneous);
  return 0;
}

#else
int _wrap_gtk_flow_box_set_homogeneous(Stack stack, int rhs, int opt, int lhs) /* set_homogeneous */
{
  Scierror("Error: function gtk_flow_box_set_homogeneous not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_get_homogeneous(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_flow_box_get_homogeneous(GTK_FLOW_BOX(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_flow_box_get_homogeneous(Stack stack, int rhs, int opt, int lhs) /* get_homogeneous */
{
  Scierror("Error: function gtk_flow_box_get_homogeneous not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_set_row_spacing(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int spacing;
  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
    gtk_flow_box_set_row_spacing(GTK_FLOW_BOX(self->obj),spacing);
  return 0;
}

#else
int _wrap_gtk_flow_box_set_row_spacing(Stack stack, int rhs, int opt, int lhs) /* set_row_spacing */
{
  Scierror("Error: function gtk_flow_box_set_row_spacing not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_get_row_spacing(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_flow_box_get_row_spacing(GTK_FLOW_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_flow_box_get_row_spacing(Stack stack, int rhs, int opt, int lhs) /* get_row_spacing */
{
  Scierror("Error: function gtk_flow_box_get_row_spacing not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_set_column_spacing(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int spacing;
  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
    gtk_flow_box_set_column_spacing(GTK_FLOW_BOX(self->obj),spacing);
  return 0;
}

#else
int _wrap_gtk_flow_box_set_column_spacing(Stack stack, int rhs, int opt, int lhs) /* set_column_spacing */
{
  Scierror("Error: function gtk_flow_box_set_column_spacing not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_get_column_spacing(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_flow_box_get_column_spacing(GTK_FLOW_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_flow_box_get_column_spacing(Stack stack, int rhs, int opt, int lhs) /* get_column_spacing */
{
  Scierror("Error: function gtk_flow_box_get_column_spacing not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_set_min_children_per_line(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int n_children;
  if ( GetArgs(stack,rhs,opt,T,&n_children) == FAIL) return RET_BUG;
    gtk_flow_box_set_min_children_per_line(GTK_FLOW_BOX(self->obj),n_children);
  return 0;
}

#else
int _wrap_gtk_flow_box_set_min_children_per_line(Stack stack, int rhs, int opt, int lhs) /* set_min_children_per_line */
{
  Scierror("Error: function gtk_flow_box_set_min_children_per_line not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_get_min_children_per_line(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_flow_box_get_min_children_per_line(GTK_FLOW_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_flow_box_get_min_children_per_line(Stack stack, int rhs, int opt, int lhs) /* get_min_children_per_line */
{
  Scierror("Error: function gtk_flow_box_get_min_children_per_line not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_set_max_children_per_line(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int n_children;
  if ( GetArgs(stack,rhs,opt,T,&n_children) == FAIL) return RET_BUG;
    gtk_flow_box_set_max_children_per_line(GTK_FLOW_BOX(self->obj),n_children);
  return 0;
}

#else
int _wrap_gtk_flow_box_set_max_children_per_line(Stack stack, int rhs, int opt, int lhs) /* set_max_children_per_line */
{
  Scierror("Error: function gtk_flow_box_set_max_children_per_line not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_get_max_children_per_line(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_flow_box_get_max_children_per_line(GTK_FLOW_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_flow_box_get_max_children_per_line(Stack stack, int rhs, int opt, int lhs) /* get_max_children_per_line */
{
  Scierror("Error: function gtk_flow_box_get_max_children_per_line not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_set_activate_on_single_click(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int single;
  if ( GetArgs(stack,rhs,opt,T,&single) == FAIL) return RET_BUG;
    gtk_flow_box_set_activate_on_single_click(GTK_FLOW_BOX(self->obj),single);
  return 0;
}

#else
int _wrap_gtk_flow_box_set_activate_on_single_click(Stack stack, int rhs, int opt, int lhs) /* set_activate_on_single_click */
{
  Scierror("Error: function gtk_flow_box_set_activate_on_single_click not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_get_activate_on_single_click(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_flow_box_get_activate_on_single_click(GTK_FLOW_BOX(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_flow_box_get_activate_on_single_click(Stack stack, int rhs, int opt, int lhs) /* get_activate_on_single_click */
{
  Scierror("Error: function gtk_flow_box_get_activate_on_single_click not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_insert(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *widget;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &position) == FAIL) return RET_BUG;
    gtk_flow_box_insert(GTK_FLOW_BOX(self->obj),GTK_WIDGET(widget->obj),position);
  return 0;
}

#else
int _wrap_gtk_flow_box_insert(Stack stack, int rhs, int opt, int lhs) /* insert */
{
  Scierror("Error: function gtk_flow_box_insert not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_get_selected_children(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_flow_box_get_selected_children(GTK_FLOW_BOX(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

#else
int _wrap_gtk_flow_box_get_selected_children(Stack stack, int rhs, int opt, int lhs) /* get_selected_children */
{
  Scierror("Error: function gtk_flow_box_get_selected_children not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_select_all(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_flow_box_select_all(GTK_FLOW_BOX(self->obj));
  return 0;
}

#else
int _wrap_gtk_flow_box_select_all(Stack stack, int rhs, int opt, int lhs) /* select_all */
{
  Scierror("Error: function gtk_flow_box_select_all not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_unselect_all(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_flow_box_unselect_all(GTK_FLOW_BOX(self->obj));
  return 0;
}

#else
int _wrap_gtk_flow_box_unselect_all(Stack stack, int rhs, int opt, int lhs) /* unselect_all */
{
  Scierror("Error: function gtk_flow_box_unselect_all not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_set_selection_mode(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSelectionMode mode;
  NspObject *nsp_mode = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SELECTION_MODE, nsp_mode, &mode)== FAIL)
      return RET_BUG;
    gtk_flow_box_set_selection_mode(GTK_FLOW_BOX(self->obj),mode);
  return 0;
}

#else
int _wrap_gtk_flow_box_set_selection_mode(Stack stack, int rhs, int opt, int lhs) /* set_selection_mode */
{
  Scierror("Error: function gtk_flow_box_set_selection_mode not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_get_selection_mode(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_flow_box_get_selection_mode(GTK_FLOW_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_flow_box_get_selection_mode(Stack stack, int rhs, int opt, int lhs) /* get_selection_mode */
{
  Scierror("Error: function gtk_flow_box_get_selection_mode not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_set_hadjustment(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *adjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
    gtk_flow_box_set_hadjustment(GTK_FLOW_BOX(self->obj),GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

#else
int _wrap_gtk_flow_box_set_hadjustment(Stack stack, int rhs, int opt, int lhs) /* set_hadjustment */
{
  Scierror("Error: function gtk_flow_box_set_hadjustment not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_set_vadjustment(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *adjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
    gtk_flow_box_set_vadjustment(GTK_FLOW_BOX(self->obj),GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

#else
int _wrap_gtk_flow_box_set_vadjustment(Stack stack, int rhs, int opt, int lhs) /* set_vadjustment */
{
  Scierror("Error: function gtk_flow_box_set_vadjustment not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_invalidate_filter(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_flow_box_invalidate_filter(GTK_FLOW_BOX(self->obj));
  return 0;
}

#else
int _wrap_gtk_flow_box_invalidate_filter(Stack stack, int rhs, int opt, int lhs) /* invalidate_filter */
{
  Scierror("Error: function gtk_flow_box_invalidate_filter not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_flow_box_invalidate_sort(NspGtkFlowBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_flow_box_invalidate_sort(GTK_FLOW_BOX(self->obj));
  return 0;
}

#else
int _wrap_gtk_flow_box_invalidate_sort(Stack stack, int rhs, int opt, int lhs) /* invalidate_sort */
{
  Scierror("Error: function gtk_flow_box_invalidate_sort not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkflowbox_methods[] = {
  {"set_homogeneous",(nsp_method *) _wrap_gtk_flow_box_set_homogeneous},
  {"get_homogeneous",(nsp_method *) _wrap_gtk_flow_box_get_homogeneous},
  {"set_row_spacing",(nsp_method *) _wrap_gtk_flow_box_set_row_spacing},
  {"get_row_spacing",(nsp_method *) _wrap_gtk_flow_box_get_row_spacing},
  {"set_column_spacing",(nsp_method *) _wrap_gtk_flow_box_set_column_spacing},
  {"get_column_spacing",(nsp_method *) _wrap_gtk_flow_box_get_column_spacing},
  {"set_min_children_per_line",(nsp_method *) _wrap_gtk_flow_box_set_min_children_per_line},
  {"get_min_children_per_line",(nsp_method *) _wrap_gtk_flow_box_get_min_children_per_line},
  {"set_max_children_per_line",(nsp_method *) _wrap_gtk_flow_box_set_max_children_per_line},
  {"get_max_children_per_line",(nsp_method *) _wrap_gtk_flow_box_get_max_children_per_line},
  {"set_activate_on_single_click",(nsp_method *) _wrap_gtk_flow_box_set_activate_on_single_click},
  {"get_activate_on_single_click",(nsp_method *) _wrap_gtk_flow_box_get_activate_on_single_click},
  {"insert",(nsp_method *) _wrap_gtk_flow_box_insert},
  {"get_selected_children",(nsp_method *) _wrap_gtk_flow_box_get_selected_children},
  {"select_all",(nsp_method *) _wrap_gtk_flow_box_select_all},
  {"unselect_all",(nsp_method *) _wrap_gtk_flow_box_unselect_all},
  {"set_selection_mode",(nsp_method *) _wrap_gtk_flow_box_set_selection_mode},
  {"get_selection_mode",(nsp_method *) _wrap_gtk_flow_box_get_selection_mode},
  {"set_hadjustment",(nsp_method *) _wrap_gtk_flow_box_set_hadjustment},
  {"set_vadjustment",(nsp_method *) _wrap_gtk_flow_box_set_vadjustment},
  {"invalidate_filter",(nsp_method *) _wrap_gtk_flow_box_invalidate_filter},
  {"invalidate_sort",(nsp_method *) _wrap_gtk_flow_box_invalidate_sort},
  { NULL, NULL}
};

static NspMethods *gtkflowbox_get_methods(void) { return gtkflowbox_methods;};
#endif /* GTK_CHECK_VERSION */
#if GTK_CHECK_VERSION(3,12,0) 
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkflowbox_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;
#endif /* GTK_CHECK_VERSION */


/* -----------NspGtkStack ----------- */


#define  NspGtkStack_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkstack.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkStack inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtkstack_id=0;
NspTypeGtkStack *nsp_type_gtkstack=NULL;

/*
 * Type object for NspGtkStack 
 * all the instance of NspTypeGtkStack share the same id. 
 * nsp_type_gtkstack: is an instance of NspTypeGtkStack 
 *    used for objects of NspGtkStack type (i.e built with new_gtkstack) 
 * other instances are used for derived classes 
 */
NspTypeGtkStack *new_type_gtkstack(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkStack *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkstack != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkstack;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkstack_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkstack_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkstack;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkstack */ 

  top->s_type =  (s_type_func *) nsp_gtkstack_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkstack_type_short_string;
  /* top->create = (create_func*) int_gtkstack_create;*/

  /* specific methods for gtkstack */

  type->init = (init_func *) init_gtkstack;

  /* 
   * NspGtkStack interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkstack_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkStack called nsp_type_gtkstack
       */
      type->id =  nsp_type_gtkstack_id = nsp_new_type_id();
      nsp_type_gtkstack = type;
      if ( nsp_register_type(nsp_type_gtkstack) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkstack, GTK_TYPE_STACK);
      return ( mode == T_BASE ) ? type : new_type_gtkstack(mode);
    }
  else 
    {
      type->id = nsp_type_gtkstack_id;
      return type;
    }
}

/*
 * initialize NspGtkStack instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkstack(NspGtkStack *Obj,NspTypeGtkStack *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkStack 
 */

NspGtkStack *new_gtkstack() 
{
  NspGtkStack *loc;
  /* type must exists */
  nsp_type_gtkstack = new_type_gtkstack(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkStack)))== NULLGTKSTACK) return loc;
  /* initialize object */
  if ( init_gtkstack(loc,nsp_type_gtkstack) == FAIL) return NULLGTKSTACK;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkStack 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkstack_type_name[]="GtkStack";
static char gtkstack_short_type_name[]="GtkStack";

static char *nsp_gtkstack_type_as_string(void)
{
  return(gtkstack_type_name);
}

static char *nsp_gtkstack_type_short_string(NspObject *v)
{
  return(gtkstack_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkStack objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkStack   *nsp_gtkstack_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkstack_id)  == TRUE  ) return ((NspGtkStack *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkstack));
  return NULL;
}

int IsGtkStackObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkstack_id);
}

int IsGtkStack(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkstack_id);
}

NspGtkStack  *GetGtkStackCopy(Stack stack, int i)
{
  if (  GetGtkStack(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkStack  *GetGtkStack(Stack stack, int i)
{
  NspGtkStack *M;
  if (( M = nsp_gtkstack_object(NthObj(i))) == NULLGTKSTACK)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkStack *gtkstack_copy(NspGtkStack *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstack);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstack);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkStack
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_stack_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_stack_new())== NULL) return RET_BUG;

  nsp_type_gtkstack = new_type_gtkstack(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstack);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_add_named(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *child;
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &name) == FAIL) return RET_BUG;
    gtk_stack_add_named(GTK_STACK(self->obj),GTK_WIDGET(child->obj),name);
  return 0;
}

#else
int _wrap_gtk_stack_add_named(Stack stack, int rhs, int opt, int lhs) /* add_named */
{
  Scierror("Error: function gtk_stack_add_named not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_add_titled(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string,string, t_end};
  NspGObject *child;
  char *name, *title;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &name, &title) == FAIL) return RET_BUG;
    gtk_stack_add_titled(GTK_STACK(self->obj),GTK_WIDGET(child->obj),name,title);
  return 0;
}

#else
int _wrap_gtk_stack_add_titled(Stack stack, int rhs, int opt, int lhs) /* add_titled */
{
  Scierror("Error: function gtk_stack_add_titled not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_stack_get_child_by_name(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    ret =gtk_stack_get_child_by_name(GTK_STACK(self->obj),name);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_stack_get_child_by_name(Stack stack, int rhs, int opt, int lhs) /* get_child_by_name */
{
  Scierror("Error: function gtk_stack_get_child_by_name not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_set_visible_child(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_stack_set_visible_child(GTK_STACK(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

#else
int _wrap_gtk_stack_set_visible_child(Stack stack, int rhs, int opt, int lhs) /* set_visible_child */
{
  Scierror("Error: function gtk_stack_set_visible_child not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_get_visible_child(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_stack_get_visible_child(GTK_STACK(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_stack_get_visible_child(Stack stack, int rhs, int opt, int lhs) /* get_visible_child */
{
  Scierror("Error: function gtk_stack_get_visible_child not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_set_visible_child_name(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_stack_set_visible_child_name(GTK_STACK(self->obj),name);
  return 0;
}

#else
int _wrap_gtk_stack_set_visible_child_name(Stack stack, int rhs, int opt, int lhs) /* set_visible_child_name */
{
  Scierror("Error: function gtk_stack_set_visible_child_name not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_get_visible_child_name(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_stack_get_visible_child_name(GTK_STACK(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_stack_get_visible_child_name(Stack stack, int rhs, int opt, int lhs) /* get_visible_child_name */
{
  Scierror("Error: function gtk_stack_get_visible_child_name not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_set_visible_child_full(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *name;
  GtkStackTransitionType transition;
  NspObject *nsp_transition = NULL;
  if ( GetArgs(stack,rhs,opt,T,&name, &nsp_transition) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STACK_TRANSITION_TYPE, nsp_transition, &transition)== FAIL)
      return RET_BUG;
    gtk_stack_set_visible_child_full(GTK_STACK(self->obj),name,transition);
  return 0;
}

#else
int _wrap_gtk_stack_set_visible_child_full(Stack stack, int rhs, int opt, int lhs) /* set_visible_child_full */
{
  Scierror("Error: function gtk_stack_set_visible_child_full not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_set_homogeneous(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int homogeneous;
  if ( GetArgs(stack,rhs,opt,T,&homogeneous) == FAIL) return RET_BUG;
    gtk_stack_set_homogeneous(GTK_STACK(self->obj),homogeneous);
  return 0;
}

#else
int _wrap_gtk_stack_set_homogeneous(Stack stack, int rhs, int opt, int lhs) /* set_homogeneous */
{
  Scierror("Error: function gtk_stack_set_homogeneous not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_get_homogeneous(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_stack_get_homogeneous(GTK_STACK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_stack_get_homogeneous(Stack stack, int rhs, int opt, int lhs) /* get_homogeneous */
{
  Scierror("Error: function gtk_stack_get_homogeneous not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_stack_set_hhomogeneous(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int hhomogeneous;
  if ( GetArgs(stack,rhs,opt,T,&hhomogeneous) == FAIL) return RET_BUG;
    gtk_stack_set_hhomogeneous(GTK_STACK(self->obj),hhomogeneous);
  return 0;
}

#else
int _wrap_gtk_stack_set_hhomogeneous(Stack stack, int rhs, int opt, int lhs) /* set_hhomogeneous */
{
  Scierror("Error: function gtk_stack_set_hhomogeneous not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_stack_get_hhomogeneous(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_stack_get_hhomogeneous(GTK_STACK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_stack_get_hhomogeneous(Stack stack, int rhs, int opt, int lhs) /* get_hhomogeneous */
{
  Scierror("Error: function gtk_stack_get_hhomogeneous not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_stack_set_vhomogeneous(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int vhomogeneous;
  if ( GetArgs(stack,rhs,opt,T,&vhomogeneous) == FAIL) return RET_BUG;
    gtk_stack_set_vhomogeneous(GTK_STACK(self->obj),vhomogeneous);
  return 0;
}

#else
int _wrap_gtk_stack_set_vhomogeneous(Stack stack, int rhs, int opt, int lhs) /* set_vhomogeneous */
{
  Scierror("Error: function gtk_stack_set_vhomogeneous not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_stack_get_vhomogeneous(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_stack_get_vhomogeneous(GTK_STACK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_stack_get_vhomogeneous(Stack stack, int rhs, int opt, int lhs) /* get_vhomogeneous */
{
  Scierror("Error: function gtk_stack_get_vhomogeneous not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_set_transition_duration(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int duration;
  if ( GetArgs(stack,rhs,opt,T,&duration) == FAIL) return RET_BUG;
    gtk_stack_set_transition_duration(GTK_STACK(self->obj),duration);
  return 0;
}

#else
int _wrap_gtk_stack_set_transition_duration(Stack stack, int rhs, int opt, int lhs) /* set_transition_duration */
{
  Scierror("Error: function gtk_stack_set_transition_duration not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_get_transition_duration(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_stack_get_transition_duration(GTK_STACK(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_stack_get_transition_duration(Stack stack, int rhs, int opt, int lhs) /* get_transition_duration */
{
  Scierror("Error: function gtk_stack_get_transition_duration not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_set_transition_type(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkStackTransitionType transition;
  NspObject *nsp_transition = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_transition) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STACK_TRANSITION_TYPE, nsp_transition, &transition)== FAIL)
      return RET_BUG;
    gtk_stack_set_transition_type(GTK_STACK(self->obj),transition);
  return 0;
}

#else
int _wrap_gtk_stack_set_transition_type(Stack stack, int rhs, int opt, int lhs) /* set_transition_type */
{
  Scierror("Error: function gtk_stack_set_transition_type not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_get_transition_type(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_stack_get_transition_type(GTK_STACK(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_stack_get_transition_type(Stack stack, int rhs, int opt, int lhs) /* get_transition_type */
{
  Scierror("Error: function gtk_stack_get_transition_type not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_stack_get_transition_running(NspGtkStack *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_stack_get_transition_running(GTK_STACK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_stack_get_transition_running(Stack stack, int rhs, int opt, int lhs) /* get_transition_running */
{
  Scierror("Error: function gtk_stack_get_transition_running not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkstack_methods[] = {
  {"add_named",(nsp_method *) _wrap_gtk_stack_add_named},
  {"add_titled",(nsp_method *) _wrap_gtk_stack_add_titled},
  {"get_child_by_name",(nsp_method *) _wrap_gtk_stack_get_child_by_name},
  {"set_visible_child",(nsp_method *) _wrap_gtk_stack_set_visible_child},
  {"get_visible_child",(nsp_method *) _wrap_gtk_stack_get_visible_child},
  {"set_visible_child_name",(nsp_method *) _wrap_gtk_stack_set_visible_child_name},
  {"get_visible_child_name",(nsp_method *) _wrap_gtk_stack_get_visible_child_name},
  {"set_visible_child_full",(nsp_method *) _wrap_gtk_stack_set_visible_child_full},
  {"set_homogeneous",(nsp_method *) _wrap_gtk_stack_set_homogeneous},
  {"get_homogeneous",(nsp_method *) _wrap_gtk_stack_get_homogeneous},
  {"set_hhomogeneous",(nsp_method *) _wrap_gtk_stack_set_hhomogeneous},
  {"get_hhomogeneous",(nsp_method *) _wrap_gtk_stack_get_hhomogeneous},
  {"set_vhomogeneous",(nsp_method *) _wrap_gtk_stack_set_vhomogeneous},
  {"get_vhomogeneous",(nsp_method *) _wrap_gtk_stack_get_vhomogeneous},
  {"set_transition_duration",(nsp_method *) _wrap_gtk_stack_set_transition_duration},
  {"get_transition_duration",(nsp_method *) _wrap_gtk_stack_get_transition_duration},
  {"set_transition_type",(nsp_method *) _wrap_gtk_stack_set_transition_type},
  {"get_transition_type",(nsp_method *) _wrap_gtk_stack_get_transition_type},
  {"get_transition_running",(nsp_method *) _wrap_gtk_stack_get_transition_running},
  { NULL, NULL}
};

static NspMethods *gtkstack_get_methods(void) { return gtkstack_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkstack_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkStackSwitcher ----------- */


#define  NspGtkStackSwitcher_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkstackswitcher.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkStackSwitcher inherits from GtkBox 
 * and implements GtkBuildable
 */

int nsp_type_gtkstackswitcher_id=0;
NspTypeGtkStackSwitcher *nsp_type_gtkstackswitcher=NULL;

/*
 * Type object for NspGtkStackSwitcher 
 * all the instance of NspTypeGtkStackSwitcher share the same id. 
 * nsp_type_gtkstackswitcher: is an instance of NspTypeGtkStackSwitcher 
 *    used for objects of NspGtkStackSwitcher type (i.e built with new_gtkstackswitcher) 
 * other instances are used for derived classes 
 */
NspTypeGtkStackSwitcher *new_type_gtkstackswitcher(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkStackSwitcher *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkstackswitcher != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkstackswitcher;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkstackswitcher_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkstackswitcher_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkstackswitcher;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkstackswitcher */ 

  top->s_type =  (s_type_func *) nsp_gtkstackswitcher_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkstackswitcher_type_short_string;
  /* top->create = (create_func*) int_gtkstackswitcher_create;*/

  /* specific methods for gtkstackswitcher */

  type->init = (init_func *) init_gtkstackswitcher;

  /* 
   * NspGtkStackSwitcher interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkstackswitcher_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkStackSwitcher called nsp_type_gtkstackswitcher
       */
      type->id =  nsp_type_gtkstackswitcher_id = nsp_new_type_id();
      nsp_type_gtkstackswitcher = type;
      if ( nsp_register_type(nsp_type_gtkstackswitcher) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkstackswitcher, GTK_TYPE_STACK_SWITCHER);
      return ( mode == T_BASE ) ? type : new_type_gtkstackswitcher(mode);
    }
  else 
    {
      type->id = nsp_type_gtkstackswitcher_id;
      return type;
    }
}

/*
 * initialize NspGtkStackSwitcher instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkstackswitcher(NspGtkStackSwitcher *Obj,NspTypeGtkStackSwitcher *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkStackSwitcher 
 */

NspGtkStackSwitcher *new_gtkstackswitcher() 
{
  NspGtkStackSwitcher *loc;
  /* type must exists */
  nsp_type_gtkstackswitcher = new_type_gtkstackswitcher(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkStackSwitcher)))== NULLGTKSTACKSWITCHER) return loc;
  /* initialize object */
  if ( init_gtkstackswitcher(loc,nsp_type_gtkstackswitcher) == FAIL) return NULLGTKSTACKSWITCHER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkStackSwitcher 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkstackswitcher_type_name[]="GtkStackSwitcher";
static char gtkstackswitcher_short_type_name[]="GtkStackSwitcher";

static char *nsp_gtkstackswitcher_type_as_string(void)
{
  return(gtkstackswitcher_type_name);
}

static char *nsp_gtkstackswitcher_type_short_string(NspObject *v)
{
  return(gtkstackswitcher_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkStackSwitcher objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkStackSwitcher   *nsp_gtkstackswitcher_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkstackswitcher_id)  == TRUE  ) return ((NspGtkStackSwitcher *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkstackswitcher));
  return NULL;
}

int IsGtkStackSwitcherObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkstackswitcher_id);
}

int IsGtkStackSwitcher(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkstackswitcher_id);
}

NspGtkStackSwitcher  *GetGtkStackSwitcherCopy(Stack stack, int i)
{
  if (  GetGtkStackSwitcher(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkStackSwitcher  *GetGtkStackSwitcher(Stack stack, int i)
{
  NspGtkStackSwitcher *M;
  if (( M = nsp_gtkstackswitcher_object(NthObj(i))) == NULLGTKSTACKSWITCHER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkStackSwitcher *gtkstackswitcher_copy(NspGtkStackSwitcher *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstackswitcher);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstackswitcher);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkStackSwitcher
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_stack_switcher_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_stack_switcher_new())== NULL) return RET_BUG;

  nsp_type_gtkstackswitcher = new_type_gtkstackswitcher(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstackswitcher);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_switcher_set_stack(NspGtkStackSwitcher *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *g_stack;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstack, &g_stack) == FAIL) return RET_BUG;
    gtk_stack_switcher_set_stack(GTK_STACK_SWITCHER(self->obj),GTK_STACK(g_stack->obj));
  return 0;
}

#else
int _wrap_gtk_stack_switcher_set_stack(Stack stack, int rhs, int opt, int lhs) /* set_stack */
{
  Scierror("Error: function gtk_stack_switcher_set_stack not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_stack_switcher_get_stack(NspGtkStackSwitcher *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkStack *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_stack_switcher_get_stack(GTK_STACK_SWITCHER(self->obj));
  nsp_type_gtkstack = new_type_gtkstack(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstack))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_stack_switcher_get_stack(Stack stack, int rhs, int opt, int lhs) /* get_stack */
{
  Scierror("Error: function gtk_stack_switcher_get_stack not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkstackswitcher_methods[] = {
  {"set_stack",(nsp_method *) _wrap_gtk_stack_switcher_set_stack},
  {"get_stack",(nsp_method *) _wrap_gtk_stack_switcher_get_stack},
  { NULL, NULL}
};

static NspMethods *gtkstackswitcher_get_methods(void) { return gtkstackswitcher_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkstackswitcher_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;

#if GTK_CHECK_VERSION(3,16,0) 

/* -----------NspGtkStackSidebar ----------- */


#define  NspGtkStackSidebar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkstacksidebar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkStackSidebar inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkstacksidebar_id=0;
NspTypeGtkStackSidebar *nsp_type_gtkstacksidebar=NULL;

/*
 * Type object for NspGtkStackSidebar 
 * all the instance of NspTypeGtkStackSidebar share the same id. 
 * nsp_type_gtkstacksidebar: is an instance of NspTypeGtkStackSidebar 
 *    used for objects of NspGtkStackSidebar type (i.e built with new_gtkstacksidebar) 
 * other instances are used for derived classes 
 */
NspTypeGtkStackSidebar *new_type_gtkstacksidebar(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkStackSidebar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkstacksidebar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkstacksidebar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkstacksidebar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkstacksidebar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkstacksidebar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkstacksidebar */ 

  top->s_type =  (s_type_func *) nsp_gtkstacksidebar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkstacksidebar_type_short_string;
  /* top->create = (create_func*) int_gtkstacksidebar_create;*/

  /* specific methods for gtkstacksidebar */

  type->init = (init_func *) init_gtkstacksidebar;

  /* 
   * NspGtkStackSidebar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkstacksidebar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkStackSidebar called nsp_type_gtkstacksidebar
       */
      type->id =  nsp_type_gtkstacksidebar_id = nsp_new_type_id();
      nsp_type_gtkstacksidebar = type;
      if ( nsp_register_type(nsp_type_gtkstacksidebar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkstacksidebar, GTK_TYPE_STACK_SIDEBAR);
      return ( mode == T_BASE ) ? type : new_type_gtkstacksidebar(mode);
    }
  else 
    {
      type->id = nsp_type_gtkstacksidebar_id;
      return type;
    }
}

/*
 * initialize NspGtkStackSidebar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkstacksidebar(NspGtkStackSidebar *Obj,NspTypeGtkStackSidebar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkStackSidebar 
 */

NspGtkStackSidebar *new_gtkstacksidebar() 
{
  NspGtkStackSidebar *loc;
  /* type must exists */
  nsp_type_gtkstacksidebar = new_type_gtkstacksidebar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkStackSidebar)))== NULLGTKSTACKSIDEBAR) return loc;
  /* initialize object */
  if ( init_gtkstacksidebar(loc,nsp_type_gtkstacksidebar) == FAIL) return NULLGTKSTACKSIDEBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkStackSidebar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkstacksidebar_type_name[]="GtkStackSidebar";
static char gtkstacksidebar_short_type_name[]="GtkStackSidebar";

static char *nsp_gtkstacksidebar_type_as_string(void)
{
  return(gtkstacksidebar_type_name);
}

static char *nsp_gtkstacksidebar_type_short_string(NspObject *v)
{
  return(gtkstacksidebar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkStackSidebar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkStackSidebar   *nsp_gtkstacksidebar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkstacksidebar_id)  == TRUE  ) return ((NspGtkStackSidebar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkstacksidebar));
  return NULL;
}

int IsGtkStackSidebarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkstacksidebar_id);
}

int IsGtkStackSidebar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkstacksidebar_id);
}

NspGtkStackSidebar  *GetGtkStackSidebarCopy(Stack stack, int i)
{
  if (  GetGtkStackSidebar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkStackSidebar  *GetGtkStackSidebar(Stack stack, int i)
{
  NspGtkStackSidebar *M;
  if (( M = nsp_gtkstacksidebar_object(NthObj(i))) == NULLGTKSTACKSIDEBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkStackSidebar *gtkstacksidebar_copy(NspGtkStackSidebar *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstacksidebar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstacksidebar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkStackSidebar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
#endif /* GTK_CHECK_VERSION */
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,16,0)
static int
_wrap_gtk_stack_sidebar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_stack_sidebar_new())== NULL) return RET_BUG;

  nsp_type_gtkstacksidebar = new_type_gtkstacksidebar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstacksidebar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_stack_sidebar_new(Stack stack, int rhs, int opt, int lhs) /* gtk_stack_sidebar_new */
{
  Scierror("Error: function gtk_stack_sidebar_new not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0) 
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_stack_sidebar_set_stack(NspGtkStackSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *g_stack;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstack, &g_stack) == FAIL) return RET_BUG;
    gtk_stack_sidebar_set_stack(GTK_STACK_SIDEBAR(self->obj),GTK_STACK(g_stack->obj));
  return 0;
}

#else
int _wrap_gtk_stack_sidebar_set_stack(Stack stack, int rhs, int opt, int lhs) /* set_stack */
{
  Scierror("Error: function gtk_stack_sidebar_set_stack not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_stack_sidebar_get_stack(NspGtkStackSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkStack *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_stack_sidebar_get_stack(GTK_STACK_SIDEBAR(self->obj));
  nsp_type_gtkstack = new_type_gtkstack(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstack))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_stack_sidebar_get_stack(Stack stack, int rhs, int opt, int lhs) /* get_stack */
{
  Scierror("Error: function gtk_stack_sidebar_get_stack not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkstacksidebar_methods[] = {
  {"set_stack",(nsp_method *) _wrap_gtk_stack_sidebar_set_stack},
  {"get_stack",(nsp_method *) _wrap_gtk_stack_sidebar_get_stack},
  { NULL, NULL}
};

static NspMethods *gtkstacksidebar_get_methods(void) { return gtkstacksidebar_methods;};
#endif /* GTK_CHECK_VERSION */
#if GTK_CHECK_VERSION(3,16,0) 
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkstacksidebar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;
#endif /* GTK_CHECK_VERSION */

#if GTK_CHECK_VERSION(3,12,0) 

/* -----------NspGtkActionBar ----------- */


#define  NspGtkActionBar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkactionbar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkActionBar inherits from GtkBin 
 */

int nsp_type_gtkactionbar_id=0;
NspTypeGtkActionBar *nsp_type_gtkactionbar=NULL;

/*
 * Type object for NspGtkActionBar 
 * all the instance of NspTypeGtkActionBar share the same id. 
 * nsp_type_gtkactionbar: is an instance of NspTypeGtkActionBar 
 *    used for objects of NspGtkActionBar type (i.e built with new_gtkactionbar) 
 * other instances are used for derived classes 
 */
NspTypeGtkActionBar *new_type_gtkactionbar(type_mode mode)
{
  NspTypeGtkActionBar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkactionbar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkactionbar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkactionbar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkactionbar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkactionbar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkactionbar */ 

  top->s_type =  (s_type_func *) nsp_gtkactionbar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkactionbar_type_short_string;
  /* top->create = (create_func*) int_gtkactionbar_create;*/

  /* specific methods for gtkactionbar */

  type->init = (init_func *) init_gtkactionbar;

  /* 
   * NspGtkActionBar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkactionbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkActionBar called nsp_type_gtkactionbar
       */
      type->id =  nsp_type_gtkactionbar_id = nsp_new_type_id();
      nsp_type_gtkactionbar = type;
      if ( nsp_register_type(nsp_type_gtkactionbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkactionbar, GTK_TYPE_ACTION_BAR);
      return ( mode == T_BASE ) ? type : new_type_gtkactionbar(mode);
    }
  else 
    {
      type->id = nsp_type_gtkactionbar_id;
      return type;
    }
}

/*
 * initialize NspGtkActionBar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkactionbar(NspGtkActionBar *Obj,NspTypeGtkActionBar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkActionBar 
 */

NspGtkActionBar *new_gtkactionbar() 
{
  NspGtkActionBar *loc;
  /* type must exists */
  nsp_type_gtkactionbar = new_type_gtkactionbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkActionBar)))== NULLGTKACTIONBAR) return loc;
  /* initialize object */
  if ( init_gtkactionbar(loc,nsp_type_gtkactionbar) == FAIL) return NULLGTKACTIONBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkActionBar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkactionbar_type_name[]="GtkActionBar";
static char gtkactionbar_short_type_name[]="GtkActionBar";

static char *nsp_gtkactionbar_type_as_string(void)
{
  return(gtkactionbar_type_name);
}

static char *nsp_gtkactionbar_type_short_string(NspObject *v)
{
  return(gtkactionbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkActionBar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkActionBar   *nsp_gtkactionbar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkactionbar_id)  == TRUE  ) return ((NspGtkActionBar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkactionbar));
  return NULL;
}

int IsGtkActionBarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkactionbar_id);
}

int IsGtkActionBar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkactionbar_id);
}

NspGtkActionBar  *GetGtkActionBarCopy(Stack stack, int i)
{
  if (  GetGtkActionBar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkActionBar  *GetGtkActionBar(Stack stack, int i)
{
  NspGtkActionBar *M;
  if (( M = nsp_gtkactionbar_object(NthObj(i))) == NULLGTKACTIONBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkActionBar *gtkactionbar_copy(NspGtkActionBar *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkactionbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkactionbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkActionBar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
#endif /* GTK_CHECK_VERSION */
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,12,0)
static int
_wrap_gtk_action_bar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_action_bar_new())== NULL) return RET_BUG;

  nsp_type_gtkactionbar = new_type_gtkactionbar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkactionbar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_action_bar_new(Stack stack, int rhs, int opt, int lhs) /* gtk_action_bar_new */
{
  Scierror("Error: function gtk_action_bar_new not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0) 
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_action_bar_get_center_widget(NspGtkActionBar *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_action_bar_get_center_widget(GTK_ACTION_BAR(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_action_bar_get_center_widget(Stack stack, int rhs, int opt, int lhs) /* get_center_widget */
{
  Scierror("Error: function gtk_action_bar_get_center_widget not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_action_bar_set_center_widget(NspGtkActionBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *center_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &center_widget) == FAIL) return RET_BUG;
    gtk_action_bar_set_center_widget(GTK_ACTION_BAR(self->obj),GTK_WIDGET(center_widget->obj));
  return 0;
}

#else
int _wrap_gtk_action_bar_set_center_widget(Stack stack, int rhs, int opt, int lhs) /* set_center_widget */
{
  Scierror("Error: function gtk_action_bar_set_center_widget not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_action_bar_pack_start(NspGtkActionBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_action_bar_pack_start(GTK_ACTION_BAR(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

#else
int _wrap_gtk_action_bar_pack_start(Stack stack, int rhs, int opt, int lhs) /* pack_start */
{
  Scierror("Error: function gtk_action_bar_pack_start not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_action_bar_pack_end(NspGtkActionBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_action_bar_pack_end(GTK_ACTION_BAR(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

#else
int _wrap_gtk_action_bar_pack_end(Stack stack, int rhs, int opt, int lhs) /* pack_end */
{
  Scierror("Error: function gtk_action_bar_pack_end not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkactionbar_methods[] = {
  {"get_center_widget",(nsp_method *) _wrap_gtk_action_bar_get_center_widget},
  {"set_center_widget",(nsp_method *) _wrap_gtk_action_bar_set_center_widget},
  {"pack_start",(nsp_method *) _wrap_gtk_action_bar_pack_start},
  {"pack_end",(nsp_method *) _wrap_gtk_action_bar_pack_end},
  { NULL, NULL}
};

static NspMethods *gtkactionbar_get_methods(void) { return gtkactionbar_methods;};
#endif /* GTK_CHECK_VERSION */
#if GTK_CHECK_VERSION(3,12,0) 
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkactionbar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;
#endif /* GTK_CHECK_VERSION */


/* -----------NspGtkHeaderBar ----------- */


#define  NspGtkHeaderBar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkheaderbar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkHeaderBar inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtkheaderbar_id=0;
NspTypeGtkHeaderBar *nsp_type_gtkheaderbar=NULL;

/*
 * Type object for NspGtkHeaderBar 
 * all the instance of NspTypeGtkHeaderBar share the same id. 
 * nsp_type_gtkheaderbar: is an instance of NspTypeGtkHeaderBar 
 *    used for objects of NspGtkHeaderBar type (i.e built with new_gtkheaderbar) 
 * other instances are used for derived classes 
 */
NspTypeGtkHeaderBar *new_type_gtkheaderbar(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkHeaderBar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkheaderbar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkheaderbar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkheaderbar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkheaderbar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkheaderbar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkheaderbar */ 

  top->s_type =  (s_type_func *) nsp_gtkheaderbar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkheaderbar_type_short_string;
  /* top->create = (create_func*) int_gtkheaderbar_create;*/

  /* specific methods for gtkheaderbar */

  type->init = (init_func *) init_gtkheaderbar;

  /* 
   * NspGtkHeaderBar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkheaderbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkHeaderBar called nsp_type_gtkheaderbar
       */
      type->id =  nsp_type_gtkheaderbar_id = nsp_new_type_id();
      nsp_type_gtkheaderbar = type;
      if ( nsp_register_type(nsp_type_gtkheaderbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkheaderbar, GTK_TYPE_HEADER_BAR);
      return ( mode == T_BASE ) ? type : new_type_gtkheaderbar(mode);
    }
  else 
    {
      type->id = nsp_type_gtkheaderbar_id;
      return type;
    }
}

/*
 * initialize NspGtkHeaderBar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkheaderbar(NspGtkHeaderBar *Obj,NspTypeGtkHeaderBar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkHeaderBar 
 */

NspGtkHeaderBar *new_gtkheaderbar() 
{
  NspGtkHeaderBar *loc;
  /* type must exists */
  nsp_type_gtkheaderbar = new_type_gtkheaderbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkHeaderBar)))== NULLGTKHEADERBAR) return loc;
  /* initialize object */
  if ( init_gtkheaderbar(loc,nsp_type_gtkheaderbar) == FAIL) return NULLGTKHEADERBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkHeaderBar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkheaderbar_type_name[]="GtkHeaderBar";
static char gtkheaderbar_short_type_name[]="GtkHeaderBar";

static char *nsp_gtkheaderbar_type_as_string(void)
{
  return(gtkheaderbar_type_name);
}

static char *nsp_gtkheaderbar_type_short_string(NspObject *v)
{
  return(gtkheaderbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkHeaderBar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkHeaderBar   *nsp_gtkheaderbar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkheaderbar_id)  == TRUE  ) return ((NspGtkHeaderBar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkheaderbar));
  return NULL;
}

int IsGtkHeaderBarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkheaderbar_id);
}

int IsGtkHeaderBar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkheaderbar_id);
}

NspGtkHeaderBar  *GetGtkHeaderBarCopy(Stack stack, int i)
{
  if (  GetGtkHeaderBar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkHeaderBar  *GetGtkHeaderBar(Stack stack, int i)
{
  NspGtkHeaderBar *M;
  if (( M = nsp_gtkheaderbar_object(NthObj(i))) == NULLGTKHEADERBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkHeaderBar *gtkheaderbar_copy(NspGtkHeaderBar *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkheaderbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkheaderbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkHeaderBar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_header_bar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_header_bar_new())== NULL) return RET_BUG;

  nsp_type_gtkheaderbar = new_type_gtkheaderbar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkheaderbar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_header_bar_set_title(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *title;
  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
    gtk_header_bar_set_title(GTK_HEADER_BAR(self->obj),title);
  return 0;
}

#else
int _wrap_gtk_header_bar_set_title(Stack stack, int rhs, int opt, int lhs) /* set_title */
{
  Scierror("Error: function gtk_header_bar_set_title not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_header_bar_get_title(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_header_bar_get_title(GTK_HEADER_BAR(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_header_bar_get_title(Stack stack, int rhs, int opt, int lhs) /* get_title */
{
  Scierror("Error: function gtk_header_bar_get_title not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_header_bar_set_subtitle(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *subtitle;
  if ( GetArgs(stack,rhs,opt,T,&subtitle) == FAIL) return RET_BUG;
    gtk_header_bar_set_subtitle(GTK_HEADER_BAR(self->obj),subtitle);
  return 0;
}

#else
int _wrap_gtk_header_bar_set_subtitle(Stack stack, int rhs, int opt, int lhs) /* set_subtitle */
{
  Scierror("Error: function gtk_header_bar_set_subtitle not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_header_bar_get_subtitle(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_header_bar_get_subtitle(GTK_HEADER_BAR(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_header_bar_get_subtitle(Stack stack, int rhs, int opt, int lhs) /* get_subtitle */
{
  Scierror("Error: function gtk_header_bar_get_subtitle not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_header_bar_set_custom_title(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *title_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &title_widget) == FAIL) return RET_BUG;
    gtk_header_bar_set_custom_title(GTK_HEADER_BAR(self->obj),GTK_WIDGET(title_widget->obj));
  return 0;
}

#else
int _wrap_gtk_header_bar_set_custom_title(Stack stack, int rhs, int opt, int lhs) /* set_custom_title */
{
  Scierror("Error: function gtk_header_bar_set_custom_title not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_header_bar_get_custom_title(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_header_bar_get_custom_title(GTK_HEADER_BAR(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_header_bar_get_custom_title(Stack stack, int rhs, int opt, int lhs) /* get_custom_title */
{
  Scierror("Error: function gtk_header_bar_get_custom_title not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_header_bar_pack_start(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_header_bar_pack_start(GTK_HEADER_BAR(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

#else
int _wrap_gtk_header_bar_pack_start(Stack stack, int rhs, int opt, int lhs) /* pack_start */
{
  Scierror("Error: function gtk_header_bar_pack_start not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_header_bar_pack_end(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_header_bar_pack_end(GTK_HEADER_BAR(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

#else
int _wrap_gtk_header_bar_pack_end(Stack stack, int rhs, int opt, int lhs) /* pack_end */
{
  Scierror("Error: function gtk_header_bar_pack_end not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_header_bar_get_show_close_button(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_header_bar_get_show_close_button(GTK_HEADER_BAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_header_bar_get_show_close_button(Stack stack, int rhs, int opt, int lhs) /* get_show_close_button */
{
  Scierror("Error: function gtk_header_bar_get_show_close_button not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_header_bar_set_show_close_button(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_header_bar_set_show_close_button(GTK_HEADER_BAR(self->obj),setting);
  return 0;
}

#else
int _wrap_gtk_header_bar_set_show_close_button(Stack stack, int rhs, int opt, int lhs) /* set_show_close_button */
{
  Scierror("Error: function gtk_header_bar_set_show_close_button not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_header_bar_set_has_subtitle(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_header_bar_set_has_subtitle(GTK_HEADER_BAR(self->obj),setting);
  return 0;
}

#else
int _wrap_gtk_header_bar_set_has_subtitle(Stack stack, int rhs, int opt, int lhs) /* set_has_subtitle */
{
  Scierror("Error: function gtk_header_bar_set_has_subtitle not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_header_bar_get_has_subtitle(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_header_bar_get_has_subtitle(GTK_HEADER_BAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_header_bar_get_has_subtitle(Stack stack, int rhs, int opt, int lhs) /* get_has_subtitle */
{
  Scierror("Error: function gtk_header_bar_get_has_subtitle not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_header_bar_set_decoration_layout(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *layout;
  if ( GetArgs(stack,rhs,opt,T,&layout) == FAIL) return RET_BUG;
    gtk_header_bar_set_decoration_layout(GTK_HEADER_BAR(self->obj),layout);
  return 0;
}

#else
int _wrap_gtk_header_bar_set_decoration_layout(Stack stack, int rhs, int opt, int lhs) /* set_decoration_layout */
{
  Scierror("Error: function gtk_header_bar_set_decoration_layout not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_header_bar_get_decoration_layout(NspGtkHeaderBar *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_header_bar_get_decoration_layout(GTK_HEADER_BAR(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_header_bar_get_decoration_layout(Stack stack, int rhs, int opt, int lhs) /* get_decoration_layout */
{
  Scierror("Error: function gtk_header_bar_get_decoration_layout not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkheaderbar_methods[] = {
  {"set_title",(nsp_method *) _wrap_gtk_header_bar_set_title},
  {"get_title",(nsp_method *) _wrap_gtk_header_bar_get_title},
  {"set_subtitle",(nsp_method *) _wrap_gtk_header_bar_set_subtitle},
  {"get_subtitle",(nsp_method *) _wrap_gtk_header_bar_get_subtitle},
  {"set_custom_title",(nsp_method *) _wrap_gtk_header_bar_set_custom_title},
  {"get_custom_title",(nsp_method *) _wrap_gtk_header_bar_get_custom_title},
  {"pack_start",(nsp_method *) _wrap_gtk_header_bar_pack_start},
  {"pack_end",(nsp_method *) _wrap_gtk_header_bar_pack_end},
  {"get_show_close_button",(nsp_method *) _wrap_gtk_header_bar_get_show_close_button},
  {"set_show_close_button",(nsp_method *) _wrap_gtk_header_bar_set_show_close_button},
  {"set_has_subtitle",(nsp_method *) _wrap_gtk_header_bar_set_has_subtitle},
  {"get_has_subtitle",(nsp_method *) _wrap_gtk_header_bar_get_has_subtitle},
  {"set_decoration_layout",(nsp_method *) _wrap_gtk_header_bar_set_decoration_layout},
  {"get_decoration_layout",(nsp_method *) _wrap_gtk_header_bar_get_decoration_layout},
  { NULL, NULL}
};

static NspMethods *gtkheaderbar_get_methods(void) { return gtkheaderbar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkheaderbar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkOverlay ----------- */


#define  NspGtkOverlay_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkoverlay.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkOverlay inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkoverlay_id=0;
NspTypeGtkOverlay *nsp_type_gtkoverlay=NULL;

/*
 * Type object for NspGtkOverlay 
 * all the instance of NspTypeGtkOverlay share the same id. 
 * nsp_type_gtkoverlay: is an instance of NspTypeGtkOverlay 
 *    used for objects of NspGtkOverlay type (i.e built with new_gtkoverlay) 
 * other instances are used for derived classes 
 */
NspTypeGtkOverlay *new_type_gtkoverlay(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkOverlay *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkoverlay != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkoverlay;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkoverlay_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkoverlay_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkoverlay;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkoverlay */ 

  top->s_type =  (s_type_func *) nsp_gtkoverlay_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkoverlay_type_short_string;
  /* top->create = (create_func*) int_gtkoverlay_create;*/

  /* specific methods for gtkoverlay */

  type->init = (init_func *) init_gtkoverlay;

  /* 
   * NspGtkOverlay interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkoverlay_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkOverlay called nsp_type_gtkoverlay
       */
      type->id =  nsp_type_gtkoverlay_id = nsp_new_type_id();
      nsp_type_gtkoverlay = type;
      if ( nsp_register_type(nsp_type_gtkoverlay) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkoverlay, GTK_TYPE_OVERLAY);
      return ( mode == T_BASE ) ? type : new_type_gtkoverlay(mode);
    }
  else 
    {
      type->id = nsp_type_gtkoverlay_id;
      return type;
    }
}

/*
 * initialize NspGtkOverlay instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkoverlay(NspGtkOverlay *Obj,NspTypeGtkOverlay *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkOverlay 
 */

NspGtkOverlay *new_gtkoverlay() 
{
  NspGtkOverlay *loc;
  /* type must exists */
  nsp_type_gtkoverlay = new_type_gtkoverlay(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkOverlay)))== NULLGTKOVERLAY) return loc;
  /* initialize object */
  if ( init_gtkoverlay(loc,nsp_type_gtkoverlay) == FAIL) return NULLGTKOVERLAY;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkOverlay 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkoverlay_type_name[]="GtkOverlay";
static char gtkoverlay_short_type_name[]="GtkOverlay";

static char *nsp_gtkoverlay_type_as_string(void)
{
  return(gtkoverlay_type_name);
}

static char *nsp_gtkoverlay_type_short_string(NspObject *v)
{
  return(gtkoverlay_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkOverlay objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkOverlay   *nsp_gtkoverlay_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkoverlay_id)  == TRUE  ) return ((NspGtkOverlay *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkoverlay));
  return NULL;
}

int IsGtkOverlayObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkoverlay_id);
}

int IsGtkOverlay(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkoverlay_id);
}

NspGtkOverlay  *GetGtkOverlayCopy(Stack stack, int i)
{
  if (  GetGtkOverlay(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkOverlay  *GetGtkOverlay(Stack stack, int i)
{
  NspGtkOverlay *M;
  if (( M = nsp_gtkoverlay_object(NthObj(i))) == NULLGTKOVERLAY)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkOverlay *gtkoverlay_copy(NspGtkOverlay *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkoverlay);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkoverlay);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkOverlay
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_overlay_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_overlay_new())== NULL) return RET_BUG;

  nsp_type_gtkoverlay = new_type_gtkoverlay(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkoverlay);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_overlay_add_overlay(NspGtkOverlay *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_overlay_add_overlay(GTK_OVERLAY(self->obj),GTK_WIDGET(widget->obj));
  return 0;
}

#else
int _wrap_gtk_overlay_add_overlay(Stack stack, int rhs, int opt, int lhs) /* add_overlay */
{
  Scierror("Error: function gtk_overlay_add_overlay not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,18,0)
static int _wrap_gtk_overlay_reorder_overlay(NspGtkOverlay *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *child;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &position) == FAIL) return RET_BUG;
    gtk_overlay_reorder_overlay(GTK_OVERLAY(self->obj),GTK_WIDGET(child->obj),position);
  return 0;
}

#else
int _wrap_gtk_overlay_reorder_overlay(Stack stack, int rhs, int opt, int lhs) /* reorder_overlay */
{
  Scierror("Error: function gtk_overlay_reorder_overlay not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,18,0)
static int _wrap_gtk_overlay_get_overlay_pass_through(NspGtkOverlay *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    ret =gtk_overlay_get_overlay_pass_through(GTK_OVERLAY(self->obj),GTK_WIDGET(widget->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_overlay_get_overlay_pass_through(Stack stack, int rhs, int opt, int lhs) /* get_overlay_pass_through */
{
  Scierror("Error: function gtk_overlay_get_overlay_pass_through not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,18,0)
static int _wrap_gtk_overlay_set_overlay_pass_through(NspGtkOverlay *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *widget;
  int pass_through;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &pass_through) == FAIL) return RET_BUG;
    gtk_overlay_set_overlay_pass_through(GTK_OVERLAY(self->obj),GTK_WIDGET(widget->obj),pass_through);
  return 0;
}

#else
int _wrap_gtk_overlay_set_overlay_pass_through(Stack stack, int rhs, int opt, int lhs) /* set_overlay_pass_through */
{
  Scierror("Error: function gtk_overlay_set_overlay_pass_through not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkoverlay_methods[] = {
  {"add_overlay",(nsp_method *) _wrap_gtk_overlay_add_overlay},
  {"reorder_overlay",(nsp_method *) _wrap_gtk_overlay_reorder_overlay},
  {"get_overlay_pass_through",(nsp_method *) _wrap_gtk_overlay_get_overlay_pass_through},
  {"set_overlay_pass_through",(nsp_method *) _wrap_gtk_overlay_set_overlay_pass_through},
  { NULL, NULL}
};

static NspMethods *gtkoverlay_get_methods(void) { return gtkoverlay_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkoverlay_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkButtonBox ----------- */


#define  NspGtkButtonBox_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkbuttonbox.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkButtonBox inherits from GtkBox 
 * and implements GtkBuildable
 */

int nsp_type_gtkbuttonbox_id=0;
NspTypeGtkButtonBox *nsp_type_gtkbuttonbox=NULL;

/*
 * Type object for NspGtkButtonBox 
 * all the instance of NspTypeGtkButtonBox share the same id. 
 * nsp_type_gtkbuttonbox: is an instance of NspTypeGtkButtonBox 
 *    used for objects of NspGtkButtonBox type (i.e built with new_gtkbuttonbox) 
 * other instances are used for derived classes 
 */
NspTypeGtkButtonBox *new_type_gtkbuttonbox(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkButtonBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkbuttonbox != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkbuttonbox;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkbuttonbox_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkbuttonbox_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkbuttonbox;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkbuttonbox */ 

  top->s_type =  (s_type_func *) nsp_gtkbuttonbox_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkbuttonbox_type_short_string;
  /* top->create = (create_func*) int_gtkbuttonbox_create;*/

  /* specific methods for gtkbuttonbox */

  type->init = (init_func *) init_gtkbuttonbox;

  /* 
   * NspGtkButtonBox interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkbuttonbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkButtonBox called nsp_type_gtkbuttonbox
       */
      type->id =  nsp_type_gtkbuttonbox_id = nsp_new_type_id();
      nsp_type_gtkbuttonbox = type;
      if ( nsp_register_type(nsp_type_gtkbuttonbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkbuttonbox, GTK_TYPE_BUTTON_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkbuttonbox(mode);
    }
  else 
    {
      type->id = nsp_type_gtkbuttonbox_id;
      return type;
    }
}

/*
 * initialize NspGtkButtonBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkbuttonbox(NspGtkButtonBox *Obj,NspTypeGtkButtonBox *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkButtonBox 
 */

NspGtkButtonBox *new_gtkbuttonbox() 
{
  NspGtkButtonBox *loc;
  /* type must exists */
  nsp_type_gtkbuttonbox = new_type_gtkbuttonbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkButtonBox)))== NULLGTKBUTTONBOX) return loc;
  /* initialize object */
  if ( init_gtkbuttonbox(loc,nsp_type_gtkbuttonbox) == FAIL) return NULLGTKBUTTONBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkButtonBox 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkbuttonbox_type_name[]="GtkButtonBox";
static char gtkbuttonbox_short_type_name[]="GtkButtonBox";

static char *nsp_gtkbuttonbox_type_as_string(void)
{
  return(gtkbuttonbox_type_name);
}

static char *nsp_gtkbuttonbox_type_short_string(NspObject *v)
{
  return(gtkbuttonbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkButtonBox objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkButtonBox   *nsp_gtkbuttonbox_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkbuttonbox_id)  == TRUE  ) return ((NspGtkButtonBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkbuttonbox));
  return NULL;
}

int IsGtkButtonBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkbuttonbox_id);
}

int IsGtkButtonBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkbuttonbox_id);
}

NspGtkButtonBox  *GetGtkButtonBoxCopy(Stack stack, int i)
{
  if (  GetGtkButtonBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkButtonBox  *GetGtkButtonBox(Stack stack, int i)
{
  NspGtkButtonBox *M;
  if (( M = nsp_gtkbuttonbox_object(NthObj(i))) == NULLGTKBUTTONBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkButtonBox *gtkbuttonbox_copy(NspGtkButtonBox *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbuttonbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbuttonbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkButtonBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_button_box_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj, t_end};
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_button_box_new(orientation))== NULL) return RET_BUG;

  nsp_type_gtkbuttonbox = new_type_gtkbuttonbox(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbuttonbox);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_button_box_get_layout(NspGtkButtonBox *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_button_box_get_layout(GTK_BUTTON_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_button_box_set_layout(NspGtkButtonBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkButtonBoxStyle layout_style;
  NspObject *nsp_layout_style = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_layout_style) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_BUTTON_BOX_STYLE, nsp_layout_style, &layout_style)== FAIL)
      return RET_BUG;
    gtk_button_box_set_layout(GTK_BUTTON_BOX(self->obj),layout_style);
  return 0;
}

static int _wrap_gtk_button_box_get_child_secondary(NspGtkButtonBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    ret =gtk_button_box_get_child_secondary(GTK_BUTTON_BOX(self->obj),GTK_WIDGET(child->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_button_box_set_child_secondary(NspGtkButtonBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *child;
  int is_secondary;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &is_secondary) == FAIL) return RET_BUG;
    gtk_button_box_set_child_secondary(GTK_BUTTON_BOX(self->obj),GTK_WIDGET(child->obj),is_secondary);
  return 0;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_button_box_get_child_non_homogeneous(NspGtkButtonBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    ret =gtk_button_box_get_child_non_homogeneous(GTK_BUTTON_BOX(self->obj),GTK_WIDGET(child->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_button_box_get_child_non_homogeneous(Stack stack, int rhs, int opt, int lhs) /* get_child_non_homogeneous */
{
  Scierror("Error: function gtk_button_box_get_child_non_homogeneous not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_button_box_set_child_non_homogeneous(NspGtkButtonBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *child;
  int non_homogeneous;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &non_homogeneous) == FAIL) return RET_BUG;
    gtk_button_box_set_child_non_homogeneous(GTK_BUTTON_BOX(self->obj),GTK_WIDGET(child->obj),non_homogeneous);
  return 0;
}

#else
int _wrap_gtk_button_box_set_child_non_homogeneous(Stack stack, int rhs, int opt, int lhs) /* set_child_non_homogeneous */
{
  Scierror("Error: function gtk_button_box_set_child_non_homogeneous not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkbuttonbox_methods[] = {
  {"get_layout",(nsp_method *) _wrap_gtk_button_box_get_layout},
  {"set_layout",(nsp_method *) _wrap_gtk_button_box_set_layout},
  {"get_child_secondary",(nsp_method *) _wrap_gtk_button_box_get_child_secondary},
  {"set_child_secondary",(nsp_method *) _wrap_gtk_button_box_set_child_secondary},
  {"get_child_non_homogeneous",(nsp_method *) _wrap_gtk_button_box_get_child_non_homogeneous},
  {"set_child_non_homogeneous",(nsp_method *) _wrap_gtk_button_box_set_child_non_homogeneous},
  { NULL, NULL}
};

static NspMethods *gtkbuttonbox_get_methods(void) { return gtkbuttonbox_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkbuttonbox_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkPaned ----------- */


#define  NspGtkPaned_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkpaned.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkPaned inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtkpaned_id=0;
NspTypeGtkPaned *nsp_type_gtkpaned=NULL;

/*
 * Type object for NspGtkPaned 
 * all the instance of NspTypeGtkPaned share the same id. 
 * nsp_type_gtkpaned: is an instance of NspTypeGtkPaned 
 *    used for objects of NspGtkPaned type (i.e built with new_gtkpaned) 
 * other instances are used for derived classes 
 */
NspTypeGtkPaned *new_type_gtkpaned(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkPaned *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkpaned != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkpaned;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkpaned_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkpaned_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkpaned;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkpaned */ 

  top->s_type =  (s_type_func *) nsp_gtkpaned_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkpaned_type_short_string;
  /* top->create = (create_func*) int_gtkpaned_create;*/

  /* specific methods for gtkpaned */

  type->init = (init_func *) init_gtkpaned;

  /* 
   * NspGtkPaned interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkpaned_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkPaned called nsp_type_gtkpaned
       */
      type->id =  nsp_type_gtkpaned_id = nsp_new_type_id();
      nsp_type_gtkpaned = type;
      if ( nsp_register_type(nsp_type_gtkpaned) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkpaned, GTK_TYPE_PANED);
      return ( mode == T_BASE ) ? type : new_type_gtkpaned(mode);
    }
  else 
    {
      type->id = nsp_type_gtkpaned_id;
      return type;
    }
}

/*
 * initialize NspGtkPaned instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkpaned(NspGtkPaned *Obj,NspTypeGtkPaned *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkPaned 
 */

NspGtkPaned *new_gtkpaned() 
{
  NspGtkPaned *loc;
  /* type must exists */
  nsp_type_gtkpaned = new_type_gtkpaned(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkPaned)))== NULLGTKPANED) return loc;
  /* initialize object */
  if ( init_gtkpaned(loc,nsp_type_gtkpaned) == FAIL) return NULLGTKPANED;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkPaned 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkpaned_type_name[]="GtkPaned";
static char gtkpaned_short_type_name[]="GtkPaned";

static char *nsp_gtkpaned_type_as_string(void)
{
  return(gtkpaned_type_name);
}

static char *nsp_gtkpaned_type_short_string(NspObject *v)
{
  return(gtkpaned_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkPaned objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkPaned   *nsp_gtkpaned_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkpaned_id)  == TRUE  ) return ((NspGtkPaned *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkpaned));
  return NULL;
}

int IsGtkPanedObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkpaned_id);
}

int IsGtkPaned(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkpaned_id);
}

NspGtkPaned  *GetGtkPanedCopy(Stack stack, int i)
{
  if (  GetGtkPaned(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkPaned  *GetGtkPaned(Stack stack, int i)
{
  NspGtkPaned *M;
  if (( M = nsp_gtkpaned_object(NthObj(i))) == NULLGTKPANED)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkPaned *gtkpaned_copy(NspGtkPaned *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkpaned);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkpaned);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkPaned
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_paned_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj, t_end};
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_paned_new(orientation))== NULL) return RET_BUG;

  nsp_type_gtkpaned = new_type_gtkpaned(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkpaned);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_paned_add1(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_paned_add1(GTK_PANED(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_paned_add2(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_paned_add2(GTK_PANED(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_paned_pack1(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,new_opts, t_end};
  nsp_option opts[] = {
	{"resize",s_bool,NULLOBJ,-1},
	{"shrink",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *child;
  int resize = FALSE, shrink = TRUE;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, opts, &resize, &shrink) == FAIL) return RET_BUG;
    gtk_paned_pack1(GTK_PANED(self->obj),GTK_WIDGET(child->obj),resize,shrink);
  return 0;
}

static int _wrap_gtk_paned_pack2(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,new_opts, t_end};
  nsp_option opts[] = {
	{"resize",s_bool,NULLOBJ,-1},
	{"shrink",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *child;
  int resize = TRUE, shrink = TRUE;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, opts, &resize, &shrink) == FAIL) return RET_BUG;
    gtk_paned_pack2(GTK_PANED(self->obj),GTK_WIDGET(child->obj),resize,shrink);
  return 0;
}

static int _wrap_gtk_paned_get_position(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_paned_get_position(GTK_PANED(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_paned_set_position(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int position;
  if ( GetArgs(stack,rhs,opt,T,&position) == FAIL) return RET_BUG;
    gtk_paned_set_position(GTK_PANED(self->obj),position);
  return 0;
}

static int _wrap_gtk_paned_get_child1(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_paned_get_child1(GTK_PANED(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_paned_get_child2(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_paned_get_child2(GTK_PANED(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_paned_get_handle_window(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_paned_get_handle_window(GTK_PANED(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_paned_set_wide_handle(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int wide;
  if ( GetArgs(stack,rhs,opt,T,&wide) == FAIL) return RET_BUG;
    gtk_paned_set_wide_handle(GTK_PANED(self->obj),wide);
  return 0;
}

#else
int _wrap_gtk_paned_set_wide_handle(Stack stack, int rhs, int opt, int lhs) /* set_wide_handle */
{
  Scierror("Error: function gtk_paned_set_wide_handle not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_paned_get_wide_handle(NspGtkPaned *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_paned_get_wide_handle(GTK_PANED(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_paned_get_wide_handle(Stack stack, int rhs, int opt, int lhs) /* get_wide_handle */
{
  Scierror("Error: function gtk_paned_get_wide_handle not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkpaned_methods[] = {
  {"add1",(nsp_method *) _wrap_gtk_paned_add1},
  {"add2",(nsp_method *) _wrap_gtk_paned_add2},
  {"pack1",(nsp_method *) _wrap_gtk_paned_pack1},
  {"pack2",(nsp_method *) _wrap_gtk_paned_pack2},
  {"get_position",(nsp_method *) _wrap_gtk_paned_get_position},
  {"set_position",(nsp_method *) _wrap_gtk_paned_set_position},
  {"get_child1",(nsp_method *) _wrap_gtk_paned_get_child1},
  {"get_child2",(nsp_method *) _wrap_gtk_paned_get_child2},
  {"get_handle_window",(nsp_method *) _wrap_gtk_paned_get_handle_window},
  {"set_wide_handle",(nsp_method *) _wrap_gtk_paned_set_wide_handle},
  {"get_wide_handle",(nsp_method *) _wrap_gtk_paned_get_wide_handle},
  { NULL, NULL}
};

static NspMethods *gtkpaned_get_methods(void) { return gtkpaned_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkpaned_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkLayout ----------- */


#define  NspGtkLayout_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtklayout.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkLayout inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtklayout_id=0;
NspTypeGtkLayout *nsp_type_gtklayout=NULL;

/*
 * Type object for NspGtkLayout 
 * all the instance of NspTypeGtkLayout share the same id. 
 * nsp_type_gtklayout: is an instance of NspTypeGtkLayout 
 *    used for objects of NspGtkLayout type (i.e built with new_gtklayout) 
 * other instances are used for derived classes 
 */
NspTypeGtkLayout *new_type_gtklayout(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkLayout *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtklayout != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtklayout;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtklayout_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtklayout_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtklayout;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtklayout */ 

  top->s_type =  (s_type_func *) nsp_gtklayout_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtklayout_type_short_string;
  /* top->create = (create_func*) int_gtklayout_create;*/

  /* specific methods for gtklayout */

  type->init = (init_func *) init_gtklayout;

  /* 
   * NspGtkLayout interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtklayout_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkLayout called nsp_type_gtklayout
       */
      type->id =  nsp_type_gtklayout_id = nsp_new_type_id();
      nsp_type_gtklayout = type;
      if ( nsp_register_type(nsp_type_gtklayout) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtklayout, GTK_TYPE_LAYOUT);
      return ( mode == T_BASE ) ? type : new_type_gtklayout(mode);
    }
  else 
    {
      type->id = nsp_type_gtklayout_id;
      return type;
    }
}

/*
 * initialize NspGtkLayout instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtklayout(NspGtkLayout *Obj,NspTypeGtkLayout *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkLayout 
 */

NspGtkLayout *new_gtklayout() 
{
  NspGtkLayout *loc;
  /* type must exists */
  nsp_type_gtklayout = new_type_gtklayout(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkLayout)))== NULLGTKLAYOUT) return loc;
  /* initialize object */
  if ( init_gtklayout(loc,nsp_type_gtklayout) == FAIL) return NULLGTKLAYOUT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkLayout 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtklayout_type_name[]="GtkLayout";
static char gtklayout_short_type_name[]="GtkLayout";

static char *nsp_gtklayout_type_as_string(void)
{
  return(gtklayout_type_name);
}

static char *nsp_gtklayout_type_short_string(NspObject *v)
{
  return(gtklayout_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkLayout objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkLayout   *nsp_gtklayout_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtklayout_id)  == TRUE  ) return ((NspGtkLayout *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtklayout));
  return NULL;
}

int IsGtkLayoutObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtklayout_id);
}

int IsGtkLayout(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtklayout_id);
}

NspGtkLayout  *GetGtkLayoutCopy(Stack stack, int i)
{
  if (  GetGtkLayout(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkLayout  *GetGtkLayout(Stack stack, int i)
{
  NspGtkLayout *M;
  if (( M = nsp_gtklayout_object(NthObj(i))) == NULLGTKLAYOUT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkLayout *gtklayout_copy(NspGtkLayout *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklayout);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklayout);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkLayout
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_layout_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"hadjustment",obj,NULLOBJ,-1},
	{"vadjustment",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkAdjustment *hadjustment = NULL, *vadjustment = NULL;
  NspGObject *nsp_hadjustment = NULL, *nsp_vadjustment = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_hadjustment, &nsp_vadjustment) == FAIL) return RET_BUG;
  if ( nsp_hadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_hadjustment))
      hadjustment = GTK_ADJUSTMENT(nsp_hadjustment->obj);
    else if (! IsNone((NspObject *)nsp_hadjustment)) {
         Scierror( "Error: hadjustment should be a GtkAdjustment or None\n");
         return RET_BUG;
    }
  }
  if ( nsp_vadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_vadjustment))
      vadjustment = GTK_ADJUSTMENT(nsp_vadjustment->obj);
    else if (! IsNone((NspObject *)nsp_vadjustment)) {
         Scierror( "Error: vadjustment should be a GtkAdjustment or None\n");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_layout_new(hadjustment,vadjustment))== NULL) return RET_BUG;

  nsp_type_gtklayout = new_type_gtklayout(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtklayout);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_layout_get_bin_window(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_layout_get_bin_window(GTK_LAYOUT(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_layout_put(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int, t_end};
  NspGObject *child_widget;
  int x, y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child_widget, &x, &y) == FAIL) return RET_BUG;
    gtk_layout_put(GTK_LAYOUT(self->obj),GTK_WIDGET(child_widget->obj),x,y);
  return 0;
}

static int _wrap_gtk_layout_move(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int, t_end};
  NspGObject *child_widget;
  int x, y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child_widget, &x, &y) == FAIL) return RET_BUG;
    gtk_layout_move(GTK_LAYOUT(self->obj),GTK_WIDGET(child_widget->obj),x,y);
  return 0;
}

static int _wrap_gtk_layout_set_size(NspGtkLayout *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int width, height;
  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
    gtk_layout_set_size(GTK_LAYOUT(self->obj),width,height);
  return 0;
}

#line 6628 "codegen-3.0/gtk.override"
static int
_wrap_gtk_layout_get_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  guint width, height;
  gtk_layout_get_size(GTK_LAYOUT(self->obj), &width, &height);

  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL)
    return RET_BUG;
  return 1;

}
#line 22525 "gtk.c"


static NspMethods gtklayout_methods[] = {
  {"get_bin_window",(nsp_method *) _wrap_gtk_layout_get_bin_window},
  {"put",(nsp_method *) _wrap_gtk_layout_put},
  {"move",(nsp_method *) _wrap_gtk_layout_move},
  {"set_size",(nsp_method *) _wrap_gtk_layout_set_size},
  {"get_size",(nsp_method *) _wrap_gtk_layout_get_size},
  { NULL, NULL}
};

static NspMethods *gtklayout_get_methods(void) { return gtklayout_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtklayout_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkNotebook ----------- */


#define  NspGtkNotebook_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtknotebook.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkNotebook inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtknotebook_id=0;
NspTypeGtkNotebook *nsp_type_gtknotebook=NULL;

/*
 * Type object for NspGtkNotebook 
 * all the instance of NspTypeGtkNotebook share the same id. 
 * nsp_type_gtknotebook: is an instance of NspTypeGtkNotebook 
 *    used for objects of NspGtkNotebook type (i.e built with new_gtknotebook) 
 * other instances are used for derived classes 
 */
NspTypeGtkNotebook *new_type_gtknotebook(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkNotebook *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtknotebook != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtknotebook;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtknotebook_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtknotebook_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtknotebook;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtknotebook */ 

  top->s_type =  (s_type_func *) nsp_gtknotebook_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtknotebook_type_short_string;
  /* top->create = (create_func*) int_gtknotebook_create;*/

  /* specific methods for gtknotebook */

  type->init = (init_func *) init_gtknotebook;

  /* 
   * NspGtkNotebook interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtknotebook_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkNotebook called nsp_type_gtknotebook
       */
      type->id =  nsp_type_gtknotebook_id = nsp_new_type_id();
      nsp_type_gtknotebook = type;
      if ( nsp_register_type(nsp_type_gtknotebook) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtknotebook, GTK_TYPE_NOTEBOOK);
      return ( mode == T_BASE ) ? type : new_type_gtknotebook(mode);
    }
  else 
    {
      type->id = nsp_type_gtknotebook_id;
      return type;
    }
}

/*
 * initialize NspGtkNotebook instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtknotebook(NspGtkNotebook *Obj,NspTypeGtkNotebook *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkNotebook 
 */

NspGtkNotebook *new_gtknotebook() 
{
  NspGtkNotebook *loc;
  /* type must exists */
  nsp_type_gtknotebook = new_type_gtknotebook(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkNotebook)))== NULLGTKNOTEBOOK) return loc;
  /* initialize object */
  if ( init_gtknotebook(loc,nsp_type_gtknotebook) == FAIL) return NULLGTKNOTEBOOK;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkNotebook 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtknotebook_type_name[]="GtkNotebook";
static char gtknotebook_short_type_name[]="GtkNotebook";

static char *nsp_gtknotebook_type_as_string(void)
{
  return(gtknotebook_type_name);
}

static char *nsp_gtknotebook_type_short_string(NspObject *v)
{
  return(gtknotebook_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkNotebook objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkNotebook   *nsp_gtknotebook_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtknotebook_id)  == TRUE  ) return ((NspGtkNotebook *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtknotebook));
  return NULL;
}

int IsGtkNotebookObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtknotebook_id);
}

int IsGtkNotebook(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtknotebook_id);
}

NspGtkNotebook  *GetGtkNotebookCopy(Stack stack, int i)
{
  if (  GetGtkNotebook(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkNotebook  *GetGtkNotebook(Stack stack, int i)
{
  NspGtkNotebook *M;
  if (( M = nsp_gtknotebook_object(NthObj(i))) == NULLGTKNOTEBOOK)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkNotebook *gtknotebook_copy(NspGtkNotebook *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtknotebook);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtknotebook);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkNotebook
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_notebook_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_notebook_new())== NULL) return RET_BUG;

  nsp_type_gtknotebook = new_type_gtknotebook(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtknotebook);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 5137 "codegen-3.0/gtk.override"

static int _wrap_gtk_notebook_append_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T1[] = {obj_check, t_end};
  int_types T2[] = {obj_check,obj_check, t_end};
  NspGObject *child, *tab_label;
  int ret;
  if ( rhs == 1 )
    {
      if ( GetArgs(stack,rhs,opt,T1,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
      ret =gtk_notebook_append_page(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),NULL);      
    }
  else
    {
      if ( GetArgs(stack,rhs,opt,T2,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label) == FAIL) return RET_BUG;
      ret =gtk_notebook_append_page(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),GTK_WIDGET(tab_label->obj));
    }

  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 22777 "gtk.c"


static int _wrap_gtk_notebook_append_page_menu(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check,obj_check, t_end};
  NspGObject *child, *tab_label, *menu_label;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label, &nsp_type_gtkwidget, &menu_label) == FAIL) return RET_BUG;
    ret =gtk_notebook_append_page_menu(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),GTK_WIDGET(tab_label->obj),GTK_WIDGET(menu_label->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_prepend_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *child, *tab_label;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label) == FAIL) return RET_BUG;
    ret =gtk_notebook_prepend_page(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),GTK_WIDGET(tab_label->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_prepend_page_menu(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check,obj_check, t_end};
  NspGObject *child, *tab_label, *menu_label;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label, &nsp_type_gtkwidget, &menu_label) == FAIL) return RET_BUG;
    ret =gtk_notebook_prepend_page_menu(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),GTK_WIDGET(tab_label->obj),GTK_WIDGET(menu_label->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_insert_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check,s_int, t_end};
  NspGObject *child, *tab_label;
  int position, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label, &position) == FAIL) return RET_BUG;
    ret =gtk_notebook_insert_page(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),GTK_WIDGET(tab_label->obj),position);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_insert_page_menu(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check,obj_check,s_int, t_end};
  NspGObject *child, *tab_label, *menu_label;
  int position, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label, &nsp_type_gtkwidget, &menu_label, &position) == FAIL) return RET_BUG;
    ret =gtk_notebook_insert_page_menu(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),GTK_WIDGET(tab_label->obj),GTK_WIDGET(menu_label->obj),position);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_remove_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int page_num;
  if ( GetArgs(stack,rhs,opt,T,&page_num) == FAIL) return RET_BUG;
    gtk_notebook_remove_page(GTK_NOTEBOOK(self->obj),page_num);
  return 0;
}

static int _wrap_gtk_notebook_set_group_name(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *group_name;
  if ( GetArgs(stack,rhs,opt,T,&group_name) == FAIL) return RET_BUG;
    gtk_notebook_set_group_name(GTK_NOTEBOOK(self->obj),group_name);
  return 0;
}

static int _wrap_gtk_notebook_get_group_name(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_notebook_get_group_name(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_get_current_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_notebook_get_current_page(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_get_nth_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int page_num;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&page_num) == FAIL) return RET_BUG;
    ret =gtk_notebook_get_nth_page(GTK_NOTEBOOK(self->obj),page_num);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_notebook_get_n_pages(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_notebook_get_n_pages(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_page_num(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    ret =gtk_notebook_page_num(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_set_current_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int page_num;
  if ( GetArgs(stack,rhs,opt,T,&page_num) == FAIL) return RET_BUG;
    gtk_notebook_set_current_page(GTK_NOTEBOOK(self->obj),page_num);
  return 0;
}

static int _wrap_gtk_notebook_next_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_notebook_next_page(GTK_NOTEBOOK(self->obj));
  return 0;
}

static int _wrap_gtk_notebook_prev_page(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_notebook_prev_page(GTK_NOTEBOOK(self->obj));
  return 0;
}

static int _wrap_gtk_notebook_set_show_border(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_border;
  if ( GetArgs(stack,rhs,opt,T,&show_border) == FAIL) return RET_BUG;
    gtk_notebook_set_show_border(GTK_NOTEBOOK(self->obj),show_border);
  return 0;
}

static int _wrap_gtk_notebook_get_show_border(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_notebook_get_show_border(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_set_show_tabs(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_tabs;
  if ( GetArgs(stack,rhs,opt,T,&show_tabs) == FAIL) return RET_BUG;
    gtk_notebook_set_show_tabs(GTK_NOTEBOOK(self->obj),show_tabs);
  return 0;
}

static int _wrap_gtk_notebook_get_show_tabs(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_notebook_get_show_tabs(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_set_tab_pos(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkPositionType pos;
  NspObject *nsp_pos = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_pos, &pos)== FAIL)
      return RET_BUG;
    gtk_notebook_set_tab_pos(GTK_NOTEBOOK(self->obj),pos);
  return 0;
}

static int _wrap_gtk_notebook_get_tab_pos(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_notebook_get_tab_pos(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_set_scrollable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int scrollable;
  if ( GetArgs(stack,rhs,opt,T,&scrollable) == FAIL) return RET_BUG;
    gtk_notebook_set_scrollable(GTK_NOTEBOOK(self->obj),scrollable);
  return 0;
}

static int _wrap_gtk_notebook_get_scrollable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_notebook_get_scrollable(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,4,0)
int _wrap_gtk_notebook_get_tab_hborder(Stack stack, int rhs, int opt, int lhs) /* get_tab_hborder */
{
  Scierror("Error: function gtk_notebook_get_tab_hborder is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_notebook_get_tab_hborder(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_notebook_get_tab_hborder(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,4,0)
int _wrap_gtk_notebook_get_tab_vborder(Stack stack, int rhs, int opt, int lhs) /* get_tab_vborder */
{
  Scierror("Error: function gtk_notebook_get_tab_vborder is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_notebook_get_tab_vborder(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_notebook_get_tab_vborder(GTK_NOTEBOOK(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
static int _wrap_gtk_notebook_popup_enable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_notebook_popup_enable(GTK_NOTEBOOK(self->obj));
  return 0;
}

static int _wrap_gtk_notebook_popup_disable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_notebook_popup_disable(GTK_NOTEBOOK(self->obj));
  return 0;
}

static int _wrap_gtk_notebook_get_tab_label(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    ret =gtk_notebook_get_tab_label(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_notebook_set_tab_label(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *child, *tab_label;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &tab_label) == FAIL) return RET_BUG;
    gtk_notebook_set_tab_label(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),GTK_WIDGET(tab_label->obj));
  return 0;
}

static int _wrap_gtk_notebook_set_tab_label_text(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *child;
  char *tab_text;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &tab_text) == FAIL) return RET_BUG;
    gtk_notebook_set_tab_label_text(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),tab_text);
  return 0;
}

static int _wrap_gtk_notebook_get_tab_label_text(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  const gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    ret =gtk_notebook_get_tab_label_text(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_get_menu_label(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    ret =gtk_notebook_get_menu_label(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_notebook_set_menu_label(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *child, *menu_label;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtkwidget, &menu_label) == FAIL) return RET_BUG;
    gtk_notebook_set_menu_label(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),GTK_WIDGET(menu_label->obj));
  return 0;
}

static int _wrap_gtk_notebook_set_menu_label_text(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *child;
  char *menu_text;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &menu_text) == FAIL) return RET_BUG;
    gtk_notebook_set_menu_label_text(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),menu_text);
  return 0;
}

static int _wrap_gtk_notebook_get_menu_label_text(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  const gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    ret =gtk_notebook_get_menu_label_text(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_reorder_child(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *child;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &position) == FAIL) return RET_BUG;
    gtk_notebook_reorder_child(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),position);
  return 0;
}

static int _wrap_gtk_notebook_get_tab_reorderable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    ret =gtk_notebook_get_tab_reorderable(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_set_tab_reorderable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *child;
  int reorderable;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &reorderable) == FAIL) return RET_BUG;
    gtk_notebook_set_tab_reorderable(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),reorderable);
  return 0;
}

static int _wrap_gtk_notebook_get_tab_detachable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    ret =gtk_notebook_get_tab_detachable(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_notebook_set_tab_detachable(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *child;
  int detachable;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &detachable) == FAIL) return RET_BUG;
    gtk_notebook_set_tab_detachable(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj),detachable);
  return 0;
}

#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_notebook_detach_tab(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_notebook_detach_tab(GTK_NOTEBOOK(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

#else
int _wrap_gtk_notebook_detach_tab(Stack stack, int rhs, int opt, int lhs) /* detach_tab */
{
  Scierror("Error: function gtk_notebook_detach_tab not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_notebook_get_action_widget(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkPackType pack_type;
  NspObject *nsp_pack_type = NULL, *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_pack_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_PACK_TYPE, nsp_pack_type, &pack_type)== FAIL)
      return RET_BUG;
    ret =gtk_notebook_get_action_widget(GTK_NOTEBOOK(self->obj),pack_type);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_notebook_set_action_widget(NspGtkNotebook *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *widget;
  GtkPackType pack_type;
  NspObject *nsp_pack_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_pack_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_PACK_TYPE, nsp_pack_type, &pack_type)== FAIL)
      return RET_BUG;
    gtk_notebook_set_action_widget(GTK_NOTEBOOK(self->obj),GTK_WIDGET(widget->obj),pack_type);
  return 0;
}

static NspMethods gtknotebook_methods[] = {
  {"append_page",(nsp_method *) _wrap_gtk_notebook_append_page},
  {"append_page_menu",(nsp_method *) _wrap_gtk_notebook_append_page_menu},
  {"prepend_page",(nsp_method *) _wrap_gtk_notebook_prepend_page},
  {"prepend_page_menu",(nsp_method *) _wrap_gtk_notebook_prepend_page_menu},
  {"insert_page",(nsp_method *) _wrap_gtk_notebook_insert_page},
  {"insert_page_menu",(nsp_method *) _wrap_gtk_notebook_insert_page_menu},
  {"remove_page",(nsp_method *) _wrap_gtk_notebook_remove_page},
  {"set_group_name",(nsp_method *) _wrap_gtk_notebook_set_group_name},
  {"get_group_name",(nsp_method *) _wrap_gtk_notebook_get_group_name},
  {"get_current_page",(nsp_method *) _wrap_gtk_notebook_get_current_page},
  {"get_nth_page",(nsp_method *) _wrap_gtk_notebook_get_nth_page},
  {"get_n_pages",(nsp_method *) _wrap_gtk_notebook_get_n_pages},
  {"page_num",(nsp_method *) _wrap_gtk_notebook_page_num},
  {"set_current_page",(nsp_method *) _wrap_gtk_notebook_set_current_page},
  {"next_page",(nsp_method *) _wrap_gtk_notebook_next_page},
  {"prev_page",(nsp_method *) _wrap_gtk_notebook_prev_page},
  {"set_show_border",(nsp_method *) _wrap_gtk_notebook_set_show_border},
  {"get_show_border",(nsp_method *) _wrap_gtk_notebook_get_show_border},
  {"set_show_tabs",(nsp_method *) _wrap_gtk_notebook_set_show_tabs},
  {"get_show_tabs",(nsp_method *) _wrap_gtk_notebook_get_show_tabs},
  {"set_tab_pos",(nsp_method *) _wrap_gtk_notebook_set_tab_pos},
  {"get_tab_pos",(nsp_method *) _wrap_gtk_notebook_get_tab_pos},
  {"set_scrollable",(nsp_method *) _wrap_gtk_notebook_set_scrollable},
  {"get_scrollable",(nsp_method *) _wrap_gtk_notebook_get_scrollable},
  {"get_tab_hborder",(nsp_method *) _wrap_gtk_notebook_get_tab_hborder},
  {"get_tab_vborder",(nsp_method *) _wrap_gtk_notebook_get_tab_vborder},
  {"popup_enable",(nsp_method *) _wrap_gtk_notebook_popup_enable},
  {"popup_disable",(nsp_method *) _wrap_gtk_notebook_popup_disable},
  {"get_tab_label",(nsp_method *) _wrap_gtk_notebook_get_tab_label},
  {"set_tab_label",(nsp_method *) _wrap_gtk_notebook_set_tab_label},
  {"set_tab_label_text",(nsp_method *) _wrap_gtk_notebook_set_tab_label_text},
  {"get_tab_label_text",(nsp_method *) _wrap_gtk_notebook_get_tab_label_text},
  {"get_menu_label",(nsp_method *) _wrap_gtk_notebook_get_menu_label},
  {"set_menu_label",(nsp_method *) _wrap_gtk_notebook_set_menu_label},
  {"set_menu_label_text",(nsp_method *) _wrap_gtk_notebook_set_menu_label_text},
  {"get_menu_label_text",(nsp_method *) _wrap_gtk_notebook_get_menu_label_text},
  {"reorder_child",(nsp_method *) _wrap_gtk_notebook_reorder_child},
  {"get_tab_reorderable",(nsp_method *) _wrap_gtk_notebook_get_tab_reorderable},
  {"set_tab_reorderable",(nsp_method *) _wrap_gtk_notebook_set_tab_reorderable},
  {"get_tab_detachable",(nsp_method *) _wrap_gtk_notebook_get_tab_detachable},
  {"set_tab_detachable",(nsp_method *) _wrap_gtk_notebook_set_tab_detachable},
  {"detach_tab",(nsp_method *) _wrap_gtk_notebook_detach_tab},
  {"get_action_widget",(nsp_method *) _wrap_gtk_notebook_get_action_widget},
  {"set_action_widget",(nsp_method *) _wrap_gtk_notebook_set_action_widget},
  { NULL, NULL}
};

static NspMethods *gtknotebook_get_methods(void) { return gtknotebook_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtknotebook_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkExpander ----------- */


#define  NspGtkExpander_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkexpander.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkExpander inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkexpander_id=0;
NspTypeGtkExpander *nsp_type_gtkexpander=NULL;

/*
 * Type object for NspGtkExpander 
 * all the instance of NspTypeGtkExpander share the same id. 
 * nsp_type_gtkexpander: is an instance of NspTypeGtkExpander 
 *    used for objects of NspGtkExpander type (i.e built with new_gtkexpander) 
 * other instances are used for derived classes 
 */
NspTypeGtkExpander *new_type_gtkexpander(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkExpander *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkexpander != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkexpander;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkexpander_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkexpander_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkexpander;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkexpander */ 

  top->s_type =  (s_type_func *) nsp_gtkexpander_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkexpander_type_short_string;
  /* top->create = (create_func*) int_gtkexpander_create;*/

  /* specific methods for gtkexpander */

  type->init = (init_func *) init_gtkexpander;

  /* 
   * NspGtkExpander interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkexpander_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkExpander called nsp_type_gtkexpander
       */
      type->id =  nsp_type_gtkexpander_id = nsp_new_type_id();
      nsp_type_gtkexpander = type;
      if ( nsp_register_type(nsp_type_gtkexpander) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkexpander, GTK_TYPE_EXPANDER);
      return ( mode == T_BASE ) ? type : new_type_gtkexpander(mode);
    }
  else 
    {
      type->id = nsp_type_gtkexpander_id;
      return type;
    }
}

/*
 * initialize NspGtkExpander instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkexpander(NspGtkExpander *Obj,NspTypeGtkExpander *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkExpander 
 */

NspGtkExpander *new_gtkexpander() 
{
  NspGtkExpander *loc;
  /* type must exists */
  nsp_type_gtkexpander = new_type_gtkexpander(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkExpander)))== NULLGTKEXPANDER) return loc;
  /* initialize object */
  if ( init_gtkexpander(loc,nsp_type_gtkexpander) == FAIL) return NULLGTKEXPANDER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkExpander 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkexpander_type_name[]="GtkExpander";
static char gtkexpander_short_type_name[]="GtkExpander";

static char *nsp_gtkexpander_type_as_string(void)
{
  return(gtkexpander_type_name);
}

static char *nsp_gtkexpander_type_short_string(NspObject *v)
{
  return(gtkexpander_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkExpander objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkExpander   *nsp_gtkexpander_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkexpander_id)  == TRUE  ) return ((NspGtkExpander *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkexpander));
  return NULL;
}

int IsGtkExpanderObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkexpander_id);
}

int IsGtkExpander(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkexpander_id);
}

NspGtkExpander  *GetGtkExpanderCopy(Stack stack, int i)
{
  if (  GetGtkExpander(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkExpander  *GetGtkExpander(Stack stack, int i)
{
  NspGtkExpander *M;
  if (( M = nsp_gtkexpander_object(NthObj(i))) == NULLGTKEXPANDER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkExpander *gtkexpander_copy(NspGtkExpander *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkexpander);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkexpander);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkExpander
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_expander_new_with_mnemonic (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *label;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_expander_new_with_mnemonic(label))== NULL) return RET_BUG;

  nsp_type_gtkexpander = new_type_gtkexpander(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkexpander);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_expander_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *label;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_expander_new(label))== NULL) return RET_BUG;

  nsp_type_gtkexpander = new_type_gtkexpander(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkexpander);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_expander_set_expanded(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int expanded;
  if ( GetArgs(stack,rhs,opt,T,&expanded) == FAIL) return RET_BUG;
    gtk_expander_set_expanded(GTK_EXPANDER(self->obj),expanded);
  return 0;
}

static int _wrap_gtk_expander_get_expanded(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_expander_get_expanded(GTK_EXPANDER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_expander_set_spacing(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int spacing;
  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
    gtk_expander_set_spacing(GTK_EXPANDER(self->obj),spacing);
  return 0;
}

static int _wrap_gtk_expander_get_spacing(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_expander_get_spacing(GTK_EXPANDER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_expander_set_label(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *label;
  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
    gtk_expander_set_label(GTK_EXPANDER(self->obj),label);
  return 0;
}

static int _wrap_gtk_expander_get_label(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_expander_get_label(GTK_EXPANDER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_expander_set_use_underline(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_underline;
  if ( GetArgs(stack,rhs,opt,T,&use_underline) == FAIL) return RET_BUG;
    gtk_expander_set_use_underline(GTK_EXPANDER(self->obj),use_underline);
  return 0;
}

static int _wrap_gtk_expander_get_use_underline(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_expander_get_use_underline(GTK_EXPANDER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_expander_set_use_markup(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_markup;
  if ( GetArgs(stack,rhs,opt,T,&use_markup) == FAIL) return RET_BUG;
    gtk_expander_set_use_markup(GTK_EXPANDER(self->obj),use_markup);
  return 0;
}

static int _wrap_gtk_expander_get_use_markup(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_expander_get_use_markup(GTK_EXPANDER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_expander_set_label_widget(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *label_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &label_widget) == FAIL) return RET_BUG;
    gtk_expander_set_label_widget(GTK_EXPANDER(self->obj),GTK_WIDGET(label_widget->obj));
  return 0;
}

static int _wrap_gtk_expander_get_label_widget(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_expander_get_label_widget(GTK_EXPANDER(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_expander_set_label_fill(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int label_fill;
  if ( GetArgs(stack,rhs,opt,T,&label_fill) == FAIL) return RET_BUG;
    gtk_expander_set_label_fill(GTK_EXPANDER(self->obj),label_fill);
  return 0;
}

static int _wrap_gtk_expander_get_label_fill(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_expander_get_label_fill(GTK_EXPANDER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_expander_set_resize_toplevel(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int resize_toplevel;
  if ( GetArgs(stack,rhs,opt,T,&resize_toplevel) == FAIL) return RET_BUG;
    gtk_expander_set_resize_toplevel(GTK_EXPANDER(self->obj),resize_toplevel);
  return 0;
}

#else
int _wrap_gtk_expander_set_resize_toplevel(Stack stack, int rhs, int opt, int lhs) /* set_resize_toplevel */
{
  Scierror("Error: function gtk_expander_set_resize_toplevel not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_expander_get_resize_toplevel(NspGtkExpander *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_expander_get_resize_toplevel(GTK_EXPANDER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_expander_get_resize_toplevel(Stack stack, int rhs, int opt, int lhs) /* get_resize_toplevel */
{
  Scierror("Error: function gtk_expander_get_resize_toplevel not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkexpander_methods[] = {
  {"set_expanded",(nsp_method *) _wrap_gtk_expander_set_expanded},
  {"get_expanded",(nsp_method *) _wrap_gtk_expander_get_expanded},
  {"set_spacing",(nsp_method *) _wrap_gtk_expander_set_spacing},
  {"get_spacing",(nsp_method *) _wrap_gtk_expander_get_spacing},
  {"set_label",(nsp_method *) _wrap_gtk_expander_set_label},
  {"get_label",(nsp_method *) _wrap_gtk_expander_get_label},
  {"set_use_underline",(nsp_method *) _wrap_gtk_expander_set_use_underline},
  {"get_use_underline",(nsp_method *) _wrap_gtk_expander_get_use_underline},
  {"set_use_markup",(nsp_method *) _wrap_gtk_expander_set_use_markup},
  {"get_use_markup",(nsp_method *) _wrap_gtk_expander_get_use_markup},
  {"set_label_widget",(nsp_method *) _wrap_gtk_expander_set_label_widget},
  {"get_label_widget",(nsp_method *) _wrap_gtk_expander_get_label_widget},
  {"set_label_fill",(nsp_method *) _wrap_gtk_expander_set_label_fill},
  {"get_label_fill",(nsp_method *) _wrap_gtk_expander_get_label_fill},
  {"set_resize_toplevel",(nsp_method *) _wrap_gtk_expander_set_resize_toplevel},
  {"get_resize_toplevel",(nsp_method *) _wrap_gtk_expander_get_resize_toplevel},
  { NULL, NULL}
};

static NspMethods *gtkexpander_get_methods(void) { return gtkexpander_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkexpander_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAspectFrame ----------- */


#define  NspGtkAspectFrame_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkaspectframe.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAspectFrame inherits from GtkFrame 
 * and implements GtkBuildable
 */

int nsp_type_gtkaspectframe_id=0;
NspTypeGtkAspectFrame *nsp_type_gtkaspectframe=NULL;

/*
 * Type object for NspGtkAspectFrame 
 * all the instance of NspTypeGtkAspectFrame share the same id. 
 * nsp_type_gtkaspectframe: is an instance of NspTypeGtkAspectFrame 
 *    used for objects of NspGtkAspectFrame type (i.e built with new_gtkaspectframe) 
 * other instances are used for derived classes 
 */
NspTypeGtkAspectFrame *new_type_gtkaspectframe(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkAspectFrame *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkaspectframe != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkaspectframe;
    }
  if (( type =  malloc(sizeof(NspTypeGtkFrame))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkframe(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkaspectframe_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkaspectframe_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkaspectframe;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkaspectframe */ 

  top->s_type =  (s_type_func *) nsp_gtkaspectframe_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkaspectframe_type_short_string;
  /* top->create = (create_func*) int_gtkaspectframe_create;*/

  /* specific methods for gtkaspectframe */

  type->init = (init_func *) init_gtkaspectframe;

  /* 
   * NspGtkAspectFrame interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkaspectframe_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAspectFrame called nsp_type_gtkaspectframe
       */
      type->id =  nsp_type_gtkaspectframe_id = nsp_new_type_id();
      nsp_type_gtkaspectframe = type;
      if ( nsp_register_type(nsp_type_gtkaspectframe) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkaspectframe, GTK_TYPE_ASPECT_FRAME);
      return ( mode == T_BASE ) ? type : new_type_gtkaspectframe(mode);
    }
  else 
    {
      type->id = nsp_type_gtkaspectframe_id;
      return type;
    }
}

/*
 * initialize NspGtkAspectFrame instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkaspectframe(NspGtkAspectFrame *Obj,NspTypeGtkAspectFrame *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAspectFrame 
 */

NspGtkAspectFrame *new_gtkaspectframe() 
{
  NspGtkAspectFrame *loc;
  /* type must exists */
  nsp_type_gtkaspectframe = new_type_gtkaspectframe(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAspectFrame)))== NULLGTKASPECTFRAME) return loc;
  /* initialize object */
  if ( init_gtkaspectframe(loc,nsp_type_gtkaspectframe) == FAIL) return NULLGTKASPECTFRAME;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAspectFrame 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkaspectframe_type_name[]="GtkAspectFrame";
static char gtkaspectframe_short_type_name[]="GtkAspectFrame";

static char *nsp_gtkaspectframe_type_as_string(void)
{
  return(gtkaspectframe_type_name);
}

static char *nsp_gtkaspectframe_type_short_string(NspObject *v)
{
  return(gtkaspectframe_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAspectFrame objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAspectFrame   *nsp_gtkaspectframe_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkaspectframe_id)  == TRUE  ) return ((NspGtkAspectFrame *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkaspectframe));
  return NULL;
}

int IsGtkAspectFrameObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkaspectframe_id);
}

int IsGtkAspectFrame(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkaspectframe_id);
}

NspGtkAspectFrame  *GetGtkAspectFrameCopy(Stack stack, int i)
{
  if (  GetGtkAspectFrame(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAspectFrame  *GetGtkAspectFrame(Stack stack, int i)
{
  NspGtkAspectFrame *M;
  if (( M = nsp_gtkaspectframe_object(NthObj(i))) == NULLGTKASPECTFRAME)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAspectFrame *gtkaspectframe_copy(NspGtkAspectFrame *self)
{
  /* return gtkframe_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaspectframe);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaspectframe);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAspectFrame
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_aspect_frame_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"label",string,NULLOBJ,-1},
	{"xalign",s_double,NULLOBJ,-1},
	{"yalign",s_double,NULLOBJ,-1},
	{"ratio",s_double,NULLOBJ,-1},
	{"obey_child",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  char *label = NULL;
  double xalign = 0.5, yalign = 0.5, ratio = 1;
  int obey_child = TRUE;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &label, &xalign, &yalign, &ratio, &obey_child) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_aspect_frame_new(label,xalign,yalign,ratio,obey_child))== NULL) return RET_BUG;

  nsp_type_gtkaspectframe = new_type_gtkaspectframe(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkaspectframe);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_aspect_frame_set(NspGtkAspectFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"xalign",s_double,NULLOBJ,-1},
	{"yalign",s_double,NULLOBJ,-1},
	{"ratio",s_double,NULLOBJ,-1},
	{"obey_child",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  double xalign = 0.0, yalign = 0.0, ratio = 1.0;
  int obey_child = 1;
  if ( GetArgs(stack,rhs,opt,T,opts, &xalign, &yalign, &ratio, &obey_child) == FAIL) return RET_BUG;
    gtk_aspect_frame_set(GTK_ASPECT_FRAME(self->obj),xalign,yalign,ratio,obey_child);
  return 0;
}

static NspMethods gtkaspectframe_methods[] = {
  {"set",(nsp_method *) _wrap_gtk_aspect_frame_set},
  { NULL, NULL}
};

static NspMethods *gtkaspectframe_get_methods(void) { return gtkaspectframe_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkaspectframe_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkFixed ----------- */


#define  NspGtkFixed_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkfixed.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFixed inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtkfixed_id=0;
NspTypeGtkFixed *nsp_type_gtkfixed=NULL;

/*
 * Type object for NspGtkFixed 
 * all the instance of NspTypeGtkFixed share the same id. 
 * nsp_type_gtkfixed: is an instance of NspTypeGtkFixed 
 *    used for objects of NspGtkFixed type (i.e built with new_gtkfixed) 
 * other instances are used for derived classes 
 */
NspTypeGtkFixed *new_type_gtkfixed(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkFixed *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfixed != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfixed;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfixed_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkfixed_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkfixed;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkfixed */ 

  top->s_type =  (s_type_func *) nsp_gtkfixed_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkfixed_type_short_string;
  /* top->create = (create_func*) int_gtkfixed_create;*/

  /* specific methods for gtkfixed */

  type->init = (init_func *) init_gtkfixed;

  /* 
   * NspGtkFixed interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkfixed_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFixed called nsp_type_gtkfixed
       */
      type->id =  nsp_type_gtkfixed_id = nsp_new_type_id();
      nsp_type_gtkfixed = type;
      if ( nsp_register_type(nsp_type_gtkfixed) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfixed, GTK_TYPE_FIXED);
      return ( mode == T_BASE ) ? type : new_type_gtkfixed(mode);
    }
  else 
    {
      type->id = nsp_type_gtkfixed_id;
      return type;
    }
}

/*
 * initialize NspGtkFixed instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfixed(NspGtkFixed *Obj,NspTypeGtkFixed *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFixed 
 */

NspGtkFixed *new_gtkfixed() 
{
  NspGtkFixed *loc;
  /* type must exists */
  nsp_type_gtkfixed = new_type_gtkfixed(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFixed)))== NULLGTKFIXED) return loc;
  /* initialize object */
  if ( init_gtkfixed(loc,nsp_type_gtkfixed) == FAIL) return NULLGTKFIXED;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFixed 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkfixed_type_name[]="GtkFixed";
static char gtkfixed_short_type_name[]="GtkFixed";

static char *nsp_gtkfixed_type_as_string(void)
{
  return(gtkfixed_type_name);
}

static char *nsp_gtkfixed_type_short_string(NspObject *v)
{
  return(gtkfixed_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFixed objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFixed   *nsp_gtkfixed_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkfixed_id)  == TRUE  ) return ((NspGtkFixed *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfixed));
  return NULL;
}

int IsGtkFixedObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkfixed_id);
}

int IsGtkFixed(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfixed_id);
}

NspGtkFixed  *GetGtkFixedCopy(Stack stack, int i)
{
  if (  GetGtkFixed(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFixed  *GetGtkFixed(Stack stack, int i)
{
  NspGtkFixed *M;
  if (( M = nsp_gtkfixed_object(NthObj(i))) == NULLGTKFIXED)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFixed *gtkfixed_copy(NspGtkFixed *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfixed);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfixed);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFixed
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_fixed_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_fixed_new())== NULL) return RET_BUG;

  nsp_type_gtkfixed = new_type_gtkfixed(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkfixed);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_fixed_put(NspGtkFixed *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int, t_end};
  NspGObject *widget;
  int x, y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &x, &y) == FAIL) return RET_BUG;
    gtk_fixed_put(GTK_FIXED(self->obj),GTK_WIDGET(widget->obj),x,y);
  return 0;
}

static int _wrap_gtk_fixed_move(NspGtkFixed *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int, t_end};
  NspGObject *widget;
  int x, y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &x, &y) == FAIL) return RET_BUG;
    gtk_fixed_move(GTK_FIXED(self->obj),GTK_WIDGET(widget->obj),x,y);
  return 0;
}

static NspMethods gtkfixed_methods[] = {
  {"put",(nsp_method *) _wrap_gtk_fixed_put},
  {"move",(nsp_method *) _wrap_gtk_fixed_move},
  { NULL, NULL}
};

static NspMethods *gtkfixed_get_methods(void) { return gtkfixed_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfixed_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkLabel ----------- */


#define  NspGtkLabel_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtklabel.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkLabel inherits from GtkMisc 
 * and implements GtkBuildable
 */

int nsp_type_gtklabel_id=0;
NspTypeGtkLabel *nsp_type_gtklabel=NULL;

/*
 * Type object for NspGtkLabel 
 * all the instance of NspTypeGtkLabel share the same id. 
 * nsp_type_gtklabel: is an instance of NspTypeGtkLabel 
 *    used for objects of NspGtkLabel type (i.e built with new_gtklabel) 
 * other instances are used for derived classes 
 */
NspTypeGtkLabel *new_type_gtklabel(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkLabel *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtklabel != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtklabel;
    }
  if (( type =  malloc(sizeof(NspTypeGtkMisc))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmisc(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtklabel_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtklabel_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtklabel;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtklabel */ 

  top->s_type =  (s_type_func *) nsp_gtklabel_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtklabel_type_short_string;
  /* top->create = (create_func*) int_gtklabel_create;*/

  /* specific methods for gtklabel */

  type->init = (init_func *) init_gtklabel;

  /* 
   * NspGtkLabel interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtklabel_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkLabel called nsp_type_gtklabel
       */
      type->id =  nsp_type_gtklabel_id = nsp_new_type_id();
      nsp_type_gtklabel = type;
      if ( nsp_register_type(nsp_type_gtklabel) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtklabel, GTK_TYPE_LABEL);
      return ( mode == T_BASE ) ? type : new_type_gtklabel(mode);
    }
  else 
    {
      type->id = nsp_type_gtklabel_id;
      return type;
    }
}

/*
 * initialize NspGtkLabel instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtklabel(NspGtkLabel *Obj,NspTypeGtkLabel *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkLabel 
 */

NspGtkLabel *new_gtklabel() 
{
  NspGtkLabel *loc;
  /* type must exists */
  nsp_type_gtklabel = new_type_gtklabel(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkLabel)))== NULLGTKLABEL) return loc;
  /* initialize object */
  if ( init_gtklabel(loc,nsp_type_gtklabel) == FAIL) return NULLGTKLABEL;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkLabel 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtklabel_type_name[]="GtkLabel";
static char gtklabel_short_type_name[]="GtkLabel";

static char *nsp_gtklabel_type_as_string(void)
{
  return(gtklabel_type_name);
}

static char *nsp_gtklabel_type_short_string(NspObject *v)
{
  return(gtklabel_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkLabel objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkLabel   *nsp_gtklabel_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtklabel_id)  == TRUE  ) return ((NspGtkLabel *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtklabel));
  return NULL;
}

int IsGtkLabelObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtklabel_id);
}

int IsGtkLabel(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtklabel_id);
}

NspGtkLabel  *GetGtkLabelCopy(Stack stack, int i)
{
  if (  GetGtkLabel(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkLabel  *GetGtkLabel(Stack stack, int i)
{
  NspGtkLabel *M;
  if (( M = nsp_gtklabel_object(NthObj(i))) == NULLGTKLABEL)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkLabel *gtklabel_copy(NspGtkLabel *self)
{
  /* return gtkmisc_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklabel);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklabel);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkLabel
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 1172 "codegen-3.0/gtk.override"
static int
_wrap_gtk_label_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"str",string,NULLOBJ,-1},
	{"mnemonic",string,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };

  char *str = NULL,  * mnemonic= NULL;

  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &str,&mnemonic) == FAIL) return RET_BUG;
  if ( mnemonic != NULL)
    {
      if ((ret = (GObject *)gtk_label_new_with_mnemonic(mnemonic))== NULL) return RET_BUG;
    }
  else
    {
      if ((ret = (GObject *)gtk_label_new(str))== NULL) return RET_BUG;
    }
  nsp_type_gtklabel = new_type_gtklabel(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtklabel );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 24427 "gtk.c"


static int _wrap_gtk_label_set_text(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *str;
  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
    gtk_label_set_text(GTK_LABEL(self->obj),str);
  return 0;
}

static int _wrap_gtk_label_get_text(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_label_get_text(GTK_LABEL(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_attributes(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  PangoAttrList *attrs = NULL;
  NspObject *nsp_attrs = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_attrs) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_attrs, PANGO_TYPE_ATTR_LIST))
      attrs = nspg_boxed_get(nsp_attrs, PangoAttrList);
  else {
      Scierror( "Error: attrs should be a PangoAttrList\n");
      return RET_BUG;
  }
    gtk_label_set_attributes(GTK_LABEL(self->obj),attrs);
  return 0;
}

static int _wrap_gtk_label_get_attributes(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoAttrList *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_label_get_attributes(GTK_LABEL(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,PANGO_TYPE_ATTR_LIST, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_pangoattrlist))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_label_set_label(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *str;
  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
    gtk_label_set_label(GTK_LABEL(self->obj),str);
  return 0;
}

static int _wrap_gtk_label_get_label(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_label_get_label(GTK_LABEL(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_markup(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *str;
  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
    gtk_label_set_markup(GTK_LABEL(self->obj),str);
  return 0;
}

static int _wrap_gtk_label_set_use_markup(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_label_set_use_markup(GTK_LABEL(self->obj),setting);
  return 0;
}

static int _wrap_gtk_label_get_use_markup(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_label_get_use_markup(GTK_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_use_underline(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_label_set_use_underline(GTK_LABEL(self->obj),setting);
  return 0;
}

static int _wrap_gtk_label_get_use_underline(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_label_get_use_underline(GTK_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_markup_with_mnemonic(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *str;
  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
    gtk_label_set_markup_with_mnemonic(GTK_LABEL(self->obj),str);
  return 0;
}

static int _wrap_gtk_label_get_mnemonic_keyval(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_label_get_mnemonic_keyval(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_mnemonic_widget(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_label_set_mnemonic_widget(GTK_LABEL(self->obj),GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_label_get_mnemonic_widget(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_label_get_mnemonic_widget(GTK_LABEL(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_label_set_text_with_mnemonic(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *str;
  if ( GetArgs(stack,rhs,opt,T,&str) == FAIL) return RET_BUG;
    gtk_label_set_text_with_mnemonic(GTK_LABEL(self->obj),str);
  return 0;
}

static int _wrap_gtk_label_set_justify(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkJustification jtype;
  NspObject *nsp_jtype = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_jtype) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_JUSTIFICATION, nsp_jtype, &jtype)== FAIL)
      return RET_BUG;
    gtk_label_set_justify(GTK_LABEL(self->obj),jtype);
  return 0;
}

static int _wrap_gtk_label_get_justify(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_label_get_justify(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_ellipsize(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  PangoEllipsizeMode mode;
  NspObject *nsp_mode = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(PANGO_TYPE_ELLIPSIZE_MODE, nsp_mode, &mode)== FAIL)
      return RET_BUG;
    gtk_label_set_ellipsize(GTK_LABEL(self->obj),mode);
  return 0;
}

static int _wrap_gtk_label_get_ellipsize(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_label_get_ellipsize(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_width_chars(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int n_chars;
  if ( GetArgs(stack,rhs,opt,T,&n_chars) == FAIL) return RET_BUG;
    gtk_label_set_width_chars(GTK_LABEL(self->obj),n_chars);
  return 0;
}

static int _wrap_gtk_label_get_width_chars(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_label_get_width_chars(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_max_width_chars(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int n_chars;
  if ( GetArgs(stack,rhs,opt,T,&n_chars) == FAIL) return RET_BUG;
    gtk_label_set_max_width_chars(GTK_LABEL(self->obj),n_chars);
  return 0;
}

static int _wrap_gtk_label_get_max_width_chars(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_label_get_max_width_chars(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_label_set_lines(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int lines;
  if ( GetArgs(stack,rhs,opt,T,&lines) == FAIL) return RET_BUG;
    gtk_label_set_lines(GTK_LABEL(self->obj),lines);
  return 0;
}

#else
int _wrap_gtk_label_set_lines(Stack stack, int rhs, int opt, int lhs) /* set_lines */
{
  Scierror("Error: function gtk_label_set_lines not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_label_get_lines(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_label_get_lines(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_label_get_lines(Stack stack, int rhs, int opt, int lhs) /* get_lines */
{
  Scierror("Error: function gtk_label_get_lines not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_label_set_pattern(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *pattern;
  if ( GetArgs(stack,rhs,opt,T,&pattern) == FAIL) return RET_BUG;
    gtk_label_set_pattern(GTK_LABEL(self->obj),pattern);
  return 0;
}

static int _wrap_gtk_label_set_line_wrap(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int wrap;
  if ( GetArgs(stack,rhs,opt,T,&wrap) == FAIL) return RET_BUG;
    gtk_label_set_line_wrap(GTK_LABEL(self->obj),wrap);
  return 0;
}

static int _wrap_gtk_label_get_line_wrap(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_label_get_line_wrap(GTK_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_line_wrap_mode(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  PangoWrapMode wrap_mode;
  NspObject *nsp_wrap_mode = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_wrap_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(PANGO_TYPE_WRAP_MODE, nsp_wrap_mode, &wrap_mode)== FAIL)
      return RET_BUG;
    gtk_label_set_line_wrap_mode(GTK_LABEL(self->obj),wrap_mode);
  return 0;
}

static int _wrap_gtk_label_get_line_wrap_mode(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_label_get_line_wrap_mode(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_selectable(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_label_set_selectable(GTK_LABEL(self->obj),setting);
  return 0;
}

static int _wrap_gtk_label_get_selectable(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_label_get_selectable(GTK_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_angle(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double angle;
  if ( GetArgs(stack,rhs,opt,T,&angle) == FAIL) return RET_BUG;
    gtk_label_set_angle(GTK_LABEL(self->obj),angle);
  return 0;
}

static int _wrap_gtk_label_get_angle(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_label_get_angle(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_select_region(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int start_offset, end_offset;
  if ( GetArgs(stack,rhs,opt,T,&start_offset, &end_offset) == FAIL) return RET_BUG;
    gtk_label_select_region(GTK_LABEL(self->obj),start_offset,end_offset);
  return 0;
}

#line 1218 "codegen-3.0/gtk.override"
static int
_wrap_gtk_label_get_selection_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int start, end;
  CheckRhs(0,0);
  CheckLhs(0,1);
  if (!gtk_label_get_selection_bounds(GTK_LABEL(self->obj), &start, &end))
    {
      if (  nsp_move_doubles(stack,1,0,0) == FAIL)
	return RET_BUG;
    }
  else
    {
      if (  nsp_move_doubles(stack,1,1,2,(double) start, (double) end) == FAIL)
	return RET_BUG;
    }
  return 1;
}
#line 24812 "gtk.c"


static int _wrap_gtk_label_get_layout(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoLayout *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_label_get_layout(GTK_LABEL(self->obj));
  nsp_type_pangolayout = new_type_pangolayout(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangolayout))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 1238 "codegen-3.0/gtk.override"
static int
_wrap_gtk_label_get_layout_offsets(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint x, y;
  gtk_label_get_layout_offsets(GTK_LABEL(self->obj), &x, &y);
  if (  nsp_move_doubles(stack,1,1,2,(double) x,(double) y) == FAIL)
    return RET_BUG;
  return 1;
}
#line 24837 "gtk.c"


static int _wrap_gtk_label_set_single_line_mode(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int single_line_mode;
  if ( GetArgs(stack,rhs,opt,T,&single_line_mode) == FAIL) return RET_BUG;
    gtk_label_set_single_line_mode(GTK_LABEL(self->obj),single_line_mode);
  return 0;
}

static int _wrap_gtk_label_get_single_line_mode(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_label_get_single_line_mode(GTK_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_get_current_uri(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_label_get_current_uri(GTK_LABEL(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_label_set_track_visited_links(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int track_links;
  if ( GetArgs(stack,rhs,opt,T,&track_links) == FAIL) return RET_BUG;
    gtk_label_set_track_visited_links(GTK_LABEL(self->obj),track_links);
  return 0;
}

static int _wrap_gtk_label_get_track_visited_links(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_label_get_track_visited_links(GTK_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_label_set_xalign(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double xalign;
  if ( GetArgs(stack,rhs,opt,T,&xalign) == FAIL) return RET_BUG;
    gtk_label_set_xalign(GTK_LABEL(self->obj),xalign);
  return 0;
}

#else
int _wrap_gtk_label_set_xalign(Stack stack, int rhs, int opt, int lhs) /* set_xalign */
{
  Scierror("Error: function gtk_label_set_xalign not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_label_get_xalign(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_label_get_xalign(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_label_get_xalign(Stack stack, int rhs, int opt, int lhs) /* get_xalign */
{
  Scierror("Error: function gtk_label_get_xalign not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_label_set_yalign(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double yalign;
  if ( GetArgs(stack,rhs,opt,T,&yalign) == FAIL) return RET_BUG;
    gtk_label_set_yalign(GTK_LABEL(self->obj),yalign);
  return 0;
}

#else
int _wrap_gtk_label_set_yalign(Stack stack, int rhs, int opt, int lhs) /* set_yalign */
{
  Scierror("Error: function gtk_label_set_yalign not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_label_get_yalign(NspGtkLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_label_get_yalign(GTK_LABEL(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_label_get_yalign(Stack stack, int rhs, int opt, int lhs) /* get_yalign */
{
  Scierror("Error: function gtk_label_get_yalign not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtklabel_methods[] = {
  {"set_text",(nsp_method *) _wrap_gtk_label_set_text},
  {"get_text",(nsp_method *) _wrap_gtk_label_get_text},
  {"set_attributes",(nsp_method *) _wrap_gtk_label_set_attributes},
  {"get_attributes",(nsp_method *) _wrap_gtk_label_get_attributes},
  {"set_label",(nsp_method *) _wrap_gtk_label_set_label},
  {"get_label",(nsp_method *) _wrap_gtk_label_get_label},
  {"set_markup",(nsp_method *) _wrap_gtk_label_set_markup},
  {"set_use_markup",(nsp_method *) _wrap_gtk_label_set_use_markup},
  {"get_use_markup",(nsp_method *) _wrap_gtk_label_get_use_markup},
  {"set_use_underline",(nsp_method *) _wrap_gtk_label_set_use_underline},
  {"get_use_underline",(nsp_method *) _wrap_gtk_label_get_use_underline},
  {"set_markup_with_mnemonic",(nsp_method *) _wrap_gtk_label_set_markup_with_mnemonic},
  {"get_mnemonic_keyval",(nsp_method *) _wrap_gtk_label_get_mnemonic_keyval},
  {"set_mnemonic_widget",(nsp_method *) _wrap_gtk_label_set_mnemonic_widget},
  {"get_mnemonic_widget",(nsp_method *) _wrap_gtk_label_get_mnemonic_widget},
  {"set_text_with_mnemonic",(nsp_method *) _wrap_gtk_label_set_text_with_mnemonic},
  {"set_justify",(nsp_method *) _wrap_gtk_label_set_justify},
  {"get_justify",(nsp_method *) _wrap_gtk_label_get_justify},
  {"set_ellipsize",(nsp_method *) _wrap_gtk_label_set_ellipsize},
  {"get_ellipsize",(nsp_method *) _wrap_gtk_label_get_ellipsize},
  {"set_width_chars",(nsp_method *) _wrap_gtk_label_set_width_chars},
  {"get_width_chars",(nsp_method *) _wrap_gtk_label_get_width_chars},
  {"set_max_width_chars",(nsp_method *) _wrap_gtk_label_set_max_width_chars},
  {"get_max_width_chars",(nsp_method *) _wrap_gtk_label_get_max_width_chars},
  {"set_lines",(nsp_method *) _wrap_gtk_label_set_lines},
  {"get_lines",(nsp_method *) _wrap_gtk_label_get_lines},
  {"set_pattern",(nsp_method *) _wrap_gtk_label_set_pattern},
  {"set_line_wrap",(nsp_method *) _wrap_gtk_label_set_line_wrap},
  {"get_line_wrap",(nsp_method *) _wrap_gtk_label_get_line_wrap},
  {"set_line_wrap_mode",(nsp_method *) _wrap_gtk_label_set_line_wrap_mode},
  {"get_line_wrap_mode",(nsp_method *) _wrap_gtk_label_get_line_wrap_mode},
  {"set_selectable",(nsp_method *) _wrap_gtk_label_set_selectable},
  {"get_selectable",(nsp_method *) _wrap_gtk_label_get_selectable},
  {"set_angle",(nsp_method *) _wrap_gtk_label_set_angle},
  {"get_angle",(nsp_method *) _wrap_gtk_label_get_angle},
  {"select_region",(nsp_method *) _wrap_gtk_label_select_region},
  {"get_selection_bounds",(nsp_method *) _wrap_gtk_label_get_selection_bounds},
  {"get_layout",(nsp_method *) _wrap_gtk_label_get_layout},
  {"get_layout_offsets",(nsp_method *) _wrap_gtk_label_get_layout_offsets},
  {"set_single_line_mode",(nsp_method *) _wrap_gtk_label_set_single_line_mode},
  {"get_single_line_mode",(nsp_method *) _wrap_gtk_label_get_single_line_mode},
  {"get_current_uri",(nsp_method *) _wrap_gtk_label_get_current_uri},
  {"set_track_visited_links",(nsp_method *) _wrap_gtk_label_set_track_visited_links},
  {"get_track_visited_links",(nsp_method *) _wrap_gtk_label_get_track_visited_links},
  {"set_xalign",(nsp_method *) _wrap_gtk_label_set_xalign},
  {"get_xalign",(nsp_method *) _wrap_gtk_label_get_xalign},
  {"set_yalign",(nsp_method *) _wrap_gtk_label_set_yalign},
  {"get_yalign",(nsp_method *) _wrap_gtk_label_get_yalign},
  { NULL, NULL}
};

static NspMethods *gtklabel_get_methods(void) { return gtklabel_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtklabel_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkImage ----------- */


#define  NspGtkImage_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkimage.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkImage inherits from GtkMisc 
 * and implements GtkBuildable
 */

int nsp_type_gtkimage_id=0;
NspTypeGtkImage *nsp_type_gtkimage=NULL;

/*
 * Type object for NspGtkImage 
 * all the instance of NspTypeGtkImage share the same id. 
 * nsp_type_gtkimage: is an instance of NspTypeGtkImage 
 *    used for objects of NspGtkImage type (i.e built with new_gtkimage) 
 * other instances are used for derived classes 
 */
NspTypeGtkImage *new_type_gtkimage(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkImage *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkimage != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkimage;
    }
  if (( type =  malloc(sizeof(NspTypeGtkMisc))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmisc(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkimage_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkimage_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkimage;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkimage */ 

  top->s_type =  (s_type_func *) nsp_gtkimage_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkimage_type_short_string;
  /* top->create = (create_func*) int_gtkimage_create;*/

  /* specific methods for gtkimage */

  type->init = (init_func *) init_gtkimage;

  /* 
   * NspGtkImage interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkimage_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkImage called nsp_type_gtkimage
       */
      type->id =  nsp_type_gtkimage_id = nsp_new_type_id();
      nsp_type_gtkimage = type;
      if ( nsp_register_type(nsp_type_gtkimage) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkimage, GTK_TYPE_IMAGE);
      return ( mode == T_BASE ) ? type : new_type_gtkimage(mode);
    }
  else 
    {
      type->id = nsp_type_gtkimage_id;
      return type;
    }
}

/*
 * initialize NspGtkImage instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkimage(NspGtkImage *Obj,NspTypeGtkImage *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkImage 
 */

NspGtkImage *new_gtkimage() 
{
  NspGtkImage *loc;
  /* type must exists */
  nsp_type_gtkimage = new_type_gtkimage(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkImage)))== NULLGTKIMAGE) return loc;
  /* initialize object */
  if ( init_gtkimage(loc,nsp_type_gtkimage) == FAIL) return NULLGTKIMAGE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkImage 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkimage_type_name[]="GtkImage";
static char gtkimage_short_type_name[]="GtkImage";

static char *nsp_gtkimage_type_as_string(void)
{
  return(gtkimage_type_name);
}

static char *nsp_gtkimage_type_short_string(NspObject *v)
{
  return(gtkimage_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkImage objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkImage   *nsp_gtkimage_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkimage_id)  == TRUE  ) return ((NspGtkImage *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkimage));
  return NULL;
}

int IsGtkImageObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkimage_id);
}

int IsGtkImage(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkimage_id);
}

NspGtkImage  *GetGtkImageCopy(Stack stack, int i)
{
  if (  GetGtkImage(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkImage  *GetGtkImage(Stack stack, int i)
{
  NspGtkImage *M;
  if (( M = nsp_gtkimage_object(NthObj(i))) == NULLGTKIMAGE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkImage *gtkimage_copy(NspGtkImage *self)
{
  /* return gtkmisc_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimage);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimage);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkImage
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_image_new_from_surface (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj, t_end};
  cairo_surface_t *surface = NULL;
  NspObject *nsp_surface = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_surface) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_surface, CAIRO_GOBJECT_TYPE_SURFACE))
      surface = nspg_boxed_get(nsp_surface, cairo_surface_t);
  else {
      Scierror( "Error: surface should be a cairo_surface_t\n");
      return RET_BUG;
  }
  if ((ret = (GObject *)gtk_image_new_from_surface(surface))== NULL) return RET_BUG;

  nsp_type_gtkimage = new_type_gtkimage(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_image_new_from_gicon (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *icon;
  GtkIconSize size;
  NspObject *nsp_size = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gicon, &icon, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_image_new_from_gicon(G_ICON(icon->obj),size))== NULL) return RET_BUG;

  nsp_type_gtkimage = new_type_gtkimage(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_image_new_from_icon_name (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *icon_name;
  GtkIconSize size;
  NspObject *nsp_size = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&icon_name, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_image_new_from_icon_name(icon_name,size))== NULL) return RET_BUG;

  nsp_type_gtkimage = new_type_gtkimage(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_image_new_from_animation (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *animation;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbufanimation, &animation) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_image_new_from_animation(GDK_PIXBUF_ANIMATION(animation->obj)))== NULL) return RET_BUG;

  nsp_type_gtkimage = new_type_gtkimage(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_image_new_from_pixbuf (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *pixbuf;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_image_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj)))== NULL) return RET_BUG;

  nsp_type_gtkimage = new_type_gtkimage(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_image_new_from_resource (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *resource_path;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&resource_path) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_image_new_from_resource(resource_path))== NULL) return RET_BUG;

  nsp_type_gtkimage = new_type_gtkimage(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_image_new_from_file (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *filename;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_image_new_from_file(filename))== NULL) return RET_BUG;

  nsp_type_gtkimage = new_type_gtkimage(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 4241 "codegen-3.0/gtk.override"

static const char *image_table[] = {
  "file",  "pixbuf",  "animation", "icon_name", "gicon", "resource", "surface", NULL};

typedef enum {
 FROM_file,
 FROM_pixbuf,
 FROM_animation,
 FROM_icon_name ,
 FROM_gicon,
 FROM_resource,
 FROM_surface}  image_from;

static int _wrap1_gtk_image_new_from_file(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,string,t_end};
  char *filename;
  NspObject *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&str,&filename) == FAIL) return RET_BUG;
  ret = gtk_image_new_from_file(filename);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap1_gtk_image_new_from_pixbuf(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,obj_check,t_end};
  NspGObject *pixbuf;
  NspObject *nsp_ret;
  GtkWidget *ret;
  if ( rhs == 1 )
    {
      ret = gtk_image_new_from_pixbuf(NULL);
    }
  else
    {
      if ( GetArgs(stack,rhs,opt,T,&str,&nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
      ret = gtk_image_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
    }
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap1_gtk_image_new_from_animation(Stack stack, int rhs, int opt, int lhs)
{
  char *str;
  int_types T[] = {string,obj_check,t_end};
  NspGObject *animation;
  NspObject *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&str,&nsp_type_gdkpixbufanimation, &animation) == FAIL) return RET_BUG;
    ret = gtk_image_new_from_animation(GDK_PIXBUF_ANIMATION(animation->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap1_gtk_image_new_from_icon_name(Stack stack, int rhs, int opt, int lhs)
{
  char *str,*icon_name;
  int_types T[] = {string,string,obj,t_end};
  GtkIconSize icon_size;
  NspObject *nsp_icon_size;
  NspObject *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&str,&icon_name,&nsp_icon_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_icon_size,&icon_size)== FAIL) return RET_BUG;
  ret = gtk_image_new_from_icon_name(icon_name, icon_size);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap1_gtk_image_new_from_gicon(Stack stack, int rhs, int opt, int lhs)
{
  Scierror("Error: to be done\n");
  return RET_BUG;
}

static int _wrap1_gtk_image_new_from_resource(Stack stack, int rhs, int opt, int lhs)
{
  char *str,*resource;
  int_types T[] = {string,string,t_end};
  NspObject *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&str,&resource) == FAIL) return RET_BUG;
  ret = gtk_image_new_from_resource(resource);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkimage))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap1_gtk_image_new_from_surface(Stack stack, int rhs, int opt, int lhs)
{
  Scierror("Error: to be done\n");
  return RET_BUG;
}

static int
_wrap_gtk_image_new(Stack stack, int rhs, int opt, int lhs)
{
  int rep;
  GObject *ret; NspObject *nsp_ret;

  if ( rhs == 0 )
    {
      if ((ret = (GObject *)gtk_image_new())== NULL) return RET_BUG;
      nsp_type_gtkimage = new_type_gtkimage(T_BASE);
      nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkimage );
      if ( nsp_ret == NULL) return RET_BUG;
      MoveObj(stack,1,nsp_ret);
      return 1;
    }
  else
    {
      if ((rep= GetStringInArray(stack,1,image_table,1)) == -1) return RET_BUG;
      switch (rep)
	{
	case FROM_file:  return _wrap1_gtk_image_new_from_file(stack,rhs,opt,lhs);
	case FROM_pixbuf:  return _wrap1_gtk_image_new_from_pixbuf(stack,rhs,opt,lhs);
	case FROM_animation: return _wrap1_gtk_image_new_from_animation(stack,rhs,opt,lhs);
	case FROM_icon_name : return _wrap1_gtk_image_new_from_icon_name(stack,rhs,opt,lhs);
	case FROM_gicon: return _wrap1_gtk_image_new_from_gicon(stack,rhs,opt,lhs);
	case FROM_resource: return _wrap1_gtk_image_new_from_resource(stack,rhs,opt,lhs);
	case FROM_surface: return _wrap1_gtk_image_new_from_surface(stack,rhs,opt,lhs);
      }
    }
  return RET_BUG;;
}
#line 25480 "gtk.c"


static int _wrap_gtk_image_clear(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_image_clear(GTK_IMAGE(self->obj));
  return 0;
}

static int _wrap_gtk_image_set_from_file(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *filename;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    gtk_image_set_from_file(GTK_IMAGE(self->obj),filename);
  return 0;
}

static int _wrap_gtk_image_set_from_resource(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *resource_path;
  if ( GetArgs(stack,rhs,opt,T,&resource_path) == FAIL) return RET_BUG;
    gtk_image_set_from_resource(GTK_IMAGE(self->obj),resource_path);
  return 0;
}

static int _wrap_gtk_image_set_from_pixbuf(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *pixbuf;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
    gtk_image_set_from_pixbuf(GTK_IMAGE(self->obj),GDK_PIXBUF(pixbuf->obj));
  return 0;
}

static int _wrap_gtk_image_set_from_animation(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *animation;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbufanimation, &animation) == FAIL) return RET_BUG;
    gtk_image_set_from_animation(GTK_IMAGE(self->obj),GDK_PIXBUF_ANIMATION(animation->obj));
  return 0;
}

static int _wrap_gtk_image_set_from_icon_name(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *icon_name;
  GtkIconSize size;
  NspObject *nsp_size = NULL;
  if ( GetArgs(stack,rhs,opt,T,&icon_name, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
    gtk_image_set_from_icon_name(GTK_IMAGE(self->obj),icon_name,size);
  return 0;
}

static int _wrap_gtk_image_set_from_gicon(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *icon;
  GtkIconSize size;
  NspObject *nsp_size = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gicon, &icon, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
    gtk_image_set_from_gicon(GTK_IMAGE(self->obj),G_ICON(icon->obj),size);
  return 0;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_image_set_from_surface(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  cairo_surface_t *surface = NULL;
  NspObject *nsp_surface = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_surface) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_surface, CAIRO_GOBJECT_TYPE_SURFACE))
      surface = nspg_boxed_get(nsp_surface, cairo_surface_t);
  else {
      Scierror( "Error: surface should be a cairo_surface_t\n");
      return RET_BUG;
  }
    gtk_image_set_from_surface(GTK_IMAGE(self->obj),surface);
  return 0;
}

#else
int _wrap_gtk_image_set_from_surface(Stack stack, int rhs, int opt, int lhs) /* set_from_surface */
{
  Scierror("Error: function gtk_image_set_from_surface not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_image_set_pixel_size(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int pixel_size;
  if ( GetArgs(stack,rhs,opt,T,&pixel_size) == FAIL) return RET_BUG;
    gtk_image_set_pixel_size(GTK_IMAGE(self->obj),pixel_size);
  return 0;
}

static int _wrap_gtk_image_get_storage_type(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_image_get_storage_type(GTK_IMAGE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_image_get_pixbuf(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_image_get_pixbuf(GTK_IMAGE(self->obj));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_image_get_animation(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbufAnimation *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_image_get_animation(GTK_IMAGE(self->obj));
  nsp_type_gdkpixbufanimation = new_type_gdkpixbufanimation(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbufanimation))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 4387 "codegen-3.0/gtk.override"

static int _wrap_gtk_image_get_icon_name(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *name;
  CheckRhs(0,0);
  CheckLhs(0,2);
  const gchar *icon_name;
  GtkIconSize size;
  gtk_image_get_icon_name(GTK_IMAGE(self->obj),&icon_name,&size);
  name = nsp_new_string_obj(NVOID,icon_name,-1);
  MoveObj(stack,1,name);
  if ( lhs == 2 ) {
    if ( nsp_move_double(stack,2,(double) size) == FAIL)
      return RET_BUG;
  }
  return Max(lhs,1);
}



#line 25639 "gtk.c"


static int _wrap_gtk_image_get_pixel_size(NspGtkImage *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_image_get_pixel_size(GTK_IMAGE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkimage_methods[] = {
  {"clear",(nsp_method *) _wrap_gtk_image_clear},
  {"set_from_file",(nsp_method *) _wrap_gtk_image_set_from_file},
  {"set_from_resource",(nsp_method *) _wrap_gtk_image_set_from_resource},
  {"set_from_pixbuf",(nsp_method *) _wrap_gtk_image_set_from_pixbuf},
  {"set_from_animation",(nsp_method *) _wrap_gtk_image_set_from_animation},
  {"set_from_icon_name",(nsp_method *) _wrap_gtk_image_set_from_icon_name},
  {"set_from_gicon",(nsp_method *) _wrap_gtk_image_set_from_gicon},
  {"set_from_surface",(nsp_method *) _wrap_gtk_image_set_from_surface},
  {"set_pixel_size",(nsp_method *) _wrap_gtk_image_set_pixel_size},
  {"get_storage_type",(nsp_method *) _wrap_gtk_image_get_storage_type},
  {"get_pixbuf",(nsp_method *) _wrap_gtk_image_get_pixbuf},
  {"get_animation",(nsp_method *) _wrap_gtk_image_get_animation},
  {"get_icon_name",(nsp_method *) _wrap_gtk_image_get_icon_name},
  {"get_pixel_size",(nsp_method *) _wrap_gtk_image_get_pixel_size},
  { NULL, NULL}
};

static NspMethods *gtkimage_get_methods(void) { return gtkimage_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkimage_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkSpinner ----------- */


#define  NspGtkSpinner_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkspinner.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkSpinner inherits from GtkWidget 
 * and implements GtkBuildable
 */

int nsp_type_gtkspinner_id=0;
NspTypeGtkSpinner *nsp_type_gtkspinner=NULL;

/*
 * Type object for NspGtkSpinner 
 * all the instance of NspTypeGtkSpinner share the same id. 
 * nsp_type_gtkspinner: is an instance of NspTypeGtkSpinner 
 *    used for objects of NspGtkSpinner type (i.e built with new_gtkspinner) 
 * other instances are used for derived classes 
 */
NspTypeGtkSpinner *new_type_gtkspinner(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkSpinner *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkspinner != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkspinner;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkspinner_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkspinner_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkspinner;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkspinner */ 

  top->s_type =  (s_type_func *) nsp_gtkspinner_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkspinner_type_short_string;
  /* top->create = (create_func*) int_gtkspinner_create;*/

  /* specific methods for gtkspinner */

  type->init = (init_func *) init_gtkspinner;

  /* 
   * NspGtkSpinner interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkspinner_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSpinner called nsp_type_gtkspinner
       */
      type->id =  nsp_type_gtkspinner_id = nsp_new_type_id();
      nsp_type_gtkspinner = type;
      if ( nsp_register_type(nsp_type_gtkspinner) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkspinner, GTK_TYPE_SPINNER);
      return ( mode == T_BASE ) ? type : new_type_gtkspinner(mode);
    }
  else 
    {
      type->id = nsp_type_gtkspinner_id;
      return type;
    }
}

/*
 * initialize NspGtkSpinner instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkspinner(NspGtkSpinner *Obj,NspTypeGtkSpinner *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkSpinner 
 */

NspGtkSpinner *new_gtkspinner() 
{
  NspGtkSpinner *loc;
  /* type must exists */
  nsp_type_gtkspinner = new_type_gtkspinner(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSpinner)))== NULLGTKSPINNER) return loc;
  /* initialize object */
  if ( init_gtkspinner(loc,nsp_type_gtkspinner) == FAIL) return NULLGTKSPINNER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkSpinner 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkspinner_type_name[]="GtkSpinner";
static char gtkspinner_short_type_name[]="GtkSpinner";

static char *nsp_gtkspinner_type_as_string(void)
{
  return(gtkspinner_type_name);
}

static char *nsp_gtkspinner_type_short_string(NspObject *v)
{
  return(gtkspinner_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkSpinner objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkSpinner   *nsp_gtkspinner_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkspinner_id)  == TRUE  ) return ((NspGtkSpinner *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkspinner));
  return NULL;
}

int IsGtkSpinnerObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkspinner_id);
}

int IsGtkSpinner(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkspinner_id);
}

NspGtkSpinner  *GetGtkSpinnerCopy(Stack stack, int i)
{
  if (  GetGtkSpinner(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSpinner  *GetGtkSpinner(Stack stack, int i)
{
  NspGtkSpinner *M;
  if (( M = nsp_gtkspinner_object(NthObj(i))) == NULLGTKSPINNER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSpinner *gtkspinner_copy(NspGtkSpinner *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkspinner);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkspinner);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSpinner
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_spinner_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_spinner_new())== NULL) return RET_BUG;

  nsp_type_gtkspinner = new_type_gtkspinner(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkspinner);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_spinner_start(NspGtkSpinner *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_spinner_start(GTK_SPINNER(self->obj));
  return 0;
}

static int _wrap_gtk_spinner_stop(NspGtkSpinner *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_spinner_stop(GTK_SPINNER(self->obj));
  return 0;
}

static NspMethods gtkspinner_methods[] = {
  {"start",(nsp_method *) _wrap_gtk_spinner_start},
  {"stop",(nsp_method *) _wrap_gtk_spinner_stop},
  { NULL, NULL}
};

static NspMethods *gtkspinner_get_methods(void) { return gtkspinner_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkspinner_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkInfoBar ----------- */


#define  NspGtkInfoBar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkinfobar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkInfoBar inherits from GtkBox 
 * and implements GtkBuildable
 */

int nsp_type_gtkinfobar_id=0;
NspTypeGtkInfoBar *nsp_type_gtkinfobar=NULL;

/*
 * Type object for NspGtkInfoBar 
 * all the instance of NspTypeGtkInfoBar share the same id. 
 * nsp_type_gtkinfobar: is an instance of NspTypeGtkInfoBar 
 *    used for objects of NspGtkInfoBar type (i.e built with new_gtkinfobar) 
 * other instances are used for derived classes 
 */
NspTypeGtkInfoBar *new_type_gtkinfobar(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkInfoBar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkinfobar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkinfobar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkinfobar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkinfobar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkinfobar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkinfobar */ 

  top->s_type =  (s_type_func *) nsp_gtkinfobar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkinfobar_type_short_string;
  /* top->create = (create_func*) int_gtkinfobar_create;*/

  /* specific methods for gtkinfobar */

  type->init = (init_func *) init_gtkinfobar;

  /* 
   * NspGtkInfoBar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkinfobar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkInfoBar called nsp_type_gtkinfobar
       */
      type->id =  nsp_type_gtkinfobar_id = nsp_new_type_id();
      nsp_type_gtkinfobar = type;
      if ( nsp_register_type(nsp_type_gtkinfobar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkinfobar, GTK_TYPE_INFO_BAR);
      return ( mode == T_BASE ) ? type : new_type_gtkinfobar(mode);
    }
  else 
    {
      type->id = nsp_type_gtkinfobar_id;
      return type;
    }
}

/*
 * initialize NspGtkInfoBar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkinfobar(NspGtkInfoBar *Obj,NspTypeGtkInfoBar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkInfoBar 
 */

NspGtkInfoBar *new_gtkinfobar() 
{
  NspGtkInfoBar *loc;
  /* type must exists */
  nsp_type_gtkinfobar = new_type_gtkinfobar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkInfoBar)))== NULLGTKINFOBAR) return loc;
  /* initialize object */
  if ( init_gtkinfobar(loc,nsp_type_gtkinfobar) == FAIL) return NULLGTKINFOBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkInfoBar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkinfobar_type_name[]="GtkInfoBar";
static char gtkinfobar_short_type_name[]="GtkInfoBar";

static char *nsp_gtkinfobar_type_as_string(void)
{
  return(gtkinfobar_type_name);
}

static char *nsp_gtkinfobar_type_short_string(NspObject *v)
{
  return(gtkinfobar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkInfoBar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkInfoBar   *nsp_gtkinfobar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkinfobar_id)  == TRUE  ) return ((NspGtkInfoBar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkinfobar));
  return NULL;
}

int IsGtkInfoBarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkinfobar_id);
}

int IsGtkInfoBar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkinfobar_id);
}

NspGtkInfoBar  *GetGtkInfoBarCopy(Stack stack, int i)
{
  if (  GetGtkInfoBar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkInfoBar  *GetGtkInfoBar(Stack stack, int i)
{
  NspGtkInfoBar *M;
  if (( M = nsp_gtkinfobar_object(NthObj(i))) == NULLGTKINFOBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkInfoBar *gtkinfobar_copy(NspGtkInfoBar *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkinfobar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkinfobar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkInfoBar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_info_bar_new_with_buttons (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *first_button_text;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&first_button_text) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_info_bar_new_with_buttons(first_button_text))== NULL) return RET_BUG;

  nsp_type_gtkinfobar = new_type_gtkinfobar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkinfobar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_info_bar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_info_bar_new())== NULL) return RET_BUG;

  nsp_type_gtkinfobar = new_type_gtkinfobar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkinfobar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_info_bar_get_action_area(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_info_bar_get_action_area(GTK_INFO_BAR(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_info_bar_get_content_area(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_info_bar_get_content_area(GTK_INFO_BAR(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_info_bar_add_action_widget(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *child;
  int response_id;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &response_id) == FAIL) return RET_BUG;
    gtk_info_bar_add_action_widget(GTK_INFO_BAR(self->obj),GTK_WIDGET(child->obj),response_id);
  return 0;
}

static int _wrap_gtk_info_bar_add_button(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int, t_end};
  char *button_text;
  int response_id;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&button_text, &response_id) == FAIL) return RET_BUG;
    ret =gtk_info_bar_add_button(GTK_INFO_BAR(self->obj),button_text,response_id);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_info_bar_add_buttons(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *first_button_text;
  if ( GetArgs(stack,rhs,opt,T,&first_button_text) == FAIL) return RET_BUG;
    gtk_info_bar_add_buttons(GTK_INFO_BAR(self->obj),first_button_text);
  return 0;
}

static int _wrap_gtk_info_bar_set_response_sensitive(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_bool, t_end};
  int response_id, setting;
  if ( GetArgs(stack,rhs,opt,T,&response_id, &setting) == FAIL) return RET_BUG;
    gtk_info_bar_set_response_sensitive(GTK_INFO_BAR(self->obj),response_id,setting);
  return 0;
}

static int _wrap_gtk_info_bar_set_default_response(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int response_id;
  if ( GetArgs(stack,rhs,opt,T,&response_id) == FAIL) return RET_BUG;
    gtk_info_bar_set_default_response(GTK_INFO_BAR(self->obj),response_id);
  return 0;
}

static int _wrap_gtk_info_bar_response(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int response_id;
  if ( GetArgs(stack,rhs,opt,T,&response_id) == FAIL) return RET_BUG;
    gtk_info_bar_response(GTK_INFO_BAR(self->obj),response_id);
  return 0;
}

static int _wrap_gtk_info_bar_set_message_type(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkMessageType message_type;
  NspObject *nsp_message_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_message_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_MESSAGE_TYPE, nsp_message_type, &message_type)== FAIL)
      return RET_BUG;
    gtk_info_bar_set_message_type(GTK_INFO_BAR(self->obj),message_type);
  return 0;
}

static int _wrap_gtk_info_bar_get_message_type(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_info_bar_get_message_type(GTK_INFO_BAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_info_bar_set_show_close_button(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_info_bar_set_show_close_button(GTK_INFO_BAR(self->obj),setting);
  return 0;
}

#else
int _wrap_gtk_info_bar_set_show_close_button(Stack stack, int rhs, int opt, int lhs) /* set_show_close_button */
{
  Scierror("Error: function gtk_info_bar_set_show_close_button not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_info_bar_get_show_close_button(NspGtkInfoBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_info_bar_get_show_close_button(GTK_INFO_BAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_info_bar_get_show_close_button(Stack stack, int rhs, int opt, int lhs) /* get_show_close_button */
{
  Scierror("Error: function gtk_info_bar_get_show_close_button not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkinfobar_methods[] = {
  {"get_action_area",(nsp_method *) _wrap_gtk_info_bar_get_action_area},
  {"get_content_area",(nsp_method *) _wrap_gtk_info_bar_get_content_area},
  {"add_action_widget",(nsp_method *) _wrap_gtk_info_bar_add_action_widget},
  {"add_button",(nsp_method *) _wrap_gtk_info_bar_add_button},
  {"add_buttons",(nsp_method *) _wrap_gtk_info_bar_add_buttons},
  {"set_response_sensitive",(nsp_method *) _wrap_gtk_info_bar_set_response_sensitive},
  {"set_default_response",(nsp_method *) _wrap_gtk_info_bar_set_default_response},
  {"response",(nsp_method *) _wrap_gtk_info_bar_response},
  {"set_message_type",(nsp_method *) _wrap_gtk_info_bar_set_message_type},
  {"get_message_type",(nsp_method *) _wrap_gtk_info_bar_get_message_type},
  {"set_show_close_button",(nsp_method *) _wrap_gtk_info_bar_set_show_close_button},
  {"get_show_close_button",(nsp_method *) _wrap_gtk_info_bar_get_show_close_button},
  { NULL, NULL}
};

static NspMethods *gtkinfobar_get_methods(void) { return gtkinfobar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkinfobar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkProgressBar ----------- */


#define  NspGtkProgressBar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkprogressbar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkProgressBar inherits from GtkWidget 
 * and implements GtkOrientable GtkBuildable
 */

int nsp_type_gtkprogressbar_id=0;
NspTypeGtkProgressBar *nsp_type_gtkprogressbar=NULL;

/*
 * Type object for NspGtkProgressBar 
 * all the instance of NspTypeGtkProgressBar share the same id. 
 * nsp_type_gtkprogressbar: is an instance of NspTypeGtkProgressBar 
 *    used for objects of NspGtkProgressBar type (i.e built with new_gtkprogressbar) 
 * other instances are used for derived classes 
 */
NspTypeGtkProgressBar *new_type_gtkprogressbar(type_mode mode)
{
  NspTypeGtkOrientable *t_gtkorientable;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkProgressBar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkprogressbar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkprogressbar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkprogressbar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkprogressbar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkprogressbar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkprogressbar */ 

  top->s_type =  (s_type_func *) nsp_gtkprogressbar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkprogressbar_type_short_string;
  /* top->create = (create_func*) int_gtkprogressbar_create;*/

  /* specific methods for gtkprogressbar */

  type->init = (init_func *) init_gtkprogressbar;

  /* 
   * NspGtkProgressBar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkorientable = new_type_gtkorientable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkorientable;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkprogressbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkProgressBar called nsp_type_gtkprogressbar
       */
      type->id =  nsp_type_gtkprogressbar_id = nsp_new_type_id();
      nsp_type_gtkprogressbar = type;
      if ( nsp_register_type(nsp_type_gtkprogressbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkprogressbar, GTK_TYPE_PROGRESS_BAR);
      return ( mode == T_BASE ) ? type : new_type_gtkprogressbar(mode);
    }
  else 
    {
      type->id = nsp_type_gtkprogressbar_id;
      return type;
    }
}

/*
 * initialize NspGtkProgressBar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkprogressbar(NspGtkProgressBar *Obj,NspTypeGtkProgressBar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkProgressBar 
 */

NspGtkProgressBar *new_gtkprogressbar() 
{
  NspGtkProgressBar *loc;
  /* type must exists */
  nsp_type_gtkprogressbar = new_type_gtkprogressbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkProgressBar)))== NULLGTKPROGRESSBAR) return loc;
  /* initialize object */
  if ( init_gtkprogressbar(loc,nsp_type_gtkprogressbar) == FAIL) return NULLGTKPROGRESSBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkProgressBar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkprogressbar_type_name[]="GtkProgressBar";
static char gtkprogressbar_short_type_name[]="GtkProgressBar";

static char *nsp_gtkprogressbar_type_as_string(void)
{
  return(gtkprogressbar_type_name);
}

static char *nsp_gtkprogressbar_type_short_string(NspObject *v)
{
  return(gtkprogressbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkProgressBar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkProgressBar   *nsp_gtkprogressbar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkprogressbar_id)  == TRUE  ) return ((NspGtkProgressBar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkprogressbar));
  return NULL;
}

int IsGtkProgressBarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkprogressbar_id);
}

int IsGtkProgressBar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkprogressbar_id);
}

NspGtkProgressBar  *GetGtkProgressBarCopy(Stack stack, int i)
{
  if (  GetGtkProgressBar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkProgressBar  *GetGtkProgressBar(Stack stack, int i)
{
  NspGtkProgressBar *M;
  if (( M = nsp_gtkprogressbar_object(NthObj(i))) == NULLGTKPROGRESSBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkProgressBar *gtkprogressbar_copy(NspGtkProgressBar *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprogressbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprogressbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkProgressBar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_progress_bar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_progress_bar_new())== NULL) return RET_BUG;

  nsp_type_gtkprogressbar = new_type_gtkprogressbar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkprogressbar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_progress_bar_pulse(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_progress_bar_pulse(GTK_PROGRESS_BAR(self->obj));
  return 0;
}

static int _wrap_gtk_progress_bar_set_text(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    gtk_progress_bar_set_text(GTK_PROGRESS_BAR(self->obj),text);
  return 0;
}

static int _wrap_gtk_progress_bar_set_fraction(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double fraction;
  if ( GetArgs(stack,rhs,opt,T,&fraction) == FAIL) return RET_BUG;
    gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(self->obj),fraction);
  return 0;
}

static int _wrap_gtk_progress_bar_set_pulse_step(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double fraction;
  if ( GetArgs(stack,rhs,opt,T,&fraction) == FAIL) return RET_BUG;
    gtk_progress_bar_set_pulse_step(GTK_PROGRESS_BAR(self->obj),fraction);
  return 0;
}

static int _wrap_gtk_progress_bar_set_inverted(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int inverted;
  if ( GetArgs(stack,rhs,opt,T,&inverted) == FAIL) return RET_BUG;
    gtk_progress_bar_set_inverted(GTK_PROGRESS_BAR(self->obj),inverted);
  return 0;
}

static int _wrap_gtk_progress_bar_get_text(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_progress_bar_get_text(GTK_PROGRESS_BAR(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_progress_bar_get_fraction(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_progress_bar_get_fraction(GTK_PROGRESS_BAR(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_progress_bar_get_pulse_step(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_progress_bar_get_pulse_step(GTK_PROGRESS_BAR(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_progress_bar_get_inverted(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_progress_bar_get_inverted(GTK_PROGRESS_BAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_progress_bar_set_ellipsize(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  PangoEllipsizeMode mode;
  NspObject *nsp_mode = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(PANGO_TYPE_ELLIPSIZE_MODE, nsp_mode, &mode)== FAIL)
      return RET_BUG;
    gtk_progress_bar_set_ellipsize(GTK_PROGRESS_BAR(self->obj),mode);
  return 0;
}

static int _wrap_gtk_progress_bar_get_ellipsize(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_progress_bar_get_ellipsize(GTK_PROGRESS_BAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_progress_bar_set_show_text(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_text;
  if ( GetArgs(stack,rhs,opt,T,&show_text) == FAIL) return RET_BUG;
    gtk_progress_bar_set_show_text(GTK_PROGRESS_BAR(self->obj),show_text);
  return 0;
}

static int _wrap_gtk_progress_bar_get_show_text(NspGtkProgressBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_progress_bar_get_show_text(GTK_PROGRESS_BAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkprogressbar_methods[] = {
  {"pulse",(nsp_method *) _wrap_gtk_progress_bar_pulse},
  {"set_text",(nsp_method *) _wrap_gtk_progress_bar_set_text},
  {"set_fraction",(nsp_method *) _wrap_gtk_progress_bar_set_fraction},
  {"set_pulse_step",(nsp_method *) _wrap_gtk_progress_bar_set_pulse_step},
  {"set_inverted",(nsp_method *) _wrap_gtk_progress_bar_set_inverted},
  {"get_text",(nsp_method *) _wrap_gtk_progress_bar_get_text},
  {"get_fraction",(nsp_method *) _wrap_gtk_progress_bar_get_fraction},
  {"get_pulse_step",(nsp_method *) _wrap_gtk_progress_bar_get_pulse_step},
  {"get_inverted",(nsp_method *) _wrap_gtk_progress_bar_get_inverted},
  {"set_ellipsize",(nsp_method *) _wrap_gtk_progress_bar_set_ellipsize},
  {"get_ellipsize",(nsp_method *) _wrap_gtk_progress_bar_get_ellipsize},
  {"set_show_text",(nsp_method *) _wrap_gtk_progress_bar_set_show_text},
  {"get_show_text",(nsp_method *) _wrap_gtk_progress_bar_get_show_text},
  { NULL, NULL}
};

static NspMethods *gtkprogressbar_get_methods(void) { return gtkprogressbar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkprogressbar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkLevelBar ----------- */


#define  NspGtkLevelBar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtklevelbar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkLevelBar inherits from GtkWidget 
 * and implements GtkBuildable
 */

int nsp_type_gtklevelbar_id=0;
NspTypeGtkLevelBar *nsp_type_gtklevelbar=NULL;

/*
 * Type object for NspGtkLevelBar 
 * all the instance of NspTypeGtkLevelBar share the same id. 
 * nsp_type_gtklevelbar: is an instance of NspTypeGtkLevelBar 
 *    used for objects of NspGtkLevelBar type (i.e built with new_gtklevelbar) 
 * other instances are used for derived classes 
 */
NspTypeGtkLevelBar *new_type_gtklevelbar(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkLevelBar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtklevelbar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtklevelbar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtklevelbar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtklevelbar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtklevelbar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtklevelbar */ 

  top->s_type =  (s_type_func *) nsp_gtklevelbar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtklevelbar_type_short_string;
  /* top->create = (create_func*) int_gtklevelbar_create;*/

  /* specific methods for gtklevelbar */

  type->init = (init_func *) init_gtklevelbar;

  /* 
   * NspGtkLevelBar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtklevelbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkLevelBar called nsp_type_gtklevelbar
       */
      type->id =  nsp_type_gtklevelbar_id = nsp_new_type_id();
      nsp_type_gtklevelbar = type;
      if ( nsp_register_type(nsp_type_gtklevelbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtklevelbar, GTK_TYPE_LEVEL_BAR);
      return ( mode == T_BASE ) ? type : new_type_gtklevelbar(mode);
    }
  else 
    {
      type->id = nsp_type_gtklevelbar_id;
      return type;
    }
}

/*
 * initialize NspGtkLevelBar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtklevelbar(NspGtkLevelBar *Obj,NspTypeGtkLevelBar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkLevelBar 
 */

NspGtkLevelBar *new_gtklevelbar() 
{
  NspGtkLevelBar *loc;
  /* type must exists */
  nsp_type_gtklevelbar = new_type_gtklevelbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkLevelBar)))== NULLGTKLEVELBAR) return loc;
  /* initialize object */
  if ( init_gtklevelbar(loc,nsp_type_gtklevelbar) == FAIL) return NULLGTKLEVELBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkLevelBar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtklevelbar_type_name[]="GtkLevelBar";
static char gtklevelbar_short_type_name[]="GtkLevelBar";

static char *nsp_gtklevelbar_type_as_string(void)
{
  return(gtklevelbar_type_name);
}

static char *nsp_gtklevelbar_type_short_string(NspObject *v)
{
  return(gtklevelbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkLevelBar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkLevelBar   *nsp_gtklevelbar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtklevelbar_id)  == TRUE  ) return ((NspGtkLevelBar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtklevelbar));
  return NULL;
}

int IsGtkLevelBarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtklevelbar_id);
}

int IsGtkLevelBar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtklevelbar_id);
}

NspGtkLevelBar  *GetGtkLevelBarCopy(Stack stack, int i)
{
  if (  GetGtkLevelBar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkLevelBar  *GetGtkLevelBar(Stack stack, int i)
{
  NspGtkLevelBar *M;
  if (( M = nsp_gtklevelbar_object(NthObj(i))) == NULLGTKLEVELBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkLevelBar *gtklevelbar_copy(NspGtkLevelBar *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklevelbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklevelbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkLevelBar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_level_bar_new_for_interval (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_double,s_double, t_end};
  double min_value, max_value;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&min_value, &max_value) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_level_bar_new_for_interval(min_value,max_value))== NULL) return RET_BUG;

  nsp_type_gtklevelbar = new_type_gtklevelbar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtklevelbar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_level_bar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_level_bar_new())== NULL) return RET_BUG;

  nsp_type_gtklevelbar = new_type_gtklevelbar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtklevelbar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_level_bar_set_mode(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkLevelBarMode mode;
  NspObject *nsp_mode = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_LEVEL_BAR_MODE, nsp_mode, &mode)== FAIL)
      return RET_BUG;
    gtk_level_bar_set_mode(GTK_LEVEL_BAR(self->obj),mode);
  return 0;
}

#else
int _wrap_gtk_level_bar_set_mode(Stack stack, int rhs, int opt, int lhs) /* set_mode */
{
  Scierror("Error: function gtk_level_bar_set_mode not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_level_bar_get_mode(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_level_bar_get_mode(GTK_LEVEL_BAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_level_bar_get_mode(Stack stack, int rhs, int opt, int lhs) /* get_mode */
{
  Scierror("Error: function gtk_level_bar_get_mode not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_level_bar_set_value(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double value;
  if ( GetArgs(stack,rhs,opt,T,&value) == FAIL) return RET_BUG;
    gtk_level_bar_set_value(GTK_LEVEL_BAR(self->obj),value);
  return 0;
}

#else
int _wrap_gtk_level_bar_set_value(Stack stack, int rhs, int opt, int lhs) /* set_value */
{
  Scierror("Error: function gtk_level_bar_set_value not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_level_bar_get_value(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_level_bar_get_value(GTK_LEVEL_BAR(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_level_bar_get_value(Stack stack, int rhs, int opt, int lhs) /* get_value */
{
  Scierror("Error: function gtk_level_bar_get_value not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_level_bar_set_min_value(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double value;
  if ( GetArgs(stack,rhs,opt,T,&value) == FAIL) return RET_BUG;
    gtk_level_bar_set_min_value(GTK_LEVEL_BAR(self->obj),value);
  return 0;
}

#else
int _wrap_gtk_level_bar_set_min_value(Stack stack, int rhs, int opt, int lhs) /* set_min_value */
{
  Scierror("Error: function gtk_level_bar_set_min_value not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_level_bar_get_min_value(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_level_bar_get_min_value(GTK_LEVEL_BAR(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_level_bar_get_min_value(Stack stack, int rhs, int opt, int lhs) /* get_min_value */
{
  Scierror("Error: function gtk_level_bar_get_min_value not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_level_bar_set_max_value(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double value;
  if ( GetArgs(stack,rhs,opt,T,&value) == FAIL) return RET_BUG;
    gtk_level_bar_set_max_value(GTK_LEVEL_BAR(self->obj),value);
  return 0;
}

#else
int _wrap_gtk_level_bar_set_max_value(Stack stack, int rhs, int opt, int lhs) /* set_max_value */
{
  Scierror("Error: function gtk_level_bar_set_max_value not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_level_bar_get_max_value(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_level_bar_get_max_value(GTK_LEVEL_BAR(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_level_bar_get_max_value(Stack stack, int rhs, int opt, int lhs) /* get_max_value */
{
  Scierror("Error: function gtk_level_bar_get_max_value not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_level_bar_set_inverted(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int inverted;
  if ( GetArgs(stack,rhs,opt,T,&inverted) == FAIL) return RET_BUG;
    gtk_level_bar_set_inverted(GTK_LEVEL_BAR(self->obj),inverted);
  return 0;
}

#else
int _wrap_gtk_level_bar_set_inverted(Stack stack, int rhs, int opt, int lhs) /* set_inverted */
{
  Scierror("Error: function gtk_level_bar_set_inverted not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_level_bar_get_inverted(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_level_bar_get_inverted(GTK_LEVEL_BAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_level_bar_get_inverted(Stack stack, int rhs, int opt, int lhs) /* get_inverted */
{
  Scierror("Error: function gtk_level_bar_get_inverted not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_level_bar_add_offset_value(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_double, t_end};
  char *name;
  double value;
  if ( GetArgs(stack,rhs,opt,T,&name, &value) == FAIL) return RET_BUG;
    gtk_level_bar_add_offset_value(GTK_LEVEL_BAR(self->obj),name,value);
  return 0;
}

#else
int _wrap_gtk_level_bar_add_offset_value(Stack stack, int rhs, int opt, int lhs) /* add_offset_value */
{
  Scierror("Error: function gtk_level_bar_add_offset_value not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_level_bar_remove_offset_value(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_level_bar_remove_offset_value(GTK_LEVEL_BAR(self->obj),name);
  return 0;
}

#else
int _wrap_gtk_level_bar_remove_offset_value(Stack stack, int rhs, int opt, int lhs) /* remove_offset_value */
{
  Scierror("Error: function gtk_level_bar_remove_offset_value not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_level_bar_get_offset_value(NspGtkLevelBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_double, t_end};
  char *name;
  double value;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&name, &value) == FAIL) return RET_BUG;
    ret =gtk_level_bar_get_offset_value(GTK_LEVEL_BAR(self->obj),name,&value);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_level_bar_get_offset_value(Stack stack, int rhs, int opt, int lhs) /* get_offset_value */
{
  Scierror("Error: function gtk_level_bar_get_offset_value not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtklevelbar_methods[] = {
  {"set_mode",(nsp_method *) _wrap_gtk_level_bar_set_mode},
  {"get_mode",(nsp_method *) _wrap_gtk_level_bar_get_mode},
  {"set_value",(nsp_method *) _wrap_gtk_level_bar_set_value},
  {"get_value",(nsp_method *) _wrap_gtk_level_bar_get_value},
  {"set_min_value",(nsp_method *) _wrap_gtk_level_bar_set_min_value},
  {"get_min_value",(nsp_method *) _wrap_gtk_level_bar_get_min_value},
  {"set_max_value",(nsp_method *) _wrap_gtk_level_bar_set_max_value},
  {"get_max_value",(nsp_method *) _wrap_gtk_level_bar_get_max_value},
  {"set_inverted",(nsp_method *) _wrap_gtk_level_bar_set_inverted},
  {"get_inverted",(nsp_method *) _wrap_gtk_level_bar_get_inverted},
  {"add_offset_value",(nsp_method *) _wrap_gtk_level_bar_add_offset_value},
  {"remove_offset_value",(nsp_method *) _wrap_gtk_level_bar_remove_offset_value},
  {"get_offset_value",(nsp_method *) _wrap_gtk_level_bar_get_offset_value},
  { NULL, NULL}
};

static NspMethods *gtklevelbar_get_methods(void) { return gtklevelbar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtklevelbar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkStatusbar ----------- */


#define  NspGtkStatusbar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkstatusbar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkStatusbar inherits from GtkBox 
 * and implements GtkBuildable
 */

int nsp_type_gtkstatusbar_id=0;
NspTypeGtkStatusbar *nsp_type_gtkstatusbar=NULL;

/*
 * Type object for NspGtkStatusbar 
 * all the instance of NspTypeGtkStatusbar share the same id. 
 * nsp_type_gtkstatusbar: is an instance of NspTypeGtkStatusbar 
 *    used for objects of NspGtkStatusbar type (i.e built with new_gtkstatusbar) 
 * other instances are used for derived classes 
 */
NspTypeGtkStatusbar *new_type_gtkstatusbar(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkStatusbar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkstatusbar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkstatusbar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkstatusbar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkstatusbar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkstatusbar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkstatusbar */ 

  top->s_type =  (s_type_func *) nsp_gtkstatusbar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkstatusbar_type_short_string;
  /* top->create = (create_func*) int_gtkstatusbar_create;*/

  /* specific methods for gtkstatusbar */

  type->init = (init_func *) init_gtkstatusbar;

  /* 
   * NspGtkStatusbar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkstatusbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkStatusbar called nsp_type_gtkstatusbar
       */
      type->id =  nsp_type_gtkstatusbar_id = nsp_new_type_id();
      nsp_type_gtkstatusbar = type;
      if ( nsp_register_type(nsp_type_gtkstatusbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkstatusbar, GTK_TYPE_STATUSBAR);
      return ( mode == T_BASE ) ? type : new_type_gtkstatusbar(mode);
    }
  else 
    {
      type->id = nsp_type_gtkstatusbar_id;
      return type;
    }
}

/*
 * initialize NspGtkStatusbar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkstatusbar(NspGtkStatusbar *Obj,NspTypeGtkStatusbar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkStatusbar 
 */

NspGtkStatusbar *new_gtkstatusbar() 
{
  NspGtkStatusbar *loc;
  /* type must exists */
  nsp_type_gtkstatusbar = new_type_gtkstatusbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkStatusbar)))== NULLGTKSTATUSBAR) return loc;
  /* initialize object */
  if ( init_gtkstatusbar(loc,nsp_type_gtkstatusbar) == FAIL) return NULLGTKSTATUSBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkStatusbar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkstatusbar_type_name[]="GtkStatusbar";
static char gtkstatusbar_short_type_name[]="GtkStatusbar";

static char *nsp_gtkstatusbar_type_as_string(void)
{
  return(gtkstatusbar_type_name);
}

static char *nsp_gtkstatusbar_type_short_string(NspObject *v)
{
  return(gtkstatusbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkStatusbar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkStatusbar   *nsp_gtkstatusbar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkstatusbar_id)  == TRUE  ) return ((NspGtkStatusbar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkstatusbar));
  return NULL;
}

int IsGtkStatusbarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkstatusbar_id);
}

int IsGtkStatusbar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkstatusbar_id);
}

NspGtkStatusbar  *GetGtkStatusbarCopy(Stack stack, int i)
{
  if (  GetGtkStatusbar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkStatusbar  *GetGtkStatusbar(Stack stack, int i)
{
  NspGtkStatusbar *M;
  if (( M = nsp_gtkstatusbar_object(NthObj(i))) == NULLGTKSTATUSBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkStatusbar *gtkstatusbar_copy(NspGtkStatusbar *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstatusbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstatusbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkStatusbar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_statusbar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_statusbar_new())== NULL) return RET_BUG;

  nsp_type_gtkstatusbar = new_type_gtkstatusbar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstatusbar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_statusbar_get_context_id(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *context_description;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&context_description) == FAIL) return RET_BUG;
    ret =gtk_statusbar_get_context_id(GTK_STATUSBAR(self->obj),context_description);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_statusbar_push(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,string, t_end};
  int context_id, ret;
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&context_id, &text) == FAIL) return RET_BUG;
    ret =gtk_statusbar_push(GTK_STATUSBAR(self->obj),context_id,text);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_statusbar_pop(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int context_id;
  if ( GetArgs(stack,rhs,opt,T,&context_id) == FAIL) return RET_BUG;
    gtk_statusbar_pop(GTK_STATUSBAR(self->obj),context_id);
  return 0;
}

static int _wrap_gtk_statusbar_remove(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int context_id, message_id;
  if ( GetArgs(stack,rhs,opt,T,&context_id, &message_id) == FAIL) return RET_BUG;
    gtk_statusbar_remove(GTK_STATUSBAR(self->obj),context_id,message_id);
  return 0;
}

static int _wrap_gtk_statusbar_remove_all(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int context_id;
  if ( GetArgs(stack,rhs,opt,T,&context_id) == FAIL) return RET_BUG;
    gtk_statusbar_remove_all(GTK_STATUSBAR(self->obj),context_id);
  return 0;
}

static int _wrap_gtk_statusbar_get_message_area(NspGtkStatusbar *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_statusbar_get_message_area(GTK_STATUSBAR(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkstatusbar_methods[] = {
  {"get_context_id",(nsp_method *) _wrap_gtk_statusbar_get_context_id},
  {"push",(nsp_method *) _wrap_gtk_statusbar_push},
  {"pop",(nsp_method *) _wrap_gtk_statusbar_pop},
  {"remove",(nsp_method *) _wrap_gtk_statusbar_remove},
  {"remove_all",(nsp_method *) _wrap_gtk_statusbar_remove_all},
  {"get_message_area",(nsp_method *) _wrap_gtk_statusbar_get_message_area},
  { NULL, NULL}
};

static NspMethods *gtkstatusbar_get_methods(void) { return gtkstatusbar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkstatusbar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAccelLabel ----------- */


#define  NspGtkAccelLabel_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkaccellabel.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAccelLabel inherits from GtkLabel 
 * and implements GtkBuildable
 */

int nsp_type_gtkaccellabel_id=0;
NspTypeGtkAccelLabel *nsp_type_gtkaccellabel=NULL;

/*
 * Type object for NspGtkAccelLabel 
 * all the instance of NspTypeGtkAccelLabel share the same id. 
 * nsp_type_gtkaccellabel: is an instance of NspTypeGtkAccelLabel 
 *    used for objects of NspGtkAccelLabel type (i.e built with new_gtkaccellabel) 
 * other instances are used for derived classes 
 */
NspTypeGtkAccelLabel *new_type_gtkaccellabel(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkAccelLabel *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkaccellabel != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkaccellabel;
    }
  if (( type =  malloc(sizeof(NspTypeGtkLabel))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtklabel(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkaccellabel_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkaccellabel_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkaccellabel;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkaccellabel */ 

  top->s_type =  (s_type_func *) nsp_gtkaccellabel_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkaccellabel_type_short_string;
  /* top->create = (create_func*) int_gtkaccellabel_create;*/

  /* specific methods for gtkaccellabel */

  type->init = (init_func *) init_gtkaccellabel;

  /* 
   * NspGtkAccelLabel interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkaccellabel_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAccelLabel called nsp_type_gtkaccellabel
       */
      type->id =  nsp_type_gtkaccellabel_id = nsp_new_type_id();
      nsp_type_gtkaccellabel = type;
      if ( nsp_register_type(nsp_type_gtkaccellabel) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkaccellabel, GTK_TYPE_ACCEL_LABEL);
      return ( mode == T_BASE ) ? type : new_type_gtkaccellabel(mode);
    }
  else 
    {
      type->id = nsp_type_gtkaccellabel_id;
      return type;
    }
}

/*
 * initialize NspGtkAccelLabel instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkaccellabel(NspGtkAccelLabel *Obj,NspTypeGtkAccelLabel *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAccelLabel 
 */

NspGtkAccelLabel *new_gtkaccellabel() 
{
  NspGtkAccelLabel *loc;
  /* type must exists */
  nsp_type_gtkaccellabel = new_type_gtkaccellabel(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAccelLabel)))== NULLGTKACCELLABEL) return loc;
  /* initialize object */
  if ( init_gtkaccellabel(loc,nsp_type_gtkaccellabel) == FAIL) return NULLGTKACCELLABEL;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAccelLabel 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkaccellabel_type_name[]="GtkAccelLabel";
static char gtkaccellabel_short_type_name[]="GtkAccelLabel";

static char *nsp_gtkaccellabel_type_as_string(void)
{
  return(gtkaccellabel_type_name);
}

static char *nsp_gtkaccellabel_type_short_string(NspObject *v)
{
  return(gtkaccellabel_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAccelLabel objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAccelLabel   *nsp_gtkaccellabel_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkaccellabel_id)  == TRUE  ) return ((NspGtkAccelLabel *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkaccellabel));
  return NULL;
}

int IsGtkAccelLabelObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkaccellabel_id);
}

int IsGtkAccelLabel(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkaccellabel_id);
}

NspGtkAccelLabel  *GetGtkAccelLabelCopy(Stack stack, int i)
{
  if (  GetGtkAccelLabel(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAccelLabel  *GetGtkAccelLabel(Stack stack, int i)
{
  NspGtkAccelLabel *M;
  if (( M = nsp_gtkaccellabel_object(NthObj(i))) == NULLGTKACCELLABEL)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAccelLabel *gtkaccellabel_copy(NspGtkAccelLabel *self)
{
  /* return gtklabel_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccellabel);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccellabel);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAccelLabel
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_accel_label_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"string",string,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  char *string = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &string) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_accel_label_new(string))== NULL) return RET_BUG;

  nsp_type_gtkaccellabel = new_type_gtkaccellabel(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkaccellabel);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_accel_label_get_accel_widget(NspGtkAccelLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_accel_label_get_accel_widget(GTK_ACCEL_LABEL(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_accel_label_get_accel_width(NspGtkAccelLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_accel_label_get_accel_width(GTK_ACCEL_LABEL(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_accel_label_set_accel_widget(NspGtkAccelLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *accel_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &accel_widget) == FAIL) return RET_BUG;
    gtk_accel_label_set_accel_widget(GTK_ACCEL_LABEL(self->obj),GTK_WIDGET(accel_widget->obj));
  return 0;
}

static int _wrap_gtk_accel_label_refetch(NspGtkAccelLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_accel_label_refetch(GTK_ACCEL_LABEL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_accel_label_set_accel(NspGtkAccelLabel *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,obj, t_end};
  int accelerator_key;
  GdkModifierType accelerator_mods;
  NspObject *nsp_accelerator_mods = NULL;
  if ( GetArgs(stack,rhs,opt,T,&accelerator_key, &nsp_accelerator_mods) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accelerator_mods, &accelerator_mods)==FAIL)
      return RET_BUG;
    gtk_accel_label_set_accel(GTK_ACCEL_LABEL(self->obj),accelerator_key,accelerator_mods);
  return 0;
}

#else
int _wrap_gtk_accel_label_set_accel(Stack stack, int rhs, int opt, int lhs) /* set_accel */
{
  Scierror("Error: function gtk_accel_label_set_accel not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkaccellabel_methods[] = {
  {"get_accel_widget",(nsp_method *) _wrap_gtk_accel_label_get_accel_widget},
  {"get_accel_width",(nsp_method *) _wrap_gtk_accel_label_get_accel_width},
  {"set_accel_widget",(nsp_method *) _wrap_gtk_accel_label_set_accel_widget},
  {"refetch",(nsp_method *) _wrap_gtk_accel_label_refetch},
  {"set_accel",(nsp_method *) _wrap_gtk_accel_label_set_accel},
  { NULL, NULL}
};

static NspMethods *gtkaccellabel_get_methods(void) { return gtkaccellabel_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkaccellabel_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkButton ----------- */


#define  NspGtkButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkButton inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkbutton_id=0;
NspTypeGtkButton *nsp_type_gtkbutton=NULL;

/*
 * Type object for NspGtkButton 
 * all the instance of NspTypeGtkButton share the same id. 
 * nsp_type_gtkbutton: is an instance of NspTypeGtkButton 
 *    used for objects of NspGtkButton type (i.e built with new_gtkbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkButton *new_type_gtkbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkbutton */ 

  top->s_type =  (s_type_func *) nsp_gtkbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkbutton_type_short_string;
  /* top->create = (create_func*) int_gtkbutton_create;*/

  /* specific methods for gtkbutton */

  type->init = (init_func *) init_gtkbutton;

  /* 
   * NspGtkButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkButton called nsp_type_gtkbutton
       */
      type->id =  nsp_type_gtkbutton_id = nsp_new_type_id();
      nsp_type_gtkbutton = type;
      if ( nsp_register_type(nsp_type_gtkbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkbutton, GTK_TYPE_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkbutton(NspGtkButton *Obj,NspTypeGtkButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkButton 
 */

NspGtkButton *new_gtkbutton() 
{
  NspGtkButton *loc;
  /* type must exists */
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkButton)))== NULLGTKBUTTON) return loc;
  /* initialize object */
  if ( init_gtkbutton(loc,nsp_type_gtkbutton) == FAIL) return NULLGTKBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkbutton_type_name[]="GtkButton";
static char gtkbutton_short_type_name[]="GtkButton";

static char *nsp_gtkbutton_type_as_string(void)
{
  return(gtkbutton_type_name);
}

static char *nsp_gtkbutton_type_short_string(NspObject *v)
{
  return(gtkbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkButton   *nsp_gtkbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkbutton_id)  == TRUE  ) return ((NspGtkButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkbutton));
  return NULL;
}

int IsGtkButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkbutton_id);
}

int IsGtkButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkbutton_id);
}

NspGtkButton  *GetGtkButtonCopy(Stack stack, int i)
{
  if (  GetGtkButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkButton  *GetGtkButton(Stack stack, int i)
{
  NspGtkButton *M;
  if (( M = nsp_gtkbutton_object(NthObj(i))) == NULLGTKBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkButton *gtkbutton_copy(NspGtkButton *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_button_new_from_icon_name (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *icon_name;
  GtkIconSize size;
  NspObject *nsp_size = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&icon_name, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_button_new_from_icon_name(icon_name,size))== NULL) return RET_BUG;

  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 4411 "codegen-3.0/gtk.override"
/* OK */
static int
_wrap_gtk_button_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"mnemonic",string,NULLOBJ,-1},
    {"label",string,NULLOBJ,-1},
    {"stock",string,NULLOBJ,-1},
    {"icon_name",string,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };

  gchar *mnemonic = NULL, *label = NULL, *stock = NULL,*icon_name=NULL;

  if (GetArgs(stack,rhs,opt,T, &opts,&mnemonic, &label, &stock,&icon_name) == FAIL)  return RET_BUG;
  if ( stock )
    {
      /* gobj = (GObject *) gtk_button_new_from_stock(stock); */
      gobj = (GObject *) gtk_button_new_with_label(stock);
    }
  else if (icon_name)
    {
      gobj = (GObject *) gtk_button_new_from_icon_name(icon_name,GTK_ICON_SIZE_BUTTON);
    }
  else if (mnemonic)
    {
      gobj = (GObject *) gtk_button_new_with_mnemonic(mnemonic);
    }
  else if (label)
    {
      gobj = (GObject *) gtk_button_new_with_mnemonic(label);
    }
  else
    {
      gobj = (GObject *) gtk_button_new();
    }
  if (gobj == NULL ) {
    Scierror( "%s: could not create GtkButton object",NspFname(stack));
    return RET_BUG;
  }
  nsp_type_gtkbutton = new_type_gtkbutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtkbutton))== NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 27978 "gtk.c"


static int _wrap_gtk_button_clicked(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_button_clicked(GTK_BUTTON(self->obj));
  return 0;
}

#if GTK_CHECK_VERSION(2,20,0)
int _wrap_gtk_button_pressed(Stack stack, int rhs, int opt, int lhs) /* pressed */
{
  Scierror("Error: function gtk_button_pressed is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_button_pressed(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_button_pressed(GTK_BUTTON(self->obj));
  return 0;
}

#endif
#if GTK_CHECK_VERSION(2,20,0)
int _wrap_gtk_button_released(Stack stack, int rhs, int opt, int lhs) /* released */
{
  Scierror("Error: function gtk_button_released is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_button_released(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_button_released(GTK_BUTTON(self->obj));
  return 0;
}

#endif
#if GTK_CHECK_VERSION(2,20,0)
int _wrap_gtk_button_enter(Stack stack, int rhs, int opt, int lhs) /* enter */
{
  Scierror("Error: function gtk_button_enter is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_button_enter(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_button_enter(GTK_BUTTON(self->obj));
  return 0;
}

#endif
#if GTK_CHECK_VERSION(2,20,0)
int _wrap_gtk_button_leave(Stack stack, int rhs, int opt, int lhs) /* leave */
{
  Scierror("Error: function gtk_button_leave is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_button_leave(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_button_leave(GTK_BUTTON(self->obj));
  return 0;
}

#endif
static int _wrap_gtk_button_set_relief(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkReliefStyle relief;
  NspObject *nsp_relief = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_relief) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_RELIEF_STYLE, nsp_relief, &relief)== FAIL)
      return RET_BUG;
    gtk_button_set_relief(GTK_BUTTON(self->obj),relief);
  return 0;
}

static int _wrap_gtk_button_get_relief(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_button_get_relief(GTK_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_button_set_label(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *label;
  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
    gtk_button_set_label(GTK_BUTTON(self->obj),label);
  return 0;
}

static int _wrap_gtk_button_get_label(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_button_get_label(GTK_BUTTON(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_button_set_use_underline(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_underline;
  if ( GetArgs(stack,rhs,opt,T,&use_underline) == FAIL) return RET_BUG;
    gtk_button_set_use_underline(GTK_BUTTON(self->obj),use_underline);
  return 0;
}

static int _wrap_gtk_button_get_use_underline(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_button_get_use_underline(GTK_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_button_set_use_stock(Stack stack, int rhs, int opt, int lhs) /* set_use_stock */
{
  Scierror("Error: function gtk_button_set_use_stock is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_button_set_use_stock(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_stock;
  if ( GetArgs(stack,rhs,opt,T,&use_stock) == FAIL) return RET_BUG;
    gtk_button_set_use_stock(GTK_BUTTON(self->obj),use_stock);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_button_get_use_stock(Stack stack, int rhs, int opt, int lhs) /* get_use_stock */
{
  Scierror("Error: function gtk_button_get_use_stock is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_button_get_use_stock(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_button_get_use_stock(GTK_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
static int _wrap_gtk_button_set_focus_on_click(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int focus_on_click;
  if ( GetArgs(stack,rhs,opt,T,&focus_on_click) == FAIL) return RET_BUG;
    gtk_button_set_focus_on_click(GTK_BUTTON(self->obj),focus_on_click);
  return 0;
}

static int _wrap_gtk_button_get_focus_on_click(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_button_get_focus_on_click(GTK_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_button_set_alignment(Stack stack, int rhs, int opt, int lhs) /* set_alignment */
{
  Scierror("Error: function gtk_button_set_alignment is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_button_set_alignment(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,s_double, t_end};
  double xalign, yalign;
  if ( GetArgs(stack,rhs,opt,T,&xalign, &yalign) == FAIL) return RET_BUG;
    gtk_button_set_alignment(GTK_BUTTON(self->obj),xalign,yalign);
  return 0;
}

#endif
static int _wrap_gtk_button_set_image(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *image;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &image) == FAIL) return RET_BUG;
    gtk_button_set_image(GTK_BUTTON(self->obj),GTK_WIDGET(image->obj));
  return 0;
}

static int _wrap_gtk_button_get_image(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_button_get_image(GTK_BUTTON(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_button_set_image_position(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkPositionType position;
  NspObject *nsp_position = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_position) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_position, &position)== FAIL)
      return RET_BUG;
    gtk_button_set_image_position(GTK_BUTTON(self->obj),position);
  return 0;
}

static int _wrap_gtk_button_get_image_position(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_button_get_image_position(GTK_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_button_set_always_show_image(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int always_show;
  if ( GetArgs(stack,rhs,opt,T,&always_show) == FAIL) return RET_BUG;
    gtk_button_set_always_show_image(GTK_BUTTON(self->obj),always_show);
  return 0;
}

#else
int _wrap_gtk_button_set_always_show_image(Stack stack, int rhs, int opt, int lhs) /* set_always_show_image */
{
  Scierror("Error: function gtk_button_set_always_show_image not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_button_get_always_show_image(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_button_get_always_show_image(GTK_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_button_get_always_show_image(Stack stack, int rhs, int opt, int lhs) /* get_always_show_image */
{
  Scierror("Error: function gtk_button_get_always_show_image not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_button_get_event_window(NspGtkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_button_get_event_window(GTK_BUTTON(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkbutton_methods[] = {
  {"clicked",(nsp_method *) _wrap_gtk_button_clicked},
  {"pressed",(nsp_method *) _wrap_gtk_button_pressed},
  {"released",(nsp_method *) _wrap_gtk_button_released},
  {"enter",(nsp_method *) _wrap_gtk_button_enter},
  {"leave",(nsp_method *) _wrap_gtk_button_leave},
  {"set_relief",(nsp_method *) _wrap_gtk_button_set_relief},
  {"get_relief",(nsp_method *) _wrap_gtk_button_get_relief},
  {"set_label",(nsp_method *) _wrap_gtk_button_set_label},
  {"get_label",(nsp_method *) _wrap_gtk_button_get_label},
  {"set_use_underline",(nsp_method *) _wrap_gtk_button_set_use_underline},
  {"get_use_underline",(nsp_method *) _wrap_gtk_button_get_use_underline},
  {"set_use_stock",(nsp_method *) _wrap_gtk_button_set_use_stock},
  {"get_use_stock",(nsp_method *) _wrap_gtk_button_get_use_stock},
  {"set_focus_on_click",(nsp_method *) _wrap_gtk_button_set_focus_on_click},
  {"get_focus_on_click",(nsp_method *) _wrap_gtk_button_get_focus_on_click},
  {"set_alignment",(nsp_method *) _wrap_gtk_button_set_alignment},
  {"set_image",(nsp_method *) _wrap_gtk_button_set_image},
  {"get_image",(nsp_method *) _wrap_gtk_button_get_image},
  {"set_image_position",(nsp_method *) _wrap_gtk_button_set_image_position},
  {"get_image_position",(nsp_method *) _wrap_gtk_button_get_image_position},
  {"set_always_show_image",(nsp_method *) _wrap_gtk_button_set_always_show_image},
  {"get_always_show_image",(nsp_method *) _wrap_gtk_button_get_always_show_image},
  {"get_event_window",(nsp_method *) _wrap_gtk_button_get_event_window},
  { NULL, NULL}
};

static NspMethods *gtkbutton_get_methods(void) { return gtkbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCheckButton ----------- */


#define  NspGtkCheckButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcheckbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCheckButton inherits from GtkToggleButton 
 * and implements GtkBuildable
 */

int nsp_type_gtkcheckbutton_id=0;
NspTypeGtkCheckButton *nsp_type_gtkcheckbutton=NULL;

/*
 * Type object for NspGtkCheckButton 
 * all the instance of NspTypeGtkCheckButton share the same id. 
 * nsp_type_gtkcheckbutton: is an instance of NspTypeGtkCheckButton 
 *    used for objects of NspGtkCheckButton type (i.e built with new_gtkcheckbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkCheckButton *new_type_gtkcheckbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkCheckButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcheckbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcheckbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkToggleButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtktogglebutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcheckbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcheckbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcheckbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcheckbutton */ 

  top->s_type =  (s_type_func *) nsp_gtkcheckbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcheckbutton_type_short_string;
  /* top->create = (create_func*) int_gtkcheckbutton_create;*/

  /* specific methods for gtkcheckbutton */

  type->init = (init_func *) init_gtkcheckbutton;

  /* 
   * NspGtkCheckButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkcheckbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCheckButton called nsp_type_gtkcheckbutton
       */
      type->id =  nsp_type_gtkcheckbutton_id = nsp_new_type_id();
      nsp_type_gtkcheckbutton = type;
      if ( nsp_register_type(nsp_type_gtkcheckbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcheckbutton, GTK_TYPE_CHECK_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkcheckbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcheckbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkCheckButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcheckbutton(NspGtkCheckButton *Obj,NspTypeGtkCheckButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCheckButton 
 */

NspGtkCheckButton *new_gtkcheckbutton() 
{
  NspGtkCheckButton *loc;
  /* type must exists */
  nsp_type_gtkcheckbutton = new_type_gtkcheckbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCheckButton)))== NULLGTKCHECKBUTTON) return loc;
  /* initialize object */
  if ( init_gtkcheckbutton(loc,nsp_type_gtkcheckbutton) == FAIL) return NULLGTKCHECKBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCheckButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcheckbutton_type_name[]="GtkCheckButton";
static char gtkcheckbutton_short_type_name[]="GtkCheckButton";

static char *nsp_gtkcheckbutton_type_as_string(void)
{
  return(gtkcheckbutton_type_name);
}

static char *nsp_gtkcheckbutton_type_short_string(NspObject *v)
{
  return(gtkcheckbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCheckButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCheckButton   *nsp_gtkcheckbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcheckbutton_id)  == TRUE  ) return ((NspGtkCheckButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcheckbutton));
  return NULL;
}

int IsGtkCheckButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcheckbutton_id);
}

int IsGtkCheckButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcheckbutton_id);
}

NspGtkCheckButton  *GetGtkCheckButtonCopy(Stack stack, int i)
{
  if (  GetGtkCheckButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCheckButton  *GetGtkCheckButton(Stack stack, int i)
{
  NspGtkCheckButton *M;
  if (( M = nsp_gtkcheckbutton_object(NthObj(i))) == NULLGTKCHECKBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCheckButton *gtkcheckbutton_copy(NspGtkCheckButton *self)
{
  /* return gtktogglebutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcheckbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcheckbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCheckButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 4519 "codegen-3.0/gtk.override"
static int
_wrap_gtk_check_button_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"mnemonic",string,NULLOBJ,-1},
    {"label",string,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };

  gchar *mnemonic = NULL, *label = NULL;

  if (GetArgs(stack,rhs,opt,T, &opts,&mnemonic, &label) == FAIL)  return RET_BUG;
  if (mnemonic)
    gobj = (GObject *)gtk_check_button_new_with_mnemonic(mnemonic);
  else if (label)
    gobj = (GObject *)gtk_check_button_new_with_mnemonic(label);
  else
    gobj = (GObject *)gtk_check_button_new();
  if (gobj == NULL ) {
    Scierror( "%s: could not create GtkCheckButton object",NspFname(stack));
    return RET_BUG;
  }
  nsp_type_gtkcheckbutton = new_type_gtkcheckbutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtkcheckbutton))== NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 28522 "gtk.c"


static NspMethods *gtkcheckbutton_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcheckbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRadioButton ----------- */


#define  NspGtkRadioButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkradiobutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRadioButton inherits from GtkCheckButton 
 * and implements GtkBuildable
 */

int nsp_type_gtkradiobutton_id=0;
NspTypeGtkRadioButton *nsp_type_gtkradiobutton=NULL;

/*
 * Type object for NspGtkRadioButton 
 * all the instance of NspTypeGtkRadioButton share the same id. 
 * nsp_type_gtkradiobutton: is an instance of NspTypeGtkRadioButton 
 *    used for objects of NspGtkRadioButton type (i.e built with new_gtkradiobutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkRadioButton *new_type_gtkradiobutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkRadioButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkradiobutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkradiobutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkCheckButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcheckbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkradiobutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkradiobutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkradiobutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkradiobutton */ 

  top->s_type =  (s_type_func *) nsp_gtkradiobutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkradiobutton_type_short_string;
  /* top->create = (create_func*) int_gtkradiobutton_create;*/

  /* specific methods for gtkradiobutton */

  type->init = (init_func *) init_gtkradiobutton;

  /* 
   * NspGtkRadioButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkradiobutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRadioButton called nsp_type_gtkradiobutton
       */
      type->id =  nsp_type_gtkradiobutton_id = nsp_new_type_id();
      nsp_type_gtkradiobutton = type;
      if ( nsp_register_type(nsp_type_gtkradiobutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkradiobutton, GTK_TYPE_RADIO_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkradiobutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkradiobutton_id;
      return type;
    }
}

/*
 * initialize NspGtkRadioButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkradiobutton(NspGtkRadioButton *Obj,NspTypeGtkRadioButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRadioButton 
 */

NspGtkRadioButton *new_gtkradiobutton() 
{
  NspGtkRadioButton *loc;
  /* type must exists */
  nsp_type_gtkradiobutton = new_type_gtkradiobutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRadioButton)))== NULLGTKRADIOBUTTON) return loc;
  /* initialize object */
  if ( init_gtkradiobutton(loc,nsp_type_gtkradiobutton) == FAIL) return NULLGTKRADIOBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRadioButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkradiobutton_type_name[]="GtkRadioButton";
static char gtkradiobutton_short_type_name[]="GtkRadioButton";

static char *nsp_gtkradiobutton_type_as_string(void)
{
  return(gtkradiobutton_type_name);
}

static char *nsp_gtkradiobutton_type_short_string(NspObject *v)
{
  return(gtkradiobutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRadioButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRadioButton   *nsp_gtkradiobutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkradiobutton_id)  == TRUE  ) return ((NspGtkRadioButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkradiobutton));
  return NULL;
}

int IsGtkRadioButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkradiobutton_id);
}

int IsGtkRadioButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkradiobutton_id);
}

NspGtkRadioButton  *GetGtkRadioButtonCopy(Stack stack, int i)
{
  if (  GetGtkRadioButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRadioButton  *GetGtkRadioButton(Stack stack, int i)
{
  NspGtkRadioButton *M;
  if (( M = nsp_gtkradiobutton_object(NthObj(i))) == NULLGTKRADIOBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRadioButton *gtkradiobutton_copy(NspGtkRadioButton *self)
{
  /* return gtkcheckbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradiobutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradiobutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRadioButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 4552 "codegen-3.0/gtk.override"
static int
_wrap_gtk_radio_button_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  GtkRadioButton *group= NULL;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"group",obj,NULLOBJ,-1},
    {"label",string,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };
  NspObject *nsp_group = NULL;
  gchar *label = NULL;
  if (GetArgs(stack,rhs,opt,T, &opts,&nsp_group, &label) == FAIL)  return RET_BUG;

  if ( nsp_group != NULL )
    {
      if (nspgobject_check(nsp_group,nsp_type_gtkradiobutton))
	group = GTK_RADIO_BUTTON(nspgobject_get(nsp_group));
      else {
	Scierror("group argument must be a GtkRadioButton");
	return RET_BUG;
      }
    }

  if (label == NULL) {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_button_new(NULL);
    else
      gobj = (GObject *)gtk_radio_button_new_from_widget( group);
  } else {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_button_new_with_mnemonic(NULL,label);
    else
      gobj = (GObject *)gtk_radio_button_new_with_mnemonic_from_widget(group, label);
  }
  if (!gobj) {
    Scierror( "could not create GtkRadioButton object");
    return RET_BUG;
  }
  nsp_type_gtkradiobutton = new_type_gtkradiobutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtkradiobutton))== NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 28774 "gtk.c"


#line 4599 "codegen-3.0/gtk.override"
static int
_wrap_gtk_radio_button_get_group(NspGObject *self,Stack stack,int rhs,int opt,int lhs) {
  NspList *nsp_list;
  GSList *list, *tmp;
  list = gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj));
  NSP_LIST_FROM_GLIST(list, nspgobject_new("lel",G_OBJECT(tmp->data)),g_slist_free);
}

#line 28786 "gtk.c"


static int _wrap_gtk_radio_button_join_group(NspGtkRadioButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *group_source;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkradiobutton, &group_source) == FAIL) return RET_BUG;
    gtk_radio_button_join_group(GTK_RADIO_BUTTON(self->obj),GTK_RADIO_BUTTON(group_source->obj));
  return 0;
}

static NspMethods gtkradiobutton_methods[] = {
  {"get_group",(nsp_method *) _wrap_gtk_radio_button_get_group},
  {"join_group",(nsp_method *) _wrap_gtk_radio_button_join_group},
  { NULL, NULL}
};

static NspMethods *gtkradiobutton_get_methods(void) { return gtkradiobutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkradiobutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkToggleButton ----------- */


#define  NspGtkToggleButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktogglebutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkToggleButton inherits from GtkButton 
 * and implements GtkBuildable
 */

int nsp_type_gtktogglebutton_id=0;
NspTypeGtkToggleButton *nsp_type_gtktogglebutton=NULL;

/*
 * Type object for NspGtkToggleButton 
 * all the instance of NspTypeGtkToggleButton share the same id. 
 * nsp_type_gtktogglebutton: is an instance of NspTypeGtkToggleButton 
 *    used for objects of NspGtkToggleButton type (i.e built with new_gtktogglebutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkToggleButton *new_type_gtktogglebutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkToggleButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktogglebutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktogglebutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktogglebutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktogglebutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktogglebutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktogglebutton */ 

  top->s_type =  (s_type_func *) nsp_gtktogglebutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktogglebutton_type_short_string;
  /* top->create = (create_func*) int_gtktogglebutton_create;*/

  /* specific methods for gtktogglebutton */

  type->init = (init_func *) init_gtktogglebutton;

  /* 
   * NspGtkToggleButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtktogglebutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkToggleButton called nsp_type_gtktogglebutton
       */
      type->id =  nsp_type_gtktogglebutton_id = nsp_new_type_id();
      nsp_type_gtktogglebutton = type;
      if ( nsp_register_type(nsp_type_gtktogglebutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktogglebutton, GTK_TYPE_TOGGLE_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtktogglebutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtktogglebutton_id;
      return type;
    }
}

/*
 * initialize NspGtkToggleButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktogglebutton(NspGtkToggleButton *Obj,NspTypeGtkToggleButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkToggleButton 
 */

NspGtkToggleButton *new_gtktogglebutton() 
{
  NspGtkToggleButton *loc;
  /* type must exists */
  nsp_type_gtktogglebutton = new_type_gtktogglebutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkToggleButton)))== NULLGTKTOGGLEBUTTON) return loc;
  /* initialize object */
  if ( init_gtktogglebutton(loc,nsp_type_gtktogglebutton) == FAIL) return NULLGTKTOGGLEBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkToggleButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktogglebutton_type_name[]="GtkToggleButton";
static char gtktogglebutton_short_type_name[]="GtkToggleButton";

static char *nsp_gtktogglebutton_type_as_string(void)
{
  return(gtktogglebutton_type_name);
}

static char *nsp_gtktogglebutton_type_short_string(NspObject *v)
{
  return(gtktogglebutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkToggleButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkToggleButton   *nsp_gtktogglebutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktogglebutton_id)  == TRUE  ) return ((NspGtkToggleButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktogglebutton));
  return NULL;
}

int IsGtkToggleButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktogglebutton_id);
}

int IsGtkToggleButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktogglebutton_id);
}

NspGtkToggleButton  *GetGtkToggleButtonCopy(Stack stack, int i)
{
  if (  GetGtkToggleButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkToggleButton  *GetGtkToggleButton(Stack stack, int i)
{
  NspGtkToggleButton *M;
  if (( M = nsp_gtktogglebutton_object(NthObj(i))) == NULLGTKTOGGLEBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkToggleButton *gtktogglebutton_copy(NspGtkToggleButton *self)
{
  /* return gtkbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktogglebutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktogglebutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkToggleButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 4485 "codegen-3.0/gtk.override"
/* OK */
static int
_wrap_gtk_toggle_button_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"mnemonic",string,NULLOBJ,-1},
    {"label",string,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };

  gchar *mnemonic = NULL, *label = NULL;

  if (GetArgs(stack,rhs,opt,T, &opts,&mnemonic, &label) == FAIL)  return RET_BUG;
  if (mnemonic)
    gobj = (GObject *)gtk_toggle_button_new_with_mnemonic(mnemonic);
  else if (label)
    gobj = (GObject *)gtk_toggle_button_new_with_mnemonic(label);
  else
    gobj = (GObject *)gtk_toggle_button_new();
  if (gobj == NULL ) {
    Scierror( "%s: could not create GtkToggleButton object",NspFname(stack));
    return RET_BUG;
  }
  nsp_type_gtktogglebutton = new_type_gtktogglebutton(T_BASE);
  if (( ret = (NspObject *) gobject_create(NVOID,gobj ,(NspTypeBase *) nsp_type_gtktogglebutton))== NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 29038 "gtk.c"


static int _wrap_gtk_toggle_button_set_mode(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int draw_indicator;
  if ( GetArgs(stack,rhs,opt,T,&draw_indicator) == FAIL) return RET_BUG;
    gtk_toggle_button_set_mode(GTK_TOGGLE_BUTTON(self->obj),draw_indicator);
  return 0;
}

static int _wrap_gtk_toggle_button_get_mode(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_toggle_button_get_mode(GTK_TOGGLE_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toggle_button_set_active(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int is_active;
  if ( GetArgs(stack,rhs,opt,T,&is_active) == FAIL) return RET_BUG;
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self->obj),is_active);
  return 0;
}

static int _wrap_gtk_toggle_button_get_active(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toggle_button_toggled(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_toggle_button_toggled(GTK_TOGGLE_BUTTON(self->obj));
  return 0;
}

static int _wrap_gtk_toggle_button_set_inconsistent(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_toggle_button_set_inconsistent(GTK_TOGGLE_BUTTON(self->obj),setting);
  return 0;
}

static int _wrap_gtk_toggle_button_get_inconsistent(NspGtkToggleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_toggle_button_get_inconsistent(GTK_TOGGLE_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktogglebutton_methods[] = {
  {"set_mode",(nsp_method *) _wrap_gtk_toggle_button_set_mode},
  {"get_mode",(nsp_method *) _wrap_gtk_toggle_button_get_mode},
  {"set_active",(nsp_method *) _wrap_gtk_toggle_button_set_active},
  {"get_active",(nsp_method *) _wrap_gtk_toggle_button_get_active},
  {"toggled",(nsp_method *) _wrap_gtk_toggle_button_toggled},
  {"set_inconsistent",(nsp_method *) _wrap_gtk_toggle_button_set_inconsistent},
  {"get_inconsistent",(nsp_method *) _wrap_gtk_toggle_button_get_inconsistent},
  { NULL, NULL}
};

static NspMethods *gtktogglebutton_get_methods(void) { return gtktogglebutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktogglebutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkLinkButton ----------- */


#define  NspGtkLinkButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtklinkbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkLinkButton inherits from GtkButton 
 * and implements GtkBuildable
 */

int nsp_type_gtklinkbutton_id=0;
NspTypeGtkLinkButton *nsp_type_gtklinkbutton=NULL;

/*
 * Type object for NspGtkLinkButton 
 * all the instance of NspTypeGtkLinkButton share the same id. 
 * nsp_type_gtklinkbutton: is an instance of NspTypeGtkLinkButton 
 *    used for objects of NspGtkLinkButton type (i.e built with new_gtklinkbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkLinkButton *new_type_gtklinkbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkLinkButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtklinkbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtklinkbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtklinkbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtklinkbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtklinkbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtklinkbutton */ 

  top->s_type =  (s_type_func *) nsp_gtklinkbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtklinkbutton_type_short_string;
  /* top->create = (create_func*) int_gtklinkbutton_create;*/

  /* specific methods for gtklinkbutton */

  type->init = (init_func *) init_gtklinkbutton;

  /* 
   * NspGtkLinkButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtklinkbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkLinkButton called nsp_type_gtklinkbutton
       */
      type->id =  nsp_type_gtklinkbutton_id = nsp_new_type_id();
      nsp_type_gtklinkbutton = type;
      if ( nsp_register_type(nsp_type_gtklinkbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtklinkbutton, GTK_TYPE_LINK_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtklinkbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtklinkbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkLinkButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtklinkbutton(NspGtkLinkButton *Obj,NspTypeGtkLinkButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkLinkButton 
 */

NspGtkLinkButton *new_gtklinkbutton() 
{
  NspGtkLinkButton *loc;
  /* type must exists */
  nsp_type_gtklinkbutton = new_type_gtklinkbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkLinkButton)))== NULLGTKLINKBUTTON) return loc;
  /* initialize object */
  if ( init_gtklinkbutton(loc,nsp_type_gtklinkbutton) == FAIL) return NULLGTKLINKBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkLinkButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtklinkbutton_type_name[]="GtkLinkButton";
static char gtklinkbutton_short_type_name[]="GtkLinkButton";

static char *nsp_gtklinkbutton_type_as_string(void)
{
  return(gtklinkbutton_type_name);
}

static char *nsp_gtklinkbutton_type_short_string(NspObject *v)
{
  return(gtklinkbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkLinkButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkLinkButton   *nsp_gtklinkbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtklinkbutton_id)  == TRUE  ) return ((NspGtkLinkButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtklinkbutton));
  return NULL;
}

int IsGtkLinkButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtklinkbutton_id);
}

int IsGtkLinkButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtklinkbutton_id);
}

NspGtkLinkButton  *GetGtkLinkButtonCopy(Stack stack, int i)
{
  if (  GetGtkLinkButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkLinkButton  *GetGtkLinkButton(Stack stack, int i)
{
  NspGtkLinkButton *M;
  if (( M = nsp_gtklinkbutton_object(NthObj(i))) == NULLGTKLINKBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkLinkButton *gtklinkbutton_copy(NspGtkLinkButton *self)
{
  /* return gtkbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklinkbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklinkbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkLinkButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_link_button_new_with_label (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,string, t_end};
  char *uri, *label;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&uri, &label) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_link_button_new_with_label(uri,label))== NULL) return RET_BUG;

  nsp_type_gtklinkbutton = new_type_gtklinkbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtklinkbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_link_button_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_link_button_new(uri))== NULL) return RET_BUG;

  nsp_type_gtklinkbutton = new_type_gtklinkbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtklinkbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_link_button_get_uri(NspGtkLinkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_link_button_get_uri(GTK_LINK_BUTTON(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_link_button_set_uri(NspGtkLinkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    gtk_link_button_set_uri(GTK_LINK_BUTTON(self->obj),uri);
  return 0;
}

static int _wrap_gtk_link_button_get_visited(NspGtkLinkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_link_button_get_visited(GTK_LINK_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_link_button_set_visited(NspGtkLinkButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int visited;
  if ( GetArgs(stack,rhs,opt,T,&visited) == FAIL) return RET_BUG;
    gtk_link_button_set_visited(GTK_LINK_BUTTON(self->obj),visited);
  return 0;
}

static NspMethods gtklinkbutton_methods[] = {
  {"get_uri",(nsp_method *) _wrap_gtk_link_button_get_uri},
  {"set_uri",(nsp_method *) _wrap_gtk_link_button_set_uri},
  {"get_visited",(nsp_method *) _wrap_gtk_link_button_get_visited},
  {"set_visited",(nsp_method *) _wrap_gtk_link_button_set_visited},
  { NULL, NULL}
};

static NspMethods *gtklinkbutton_get_methods(void) { return gtklinkbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtklinkbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkMenuButton ----------- */


#define  NspGtkMenuButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkmenubutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkMenuButton inherits from GtkToggleButton 
 * and implements GtkBuildable
 */

int nsp_type_gtkmenubutton_id=0;
NspTypeGtkMenuButton *nsp_type_gtkmenubutton=NULL;

/*
 * Type object for NspGtkMenuButton 
 * all the instance of NspTypeGtkMenuButton share the same id. 
 * nsp_type_gtkmenubutton: is an instance of NspTypeGtkMenuButton 
 *    used for objects of NspGtkMenuButton type (i.e built with new_gtkmenubutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkMenuButton *new_type_gtkmenubutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkMenuButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmenubutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmenubutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkToggleButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtktogglebutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmenubutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkmenubutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkmenubutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkmenubutton */ 

  top->s_type =  (s_type_func *) nsp_gtkmenubutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkmenubutton_type_short_string;
  /* top->create = (create_func*) int_gtkmenubutton_create;*/

  /* specific methods for gtkmenubutton */

  type->init = (init_func *) init_gtkmenubutton;

  /* 
   * NspGtkMenuButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkmenubutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMenuButton called nsp_type_gtkmenubutton
       */
      type->id =  nsp_type_gtkmenubutton_id = nsp_new_type_id();
      nsp_type_gtkmenubutton = type;
      if ( nsp_register_type(nsp_type_gtkmenubutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmenubutton, GTK_TYPE_MENU_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkmenubutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkmenubutton_id;
      return type;
    }
}

/*
 * initialize NspGtkMenuButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmenubutton(NspGtkMenuButton *Obj,NspTypeGtkMenuButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkMenuButton 
 */

NspGtkMenuButton *new_gtkmenubutton() 
{
  NspGtkMenuButton *loc;
  /* type must exists */
  nsp_type_gtkmenubutton = new_type_gtkmenubutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMenuButton)))== NULLGTKMENUBUTTON) return loc;
  /* initialize object */
  if ( init_gtkmenubutton(loc,nsp_type_gtkmenubutton) == FAIL) return NULLGTKMENUBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkMenuButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkmenubutton_type_name[]="GtkMenuButton";
static char gtkmenubutton_short_type_name[]="GtkMenuButton";

static char *nsp_gtkmenubutton_type_as_string(void)
{
  return(gtkmenubutton_type_name);
}

static char *nsp_gtkmenubutton_type_short_string(NspObject *v)
{
  return(gtkmenubutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkMenuButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkMenuButton   *nsp_gtkmenubutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkmenubutton_id)  == TRUE  ) return ((NspGtkMenuButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmenubutton));
  return NULL;
}

int IsGtkMenuButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkmenubutton_id);
}

int IsGtkMenuButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmenubutton_id);
}

NspGtkMenuButton  *GetGtkMenuButtonCopy(Stack stack, int i)
{
  if (  GetGtkMenuButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMenuButton  *GetGtkMenuButton(Stack stack, int i)
{
  NspGtkMenuButton *M;
  if (( M = nsp_gtkmenubutton_object(NthObj(i))) == NULLGTKMENUBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMenuButton *gtkmenubutton_copy(NspGtkMenuButton *self)
{
  /* return gtktogglebutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenubutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenubutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMenuButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_menu_button_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_menu_button_new())== NULL) return RET_BUG;

  nsp_type_gtkmenubutton = new_type_gtkmenubutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkmenubutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_menu_button_set_popup(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *menu;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &menu) == FAIL) return RET_BUG;
    gtk_menu_button_set_popup(GTK_MENU_BUTTON(self->obj),GTK_WIDGET(menu->obj));
  return 0;
}

#else
int _wrap_gtk_menu_button_set_popup(Stack stack, int rhs, int opt, int lhs) /* set_popup */
{
  Scierror("Error: function gtk_menu_button_set_popup not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_menu_button_get_popup(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkMenu *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_menu_button_get_popup(GTK_MENU_BUTTON(self->obj));
  nsp_type_gtkmenu = new_type_gtkmenu(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkmenu))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_menu_button_get_popup(Stack stack, int rhs, int opt, int lhs) /* get_popup */
{
  Scierror("Error: function gtk_menu_button_get_popup not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_menu_button_set_popover(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *popover;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &popover) == FAIL) return RET_BUG;
    gtk_menu_button_set_popover(GTK_MENU_BUTTON(self->obj),GTK_WIDGET(popover->obj));
  return 0;
}

#else
int _wrap_gtk_menu_button_set_popover(Stack stack, int rhs, int opt, int lhs) /* set_popover */
{
  Scierror("Error: function gtk_menu_button_set_popover not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_menu_button_get_popover(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkPopover *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_menu_button_get_popover(GTK_MENU_BUTTON(self->obj));
  nsp_type_gtkpopover = new_type_gtkpopover(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkpopover))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_menu_button_get_popover(Stack stack, int rhs, int opt, int lhs) /* get_popover */
{
  Scierror("Error: function gtk_menu_button_get_popover not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_menu_button_set_direction(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkArrowType direction;
  NspObject *nsp_direction = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_direction) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ARROW_TYPE, nsp_direction, &direction)== FAIL)
      return RET_BUG;
    gtk_menu_button_set_direction(GTK_MENU_BUTTON(self->obj),direction);
  return 0;
}

#else
int _wrap_gtk_menu_button_set_direction(Stack stack, int rhs, int opt, int lhs) /* set_direction */
{
  Scierror("Error: function gtk_menu_button_set_direction not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_menu_button_get_direction(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_menu_button_get_direction(GTK_MENU_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_menu_button_get_direction(Stack stack, int rhs, int opt, int lhs) /* get_direction */
{
  Scierror("Error: function gtk_menu_button_get_direction not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_menu_button_set_menu_model(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *menu_model;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gmenumodel, &menu_model) == FAIL) return RET_BUG;
    gtk_menu_button_set_menu_model(GTK_MENU_BUTTON(self->obj),G_MENU_MODEL(menu_model->obj));
  return 0;
}

#else
int _wrap_gtk_menu_button_set_menu_model(Stack stack, int rhs, int opt, int lhs) /* set_menu_model */
{
  Scierror("Error: function gtk_menu_button_set_menu_model not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_menu_button_get_menu_model(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GMenuModel *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_menu_button_get_menu_model(GTK_MENU_BUTTON(self->obj));
  nsp_type_gmenumodel = new_type_gmenumodel(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gmenumodel))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_menu_button_get_menu_model(Stack stack, int rhs, int opt, int lhs) /* get_menu_model */
{
  Scierror("Error: function gtk_menu_button_get_menu_model not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_menu_button_set_align_widget(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *align_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &align_widget) == FAIL) return RET_BUG;
    gtk_menu_button_set_align_widget(GTK_MENU_BUTTON(self->obj),GTK_WIDGET(align_widget->obj));
  return 0;
}

#else
int _wrap_gtk_menu_button_set_align_widget(Stack stack, int rhs, int opt, int lhs) /* set_align_widget */
{
  Scierror("Error: function gtk_menu_button_set_align_widget not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_menu_button_get_align_widget(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_menu_button_get_align_widget(GTK_MENU_BUTTON(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_menu_button_get_align_widget(Stack stack, int rhs, int opt, int lhs) /* get_align_widget */
{
  Scierror("Error: function gtk_menu_button_get_align_widget not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_menu_button_set_use_popover(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_popover;
  if ( GetArgs(stack,rhs,opt,T,&use_popover) == FAIL) return RET_BUG;
    gtk_menu_button_set_use_popover(GTK_MENU_BUTTON(self->obj),use_popover);
  return 0;
}

#else
int _wrap_gtk_menu_button_set_use_popover(Stack stack, int rhs, int opt, int lhs) /* set_use_popover */
{
  Scierror("Error: function gtk_menu_button_set_use_popover not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_menu_button_get_use_popover(NspGtkMenuButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_menu_button_get_use_popover(GTK_MENU_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_menu_button_get_use_popover(Stack stack, int rhs, int opt, int lhs) /* get_use_popover */
{
  Scierror("Error: function gtk_menu_button_get_use_popover not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkmenubutton_methods[] = {
  {"set_popup",(nsp_method *) _wrap_gtk_menu_button_set_popup},
  {"get_popup",(nsp_method *) _wrap_gtk_menu_button_get_popup},
  {"set_popover",(nsp_method *) _wrap_gtk_menu_button_set_popover},
  {"get_popover",(nsp_method *) _wrap_gtk_menu_button_get_popover},
  {"set_direction",(nsp_method *) _wrap_gtk_menu_button_set_direction},
  {"get_direction",(nsp_method *) _wrap_gtk_menu_button_get_direction},
  {"set_menu_model",(nsp_method *) _wrap_gtk_menu_button_set_menu_model},
  {"get_menu_model",(nsp_method *) _wrap_gtk_menu_button_get_menu_model},
  {"set_align_widget",(nsp_method *) _wrap_gtk_menu_button_set_align_widget},
  {"get_align_widget",(nsp_method *) _wrap_gtk_menu_button_get_align_widget},
  {"set_use_popover",(nsp_method *) _wrap_gtk_menu_button_set_use_popover},
  {"get_use_popover",(nsp_method *) _wrap_gtk_menu_button_get_use_popover},
  { NULL, NULL}
};

static NspMethods *gtkmenubutton_get_methods(void) { return gtkmenubutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmenubutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkSwitch ----------- */


#define  NspGtkSwitch_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkswitch.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkSwitch inherits from GtkWidget 
 * and implements GtkBuildable
 */

int nsp_type_gtkswitch_id=0;
NspTypeGtkSwitch *nsp_type_gtkswitch=NULL;

/*
 * Type object for NspGtkSwitch 
 * all the instance of NspTypeGtkSwitch share the same id. 
 * nsp_type_gtkswitch: is an instance of NspTypeGtkSwitch 
 *    used for objects of NspGtkSwitch type (i.e built with new_gtkswitch) 
 * other instances are used for derived classes 
 */
NspTypeGtkSwitch *new_type_gtkswitch(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkSwitch *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkswitch != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkswitch;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkswitch_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkswitch_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkswitch;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkswitch */ 

  top->s_type =  (s_type_func *) nsp_gtkswitch_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkswitch_type_short_string;
  /* top->create = (create_func*) int_gtkswitch_create;*/

  /* specific methods for gtkswitch */

  type->init = (init_func *) init_gtkswitch;

  /* 
   * NspGtkSwitch interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkswitch_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSwitch called nsp_type_gtkswitch
       */
      type->id =  nsp_type_gtkswitch_id = nsp_new_type_id();
      nsp_type_gtkswitch = type;
      if ( nsp_register_type(nsp_type_gtkswitch) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkswitch, GTK_TYPE_SWITCH);
      return ( mode == T_BASE ) ? type : new_type_gtkswitch(mode);
    }
  else 
    {
      type->id = nsp_type_gtkswitch_id;
      return type;
    }
}

/*
 * initialize NspGtkSwitch instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkswitch(NspGtkSwitch *Obj,NspTypeGtkSwitch *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkSwitch 
 */

NspGtkSwitch *new_gtkswitch() 
{
  NspGtkSwitch *loc;
  /* type must exists */
  nsp_type_gtkswitch = new_type_gtkswitch(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSwitch)))== NULLGTKSWITCH) return loc;
  /* initialize object */
  if ( init_gtkswitch(loc,nsp_type_gtkswitch) == FAIL) return NULLGTKSWITCH;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkSwitch 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkswitch_type_name[]="GtkSwitch";
static char gtkswitch_short_type_name[]="GtkSwitch";

static char *nsp_gtkswitch_type_as_string(void)
{
  return(gtkswitch_type_name);
}

static char *nsp_gtkswitch_type_short_string(NspObject *v)
{
  return(gtkswitch_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkSwitch objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkSwitch   *nsp_gtkswitch_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkswitch_id)  == TRUE  ) return ((NspGtkSwitch *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkswitch));
  return NULL;
}

int IsGtkSwitchObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkswitch_id);
}

int IsGtkSwitch(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkswitch_id);
}

NspGtkSwitch  *GetGtkSwitchCopy(Stack stack, int i)
{
  if (  GetGtkSwitch(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSwitch  *GetGtkSwitch(Stack stack, int i)
{
  NspGtkSwitch *M;
  if (( M = nsp_gtkswitch_object(NthObj(i))) == NULLGTKSWITCH)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSwitch *gtkswitch_copy(NspGtkSwitch *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkswitch);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkswitch);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSwitch
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_switch_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_switch_new())== NULL) return RET_BUG;

  nsp_type_gtkswitch = new_type_gtkswitch(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkswitch);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_switch_set_active(NspGtkSwitch *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int is_active;
  if ( GetArgs(stack,rhs,opt,T,&is_active) == FAIL) return RET_BUG;
    gtk_switch_set_active(GTK_SWITCH(self->obj),is_active);
  return 0;
}

static int _wrap_gtk_switch_get_active(NspGtkSwitch *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_switch_get_active(GTK_SWITCH(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_switch_set_state(NspGtkSwitch *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int state;
  if ( GetArgs(stack,rhs,opt,T,&state) == FAIL) return RET_BUG;
    gtk_switch_set_state(GTK_SWITCH(self->obj),state);
  return 0;
}

#else
int _wrap_gtk_switch_set_state(Stack stack, int rhs, int opt, int lhs) /* set_state */
{
  Scierror("Error: function gtk_switch_set_state not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_switch_get_state(NspGtkSwitch *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_switch_get_state(GTK_SWITCH(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_switch_get_state(Stack stack, int rhs, int opt, int lhs) /* get_state */
{
  Scierror("Error: function gtk_switch_get_state not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkswitch_methods[] = {
  {"set_active",(nsp_method *) _wrap_gtk_switch_set_active},
  {"get_active",(nsp_method *) _wrap_gtk_switch_get_active},
  {"set_state",(nsp_method *) _wrap_gtk_switch_set_state},
  {"get_state",(nsp_method *) _wrap_gtk_switch_get_state},
  { NULL, NULL}
};

static NspMethods *gtkswitch_get_methods(void) { return gtkswitch_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkswitch_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkScaleButton ----------- */


#define  NspGtkScaleButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkscalebutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkScaleButton inherits from GtkButton 
 * and implements GtkBuildable
 */

int nsp_type_gtkscalebutton_id=0;
NspTypeGtkScaleButton *nsp_type_gtkscalebutton=NULL;

/*
 * Type object for NspGtkScaleButton 
 * all the instance of NspTypeGtkScaleButton share the same id. 
 * nsp_type_gtkscalebutton: is an instance of NspTypeGtkScaleButton 
 *    used for objects of NspGtkScaleButton type (i.e built with new_gtkscalebutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkScaleButton *new_type_gtkscalebutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkScaleButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkscalebutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkscalebutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkscalebutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkscalebutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkscalebutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkscalebutton */ 

  top->s_type =  (s_type_func *) nsp_gtkscalebutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkscalebutton_type_short_string;
  /* top->create = (create_func*) int_gtkscalebutton_create;*/

  /* specific methods for gtkscalebutton */

  type->init = (init_func *) init_gtkscalebutton;

  /* 
   * NspGtkScaleButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkscalebutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkScaleButton called nsp_type_gtkscalebutton
       */
      type->id =  nsp_type_gtkscalebutton_id = nsp_new_type_id();
      nsp_type_gtkscalebutton = type;
      if ( nsp_register_type(nsp_type_gtkscalebutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkscalebutton, GTK_TYPE_SCALE_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkscalebutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkscalebutton_id;
      return type;
    }
}

/*
 * initialize NspGtkScaleButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkscalebutton(NspGtkScaleButton *Obj,NspTypeGtkScaleButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkScaleButton 
 */

NspGtkScaleButton *new_gtkscalebutton() 
{
  NspGtkScaleButton *loc;
  /* type must exists */
  nsp_type_gtkscalebutton = new_type_gtkscalebutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkScaleButton)))== NULLGTKSCALEBUTTON) return loc;
  /* initialize object */
  if ( init_gtkscalebutton(loc,nsp_type_gtkscalebutton) == FAIL) return NULLGTKSCALEBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkScaleButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkscalebutton_type_name[]="GtkScaleButton";
static char gtkscalebutton_short_type_name[]="GtkScaleButton";

static char *nsp_gtkscalebutton_type_as_string(void)
{
  return(gtkscalebutton_type_name);
}

static char *nsp_gtkscalebutton_type_short_string(NspObject *v)
{
  return(gtkscalebutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkScaleButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkScaleButton   *nsp_gtkscalebutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkscalebutton_id)  == TRUE  ) return ((NspGtkScaleButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkscalebutton));
  return NULL;
}

int IsGtkScaleButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkscalebutton_id);
}

int IsGtkScaleButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkscalebutton_id);
}

NspGtkScaleButton  *GetGtkScaleButtonCopy(Stack stack, int i)
{
  if (  GetGtkScaleButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkScaleButton  *GetGtkScaleButton(Stack stack, int i)
{
  NspGtkScaleButton *M;
  if (( M = nsp_gtkscalebutton_object(NthObj(i))) == NULLGTKSCALEBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkScaleButton *gtkscalebutton_copy(NspGtkScaleButton *self)
{
  /* return gtkbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscalebutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscalebutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkScaleButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_scale_button_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,s_double,s_double,s_double,obj, t_end};
  GtkIconSize size;
  NspObject *nsp_size = NULL, *nsp_icons = NULL;
  double min, max, step;
  const gchar **icons = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_size, &min, &max, &step, &nsp_icons) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
  if ( IsSMat(nsp_icons))
    { icons = (const gchar **) ((NspSMatrix *) nsp_icons)->S;}
  else
    {
      Scierror("Error: icons should be of type SMat\n");
      return RET_BUG;
    }
  if ((ret = (GObject *)gtk_scale_button_new(size,min,max,step,icons))== NULL) return RET_BUG;

  nsp_type_gtkscalebutton = new_type_gtkscalebutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkscalebutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scale_button_set_icons(NspGtkScaleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  const gchar **icons = NULL;
  NspObject *nsp_icons = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icons) == FAIL) return RET_BUG;
  if ( IsSMat(nsp_icons))
    { icons = (const gchar **) ((NspSMatrix *) nsp_icons)->S;}
  else
    {
      Scierror("Error: icons should be of type SMat\n");
      return RET_BUG;
    }
    gtk_scale_button_set_icons(GTK_SCALE_BUTTON(self->obj),icons);
  return 0;
}

static int _wrap_gtk_scale_button_get_value(NspGtkScaleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_scale_button_get_value(GTK_SCALE_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scale_button_set_value(NspGtkScaleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double value;
  if ( GetArgs(stack,rhs,opt,T,&value) == FAIL) return RET_BUG;
    gtk_scale_button_set_value(GTK_SCALE_BUTTON(self->obj),value);
  return 0;
}

static int _wrap_gtk_scale_button_get_adjustment(NspGtkScaleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAdjustment *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_scale_button_get_adjustment(GTK_SCALE_BUTTON(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scale_button_set_adjustment(NspGtkScaleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *adjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
    gtk_scale_button_set_adjustment(GTK_SCALE_BUTTON(self->obj),GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_scale_button_get_plus_button(NspGtkScaleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_scale_button_get_plus_button(GTK_SCALE_BUTTON(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scale_button_get_minus_button(NspGtkScaleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_scale_button_get_minus_button(GTK_SCALE_BUTTON(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scale_button_get_popup(NspGtkScaleButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_scale_button_get_popup(GTK_SCALE_BUTTON(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkscalebutton_methods[] = {
  {"set_icons",(nsp_method *) _wrap_gtk_scale_button_set_icons},
  {"get_value",(nsp_method *) _wrap_gtk_scale_button_get_value},
  {"set_value",(nsp_method *) _wrap_gtk_scale_button_set_value},
  {"get_adjustment",(nsp_method *) _wrap_gtk_scale_button_get_adjustment},
  {"set_adjustment",(nsp_method *) _wrap_gtk_scale_button_set_adjustment},
  {"get_plus_button",(nsp_method *) _wrap_gtk_scale_button_get_plus_button},
  {"get_minus_button",(nsp_method *) _wrap_gtk_scale_button_get_minus_button},
  {"get_popup",(nsp_method *) _wrap_gtk_scale_button_get_popup},
  { NULL, NULL}
};

static NspMethods *gtkscalebutton_get_methods(void) { return gtkscalebutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkscalebutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkVolumeButton ----------- */


#define  NspGtkVolumeButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkvolumebutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkVolumeButton inherits from GtkScaleButton 
 * and implements GtkBuildable
 */

int nsp_type_gtkvolumebutton_id=0;
NspTypeGtkVolumeButton *nsp_type_gtkvolumebutton=NULL;

/*
 * Type object for NspGtkVolumeButton 
 * all the instance of NspTypeGtkVolumeButton share the same id. 
 * nsp_type_gtkvolumebutton: is an instance of NspTypeGtkVolumeButton 
 *    used for objects of NspGtkVolumeButton type (i.e built with new_gtkvolumebutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkVolumeButton *new_type_gtkvolumebutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkVolumeButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkvolumebutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkvolumebutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkScaleButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkscalebutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkvolumebutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkvolumebutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkvolumebutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkvolumebutton */ 

  top->s_type =  (s_type_func *) nsp_gtkvolumebutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkvolumebutton_type_short_string;
  /* top->create = (create_func*) int_gtkvolumebutton_create;*/

  /* specific methods for gtkvolumebutton */

  type->init = (init_func *) init_gtkvolumebutton;

  /* 
   * NspGtkVolumeButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkvolumebutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkVolumeButton called nsp_type_gtkvolumebutton
       */
      type->id =  nsp_type_gtkvolumebutton_id = nsp_new_type_id();
      nsp_type_gtkvolumebutton = type;
      if ( nsp_register_type(nsp_type_gtkvolumebutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkvolumebutton, GTK_TYPE_VOLUME_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkvolumebutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkvolumebutton_id;
      return type;
    }
}

/*
 * initialize NspGtkVolumeButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkvolumebutton(NspGtkVolumeButton *Obj,NspTypeGtkVolumeButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkVolumeButton 
 */

NspGtkVolumeButton *new_gtkvolumebutton() 
{
  NspGtkVolumeButton *loc;
  /* type must exists */
  nsp_type_gtkvolumebutton = new_type_gtkvolumebutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkVolumeButton)))== NULLGTKVOLUMEBUTTON) return loc;
  /* initialize object */
  if ( init_gtkvolumebutton(loc,nsp_type_gtkvolumebutton) == FAIL) return NULLGTKVOLUMEBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkVolumeButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkvolumebutton_type_name[]="GtkVolumeButton";
static char gtkvolumebutton_short_type_name[]="GtkVolumeButton";

static char *nsp_gtkvolumebutton_type_as_string(void)
{
  return(gtkvolumebutton_type_name);
}

static char *nsp_gtkvolumebutton_type_short_string(NspObject *v)
{
  return(gtkvolumebutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkVolumeButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkVolumeButton   *nsp_gtkvolumebutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkvolumebutton_id)  == TRUE  ) return ((NspGtkVolumeButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkvolumebutton));
  return NULL;
}

int IsGtkVolumeButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkvolumebutton_id);
}

int IsGtkVolumeButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkvolumebutton_id);
}

NspGtkVolumeButton  *GetGtkVolumeButtonCopy(Stack stack, int i)
{
  if (  GetGtkVolumeButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkVolumeButton  *GetGtkVolumeButton(Stack stack, int i)
{
  NspGtkVolumeButton *M;
  if (( M = nsp_gtkvolumebutton_object(NthObj(i))) == NULLGTKVOLUMEBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkVolumeButton *gtkvolumebutton_copy(NspGtkVolumeButton *self)
{
  /* return gtkscalebutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvolumebutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkvolumebutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkVolumeButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_volume_button_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_volume_button_new())== NULL) return RET_BUG;

  nsp_type_gtkvolumebutton = new_type_gtkvolumebutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkvolumebutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkvolumebutton_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkvolumebutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkLockButton ----------- */


#define  NspGtkLockButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtklockbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkLockButton inherits from GtkButton 
 * and implements GtkBuildable
 */

int nsp_type_gtklockbutton_id=0;
NspTypeGtkLockButton *nsp_type_gtklockbutton=NULL;

/*
 * Type object for NspGtkLockButton 
 * all the instance of NspTypeGtkLockButton share the same id. 
 * nsp_type_gtklockbutton: is an instance of NspTypeGtkLockButton 
 *    used for objects of NspGtkLockButton type (i.e built with new_gtklockbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkLockButton *new_type_gtklockbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkLockButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtklockbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtklockbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtklockbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtklockbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtklockbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtklockbutton */ 

  top->s_type =  (s_type_func *) nsp_gtklockbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtklockbutton_type_short_string;
  /* top->create = (create_func*) int_gtklockbutton_create;*/

  /* specific methods for gtklockbutton */

  type->init = (init_func *) init_gtklockbutton;

  /* 
   * NspGtkLockButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtklockbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkLockButton called nsp_type_gtklockbutton
       */
      type->id =  nsp_type_gtklockbutton_id = nsp_new_type_id();
      nsp_type_gtklockbutton = type;
      if ( nsp_register_type(nsp_type_gtklockbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtklockbutton, GTK_TYPE_LOCK_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtklockbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtklockbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkLockButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtklockbutton(NspGtkLockButton *Obj,NspTypeGtkLockButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkLockButton 
 */

NspGtkLockButton *new_gtklockbutton() 
{
  NspGtkLockButton *loc;
  /* type must exists */
  nsp_type_gtklockbutton = new_type_gtklockbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkLockButton)))== NULLGTKLOCKBUTTON) return loc;
  /* initialize object */
  if ( init_gtklockbutton(loc,nsp_type_gtklockbutton) == FAIL) return NULLGTKLOCKBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkLockButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtklockbutton_type_name[]="GtkLockButton";
static char gtklockbutton_short_type_name[]="GtkLockButton";

static char *nsp_gtklockbutton_type_as_string(void)
{
  return(gtklockbutton_type_name);
}

static char *nsp_gtklockbutton_type_short_string(NspObject *v)
{
  return(gtklockbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkLockButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkLockButton   *nsp_gtklockbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtklockbutton_id)  == TRUE  ) return ((NspGtkLockButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtklockbutton));
  return NULL;
}

int IsGtkLockButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtklockbutton_id);
}

int IsGtkLockButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtklockbutton_id);
}

NspGtkLockButton  *GetGtkLockButtonCopy(Stack stack, int i)
{
  if (  GetGtkLockButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkLockButton  *GetGtkLockButton(Stack stack, int i)
{
  NspGtkLockButton *M;
  if (( M = nsp_gtklockbutton_object(NthObj(i))) == NULLGTKLOCKBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkLockButton *gtklockbutton_copy(NspGtkLockButton *self)
{
  /* return gtkbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklockbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtklockbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkLockButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_lock_button_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *permission;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gpermission, &permission) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_lock_button_new(G_PERMISSION(permission->obj)))== NULL) return RET_BUG;

  nsp_type_gtklockbutton = new_type_gtklockbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtklockbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_lock_button_get_permission(NspGtkLockButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GPermission *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_lock_button_get_permission(GTK_LOCK_BUTTON(self->obj));
  nsp_type_gpermission = new_type_gpermission(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gpermission))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_lock_button_get_permission(Stack stack, int rhs, int opt, int lhs) /* get_permission */
{
  Scierror("Error: function gtk_lock_button_get_permission not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_lock_button_set_permission(NspGtkLockButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *permission;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gpermission, &permission) == FAIL) return RET_BUG;
    gtk_lock_button_set_permission(GTK_LOCK_BUTTON(self->obj),G_PERMISSION(permission->obj));
  return 0;
}

#else
int _wrap_gtk_lock_button_set_permission(Stack stack, int rhs, int opt, int lhs) /* set_permission */
{
  Scierror("Error: function gtk_lock_button_set_permission not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtklockbutton_methods[] = {
  {"get_permission",(nsp_method *) _wrap_gtk_lock_button_get_permission},
  {"set_permission",(nsp_method *) _wrap_gtk_lock_button_set_permission},
  { NULL, NULL}
};

static NspMethods *gtklockbutton_get_methods(void) { return gtklockbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtklockbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;

#if GTK_CHECK_VERSION(3,16,0) 

/* -----------NspGtkModelButton ----------- */


#define  NspGtkModelButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkmodelbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkModelButton inherits from GtkButton 
 * and implements GtkBuildable
 */

int nsp_type_gtkmodelbutton_id=0;
NspTypeGtkModelButton *nsp_type_gtkmodelbutton=NULL;

/*
 * Type object for NspGtkModelButton 
 * all the instance of NspTypeGtkModelButton share the same id. 
 * nsp_type_gtkmodelbutton: is an instance of NspTypeGtkModelButton 
 *    used for objects of NspGtkModelButton type (i.e built with new_gtkmodelbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkModelButton *new_type_gtkmodelbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkModelButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmodelbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmodelbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmodelbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkmodelbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkmodelbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkmodelbutton */ 

  top->s_type =  (s_type_func *) nsp_gtkmodelbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkmodelbutton_type_short_string;
  /* top->create = (create_func*) int_gtkmodelbutton_create;*/

  /* specific methods for gtkmodelbutton */

  type->init = (init_func *) init_gtkmodelbutton;

  /* 
   * NspGtkModelButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkmodelbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkModelButton called nsp_type_gtkmodelbutton
       */
      type->id =  nsp_type_gtkmodelbutton_id = nsp_new_type_id();
      nsp_type_gtkmodelbutton = type;
      if ( nsp_register_type(nsp_type_gtkmodelbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmodelbutton, GTK_TYPE_MODEL_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkmodelbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkmodelbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkModelButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmodelbutton(NspGtkModelButton *Obj,NspTypeGtkModelButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkModelButton 
 */

NspGtkModelButton *new_gtkmodelbutton() 
{
  NspGtkModelButton *loc;
  /* type must exists */
  nsp_type_gtkmodelbutton = new_type_gtkmodelbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkModelButton)))== NULLGTKMODELBUTTON) return loc;
  /* initialize object */
  if ( init_gtkmodelbutton(loc,nsp_type_gtkmodelbutton) == FAIL) return NULLGTKMODELBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkModelButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkmodelbutton_type_name[]="GtkModelButton";
static char gtkmodelbutton_short_type_name[]="GtkModelButton";

static char *nsp_gtkmodelbutton_type_as_string(void)
{
  return(gtkmodelbutton_type_name);
}

static char *nsp_gtkmodelbutton_type_short_string(NspObject *v)
{
  return(gtkmodelbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkModelButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkModelButton   *nsp_gtkmodelbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkmodelbutton_id)  == TRUE  ) return ((NspGtkModelButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmodelbutton));
  return NULL;
}

int IsGtkModelButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkmodelbutton_id);
}

int IsGtkModelButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmodelbutton_id);
}

NspGtkModelButton  *GetGtkModelButtonCopy(Stack stack, int i)
{
  if (  GetGtkModelButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkModelButton  *GetGtkModelButton(Stack stack, int i)
{
  NspGtkModelButton *M;
  if (( M = nsp_gtkmodelbutton_object(NthObj(i))) == NULLGTKMODELBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkModelButton *gtkmodelbutton_copy(NspGtkModelButton *self)
{
  /* return gtkbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmodelbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmodelbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkModelButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
#endif /* GTK_CHECK_VERSION */
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,16,0)
static int
_wrap_gtk_model_button_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_model_button_new())== NULL) return RET_BUG;

  nsp_type_gtkmodelbutton = new_type_gtkmodelbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkmodelbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_model_button_new(Stack stack, int rhs, int opt, int lhs) /* gtk_model_button_new */
{
  Scierror("Error: function gtk_model_button_new not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0) 
static NspMethods *gtkmodelbutton_get_methods(void) { return NULL;};
#endif /* GTK_CHECK_VERSION */
#if GTK_CHECK_VERSION(3,16,0) 
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmodelbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;
#endif /* GTK_CHECK_VERSION */


/* -----------NspGtkEntry ----------- */


#define  NspGtkEntry_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkentry.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkEntry inherits from GtkWidget 
 * and implements GtkEditable GtkCellEditable GtkBuildable
 */

int nsp_type_gtkentry_id=0;
NspTypeGtkEntry *nsp_type_gtkentry=NULL;

/*
 * Type object for NspGtkEntry 
 * all the instance of NspTypeGtkEntry share the same id. 
 * nsp_type_gtkentry: is an instance of NspTypeGtkEntry 
 *    used for objects of NspGtkEntry type (i.e built with new_gtkentry) 
 * other instances are used for derived classes 
 */
NspTypeGtkEntry *new_type_gtkentry(type_mode mode)
{
  NspTypeGtkEditable *t_gtkeditable;
  NspTypeGtkCellEditable *t_gtkcelleditable;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkEntry *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkentry != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkentry;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkentry_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkentry_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkentry;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkentry */ 

  top->s_type =  (s_type_func *) nsp_gtkentry_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkentry_type_short_string;
  /* top->create = (create_func*) int_gtkentry_create;*/

  /* specific methods for gtkentry */

  type->init = (init_func *) init_gtkentry;

  /* 
   * NspGtkEntry interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkeditable = new_type_gtkeditable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkeditable;
  t_gtkcelleditable = new_type_gtkcelleditable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkcelleditable;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkentry_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkEntry called nsp_type_gtkentry
       */
      type->id =  nsp_type_gtkentry_id = nsp_new_type_id();
      nsp_type_gtkentry = type;
      if ( nsp_register_type(nsp_type_gtkentry) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkentry, GTK_TYPE_ENTRY);
      return ( mode == T_BASE ) ? type : new_type_gtkentry(mode);
    }
  else 
    {
      type->id = nsp_type_gtkentry_id;
      return type;
    }
}

/*
 * initialize NspGtkEntry instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkentry(NspGtkEntry *Obj,NspTypeGtkEntry *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkEntry 
 */

NspGtkEntry *new_gtkentry() 
{
  NspGtkEntry *loc;
  /* type must exists */
  nsp_type_gtkentry = new_type_gtkentry(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkEntry)))== NULLGTKENTRY) return loc;
  /* initialize object */
  if ( init_gtkentry(loc,nsp_type_gtkentry) == FAIL) return NULLGTKENTRY;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkEntry 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkentry_type_name[]="GtkEntry";
static char gtkentry_short_type_name[]="GtkEntry";

static char *nsp_gtkentry_type_as_string(void)
{
  return(gtkentry_type_name);
}

static char *nsp_gtkentry_type_short_string(NspObject *v)
{
  return(gtkentry_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkEntry objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkEntry   *nsp_gtkentry_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkentry_id)  == TRUE  ) return ((NspGtkEntry *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkentry));
  return NULL;
}

int IsGtkEntryObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkentry_id);
}

int IsGtkEntry(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkentry_id);
}

NspGtkEntry  *GetGtkEntryCopy(Stack stack, int i)
{
  if (  GetGtkEntry(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkEntry  *GetGtkEntry(Stack stack, int i)
{
  NspGtkEntry *M;
  if (( M = nsp_gtkentry_object(NthObj(i))) == NULLGTKENTRY)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkEntry *gtkentry_copy(NspGtkEntry *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkentry);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkentry);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkEntry
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 3876 "codegen-3.0/gtk.override"

static int
_wrap_gtk_entry_new(Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_entry_new())== NULL) return RET_BUG;
  nsp_type_gtkentry = new_type_gtkentry(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkentry );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 31390 "gtk.c"


static int _wrap_gtk_entry_get_buffer(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkEntryBuffer *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_buffer(GTK_ENTRY(self->obj));
  nsp_type_gtkentrybuffer = new_type_gtkentrybuffer(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkentrybuffer))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_entry_set_buffer(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *buffer;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkentrybuffer, &buffer) == FAIL) return RET_BUG;
    gtk_entry_set_buffer(GTK_ENTRY(self->obj),GTK_ENTRY_BUFFER(buffer->obj));
  return 0;
}

#line 3892 "codegen-3.0/gtk.override"
static int _wrap_gtk_entry_get_text_area(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkRectangle ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  gtk_entry_get_text_area(GTK_ENTRY(self->obj),&ret);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE,&ret, TRUE, TRUE,NULL))==NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 31427 "gtk.c"


static int _wrap_gtk_entry_set_visibility(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int visible;
  if ( GetArgs(stack,rhs,opt,T,&visible) == FAIL) return RET_BUG;
    gtk_entry_set_visibility(GTK_ENTRY(self->obj),visible);
  return 0;
}

static int _wrap_gtk_entry_get_visibility(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_visibility(GTK_ENTRY(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_invisible_char(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  gunichar ch;
  int nsp_ch = 0;
  if ( GetArgs(stack,rhs,opt,T,&nsp_ch) == FAIL) return RET_BUG;
  ch = (gunichar)nsp_ch;
    gtk_entry_set_invisible_char(GTK_ENTRY(self->obj),ch);
  return 0;
}

static int _wrap_gtk_entry_get_invisible_char(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  gunichar ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_invisible_char(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)== FAIL)return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_unset_invisible_char(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_entry_unset_invisible_char(GTK_ENTRY(self->obj));
  return 0;
}

static int _wrap_gtk_entry_set_has_frame(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_entry_set_has_frame(GTK_ENTRY(self->obj),setting);
  return 0;
}

static int _wrap_gtk_entry_get_has_frame(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_has_frame(GTK_ENTRY(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,4,0)
int _wrap_gtk_entry_set_inner_border(Stack stack, int rhs, int opt, int lhs) /* set_inner_border */
{
  Scierror("Error: function gtk_entry_set_inner_border is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_entry_set_inner_border(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkBorder *border = NULL;
  NspObject *nsp_border = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_border) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_border, GTK_TYPE_BORDER))
      border = nspg_boxed_get(nsp_border, GtkBorder);
  else {
      Scierror( "Error: border should be a GtkBorder\n");
      return RET_BUG;
  }
    gtk_entry_set_inner_border(GTK_ENTRY(self->obj),border);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,4,0)
int _wrap_gtk_entry_get_inner_border(Stack stack, int rhs, int opt, int lhs) /* get_inner_border */
{
  Scierror("Error: function gtk_entry_get_inner_border is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_entry_get_inner_border(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkBorder *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_inner_border(GTK_ENTRY(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_BORDER, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkborder))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#endif
static int _wrap_gtk_entry_set_overwrite_mode(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int overwrite;
  if ( GetArgs(stack,rhs,opt,T,&overwrite) == FAIL) return RET_BUG;
    gtk_entry_set_overwrite_mode(GTK_ENTRY(self->obj),overwrite);
  return 0;
}

static int _wrap_gtk_entry_get_overwrite_mode(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_overwrite_mode(GTK_ENTRY(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_max_length(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int max;
  if ( GetArgs(stack,rhs,opt,T,&max) == FAIL) return RET_BUG;
    gtk_entry_set_max_length(GTK_ENTRY(self->obj),max);
  return 0;
}

static int _wrap_gtk_entry_get_max_length(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_max_length(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_get_text_length(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_text_length(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_activates_default(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_entry_set_activates_default(GTK_ENTRY(self->obj),setting);
  return 0;
}

static int _wrap_gtk_entry_get_activates_default(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_activates_default(GTK_ENTRY(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_width_chars(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int n_chars;
  if ( GetArgs(stack,rhs,opt,T,&n_chars) == FAIL) return RET_BUG;
    gtk_entry_set_width_chars(GTK_ENTRY(self->obj),n_chars);
  return 0;
}

static int _wrap_gtk_entry_get_width_chars(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_width_chars(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_entry_set_max_width_chars(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int n_chars;
  if ( GetArgs(stack,rhs,opt,T,&n_chars) == FAIL) return RET_BUG;
    gtk_entry_set_max_width_chars(GTK_ENTRY(self->obj),n_chars);
  return 0;
}

#else
int _wrap_gtk_entry_set_max_width_chars(Stack stack, int rhs, int opt, int lhs) /* set_max_width_chars */
{
  Scierror("Error: function gtk_entry_set_max_width_chars not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_entry_get_max_width_chars(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_max_width_chars(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_entry_get_max_width_chars(Stack stack, int rhs, int opt, int lhs) /* get_max_width_chars */
{
  Scierror("Error: function gtk_entry_get_max_width_chars not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_entry_set_text(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    gtk_entry_set_text(GTK_ENTRY(self->obj),text);
  return 0;
}

static int _wrap_gtk_entry_get_text(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_text(GTK_ENTRY(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_get_layout(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoLayout *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_layout(GTK_ENTRY(self->obj));
  nsp_type_pangolayout = new_type_pangolayout(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangolayout))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 3906 "codegen-3.0/gtk.override"
static int
_wrap_gtk_entry_get_layout_offsets(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int x, y;

  gtk_entry_get_layout_offsets(GTK_ENTRY(self->obj), &x, &y);
  if (  nsp_move_doubles(stack,1,1,2,(double) x,(double) y) == FAIL)
    return RET_BUG;
  return 1;
}

#line 31695 "gtk.c"


static int _wrap_gtk_entry_set_alignment(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double xalign;
  if ( GetArgs(stack,rhs,opt,T,&xalign) == FAIL) return RET_BUG;
    gtk_entry_set_alignment(GTK_ENTRY(self->obj),xalign);
  return 0;
}

static int _wrap_gtk_entry_get_alignment(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_alignment(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_completion(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *completion;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkentrycompletion, &completion) == FAIL) return RET_BUG;
    gtk_entry_set_completion(GTK_ENTRY(self->obj),GTK_ENTRY_COMPLETION(completion->obj));
  return 0;
}

static int _wrap_gtk_entry_get_completion(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkEntryCompletion *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_completion(GTK_ENTRY(self->obj));
  nsp_type_gtkentrycompletion = new_type_gtkentrycompletion(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkentrycompletion))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_entry_layout_index_to_text_index(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int layout_index, ret;
  if ( GetArgs(stack,rhs,opt,T,&layout_index) == FAIL) return RET_BUG;
    ret =gtk_entry_layout_index_to_text_index(GTK_ENTRY(self->obj),layout_index);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_text_index_to_layout_index(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int text_index, ret;
  if ( GetArgs(stack,rhs,opt,T,&text_index) == FAIL) return RET_BUG;
    ret =gtk_entry_text_index_to_layout_index(GTK_ENTRY(self->obj),text_index);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_cursor_hadjustment(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *adjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
    gtk_entry_set_cursor_hadjustment(GTK_ENTRY(self->obj),GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_entry_get_cursor_hadjustment(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAdjustment *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_cursor_hadjustment(GTK_ENTRY(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_entry_set_progress_fraction(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double fraction;
  if ( GetArgs(stack,rhs,opt,T,&fraction) == FAIL) return RET_BUG;
    gtk_entry_set_progress_fraction(GTK_ENTRY(self->obj),fraction);
  return 0;
}

static int _wrap_gtk_entry_get_progress_fraction(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_progress_fraction(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_progress_pulse_step(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double fraction;
  if ( GetArgs(stack,rhs,opt,T,&fraction) == FAIL) return RET_BUG;
    gtk_entry_set_progress_pulse_step(GTK_ENTRY(self->obj),fraction);
  return 0;
}

static int _wrap_gtk_entry_get_progress_pulse_step(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_progress_pulse_step(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_progress_pulse(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_entry_progress_pulse(GTK_ENTRY(self->obj));
  return 0;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_entry_get_placeholder_text(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_placeholder_text(GTK_ENTRY(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_entry_get_placeholder_text(Stack stack, int rhs, int opt, int lhs) /* get_placeholder_text */
{
  Scierror("Error: function gtk_entry_get_placeholder_text not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_entry_set_placeholder_text(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    gtk_entry_set_placeholder_text(GTK_ENTRY(self->obj),text);
  return 0;
}

#else
int _wrap_gtk_entry_set_placeholder_text(Stack stack, int rhs, int opt, int lhs) /* set_placeholder_text */
{
  Scierror("Error: function gtk_entry_set_placeholder_text not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_entry_set_icon_from_pixbuf(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  NspGObject *pixbuf;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos, &nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    gtk_entry_set_icon_from_pixbuf(GTK_ENTRY(self->obj),icon_pos,GDK_PIXBUF(pixbuf->obj));
  return 0;
}

static int _wrap_gtk_entry_set_icon_from_icon_name(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,string, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  char *icon_name;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos, &icon_name) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    gtk_entry_set_icon_from_icon_name(GTK_ENTRY(self->obj),icon_pos,icon_name);
  return 0;
}

static int _wrap_gtk_entry_set_icon_from_gicon(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  NspGObject *icon;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos, &nsp_type_gicon, &icon) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    gtk_entry_set_icon_from_gicon(GTK_ENTRY(self->obj),icon_pos,G_ICON(icon->obj));
  return 0;
}

static int _wrap_gtk_entry_get_icon_storage_type(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  gint ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    ret =gtk_entry_get_icon_storage_type(GTK_ENTRY(self->obj),icon_pos);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_get_icon_pixbuf(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL, *nsp_ret;
  GdkPixbuf *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    ret =gtk_entry_get_icon_pixbuf(GTK_ENTRY(self->obj),icon_pos);
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_entry_get_icon_name(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  const gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    ret =gtk_entry_get_icon_name(GTK_ENTRY(self->obj),icon_pos);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_get_icon_gicon(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL, *nsp_ret;
  GIcon *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    ret =gtk_entry_get_icon_gicon(GTK_ENTRY(self->obj),icon_pos);
  nsp_type_gicon = new_type_gicon(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gicon))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_entry_set_icon_activatable(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_bool, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  int activatable;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos, &activatable) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    gtk_entry_set_icon_activatable(GTK_ENTRY(self->obj),icon_pos,activatable);
  return 0;
}

static int _wrap_gtk_entry_get_icon_activatable(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    ret =gtk_entry_get_icon_activatable(GTK_ENTRY(self->obj),icon_pos);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_icon_sensitive(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_bool, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  int sensitive;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos, &sensitive) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    gtk_entry_set_icon_sensitive(GTK_ENTRY(self->obj),icon_pos,sensitive);
  return 0;
}

static int _wrap_gtk_entry_get_icon_sensitive(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    ret =gtk_entry_get_icon_sensitive(GTK_ENTRY(self->obj),icon_pos);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_get_icon_at_pos(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int x, y, ret;
  if ( GetArgs(stack,rhs,opt,T,&x, &y) == FAIL) return RET_BUG;
    ret =gtk_entry_get_icon_at_pos(GTK_ENTRY(self->obj),x,y);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_set_icon_tooltip_text(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,string, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  char *tooltip;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos, &tooltip) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    gtk_entry_set_icon_tooltip_text(GTK_ENTRY(self->obj),icon_pos,tooltip);
  return 0;
}

static int _wrap_gtk_entry_get_icon_tooltip_text(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    ret =gtk_entry_get_icon_tooltip_text(GTK_ENTRY(self->obj),icon_pos);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_entry_set_icon_tooltip_markup(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,string, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  char *tooltip;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos, &tooltip) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    gtk_entry_set_icon_tooltip_markup(GTK_ENTRY(self->obj),icon_pos,tooltip);
  return 0;
}

static int _wrap_gtk_entry_get_icon_tooltip_markup(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
    ret =gtk_entry_get_icon_tooltip_markup(GTK_ENTRY(self->obj),icon_pos);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_entry_get_current_icon_drag_source(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_current_icon_drag_source(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 3919 "codegen-3.0/gtk.override"

static int _wrap_gtk_entry_get_icon_area(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkEntryIconPosition icon_pos;
  NspObject *nsp_icon_pos = NULL, *ret;
  GdkRectangle icon_area = { 0, 0, 0, 0 };
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ENTRY_ICON_POSITION, nsp_icon_pos, &icon_pos)== FAIL)
      return RET_BUG;
  gtk_entry_get_icon_area(GTK_ENTRY(self->obj),icon_pos,&icon_area);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &icon_area, TRUE, TRUE,
					 (NspTypeBase *) nsp_type_gdkrectangle)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}

#line 32101 "gtk.c"


static int _wrap_gtk_entry_im_context_filter_keypress(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    ret =gtk_entry_im_context_filter_keypress(GTK_ENTRY(self->obj),(GdkEventKey *)event);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_reset_im_context(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_entry_reset_im_context(GTK_ENTRY(self->obj));
  return 0;
}

#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_entry_set_input_purpose(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkInputPurpose purpose;
  NspObject *nsp_purpose = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_purpose) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_INPUT_PURPOSE, nsp_purpose, &purpose)== FAIL)
      return RET_BUG;
    gtk_entry_set_input_purpose(GTK_ENTRY(self->obj),purpose);
  return 0;
}

#else
int _wrap_gtk_entry_set_input_purpose(Stack stack, int rhs, int opt, int lhs) /* set_input_purpose */
{
  Scierror("Error: function gtk_entry_set_input_purpose not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_entry_get_input_purpose(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_input_purpose(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_entry_get_input_purpose(Stack stack, int rhs, int opt, int lhs) /* get_input_purpose */
{
  Scierror("Error: function gtk_entry_get_input_purpose not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_entry_set_input_hints(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkInputHints hints;
  NspObject *nsp_hints = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_hints) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_INPUT_HINTS, nsp_hints, &hints)==FAIL)
      return RET_BUG;
    gtk_entry_set_input_hints(GTK_ENTRY(self->obj),hints);
  return 0;
}

#else
int _wrap_gtk_entry_set_input_hints(Stack stack, int rhs, int opt, int lhs) /* set_input_hints */
{
  Scierror("Error: function gtk_entry_set_input_hints not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_entry_get_input_hints(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_input_hints(GTK_ENTRY(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_entry_get_input_hints(Stack stack, int rhs, int opt, int lhs) /* get_input_hints */
{
  Scierror("Error: function gtk_entry_get_input_hints not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_entry_set_attributes(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  PangoAttrList *attrs = NULL;
  NspObject *nsp_attrs = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_attrs) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_attrs, PANGO_TYPE_ATTR_LIST))
      attrs = nspg_boxed_get(nsp_attrs, PangoAttrList);
  else {
      Scierror( "Error: attrs should be a PangoAttrList\n");
      return RET_BUG;
  }
    gtk_entry_set_attributes(GTK_ENTRY(self->obj),attrs);
  return 0;
}

#else
int _wrap_gtk_entry_set_attributes(Stack stack, int rhs, int opt, int lhs) /* set_attributes */
{
  Scierror("Error: function gtk_entry_set_attributes not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_entry_get_attributes(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoAttrList *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_attributes(GTK_ENTRY(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,PANGO_TYPE_ATTR_LIST, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_pangoattrlist))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_entry_get_attributes(Stack stack, int rhs, int opt, int lhs) /* get_attributes */
{
  Scierror("Error: function gtk_entry_get_attributes not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_entry_set_tabs(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  PangoTabArray *tabs = NULL;
  NspObject *nsp_tabs = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_tabs) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_tabs, PANGO_TYPE_TAB_ARRAY))
      tabs = nspg_boxed_get(nsp_tabs, PangoTabArray);
  else {
      Scierror( "Error: tabs should be a PangoTabArray\n");
      return RET_BUG;
  }
    gtk_entry_set_tabs(GTK_ENTRY(self->obj),tabs);
  return 0;
}

#else
int _wrap_gtk_entry_set_tabs(Stack stack, int rhs, int opt, int lhs) /* set_tabs */
{
  Scierror("Error: function gtk_entry_set_tabs not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_entry_get_tabs(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoTabArray *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_entry_get_tabs(GTK_ENTRY(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,PANGO_TYPE_TAB_ARRAY, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_pangotabarray))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_entry_get_tabs(Stack stack, int rhs, int opt, int lhs) /* get_tabs */
{
  Scierror("Error: function gtk_entry_get_tabs not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_entry_grab_focus_without_selecting(NspGtkEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_entry_grab_focus_without_selecting(GTK_ENTRY(self->obj));
  return 0;
}

#else
int _wrap_gtk_entry_grab_focus_without_selecting(Stack stack, int rhs, int opt, int lhs) /* grab_focus_without_selecting */
{
  Scierror("Error: function gtk_entry_grab_focus_without_selecting not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkentry_methods[] = {
  {"get_buffer",(nsp_method *) _wrap_gtk_entry_get_buffer},
  {"set_buffer",(nsp_method *) _wrap_gtk_entry_set_buffer},
  {"get_text_area",(nsp_method *) _wrap_gtk_entry_get_text_area},
  {"set_visibility",(nsp_method *) _wrap_gtk_entry_set_visibility},
  {"get_visibility",(nsp_method *) _wrap_gtk_entry_get_visibility},
  {"set_invisible_char",(nsp_method *) _wrap_gtk_entry_set_invisible_char},
  {"get_invisible_char",(nsp_method *) _wrap_gtk_entry_get_invisible_char},
  {"unset_invisible_char",(nsp_method *) _wrap_gtk_entry_unset_invisible_char},
  {"set_has_frame",(nsp_method *) _wrap_gtk_entry_set_has_frame},
  {"get_has_frame",(nsp_method *) _wrap_gtk_entry_get_has_frame},
  {"set_inner_border",(nsp_method *) _wrap_gtk_entry_set_inner_border},
  {"get_inner_border",(nsp_method *) _wrap_gtk_entry_get_inner_border},
  {"set_overwrite_mode",(nsp_method *) _wrap_gtk_entry_set_overwrite_mode},
  {"get_overwrite_mode",(nsp_method *) _wrap_gtk_entry_get_overwrite_mode},
  {"set_max_length",(nsp_method *) _wrap_gtk_entry_set_max_length},
  {"get_max_length",(nsp_method *) _wrap_gtk_entry_get_max_length},
  {"get_text_length",(nsp_method *) _wrap_gtk_entry_get_text_length},
  {"set_activates_default",(nsp_method *) _wrap_gtk_entry_set_activates_default},
  {"get_activates_default",(nsp_method *) _wrap_gtk_entry_get_activates_default},
  {"set_width_chars",(nsp_method *) _wrap_gtk_entry_set_width_chars},
  {"get_width_chars",(nsp_method *) _wrap_gtk_entry_get_width_chars},
  {"set_max_width_chars",(nsp_method *) _wrap_gtk_entry_set_max_width_chars},
  {"get_max_width_chars",(nsp_method *) _wrap_gtk_entry_get_max_width_chars},
  {"set_text",(nsp_method *) _wrap_gtk_entry_set_text},
  {"get_text",(nsp_method *) _wrap_gtk_entry_get_text},
  {"get_layout",(nsp_method *) _wrap_gtk_entry_get_layout},
  {"get_layout_offsets",(nsp_method *) _wrap_gtk_entry_get_layout_offsets},
  {"set_alignment",(nsp_method *) _wrap_gtk_entry_set_alignment},
  {"get_alignment",(nsp_method *) _wrap_gtk_entry_get_alignment},
  {"set_completion",(nsp_method *) _wrap_gtk_entry_set_completion},
  {"get_completion",(nsp_method *) _wrap_gtk_entry_get_completion},
  {"layout_index_to_text_index",(nsp_method *) _wrap_gtk_entry_layout_index_to_text_index},
  {"text_index_to_layout_index",(nsp_method *) _wrap_gtk_entry_text_index_to_layout_index},
  {"set_cursor_hadjustment",(nsp_method *) _wrap_gtk_entry_set_cursor_hadjustment},
  {"get_cursor_hadjustment",(nsp_method *) _wrap_gtk_entry_get_cursor_hadjustment},
  {"set_progress_fraction",(nsp_method *) _wrap_gtk_entry_set_progress_fraction},
  {"get_progress_fraction",(nsp_method *) _wrap_gtk_entry_get_progress_fraction},
  {"set_progress_pulse_step",(nsp_method *) _wrap_gtk_entry_set_progress_pulse_step},
  {"get_progress_pulse_step",(nsp_method *) _wrap_gtk_entry_get_progress_pulse_step},
  {"progress_pulse",(nsp_method *) _wrap_gtk_entry_progress_pulse},
  {"get_placeholder_text",(nsp_method *) _wrap_gtk_entry_get_placeholder_text},
  {"set_placeholder_text",(nsp_method *) _wrap_gtk_entry_set_placeholder_text},
  {"set_icon_from_pixbuf",(nsp_method *) _wrap_gtk_entry_set_icon_from_pixbuf},
  {"set_icon_from_icon_name",(nsp_method *) _wrap_gtk_entry_set_icon_from_icon_name},
  {"set_icon_from_gicon",(nsp_method *) _wrap_gtk_entry_set_icon_from_gicon},
  {"get_icon_storage_type",(nsp_method *) _wrap_gtk_entry_get_icon_storage_type},
  {"get_icon_pixbuf",(nsp_method *) _wrap_gtk_entry_get_icon_pixbuf},
  {"get_icon_name",(nsp_method *) _wrap_gtk_entry_get_icon_name},
  {"get_icon_gicon",(nsp_method *) _wrap_gtk_entry_get_icon_gicon},
  {"set_icon_activatable",(nsp_method *) _wrap_gtk_entry_set_icon_activatable},
  {"get_icon_activatable",(nsp_method *) _wrap_gtk_entry_get_icon_activatable},
  {"set_icon_sensitive",(nsp_method *) _wrap_gtk_entry_set_icon_sensitive},
  {"get_icon_sensitive",(nsp_method *) _wrap_gtk_entry_get_icon_sensitive},
  {"get_icon_at_pos",(nsp_method *) _wrap_gtk_entry_get_icon_at_pos},
  {"set_icon_tooltip_text",(nsp_method *) _wrap_gtk_entry_set_icon_tooltip_text},
  {"get_icon_tooltip_text",(nsp_method *) _wrap_gtk_entry_get_icon_tooltip_text},
  {"set_icon_tooltip_markup",(nsp_method *) _wrap_gtk_entry_set_icon_tooltip_markup},
  {"get_icon_tooltip_markup",(nsp_method *) _wrap_gtk_entry_get_icon_tooltip_markup},
  {"get_current_icon_drag_source",(nsp_method *) _wrap_gtk_entry_get_current_icon_drag_source},
  {"get_icon_area",(nsp_method *) _wrap_gtk_entry_get_icon_area},
  {"im_context_filter_keypress",(nsp_method *) _wrap_gtk_entry_im_context_filter_keypress},
  {"reset_im_context",(nsp_method *) _wrap_gtk_entry_reset_im_context},
  {"set_input_purpose",(nsp_method *) _wrap_gtk_entry_set_input_purpose},
  {"get_input_purpose",(nsp_method *) _wrap_gtk_entry_get_input_purpose},
  {"set_input_hints",(nsp_method *) _wrap_gtk_entry_set_input_hints},
  {"get_input_hints",(nsp_method *) _wrap_gtk_entry_get_input_hints},
  {"set_attributes",(nsp_method *) _wrap_gtk_entry_set_attributes},
  {"get_attributes",(nsp_method *) _wrap_gtk_entry_get_attributes},
  {"set_tabs",(nsp_method *) _wrap_gtk_entry_set_tabs},
  {"get_tabs",(nsp_method *) _wrap_gtk_entry_get_tabs},
  {"grab_focus_without_selecting",(nsp_method *) _wrap_gtk_entry_grab_focus_without_selecting},
  { NULL, NULL}
};

static NspMethods *gtkentry_get_methods(void) { return gtkentry_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkentry_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkEntryBuffer ----------- */


#define  NspGtkEntryBuffer_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkentrybuffer.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkEntryBuffer inherits from GObject 
 */

int nsp_type_gtkentrybuffer_id=0;
NspTypeGtkEntryBuffer *nsp_type_gtkentrybuffer=NULL;

/*
 * Type object for NspGtkEntryBuffer 
 * all the instance of NspTypeGtkEntryBuffer share the same id. 
 * nsp_type_gtkentrybuffer: is an instance of NspTypeGtkEntryBuffer 
 *    used for objects of NspGtkEntryBuffer type (i.e built with new_gtkentrybuffer) 
 * other instances are used for derived classes 
 */
NspTypeGtkEntryBuffer *new_type_gtkentrybuffer(type_mode mode)
{
  NspTypeGtkEntryBuffer *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkentrybuffer != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkentrybuffer;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkentrybuffer_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkentrybuffer_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkentrybuffer;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkentrybuffer */ 

  top->s_type =  (s_type_func *) nsp_gtkentrybuffer_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkentrybuffer_type_short_string;
  /* top->create = (create_func*) int_gtkentrybuffer_create;*/

  /* specific methods for gtkentrybuffer */

  type->init = (init_func *) init_gtkentrybuffer;

  /* 
   * NspGtkEntryBuffer interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkentrybuffer_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkEntryBuffer called nsp_type_gtkentrybuffer
       */
      type->id =  nsp_type_gtkentrybuffer_id = nsp_new_type_id();
      nsp_type_gtkentrybuffer = type;
      if ( nsp_register_type(nsp_type_gtkentrybuffer) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkentrybuffer, GTK_TYPE_ENTRY_BUFFER);
      return ( mode == T_BASE ) ? type : new_type_gtkentrybuffer(mode);
    }
  else 
    {
      type->id = nsp_type_gtkentrybuffer_id;
      return type;
    }
}

/*
 * initialize NspGtkEntryBuffer instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkentrybuffer(NspGtkEntryBuffer *Obj,NspTypeGtkEntryBuffer *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkEntryBuffer 
 */

NspGtkEntryBuffer *new_gtkentrybuffer() 
{
  NspGtkEntryBuffer *loc;
  /* type must exists */
  nsp_type_gtkentrybuffer = new_type_gtkentrybuffer(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkEntryBuffer)))== NULLGTKENTRYBUFFER) return loc;
  /* initialize object */
  if ( init_gtkentrybuffer(loc,nsp_type_gtkentrybuffer) == FAIL) return NULLGTKENTRYBUFFER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkEntryBuffer 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkentrybuffer_type_name[]="GtkEntryBuffer";
static char gtkentrybuffer_short_type_name[]="GtkEntryBuffer";

static char *nsp_gtkentrybuffer_type_as_string(void)
{
  return(gtkentrybuffer_type_name);
}

static char *nsp_gtkentrybuffer_type_short_string(NspObject *v)
{
  return(gtkentrybuffer_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkEntryBuffer objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkEntryBuffer   *nsp_gtkentrybuffer_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkentrybuffer_id)  == TRUE  ) return ((NspGtkEntryBuffer *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkentrybuffer));
  return NULL;
}

int IsGtkEntryBufferObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkentrybuffer_id);
}

int IsGtkEntryBuffer(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkentrybuffer_id);
}

NspGtkEntryBuffer  *GetGtkEntryBufferCopy(Stack stack, int i)
{
  if (  GetGtkEntryBuffer(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkEntryBuffer  *GetGtkEntryBuffer(Stack stack, int i)
{
  NspGtkEntryBuffer *M;
  if (( M = nsp_gtkentrybuffer_object(NthObj(i))) == NULLGTKENTRYBUFFER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkEntryBuffer *gtkentrybuffer_copy(NspGtkEntryBuffer *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkentrybuffer);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkentrybuffer);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkEntryBuffer
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_entry_buffer_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,s_int, t_end};
  char *initial_chars;
  int n_initial_chars;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&initial_chars, &n_initial_chars) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_entry_buffer_new(initial_chars,n_initial_chars))== NULL) return RET_BUG;

  nsp_type_gtkentrybuffer = new_type_gtkentrybuffer(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkentrybuffer);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_entry_buffer_get_bytes(NspGtkEntryBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_buffer_get_bytes(GTK_ENTRY_BUFFER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_buffer_get_length(NspGtkEntryBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_buffer_get_length(GTK_ENTRY_BUFFER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_buffer_get_text(NspGtkEntryBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_entry_buffer_get_text(GTK_ENTRY_BUFFER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_buffer_set_text(NspGtkEntryBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int, t_end};
  char *chars;
  int n_chars;
  if ( GetArgs(stack,rhs,opt,T,&chars, &n_chars) == FAIL) return RET_BUG;
    gtk_entry_buffer_set_text(GTK_ENTRY_BUFFER(self->obj),chars,n_chars);
  return 0;
}

static int _wrap_gtk_entry_buffer_set_max_length(NspGtkEntryBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int max_length;
  if ( GetArgs(stack,rhs,opt,T,&max_length) == FAIL) return RET_BUG;
    gtk_entry_buffer_set_max_length(GTK_ENTRY_BUFFER(self->obj),max_length);
  return 0;
}

static int _wrap_gtk_entry_buffer_get_max_length(NspGtkEntryBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_buffer_get_max_length(GTK_ENTRY_BUFFER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_buffer_insert_text(NspGtkEntryBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,string,s_int, t_end};
  int position, n_chars, ret;
  char *chars;
  if ( GetArgs(stack,rhs,opt,T,&position, &chars, &n_chars) == FAIL) return RET_BUG;
    ret =gtk_entry_buffer_insert_text(GTK_ENTRY_BUFFER(self->obj),position,chars,n_chars);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_buffer_delete_text(NspGtkEntryBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int position, n_chars, ret;
  if ( GetArgs(stack,rhs,opt,T,&position, &n_chars) == FAIL) return RET_BUG;
    ret =gtk_entry_buffer_delete_text(GTK_ENTRY_BUFFER(self->obj),position,n_chars);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_buffer_emit_inserted_text(NspGtkEntryBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,string,s_int, t_end};
  int position, n_chars;
  char *chars;
  if ( GetArgs(stack,rhs,opt,T,&position, &chars, &n_chars) == FAIL) return RET_BUG;
    gtk_entry_buffer_emit_inserted_text(GTK_ENTRY_BUFFER(self->obj),position,chars,n_chars);
  return 0;
}

static int _wrap_gtk_entry_buffer_emit_deleted_text(NspGtkEntryBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int position, n_chars;
  if ( GetArgs(stack,rhs,opt,T,&position, &n_chars) == FAIL) return RET_BUG;
    gtk_entry_buffer_emit_deleted_text(GTK_ENTRY_BUFFER(self->obj),position,n_chars);
  return 0;
}

static NspMethods gtkentrybuffer_methods[] = {
  {"get_bytes",(nsp_method *) _wrap_gtk_entry_buffer_get_bytes},
  {"get_length",(nsp_method *) _wrap_gtk_entry_buffer_get_length},
  {"get_text",(nsp_method *) _wrap_gtk_entry_buffer_get_text},
  {"set_text",(nsp_method *) _wrap_gtk_entry_buffer_set_text},
  {"set_max_length",(nsp_method *) _wrap_gtk_entry_buffer_set_max_length},
  {"get_max_length",(nsp_method *) _wrap_gtk_entry_buffer_get_max_length},
  {"insert_text",(nsp_method *) _wrap_gtk_entry_buffer_insert_text},
  {"delete_text",(nsp_method *) _wrap_gtk_entry_buffer_delete_text},
  {"emit_inserted_text",(nsp_method *) _wrap_gtk_entry_buffer_emit_inserted_text},
  {"emit_deleted_text",(nsp_method *) _wrap_gtk_entry_buffer_emit_deleted_text},
  { NULL, NULL}
};

static NspMethods *gtkentrybuffer_get_methods(void) { return gtkentrybuffer_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkentrybuffer_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkEntryCompletion ----------- */


#define  NspGtkEntryCompletion_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkentrycompletion.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkEntryCompletion inherits from GObject 
 * and implements GtkCellLayout GtkBuildable
 */

int nsp_type_gtkentrycompletion_id=0;
NspTypeGtkEntryCompletion *nsp_type_gtkentrycompletion=NULL;

/*
 * Type object for NspGtkEntryCompletion 
 * all the instance of NspTypeGtkEntryCompletion share the same id. 
 * nsp_type_gtkentrycompletion: is an instance of NspTypeGtkEntryCompletion 
 *    used for objects of NspGtkEntryCompletion type (i.e built with new_gtkentrycompletion) 
 * other instances are used for derived classes 
 */
NspTypeGtkEntryCompletion *new_type_gtkentrycompletion(type_mode mode)
{
  NspTypeGtkCellLayout *t_gtkcelllayout;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkEntryCompletion *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkentrycompletion != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkentrycompletion;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkentrycompletion_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkentrycompletion_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkentrycompletion;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkentrycompletion */ 

  top->s_type =  (s_type_func *) nsp_gtkentrycompletion_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkentrycompletion_type_short_string;
  /* top->create = (create_func*) int_gtkentrycompletion_create;*/

  /* specific methods for gtkentrycompletion */

  type->init = (init_func *) init_gtkentrycompletion;

  /* 
   * NspGtkEntryCompletion interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkcelllayout = new_type_gtkcelllayout(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkcelllayout;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkentrycompletion_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkEntryCompletion called nsp_type_gtkentrycompletion
       */
      type->id =  nsp_type_gtkentrycompletion_id = nsp_new_type_id();
      nsp_type_gtkentrycompletion = type;
      if ( nsp_register_type(nsp_type_gtkentrycompletion) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkentrycompletion, GTK_TYPE_ENTRY_COMPLETION);
      return ( mode == T_BASE ) ? type : new_type_gtkentrycompletion(mode);
    }
  else 
    {
      type->id = nsp_type_gtkentrycompletion_id;
      return type;
    }
}

/*
 * initialize NspGtkEntryCompletion instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkentrycompletion(NspGtkEntryCompletion *Obj,NspTypeGtkEntryCompletion *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkEntryCompletion 
 */

NspGtkEntryCompletion *new_gtkentrycompletion() 
{
  NspGtkEntryCompletion *loc;
  /* type must exists */
  nsp_type_gtkentrycompletion = new_type_gtkentrycompletion(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkEntryCompletion)))== NULLGTKENTRYCOMPLETION) return loc;
  /* initialize object */
  if ( init_gtkentrycompletion(loc,nsp_type_gtkentrycompletion) == FAIL) return NULLGTKENTRYCOMPLETION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkEntryCompletion 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkentrycompletion_type_name[]="GtkEntryCompletion";
static char gtkentrycompletion_short_type_name[]="GtkEntryCompletion";

static char *nsp_gtkentrycompletion_type_as_string(void)
{
  return(gtkentrycompletion_type_name);
}

static char *nsp_gtkentrycompletion_type_short_string(NspObject *v)
{
  return(gtkentrycompletion_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkEntryCompletion objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkEntryCompletion   *nsp_gtkentrycompletion_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkentrycompletion_id)  == TRUE  ) return ((NspGtkEntryCompletion *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkentrycompletion));
  return NULL;
}

int IsGtkEntryCompletionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkentrycompletion_id);
}

int IsGtkEntryCompletion(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkentrycompletion_id);
}

NspGtkEntryCompletion  *GetGtkEntryCompletionCopy(Stack stack, int i)
{
  if (  GetGtkEntryCompletion(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkEntryCompletion  *GetGtkEntryCompletion(Stack stack, int i)
{
  NspGtkEntryCompletion *M;
  if (( M = nsp_gtkentrycompletion_object(NthObj(i))) == NULLGTKENTRYCOMPLETION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkEntryCompletion *gtkentrycompletion_copy(NspGtkEntryCompletion *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkentrycompletion);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkentrycompletion);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkEntryCompletion
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_entry_completion_new_with_area (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *area;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellarea, &area) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_entry_completion_new_with_area(GTK_CELL_AREA(area->obj)))== NULL) return RET_BUG;

  nsp_type_gtkentrycompletion = new_type_gtkentrycompletion(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkentrycompletion);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_entry_completion_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_entry_completion_new())== NULL) return RET_BUG;

  nsp_type_gtkentrycompletion = new_type_gtkentrycompletion(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkentrycompletion);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_entry_completion_get_entry(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_entry_completion_get_entry(GTK_ENTRY_COMPLETION(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_entry_completion_set_model(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"model",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreeModel *model = NULL;
  NspGObject *nsp_model = NULL;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_model) == FAIL) return RET_BUG;
  if ( nsp_model != NULL ) {
    if ( IsGtkTreeModel((NspObject *)nsp_model))
      model = GTK_TREE_MODEL(nsp_model->obj);
    else if (! IsNone((NspObject *)nsp_model)) {
         Scierror( "Error: model should be a GtkTreeModel or None\n");
         return RET_BUG;
    }
  }
    gtk_entry_completion_set_model(GTK_ENTRY_COMPLETION(self->obj),model);
  return 0;
}

static int _wrap_gtk_entry_completion_get_model(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_entry_completion_get_model(GTK_ENTRY_COMPLETION(self->obj));
  nsp_type_gtktreemodel = new_type_gtktreemodel(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreemodel))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_entry_completion_set_minimum_key_length(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int length;
  if ( GetArgs(stack,rhs,opt,T,&length) == FAIL) return RET_BUG;
    gtk_entry_completion_set_minimum_key_length(GTK_ENTRY_COMPLETION(self->obj),length);
  return 0;
}

static int _wrap_gtk_entry_completion_get_minimum_key_length(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_completion_get_minimum_key_length(GTK_ENTRY_COMPLETION(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_entry_completion_compute_prefix(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *key;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&key) == FAIL) return RET_BUG;
    ret =gtk_entry_completion_compute_prefix(GTK_ENTRY_COMPLETION(self->obj),key);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

#else
int _wrap_gtk_entry_completion_compute_prefix(Stack stack, int rhs, int opt, int lhs) /* compute_prefix */
{
  Scierror("Error: function gtk_entry_completion_compute_prefix not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_entry_completion_complete(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_entry_completion_complete(GTK_ENTRY_COMPLETION(self->obj));
  return 0;
}

static int _wrap_gtk_entry_completion_insert_prefix(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_entry_completion_insert_prefix(GTK_ENTRY_COMPLETION(self->obj));
  return 0;
}

static int _wrap_gtk_entry_completion_insert_action_text(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,string, t_end};
  int index_;
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&index_, &text) == FAIL) return RET_BUG;
    gtk_entry_completion_insert_action_text(GTK_ENTRY_COMPLETION(self->obj),index_,text);
  return 0;
}

static int _wrap_gtk_entry_completion_insert_action_markup(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,string, t_end};
  int index_;
  char *markup;
  if ( GetArgs(stack,rhs,opt,T,&index_, &markup) == FAIL) return RET_BUG;
    gtk_entry_completion_insert_action_markup(GTK_ENTRY_COMPLETION(self->obj),index_,markup);
  return 0;
}

static int _wrap_gtk_entry_completion_delete_action(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int index_;
  if ( GetArgs(stack,rhs,opt,T,&index_) == FAIL) return RET_BUG;
    gtk_entry_completion_delete_action(GTK_ENTRY_COMPLETION(self->obj),index_);
  return 0;
}

static int _wrap_gtk_entry_completion_set_inline_completion(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int inline_completion;
  if ( GetArgs(stack,rhs,opt,T,&inline_completion) == FAIL) return RET_BUG;
    gtk_entry_completion_set_inline_completion(GTK_ENTRY_COMPLETION(self->obj),inline_completion);
  return 0;
}

static int _wrap_gtk_entry_completion_get_inline_completion(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_completion_get_inline_completion(GTK_ENTRY_COMPLETION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_completion_set_inline_selection(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int inline_selection;
  if ( GetArgs(stack,rhs,opt,T,&inline_selection) == FAIL) return RET_BUG;
    gtk_entry_completion_set_inline_selection(GTK_ENTRY_COMPLETION(self->obj),inline_selection);
  return 0;
}

static int _wrap_gtk_entry_completion_get_inline_selection(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_completion_get_inline_selection(GTK_ENTRY_COMPLETION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_completion_set_popup_completion(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int popup_completion;
  if ( GetArgs(stack,rhs,opt,T,&popup_completion) == FAIL) return RET_BUG;
    gtk_entry_completion_set_popup_completion(GTK_ENTRY_COMPLETION(self->obj),popup_completion);
  return 0;
}

static int _wrap_gtk_entry_completion_get_popup_completion(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_completion_get_popup_completion(GTK_ENTRY_COMPLETION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_completion_set_popup_set_width(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int popup_set_width;
  if ( GetArgs(stack,rhs,opt,T,&popup_set_width) == FAIL) return RET_BUG;
    gtk_entry_completion_set_popup_set_width(GTK_ENTRY_COMPLETION(self->obj),popup_set_width);
  return 0;
}

static int _wrap_gtk_entry_completion_get_popup_set_width(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_completion_get_popup_set_width(GTK_ENTRY_COMPLETION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_completion_set_popup_single_match(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int popup_single_match;
  if ( GetArgs(stack,rhs,opt,T,&popup_single_match) == FAIL) return RET_BUG;
    gtk_entry_completion_set_popup_single_match(GTK_ENTRY_COMPLETION(self->obj),popup_single_match);
  return 0;
}

static int _wrap_gtk_entry_completion_get_popup_single_match(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_completion_get_popup_single_match(GTK_ENTRY_COMPLETION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_completion_get_completion_prefix(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_entry_completion_get_completion_prefix(GTK_ENTRY_COMPLETION(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_entry_completion_set_text_column(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int column;
  if ( GetArgs(stack,rhs,opt,T,&column) == FAIL) return RET_BUG;
    gtk_entry_completion_set_text_column(GTK_ENTRY_COMPLETION(self->obj),column);
  return 0;
}

static int _wrap_gtk_entry_completion_get_text_column(NspGtkEntryCompletion *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_entry_completion_get_text_column(GTK_ENTRY_COMPLETION(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkentrycompletion_methods[] = {
  {"get_entry",(nsp_method *) _wrap_gtk_entry_completion_get_entry},
  {"set_model",(nsp_method *) _wrap_gtk_entry_completion_set_model},
  {"get_model",(nsp_method *) _wrap_gtk_entry_completion_get_model},
  {"set_minimum_key_length",(nsp_method *) _wrap_gtk_entry_completion_set_minimum_key_length},
  {"get_minimum_key_length",(nsp_method *) _wrap_gtk_entry_completion_get_minimum_key_length},
  {"compute_prefix",(nsp_method *) _wrap_gtk_entry_completion_compute_prefix},
  {"complete",(nsp_method *) _wrap_gtk_entry_completion_complete},
  {"insert_prefix",(nsp_method *) _wrap_gtk_entry_completion_insert_prefix},
  {"insert_action_text",(nsp_method *) _wrap_gtk_entry_completion_insert_action_text},
  {"insert_action_markup",(nsp_method *) _wrap_gtk_entry_completion_insert_action_markup},
  {"delete_action",(nsp_method *) _wrap_gtk_entry_completion_delete_action},
  {"set_inline_completion",(nsp_method *) _wrap_gtk_entry_completion_set_inline_completion},
  {"get_inline_completion",(nsp_method *) _wrap_gtk_entry_completion_get_inline_completion},
  {"set_inline_selection",(nsp_method *) _wrap_gtk_entry_completion_set_inline_selection},
  {"get_inline_selection",(nsp_method *) _wrap_gtk_entry_completion_get_inline_selection},
  {"set_popup_completion",(nsp_method *) _wrap_gtk_entry_completion_set_popup_completion},
  {"get_popup_completion",(nsp_method *) _wrap_gtk_entry_completion_get_popup_completion},
  {"set_popup_set_width",(nsp_method *) _wrap_gtk_entry_completion_set_popup_set_width},
  {"get_popup_set_width",(nsp_method *) _wrap_gtk_entry_completion_get_popup_set_width},
  {"set_popup_single_match",(nsp_method *) _wrap_gtk_entry_completion_set_popup_single_match},
  {"get_popup_single_match",(nsp_method *) _wrap_gtk_entry_completion_get_popup_single_match},
  {"get_completion_prefix",(nsp_method *) _wrap_gtk_entry_completion_get_completion_prefix},
  {"set_text_column",(nsp_method *) _wrap_gtk_entry_completion_set_text_column},
  {"get_text_column",(nsp_method *) _wrap_gtk_entry_completion_get_text_column},
  { NULL, NULL}
};

static NspMethods *gtkentrycompletion_get_methods(void) { return gtkentrycompletion_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkentrycompletion_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkScale ----------- */


#define  NspGtkScale_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkscale.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkScale inherits from GtkRange 
 * and implements GtkBuildable
 */

int nsp_type_gtkscale_id=0;
NspTypeGtkScale *nsp_type_gtkscale=NULL;

/*
 * Type object for NspGtkScale 
 * all the instance of NspTypeGtkScale share the same id. 
 * nsp_type_gtkscale: is an instance of NspTypeGtkScale 
 *    used for objects of NspGtkScale type (i.e built with new_gtkscale) 
 * other instances are used for derived classes 
 */
NspTypeGtkScale *new_type_gtkscale(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkScale *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkscale != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkscale;
    }
  if (( type =  malloc(sizeof(NspTypeGtkRange))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkrange(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkscale_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkscale_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkscale;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkscale */ 

  top->s_type =  (s_type_func *) nsp_gtkscale_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkscale_type_short_string;
  /* top->create = (create_func*) int_gtkscale_create;*/

  /* specific methods for gtkscale */

  type->init = (init_func *) init_gtkscale;

  /* 
   * NspGtkScale interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkscale_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkScale called nsp_type_gtkscale
       */
      type->id =  nsp_type_gtkscale_id = nsp_new_type_id();
      nsp_type_gtkscale = type;
      if ( nsp_register_type(nsp_type_gtkscale) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkscale, GTK_TYPE_SCALE);
      return ( mode == T_BASE ) ? type : new_type_gtkscale(mode);
    }
  else 
    {
      type->id = nsp_type_gtkscale_id;
      return type;
    }
}

/*
 * initialize NspGtkScale instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkscale(NspGtkScale *Obj,NspTypeGtkScale *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkScale 
 */

NspGtkScale *new_gtkscale() 
{
  NspGtkScale *loc;
  /* type must exists */
  nsp_type_gtkscale = new_type_gtkscale(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkScale)))== NULLGTKSCALE) return loc;
  /* initialize object */
  if ( init_gtkscale(loc,nsp_type_gtkscale) == FAIL) return NULLGTKSCALE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkScale 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkscale_type_name[]="GtkScale";
static char gtkscale_short_type_name[]="GtkScale";

static char *nsp_gtkscale_type_as_string(void)
{
  return(gtkscale_type_name);
}

static char *nsp_gtkscale_type_short_string(NspObject *v)
{
  return(gtkscale_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkScale objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkScale   *nsp_gtkscale_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkscale_id)  == TRUE  ) return ((NspGtkScale *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkscale));
  return NULL;
}

int IsGtkScaleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkscale_id);
}

int IsGtkScale(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkscale_id);
}

NspGtkScale  *GetGtkScaleCopy(Stack stack, int i)
{
  if (  GetGtkScale(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkScale  *GetGtkScale(Stack stack, int i)
{
  NspGtkScale *M;
  if (( M = nsp_gtkscale_object(NthObj(i))) == NULLGTKSCALE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkScale *gtkscale_copy(NspGtkScale *self)
{
  /* return gtkrange_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscale);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscale);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkScale
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_scale_new_with_range (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,s_double,s_double,s_double, t_end};
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;
  double min, max, step;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation, &min, &max, &step) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_scale_new_with_range(orientation,min,max,step))== NULL) return RET_BUG;

  nsp_type_gtkscale = new_type_gtkscale(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkscale);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_scale_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,new_opts, t_end};
  nsp_option opts[] = {
	{"adjustment",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;
  GtkAdjustment *adjustment = NULL;
  NspGObject *nsp_adjustment = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation, opts, &nsp_adjustment) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  if ( nsp_adjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
    else if (! IsNone((NspObject *)nsp_adjustment)) {
         Scierror( "Error: adjustment should be a GtkAdjustment or None\n");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_scale_new(orientation,adjustment))== NULL) return RET_BUG;

  nsp_type_gtkscale = new_type_gtkscale(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkscale);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scale_set_digits(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int digits;
  if ( GetArgs(stack,rhs,opt,T,&digits) == FAIL) return RET_BUG;
    gtk_scale_set_digits(GTK_SCALE(self->obj),digits);
  return 0;
}

static int _wrap_gtk_scale_get_digits(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_scale_get_digits(GTK_SCALE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scale_set_draw_value(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int draw_value;
  if ( GetArgs(stack,rhs,opt,T,&draw_value) == FAIL) return RET_BUG;
    gtk_scale_set_draw_value(GTK_SCALE(self->obj),draw_value);
  return 0;
}

static int _wrap_gtk_scale_get_draw_value(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_scale_get_draw_value(GTK_SCALE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_scale_set_has_origin(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int has_origin;
  if ( GetArgs(stack,rhs,opt,T,&has_origin) == FAIL) return RET_BUG;
    gtk_scale_set_has_origin(GTK_SCALE(self->obj),has_origin);
  return 0;
}

#else
int _wrap_gtk_scale_set_has_origin(Stack stack, int rhs, int opt, int lhs) /* set_has_origin */
{
  Scierror("Error: function gtk_scale_set_has_origin not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_scale_get_has_origin(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_scale_get_has_origin(GTK_SCALE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_scale_get_has_origin(Stack stack, int rhs, int opt, int lhs) /* get_has_origin */
{
  Scierror("Error: function gtk_scale_get_has_origin not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_scale_set_value_pos(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkPositionType pos;
  NspObject *nsp_pos = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_pos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_pos, &pos)== FAIL)
      return RET_BUG;
    gtk_scale_set_value_pos(GTK_SCALE(self->obj),pos);
  return 0;
}

static int _wrap_gtk_scale_get_value_pos(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_scale_get_value_pos(GTK_SCALE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scale_get_layout(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoLayout *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_scale_get_layout(GTK_SCALE(self->obj));
  nsp_type_pangolayout = new_type_pangolayout(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangolayout))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scale_get_layout_offsets(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int x, y;
  if ( GetArgs(stack,rhs,opt,T,&x, &y) == FAIL) return RET_BUG;
    gtk_scale_get_layout_offsets(GTK_SCALE(self->obj),&x,&y);
  return 0;
}

static int _wrap_gtk_scale_add_mark(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,obj,string, t_end};
  double value;
  GtkPositionType position;
  NspObject *nsp_position = NULL;
  char *markup;
  if ( GetArgs(stack,rhs,opt,T,&value, &nsp_position, &markup) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_position, &position)== FAIL)
      return RET_BUG;
    gtk_scale_add_mark(GTK_SCALE(self->obj),value,position,markup);
  return 0;
}

static int _wrap_gtk_scale_clear_marks(NspGtkScale *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_scale_clear_marks(GTK_SCALE(self->obj));
  return 0;
}

static NspMethods gtkscale_methods[] = {
  {"set_digits",(nsp_method *) _wrap_gtk_scale_set_digits},
  {"get_digits",(nsp_method *) _wrap_gtk_scale_get_digits},
  {"set_draw_value",(nsp_method *) _wrap_gtk_scale_set_draw_value},
  {"get_draw_value",(nsp_method *) _wrap_gtk_scale_get_draw_value},
  {"set_has_origin",(nsp_method *) _wrap_gtk_scale_set_has_origin},
  {"get_has_origin",(nsp_method *) _wrap_gtk_scale_get_has_origin},
  {"set_value_pos",(nsp_method *) _wrap_gtk_scale_set_value_pos},
  {"get_value_pos",(nsp_method *) _wrap_gtk_scale_get_value_pos},
  {"get_layout",(nsp_method *) _wrap_gtk_scale_get_layout},
  {"get_layout_offsets",(nsp_method *) _wrap_gtk_scale_get_layout_offsets},
  {"add_mark",(nsp_method *) _wrap_gtk_scale_add_mark},
  {"clear_marks",(nsp_method *) _wrap_gtk_scale_clear_marks},
  { NULL, NULL}
};

static NspMethods *gtkscale_get_methods(void) { return gtkscale_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkscale_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkSpinButton ----------- */


#define  NspGtkSpinButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkspinbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkSpinButton inherits from GtkEntry 
 * and implements GtkBuildable
 */

int nsp_type_gtkspinbutton_id=0;
NspTypeGtkSpinButton *nsp_type_gtkspinbutton=NULL;

/*
 * Type object for NspGtkSpinButton 
 * all the instance of NspTypeGtkSpinButton share the same id. 
 * nsp_type_gtkspinbutton: is an instance of NspTypeGtkSpinButton 
 *    used for objects of NspGtkSpinButton type (i.e built with new_gtkspinbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkSpinButton *new_type_gtkspinbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkSpinButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkspinbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkspinbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkEntry))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkentry(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkspinbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkspinbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkspinbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkspinbutton */ 

  top->s_type =  (s_type_func *) nsp_gtkspinbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkspinbutton_type_short_string;
  /* top->create = (create_func*) int_gtkspinbutton_create;*/

  /* specific methods for gtkspinbutton */

  type->init = (init_func *) init_gtkspinbutton;

  /* 
   * NspGtkSpinButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkspinbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSpinButton called nsp_type_gtkspinbutton
       */
      type->id =  nsp_type_gtkspinbutton_id = nsp_new_type_id();
      nsp_type_gtkspinbutton = type;
      if ( nsp_register_type(nsp_type_gtkspinbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkspinbutton, GTK_TYPE_SPIN_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkspinbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkspinbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkSpinButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkspinbutton(NspGtkSpinButton *Obj,NspTypeGtkSpinButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkSpinButton 
 */

NspGtkSpinButton *new_gtkspinbutton() 
{
  NspGtkSpinButton *loc;
  /* type must exists */
  nsp_type_gtkspinbutton = new_type_gtkspinbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSpinButton)))== NULLGTKSPINBUTTON) return loc;
  /* initialize object */
  if ( init_gtkspinbutton(loc,nsp_type_gtkspinbutton) == FAIL) return NULLGTKSPINBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkSpinButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkspinbutton_type_name[]="GtkSpinButton";
static char gtkspinbutton_short_type_name[]="GtkSpinButton";

static char *nsp_gtkspinbutton_type_as_string(void)
{
  return(gtkspinbutton_type_name);
}

static char *nsp_gtkspinbutton_type_short_string(NspObject *v)
{
  return(gtkspinbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkSpinButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkSpinButton   *nsp_gtkspinbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkspinbutton_id)  == TRUE  ) return ((NspGtkSpinButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkspinbutton));
  return NULL;
}

int IsGtkSpinButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkspinbutton_id);
}

int IsGtkSpinButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkspinbutton_id);
}

NspGtkSpinButton  *GetGtkSpinButtonCopy(Stack stack, int i)
{
  if (  GetGtkSpinButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSpinButton  *GetGtkSpinButton(Stack stack, int i)
{
  NspGtkSpinButton *M;
  if (( M = nsp_gtkspinbutton_object(NthObj(i))) == NULLGTKSPINBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSpinButton *gtkspinbutton_copy(NspGtkSpinButton *self)
{
  /* return gtkentry_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkspinbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkspinbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSpinButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_spin_button_new_with_range (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {s_double,s_double,s_double, t_end};
  double min, max, step;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&min, &max, &step) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_spin_button_new_with_range(min,max,step))== NULL) return RET_BUG;

  nsp_type_gtkspinbutton = new_type_gtkspinbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkspinbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_spin_button_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"adjustment",obj,NULLOBJ,-1},
	{"climb_rate",s_double,NULLOBJ,-1},
	{"digits",s_int,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkAdjustment *adjustment = NULL;
  NspGObject *nsp_adjustment = NULL;
  double climb_rate = 0.0;
  int digits = 0;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_adjustment, &climb_rate, &digits) == FAIL) return RET_BUG;
  if ( nsp_adjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
    else if (! IsNone((NspObject *)nsp_adjustment)) {
         Scierror( "Error: adjustment should be a GtkAdjustment or None\n");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_spin_button_new(adjustment,climb_rate,digits))== NULL) return RET_BUG;

  nsp_type_gtkspinbutton = new_type_gtkspinbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkspinbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_spin_button_configure(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"adjustment",obj,NULLOBJ,-1},
	{"climb_rate",s_double,NULLOBJ,-1},
	{"digits",s_int,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkAdjustment *adjustment = NULL;
  NspGObject *nsp_adjustment = NULL;
  double climb_rate;
  int digits;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_adjustment, &climb_rate, &digits) == FAIL) return RET_BUG;
  if ( nsp_adjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
    else if (! IsNone((NspObject *)nsp_adjustment)) {
         Scierror( "Error: adjustment should be a GtkAdjustment or None\n");
         return RET_BUG;
    }
  }
    gtk_spin_button_configure(GTK_SPIN_BUTTON(self->obj),adjustment,climb_rate,digits);
  return 0;
}

static int _wrap_gtk_spin_button_set_adjustment(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *adjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
    gtk_spin_button_set_adjustment(GTK_SPIN_BUTTON(self->obj),GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_spin_button_get_adjustment(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAdjustment *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_spin_button_get_adjustment(GTK_SPIN_BUTTON(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_spin_button_set_digits(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int digits;
  if ( GetArgs(stack,rhs,opt,T,&digits) == FAIL) return RET_BUG;
    gtk_spin_button_set_digits(GTK_SPIN_BUTTON(self->obj),digits);
  return 0;
}

static int _wrap_gtk_spin_button_get_digits(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_spin_button_get_digits(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_set_increments(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,s_double, t_end};
  double step, page;
  if ( GetArgs(stack,rhs,opt,T,&step, &page) == FAIL) return RET_BUG;
    gtk_spin_button_set_increments(GTK_SPIN_BUTTON(self->obj),step,page);
  return 0;
}

#line 1249 "codegen-3.0/gtk.override"
static int
_wrap_gtk_spin_button_get_increments(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gdouble step;
  gdouble page;

  gtk_spin_button_get_increments(GTK_SPIN_BUTTON(self->obj), &step, &page);
  if (  nsp_move_doubles(stack,1,1,2,(double) step,(double) page) == FAIL)
    return RET_BUG;
  return 1;

}
#line 33956 "gtk.c"


static int _wrap_gtk_spin_button_set_range(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,s_double, t_end};
  double min, max;
  if ( GetArgs(stack,rhs,opt,T,&min, &max) == FAIL) return RET_BUG;
    gtk_spin_button_set_range(GTK_SPIN_BUTTON(self->obj),min,max);
  return 0;
}

#line 1263 "codegen-3.0/gtk.override"
static int
_wrap_gtk_spin_button_get_range(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gdouble min;
  gdouble max;

  gtk_spin_button_get_range(GTK_SPIN_BUTTON(self->obj), &min, &max);
  if (  nsp_move_doubles(stack,1,1,2,(double) min,(double) max) == FAIL)
    return RET_BUG;
  return 1;
}
#line 33980 "gtk.c"


static int _wrap_gtk_spin_button_get_value(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_spin_button_get_value(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_get_value_as_int(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_set_value(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double value;
  if ( GetArgs(stack,rhs,opt,T,&value) == FAIL) return RET_BUG;
    gtk_spin_button_set_value(GTK_SPIN_BUTTON(self->obj),value);
  return 0;
}

static int _wrap_gtk_spin_button_set_update_policy(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSpinButtonUpdatePolicy policy;
  NspObject *nsp_policy = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_policy) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SPIN_BUTTON_UPDATE_POLICY, nsp_policy, &policy)== FAIL)
      return RET_BUG;
    gtk_spin_button_set_update_policy(GTK_SPIN_BUTTON(self->obj),policy);
  return 0;
}

static int _wrap_gtk_spin_button_get_update_policy(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_spin_button_get_update_policy(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_set_numeric(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int numeric;
  if ( GetArgs(stack,rhs,opt,T,&numeric) == FAIL) return RET_BUG;
    gtk_spin_button_set_numeric(GTK_SPIN_BUTTON(self->obj),numeric);
  return 0;
}

static int _wrap_gtk_spin_button_get_numeric(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_spin_button_get_numeric(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_spin(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_double, t_end};
  GtkSpinType direction;
  NspObject *nsp_direction = NULL;
  double increment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_direction, &increment) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SPIN_TYPE, nsp_direction, &direction)== FAIL)
      return RET_BUG;
    gtk_spin_button_spin(GTK_SPIN_BUTTON(self->obj),direction,increment);
  return 0;
}

static int _wrap_gtk_spin_button_set_wrap(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int wrap;
  if ( GetArgs(stack,rhs,opt,T,&wrap) == FAIL) return RET_BUG;
    gtk_spin_button_set_wrap(GTK_SPIN_BUTTON(self->obj),wrap);
  return 0;
}

static int _wrap_gtk_spin_button_get_wrap(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_spin_button_get_wrap(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_set_snap_to_ticks(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int snap_to_ticks;
  if ( GetArgs(stack,rhs,opt,T,&snap_to_ticks) == FAIL) return RET_BUG;
    gtk_spin_button_set_snap_to_ticks(GTK_SPIN_BUTTON(self->obj),snap_to_ticks);
  return 0;
}

static int _wrap_gtk_spin_button_get_snap_to_ticks(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_spin_button_get_snap_to_ticks(GTK_SPIN_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_spin_button_update(NspGtkSpinButton *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_spin_button_update(GTK_SPIN_BUTTON(self->obj));
  return 0;
}

static NspMethods gtkspinbutton_methods[] = {
  {"configure",(nsp_method *) _wrap_gtk_spin_button_configure},
  {"set_adjustment",(nsp_method *) _wrap_gtk_spin_button_set_adjustment},
  {"get_adjustment",(nsp_method *) _wrap_gtk_spin_button_get_adjustment},
  {"set_digits",(nsp_method *) _wrap_gtk_spin_button_set_digits},
  {"get_digits",(nsp_method *) _wrap_gtk_spin_button_get_digits},
  {"set_increments",(nsp_method *) _wrap_gtk_spin_button_set_increments},
  {"get_increments",(nsp_method *) _wrap_gtk_spin_button_get_increments},
  {"set_range",(nsp_method *) _wrap_gtk_spin_button_set_range},
  {"get_range",(nsp_method *) _wrap_gtk_spin_button_get_range},
  {"get_value",(nsp_method *) _wrap_gtk_spin_button_get_value},
  {"get_value_as_int",(nsp_method *) _wrap_gtk_spin_button_get_value_as_int},
  {"set_value",(nsp_method *) _wrap_gtk_spin_button_set_value},
  {"set_update_policy",(nsp_method *) _wrap_gtk_spin_button_set_update_policy},
  {"get_update_policy",(nsp_method *) _wrap_gtk_spin_button_get_update_policy},
  {"set_numeric",(nsp_method *) _wrap_gtk_spin_button_set_numeric},
  {"get_numeric",(nsp_method *) _wrap_gtk_spin_button_get_numeric},
  {"spin",(nsp_method *) _wrap_gtk_spin_button_spin},
  {"set_wrap",(nsp_method *) _wrap_gtk_spin_button_set_wrap},
  {"get_wrap",(nsp_method *) _wrap_gtk_spin_button_get_wrap},
  {"set_snap_to_ticks",(nsp_method *) _wrap_gtk_spin_button_set_snap_to_ticks},
  {"get_snap_to_ticks",(nsp_method *) _wrap_gtk_spin_button_get_snap_to_ticks},
  {"update",(nsp_method *) _wrap_gtk_spin_button_update},
  { NULL, NULL}
};

static NspMethods *gtkspinbutton_get_methods(void) { return gtkspinbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkspinbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkSearchEntry ----------- */


#define  NspGtkSearchEntry_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtksearchentry.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkSearchEntry inherits from GtkEntry 
 * and implements GtkEditable GtkCellEditable GtkBuildable
 */

int nsp_type_gtksearchentry_id=0;
NspTypeGtkSearchEntry *nsp_type_gtksearchentry=NULL;

/*
 * Type object for NspGtkSearchEntry 
 * all the instance of NspTypeGtkSearchEntry share the same id. 
 * nsp_type_gtksearchentry: is an instance of NspTypeGtkSearchEntry 
 *    used for objects of NspGtkSearchEntry type (i.e built with new_gtksearchentry) 
 * other instances are used for derived classes 
 */
NspTypeGtkSearchEntry *new_type_gtksearchentry(type_mode mode)
{
  NspTypeGtkEditable *t_gtkeditable;
  NspTypeGtkCellEditable *t_gtkcelleditable;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkSearchEntry *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtksearchentry != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtksearchentry;
    }
  if (( type =  malloc(sizeof(NspTypeGtkEntry))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkentry(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtksearchentry_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtksearchentry_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtksearchentry;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtksearchentry */ 

  top->s_type =  (s_type_func *) nsp_gtksearchentry_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtksearchentry_type_short_string;
  /* top->create = (create_func*) int_gtksearchentry_create;*/

  /* specific methods for gtksearchentry */

  type->init = (init_func *) init_gtksearchentry;

  /* 
   * NspGtkSearchEntry interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkeditable = new_type_gtkeditable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkeditable;
  t_gtkcelleditable = new_type_gtkcelleditable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkcelleditable;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtksearchentry_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSearchEntry called nsp_type_gtksearchentry
       */
      type->id =  nsp_type_gtksearchentry_id = nsp_new_type_id();
      nsp_type_gtksearchentry = type;
      if ( nsp_register_type(nsp_type_gtksearchentry) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtksearchentry, GTK_TYPE_SEARCH_ENTRY);
      return ( mode == T_BASE ) ? type : new_type_gtksearchentry(mode);
    }
  else 
    {
      type->id = nsp_type_gtksearchentry_id;
      return type;
    }
}

/*
 * initialize NspGtkSearchEntry instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtksearchentry(NspGtkSearchEntry *Obj,NspTypeGtkSearchEntry *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkSearchEntry 
 */

NspGtkSearchEntry *new_gtksearchentry() 
{
  NspGtkSearchEntry *loc;
  /* type must exists */
  nsp_type_gtksearchentry = new_type_gtksearchentry(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSearchEntry)))== NULLGTKSEARCHENTRY) return loc;
  /* initialize object */
  if ( init_gtksearchentry(loc,nsp_type_gtksearchentry) == FAIL) return NULLGTKSEARCHENTRY;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkSearchEntry 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtksearchentry_type_name[]="GtkSearchEntry";
static char gtksearchentry_short_type_name[]="GtkSearchEntry";

static char *nsp_gtksearchentry_type_as_string(void)
{
  return(gtksearchentry_type_name);
}

static char *nsp_gtksearchentry_type_short_string(NspObject *v)
{
  return(gtksearchentry_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkSearchEntry objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkSearchEntry   *nsp_gtksearchentry_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtksearchentry_id)  == TRUE  ) return ((NspGtkSearchEntry *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtksearchentry));
  return NULL;
}

int IsGtkSearchEntryObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtksearchentry_id);
}

int IsGtkSearchEntry(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtksearchentry_id);
}

NspGtkSearchEntry  *GetGtkSearchEntryCopy(Stack stack, int i)
{
  if (  GetGtkSearchEntry(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSearchEntry  *GetGtkSearchEntry(Stack stack, int i)
{
  NspGtkSearchEntry *M;
  if (( M = nsp_gtksearchentry_object(NthObj(i))) == NULLGTKSEARCHENTRY)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSearchEntry *gtksearchentry_copy(NspGtkSearchEntry *self)
{
  /* return gtkentry_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksearchentry);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksearchentry);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSearchEntry
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_search_entry_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_search_entry_new())== NULL) return RET_BUG;

  nsp_type_gtksearchentry = new_type_gtksearchentry(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtksearchentry);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_search_entry_handle_event(NspGtkSearchEntry *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    ret =gtk_search_entry_handle_event(GTK_SEARCH_ENTRY(self->obj),event);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_search_entry_handle_event(Stack stack, int rhs, int opt, int lhs) /* handle_event */
{
  Scierror("Error: function gtk_search_entry_handle_event not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtksearchentry_methods[] = {
  {"handle_event",(nsp_method *) _wrap_gtk_search_entry_handle_event},
  { NULL, NULL}
};

static NspMethods *gtksearchentry_get_methods(void) { return gtksearchentry_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtksearchentry_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkSearchBar ----------- */


#define  NspGtkSearchBar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtksearchbar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkSearchBar inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtksearchbar_id=0;
NspTypeGtkSearchBar *nsp_type_gtksearchbar=NULL;

/*
 * Type object for NspGtkSearchBar 
 * all the instance of NspTypeGtkSearchBar share the same id. 
 * nsp_type_gtksearchbar: is an instance of NspTypeGtkSearchBar 
 *    used for objects of NspGtkSearchBar type (i.e built with new_gtksearchbar) 
 * other instances are used for derived classes 
 */
NspTypeGtkSearchBar *new_type_gtksearchbar(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkSearchBar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtksearchbar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtksearchbar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtksearchbar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtksearchbar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtksearchbar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtksearchbar */ 

  top->s_type =  (s_type_func *) nsp_gtksearchbar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtksearchbar_type_short_string;
  /* top->create = (create_func*) int_gtksearchbar_create;*/

  /* specific methods for gtksearchbar */

  type->init = (init_func *) init_gtksearchbar;

  /* 
   * NspGtkSearchBar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtksearchbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSearchBar called nsp_type_gtksearchbar
       */
      type->id =  nsp_type_gtksearchbar_id = nsp_new_type_id();
      nsp_type_gtksearchbar = type;
      if ( nsp_register_type(nsp_type_gtksearchbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtksearchbar, GTK_TYPE_SEARCH_BAR);
      return ( mode == T_BASE ) ? type : new_type_gtksearchbar(mode);
    }
  else 
    {
      type->id = nsp_type_gtksearchbar_id;
      return type;
    }
}

/*
 * initialize NspGtkSearchBar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtksearchbar(NspGtkSearchBar *Obj,NspTypeGtkSearchBar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkSearchBar 
 */

NspGtkSearchBar *new_gtksearchbar() 
{
  NspGtkSearchBar *loc;
  /* type must exists */
  nsp_type_gtksearchbar = new_type_gtksearchbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSearchBar)))== NULLGTKSEARCHBAR) return loc;
  /* initialize object */
  if ( init_gtksearchbar(loc,nsp_type_gtksearchbar) == FAIL) return NULLGTKSEARCHBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkSearchBar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtksearchbar_type_name[]="GtkSearchBar";
static char gtksearchbar_short_type_name[]="GtkSearchBar";

static char *nsp_gtksearchbar_type_as_string(void)
{
  return(gtksearchbar_type_name);
}

static char *nsp_gtksearchbar_type_short_string(NspObject *v)
{
  return(gtksearchbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkSearchBar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkSearchBar   *nsp_gtksearchbar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtksearchbar_id)  == TRUE  ) return ((NspGtkSearchBar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtksearchbar));
  return NULL;
}

int IsGtkSearchBarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtksearchbar_id);
}

int IsGtkSearchBar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtksearchbar_id);
}

NspGtkSearchBar  *GetGtkSearchBarCopy(Stack stack, int i)
{
  if (  GetGtkSearchBar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSearchBar  *GetGtkSearchBar(Stack stack, int i)
{
  NspGtkSearchBar *M;
  if (( M = nsp_gtksearchbar_object(NthObj(i))) == NULLGTKSEARCHBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSearchBar *gtksearchbar_copy(NspGtkSearchBar *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksearchbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksearchbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSearchBar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_search_bar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_search_bar_new())== NULL) return RET_BUG;

  nsp_type_gtksearchbar = new_type_gtksearchbar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtksearchbar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_search_bar_connect_entry(NspGtkSearchBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *entry;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkentry, &entry) == FAIL) return RET_BUG;
    gtk_search_bar_connect_entry(GTK_SEARCH_BAR(self->obj),GTK_ENTRY(entry->obj));
  return 0;
}

#else
int _wrap_gtk_search_bar_connect_entry(Stack stack, int rhs, int opt, int lhs) /* connect_entry */
{
  Scierror("Error: function gtk_search_bar_connect_entry not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_search_bar_get_search_mode(NspGtkSearchBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_search_bar_get_search_mode(GTK_SEARCH_BAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_search_bar_get_search_mode(Stack stack, int rhs, int opt, int lhs) /* get_search_mode */
{
  Scierror("Error: function gtk_search_bar_get_search_mode not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_search_bar_set_search_mode(NspGtkSearchBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int search_mode;
  if ( GetArgs(stack,rhs,opt,T,&search_mode) == FAIL) return RET_BUG;
    gtk_search_bar_set_search_mode(GTK_SEARCH_BAR(self->obj),search_mode);
  return 0;
}

#else
int _wrap_gtk_search_bar_set_search_mode(Stack stack, int rhs, int opt, int lhs) /* set_search_mode */
{
  Scierror("Error: function gtk_search_bar_set_search_mode not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_search_bar_get_show_close_button(NspGtkSearchBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_search_bar_get_show_close_button(GTK_SEARCH_BAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_search_bar_get_show_close_button(Stack stack, int rhs, int opt, int lhs) /* get_show_close_button */
{
  Scierror("Error: function gtk_search_bar_get_show_close_button not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_search_bar_set_show_close_button(NspGtkSearchBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int visible;
  if ( GetArgs(stack,rhs,opt,T,&visible) == FAIL) return RET_BUG;
    gtk_search_bar_set_show_close_button(GTK_SEARCH_BAR(self->obj),visible);
  return 0;
}

#else
int _wrap_gtk_search_bar_set_show_close_button(Stack stack, int rhs, int opt, int lhs) /* set_show_close_button */
{
  Scierror("Error: function gtk_search_bar_set_show_close_button not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_search_bar_handle_event(NspGtkSearchBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    ret =gtk_search_bar_handle_event(GTK_SEARCH_BAR(self->obj),event);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_search_bar_handle_event(Stack stack, int rhs, int opt, int lhs) /* handle_event */
{
  Scierror("Error: function gtk_search_bar_handle_event not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtksearchbar_methods[] = {
  {"connect_entry",(nsp_method *) _wrap_gtk_search_bar_connect_entry},
  {"get_search_mode",(nsp_method *) _wrap_gtk_search_bar_get_search_mode},
  {"set_search_mode",(nsp_method *) _wrap_gtk_search_bar_set_search_mode},
  {"get_show_close_button",(nsp_method *) _wrap_gtk_search_bar_get_show_close_button},
  {"set_show_close_button",(nsp_method *) _wrap_gtk_search_bar_set_show_close_button},
  {"handle_event",(nsp_method *) _wrap_gtk_search_bar_handle_event},
  { NULL, NULL}
};

static NspMethods *gtksearchbar_get_methods(void) { return gtksearchbar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtksearchbar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTextMark ----------- */


#define  NspGtkTextMark_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktextmark.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTextMark inherits from GObject 
 */

int nsp_type_gtktextmark_id=0;
NspTypeGtkTextMark *nsp_type_gtktextmark=NULL;

/*
 * Type object for NspGtkTextMark 
 * all the instance of NspTypeGtkTextMark share the same id. 
 * nsp_type_gtktextmark: is an instance of NspTypeGtkTextMark 
 *    used for objects of NspGtkTextMark type (i.e built with new_gtktextmark) 
 * other instances are used for derived classes 
 */
NspTypeGtkTextMark *new_type_gtktextmark(type_mode mode)
{
  NspTypeGtkTextMark *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextmark != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextmark;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextmark_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktextmark_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktextmark;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktextmark */ 

  top->s_type =  (s_type_func *) nsp_gtktextmark_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktextmark_type_short_string;
  /* top->create = (create_func*) int_gtktextmark_create;*/

  /* specific methods for gtktextmark */

  type->init = (init_func *) init_gtktextmark;

  /* 
   * NspGtkTextMark interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktextmark_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextMark called nsp_type_gtktextmark
       */
      type->id =  nsp_type_gtktextmark_id = nsp_new_type_id();
      nsp_type_gtktextmark = type;
      if ( nsp_register_type(nsp_type_gtktextmark) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextmark, GTK_TYPE_TEXT_MARK);
      return ( mode == T_BASE ) ? type : new_type_gtktextmark(mode);
    }
  else 
    {
      type->id = nsp_type_gtktextmark_id;
      return type;
    }
}

/*
 * initialize NspGtkTextMark instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextmark(NspGtkTextMark *Obj,NspTypeGtkTextMark *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTextMark 
 */

NspGtkTextMark *new_gtktextmark() 
{
  NspGtkTextMark *loc;
  /* type must exists */
  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextMark)))== NULLGTKTEXTMARK) return loc;
  /* initialize object */
  if ( init_gtktextmark(loc,nsp_type_gtktextmark) == FAIL) return NULLGTKTEXTMARK;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTextMark 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktextmark_type_name[]="GtkTextMark";
static char gtktextmark_short_type_name[]="GtkTextMark";

static char *nsp_gtktextmark_type_as_string(void)
{
  return(gtktextmark_type_name);
}

static char *nsp_gtktextmark_type_short_string(NspObject *v)
{
  return(gtktextmark_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTextMark objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTextMark   *nsp_gtktextmark_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktextmark_id)  == TRUE  ) return ((NspGtkTextMark *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextmark));
  return NULL;
}

int IsGtkTextMarkObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktextmark_id);
}

int IsGtkTextMark(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextmark_id);
}

NspGtkTextMark  *GetGtkTextMarkCopy(Stack stack, int i)
{
  if (  GetGtkTextMark(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextMark  *GetGtkTextMark(Stack stack, int i)
{
  NspGtkTextMark *M;
  if (( M = nsp_gtktextmark_object(NthObj(i))) == NULLGTKTEXTMARK)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextMark *gtktextmark_copy(NspGtkTextMark *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextmark);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextmark);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextMark
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_text_mark_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,s_bool, t_end};
  char *name;
  int left_gravity;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&name, &left_gravity) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_text_mark_new(name,left_gravity))== NULL) return RET_BUG;

  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextmark);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_mark_set_visible(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_text_mark_set_visible(GTK_TEXT_MARK(self->obj),setting);
  return 0;
}

static int _wrap_gtk_text_mark_get_visible(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_mark_get_visible(GTK_TEXT_MARK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_mark_get_name(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_text_mark_get_name(GTK_TEXT_MARK(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_mark_get_deleted(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_mark_get_deleted(GTK_TEXT_MARK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_mark_get_buffer(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextBuffer *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_text_mark_get_buffer(GTK_TEXT_MARK(self->obj));
  nsp_type_gtktextbuffer = new_type_gtktextbuffer(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextbuffer))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_mark_get_left_gravity(NspGtkTextMark *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_mark_get_left_gravity(GTK_TEXT_MARK(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktextmark_methods[] = {
  {"set_visible",(nsp_method *) _wrap_gtk_text_mark_set_visible},
  {"get_visible",(nsp_method *) _wrap_gtk_text_mark_get_visible},
  {"get_name",(nsp_method *) _wrap_gtk_text_mark_get_name},
  {"get_deleted",(nsp_method *) _wrap_gtk_text_mark_get_deleted},
  {"get_buffer",(nsp_method *) _wrap_gtk_text_mark_get_buffer},
  {"get_left_gravity",(nsp_method *) _wrap_gtk_text_mark_get_left_gravity},
  { NULL, NULL}
};

static NspMethods *gtktextmark_get_methods(void) { return gtktextmark_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktextmark_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTextBuffer ----------- */


#define  NspGtkTextBuffer_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktextbuffer.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTextBuffer inherits from GObject 
 */

int nsp_type_gtktextbuffer_id=0;
NspTypeGtkTextBuffer *nsp_type_gtktextbuffer=NULL;

/*
 * Type object for NspGtkTextBuffer 
 * all the instance of NspTypeGtkTextBuffer share the same id. 
 * nsp_type_gtktextbuffer: is an instance of NspTypeGtkTextBuffer 
 *    used for objects of NspGtkTextBuffer type (i.e built with new_gtktextbuffer) 
 * other instances are used for derived classes 
 */
NspTypeGtkTextBuffer *new_type_gtktextbuffer(type_mode mode)
{
  NspTypeGtkTextBuffer *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextbuffer != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextbuffer;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextbuffer_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktextbuffer_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktextbuffer;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktextbuffer */ 

  top->s_type =  (s_type_func *) nsp_gtktextbuffer_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktextbuffer_type_short_string;
  /* top->create = (create_func*) int_gtktextbuffer_create;*/

  /* specific methods for gtktextbuffer */

  type->init = (init_func *) init_gtktextbuffer;

  /* 
   * NspGtkTextBuffer interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktextbuffer_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextBuffer called nsp_type_gtktextbuffer
       */
      type->id =  nsp_type_gtktextbuffer_id = nsp_new_type_id();
      nsp_type_gtktextbuffer = type;
      if ( nsp_register_type(nsp_type_gtktextbuffer) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextbuffer, GTK_TYPE_TEXT_BUFFER);
      return ( mode == T_BASE ) ? type : new_type_gtktextbuffer(mode);
    }
  else 
    {
      type->id = nsp_type_gtktextbuffer_id;
      return type;
    }
}

/*
 * initialize NspGtkTextBuffer instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextbuffer(NspGtkTextBuffer *Obj,NspTypeGtkTextBuffer *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTextBuffer 
 */

NspGtkTextBuffer *new_gtktextbuffer() 
{
  NspGtkTextBuffer *loc;
  /* type must exists */
  nsp_type_gtktextbuffer = new_type_gtktextbuffer(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextBuffer)))== NULLGTKTEXTBUFFER) return loc;
  /* initialize object */
  if ( init_gtktextbuffer(loc,nsp_type_gtktextbuffer) == FAIL) return NULLGTKTEXTBUFFER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTextBuffer 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktextbuffer_type_name[]="GtkTextBuffer";
static char gtktextbuffer_short_type_name[]="GtkTextBuffer";

static char *nsp_gtktextbuffer_type_as_string(void)
{
  return(gtktextbuffer_type_name);
}

static char *nsp_gtktextbuffer_type_short_string(NspObject *v)
{
  return(gtktextbuffer_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTextBuffer objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTextBuffer   *nsp_gtktextbuffer_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktextbuffer_id)  == TRUE  ) return ((NspGtkTextBuffer *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextbuffer));
  return NULL;
}

int IsGtkTextBufferObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktextbuffer_id);
}

int IsGtkTextBuffer(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextbuffer_id);
}

NspGtkTextBuffer  *GetGtkTextBufferCopy(Stack stack, int i)
{
  if (  GetGtkTextBuffer(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextBuffer  *GetGtkTextBuffer(Stack stack, int i)
{
  NspGtkTextBuffer *M;
  if (( M = nsp_gtktextbuffer_object(NthObj(i))) == NULLGTKTEXTBUFFER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextBuffer *gtktextbuffer_copy(NspGtkTextBuffer *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextbuffer);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextbuffer);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextBuffer
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_text_buffer_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"table",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTextTagTable *table = NULL;
  NspGObject *nsp_table = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_table) == FAIL) return RET_BUG;
  if ( nsp_table != NULL ) {
    if ( IsGtkTextTagTable((NspObject *)nsp_table))
      table = GTK_TEXT_TAG_TABLE(nsp_table->obj);
    else if (! IsNone((NspObject *)nsp_table)) {
         Scierror( "Error: table should be a GtkTextTagTable or None\n");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_text_buffer_new(table))== NULL) return RET_BUG;

  nsp_type_gtktextbuffer = new_type_gtktextbuffer(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextbuffer);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_get_line_count(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_buffer_get_line_count(GTK_TEXT_BUFFER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_get_char_count(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_buffer_get_char_count(GTK_TEXT_BUFFER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_get_tag_table(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextTagTable *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_text_buffer_get_tag_table(GTK_TEXT_BUFFER(self->obj));
  nsp_type_gtktexttagtable = new_type_gtktexttagtable(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktexttagtable))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 6022 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_set_text(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  char *text;
  int_types T[] = { string, t_end} ;
  if (GetArgs(stack,rhs,opt,T, &text) == FAIL) return RET_BUG;
  gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->obj), text, strlen(text));
  return 0;
}
#line 35273 "gtk.c"


#line 6052 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_insert(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check , string, t_end} ;
  NspObject *nsp_iter;
  char *text;
  GtkTextIter *iter = NULL;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter,  &nsp_iter, &text)  == FAIL) return RET_BUG;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text));
  return 0;
}
#line 35290 "gtk.c"


#line 6067 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_insert_at_cursor(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { string, t_end} ;
  char *text;

  if (GetArgs(stack,rhs,opt,T, &text)  == FAIL) return RET_BUG;
  gtk_text_buffer_insert_at_cursor(GTK_TEXT_BUFFER(self->obj), text,strlen(text));
  return 0;
}
#line 35304 "gtk.c"


#line 6079 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_insert_interactive(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check ,string,s_bool, t_end} ;
  /* static char *kwlist[] = { "iter", "text", "default_editable", NULL };*/
  NspObject *nsp_iter;
  char *text;
  int default_editable, ret;
  GtkTextIter *iter = NULL;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter,&nsp_iter, &text, &default_editable) == FAIL) return RET_BUG;;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  ret = gtk_text_buffer_insert_interactive(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text), default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}
#line 35324 "gtk.c"


#line 6097 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_insert_interactive_at_cursor(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_bool, t_end} ;
  char *text;
  int  default_editable, ret;
  if (GetArgs(stack,rhs,opt,T, &text, &default_editable) ==  FAIL) return RET_BUG;;
  ret = gtk_text_buffer_insert_interactive_at_cursor(GTK_TEXT_BUFFER(self->obj), text,strlen(text), default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}
#line 35339 "gtk.c"


static int _wrap_gtk_text_buffer_insert_range(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj,obj, t_end};
  GtkTextIter *iter = NULL, *start = NULL, *end = NULL;
  NspObject *nsp_iter = NULL, *nsp_start = NULL, *nsp_end = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "Error: start should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "Error: end should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_insert_range(GTK_TEXT_BUFFER(self->obj),iter,start,end);
  return 0;
}

static int _wrap_gtk_text_buffer_insert_range_interactive(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj,obj,s_bool, t_end};
  GtkTextIter *iter = NULL, *start = NULL, *end = NULL;
  NspObject *nsp_iter = NULL, *nsp_start = NULL, *nsp_end = NULL;
  int default_editable, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_start, &nsp_end, &default_editable) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "Error: start should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "Error: end should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_buffer_insert_range_interactive(GTK_TEXT_BUFFER(self->obj),iter,start,end,default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 5773 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_insert_with_tags(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject  *nsp_iter;
  gint i,  start_offset;
  gchar *text;
  GtkTextIter *iter, start;

  if (rhs - opt < 1) {
    Scierror("GtkTextBuffer.insert_with_tags requires at least one argument (iter)");
    return RET_BUG;
  }
  
  if (( nsp_iter = (NspObject *) GetGtkTextIter(stack,1)) == NULL) return RET_BUG;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  
  if ( rhs >= 2)
    {
      if (( text = GetString(stack,2))== NULL) return RET_BUG;
      start_offset = gtk_text_iter_get_offset(iter);
      gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text));
      gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj), &start, start_offset);
    }
  for (i = 3; i <= rhs ; i++)
    {
      NspGtkTextTag *Tag;
      if (( Tag = (NspGtkTextTag *) GetGtkTextTag(stack,i))== NULL) return RET_BUG;
      gtk_text_buffer_apply_tag(GTK_TEXT_BUFFER(self->obj),
				GTK_TEXT_TAG(Tag->obj), &start, iter);
    }
  return 0;
}
#line 35433 "gtk.c"


#line 5807 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_insert_with_tags_by_name(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject  *nsp_iter;
  gint  i, start_offset;
  gchar *text;
  GtkTextIter *iter, start;

  if (rhs-opt < 1) {
    Scierror("GtkTextBuffer.insert_with_tags_by_name requires at least one argument (iter)");
    return RET_BUG;
  }

  if (( nsp_iter =(NspObject *)  GetGtkTextIter(stack,1)) == NULL) return RET_BUG;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  
  if ( rhs >= 2)
    {
      if (( text = GetString(stack,2))== NULL) return RET_BUG;
      start_offset = gtk_text_iter_get_offset(iter);
      gtk_text_buffer_insert(GTK_TEXT_BUFFER(self->obj), iter, text,strlen(text));
      gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj), &start, start_offset);
    }
  for (i = 3; i <= rhs ; i++)
    {
      char *tagname;
      if (( tagname = GetString(stack,i))== NULL) return RET_BUG;
      gtk_text_buffer_apply_tag_by_name(GTK_TEXT_BUFFER(self->obj),tagname, &start, iter);
    }
  return 0;
}
#line 35468 "gtk.c"


#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_text_buffer_insert_markup(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,string,s_int, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  char *markup;
  int len;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &markup, &len) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_insert_markup(GTK_TEXT_BUFFER(self->obj),iter,markup,len);
  return 0;
}

#else
int _wrap_gtk_text_buffer_insert_markup(Stack stack, int rhs, int opt, int lhs) /* insert_markup */
{
  Scierror("Error: function gtk_text_buffer_insert_markup not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_text_buffer_delete(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTextIter *start = NULL, *end = NULL;
  NspObject *nsp_start = NULL, *nsp_end = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "Error: start should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "Error: end should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_delete(GTK_TEXT_BUFFER(self->obj),start,end);
  return 0;
}

static int _wrap_gtk_text_buffer_delete_interactive(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj,s_bool, t_end};
  GtkTextIter *start_iter = NULL, *end_iter = NULL;
  NspObject *nsp_start_iter = NULL, *nsp_end_iter = NULL;
  int default_editable, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_start_iter, &nsp_end_iter, &default_editable) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start_iter, GTK_TYPE_TEXT_ITER))
      start_iter = nspg_boxed_get(nsp_start_iter, GtkTextIter);
  else {
      Scierror( "Error: start_iter should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end_iter, GTK_TYPE_TEXT_ITER))
      end_iter = nspg_boxed_get(nsp_end_iter, GtkTextIter);
  else {
      Scierror( "Error: end_iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_buffer_delete_interactive(GTK_TEXT_BUFFER(self->obj),start_iter,end_iter,default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_backspace(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_bool,s_bool, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int interactive, default_editable, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &interactive, &default_editable) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_buffer_backspace(GTK_TEXT_BUFFER(self->obj),iter,interactive,default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_get_text(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj,new_opts, t_end};
  nsp_option opts[] = {
	{"include_hidden_chars",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTextIter *start = NULL, *end = NULL;
  NspObject *nsp_start = NULL, *nsp_end = NULL;
  int include_hidden_chars = TRUE;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_start, &nsp_end, opts, &include_hidden_chars) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "Error: start should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "Error: end should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_buffer_get_text(GTK_TEXT_BUFFER(self->obj),start,end,include_hidden_chars);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_text_buffer_get_slice(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj,new_opts, t_end};
  nsp_option opts[] = {
	{"include_hidden_chars",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTextIter *start = NULL, *end = NULL;
  NspObject *nsp_start = NULL, *nsp_end = NULL;
  int include_hidden_chars = TRUE;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_start, &nsp_end, opts, &include_hidden_chars) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "Error: start should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "Error: end should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_buffer_get_slice(GTK_TEXT_BUFFER(self->obj),start,end,include_hidden_chars);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_text_buffer_insert_pixbuf(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  NspGObject *pixbuf;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_insert_pixbuf(GTK_TEXT_BUFFER(self->obj),iter,GDK_PIXBUF(pixbuf->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_insert_child_anchor(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  NspGObject *anchor;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_type_gtktextchildanchor, &anchor) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_insert_child_anchor(GTK_TEXT_BUFFER(self->obj),iter,GTK_TEXT_CHILD_ANCHOR(anchor->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_create_child_anchor(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL, *nsp_ret;
  GtkTextChildAnchor *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_buffer_create_child_anchor(GTK_TEXT_BUFFER(self->obj),iter);
  nsp_type_gtktextchildanchor = new_type_gtktextchildanchor(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextchildanchor))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_add_mark(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *mark;
  GtkTextIter *where = NULL;
  NspObject *nsp_where = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark, &nsp_where) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_where, GTK_TYPE_TEXT_ITER))
      where = nspg_boxed_get(nsp_where, GtkTextIter);
  else {
      Scierror( "Error: where should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_add_mark(GTK_TEXT_BUFFER(self->obj),GTK_TEXT_MARK(mark->obj),where);
  return 0;
}

static int _wrap_gtk_text_buffer_create_mark(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"mark_name",string,NULLOBJ,-1},
	{"where",obj,NULLOBJ,-1},
	{"left_gravity",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  char *mark_name = NULL;
  GtkTextIter *where = NULL;
  NspObject *nsp_where = NULL, *nsp_ret;
  int left_gravity = FALSE;
  GtkTextMark *ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &mark_name, &nsp_where, &left_gravity) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_where, GTK_TYPE_TEXT_ITER))
      where = nspg_boxed_get(nsp_where, GtkTextIter);
  else {
      Scierror( "Error: where should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_buffer_create_mark(GTK_TEXT_BUFFER(self->obj),mark_name,where,left_gravity);
  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextmark))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_move_mark(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *mark;
  GtkTextIter *where = NULL;
  NspObject *nsp_where = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark, &nsp_where) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_where, GTK_TYPE_TEXT_ITER))
      where = nspg_boxed_get(nsp_where, GtkTextIter);
  else {
      Scierror( "Error: where should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_move_mark(GTK_TEXT_BUFFER(self->obj),GTK_TEXT_MARK(mark->obj),where);
  return 0;
}

static int _wrap_gtk_text_buffer_delete_mark(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *mark;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark) == FAIL) return RET_BUG;
    gtk_text_buffer_delete_mark(GTK_TEXT_BUFFER(self->obj),GTK_TEXT_MARK(mark->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_get_mark(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  GtkTextMark *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    ret =gtk_text_buffer_get_mark(GTK_TEXT_BUFFER(self->obj),name);
  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextmark))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_move_mark_by_name(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *name;
  GtkTextIter *where = NULL;
  NspObject *nsp_where = NULL;
  if ( GetArgs(stack,rhs,opt,T,&name, &nsp_where) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_where, GTK_TYPE_TEXT_ITER))
      where = nspg_boxed_get(nsp_where, GtkTextIter);
  else {
      Scierror( "Error: where should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_move_mark_by_name(GTK_TEXT_BUFFER(self->obj),name,where);
  return 0;
}

static int _wrap_gtk_text_buffer_delete_mark_by_name(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_text_buffer_delete_mark_by_name(GTK_TEXT_BUFFER(self->obj),name);
  return 0;
}

static int _wrap_gtk_text_buffer_get_insert(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextMark *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_text_buffer_get_insert(GTK_TEXT_BUFFER(self->obj));
  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextmark))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_get_selection_bound(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextMark *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_text_buffer_get_selection_bound(GTK_TEXT_BUFFER(self->obj));
  nsp_type_gtktextmark = new_type_gtktextmark(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextmark))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_place_cursor(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextIter *where = NULL;
  NspObject *nsp_where = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_where) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_where, GTK_TYPE_TEXT_ITER))
      where = nspg_boxed_get(nsp_where, GtkTextIter);
  else {
      Scierror( "Error: where should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_place_cursor(GTK_TEXT_BUFFER(self->obj),where);
  return 0;
}

static int _wrap_gtk_text_buffer_select_range(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTextIter *ins = NULL, *bound = NULL;
  NspObject *nsp_ins = NULL, *nsp_bound = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_ins, &nsp_bound) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_ins, GTK_TYPE_TEXT_ITER))
      ins = nspg_boxed_get(nsp_ins, GtkTextIter);
  else {
      Scierror( "Error: ins should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_bound, GTK_TYPE_TEXT_ITER))
      bound = nspg_boxed_get(nsp_bound, GtkTextIter);
  else {
      Scierror( "Error: bound should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_select_range(GTK_TEXT_BUFFER(self->obj),ins,bound);
  return 0;
}

static int _wrap_gtk_text_buffer_apply_tag(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,obj, t_end};
  NspGObject *tag;
  GtkTextIter *start = NULL, *end = NULL;
  NspObject *nsp_start = NULL, *nsp_end = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktexttag, &tag, &nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "Error: start should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "Error: end should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_apply_tag(GTK_TEXT_BUFFER(self->obj),GTK_TEXT_TAG(tag->obj),start,end);
  return 0;
}

static int _wrap_gtk_text_buffer_remove_tag(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,obj, t_end};
  NspGObject *tag;
  GtkTextIter *start = NULL, *end = NULL;
  NspObject *nsp_start = NULL, *nsp_end = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktexttag, &tag, &nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "Error: start should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "Error: end should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_remove_tag(GTK_TEXT_BUFFER(self->obj),GTK_TEXT_TAG(tag->obj),start,end);
  return 0;
}

static int _wrap_gtk_text_buffer_apply_tag_by_name(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj,obj, t_end};
  char *name;
  GtkTextIter *start = NULL, *end = NULL;
  NspObject *nsp_start = NULL, *nsp_end = NULL;
  if ( GetArgs(stack,rhs,opt,T,&name, &nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "Error: start should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "Error: end should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_apply_tag_by_name(GTK_TEXT_BUFFER(self->obj),name,start,end);
  return 0;
}

static int _wrap_gtk_text_buffer_remove_tag_by_name(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj,obj, t_end};
  char *name;
  GtkTextIter *start = NULL, *end = NULL;
  NspObject *nsp_start = NULL, *nsp_end = NULL;
  if ( GetArgs(stack,rhs,opt,T,&name, &nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "Error: start should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "Error: end should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_remove_tag_by_name(GTK_TEXT_BUFFER(self->obj),name,start,end);
  return 0;
}

static int _wrap_gtk_text_buffer_remove_all_tags(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTextIter *start = NULL, *end = NULL;
  NspObject *nsp_start = NULL, *nsp_end = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_start, &nsp_end) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start, GTK_TYPE_TEXT_ITER))
      start = nspg_boxed_get(nsp_start, GtkTextIter);
  else {
      Scierror( "Error: start should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end, GTK_TYPE_TEXT_ITER))
      end = nspg_boxed_get(nsp_end, GtkTextIter);
  else {
      Scierror( "Error: end should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_remove_all_tags(GTK_TEXT_BUFFER(self->obj),start,end);
  return 0;
}

#line 5840 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_create_tag(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int i;
  gchar *tag_name = NULL;
  GtkTextTag *tag;
  GtkTextTagTable *table;
  NspObject *ret;

  if ( rhs -opt != 1 )
    {
      Scierror("Expecting a tag name followed by optional named arguments\n");
      return RET_BUG;
    }

  if (( tag_name = GetString(stack,1))== NULL) return RET_BUG;
  table = GTK_TEXT_TAG_TABLE(gtk_text_buffer_get_tag_table(GTK_TEXT_BUFFER(self->obj)));
  if ( table && gtk_text_tag_table_lookup(table, tag_name))
    {
      Scierror("A tag named '%s' is already in the tag table", tag_name);
      return RET_BUG;
    }

  tag = gtk_text_buffer_create_tag(GTK_TEXT_BUFFER(self->obj), tag_name, NULL);

  for ( i = rhs -opt + 1; i <= rhs ; i++)
    {
      /* set tag properties if any */
      NspObject *prop = NthObj(i) ;
      GParamSpec *pspec;
      GValue value = { 0, };
      const gchar *prop_str =nsp_object_get_name(NthObj(i));

      pspec = g_object_class_find_property (G_OBJECT_GET_CLASS(tag),  prop_str);
      if (!pspec) {
	Scierror( "unsupported tag property `%s'", prop_str);
	/* XXX: Free tag? */
	return RET_BUG;
      }
      g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
      if (nspg_value_from_nspobject(&value, prop) < 0) {
	Scierror( "could not convert tag property '%s' to correct type",  prop_str);
	/* XXX: Free tag? */
	return RET_BUG;
      }
      g_object_set_property((GObject *)tag, prop_str, &value);
      g_value_unset(&value);
    }
  if ((ret = (NspObject *) gobject_create(NVOID,(GObject *)tag,(NspTypeBase *) nsp_type_gtktexttag))== NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 36013 "gtk.c"


#line 5895 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_get_iter_at_line_offset(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "line_number", "char_offset", NULL };*/
  GtkTextIter iter;
  int line_number, char_offset;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &line_number, &char_offset) == FAIL) return RET_BUG;;

  gtk_text_buffer_get_iter_at_line_offset(GTK_TEXT_BUFFER(self->obj), &iter, line_number, char_offset);
  if ((ret =(NspObject *)  gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 36033 "gtk.c"


#line 5913 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_get_iter_at_line_index(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "line_number", "byte_offset", NULL };*/
  GtkTextIter iter;
  int line_number, byte_offset;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T,&line_number, &byte_offset)  == FAIL) return RET_BUG;;

  gtk_text_buffer_get_iter_at_line_index(GTK_TEXT_BUFFER(self->obj), &iter, line_number, byte_offset);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 36053 "gtk.c"


#line 5931 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_get_iter_at_offset(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int char_offset;
  int_types T[] = {s_int, t_end} ;
  GtkTextIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &char_offset) == FAIL) return RET_BUG;;
  gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),  &iter, char_offset);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 36072 "gtk.c"


#line 5948 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_get_iter_at_line(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int line_number;
  int_types T[] = {s_int, t_end} ;
  GtkTextIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &line_number) == FAIL) return RET_BUG;;
  gtk_text_buffer_get_iter_at_line(GTK_TEXT_BUFFER(self->obj), &iter, line_number);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 36090 "gtk.c"


#line 5964 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_get_start_iter(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextIter iter;
  NspObject *ret;
  gtk_text_buffer_get_start_iter(GTK_TEXT_BUFFER(self->obj), &iter);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 36104 "gtk.c"


#line 5976 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_get_end_iter(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextIter iter;
  NspObject *ret;
  gtk_text_buffer_get_end_iter(GTK_TEXT_BUFFER(self->obj), &iter);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,nsp_type_gtktextiter)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 36118 "gtk.c"


#line 5988 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_get_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret1,*ret2;
  GtkTextIter start, end;
  CheckRhs(0,0);
  CheckLhs(2,2);
  gtk_text_buffer_get_bounds(GTK_TEXT_BUFFER(self->obj), &start, &end);
  if ((ret1 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &start,TRUE, TRUE,nsp_type_gtktextiter))== NULL)
    return RET_BUG;
  MoveObj(stack,1,ret1);
  if ((ret2 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &end,TRUE, TRUE,nsp_type_gtktextiter))==NULL)
    return RET_BUG;
  MoveObj(stack,2,ret2);
  return 2;
}
#line 36138 "gtk.c"


#line 6006 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_get_iter_at_mark(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *mark;
  int_types T[] = {obj_check, t_end} ;
  GtkTextIter iter;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark) == FAIL) return RET_BUG;;
  gtk_text_buffer_get_iter_at_mark(GTK_TEXT_BUFFER(self->obj), &iter, GTK_TEXT_MARK(mark->obj));
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 36156 "gtk.c"


static int _wrap_gtk_text_buffer_get_iter_at_child_anchor(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  NspGObject *anchor;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_type_gtktextchildanchor, &anchor) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_get_iter_at_child_anchor(GTK_TEXT_BUFFER(self->obj),iter,GTK_TEXT_CHILD_ANCHOR(anchor->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_get_modified(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_buffer_get_modified(GTK_TEXT_BUFFER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_set_modified(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_text_buffer_set_modified(GTK_TEXT_BUFFER(self->obj),setting);
  return 0;
}

static int _wrap_gtk_text_buffer_get_has_selection(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_buffer_get_has_selection(GTK_TEXT_BUFFER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_add_selection_clipboard(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *clipboard;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkclipboard, &clipboard) == FAIL) return RET_BUG;
    gtk_text_buffer_add_selection_clipboard(GTK_TEXT_BUFFER(self->obj),GTK_CLIPBOARD(clipboard->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_remove_selection_clipboard(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *clipboard;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkclipboard, &clipboard) == FAIL) return RET_BUG;
    gtk_text_buffer_remove_selection_clipboard(GTK_TEXT_BUFFER(self->obj),GTK_CLIPBOARD(clipboard->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_cut_clipboard(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *clipboard;
  int default_editable;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkclipboard, &clipboard, &default_editable) == FAIL) return RET_BUG;
    gtk_text_buffer_cut_clipboard(GTK_TEXT_BUFFER(self->obj),GTK_CLIPBOARD(clipboard->obj),default_editable);
  return 0;
}

static int _wrap_gtk_text_buffer_copy_clipboard(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *clipboard;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkclipboard, &clipboard) == FAIL) return RET_BUG;
    gtk_text_buffer_copy_clipboard(GTK_TEXT_BUFFER(self->obj),GTK_CLIPBOARD(clipboard->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_paste_clipboard(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,s_bool, t_end};
  NspGObject *clipboard;
  GtkTextIter *override_location = NULL;
  NspObject *nsp_override_location = NULL;
  int default_editable;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkclipboard, &clipboard, &nsp_override_location, &default_editable) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_override_location, GTK_TYPE_TEXT_ITER))
      override_location = nspg_boxed_get(nsp_override_location, GtkTextIter);
  else {
      Scierror( "Error: override_location should be a GtkTextIter\n");
      return RET_BUG;
  }
    gtk_text_buffer_paste_clipboard(GTK_TEXT_BUFFER(self->obj),GTK_CLIPBOARD(clipboard->obj),override_location,default_editable);
  return 0;
}

#line 6033 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_buffer_get_selection_bounds(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret1,*ret2;
  GtkTextIter start, end;
  CheckRhs(0,0);
  CheckLhs(2,2);
  if (!gtk_text_buffer_get_selection_bounds(GTK_TEXT_BUFFER(self->obj),&start, &end))
    return RET_BUG;
  if ((ret1 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &start,TRUE, TRUE,nsp_type_gtktextiter))== NULL)
    return RET_BUG;
  MoveObj(stack,1,ret1);
  if ((ret2 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &end,TRUE, TRUE,nsp_type_gtktextiter))==NULL)
    return RET_BUG;
  MoveObj(stack,1,ret2);
  return 2;
}
#line 36276 "gtk.c"


static int _wrap_gtk_text_buffer_delete_selection(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool,s_bool, t_end};
  int interactive, default_editable, ret;
  if ( GetArgs(stack,rhs,opt,T,&interactive, &default_editable) == FAIL) return RET_BUG;
    ret =gtk_text_buffer_delete_selection(GTK_TEXT_BUFFER(self->obj),interactive,default_editable);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_buffer_begin_user_action(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_text_buffer_begin_user_action(GTK_TEXT_BUFFER(self->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_end_user_action(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_text_buffer_end_user_action(GTK_TEXT_BUFFER(self->obj));
  return 0;
}

static int _wrap_gtk_text_buffer_register_serialize_tagset(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *tagset_name;
  GdkAtom ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&tagset_name) == FAIL) return RET_BUG;
    ret =gtk_text_buffer_register_serialize_tagset(GTK_TEXT_BUFFER(self->obj),tagset_name);
  if (( nsp_ret = (NspObject *) gdkatom_create(NVOID,NULL,ret,NULL))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_register_deserialize_tagset(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *tagset_name;
  GdkAtom ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&tagset_name) == FAIL) return RET_BUG;
    ret =gtk_text_buffer_register_deserialize_tagset(GTK_TEXT_BUFFER(self->obj),tagset_name);
  if (( nsp_ret = (NspObject *) gdkatom_create(NVOID,NULL,ret,NULL))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_buffer_unregister_serialize_format(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkAtom format;
  NspObject *nsp_format = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_format) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_format,&format)==FAIL) return RET_BUG;
    gtk_text_buffer_unregister_serialize_format(GTK_TEXT_BUFFER(self->obj),format);
  return 0;
}

static int _wrap_gtk_text_buffer_unregister_deserialize_format(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkAtom format;
  NspObject *nsp_format = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_format) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_format,&format)==FAIL) return RET_BUG;
    gtk_text_buffer_unregister_deserialize_format(GTK_TEXT_BUFFER(self->obj),format);
  return 0;
}

static int _wrap_gtk_text_buffer_deserialize_set_can_create_tags(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_bool, t_end};
  GdkAtom format;
  NspObject *nsp_format = NULL;
  int can_create_tags;
  if ( GetArgs(stack,rhs,opt,T,&nsp_format, &can_create_tags) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_format,&format)==FAIL) return RET_BUG;
    gtk_text_buffer_deserialize_set_can_create_tags(GTK_TEXT_BUFFER(self->obj),format,can_create_tags);
  return 0;
}

static int _wrap_gtk_text_buffer_deserialize_get_can_create_tags(NspGtkTextBuffer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkAtom format;
  NspObject *nsp_format = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_format) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_format,&format)==FAIL) return RET_BUG;
    ret =gtk_text_buffer_deserialize_get_can_create_tags(GTK_TEXT_BUFFER(self->obj),format);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktextbuffer_methods[] = {
  {"get_line_count",(nsp_method *) _wrap_gtk_text_buffer_get_line_count},
  {"get_char_count",(nsp_method *) _wrap_gtk_text_buffer_get_char_count},
  {"get_tag_table",(nsp_method *) _wrap_gtk_text_buffer_get_tag_table},
  {"set_text",(nsp_method *) _wrap_gtk_text_buffer_set_text},
  {"insert",(nsp_method *) _wrap_gtk_text_buffer_insert},
  {"insert_at_cursor",(nsp_method *) _wrap_gtk_text_buffer_insert_at_cursor},
  {"insert_interactive",(nsp_method *) _wrap_gtk_text_buffer_insert_interactive},
  {"insert_interactive_at_cursor",(nsp_method *) _wrap_gtk_text_buffer_insert_interactive_at_cursor},
  {"insert_range",(nsp_method *) _wrap_gtk_text_buffer_insert_range},
  {"insert_range_interactive",(nsp_method *) _wrap_gtk_text_buffer_insert_range_interactive},
  {"insert_with_tags",(nsp_method *) _wrap_gtk_text_buffer_insert_with_tags},
  {"insert_with_tags_by_name",(nsp_method *) _wrap_gtk_text_buffer_insert_with_tags_by_name},
  {"insert_markup",(nsp_method *) _wrap_gtk_text_buffer_insert_markup},
  {"delete",(nsp_method *) _wrap_gtk_text_buffer_delete},
  {"delete_interactive",(nsp_method *) _wrap_gtk_text_buffer_delete_interactive},
  {"backspace",(nsp_method *) _wrap_gtk_text_buffer_backspace},
  {"get_text",(nsp_method *) _wrap_gtk_text_buffer_get_text},
  {"get_slice",(nsp_method *) _wrap_gtk_text_buffer_get_slice},
  {"insert_pixbuf",(nsp_method *) _wrap_gtk_text_buffer_insert_pixbuf},
  {"insert_child_anchor",(nsp_method *) _wrap_gtk_text_buffer_insert_child_anchor},
  {"create_child_anchor",(nsp_method *) _wrap_gtk_text_buffer_create_child_anchor},
  {"add_mark",(nsp_method *) _wrap_gtk_text_buffer_add_mark},
  {"create_mark",(nsp_method *) _wrap_gtk_text_buffer_create_mark},
  {"move_mark",(nsp_method *) _wrap_gtk_text_buffer_move_mark},
  {"delete_mark",(nsp_method *) _wrap_gtk_text_buffer_delete_mark},
  {"get_mark",(nsp_method *) _wrap_gtk_text_buffer_get_mark},
  {"move_mark_by_name",(nsp_method *) _wrap_gtk_text_buffer_move_mark_by_name},
  {"delete_mark_by_name",(nsp_method *) _wrap_gtk_text_buffer_delete_mark_by_name},
  {"get_insert",(nsp_method *) _wrap_gtk_text_buffer_get_insert},
  {"get_selection_bound",(nsp_method *) _wrap_gtk_text_buffer_get_selection_bound},
  {"place_cursor",(nsp_method *) _wrap_gtk_text_buffer_place_cursor},
  {"select_range",(nsp_method *) _wrap_gtk_text_buffer_select_range},
  {"apply_tag",(nsp_method *) _wrap_gtk_text_buffer_apply_tag},
  {"remove_tag",(nsp_method *) _wrap_gtk_text_buffer_remove_tag},
  {"apply_tag_by_name",(nsp_method *) _wrap_gtk_text_buffer_apply_tag_by_name},
  {"remove_tag_by_name",(nsp_method *) _wrap_gtk_text_buffer_remove_tag_by_name},
  {"remove_all_tags",(nsp_method *) _wrap_gtk_text_buffer_remove_all_tags},
  {"create_tag",(nsp_method *) _wrap_gtk_text_buffer_create_tag},
  {"get_iter_at_line_offset",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_line_offset},
  {"get_iter_at_line_index",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_line_index},
  {"get_iter_at_offset",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_offset},
  {"get_iter_at_line",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_line},
  {"get_start_iter",(nsp_method *) _wrap_gtk_text_buffer_get_start_iter},
  {"get_end_iter",(nsp_method *) _wrap_gtk_text_buffer_get_end_iter},
  {"get_bounds",(nsp_method *) _wrap_gtk_text_buffer_get_bounds},
  {"get_iter_at_mark",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_mark},
  {"get_iter_at_child_anchor",(nsp_method *) _wrap_gtk_text_buffer_get_iter_at_child_anchor},
  {"get_modified",(nsp_method *) _wrap_gtk_text_buffer_get_modified},
  {"set_modified",(nsp_method *) _wrap_gtk_text_buffer_set_modified},
  {"get_has_selection",(nsp_method *) _wrap_gtk_text_buffer_get_has_selection},
  {"add_selection_clipboard",(nsp_method *) _wrap_gtk_text_buffer_add_selection_clipboard},
  {"remove_selection_clipboard",(nsp_method *) _wrap_gtk_text_buffer_remove_selection_clipboard},
  {"cut_clipboard",(nsp_method *) _wrap_gtk_text_buffer_cut_clipboard},
  {"copy_clipboard",(nsp_method *) _wrap_gtk_text_buffer_copy_clipboard},
  {"paste_clipboard",(nsp_method *) _wrap_gtk_text_buffer_paste_clipboard},
  {"get_selection_bounds",(nsp_method *) _wrap_gtk_text_buffer_get_selection_bounds},
  {"delete_selection",(nsp_method *) _wrap_gtk_text_buffer_delete_selection},
  {"begin_user_action",(nsp_method *) _wrap_gtk_text_buffer_begin_user_action},
  {"end_user_action",(nsp_method *) _wrap_gtk_text_buffer_end_user_action},
  {"register_serialize_tagset",(nsp_method *) _wrap_gtk_text_buffer_register_serialize_tagset},
  {"register_deserialize_tagset",(nsp_method *) _wrap_gtk_text_buffer_register_deserialize_tagset},
  {"unregister_serialize_format",(nsp_method *) _wrap_gtk_text_buffer_unregister_serialize_format},
  {"unregister_deserialize_format",(nsp_method *) _wrap_gtk_text_buffer_unregister_deserialize_format},
  {"deserialize_set_can_create_tags",(nsp_method *) _wrap_gtk_text_buffer_deserialize_set_can_create_tags},
  {"deserialize_get_can_create_tags",(nsp_method *) _wrap_gtk_text_buffer_deserialize_get_can_create_tags},
  { NULL, NULL}
};

static NspMethods *gtktextbuffer_get_methods(void) { return gtktextbuffer_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktextbuffer_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTextTag ----------- */


#define  NspGtkTextTag_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktexttag.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTextTag inherits from GObject 
 */

int nsp_type_gtktexttag_id=0;
NspTypeGtkTextTag *nsp_type_gtktexttag=NULL;

/*
 * Type object for NspGtkTextTag 
 * all the instance of NspTypeGtkTextTag share the same id. 
 * nsp_type_gtktexttag: is an instance of NspTypeGtkTextTag 
 *    used for objects of NspGtkTextTag type (i.e built with new_gtktexttag) 
 * other instances are used for derived classes 
 */
NspTypeGtkTextTag *new_type_gtktexttag(type_mode mode)
{
  NspTypeGtkTextTag *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktexttag != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktexttag;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktexttag_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktexttag_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktexttag;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktexttag */ 

  top->s_type =  (s_type_func *) nsp_gtktexttag_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktexttag_type_short_string;
  /* top->create = (create_func*) int_gtktexttag_create;*/

  /* specific methods for gtktexttag */

  type->init = (init_func *) init_gtktexttag;

  /* 
   * NspGtkTextTag interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktexttag_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextTag called nsp_type_gtktexttag
       */
      type->id =  nsp_type_gtktexttag_id = nsp_new_type_id();
      nsp_type_gtktexttag = type;
      if ( nsp_register_type(nsp_type_gtktexttag) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktexttag, GTK_TYPE_TEXT_TAG);
      return ( mode == T_BASE ) ? type : new_type_gtktexttag(mode);
    }
  else 
    {
      type->id = nsp_type_gtktexttag_id;
      return type;
    }
}

/*
 * initialize NspGtkTextTag instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktexttag(NspGtkTextTag *Obj,NspTypeGtkTextTag *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTextTag 
 */

NspGtkTextTag *new_gtktexttag() 
{
  NspGtkTextTag *loc;
  /* type must exists */
  nsp_type_gtktexttag = new_type_gtktexttag(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextTag)))== NULLGTKTEXTTAG) return loc;
  /* initialize object */
  if ( init_gtktexttag(loc,nsp_type_gtktexttag) == FAIL) return NULLGTKTEXTTAG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTextTag 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktexttag_type_name[]="GtkTextTag";
static char gtktexttag_short_type_name[]="GtkTextTag";

static char *nsp_gtktexttag_type_as_string(void)
{
  return(gtktexttag_type_name);
}

static char *nsp_gtktexttag_type_short_string(NspObject *v)
{
  return(gtktexttag_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTextTag objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTextTag   *nsp_gtktexttag_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktexttag_id)  == TRUE  ) return ((NspGtkTextTag *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktexttag));
  return NULL;
}

int IsGtkTextTagObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktexttag_id);
}

int IsGtkTextTag(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktexttag_id);
}

NspGtkTextTag  *GetGtkTextTagCopy(Stack stack, int i)
{
  if (  GetGtkTextTag(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextTag  *GetGtkTextTag(Stack stack, int i)
{
  NspGtkTextTag *M;
  if (( M = nsp_gtktexttag_object(NthObj(i))) == NULLGTKTEXTTAG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextTag *gtktexttag_copy(NspGtkTextTag *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktexttag);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktexttag);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextTag
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_text_tag_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"name",string,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  char *name = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &name) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_text_tag_new(name))== NULL) return RET_BUG;

  nsp_type_gtktexttag = new_type_gtktexttag(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktexttag);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_tag_get_priority(NspGtkTextTag *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_tag_get_priority(GTK_TEXT_TAG(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_tag_set_priority(NspGtkTextTag *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int priority;
  if ( GetArgs(stack,rhs,opt,T,&priority) == FAIL) return RET_BUG;
    gtk_text_tag_set_priority(GTK_TEXT_TAG(self->obj),priority);
  return 0;
}

static int _wrap_gtk_text_tag_event(NspGtkTextTag *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,obj, t_end};
  NspGObject *event_object = NULL;
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL, *nsp_iter = NULL;
  GtkTextIter *iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gobject, &event_object, &nsp_event, &nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_tag_event(GTK_TEXT_TAG(self->obj),G_OBJECT(event_object->obj),event,iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktexttag_methods[] = {
  {"get_priority",(nsp_method *) _wrap_gtk_text_tag_get_priority},
  {"set_priority",(nsp_method *) _wrap_gtk_text_tag_set_priority},
  {"event",(nsp_method *) _wrap_gtk_text_tag_event},
  { NULL, NULL}
};

static NspMethods *gtktexttag_get_methods(void) { return gtktexttag_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktexttag_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTextTagTable ----------- */


#define  NspGtkTextTagTable_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktexttagtable.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTextTagTable inherits from GObject 
 * and implements GtkBuildable
 */

int nsp_type_gtktexttagtable_id=0;
NspTypeGtkTextTagTable *nsp_type_gtktexttagtable=NULL;

/*
 * Type object for NspGtkTextTagTable 
 * all the instance of NspTypeGtkTextTagTable share the same id. 
 * nsp_type_gtktexttagtable: is an instance of NspTypeGtkTextTagTable 
 *    used for objects of NspGtkTextTagTable type (i.e built with new_gtktexttagtable) 
 * other instances are used for derived classes 
 */
NspTypeGtkTextTagTable *new_type_gtktexttagtable(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkTextTagTable *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktexttagtable != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktexttagtable;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktexttagtable_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktexttagtable_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktexttagtable;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktexttagtable */ 

  top->s_type =  (s_type_func *) nsp_gtktexttagtable_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktexttagtable_type_short_string;
  /* top->create = (create_func*) int_gtktexttagtable_create;*/

  /* specific methods for gtktexttagtable */

  type->init = (init_func *) init_gtktexttagtable;

  /* 
   * NspGtkTextTagTable interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtktexttagtable_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextTagTable called nsp_type_gtktexttagtable
       */
      type->id =  nsp_type_gtktexttagtable_id = nsp_new_type_id();
      nsp_type_gtktexttagtable = type;
      if ( nsp_register_type(nsp_type_gtktexttagtable) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktexttagtable, GTK_TYPE_TEXT_TAG_TABLE);
      return ( mode == T_BASE ) ? type : new_type_gtktexttagtable(mode);
    }
  else 
    {
      type->id = nsp_type_gtktexttagtable_id;
      return type;
    }
}

/*
 * initialize NspGtkTextTagTable instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktexttagtable(NspGtkTextTagTable *Obj,NspTypeGtkTextTagTable *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTextTagTable 
 */

NspGtkTextTagTable *new_gtktexttagtable() 
{
  NspGtkTextTagTable *loc;
  /* type must exists */
  nsp_type_gtktexttagtable = new_type_gtktexttagtable(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextTagTable)))== NULLGTKTEXTTAGTABLE) return loc;
  /* initialize object */
  if ( init_gtktexttagtable(loc,nsp_type_gtktexttagtable) == FAIL) return NULLGTKTEXTTAGTABLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTextTagTable 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktexttagtable_type_name[]="GtkTextTagTable";
static char gtktexttagtable_short_type_name[]="GtkTextTagTable";

static char *nsp_gtktexttagtable_type_as_string(void)
{
  return(gtktexttagtable_type_name);
}

static char *nsp_gtktexttagtable_type_short_string(NspObject *v)
{
  return(gtktexttagtable_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTextTagTable objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTextTagTable   *nsp_gtktexttagtable_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktexttagtable_id)  == TRUE  ) return ((NspGtkTextTagTable *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktexttagtable));
  return NULL;
}

int IsGtkTextTagTableObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktexttagtable_id);
}

int IsGtkTextTagTable(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktexttagtable_id);
}

NspGtkTextTagTable  *GetGtkTextTagTableCopy(Stack stack, int i)
{
  if (  GetGtkTextTagTable(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextTagTable  *GetGtkTextTagTable(Stack stack, int i)
{
  NspGtkTextTagTable *M;
  if (( M = nsp_gtktexttagtable_object(NthObj(i))) == NULLGTKTEXTTAGTABLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextTagTable *gtktexttagtable_copy(NspGtkTextTagTable *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktexttagtable);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktexttagtable);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextTagTable
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_text_tag_table_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_text_tag_table_new())== NULL) return RET_BUG;

  nsp_type_gtktexttagtable = new_type_gtktexttagtable(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktexttagtable);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_tag_table_remove(NspGtkTextTagTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *tag;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktexttag, &tag) == FAIL) return RET_BUG;
    gtk_text_tag_table_remove(GTK_TEXT_TAG_TABLE(self->obj),GTK_TEXT_TAG(tag->obj));
  return 0;
}

static int _wrap_gtk_text_tag_table_lookup(NspGtkTextTagTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  GtkTextTag *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    ret =gtk_text_tag_table_lookup(GTK_TEXT_TAG_TABLE(self->obj),name);
  nsp_type_gtktexttag = new_type_gtktexttag(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktexttag))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_tag_table_get_size(NspGtkTextTagTable *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_tag_table_get_size(GTK_TEXT_TAG_TABLE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktexttagtable_methods[] = {
  {"remove",(nsp_method *) _wrap_gtk_text_tag_table_remove},
  {"lookup",(nsp_method *) _wrap_gtk_text_tag_table_lookup},
  {"get_size",(nsp_method *) _wrap_gtk_text_tag_table_get_size},
  { NULL, NULL}
};

static NspMethods *gtktexttagtable_get_methods(void) { return gtktexttagtable_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktexttagtable_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTextView ----------- */


#define  NspGtkTextView_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktextview.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTextView inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtktextview_id=0;
NspTypeGtkTextView *nsp_type_gtktextview=NULL;

/*
 * Type object for NspGtkTextView 
 * all the instance of NspTypeGtkTextView share the same id. 
 * nsp_type_gtktextview: is an instance of NspTypeGtkTextView 
 *    used for objects of NspGtkTextView type (i.e built with new_gtktextview) 
 * other instances are used for derived classes 
 */
NspTypeGtkTextView *new_type_gtktextview(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkTextView *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextview != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextview;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextview_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktextview_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktextview;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktextview */ 

  top->s_type =  (s_type_func *) nsp_gtktextview_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktextview_type_short_string;
  /* top->create = (create_func*) int_gtktextview_create;*/

  /* specific methods for gtktextview */

  type->init = (init_func *) init_gtktextview;

  /* 
   * NspGtkTextView interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtktextview_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextView called nsp_type_gtktextview
       */
      type->id =  nsp_type_gtktextview_id = nsp_new_type_id();
      nsp_type_gtktextview = type;
      if ( nsp_register_type(nsp_type_gtktextview) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextview, GTK_TYPE_TEXT_VIEW);
      return ( mode == T_BASE ) ? type : new_type_gtktextview(mode);
    }
  else 
    {
      type->id = nsp_type_gtktextview_id;
      return type;
    }
}

/*
 * initialize NspGtkTextView instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextview(NspGtkTextView *Obj,NspTypeGtkTextView *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTextView 
 */

NspGtkTextView *new_gtktextview() 
{
  NspGtkTextView *loc;
  /* type must exists */
  nsp_type_gtktextview = new_type_gtktextview(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextView)))== NULLGTKTEXTVIEW) return loc;
  /* initialize object */
  if ( init_gtktextview(loc,nsp_type_gtktextview) == FAIL) return NULLGTKTEXTVIEW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTextView 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktextview_type_name[]="GtkTextView";
static char gtktextview_short_type_name[]="GtkTextView";

static char *nsp_gtktextview_type_as_string(void)
{
  return(gtktextview_type_name);
}

static char *nsp_gtktextview_type_short_string(NspObject *v)
{
  return(gtktextview_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTextView objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTextView   *nsp_gtktextview_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktextview_id)  == TRUE  ) return ((NspGtkTextView *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextview));
  return NULL;
}

int IsGtkTextViewObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktextview_id);
}

int IsGtkTextView(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextview_id);
}

NspGtkTextView  *GetGtkTextViewCopy(Stack stack, int i)
{
  if (  GetGtkTextView(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextView  *GetGtkTextView(Stack stack, int i)
{
  NspGtkTextView *M;
  if (( M = nsp_gtktextview_object(NthObj(i))) == NULLGTKTEXTVIEW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextView *gtktextview_copy(NspGtkTextView *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextview);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextview);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextView
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_text_view_new_with_buffer (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *buffer;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextbuffer, &buffer) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_text_view_new_with_buffer(GTK_TEXT_BUFFER(buffer->obj)))== NULL) return RET_BUG;

  nsp_type_gtktextview = new_type_gtktextview(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextview);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_text_view_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_text_view_new())== NULL) return RET_BUG;

  nsp_type_gtktextview = new_type_gtktextview(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextview);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_view_set_buffer(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *buffer;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextbuffer, &buffer) == FAIL) return RET_BUG;
    gtk_text_view_set_buffer(GTK_TEXT_VIEW(self->obj),GTK_TEXT_BUFFER(buffer->obj));
  return 0;
}

static int _wrap_gtk_text_view_get_buffer(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextBuffer *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_buffer(GTK_TEXT_VIEW(self->obj));
  nsp_type_gtktextbuffer = new_type_gtktextbuffer(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextbuffer))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_view_scroll_to_iter(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_double,new_opts, t_end};
  nsp_option opts[] = {
	{"use_align",s_bool,NULLOBJ,-1},
	{"xalign",s_double,NULLOBJ,-1},
	{"yalign",s_double,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  double within_margin, xalign = 0.5, yalign = 0.5;
  int use_align = FALSE, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &within_margin, opts, &use_align, &xalign, &yalign) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_view_scroll_to_iter(GTK_TEXT_VIEW(self->obj),iter,within_margin,use_align,xalign,yalign);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_scroll_to_mark(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_double,new_opts, t_end};
  nsp_option opts[] = {
	{"use_align",s_bool,NULLOBJ,-1},
	{"xalign",s_double,NULLOBJ,-1},
	{"yalign",s_double,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *mark;
  double within_margin, xalign = 0.5, yalign = 0.5;
  int use_align = FALSE;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark, &within_margin, opts, &use_align, &xalign, &yalign) == FAIL) return RET_BUG;
    gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(self->obj),GTK_TEXT_MARK(mark->obj),within_margin,use_align,xalign,yalign);
  return 0;
}

static int _wrap_gtk_text_view_scroll_mark_onscreen(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *mark;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark) == FAIL) return RET_BUG;
    gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(self->obj),GTK_TEXT_MARK(mark->obj));
  return 0;
}

static int _wrap_gtk_text_view_move_mark_onscreen(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *mark;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextmark, &mark) == FAIL) return RET_BUG;
    ret =gtk_text_view_move_mark_onscreen(GTK_TEXT_VIEW(self->obj),GTK_TEXT_MARK(mark->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_place_cursor_onscreen(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_place_cursor_onscreen(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 6120 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_view_get_visible_rect(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkRectangle visible_rect;
  NspObject *ret;

  gtk_text_view_get_visible_rect(GTK_TEXT_VIEW(self->obj), &visible_rect);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &visible_rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 37307 "gtk.c"


static int _wrap_gtk_text_view_set_cursor_visible(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_text_view_get_cursor_visible(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_cursor_visible(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_get_cursor_locations(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj,obj, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL, *nsp_strong, *nsp_weak;
  GdkRectangle strong = { 0, 0, 0, 0 }, weak = { 0, 0, 0, 0 };
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_strong, &nsp_weak) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
  if (!nsp_gdk_rectangle_from_object(nsp_strong, &strong))
      return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_weak, &weak))
      return RET_BUG;
    gtk_text_view_get_cursor_locations(GTK_TEXT_VIEW(self->obj),iter,&strong,&weak);
  return 0;
}

#line 6794 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_view_get_iter_location(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end} ;
  /* static char *kwlist[] = { "iter", NULL };*/
  NspObject *nsp_iter;
  GdkRectangle location;
  GtkTextIter *iter = NULL;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter, &nsp_iter)  == FAIL) return RET_BUG;;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  gtk_text_view_get_iter_location(GTK_TEXT_VIEW(self->obj), iter, &location);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &location, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 37368 "gtk.c"


#line 6850 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_view_get_iter_at_location(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,t_end} ;
  /* static char *kwlist[] = { "x", "y", NULL };*/
  GtkTextIter iter;
  gint x, y;
  NspObject *ret;

  if (GetArgs(stack,rhs,opt,T, &x, &y)  == FAIL) return RET_BUG;;
  gtk_text_view_get_iter_at_location(GTK_TEXT_VIEW(self->obj),  &iter, x, y);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}

#line 37388 "gtk.c"


#line 6868 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_view_get_iter_at_position(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,t_end} ;
  GtkTextIter iter;
  gint x, y, trailing;
  NspObject *ret;
  CheckLhs(0,2);
  if (GetArgs(stack,rhs,opt,T, &x, &y)  == FAIL) return RET_BUG;;
  gtk_text_view_get_iter_at_position(GTK_TEXT_VIEW(self->obj), &iter, &trailing,x, y);
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE,NULL)) == NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  if ( lhs == 2 )
    {
      if (  nsp_move_doubles(stack,2,1,1,(double) trailing) == FAIL)
	return RET_BUG;
    }
  return Max(lhs,1);
}

#line 37412 "gtk.c"


#line 6831 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_view_get_line_yrange(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end} ;
  /* static char *kwlist[] = { "iter", NULL };*/
  GtkTextIter *iter = NULL;
  gint y = -1, height = -1;
  NspObject *nsp_iter;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtktextiter, &nsp_iter)  == FAIL) return RET_BUG;;
  iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  gtk_text_view_get_line_yrange(GTK_TEXT_VIEW(self->obj),
				iter, &y, &height);
  if (  nsp_move_doubles(stack,1,1,2,(double) y,(double) height) == FAIL)
    return RET_BUG;
  return 1;
}
#line 37433 "gtk.c"


#line 6814 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_view_get_line_at_y(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end} ;
  int_types ret_T[] = {obj,s_int, t_end} ;
  /* static char *kwlist[] = { "y", NULL };*/
  GtkTextIter iter;
  gint y, line_top;

  if (GetArgs(stack,rhs,opt,T, &y)   == FAIL) return RET_BUG;;
  gtk_text_view_get_line_at_y(GTK_TEXT_VIEW(self->obj),  &iter, y, &line_top);
  return RetArgs(stack,lhs,ret_T,
		 (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ITER, &iter,TRUE, TRUE, NULL),
		 line_top);
}
#line 37452 "gtk.c"


#line 6133 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_view_buffer_to_window_coords(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "win", "buffer_x", "buffer_y", NULL };*/
  GtkTextWindowType win;
  gint buffer_x, buffer_y, window_x = 0, window_y = 0;
  NspObject *nsp_win;

  if (GetArgs(stack,rhs,opt,T, &nsp_win, &buffer_x, &buffer_y) == FAIL) return RET_BUG;;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_win,&win))
    return RET_BUG;
  gtk_text_view_buffer_to_window_coords(GTK_TEXT_VIEW(self->obj), win,
					buffer_x, buffer_y,
					&window_x, &window_y);
  if ( nsp_move_doubles(stack,1,1,2,(double) window_x,(double) window_y) == FAIL) return RET_BUG;
  return 1;
}
#line 37474 "gtk.c"


#line 6153 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_view_window_to_buffer_coords(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "win", "window_x", "window_y", NULL };*/
  GtkTextWindowType win;
  gint window_x, window_y, buffer_x = 0, buffer_y = 0;
  NspObject *nsp_win;

  if (GetArgs(stack,rhs,opt,T, &nsp_win, &window_x, &window_y) == FAIL) return RET_BUG;;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_win,&win))
    return RET_BUG;
  gtk_text_view_window_to_buffer_coords(GTK_TEXT_VIEW(self->obj), win,
					window_x, window_y,
					&buffer_x, &buffer_y);
  if ( nsp_move_doubles(stack,1,1,2,(double) buffer_x,(double) buffer_y) == FAIL) return RET_BUG;
  return 1;
}
#line 37496 "gtk.c"


static int _wrap_gtk_text_view_get_window(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextWindowType win;
  NspObject *nsp_win = NULL, *nsp_ret;
  GdkWindow *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_win) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_win, &win)== FAIL)
      return RET_BUG;
    ret =gtk_text_view_get_window(GTK_TEXT_VIEW(self->obj),win);
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_view_get_window_type(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *window;
  gint ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window) == FAIL) return RET_BUG;
    ret =gtk_text_view_get_window_type(GTK_TEXT_VIEW(self->obj),GDK_WINDOW(window->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_border_window_size(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int, t_end};
  GtkTextWindowType type;
  NspObject *nsp_type = NULL;
  int size;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type, &size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
    gtk_text_view_set_border_window_size(GTK_TEXT_VIEW(self->obj),type,size);
  return 0;
}

static int _wrap_gtk_text_view_get_border_window_size(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextWindowType type;
  NspObject *nsp_type = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
    ret =gtk_text_view_get_border_window_size(GTK_TEXT_VIEW(self->obj),type);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_forward_display_line(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_view_forward_display_line(GTK_TEXT_VIEW(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_backward_display_line(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_view_backward_display_line(GTK_TEXT_VIEW(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_forward_display_line_end(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_view_forward_display_line_end(GTK_TEXT_VIEW(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_backward_display_line_start(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_view_backward_display_line_start(GTK_TEXT_VIEW(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_starts_display_line(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_view_starts_display_line(GTK_TEXT_VIEW(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_move_visually(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int, t_end};
  GtkTextIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int count, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &count) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TEXT_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTextIter);
  else {
      Scierror( "Error: iter should be a GtkTextIter\n");
      return RET_BUG;
  }
    ret =gtk_text_view_move_visually(GTK_TEXT_VIEW(self->obj),iter,count);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_im_context_filter_keypress(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    ret =gtk_text_view_im_context_filter_keypress(GTK_TEXT_VIEW(self->obj),(GdkEventKey *)event);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_reset_im_context(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_text_view_reset_im_context(GTK_TEXT_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_text_view_add_child_at_anchor(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *child, *anchor;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_type_gtktextchildanchor, &anchor) == FAIL) return RET_BUG;
    gtk_text_view_add_child_at_anchor(GTK_TEXT_VIEW(self->obj),GTK_WIDGET(child->obj),GTK_TEXT_CHILD_ANCHOR(anchor->obj));
  return 0;
}

static int _wrap_gtk_text_view_add_child_in_window(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,s_int,s_int, t_end};
  NspGObject *child;
  GtkTextWindowType which_window;
  NspObject *nsp_which_window = NULL;
  int xpos, ypos;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_which_window, &xpos, &ypos) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_WINDOW_TYPE, nsp_which_window, &which_window)== FAIL)
      return RET_BUG;
    gtk_text_view_add_child_in_window(GTK_TEXT_VIEW(self->obj),GTK_WIDGET(child->obj),which_window,xpos,ypos);
  return 0;
}

static int _wrap_gtk_text_view_move_child(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int, t_end};
  NspGObject *child;
  int xpos, ypos;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &xpos, &ypos) == FAIL) return RET_BUG;
    gtk_text_view_move_child(GTK_TEXT_VIEW(self->obj),GTK_WIDGET(child->obj),xpos,ypos);
  return 0;
}

static int _wrap_gtk_text_view_set_wrap_mode(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkWrapMode wrap_mode;
  NspObject *nsp_wrap_mode = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_wrap_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_WRAP_MODE, nsp_wrap_mode, &wrap_mode)== FAIL)
      return RET_BUG;
    gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(self->obj),wrap_mode);
  return 0;
}

static int _wrap_gtk_text_view_get_wrap_mode(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_wrap_mode(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_editable(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_text_view_set_editable(GTK_TEXT_VIEW(self->obj),setting);
  return 0;
}

static int _wrap_gtk_text_view_get_editable(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_editable(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_overwrite(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int overwrite;
  if ( GetArgs(stack,rhs,opt,T,&overwrite) == FAIL) return RET_BUG;
    gtk_text_view_set_overwrite(GTK_TEXT_VIEW(self->obj),overwrite);
  return 0;
}

static int _wrap_gtk_text_view_get_overwrite(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_overwrite(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_accepts_tab(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int accepts_tab;
  if ( GetArgs(stack,rhs,opt,T,&accepts_tab) == FAIL) return RET_BUG;
    gtk_text_view_set_accepts_tab(GTK_TEXT_VIEW(self->obj),accepts_tab);
  return 0;
}

static int _wrap_gtk_text_view_get_accepts_tab(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_accepts_tab(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_pixels_above_lines(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int pixels_above_lines;
  if ( GetArgs(stack,rhs,opt,T,&pixels_above_lines) == FAIL) return RET_BUG;
    gtk_text_view_set_pixels_above_lines(GTK_TEXT_VIEW(self->obj),pixels_above_lines);
  return 0;
}

static int _wrap_gtk_text_view_get_pixels_above_lines(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_pixels_above_lines(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_pixels_below_lines(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int pixels_below_lines;
  if ( GetArgs(stack,rhs,opt,T,&pixels_below_lines) == FAIL) return RET_BUG;
    gtk_text_view_set_pixels_below_lines(GTK_TEXT_VIEW(self->obj),pixels_below_lines);
  return 0;
}

static int _wrap_gtk_text_view_get_pixels_below_lines(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_pixels_below_lines(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_pixels_inside_wrap(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int pixels_inside_wrap;
  if ( GetArgs(stack,rhs,opt,T,&pixels_inside_wrap) == FAIL) return RET_BUG;
    gtk_text_view_set_pixels_inside_wrap(GTK_TEXT_VIEW(self->obj),pixels_inside_wrap);
  return 0;
}

static int _wrap_gtk_text_view_get_pixels_inside_wrap(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_pixels_inside_wrap(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_justification(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkJustification justification;
  NspObject *nsp_justification = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_justification) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_JUSTIFICATION, nsp_justification, &justification)== FAIL)
      return RET_BUG;
    gtk_text_view_set_justification(GTK_TEXT_VIEW(self->obj),justification);
  return 0;
}

static int _wrap_gtk_text_view_get_justification(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_justification(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_left_margin(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int left_margin;
  if ( GetArgs(stack,rhs,opt,T,&left_margin) == FAIL) return RET_BUG;
    gtk_text_view_set_left_margin(GTK_TEXT_VIEW(self->obj),left_margin);
  return 0;
}

static int _wrap_gtk_text_view_get_left_margin(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_left_margin(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_right_margin(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int right_margin;
  if ( GetArgs(stack,rhs,opt,T,&right_margin) == FAIL) return RET_BUG;
    gtk_text_view_set_right_margin(GTK_TEXT_VIEW(self->obj),right_margin);
  return 0;
}

static int _wrap_gtk_text_view_get_right_margin(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_right_margin(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_indent(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int indent;
  if ( GetArgs(stack,rhs,opt,T,&indent) == FAIL) return RET_BUG;
    gtk_text_view_set_indent(GTK_TEXT_VIEW(self->obj),indent);
  return 0;
}

static int _wrap_gtk_text_view_get_indent(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_indent(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_text_view_set_tabs(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  PangoTabArray *tabs = NULL;
  NspObject *nsp_tabs = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_tabs) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_tabs, PANGO_TYPE_TAB_ARRAY))
      tabs = nspg_boxed_get(nsp_tabs, PangoTabArray);
  else {
      Scierror( "Error: tabs should be a PangoTabArray\n");
      return RET_BUG;
  }
    gtk_text_view_set_tabs(GTK_TEXT_VIEW(self->obj),tabs);
  return 0;
}

static int _wrap_gtk_text_view_get_tabs(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoTabArray *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_tabs(GTK_TEXT_VIEW(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,PANGO_TYPE_TAB_ARRAY, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_pangotabarray))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_text_view_get_default_attributes(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTextAttributes *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_default_attributes(GTK_TEXT_VIEW(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TEXT_ATTRIBUTES, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktextattributes))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_text_view_set_input_purpose(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkInputPurpose purpose;
  NspObject *nsp_purpose = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_purpose) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_INPUT_PURPOSE, nsp_purpose, &purpose)== FAIL)
      return RET_BUG;
    gtk_text_view_set_input_purpose(GTK_TEXT_VIEW(self->obj),purpose);
  return 0;
}

#else
int _wrap_gtk_text_view_set_input_purpose(Stack stack, int rhs, int opt, int lhs) /* set_input_purpose */
{
  Scierror("Error: function gtk_text_view_set_input_purpose not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_text_view_get_input_purpose(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_input_purpose(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_text_view_get_input_purpose(Stack stack, int rhs, int opt, int lhs) /* get_input_purpose */
{
  Scierror("Error: function gtk_text_view_get_input_purpose not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_text_view_set_input_hints(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkInputHints hints;
  NspObject *nsp_hints = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_hints) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_INPUT_HINTS, nsp_hints, &hints)==FAIL)
      return RET_BUG;
    gtk_text_view_set_input_hints(GTK_TEXT_VIEW(self->obj),hints);
  return 0;
}

#else
int _wrap_gtk_text_view_set_input_hints(Stack stack, int rhs, int opt, int lhs) /* set_input_hints */
{
  Scierror("Error: function gtk_text_view_set_input_hints not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_text_view_get_input_hints(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_input_hints(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_text_view_get_input_hints(Stack stack, int rhs, int opt, int lhs) /* get_input_hints */
{
  Scierror("Error: function gtk_text_view_get_input_hints not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_text_view_set_monospace(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int monospace;
  if ( GetArgs(stack,rhs,opt,T,&monospace) == FAIL) return RET_BUG;
    gtk_text_view_set_monospace(GTK_TEXT_VIEW(self->obj),monospace);
  return 0;
}

#else
int _wrap_gtk_text_view_set_monospace(Stack stack, int rhs, int opt, int lhs) /* set_monospace */
{
  Scierror("Error: function gtk_text_view_set_monospace not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_text_view_get_monospace(NspGtkTextView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_view_get_monospace(GTK_TEXT_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_text_view_get_monospace(Stack stack, int rhs, int opt, int lhs) /* get_monospace */
{
  Scierror("Error: function gtk_text_view_get_monospace not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtktextview_methods[] = {
  {"set_buffer",(nsp_method *) _wrap_gtk_text_view_set_buffer},
  {"get_buffer",(nsp_method *) _wrap_gtk_text_view_get_buffer},
  {"scroll_to_iter",(nsp_method *) _wrap_gtk_text_view_scroll_to_iter},
  {"scroll_to_mark",(nsp_method *) _wrap_gtk_text_view_scroll_to_mark},
  {"scroll_mark_onscreen",(nsp_method *) _wrap_gtk_text_view_scroll_mark_onscreen},
  {"move_mark_onscreen",(nsp_method *) _wrap_gtk_text_view_move_mark_onscreen},
  {"place_cursor_onscreen",(nsp_method *) _wrap_gtk_text_view_place_cursor_onscreen},
  {"get_visible_rect",(nsp_method *) _wrap_gtk_text_view_get_visible_rect},
  {"set_cursor_visible",(nsp_method *) _wrap_gtk_text_view_set_cursor_visible},
  {"get_cursor_visible",(nsp_method *) _wrap_gtk_text_view_get_cursor_visible},
  {"get_cursor_locations",(nsp_method *) _wrap_gtk_text_view_get_cursor_locations},
  {"get_iter_location",(nsp_method *) _wrap_gtk_text_view_get_iter_location},
  {"get_iter_at_location",(nsp_method *) _wrap_gtk_text_view_get_iter_at_location},
  {"get_iter_at_position",(nsp_method *) _wrap_gtk_text_view_get_iter_at_position},
  {"get_line_yrange",(nsp_method *) _wrap_gtk_text_view_get_line_yrange},
  {"get_line_at_y",(nsp_method *) _wrap_gtk_text_view_get_line_at_y},
  {"buffer_to_window_coords",(nsp_method *) _wrap_gtk_text_view_buffer_to_window_coords},
  {"window_to_buffer_coords",(nsp_method *) _wrap_gtk_text_view_window_to_buffer_coords},
  {"get_window",(nsp_method *) _wrap_gtk_text_view_get_window},
  {"get_window_type",(nsp_method *) _wrap_gtk_text_view_get_window_type},
  {"set_border_window_size",(nsp_method *) _wrap_gtk_text_view_set_border_window_size},
  {"get_border_window_size",(nsp_method *) _wrap_gtk_text_view_get_border_window_size},
  {"forward_display_line",(nsp_method *) _wrap_gtk_text_view_forward_display_line},
  {"backward_display_line",(nsp_method *) _wrap_gtk_text_view_backward_display_line},
  {"forward_display_line_end",(nsp_method *) _wrap_gtk_text_view_forward_display_line_end},
  {"backward_display_line_start",(nsp_method *) _wrap_gtk_text_view_backward_display_line_start},
  {"starts_display_line",(nsp_method *) _wrap_gtk_text_view_starts_display_line},
  {"move_visually",(nsp_method *) _wrap_gtk_text_view_move_visually},
  {"im_context_filter_keypress",(nsp_method *) _wrap_gtk_text_view_im_context_filter_keypress},
  {"reset_im_context",(nsp_method *) _wrap_gtk_text_view_reset_im_context},
  {"add_child_at_anchor",(nsp_method *) _wrap_gtk_text_view_add_child_at_anchor},
  {"add_child_in_window",(nsp_method *) _wrap_gtk_text_view_add_child_in_window},
  {"move_child",(nsp_method *) _wrap_gtk_text_view_move_child},
  {"set_wrap_mode",(nsp_method *) _wrap_gtk_text_view_set_wrap_mode},
  {"get_wrap_mode",(nsp_method *) _wrap_gtk_text_view_get_wrap_mode},
  {"set_editable",(nsp_method *) _wrap_gtk_text_view_set_editable},
  {"get_editable",(nsp_method *) _wrap_gtk_text_view_get_editable},
  {"set_overwrite",(nsp_method *) _wrap_gtk_text_view_set_overwrite},
  {"get_overwrite",(nsp_method *) _wrap_gtk_text_view_get_overwrite},
  {"set_accepts_tab",(nsp_method *) _wrap_gtk_text_view_set_accepts_tab},
  {"get_accepts_tab",(nsp_method *) _wrap_gtk_text_view_get_accepts_tab},
  {"set_pixels_above_lines",(nsp_method *) _wrap_gtk_text_view_set_pixels_above_lines},
  {"get_pixels_above_lines",(nsp_method *) _wrap_gtk_text_view_get_pixels_above_lines},
  {"set_pixels_below_lines",(nsp_method *) _wrap_gtk_text_view_set_pixels_below_lines},
  {"get_pixels_below_lines",(nsp_method *) _wrap_gtk_text_view_get_pixels_below_lines},
  {"set_pixels_inside_wrap",(nsp_method *) _wrap_gtk_text_view_set_pixels_inside_wrap},
  {"get_pixels_inside_wrap",(nsp_method *) _wrap_gtk_text_view_get_pixels_inside_wrap},
  {"set_justification",(nsp_method *) _wrap_gtk_text_view_set_justification},
  {"get_justification",(nsp_method *) _wrap_gtk_text_view_get_justification},
  {"set_left_margin",(nsp_method *) _wrap_gtk_text_view_set_left_margin},
  {"get_left_margin",(nsp_method *) _wrap_gtk_text_view_get_left_margin},
  {"set_right_margin",(nsp_method *) _wrap_gtk_text_view_set_right_margin},
  {"get_right_margin",(nsp_method *) _wrap_gtk_text_view_get_right_margin},
  {"set_indent",(nsp_method *) _wrap_gtk_text_view_set_indent},
  {"get_indent",(nsp_method *) _wrap_gtk_text_view_get_indent},
  {"set_tabs",(nsp_method *) _wrap_gtk_text_view_set_tabs},
  {"get_tabs",(nsp_method *) _wrap_gtk_text_view_get_tabs},
  {"get_default_attributes",(nsp_method *) _wrap_gtk_text_view_get_default_attributes},
  {"set_input_purpose",(nsp_method *) _wrap_gtk_text_view_set_input_purpose},
  {"get_input_purpose",(nsp_method *) _wrap_gtk_text_view_get_input_purpose},
  {"set_input_hints",(nsp_method *) _wrap_gtk_text_view_set_input_hints},
  {"get_input_hints",(nsp_method *) _wrap_gtk_text_view_get_input_hints},
  {"set_monospace",(nsp_method *) _wrap_gtk_text_view_set_monospace},
  {"get_monospace",(nsp_method *) _wrap_gtk_text_view_get_monospace},
  { NULL, NULL}
};

static NspMethods *gtktextview_get_methods(void) { return gtktextview_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktextview_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTextChildAnchor ----------- */


#define  NspGtkTextChildAnchor_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktextchildanchor.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTextChildAnchor inherits from GObject 
 */

int nsp_type_gtktextchildanchor_id=0;
NspTypeGtkTextChildAnchor *nsp_type_gtktextchildanchor=NULL;

/*
 * Type object for NspGtkTextChildAnchor 
 * all the instance of NspTypeGtkTextChildAnchor share the same id. 
 * nsp_type_gtktextchildanchor: is an instance of NspTypeGtkTextChildAnchor 
 *    used for objects of NspGtkTextChildAnchor type (i.e built with new_gtktextchildanchor) 
 * other instances are used for derived classes 
 */
NspTypeGtkTextChildAnchor *new_type_gtktextchildanchor(type_mode mode)
{
  NspTypeGtkTextChildAnchor *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktextchildanchor != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktextchildanchor;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktextchildanchor_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktextchildanchor_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktextchildanchor;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktextchildanchor */ 

  top->s_type =  (s_type_func *) nsp_gtktextchildanchor_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktextchildanchor_type_short_string;
  /* top->create = (create_func*) int_gtktextchildanchor_create;*/

  /* specific methods for gtktextchildanchor */

  type->init = (init_func *) init_gtktextchildanchor;

  /* 
   * NspGtkTextChildAnchor interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktextchildanchor_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTextChildAnchor called nsp_type_gtktextchildanchor
       */
      type->id =  nsp_type_gtktextchildanchor_id = nsp_new_type_id();
      nsp_type_gtktextchildanchor = type;
      if ( nsp_register_type(nsp_type_gtktextchildanchor) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktextchildanchor, GTK_TYPE_TEXT_CHILD_ANCHOR);
      return ( mode == T_BASE ) ? type : new_type_gtktextchildanchor(mode);
    }
  else 
    {
      type->id = nsp_type_gtktextchildanchor_id;
      return type;
    }
}

/*
 * initialize NspGtkTextChildAnchor instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktextchildanchor(NspGtkTextChildAnchor *Obj,NspTypeGtkTextChildAnchor *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTextChildAnchor 
 */

NspGtkTextChildAnchor *new_gtktextchildanchor() 
{
  NspGtkTextChildAnchor *loc;
  /* type must exists */
  nsp_type_gtktextchildanchor = new_type_gtktextchildanchor(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTextChildAnchor)))== NULLGTKTEXTCHILDANCHOR) return loc;
  /* initialize object */
  if ( init_gtktextchildanchor(loc,nsp_type_gtktextchildanchor) == FAIL) return NULLGTKTEXTCHILDANCHOR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTextChildAnchor 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktextchildanchor_type_name[]="GtkTextChildAnchor";
static char gtktextchildanchor_short_type_name[]="GtkTextChildAnchor";

static char *nsp_gtktextchildanchor_type_as_string(void)
{
  return(gtktextchildanchor_type_name);
}

static char *nsp_gtktextchildanchor_type_short_string(NspObject *v)
{
  return(gtktextchildanchor_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTextChildAnchor objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTextChildAnchor   *nsp_gtktextchildanchor_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktextchildanchor_id)  == TRUE  ) return ((NspGtkTextChildAnchor *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktextchildanchor));
  return NULL;
}

int IsGtkTextChildAnchorObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktextchildanchor_id);
}

int IsGtkTextChildAnchor(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktextchildanchor_id);
}

NspGtkTextChildAnchor  *GetGtkTextChildAnchorCopy(Stack stack, int i)
{
  if (  GetGtkTextChildAnchor(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTextChildAnchor  *GetGtkTextChildAnchor(Stack stack, int i)
{
  NspGtkTextChildAnchor *M;
  if (( M = nsp_gtktextchildanchor_object(NthObj(i))) == NULLGTKTEXTCHILDANCHOR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTextChildAnchor *gtktextchildanchor_copy(NspGtkTextChildAnchor *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextchildanchor);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktextchildanchor);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTextChildAnchor
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_text_child_anchor_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_text_child_anchor_new())== NULL) return RET_BUG;

  nsp_type_gtktextchildanchor = new_type_gtktextchildanchor(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktextchildanchor);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 6110 "codegen-3.0/gtk.override"
static int
_wrap_gtk_text_child_anchor_get_widgets(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  list = gtk_text_child_anchor_get_widgets(GTK_TEXT_CHILD_ANCHOR(self->obj));
  NSP_LIST_FROM_GLIST(list,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);
}
#line 38363 "gtk.c"


static int _wrap_gtk_text_child_anchor_get_deleted(NspGtkTextChildAnchor *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_text_child_anchor_get_deleted(GTK_TEXT_CHILD_ANCHOR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktextchildanchor_methods[] = {
  {"get_widgets",(nsp_method *) _wrap_gtk_text_child_anchor_get_widgets},
  {"get_deleted",(nsp_method *) _wrap_gtk_text_child_anchor_get_deleted},
  { NULL, NULL}
};

static NspMethods *gtktextchildanchor_get_methods(void) { return gtktextchildanchor_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktextchildanchor_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeSelection ----------- */


#define  NspGtkTreeSelection_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreeselection.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeSelection inherits from GObject 
 */

int nsp_type_gtktreeselection_id=0;
NspTypeGtkTreeSelection *nsp_type_gtktreeselection=NULL;

/*
 * Type object for NspGtkTreeSelection 
 * all the instance of NspTypeGtkTreeSelection share the same id. 
 * nsp_type_gtktreeselection: is an instance of NspTypeGtkTreeSelection 
 *    used for objects of NspGtkTreeSelection type (i.e built with new_gtktreeselection) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeSelection *new_type_gtktreeselection(type_mode mode)
{
  NspTypeGtkTreeSelection *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreeselection != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreeselection;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreeselection_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreeselection_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreeselection;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreeselection */ 

  top->s_type =  (s_type_func *) nsp_gtktreeselection_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreeselection_type_short_string;
  /* top->create = (create_func*) int_gtktreeselection_create;*/

  /* specific methods for gtktreeselection */

  type->init = (init_func *) init_gtktreeselection;

  /* 
   * NspGtkTreeSelection interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktreeselection_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeSelection called nsp_type_gtktreeselection
       */
      type->id =  nsp_type_gtktreeselection_id = nsp_new_type_id();
      nsp_type_gtktreeselection = type;
      if ( nsp_register_type(nsp_type_gtktreeselection) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreeselection, GTK_TYPE_TREE_SELECTION);
      return ( mode == T_BASE ) ? type : new_type_gtktreeselection(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreeselection_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeSelection instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreeselection(NspGtkTreeSelection *Obj,NspTypeGtkTreeSelection *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeSelection 
 */

NspGtkTreeSelection *new_gtktreeselection() 
{
  NspGtkTreeSelection *loc;
  /* type must exists */
  nsp_type_gtktreeselection = new_type_gtktreeselection(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeSelection)))== NULLGTKTREESELECTION) return loc;
  /* initialize object */
  if ( init_gtktreeselection(loc,nsp_type_gtktreeselection) == FAIL) return NULLGTKTREESELECTION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeSelection 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreeselection_type_name[]="GtkTreeSelection";
static char gtktreeselection_short_type_name[]="GtkTreeSelection";

static char *nsp_gtktreeselection_type_as_string(void)
{
  return(gtktreeselection_type_name);
}

static char *nsp_gtktreeselection_type_short_string(NspObject *v)
{
  return(gtktreeselection_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeSelection objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeSelection   *nsp_gtktreeselection_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktreeselection_id)  == TRUE  ) return ((NspGtkTreeSelection *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreeselection));
  return NULL;
}

int IsGtkTreeSelectionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktreeselection_id);
}

int IsGtkTreeSelection(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreeselection_id);
}

NspGtkTreeSelection  *GetGtkTreeSelectionCopy(Stack stack, int i)
{
  if (  GetGtkTreeSelection(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeSelection  *GetGtkTreeSelection(Stack stack, int i)
{
  NspGtkTreeSelection *M;
  if (( M = nsp_gtktreeselection_object(NthObj(i))) == NULLGTKTREESELECTION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeSelection *gtktreeselection_copy(NspGtkTreeSelection *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeselection);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeselection);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeSelection
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_tree_selection_set_mode(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSelectionMode type;
  NspObject *nsp_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SELECTION_MODE, nsp_type, &type)== FAIL)
      return RET_BUG;
    gtk_tree_selection_set_mode(GTK_TREE_SELECTION(self->obj),type);
  return 0;
}

static int _wrap_gtk_tree_selection_get_mode(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tree_selection_get_mode(GTK_TREE_SELECTION(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 3398 "codegen-3.0/gtk.override"

static gboolean
nspgtk_tree_selection_marshal(GtkTreeSelection *selection,
			      GtkTreeModel *model,
			      GtkTreePath *path,
			      gboolean path_currently_selected,
			      gpointer data)
{
  NspObject *args[2];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 0,nargs = 1;
  gboolean ret = FALSE;

  nspg_block_threads();

  args[0] = (NspObject *) gboxed_create("path",GTK_TYPE_TREE_PATH,path,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
  if ( args[0]== NULL ) goto end;
  if (cunote->data)
    {
      args[1]= cunote->data;
      nargs= 2;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL)
    goto end;

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  goto end;
 end:
  {
    nspg_unblock_threads();
    return ret;
  }
}

static int
_wrap_gtk_tree_selection_set_select_function(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify *cunote;

  CheckRhs(1,2);

  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /* extra arguments **/
  if ( rhs == 2 )
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }

  cunote = g_new0(NspGtkCustomNotify, 1);
  cunote->func = func;
  cunote->data = arg;
  gtk_tree_selection_set_select_function(GTK_TREE_SELECTION(self->obj),
					 nspgtk_tree_selection_marshal,
					 cunote,
					 nspgtk_custom_destroy_notify);
  return 0;
}

#line 38665 "gtk.c"


static int _wrap_gtk_tree_selection_get_tree_view(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeView *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tree_selection_get_tree_view(GTK_TREE_SELECTION(self->obj));
  nsp_type_gtktreeview = new_type_gtktreeview(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeview))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 3293 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_selection_get_selected(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *model;
  GtkTreeIter iter;
  GtkSelectionMode mode;
  NspObject *nsp_ret1,*nsp_ret2=NULL;
  int rep;
  mode = gtk_tree_selection_get_mode(GTK_TREE_SELECTION(self->obj));
  if (mode == GTK_SELECTION_MULTIPLE) {
    Scierror("GtkTreeSelection.get_selected can not be used when selection mode is gtk.SELECTION_MULTIPLE\n");
    return RET_BUG;
  }
  rep = gtk_tree_selection_get_selected(GTK_TREE_SELECTION(self->obj),&model, &iter);
  if ( rep )
    {
      if ((nsp_ret1 = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter,TRUE, TRUE,(NspTypeBase *)
						 nsp_type_gtktreeiter ))==NULL)
	return RET_BUG;
      if ( lhs == 2)
	{
	  if ((nsp_ret2 = (NspObject *) nspgobject_new(NVOID,(GObject *) model) )  == NULL)
	    return RET_BUG;
	}
    }
  else
    {
      if ((nsp_ret1 = (NspObject *)nsp_none_create(NVOID,NULL)) == NULL)
	return RET_BUG;
      if ( lhs == 2)
	{
	  if ((nsp_ret2 = (NspObject *) nsp_none_create(NVOID,NULL)) == NULL)
	    return RET_BUG;
	}
    }

  MoveObj(stack,1,nsp_ret1);
  if ( lhs == 2 ) MoveObj(stack,2,nsp_ret2);
  return Max(lhs,1);
}
#line 38721 "gtk.c"


#line 3463 "codegen-3.0/gtk.override"
/* take care that here the glist contain boxed not gobjects */
static int _wrap_gtk_tree_selection_get_selected_rows(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  NspList *nsp_list;
  GList *ret, *tmp;
  ret = gtk_tree_selection_get_selected_rows(GTK_TREE_SELECTION(self->obj),NULL);
  NSP_LIST_FROM_GLIST(ret,((NspObject *)gboxed_create("lel",GTK_TYPE_TREE_PATH,tmp->data,TRUE, TRUE, (NspTypeBase *) nsp_type_gtktreepath)),g_list_free);
}

#line 38734 "gtk.c"


static int _wrap_gtk_tree_selection_count_selected_rows(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_selection_count_selected_rows(GTK_TREE_SELECTION(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 3335 "codegen-3.0/gtk.override"
static void
nspgtk_tree_selection_foreach_marshal(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter,  gpointer data)
{
  NspObject *args[4];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 0,nargs = 3;
  /* gboolean ret = FALSE;*/

  nspg_block_threads();
  /* Il faut ici proteger les args avec des noms et
   * viter de les construire a chaque itration .... XXXXXX
   */

  args[0] = (NspObject *) gobject_create("model",(GObject *)model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[1] = (NspObject *) gboxed_create("path",GTK_TYPE_TREE_PATH,path,TRUE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
  args[2] = (NspObject *) gboxed_create("iter",GTK_TYPE_TREE_ITER, iter,TRUE, TRUE,nsp_type_gtktreeiter);
  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL ) goto end;
  if (cunote->data)
    {
      args[3]= cunote->data;
      nargs= 4;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL)
    goto end;
  /*
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  */
  goto end;
 end:
  {
    nspg_unblock_threads();
    /*return ret;*/
  }
}

static int
_wrap_gtk_tree_selection_selected_foreach(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify cunote;

  CheckRhs(1,2);

  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /* extra arguments **/
  if ( rhs == 2 )
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }
  cunote.func = func;
  cunote.data = arg;
  gtk_tree_selection_selected_foreach(GTK_TREE_SELECTION(self->obj),
				      nspgtk_tree_selection_foreach_marshal,
				      &cunote);
  return 0;
}

#line 38808 "gtk.c"


static int _wrap_gtk_tree_selection_select_path(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_tree_selection_select_path(GTK_TREE_SELECTION(self->obj),path);
  return 0;
}

static int _wrap_gtk_tree_selection_unselect_path(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_tree_selection_unselect_path(GTK_TREE_SELECTION(self->obj),path);
  return 0;
}

static int _wrap_gtk_tree_selection_select_iter(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_selection_select_iter(GTK_TREE_SELECTION(self->obj),iter);
  return 0;
}

static int _wrap_gtk_tree_selection_unselect_iter(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_selection_unselect_iter(GTK_TREE_SELECTION(self->obj),iter);
  return 0;
}

static int _wrap_gtk_tree_selection_path_is_selected(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_selection_path_is_selected(GTK_TREE_SELECTION(self->obj),path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_selection_iter_is_selected(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_selection_iter_is_selected(GTK_TREE_SELECTION(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_selection_select_all(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_selection_select_all(GTK_TREE_SELECTION(self->obj));
  return 0;
}

static int _wrap_gtk_tree_selection_unselect_all(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_selection_unselect_all(GTK_TREE_SELECTION(self->obj));
  return 0;
}

static int _wrap_gtk_tree_selection_select_range(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreePath *start_path = NULL, *end_path = NULL;
  NspObject *nsp_start_path = NULL, *nsp_end_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_start_path, &nsp_end_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start_path, GTK_TYPE_TREE_PATH))
      start_path = nspg_boxed_get(nsp_start_path, GtkTreePath);
  else {
      Scierror( "Error: start_path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end_path, GTK_TYPE_TREE_PATH))
      end_path = nspg_boxed_get(nsp_end_path, GtkTreePath);
  else {
      Scierror( "Error: end_path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_tree_selection_select_range(GTK_TREE_SELECTION(self->obj),start_path,end_path);
  return 0;
}

static int _wrap_gtk_tree_selection_unselect_range(NspGtkTreeSelection *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreePath *start_path = NULL, *end_path = NULL;
  NspObject *nsp_start_path = NULL, *nsp_end_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_start_path, &nsp_end_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_start_path, GTK_TYPE_TREE_PATH))
      start_path = nspg_boxed_get(nsp_start_path, GtkTreePath);
  else {
      Scierror( "Error: start_path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_end_path, GTK_TYPE_TREE_PATH))
      end_path = nspg_boxed_get(nsp_end_path, GtkTreePath);
  else {
      Scierror( "Error: end_path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_tree_selection_unselect_range(GTK_TREE_SELECTION(self->obj),start_path,end_path);
  return 0;
}

static NspMethods gtktreeselection_methods[] = {
  {"set_mode",(nsp_method *) _wrap_gtk_tree_selection_set_mode},
  {"get_mode",(nsp_method *) _wrap_gtk_tree_selection_get_mode},
  {"set_select_function",(nsp_method *) _wrap_gtk_tree_selection_set_select_function},
  {"get_tree_view",(nsp_method *) _wrap_gtk_tree_selection_get_tree_view},
  {"get_selected",(nsp_method *) _wrap_gtk_tree_selection_get_selected},
  {"get_selected_rows",(nsp_method *) _wrap_gtk_tree_selection_get_selected_rows},
  {"count_selected_rows",(nsp_method *) _wrap_gtk_tree_selection_count_selected_rows},
  {"selected_foreach",(nsp_method *) _wrap_gtk_tree_selection_selected_foreach},
  {"select_path",(nsp_method *) _wrap_gtk_tree_selection_select_path},
  {"unselect_path",(nsp_method *) _wrap_gtk_tree_selection_unselect_path},
  {"select_iter",(nsp_method *) _wrap_gtk_tree_selection_select_iter},
  {"unselect_iter",(nsp_method *) _wrap_gtk_tree_selection_unselect_iter},
  {"path_is_selected",(nsp_method *) _wrap_gtk_tree_selection_path_is_selected},
  {"iter_is_selected",(nsp_method *) _wrap_gtk_tree_selection_iter_is_selected},
  {"select_all",(nsp_method *) _wrap_gtk_tree_selection_select_all},
  {"unselect_all",(nsp_method *) _wrap_gtk_tree_selection_unselect_all},
  {"select_range",(nsp_method *) _wrap_gtk_tree_selection_select_range},
  {"unselect_range",(nsp_method *) _wrap_gtk_tree_selection_unselect_range},
  { NULL, NULL}
};

static NspMethods *gtktreeselection_get_methods(void) { return gtktreeselection_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreeselection_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeViewColumn ----------- */


#define  NspGtkTreeViewColumn_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreeviewcolumn.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeViewColumn inherits from GObject 
 * and implements GtkBuildable GtkCellLayout
 */

int nsp_type_gtktreeviewcolumn_id=0;
NspTypeGtkTreeViewColumn *nsp_type_gtktreeviewcolumn=NULL;

/*
 * Type object for NspGtkTreeViewColumn 
 * all the instance of NspTypeGtkTreeViewColumn share the same id. 
 * nsp_type_gtktreeviewcolumn: is an instance of NspTypeGtkTreeViewColumn 
 *    used for objects of NspGtkTreeViewColumn type (i.e built with new_gtktreeviewcolumn) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeViewColumn *new_type_gtktreeviewcolumn(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkCellLayout *t_gtkcelllayout;
  NspTypeGtkTreeViewColumn *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreeviewcolumn != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreeviewcolumn;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreeviewcolumn_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreeviewcolumn_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreeviewcolumn;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreeviewcolumn */ 

  top->s_type =  (s_type_func *) nsp_gtktreeviewcolumn_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreeviewcolumn_type_short_string;
  /* top->create = (create_func*) int_gtktreeviewcolumn_create;*/

  /* specific methods for gtktreeviewcolumn */

  type->init = (init_func *) init_gtktreeviewcolumn;

  /* 
   * NspGtkTreeViewColumn interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  t_gtkcelllayout = new_type_gtkcelllayout(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkcelllayout;
  if ( nsp_type_gtktreeviewcolumn_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeViewColumn called nsp_type_gtktreeviewcolumn
       */
      type->id =  nsp_type_gtktreeviewcolumn_id = nsp_new_type_id();
      nsp_type_gtktreeviewcolumn = type;
      if ( nsp_register_type(nsp_type_gtktreeviewcolumn) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreeviewcolumn, GTK_TYPE_TREE_VIEW_COLUMN);
      return ( mode == T_BASE ) ? type : new_type_gtktreeviewcolumn(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreeviewcolumn_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeViewColumn instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreeviewcolumn(NspGtkTreeViewColumn *Obj,NspTypeGtkTreeViewColumn *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeViewColumn 
 */

NspGtkTreeViewColumn *new_gtktreeviewcolumn() 
{
  NspGtkTreeViewColumn *loc;
  /* type must exists */
  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeViewColumn)))== NULLGTKTREEVIEWCOLUMN) return loc;
  /* initialize object */
  if ( init_gtktreeviewcolumn(loc,nsp_type_gtktreeviewcolumn) == FAIL) return NULLGTKTREEVIEWCOLUMN;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeViewColumn 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreeviewcolumn_type_name[]="GtkTreeViewColumn";
static char gtktreeviewcolumn_short_type_name[]="GtkTreeViewColumn";

static char *nsp_gtktreeviewcolumn_type_as_string(void)
{
  return(gtktreeviewcolumn_type_name);
}

static char *nsp_gtktreeviewcolumn_type_short_string(NspObject *v)
{
  return(gtktreeviewcolumn_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeViewColumn objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeViewColumn   *nsp_gtktreeviewcolumn_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktreeviewcolumn_id)  == TRUE  ) return ((NspGtkTreeViewColumn *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreeviewcolumn));
  return NULL;
}

int IsGtkTreeViewColumnObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktreeviewcolumn_id);
}

int IsGtkTreeViewColumn(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreeviewcolumn_id);
}

NspGtkTreeViewColumn  *GetGtkTreeViewColumnCopy(Stack stack, int i)
{
  if (  GetGtkTreeViewColumn(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeViewColumn  *GetGtkTreeViewColumn(Stack stack, int i)
{
  NspGtkTreeViewColumn *M;
  if (( M = nsp_gtktreeviewcolumn_object(NthObj(i))) == NULLGTKTREEVIEWCOLUMN)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeViewColumn *gtktreeviewcolumn_copy(NspGtkTreeViewColumn *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeviewcolumn);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeviewcolumn);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeViewColumn
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_tree_view_column_new_with_area (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *area;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellarea, &area) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_tree_view_column_new_with_area(GTK_CELL_AREA(area->obj)))== NULL) return RET_BUG;

  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeviewcolumn);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 2712 "codegen-3.0/gtk.override"
/* gtktreeviewcolumn_new(title="...",renderer=nsp_type_gtkcellrenderer,options= hash)
 * options a hash table of int values
 */
static int
_wrap_gtk_tree_view_column_new(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_cell = NULL,*nsp_ret;
  NspHash *h =NULL;
  GtkTreeViewColumn *tvc;
  gchar *title = NULL;
  GtkCellRenderer *cell = NULL;

  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"title",string,NULLOBJ,-1},
	{"renderer",obj_check,NULLOBJ,-1},
	{"attrs",hash,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };

  if (GetArgs(stack,rhs,opt,T, &opts, &title,&nsp_type_gtkcellrenderer,&nsp_cell, &h)== FAIL)
    return RET_BUG;
  if ( nsp_cell != NULL) cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));

  tvc = gtk_tree_view_column_new();
  if (title != NULL )  gtk_tree_view_column_set_title(tvc, title);
  if (cell != NULL )   gtk_tree_view_column_pack_start(tvc, cell, TRUE);
  if (h != NULL)
    {
      int i;
      for ( i =0 ; i < h->hsize ; i++)
	{
	  Hash_Entry *loc = ((Hash_Entry *) h->htable) + i;
	  if ( loc->used )
	    {
	      if ( IsMat(loc->data)
		   && (((NspMatrix *) loc->data)->mn == 1)
		   && (((NspMatrix *) loc->data)->rc_type == 'r' ))
		gtk_tree_view_column_add_attribute(tvc, cell,nsp_object_get_name(loc->data),
						   ((NspMatrix *) loc->data)->R[0]);
	      else
		{
		  Scierror("%s: attribute %s should be a real scalar\n",NspFname(stack),nsp_object_get_name(loc->data));
		  return RET_BUG;
		}
	    }
	}
    }

  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *) tvc,(NspTypeBase *) nsp_type_gtktreeviewcolumn );
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 39268 "gtk.c"


static int _wrap_gtk_tree_view_column_pack_start(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *cell;
  int expand;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell, &expand) == FAIL) return RET_BUG;
    gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(self->obj),GTK_CELL_RENDERER(cell->obj),expand);
  return 0;
}

static int _wrap_gtk_tree_view_column_pack_end(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *cell;
  int expand;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell, &expand) == FAIL) return RET_BUG;
    gtk_tree_view_column_pack_end(GTK_TREE_VIEW_COLUMN(self->obj),GTK_CELL_RENDERER(cell->obj),expand);
  return 0;
}

static int _wrap_gtk_tree_view_column_clear(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_view_column_clear(GTK_TREE_VIEW_COLUMN(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_column_add_attribute(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string,s_int, t_end};
  NspGObject *cell_renderer;
  char *attribute;
  int column;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell_renderer, &attribute, &column) == FAIL) return RET_BUG;
    gtk_tree_view_column_add_attribute(GTK_TREE_VIEW_COLUMN(self->obj),GTK_CELL_RENDERER(cell_renderer->obj),attribute,column);
  return 0;
}

#line 2919 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_view_column_set_attributes(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspHash *h =NULL;
  GtkCellRenderer *cell;
  NspGtkCellRenderer *nsp_cell;
  gint i = 0;

  CheckRhs(2,2) ;
  if ((nsp_cell = GetGtkCellRenderer(stack,1)) == NULL) return RET_BUG;
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));
  if ((h = GetHash(stack,2)) == NULL) return RET_BUG;
  gtk_tree_view_column_clear_attributes(GTK_TREE_VIEW_COLUMN(self->obj),cell);

  for ( i =0 ; i < h->hsize ; i++)
    {
      Hash_Entry *loc = ((Hash_Entry *) h->htable) + i;
      if ( loc->used )
	{
	  if ( IsMat(loc->data)
	       && (((NspMatrix *) loc->data)->mn == 1)
	       && (((NspMatrix *) loc->data)->rc_type == 'r' ))
	    gtk_tree_view_column_add_attribute(GTK_TREE_VIEW_COLUMN(self->obj), cell,nsp_object_get_name(loc->data),
					       ((NspMatrix *) loc->data)->R[0]);
	  else
	    {
	      Scierror("%s: attribute %s should be a real scalar\n",NspFname(stack),nsp_object_get_name(loc->data));
	      return RET_BUG;
	    }
	}
    }
  return 0;
}
#line 39343 "gtk.c"


#line 2797 "codegen-3.0/gtk.override"
static void
nspgtk_cell_data_func_marshal (GtkTreeViewColumn *tree_column,
			       GtkCellRenderer *cell,
			       GtkTreeModel *tree_model,
			       GtkTreeIter *iter, gpointer data)
{
  NspObject *args[5], *nsp_ret;
  NspGtkCustomNotify *cunote = data;
  int nret = 0,nargs = 4;
  /* gboolean ret = FALSE; */

  g_assert (cunote->func);

  nspg_block_threads();

  args[0] =  (NspObject *) gobject_create("tree_column",(GObject *)tree_column,(NspTypeBase *) nsp_type_gtktreeviewcolumn );
  /* here we use  nspgobject_new to create the most specific object */
  args[1] =  (NspObject *) nspgobject_new("cell", (GObject *) cell);
  args[2] =  (NspObject *) gobject_create("model",(GObject *)tree_model,(NspTypeBase *) nsp_type_gtktreemodel );
  args[3] =  (NspObject *) gboxed_create("iter",GTK_TYPE_TREE_ITER, iter,TRUE, TRUE,(NspTypeBase *)nsp_type_gtktreeiter);

  if ( args[0]== NULL ||args[1]== NULL ||args[2]== NULL||args[3]== NULL ) goto end;
  if (cunote->data)
    {
      args[4]= cunote->data;
      nargs= 5;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL)
    goto end;

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    {
      /* ret =  ((NspBMatrix *) nsp_ret)->B[0]; */
    }
  nspg_unblock_threads();
 end:
  {
    nspg_unblock_threads();
  }
}

static int
_wrap_gtk_tree_view_column_set_cell_data_func (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_func, *nsp_arg = NULL;
  GtkCellRenderer *cell;
  NspGtkCellRenderer *nsp_cell;
  NspGtkCustomNotify *cunote;
  CheckRhs(2,3);
  if ((nsp_cell = GetGtkCellRenderer(stack,1)) == NULL) return RET_BUG;
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,2)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"tree_foreach")== FAIL)) return RET_BUG;
  /* extra arguments **/
  if ( rhs == 3 )
    {
      if (( nsp_arg = (NspObject *) GetListCopy(stack,3)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;

  gtk_tree_view_column_set_cell_data_func (GTK_TREE_VIEW_COLUMN (self->obj), cell,
					   nspgtk_cell_data_func_marshal,
					   cunote,
					   nspgtk_custom_destroy_notify);

  return 0;
}
#line 39417 "gtk.c"


static int _wrap_gtk_tree_view_column_clear_attributes(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *cell_renderer;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell_renderer) == FAIL) return RET_BUG;
    gtk_tree_view_column_clear_attributes(GTK_TREE_VIEW_COLUMN(self->obj),GTK_CELL_RENDERER(cell_renderer->obj));
  return 0;
}

static int _wrap_gtk_tree_view_column_set_spacing(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int spacing;
  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_spacing(GTK_TREE_VIEW_COLUMN(self->obj),spacing);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_spacing(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_spacing(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_visible(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int visible;
  if ( GetArgs(stack,rhs,opt,T,&visible) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_visible(GTK_TREE_VIEW_COLUMN(self->obj),visible);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_visible(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_visible(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_resizable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int resizable;
  if ( GetArgs(stack,rhs,opt,T,&resizable) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_resizable(GTK_TREE_VIEW_COLUMN(self->obj),resizable);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_resizable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_resizable(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_sizing(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeViewColumnSizing type;
  NspObject *nsp_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TREE_VIEW_COLUMN_SIZING, nsp_type, &type)== FAIL)
      return RET_BUG;
    gtk_tree_view_column_set_sizing(GTK_TREE_VIEW_COLUMN(self->obj),type);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_sizing(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_sizing(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_tree_view_column_get_x_offset(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_x_offset(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_tree_view_column_get_x_offset(Stack stack, int rhs, int opt, int lhs) /* get_x_offset */
{
  Scierror("Error: function gtk_tree_view_column_get_x_offset not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_tree_view_column_get_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_width(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_get_fixed_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_fixed_width(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_fixed_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int fixed_width;
  if ( GetArgs(stack,rhs,opt,T,&fixed_width) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_fixed_width(GTK_TREE_VIEW_COLUMN(self->obj),fixed_width);
  return 0;
}

static int _wrap_gtk_tree_view_column_set_min_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int min_width;
  if ( GetArgs(stack,rhs,opt,T,&min_width) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_min_width(GTK_TREE_VIEW_COLUMN(self->obj),min_width);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_min_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_min_width(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_max_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int max_width;
  if ( GetArgs(stack,rhs,opt,T,&max_width) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_max_width(GTK_TREE_VIEW_COLUMN(self->obj),max_width);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_max_width(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_max_width(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_clicked(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_view_column_clicked(GTK_TREE_VIEW_COLUMN(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_column_set_title(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *title;
  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_title(GTK_TREE_VIEW_COLUMN(self->obj),title);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_title(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_title(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_expand(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int expand;
  if ( GetArgs(stack,rhs,opt,T,&expand) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_expand(GTK_TREE_VIEW_COLUMN(self->obj),expand);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_expand(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_expand(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_clickable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int clickable;
  if ( GetArgs(stack,rhs,opt,T,&clickable) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_clickable(GTK_TREE_VIEW_COLUMN(self->obj),clickable);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_clickable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_clickable(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_widget(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_widget(GTK_TREE_VIEW_COLUMN(self->obj),GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_tree_view_column_get_widget(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_widget(GTK_TREE_VIEW_COLUMN(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_column_set_alignment(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double xalign;
  if ( GetArgs(stack,rhs,opt,T,&xalign) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_alignment(GTK_TREE_VIEW_COLUMN(self->obj),xalign);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_alignment(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_alignment(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_reorderable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int reorderable;
  if ( GetArgs(stack,rhs,opt,T,&reorderable) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_reorderable(GTK_TREE_VIEW_COLUMN(self->obj),reorderable);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_reorderable(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_reorderable(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_sort_column_id(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int sort_column_id;
  if ( GetArgs(stack,rhs,opt,T,&sort_column_id) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_sort_column_id(GTK_TREE_VIEW_COLUMN(self->obj),sort_column_id);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_sort_column_id(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_sort_column_id(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_sort_indicator(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_tree_view_column_set_sort_indicator(GTK_TREE_VIEW_COLUMN(self->obj),setting);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_sort_indicator(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_sort_indicator(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_set_sort_order(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSortType order;
  NspObject *nsp_order = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_order) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SORT_TYPE, nsp_order, &order)== FAIL)
      return RET_BUG;
    gtk_tree_view_column_set_sort_order(GTK_TREE_VIEW_COLUMN(self->obj),order);
  return 0;
}

static int _wrap_gtk_tree_view_column_get_sort_order(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_sort_order(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_cell_set_cell_data(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,s_bool,s_bool, t_end};
  NspGObject *tree_model;
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int is_expander, is_expanded;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreemodel, &tree_model, &nsp_iter, &is_expander, &is_expanded) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_view_column_cell_set_cell_data(GTK_TREE_VIEW_COLUMN(self->obj),GTK_TREE_MODEL(tree_model->obj),iter,is_expander,is_expanded);
  return 0;
}

#line 2768 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_view_column_cell_get_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int,s_int,s_int,t_end};
  GdkRectangle cell_area;
  gint x_offset, y_offset, width, height;

  gtk_tree_view_column_cell_get_size(GTK_TREE_VIEW_COLUMN(self->obj),
				     &cell_area,
				     &x_offset, &y_offset, &width, &height);

  return RetArgs(stack,lhs,T,
		 (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE,
					     &cell_area,TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle),
		 x_offset, y_offset, width, height);
}
#line 39794 "gtk.c"


static int _wrap_gtk_tree_view_column_cell_is_visible(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_cell_is_visible(GTK_TREE_VIEW_COLUMN(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_focus_cell(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *cell;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell) == FAIL) return RET_BUG;
    gtk_tree_view_column_focus_cell(GTK_TREE_VIEW_COLUMN(self->obj),GTK_CELL_RENDERER(cell->obj));
  return 0;
}

static int _wrap_gtk_tree_view_column_cell_get_position(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int, t_end};
  NspGObject *cell_renderer;
  int x_offset, width, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &cell_renderer, &x_offset, &width) == FAIL) return RET_BUG;
    ret =gtk_tree_view_column_cell_get_position(GTK_TREE_VIEW_COLUMN(self->obj),GTK_CELL_RENDERER(cell_renderer->obj),&x_offset,&width);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_column_queue_resize(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_view_column_queue_resize(GTK_TREE_VIEW_COLUMN(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_column_get_tree_view(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_tree_view(GTK_TREE_VIEW_COLUMN(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_column_get_button(NspGtkTreeViewColumn *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_column_get_button(GTK_TREE_VIEW_COLUMN(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtktreeviewcolumn_methods[] = {
  {"pack_start",(nsp_method *) _wrap_gtk_tree_view_column_pack_start},
  {"pack_end",(nsp_method *) _wrap_gtk_tree_view_column_pack_end},
  {"clear",(nsp_method *) _wrap_gtk_tree_view_column_clear},
  {"add_attribute",(nsp_method *) _wrap_gtk_tree_view_column_add_attribute},
  {"set_attributes",(nsp_method *) _wrap_gtk_tree_view_column_set_attributes},
  {"set_cell_data_func",(nsp_method *) _wrap_gtk_tree_view_column_set_cell_data_func},
  {"clear_attributes",(nsp_method *) _wrap_gtk_tree_view_column_clear_attributes},
  {"set_spacing",(nsp_method *) _wrap_gtk_tree_view_column_set_spacing},
  {"get_spacing",(nsp_method *) _wrap_gtk_tree_view_column_get_spacing},
  {"set_visible",(nsp_method *) _wrap_gtk_tree_view_column_set_visible},
  {"get_visible",(nsp_method *) _wrap_gtk_tree_view_column_get_visible},
  {"set_resizable",(nsp_method *) _wrap_gtk_tree_view_column_set_resizable},
  {"get_resizable",(nsp_method *) _wrap_gtk_tree_view_column_get_resizable},
  {"set_sizing",(nsp_method *) _wrap_gtk_tree_view_column_set_sizing},
  {"get_sizing",(nsp_method *) _wrap_gtk_tree_view_column_get_sizing},
  {"get_x_offset",(nsp_method *) _wrap_gtk_tree_view_column_get_x_offset},
  {"get_width",(nsp_method *) _wrap_gtk_tree_view_column_get_width},
  {"get_fixed_width",(nsp_method *) _wrap_gtk_tree_view_column_get_fixed_width},
  {"set_fixed_width",(nsp_method *) _wrap_gtk_tree_view_column_set_fixed_width},
  {"set_min_width",(nsp_method *) _wrap_gtk_tree_view_column_set_min_width},
  {"get_min_width",(nsp_method *) _wrap_gtk_tree_view_column_get_min_width},
  {"set_max_width",(nsp_method *) _wrap_gtk_tree_view_column_set_max_width},
  {"get_max_width",(nsp_method *) _wrap_gtk_tree_view_column_get_max_width},
  {"clicked",(nsp_method *) _wrap_gtk_tree_view_column_clicked},
  {"set_title",(nsp_method *) _wrap_gtk_tree_view_column_set_title},
  {"get_title",(nsp_method *) _wrap_gtk_tree_view_column_get_title},
  {"set_expand",(nsp_method *) _wrap_gtk_tree_view_column_set_expand},
  {"get_expand",(nsp_method *) _wrap_gtk_tree_view_column_get_expand},
  {"set_clickable",(nsp_method *) _wrap_gtk_tree_view_column_set_clickable},
  {"get_clickable",(nsp_method *) _wrap_gtk_tree_view_column_get_clickable},
  {"set_widget",(nsp_method *) _wrap_gtk_tree_view_column_set_widget},
  {"get_widget",(nsp_method *) _wrap_gtk_tree_view_column_get_widget},
  {"set_alignment",(nsp_method *) _wrap_gtk_tree_view_column_set_alignment},
  {"get_alignment",(nsp_method *) _wrap_gtk_tree_view_column_get_alignment},
  {"set_reorderable",(nsp_method *) _wrap_gtk_tree_view_column_set_reorderable},
  {"get_reorderable",(nsp_method *) _wrap_gtk_tree_view_column_get_reorderable},
  {"set_sort_column_id",(nsp_method *) _wrap_gtk_tree_view_column_set_sort_column_id},
  {"get_sort_column_id",(nsp_method *) _wrap_gtk_tree_view_column_get_sort_column_id},
  {"set_sort_indicator",(nsp_method *) _wrap_gtk_tree_view_column_set_sort_indicator},
  {"get_sort_indicator",(nsp_method *) _wrap_gtk_tree_view_column_get_sort_indicator},
  {"set_sort_order",(nsp_method *) _wrap_gtk_tree_view_column_set_sort_order},
  {"get_sort_order",(nsp_method *) _wrap_gtk_tree_view_column_get_sort_order},
  {"cell_set_cell_data",(nsp_method *) _wrap_gtk_tree_view_column_cell_set_cell_data},
  {"cell_get_size",(nsp_method *) _wrap_gtk_tree_view_column_cell_get_size},
  {"cell_is_visible",(nsp_method *) _wrap_gtk_tree_view_column_cell_is_visible},
  {"focus_cell",(nsp_method *) _wrap_gtk_tree_view_column_focus_cell},
  {"cell_get_position",(nsp_method *) _wrap_gtk_tree_view_column_cell_get_position},
  {"queue_resize",(nsp_method *) _wrap_gtk_tree_view_column_queue_resize},
  {"get_tree_view",(nsp_method *) _wrap_gtk_tree_view_column_get_tree_view},
  {"get_button",(nsp_method *) _wrap_gtk_tree_view_column_get_button},
  { NULL, NULL}
};

static NspMethods *gtktreeviewcolumn_get_methods(void) { return gtktreeviewcolumn_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreeviewcolumn_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeView ----------- */


#define  NspGtkTreeView_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreeview.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeView inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtktreeview_id=0;
NspTypeGtkTreeView *nsp_type_gtktreeview=NULL;

/*
 * Type object for NspGtkTreeView 
 * all the instance of NspTypeGtkTreeView share the same id. 
 * nsp_type_gtktreeview: is an instance of NspTypeGtkTreeView 
 *    used for objects of NspGtkTreeView type (i.e built with new_gtktreeview) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeView *new_type_gtktreeview(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkTreeView *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreeview != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreeview;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreeview_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreeview_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreeview;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreeview */ 

  top->s_type =  (s_type_func *) nsp_gtktreeview_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreeview_type_short_string;
  /* top->create = (create_func*) int_gtktreeview_create;*/

  /* specific methods for gtktreeview */

  type->init = (init_func *) init_gtktreeview;

  /* 
   * NspGtkTreeView interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtktreeview_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeView called nsp_type_gtktreeview
       */
      type->id =  nsp_type_gtktreeview_id = nsp_new_type_id();
      nsp_type_gtktreeview = type;
      if ( nsp_register_type(nsp_type_gtktreeview) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreeview, GTK_TYPE_TREE_VIEW);
      return ( mode == T_BASE ) ? type : new_type_gtktreeview(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreeview_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeView instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreeview(NspGtkTreeView *Obj,NspTypeGtkTreeView *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeView 
 */

NspGtkTreeView *new_gtktreeview() 
{
  NspGtkTreeView *loc;
  /* type must exists */
  nsp_type_gtktreeview = new_type_gtktreeview(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeView)))== NULLGTKTREEVIEW) return loc;
  /* initialize object */
  if ( init_gtktreeview(loc,nsp_type_gtktreeview) == FAIL) return NULLGTKTREEVIEW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeView 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreeview_type_name[]="GtkTreeView";
static char gtktreeview_short_type_name[]="GtkTreeView";

static char *nsp_gtktreeview_type_as_string(void)
{
  return(gtktreeview_type_name);
}

static char *nsp_gtktreeview_type_short_string(NspObject *v)
{
  return(gtktreeview_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeView objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeView   *nsp_gtktreeview_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktreeview_id)  == TRUE  ) return ((NspGtkTreeView *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreeview));
  return NULL;
}

int IsGtkTreeViewObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktreeview_id);
}

int IsGtkTreeView(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreeview_id);
}

NspGtkTreeView  *GetGtkTreeViewCopy(Stack stack, int i)
{
  if (  GetGtkTreeView(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeView  *GetGtkTreeView(Stack stack, int i)
{
  NspGtkTreeView *M;
  if (( M = nsp_gtktreeview_object(NthObj(i))) == NULLGTKTREEVIEW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeView *gtktreeview_copy(NspGtkTreeView *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeview);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreeview);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeView
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_tree_view_new_with_model (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *model;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreemodel, &model) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_tree_view_new_with_model(GTK_TREE_MODEL(model->obj)))== NULL) return RET_BUG;

  nsp_type_gtktreeview = new_type_gtktreeview(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeview);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 2548 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_view_new(Stack stack, int rhs, int opt, int lhs)
{
  NspGObject *nsp_model = NULL;
  GtkTreeModel *model = NULL;
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,1);
  if (rhs == 1)
    {
      if (( nsp_model = (NspGObject *) GetGtkTreeModel(stack,1)) == NULL)
	return RET_BUG;
      model = GTK_TREE_MODEL(nsp_model->obj);
      ret = (GObject *)gtk_tree_view_new_with_model(model);
    }
  else
    {
      ret = (GObject *)gtk_tree_view_new();
    }
  if (ret == NULL)
    {
      Scierror( "Can't create GtkTreeView");
      return RET_BUG;
    }

  nsp_type_gtktreeview = new_type_gtktreeview(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtktreeview );
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 40161 "gtk.c"


#line 2580 "codegen-3.0/gtk.override"
/* I do not want gtk_tree_view_get_model to return a tree model
 * but a more specific object i.e a liststore or treestore
 */

static int _wrap_gtk_tree_view_get_model(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *ret;
  NspObject *nsp_ret;
  ret = gtk_tree_view_get_model(GTK_TREE_VIEW(self->obj));
  if ( ret == NULL)
    {
      if ((nsp_ret =(NspObject *) nsp_none_create(NVOID,NULL)) == NULLOBJ) return RET_BUG;
    }
  else
    {
      if ((nsp_ret =(NspObject *) nspgobject_new(NVOID,(GObject *) ret))==NULLOBJ) return RET_BUG;
    }
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 40185 "gtk.c"


static int _wrap_gtk_tree_view_set_model(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"model",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreeModel *model = NULL;
  NspGObject *nsp_model = NULL;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_model) == FAIL) return RET_BUG;
  if ( nsp_model != NULL ) {
    if ( IsGtkTreeModel((NspObject *)nsp_model))
      model = GTK_TREE_MODEL(nsp_model->obj);
    else if (! IsNone((NspObject *)nsp_model)) {
         Scierror( "Error: model should be a GtkTreeModel or None\n");
         return RET_BUG;
    }
  }
    gtk_tree_view_set_model(GTK_TREE_VIEW(self->obj),model);
  return 0;
}

static int _wrap_gtk_tree_view_get_selection(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeSelection *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_selection(GTK_TREE_VIEW(self->obj));
  nsp_type_gtktreeselection = new_type_gtktreeselection(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeselection))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_get_headers_visible(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_headers_visible(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_headers_visible(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int headers_visible;
  if ( GetArgs(stack,rhs,opt,T,&headers_visible) == FAIL) return RET_BUG;
    gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(self->obj),headers_visible);
  return 0;
}

static int _wrap_gtk_tree_view_columns_autosize(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_view_columns_autosize(GTK_TREE_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_get_headers_clickable(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_headers_clickable(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_headers_clickable(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_tree_view_set_headers_clickable(GTK_TREE_VIEW(self->obj),setting);
  return 0;
}

#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_tree_view_set_rules_hint(Stack stack, int rhs, int opt, int lhs) /* set_rules_hint */
{
  Scierror("Error: function gtk_tree_view_set_rules_hint is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_tree_view_set_rules_hint(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_tree_view_set_rules_hint(GTK_TREE_VIEW(self->obj),setting);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_tree_view_get_rules_hint(Stack stack, int rhs, int opt, int lhs) /* get_rules_hint */
{
  Scierror("Error: function gtk_tree_view_get_rules_hint is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_tree_view_get_rules_hint(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_rules_hint(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_tree_view_get_activate_on_single_click(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_activate_on_single_click(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_tree_view_get_activate_on_single_click(Stack stack, int rhs, int opt, int lhs) /* get_activate_on_single_click */
{
  Scierror("Error: function gtk_tree_view_get_activate_on_single_click not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_tree_view_set_activate_on_single_click(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int single;
  if ( GetArgs(stack,rhs,opt,T,&single) == FAIL) return RET_BUG;
    gtk_tree_view_set_activate_on_single_click(GTK_TREE_VIEW(self->obj),single);
  return 0;
}

#else
int _wrap_gtk_tree_view_set_activate_on_single_click(Stack stack, int rhs, int opt, int lhs) /* set_activate_on_single_click */
{
  Scierror("Error: function gtk_tree_view_set_activate_on_single_click not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_tree_view_append_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *column;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeviewcolumn, &column) == FAIL) return RET_BUG;
    ret =gtk_tree_view_append_column(GTK_TREE_VIEW(self->obj),GTK_TREE_VIEW_COLUMN(column->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_remove_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *column;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeviewcolumn, &column) == FAIL) return RET_BUG;
    ret =gtk_tree_view_remove_column(GTK_TREE_VIEW(self->obj),GTK_TREE_VIEW_COLUMN(column->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_insert_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *column;
  int position, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeviewcolumn, &column, &position) == FAIL) return RET_BUG;
    ret =gtk_tree_view_insert_column(GTK_TREE_VIEW(self->obj),GTK_TREE_VIEW_COLUMN(column->obj),position);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 2983 "codegen-3.0/gtk.override"
/* could it be merged with insert column ? XXXX  */
static int
_wrap_gtk_tree_view_insert_column_with_attributes(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = { s_int,string, obj_check, new_opts,t_end};
  nsp_option opts[] = {
    {"attrs",hash,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };

  gint position, columns, real_position;
  GtkTreeViewColumn *column;
  GtkCellRenderer *cell;
  NspObject *nsp_cell,*nsp_ret;
  NspHash *h;
  const char *title;

  if (GetArgs(stack,rhs,opt,T, &position, &title, &nsp_type_gtkcellrenderer,&nsp_cell,&opts,&h) == FAIL)
    return RET_BUG;

  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));

  columns =  gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW(self->obj),
							  position, title, cell,
							  NULL);
  if (position == -1) {
    real_position = columns - 1;
  } else {
    real_position = position;
  }

  column = gtk_tree_view_get_column (GTK_TREE_VIEW(self->obj),  real_position);

  if (h != NULL)
    {
      int i;
      for ( i =0 ; i < h->hsize ; i++)
	{
	  Hash_Entry *loc = ((Hash_Entry *) h->htable) + i;
	  if ( loc->used )
	    {
	      if ( IsMat(loc->data)
		   && (((NspMatrix *) loc->data)->mn == 1)
		   && (((NspMatrix *) loc->data)->rc_type == 'r' ))
		gtk_tree_view_column_add_attribute(column, cell,nsp_object_get_name(loc->data),
						   ((NspMatrix *) loc->data)->R[0]);
	      else
		{
		  Scierror("%s: attribute %s should be a real scalar\n",NspFname(stack),nsp_object_get_name(loc->data));
		  return RET_BUG;
		}
	    }
	}
    }
  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)column,(NspTypeBase *) nsp_type_gtktreeviewcolumn );
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 40425 "gtk.c"


#line 2869 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_view_insert_column_with_data_func (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int position;
  gchar *title;
  NspObject *nsp_cell,*nsp_func, *nsp_arg = NULL;
  GtkCellRenderer *cell;
  NspGtkCustomNotify *cunote;
  gint retval;

  int_types T4[] = {s_int,string,obj_check,obj_check, t_end} ;
  int_types T5[] = {s_int,string,obj_check,obj_check,obj_check,t_end} ;

  CheckRhs(4,5) ;
  if ( rhs == 4 )
    {
      if (GetArgs(stack,rhs,opt,T4, &position, &title,&nsp_type_gtkcellrenderer,&nsp_cell,&nsp_type_plist, &nsp_func)== FAIL)
	return RET_BUG;
    }
  else
    {
      if (GetArgs(stack,rhs,opt,T5, &position, &title,&nsp_type_gtkcellrenderer,&nsp_cell,&nsp_type_plist, &nsp_func,&nsp_type_list, &nsp_arg)== FAIL)
	return RET_BUG;
    }
  cell = GTK_CELL_RENDERER(nspgobject_get(nsp_cell));

  if (( nsp_func =nsp_object_copy(nsp_func)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"func")== FAIL)) return RET_BUG;
  if ( nsp_arg != NULL)
    {
      if (( nsp_arg =nsp_object_copy(nsp_arg)) == NULL) return RET_BUG;
      if ((nsp_object_set_name(nsp_arg,"arg")== FAIL)) return RET_BUG;
    }
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;

  retval = gtk_tree_view_insert_column_with_data_func (
						       GTK_TREE_VIEW (self->obj),
						       position,
						       title,
						       cell,
						       nspgtk_cell_data_func_marshal,
						       cunote,
						       nspgtk_custom_destroy_notify);
  if ( nsp_move_double(stack,1,(double)retval) == FAIL) return RET_BUG;
  return 1;
}
#line 40477 "gtk.c"


#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_tree_view_get_n_columns(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_n_columns(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_tree_view_get_n_columns(Stack stack, int rhs, int opt, int lhs) /* get_n_columns */
{
  Scierror("Error: function gtk_tree_view_get_n_columns not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_tree_view_get_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int n;
  GtkTreeViewColumn *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&n) == FAIL) return RET_BUG;
    ret =gtk_tree_view_get_column(GTK_TREE_VIEW(self->obj),n);
  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeviewcolumn))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 3169 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_view_get_columns(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  list = gtk_tree_view_get_columns(GTK_TREE_VIEW(self->obj));
  NSP_LIST_FROM_GLIST(list,nspgobject_new("lel",G_OBJECT(tmp->data)),g_list_free);
}


#line 40522 "gtk.c"


static int _wrap_gtk_tree_view_move_column_after(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *column, *base_column;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeviewcolumn, &column, &nsp_type_gtktreeviewcolumn, &base_column) == FAIL) return RET_BUG;
    gtk_tree_view_move_column_after(GTK_TREE_VIEW(self->obj),GTK_TREE_VIEW_COLUMN(column->obj),GTK_TREE_VIEW_COLUMN(base_column->obj));
  return 0;
}

static int _wrap_gtk_tree_view_set_expander_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *column;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreeviewcolumn, &column) == FAIL) return RET_BUG;
    gtk_tree_view_set_expander_column(GTK_TREE_VIEW(self->obj),GTK_TREE_VIEW_COLUMN(column->obj));
  return 0;
}

static int _wrap_gtk_tree_view_get_expander_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeViewColumn *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_expander_column(GTK_TREE_VIEW(self->obj));
  nsp_type_gtktreeviewcolumn = new_type_gtktreeviewcolumn(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreeviewcolumn))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_scroll_to_point(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int tree_x, tree_y;
  if ( GetArgs(stack,rhs,opt,T,&tree_x, &tree_y) == FAIL) return RET_BUG;
    gtk_tree_view_scroll_to_point(GTK_TREE_VIEW(self->obj),tree_x,tree_y);
  return 0;
}

static int _wrap_gtk_tree_view_scroll_to_cell(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,new_opts, t_end};
  nsp_option opts[] = {
	{"column",obj,NULLOBJ,-1},
	{"use_align",s_bool,NULLOBJ,-1},
	{"row_align",s_double,NULLOBJ,-1},
	{"col_align",s_double,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  GtkTreeViewColumn *column = NULL;
  NspGObject *nsp_column = NULL;
  int use_align = FALSE;
  double row_align = 0.0, col_align = 0.0;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, opts, &nsp_column, &use_align, &row_align, &col_align) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if ( nsp_column != NULL ) {
    if ( IsGtkTreeViewColumn((NspObject *)nsp_column))
      column = GTK_TREE_VIEW_COLUMN(nsp_column->obj);
    else if (! IsNone((NspObject *)nsp_column)) {
         Scierror( "Error: column should be a GtkTreeViewColumn or None\n");
         return RET_BUG;
    }
  }
    gtk_tree_view_scroll_to_cell(GTK_TREE_VIEW(self->obj),path,column,use_align,row_align,col_align);
  return 0;
}

static int _wrap_gtk_tree_view_row_activated(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  NspGObject *column;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_type_gtktreeviewcolumn, &column) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_tree_view_row_activated(GTK_TREE_VIEW(self->obj),path,GTK_TREE_VIEW_COLUMN(column->obj));
  return 0;
}

static int _wrap_gtk_tree_view_expand_all(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_view_expand_all(GTK_TREE_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_collapse_all(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_view_collapse_all(GTK_TREE_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_expand_to_path(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_tree_view_expand_to_path(GTK_TREE_VIEW(self->obj),path);
  return 0;
}

static int _wrap_gtk_tree_view_expand_row(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_bool, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  int open_all, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &open_all) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_view_expand_row(GTK_TREE_VIEW(self->obj),path,open_all);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_collapse_row(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_view_collapse_row(GTK_TREE_VIEW(self->obj),path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_row_expanded(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_view_row_expanded(GTK_TREE_VIEW(self->obj),path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_reorderable(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int reorderable;
  if ( GetArgs(stack,rhs,opt,T,&reorderable) == FAIL) return RET_BUG;
    gtk_tree_view_set_reorderable(GTK_TREE_VIEW(self->obj),reorderable);
  return 0;
}

static int _wrap_gtk_tree_view_get_reorderable(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_reorderable(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_cursor(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,new_opts, t_end};
  nsp_option opts[] = {
	{"focus_column",obj,NULLOBJ,-1},
	{"start_editing",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  GtkTreeViewColumn *focus_column = NULL;
  NspGObject *nsp_focus_column = NULL;
  int start_editing = FALSE;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, opts, &nsp_focus_column, &start_editing) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if ( nsp_focus_column != NULL ) {
    if ( IsGtkTreeViewColumn((NspObject *)nsp_focus_column))
      focus_column = GTK_TREE_VIEW_COLUMN(nsp_focus_column->obj);
    else if (! IsNone((NspObject *)nsp_focus_column)) {
         Scierror( "Error: focus_column should be a GtkTreeViewColumn or None\n");
         return RET_BUG;
    }
  }
    gtk_tree_view_set_cursor(GTK_TREE_VIEW(self->obj),path,focus_column,start_editing);
  return 0;
}

static int _wrap_gtk_tree_view_set_cursor_on_cell(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,new_opts, t_end};
  nsp_option opts[] = {
	{"focus_column",obj,NULLOBJ,-1},
	{"focus_cell",obj,NULLOBJ,-1},
	{"start_editing",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  GtkTreeViewColumn *focus_column = NULL;
  NspGObject *nsp_focus_column = NULL, *nsp_focus_cell = NULL;
  GtkCellRenderer *focus_cell = NULL;
  int start_editing = FALSE;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, opts, &nsp_focus_column, &nsp_focus_cell, &start_editing) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if ( nsp_focus_column != NULL ) {
    if ( IsGtkTreeViewColumn((NspObject *)nsp_focus_column))
      focus_column = GTK_TREE_VIEW_COLUMN(nsp_focus_column->obj);
    else if (! IsNone((NspObject *)nsp_focus_column)) {
         Scierror( "Error: focus_column should be a GtkTreeViewColumn or None\n");
         return RET_BUG;
    }
  }
  if ( nsp_focus_cell != NULL ) {
    if ( IsGtkCellRenderer((NspObject *)nsp_focus_cell))
      focus_cell = GTK_CELL_RENDERER(nsp_focus_cell->obj);
    else if (! IsNone((NspObject *)nsp_focus_cell)) {
         Scierror( "Error: focus_cell should be a GtkCellRenderer or None\n");
         return RET_BUG;
    }
  }
    gtk_tree_view_set_cursor_on_cell(GTK_TREE_VIEW(self->obj),path,focus_column,focus_cell,start_editing);
  return 0;
}

#line 3142 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_view_get_cursor(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list_begin,obj,obj,list_end, t_end} ;
  NspObject *nsp_path;
  NspObject *nsp_column=NULL;
  GtkTreePath *path;
  GtkTreeViewColumn *column;

  gtk_tree_view_get_cursor(GTK_TREE_VIEW(self->obj), &path, &column);

  if (path != NULL) {
    nsp_path = (NspObject *)nsp_gtk_tree_path_to_nspobject(path);
  } else {
    nsp_path = (NspObject *)nsp_none_create(NVOID,NULL);
  }

  if (column != NULL) {
    nsp_column =(NspObject *) nspgobject_new(NVOID,(GObject*)column);
  } else {
    nsp_path =(NspObject *) nsp_none_create(NVOID,NULL);
  }

  return RetArgs(stack,lhs,T,nsp_path,nsp_column);
}
#line 40815 "gtk.c"


static int _wrap_gtk_tree_view_get_bin_window(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_bin_window(GTK_TREE_VIEW(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 2954 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_view_get_path_at_pos(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end} ;
  int_types ret_T[] = {obj,obj,s_int,s_int, t_end} ;
  gint x, y;
  GtkTreePath *path;
  GtkTreeViewColumn *column;
  gint cell_x, cell_y;
  NspObject *nsp_path,*nsp_column;
  if (GetArgs(stack,rhs,opt,T, &x, &y) == FAIL) return RET_BUG;

  if (gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(self->obj), x, y,
				    &path, &column, &cell_x, &cell_y))
    {
      if (path != NULL)
	nsp_path = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH,path,TRUE,TRUE,
					       (NspTypeBase *) nsp_type_gtktreepath );
      else
	nsp_path =(NspObject *) nsp_none_create(NVOID,NULL);
      if ( nsp_path == NULL) return RET_BUG;
      if ((nsp_column =(NspObject *) nspgobject_new(NVOID,(GObject *)column)) == NULL) return RET_BUG;
      return RetArgs(stack,lhs,ret_T, nsp_path,nsp_column,cell_x,cell_y);
    }
  Scierror("%s: failed to get path\n",NspFname(stack));
  return RET_BUG ;
}
#line 40858 "gtk.c"


#line 3059 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_view_get_cell_area(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end} ;
  /* static char *kwlist[] = { "path", "column", NULL };*/
  NspObject *nsp_path, *ret;
  NspGObject *column;
  GdkRectangle rect;
  GtkTreePath *path;

  if (GetArgs(stack,rhs,opt,T, &nsp_path, &nsp_type_gtktreeviewcolumn, &column) == FAIL) return RET_BUG;

  path = nsp_gtk_tree_path_from_nspobject(nsp_path);
  if (!path) {
    Scierror( "could not convert path to a GtkTreePath");
    return RET_BUG;
  }
  gtk_tree_view_get_cell_area(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj), &rect);
  if (path)
    gtk_tree_path_free(path);
    if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle))
	== NULL)
     return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 40888 "gtk.c"


#line 3087 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_view_get_background_area(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end} ;
  /* static char *kwlist[] = { "path", "column", NULL };*/
  NspObject *nsp_path, *ret;
  NspGObject *column;
  GdkRectangle rect;
  GtkTreePath *path;

  if (GetArgs(stack,rhs,opt,T, &nsp_path, &nsp_type_gtktreeviewcolumn, &column)== FAIL) return RET_BUG;

  path = nsp_gtk_tree_path_from_nspobject(nsp_path);
  if (!path) {
    Scierror( "could not convert path to a GtkTreePath");
    return RET_BUG;
  }
  gtk_tree_view_get_background_area(GTK_TREE_VIEW(self->obj), path, GTK_TREE_VIEW_COLUMN(column->obj), &rect);
  if (path)
    gtk_tree_path_free(path);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL)
     return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 40917 "gtk.c"


#line 3044 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_view_get_visible_rect(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkRectangle visible_rect;
  NspObject *ret;
  CheckRhs(1,1);
  gtk_tree_view_get_visible_rect(GTK_TREE_VIEW(self->obj), &visible_rect);

  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &visible_rect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle))
      == NULL)  return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 40934 "gtk.c"


#line 3181 "codegen-3.0/gtk.override"

/* similar to gtk_drag_source_set */

static GtkTargetEntry * nsp_gtk_target_entry_from_list(Stack stack,NspList *list,int *n_targets) ;

static int
_wrap_gtk_tree_view_enable_model_drag_source(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,list,obj, t_end} ;
  NspList  *nsp_targets;
  NspObject *nsp_sbmask, *nsp_actions;
  GdkModifierType sbmask;
  GtkTargetEntry *targets;
  GdkDragAction actions;
  gint n_targets;

  if (GetArgs(stack,rhs,opt,T,&nsp_sbmask, &nsp_targets, &nsp_actions) == FAIL) return RET_BUG;;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,  nsp_sbmask,&sbmask))
    return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION,  nsp_actions, &actions))
    return RET_BUG;

  targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets);
  if ( targets ==NULL && n_targets != 0)
    {
      Scierror("Error: failed to build target entries\n");
      return RET_BUG;
    }
  gtk_tree_view_enable_model_drag_source(GTK_TREE_VIEW(self->obj), sbmask, targets, n_targets, actions);
  g_free(targets);
  return 0;
}

#line 40971 "gtk.c"


#line 3216 "codegen-3.0/gtk.override"

static int
_wrap_gtk_tree_view_enable_model_drag_dest(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list,obj, t_end} ;
  NspObject *nsp_actions;
  NspList *nsp_targets;
  GtkTargetEntry *targets;
  GdkDragAction actions;
  gint n_targets;

  if (GetArgs(stack,rhs,opt,T,  &nsp_targets, &nsp_actions)   == FAIL) return RET_BUG;;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION, nsp_actions, &actions))
    return RET_BUG;

  targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets);
  if ( targets ==NULL && n_targets != 0)
    {
      Scierror("Error: failed to build target entries\n");
      return RET_BUG;
    }
  gtk_tree_view_enable_model_drag_dest(GTK_TREE_VIEW(self->obj), targets, n_targets,  actions);
  g_free(targets);
  return 0;
}

#line 41001 "gtk.c"


static int _wrap_gtk_tree_view_unset_rows_drag_source(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_view_unset_rows_drag_source(GTK_TREE_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_unset_rows_drag_dest(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_view_unset_rows_drag_dest(GTK_TREE_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_tree_view_set_drag_dest_row(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_pos = NULL;
  GtkTreeViewDropPosition pos;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_pos) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_TREE_VIEW_DROP_POSITION, nsp_pos, &pos)== FAIL)
      return RET_BUG;
    gtk_tree_view_set_drag_dest_row(GTK_TREE_VIEW(self->obj),path,pos);
  return 0;
}

static int _wrap_gtk_tree_view_create_row_drag_icon(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_ret;
  cairo_surface_t *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_view_create_row_drag_icon(GTK_TREE_VIEW(self->obj),path);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,CAIRO_GOBJECT_TYPE_SURFACE, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_cairo_surface_t))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_set_enable_search(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int enable_search;
  if ( GetArgs(stack,rhs,opt,T,&enable_search) == FAIL) return RET_BUG;
    gtk_tree_view_set_enable_search(GTK_TREE_VIEW(self->obj),enable_search);
  return 0;
}

static int _wrap_gtk_tree_view_get_enable_search(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_enable_search(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_get_search_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_search_column(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_search_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int column;
  if ( GetArgs(stack,rhs,opt,T,&column) == FAIL) return RET_BUG;
    gtk_tree_view_set_search_column(GTK_TREE_VIEW(self->obj),column);
  return 0;
}

static int _wrap_gtk_tree_view_get_search_entry(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkEntry *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_search_entry(GTK_TREE_VIEW(self->obj));
  nsp_type_gtkentry = new_type_gtkentry(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkentry))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_view_set_search_entry(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *entry;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkentry, &entry) == FAIL) return RET_BUG;
    gtk_tree_view_set_search_entry(GTK_TREE_VIEW(self->obj),GTK_ENTRY(entry->obj));
  return 0;
}

static int _wrap_gtk_tree_view_convert_widget_to_tree_coords(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int,s_int, t_end};
  int wx, wy, tx, ty;
  if ( GetArgs(stack,rhs,opt,T,&wx, &wy, &tx, &ty) == FAIL) return RET_BUG;
    gtk_tree_view_convert_widget_to_tree_coords(GTK_TREE_VIEW(self->obj),wx,wy,&tx,&ty);
  return 0;
}

static int _wrap_gtk_tree_view_convert_tree_to_widget_coords(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int,s_int, t_end};
  int tx, ty, wx, wy;
  if ( GetArgs(stack,rhs,opt,T,&tx, &ty, &wx, &wy) == FAIL) return RET_BUG;
    gtk_tree_view_convert_tree_to_widget_coords(GTK_TREE_VIEW(self->obj),tx,ty,&wx,&wy);
  return 0;
}

static int _wrap_gtk_tree_view_convert_widget_to_bin_window_coords(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int,s_int, t_end};
  int wx, wy, bx, by;
  if ( GetArgs(stack,rhs,opt,T,&wx, &wy, &bx, &by) == FAIL) return RET_BUG;
    gtk_tree_view_convert_widget_to_bin_window_coords(GTK_TREE_VIEW(self->obj),wx,wy,&bx,&by);
  return 0;
}

static int _wrap_gtk_tree_view_convert_bin_window_to_widget_coords(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int,s_int, t_end};
  int bx, by, wx, wy;
  if ( GetArgs(stack,rhs,opt,T,&bx, &by, &wx, &wy) == FAIL) return RET_BUG;
    gtk_tree_view_convert_bin_window_to_widget_coords(GTK_TREE_VIEW(self->obj),bx,by,&wx,&wy);
  return 0;
}

static int _wrap_gtk_tree_view_convert_tree_to_bin_window_coords(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int,s_int, t_end};
  int tx, ty, bx, by;
  if ( GetArgs(stack,rhs,opt,T,&tx, &ty, &bx, &by) == FAIL) return RET_BUG;
    gtk_tree_view_convert_tree_to_bin_window_coords(GTK_TREE_VIEW(self->obj),tx,ty,&bx,&by);
  return 0;
}

static int _wrap_gtk_tree_view_convert_bin_window_to_tree_coords(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int,s_int, t_end};
  int bx, by, tx, ty;
  if ( GetArgs(stack,rhs,opt,T,&bx, &by, &tx, &ty) == FAIL) return RET_BUG;
    gtk_tree_view_convert_bin_window_to_tree_coords(GTK_TREE_VIEW(self->obj),bx,by,&tx,&ty);
  return 0;
}

static int _wrap_gtk_tree_view_set_fixed_height_mode(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int enable;
  if ( GetArgs(stack,rhs,opt,T,&enable) == FAIL) return RET_BUG;
    gtk_tree_view_set_fixed_height_mode(GTK_TREE_VIEW(self->obj),enable);
  return 0;
}

static int _wrap_gtk_tree_view_get_fixed_height_mode(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_fixed_height_mode(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_hover_selection(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int hover;
  if ( GetArgs(stack,rhs,opt,T,&hover) == FAIL) return RET_BUG;
    gtk_tree_view_set_hover_selection(GTK_TREE_VIEW(self->obj),hover);
  return 0;
}

static int _wrap_gtk_tree_view_get_hover_selection(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_hover_selection(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_hover_expand(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int expand;
  if ( GetArgs(stack,rhs,opt,T,&expand) == FAIL) return RET_BUG;
    gtk_tree_view_set_hover_expand(GTK_TREE_VIEW(self->obj),expand);
  return 0;
}

static int _wrap_gtk_tree_view_get_hover_expand(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_hover_expand(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_rubber_banding(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int enable;
  if ( GetArgs(stack,rhs,opt,T,&enable) == FAIL) return RET_BUG;
    gtk_tree_view_set_rubber_banding(GTK_TREE_VIEW(self->obj),enable);
  return 0;
}

static int _wrap_gtk_tree_view_get_rubber_banding(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_rubber_banding(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_is_rubber_banding_active(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_is_rubber_banding_active(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_get_grid_lines(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_grid_lines(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_grid_lines(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeViewGridLines grid_lines;
  NspObject *nsp_grid_lines = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_grid_lines) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TREE_VIEW_GRID_LINES, nsp_grid_lines, &grid_lines)== FAIL)
      return RET_BUG;
    gtk_tree_view_set_grid_lines(GTK_TREE_VIEW(self->obj),grid_lines);
  return 0;
}

static int _wrap_gtk_tree_view_get_enable_tree_lines(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_enable_tree_lines(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_enable_tree_lines(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int enabled;
  if ( GetArgs(stack,rhs,opt,T,&enabled) == FAIL) return RET_BUG;
    gtk_tree_view_set_enable_tree_lines(GTK_TREE_VIEW(self->obj),enabled);
  return 0;
}

static int _wrap_gtk_tree_view_set_show_expanders(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int enabled;
  if ( GetArgs(stack,rhs,opt,T,&enabled) == FAIL) return RET_BUG;
    gtk_tree_view_set_show_expanders(GTK_TREE_VIEW(self->obj),enabled);
  return 0;
}

static int _wrap_gtk_tree_view_get_show_expanders(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_show_expanders(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_level_indentation(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int indentation;
  if ( GetArgs(stack,rhs,opt,T,&indentation) == FAIL) return RET_BUG;
    gtk_tree_view_set_level_indentation(GTK_TREE_VIEW(self->obj),indentation);
  return 0;
}

static int _wrap_gtk_tree_view_get_level_indentation(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_level_indentation(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_view_set_tooltip_row(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *tooltip;
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktooltip, &tooltip, &nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_tree_view_set_tooltip_row(GTK_TREE_VIEW(self->obj),GTK_TOOLTIP(tooltip->obj),path);
  return 0;
}

static int _wrap_gtk_tree_view_set_tooltip_cell(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,obj_check,obj_check, t_end};
  NspGObject *tooltip, *column, *cell;
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktooltip, &tooltip, &nsp_path, &nsp_type_gtktreeviewcolumn, &column, &nsp_type_gtkcellrenderer, &cell) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_tree_view_set_tooltip_cell(GTK_TREE_VIEW(self->obj),GTK_TOOLTIP(tooltip->obj),path,GTK_TREE_VIEW_COLUMN(column->obj),GTK_CELL_RENDERER(cell->obj));
  return 0;
}

#line 3244 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_view_get_tooltip_context (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *g_model;
  GtkTreePath *path = gtk_tree_path_new();
  GtkTreeIter iter;
  NspGObject *model;
  gint x,y;
  gboolean keyboard_tip;
  gboolean ok;
  int_types T[] = {s_int,s_int,s_bool,obj_check, t_end} ;
  if (GetArgs(stack,rhs,opt,T, &x,&y,&keyboard_tip,&nsp_type_gtktreemodel, &model)   == FAIL) 
    return RET_BUG;;
  g_model= GTK_TREE_MODEL(model->obj);
  ok = gtk_tree_view_get_tooltip_context(GTK_TREE_VIEW(self->obj),&x,&y,keyboard_tip,&g_model,&path,&iter);
  if ( nsp_move_boolean(stack,1,ok)==FAIL) return RET_BUG;
  if ( lhs >= 2)
    {
      if ( nsp_move_double(stack,2,(double)x ) == FAIL) return RET_BUG;
    }
  if ( lhs >= 3)
    {
      if ( nsp_move_double(stack,3,(double) y ) == FAIL) return RET_BUG;
    }
  if ( lhs >= 4)
    {
      NspObject *nsp_ret;
      if (( nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL) 
	return RET_BUG;
      MoveObj(stack,4,nsp_ret);
    }
  if ( lhs >= 5)
    {
      NspObject *nsp_ret;
      nsp_type_gtktreepath = new_type_gtktreepath(T_BASE);
      /* no need to copy path here */
      nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH,path,FALSE,TRUE,(NspTypeBase *) nsp_type_gtktreepath );
      if ( nsp_ret == NULL) return RET_BUG;
      MoveObj(stack,5,nsp_ret);
    }
  else
    {
      gtk_tree_path_free(path);
    }
  return Max(lhs,1);
}

#line 41407 "gtk.c"


static int _wrap_gtk_tree_view_set_tooltip_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int column;
  if ( GetArgs(stack,rhs,opt,T,&column) == FAIL) return RET_BUG;
    gtk_tree_view_set_tooltip_column(GTK_TREE_VIEW(self->obj),column);
  return 0;
}

static int _wrap_gtk_tree_view_get_tooltip_column(NspGtkTreeView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tree_view_get_tooltip_column(GTK_TREE_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktreeview_methods[] = {
  {"get_model",(nsp_method *) _wrap_gtk_tree_view_get_model},
  {"set_model",(nsp_method *) _wrap_gtk_tree_view_set_model},
  {"get_selection",(nsp_method *) _wrap_gtk_tree_view_get_selection},
  {"get_headers_visible",(nsp_method *) _wrap_gtk_tree_view_get_headers_visible},
  {"set_headers_visible",(nsp_method *) _wrap_gtk_tree_view_set_headers_visible},
  {"columns_autosize",(nsp_method *) _wrap_gtk_tree_view_columns_autosize},
  {"get_headers_clickable",(nsp_method *) _wrap_gtk_tree_view_get_headers_clickable},
  {"set_headers_clickable",(nsp_method *) _wrap_gtk_tree_view_set_headers_clickable},
  {"set_rules_hint",(nsp_method *) _wrap_gtk_tree_view_set_rules_hint},
  {"get_rules_hint",(nsp_method *) _wrap_gtk_tree_view_get_rules_hint},
  {"get_activate_on_single_click",(nsp_method *) _wrap_gtk_tree_view_get_activate_on_single_click},
  {"set_activate_on_single_click",(nsp_method *) _wrap_gtk_tree_view_set_activate_on_single_click},
  {"append_column",(nsp_method *) _wrap_gtk_tree_view_append_column},
  {"remove_column",(nsp_method *) _wrap_gtk_tree_view_remove_column},
  {"insert_column",(nsp_method *) _wrap_gtk_tree_view_insert_column},
  {"insert_column_with_attributes",(nsp_method *) _wrap_gtk_tree_view_insert_column_with_attributes},
  {"insert_column_with_data_func",(nsp_method *) _wrap_gtk_tree_view_insert_column_with_data_func},
  {"get_n_columns",(nsp_method *) _wrap_gtk_tree_view_get_n_columns},
  {"get_column",(nsp_method *) _wrap_gtk_tree_view_get_column},
  {"get_columns",(nsp_method *) _wrap_gtk_tree_view_get_columns},
  {"move_column_after",(nsp_method *) _wrap_gtk_tree_view_move_column_after},
  {"set_expander_column",(nsp_method *) _wrap_gtk_tree_view_set_expander_column},
  {"get_expander_column",(nsp_method *) _wrap_gtk_tree_view_get_expander_column},
  {"scroll_to_point",(nsp_method *) _wrap_gtk_tree_view_scroll_to_point},
  {"scroll_to_cell",(nsp_method *) _wrap_gtk_tree_view_scroll_to_cell},
  {"row_activated",(nsp_method *) _wrap_gtk_tree_view_row_activated},
  {"expand_all",(nsp_method *) _wrap_gtk_tree_view_expand_all},
  {"collapse_all",(nsp_method *) _wrap_gtk_tree_view_collapse_all},
  {"expand_to_path",(nsp_method *) _wrap_gtk_tree_view_expand_to_path},
  {"expand_row",(nsp_method *) _wrap_gtk_tree_view_expand_row},
  {"collapse_row",(nsp_method *) _wrap_gtk_tree_view_collapse_row},
  {"row_expanded",(nsp_method *) _wrap_gtk_tree_view_row_expanded},
  {"set_reorderable",(nsp_method *) _wrap_gtk_tree_view_set_reorderable},
  {"get_reorderable",(nsp_method *) _wrap_gtk_tree_view_get_reorderable},
  {"set_cursor",(nsp_method *) _wrap_gtk_tree_view_set_cursor},
  {"set_cursor_on_cell",(nsp_method *) _wrap_gtk_tree_view_set_cursor_on_cell},
  {"get_cursor",(nsp_method *) _wrap_gtk_tree_view_get_cursor},
  {"get_bin_window",(nsp_method *) _wrap_gtk_tree_view_get_bin_window},
  {"get_path_at_pos",(nsp_method *) _wrap_gtk_tree_view_get_path_at_pos},
  {"get_cell_area",(nsp_method *) _wrap_gtk_tree_view_get_cell_area},
  {"get_background_area",(nsp_method *) _wrap_gtk_tree_view_get_background_area},
  {"get_visible_rect",(nsp_method *) _wrap_gtk_tree_view_get_visible_rect},
  {"enable_model_drag_source",(nsp_method *) _wrap_gtk_tree_view_enable_model_drag_source},
  {"enable_model_drag_dest",(nsp_method *) _wrap_gtk_tree_view_enable_model_drag_dest},
  {"unset_rows_drag_source",(nsp_method *) _wrap_gtk_tree_view_unset_rows_drag_source},
  {"unset_rows_drag_dest",(nsp_method *) _wrap_gtk_tree_view_unset_rows_drag_dest},
  {"set_drag_dest_row",(nsp_method *) _wrap_gtk_tree_view_set_drag_dest_row},
  {"create_row_drag_icon",(nsp_method *) _wrap_gtk_tree_view_create_row_drag_icon},
  {"set_enable_search",(nsp_method *) _wrap_gtk_tree_view_set_enable_search},
  {"get_enable_search",(nsp_method *) _wrap_gtk_tree_view_get_enable_search},
  {"get_search_column",(nsp_method *) _wrap_gtk_tree_view_get_search_column},
  {"set_search_column",(nsp_method *) _wrap_gtk_tree_view_set_search_column},
  {"get_search_entry",(nsp_method *) _wrap_gtk_tree_view_get_search_entry},
  {"set_search_entry",(nsp_method *) _wrap_gtk_tree_view_set_search_entry},
  {"convert_widget_to_tree_coords",(nsp_method *) _wrap_gtk_tree_view_convert_widget_to_tree_coords},
  {"convert_tree_to_widget_coords",(nsp_method *) _wrap_gtk_tree_view_convert_tree_to_widget_coords},
  {"convert_widget_to_bin_window_coords",(nsp_method *) _wrap_gtk_tree_view_convert_widget_to_bin_window_coords},
  {"convert_bin_window_to_widget_coords",(nsp_method *) _wrap_gtk_tree_view_convert_bin_window_to_widget_coords},
  {"convert_tree_to_bin_window_coords",(nsp_method *) _wrap_gtk_tree_view_convert_tree_to_bin_window_coords},
  {"convert_bin_window_to_tree_coords",(nsp_method *) _wrap_gtk_tree_view_convert_bin_window_to_tree_coords},
  {"set_fixed_height_mode",(nsp_method *) _wrap_gtk_tree_view_set_fixed_height_mode},
  {"get_fixed_height_mode",(nsp_method *) _wrap_gtk_tree_view_get_fixed_height_mode},
  {"set_hover_selection",(nsp_method *) _wrap_gtk_tree_view_set_hover_selection},
  {"get_hover_selection",(nsp_method *) _wrap_gtk_tree_view_get_hover_selection},
  {"set_hover_expand",(nsp_method *) _wrap_gtk_tree_view_set_hover_expand},
  {"get_hover_expand",(nsp_method *) _wrap_gtk_tree_view_get_hover_expand},
  {"set_rubber_banding",(nsp_method *) _wrap_gtk_tree_view_set_rubber_banding},
  {"get_rubber_banding",(nsp_method *) _wrap_gtk_tree_view_get_rubber_banding},
  {"is_rubber_banding_active",(nsp_method *) _wrap_gtk_tree_view_is_rubber_banding_active},
  {"get_grid_lines",(nsp_method *) _wrap_gtk_tree_view_get_grid_lines},
  {"set_grid_lines",(nsp_method *) _wrap_gtk_tree_view_set_grid_lines},
  {"get_enable_tree_lines",(nsp_method *) _wrap_gtk_tree_view_get_enable_tree_lines},
  {"set_enable_tree_lines",(nsp_method *) _wrap_gtk_tree_view_set_enable_tree_lines},
  {"set_show_expanders",(nsp_method *) _wrap_gtk_tree_view_set_show_expanders},
  {"get_show_expanders",(nsp_method *) _wrap_gtk_tree_view_get_show_expanders},
  {"set_level_indentation",(nsp_method *) _wrap_gtk_tree_view_set_level_indentation},
  {"get_level_indentation",(nsp_method *) _wrap_gtk_tree_view_get_level_indentation},
  {"set_tooltip_row",(nsp_method *) _wrap_gtk_tree_view_set_tooltip_row},
  {"set_tooltip_cell",(nsp_method *) _wrap_gtk_tree_view_set_tooltip_cell},
  {"get_tooltip_context",(nsp_method *) _wrap_gtk_tree_view_get_tooltip_context},
  {"set_tooltip_column",(nsp_method *) _wrap_gtk_tree_view_set_tooltip_column},
  {"get_tooltip_column",(nsp_method *) _wrap_gtk_tree_view_get_tooltip_column},
  { NULL, NULL}
};

static NspMethods *gtktreeview_get_methods(void) { return gtktreeview_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreeview_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellView ----------- */


#define  NspGtkCellView_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellview.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellView inherits from GtkWidget 
 * and implements GtkCellLayout GtkBuildable
 */

int nsp_type_gtkcellview_id=0;
NspTypeGtkCellView *nsp_type_gtkcellview=NULL;

/*
 * Type object for NspGtkCellView 
 * all the instance of NspTypeGtkCellView share the same id. 
 * nsp_type_gtkcellview: is an instance of NspTypeGtkCellView 
 *    used for objects of NspGtkCellView type (i.e built with new_gtkcellview) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellView *new_type_gtkcellview(type_mode mode)
{
  NspTypeGtkCellLayout *t_gtkcelllayout;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkCellView *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellview != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellview;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellview_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellview_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellview;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellview */ 

  top->s_type =  (s_type_func *) nsp_gtkcellview_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellview_type_short_string;
  /* top->create = (create_func*) int_gtkcellview_create;*/

  /* specific methods for gtkcellview */

  type->init = (init_func *) init_gtkcellview;

  /* 
   * NspGtkCellView interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkcelllayout = new_type_gtkcelllayout(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkcelllayout;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkcellview_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellView called nsp_type_gtkcellview
       */
      type->id =  nsp_type_gtkcellview_id = nsp_new_type_id();
      nsp_type_gtkcellview = type;
      if ( nsp_register_type(nsp_type_gtkcellview) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellview, GTK_TYPE_CELL_VIEW);
      return ( mode == T_BASE ) ? type : new_type_gtkcellview(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellview_id;
      return type;
    }
}

/*
 * initialize NspGtkCellView instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellview(NspGtkCellView *Obj,NspTypeGtkCellView *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellView 
 */

NspGtkCellView *new_gtkcellview() 
{
  NspGtkCellView *loc;
  /* type must exists */
  nsp_type_gtkcellview = new_type_gtkcellview(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellView)))== NULLGTKCELLVIEW) return loc;
  /* initialize object */
  if ( init_gtkcellview(loc,nsp_type_gtkcellview) == FAIL) return NULLGTKCELLVIEW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellView 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellview_type_name[]="GtkCellView";
static char gtkcellview_short_type_name[]="GtkCellView";

static char *nsp_gtkcellview_type_as_string(void)
{
  return(gtkcellview_type_name);
}

static char *nsp_gtkcellview_type_short_string(NspObject *v)
{
  return(gtkcellview_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellView objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellView   *nsp_gtkcellview_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellview_id)  == TRUE  ) return ((NspGtkCellView *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellview));
  return NULL;
}

int IsGtkCellViewObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellview_id);
}

int IsGtkCellView(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellview_id);
}

NspGtkCellView  *GetGtkCellViewCopy(Stack stack, int i)
{
  if (  GetGtkCellView(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellView  *GetGtkCellView(Stack stack, int i)
{
  NspGtkCellView *M;
  if (( M = nsp_gtkcellview_object(NthObj(i))) == NULLGTKCELLVIEW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellView *gtkcellview_copy(NspGtkCellView *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellview);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellview);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellView
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_cell_view_new_with_context (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *area, *context;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellarea, &area, &nsp_type_gtkcellareacontext, &context) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_cell_view_new_with_context(GTK_CELL_AREA(area->obj),GTK_CELL_AREA_CONTEXT(context->obj)))== NULL) return RET_BUG;

  nsp_type_gtkcellview = new_type_gtkcellview(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellview);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 7299 "codegen-3.0/gtk.override"

/* merging gtk_cell_view_new
 * gtkcomboboxentry_new(text=)
 * gtkcomboboxentry_new(model=,text_column=)
 * if both text and column are given text is ignored
 */

static int
_wrap_gtk_cell_view_new(Stack stack, int rhs, int opt, int lhs)
{
  char *Text=NULL,*Markup=NULL;
  NspGObject *pixbuf = NULL;
  GObject *ret; NspObject *nsp_ret;
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
    {"text",string,NULLOBJ,-1},
    {"markup",string,NULLOBJ,-1},
    {"pixbuf",obj_check,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };
  if ( GetArgs(stack,rhs,opt,T,opts,&Text,&Markup,&nsp_type_gdkpixbuf,&pixbuf) == FAIL)
    return RET_BUG;
  if ( Text != NULL)
    {
      if ((ret =(GObject *) gtk_cell_view_new_with_text(Text))== NULL) return RET_BUG;
    }
  else if ( Markup != NULL)
    {
      if ((ret =(GObject *) gtk_cell_view_new_with_markup(Markup))== NULL) return RET_BUG;
    }
  else if ( pixbuf != NULL)
    {
      if ((ret =(GObject *) gtk_cell_view_new_with_pixbuf(GDK_PIXBUF(pixbuf->obj)))== NULL) return RET_BUG;
    }
  else
    {
      if ((ret = (GObject *)gtk_cell_view_new())== NULL) return RET_BUG;
    }
  nsp_type_gtkcellview = new_type_gtkcellview(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcellview );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 41781 "gtk.c"


static int _wrap_gtk_cell_view_set_model(NspGtkCellView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"model",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreeModel *model = NULL;
  NspGObject *nsp_model = NULL;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_model) == FAIL) return RET_BUG;
  if ( nsp_model != NULL ) {
    if ( IsGtkTreeModel((NspObject *)nsp_model))
      model = GTK_TREE_MODEL(nsp_model->obj);
    else if (! IsNone((NspObject *)nsp_model)) {
         Scierror( "Error: model should be a GtkTreeModel or None\n");
         return RET_BUG;
    }
  }
    gtk_cell_view_set_model(GTK_CELL_VIEW(self->obj),model);
  return 0;
}

static int _wrap_gtk_cell_view_get_model(NspGtkCellView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_cell_view_get_model(GTK_CELL_VIEW(self->obj));
  nsp_type_gtktreemodel = new_type_gtktreemodel(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreemodel))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_view_set_displayed_row(NspGtkCellView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"path",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_path) == FAIL) return RET_BUG;
  if ( nsp_path != NULL ) {
    if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
    else if (! IsNone(nsp_path)) {
      Scierror("Error: path should be a GtkTreePath or None\n");
      return RET_BUG;
    }
  }
    gtk_cell_view_set_displayed_row(GTK_CELL_VIEW(self->obj),path);
  return 0;
}

static int _wrap_gtk_cell_view_get_displayed_row(NspGtkCellView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreePath *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_cell_view_get_displayed_row(GTK_CELL_VIEW(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreepath))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_view_set_background_rgba(NspGtkCellView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkRGBA *rgba = NULL;
  NspObject *nsp_rgba = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_rgba) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_rgba, GDK_TYPE_RGBA))
      rgba = nspg_boxed_get(nsp_rgba, GdkRGBA);
  else {
      Scierror( "Error: rgba should be a GdkRGBA\n");
      return RET_BUG;
  }
    gtk_cell_view_set_background_rgba(GTK_CELL_VIEW(self->obj),rgba);
  return 0;
}

static int _wrap_gtk_cell_view_get_draw_sensitive(NspGtkCellView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_cell_view_get_draw_sensitive(GTK_CELL_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_view_set_draw_sensitive(NspGtkCellView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int draw_sensitive;
  if ( GetArgs(stack,rhs,opt,T,&draw_sensitive) == FAIL) return RET_BUG;
    gtk_cell_view_set_draw_sensitive(GTK_CELL_VIEW(self->obj),draw_sensitive);
  return 0;
}

static int _wrap_gtk_cell_view_get_fit_model(NspGtkCellView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_cell_view_get_fit_model(GTK_CELL_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_view_set_fit_model(NspGtkCellView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int fit_model;
  if ( GetArgs(stack,rhs,opt,T,&fit_model) == FAIL) return RET_BUG;
    gtk_cell_view_set_fit_model(GTK_CELL_VIEW(self->obj),fit_model);
  return 0;
}

static NspMethods gtkcellview_methods[] = {
  {"set_model",(nsp_method *) _wrap_gtk_cell_view_set_model},
  {"get_model",(nsp_method *) _wrap_gtk_cell_view_get_model},
  {"set_displayed_row",(nsp_method *) _wrap_gtk_cell_view_set_displayed_row},
  {"get_displayed_row",(nsp_method *) _wrap_gtk_cell_view_get_displayed_row},
  {"set_background_rgba",(nsp_method *) _wrap_gtk_cell_view_set_background_rgba},
  {"get_draw_sensitive",(nsp_method *) _wrap_gtk_cell_view_get_draw_sensitive},
  {"set_draw_sensitive",(nsp_method *) _wrap_gtk_cell_view_set_draw_sensitive},
  {"get_fit_model",(nsp_method *) _wrap_gtk_cell_view_get_fit_model},
  {"set_fit_model",(nsp_method *) _wrap_gtk_cell_view_set_fit_model},
  { NULL, NULL}
};

static NspMethods *gtkcellview_get_methods(void) { return gtkcellview_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellview_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkIconView ----------- */


#define  NspGtkIconView_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkiconview.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkIconView inherits from GtkContainer 
 * and implements GtkCellLayout GtkBuildable
 */

int nsp_type_gtkiconview_id=0;
NspTypeGtkIconView *nsp_type_gtkiconview=NULL;

/*
 * Type object for NspGtkIconView 
 * all the instance of NspTypeGtkIconView share the same id. 
 * nsp_type_gtkiconview: is an instance of NspTypeGtkIconView 
 *    used for objects of NspGtkIconView type (i.e built with new_gtkiconview) 
 * other instances are used for derived classes 
 */
NspTypeGtkIconView *new_type_gtkiconview(type_mode mode)
{
  NspTypeGtkCellLayout *t_gtkcelllayout;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkIconView *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkiconview != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkiconview;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkiconview_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkiconview_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkiconview;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkiconview */ 

  top->s_type =  (s_type_func *) nsp_gtkiconview_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkiconview_type_short_string;
  /* top->create = (create_func*) int_gtkiconview_create;*/

  /* specific methods for gtkiconview */

  type->init = (init_func *) init_gtkiconview;

  /* 
   * NspGtkIconView interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkcelllayout = new_type_gtkcelllayout(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkcelllayout;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkiconview_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIconView called nsp_type_gtkiconview
       */
      type->id =  nsp_type_gtkiconview_id = nsp_new_type_id();
      nsp_type_gtkiconview = type;
      if ( nsp_register_type(nsp_type_gtkiconview) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkiconview, GTK_TYPE_ICON_VIEW);
      return ( mode == T_BASE ) ? type : new_type_gtkiconview(mode);
    }
  else 
    {
      type->id = nsp_type_gtkiconview_id;
      return type;
    }
}

/*
 * initialize NspGtkIconView instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkiconview(NspGtkIconView *Obj,NspTypeGtkIconView *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkIconView 
 */

NspGtkIconView *new_gtkiconview() 
{
  NspGtkIconView *loc;
  /* type must exists */
  nsp_type_gtkiconview = new_type_gtkiconview(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIconView)))== NULLGTKICONVIEW) return loc;
  /* initialize object */
  if ( init_gtkiconview(loc,nsp_type_gtkiconview) == FAIL) return NULLGTKICONVIEW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkIconView 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkiconview_type_name[]="GtkIconView";
static char gtkiconview_short_type_name[]="GtkIconView";

static char *nsp_gtkiconview_type_as_string(void)
{
  return(gtkiconview_type_name);
}

static char *nsp_gtkiconview_type_short_string(NspObject *v)
{
  return(gtkiconview_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkIconView objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkIconView   *nsp_gtkiconview_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkiconview_id)  == TRUE  ) return ((NspGtkIconView *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkiconview));
  return NULL;
}

int IsGtkIconViewObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkiconview_id);
}

int IsGtkIconView(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkiconview_id);
}

NspGtkIconView  *GetGtkIconViewCopy(Stack stack, int i)
{
  if (  GetGtkIconView(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIconView  *GetGtkIconView(Stack stack, int i)
{
  NspGtkIconView *M;
  if (( M = nsp_gtkiconview_object(NthObj(i))) == NULLGTKICONVIEW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkIconView *gtkiconview_copy(NspGtkIconView *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkiconview);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkiconview);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIconView
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_icon_view_new_with_model (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *model;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreemodel, &model) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_icon_view_new_with_model(GTK_TREE_MODEL(model->obj)))== NULL) return RET_BUG;

  nsp_type_gtkiconview = new_type_gtkiconview(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkiconview);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_icon_view_new_with_area (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *area;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellarea, &area) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_icon_view_new_with_area(GTK_CELL_AREA(area->obj)))== NULL) return RET_BUG;

  nsp_type_gtkiconview = new_type_gtkiconview(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkiconview);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_icon_view_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_icon_view_new())== NULL) return RET_BUG;

  nsp_type_gtkiconview = new_type_gtkiconview(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkiconview);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_icon_view_set_model(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"model",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreeModel *model = NULL;
  NspGObject *nsp_model = NULL;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_model) == FAIL) return RET_BUG;
  if ( nsp_model != NULL ) {
    if ( IsGtkTreeModel((NspObject *)nsp_model))
      model = GTK_TREE_MODEL(nsp_model->obj);
    else if (! IsNone((NspObject *)nsp_model)) {
         Scierror( "Error: model should be a GtkTreeModel or None\n");
         return RET_BUG;
    }
  }
    gtk_icon_view_set_model(GTK_ICON_VIEW(self->obj),model);
  return 0;
}

#line 2602 "codegen-3.0/gtk.override"
/* I do not want gtk_icon_view_get_model to return a tree model
 * but a more specific object i.e a liststore or treestore
 */
/* XXXX: all the other get_model should be corrected that way */
static int _wrap_gtk_icon_view_get_model(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *ret;
  NspObject *nsp_ret;
  ret = gtk_icon_view_get_model(GTK_ICON_VIEW(self->obj));
  if ( ret == NULL)
    {
      if ((nsp_ret =(NspObject *) nsp_none_create(NVOID,NULL)) == NULLOBJ) return RET_BUG;
    }
  else
    {
      if ((nsp_ret =(NspObject *) nspgobject_new(NVOID,(GObject *) ret))==NULLOBJ) return RET_BUG;
    }
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 42210 "gtk.c"


static int _wrap_gtk_icon_view_set_text_column(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int column;
  if ( GetArgs(stack,rhs,opt,T,&column) == FAIL) return RET_BUG;
    gtk_icon_view_set_text_column(GTK_ICON_VIEW(self->obj),column);
  return 0;
}

static int _wrap_gtk_icon_view_get_text_column(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_text_column(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_set_markup_column(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int column;
  if ( GetArgs(stack,rhs,opt,T,&column) == FAIL) return RET_BUG;
    gtk_icon_view_set_markup_column(GTK_ICON_VIEW(self->obj),column);
  return 0;
}

static int _wrap_gtk_icon_view_get_markup_column(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_markup_column(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_set_pixbuf_column(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int column;
  if ( GetArgs(stack,rhs,opt,T,&column) == FAIL) return RET_BUG;
    gtk_icon_view_set_pixbuf_column(GTK_ICON_VIEW(self->obj),column);
  return 0;
}

static int _wrap_gtk_icon_view_get_pixbuf_column(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_pixbuf_column(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_set_item_orientation(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
    gtk_icon_view_set_item_orientation(GTK_ICON_VIEW(self->obj),orientation);
  return 0;
}

static int _wrap_gtk_icon_view_get_item_orientation(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_item_orientation(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_set_columns(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int columns;
  if ( GetArgs(stack,rhs,opt,T,&columns) == FAIL) return RET_BUG;
    gtk_icon_view_set_columns(GTK_ICON_VIEW(self->obj),columns);
  return 0;
}

static int _wrap_gtk_icon_view_get_columns(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_columns(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_set_item_width(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int item_width;
  if ( GetArgs(stack,rhs,opt,T,&item_width) == FAIL) return RET_BUG;
    gtk_icon_view_set_item_width(GTK_ICON_VIEW(self->obj),item_width);
  return 0;
}

static int _wrap_gtk_icon_view_get_item_width(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_item_width(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_set_spacing(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int spacing;
  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
    gtk_icon_view_set_spacing(GTK_ICON_VIEW(self->obj),spacing);
  return 0;
}

static int _wrap_gtk_icon_view_get_spacing(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_spacing(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_set_row_spacing(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int row_spacing;
  if ( GetArgs(stack,rhs,opt,T,&row_spacing) == FAIL) return RET_BUG;
    gtk_icon_view_set_row_spacing(GTK_ICON_VIEW(self->obj),row_spacing);
  return 0;
}

static int _wrap_gtk_icon_view_get_row_spacing(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_row_spacing(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_set_column_spacing(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int column_spacing;
  if ( GetArgs(stack,rhs,opt,T,&column_spacing) == FAIL) return RET_BUG;
    gtk_icon_view_set_column_spacing(GTK_ICON_VIEW(self->obj),column_spacing);
  return 0;
}

static int _wrap_gtk_icon_view_get_column_spacing(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_column_spacing(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_set_margin(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int margin;
  if ( GetArgs(stack,rhs,opt,T,&margin) == FAIL) return RET_BUG;
    gtk_icon_view_set_margin(GTK_ICON_VIEW(self->obj),margin);
  return 0;
}

static int _wrap_gtk_icon_view_get_margin(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_margin(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_set_item_padding(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int item_padding;
  if ( GetArgs(stack,rhs,opt,T,&item_padding) == FAIL) return RET_BUG;
    gtk_icon_view_set_item_padding(GTK_ICON_VIEW(self->obj),item_padding);
  return 0;
}

static int _wrap_gtk_icon_view_get_item_padding(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_item_padding(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_get_path_at_pos(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int x, y;
  GtkTreePath *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&x, &y) == FAIL) return RET_BUG;
    ret =gtk_icon_view_get_path_at_pos(GTK_ICON_VIEW(self->obj),x,y);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreepath))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_icon_view_set_activate_on_single_click(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int single;
  if ( GetArgs(stack,rhs,opt,T,&single) == FAIL) return RET_BUG;
    gtk_icon_view_set_activate_on_single_click(GTK_ICON_VIEW(self->obj),single);
  return 0;
}

#else
int _wrap_gtk_icon_view_set_activate_on_single_click(Stack stack, int rhs, int opt, int lhs) /* set_activate_on_single_click */
{
  Scierror("Error: function gtk_icon_view_set_activate_on_single_click not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_icon_view_get_activate_on_single_click(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_activate_on_single_click(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_icon_view_get_activate_on_single_click(Stack stack, int rhs, int opt, int lhs) /* get_activate_on_single_click */
{
  Scierror("Error: function gtk_icon_view_get_activate_on_single_click not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_icon_view_set_selection_mode(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSelectionMode mode;
  NspObject *nsp_mode = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SELECTION_MODE, nsp_mode, &mode)== FAIL)
      return RET_BUG;
    gtk_icon_view_set_selection_mode(GTK_ICON_VIEW(self->obj),mode);
  return 0;
}

static int _wrap_gtk_icon_view_get_selection_mode(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_selection_mode(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_select_path(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_icon_view_select_path(GTK_ICON_VIEW(self->obj),path);
  return 0;
}

static int _wrap_gtk_icon_view_unselect_path(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_icon_view_unselect_path(GTK_ICON_VIEW(self->obj),path);
  return 0;
}

static int _wrap_gtk_icon_view_path_is_selected(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_icon_view_path_is_selected(GTK_ICON_VIEW(self->obj),path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_get_item_row(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_icon_view_get_item_row(GTK_ICON_VIEW(self->obj),path);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_get_item_column(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_icon_view_get_item_column(GTK_ICON_VIEW(self->obj),path);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 2624 "codegen-3.0/gtk.override"
/* take care that here the glist contain boxed not gobjects */
static int _wrap_gtk_icon_view_get_selected_items(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  NspList *nsp_list;
  GList *ret, *tmp;
  ret = gtk_icon_view_get_selected_items(GTK_ICON_VIEW(self->obj));
  NSP_LIST_FROM_GLIST(ret,((NspObject *)gboxed_create("lel",GTK_TYPE_TREE_PATH,tmp->data,TRUE, TRUE, (NspTypeBase *) nsp_type_gtktreepath)),g_list_free);
}

#line 42580 "gtk.c"


static int _wrap_gtk_icon_view_select_all(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_icon_view_select_all(GTK_ICON_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_icon_view_unselect_all(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_icon_view_unselect_all(GTK_ICON_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_icon_view_item_activated(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_icon_view_item_activated(GTK_ICON_VIEW(self->obj),path);
  return 0;
}

static int _wrap_gtk_icon_view_set_cursor(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,new_opts, t_end};
  nsp_option opts[] = {
	{"cell",obj,NULLOBJ,-1},
	{"start_editing",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  GtkCellRenderer *cell = NULL;
  NspGObject *nsp_cell = NULL;
  int start_editing = FALSE;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, opts, &nsp_cell, &start_editing) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if ( nsp_cell != NULL ) {
    if ( IsGtkCellRenderer((NspObject *)nsp_cell))
      cell = GTK_CELL_RENDERER(nsp_cell->obj);
    else if (! IsNone((NspObject *)nsp_cell)) {
         Scierror( "Error: cell should be a GtkCellRenderer or None\n");
         return RET_BUG;
    }
  }
    gtk_icon_view_set_cursor(GTK_ICON_VIEW(self->obj),path,cell,start_editing);
  return 0;
}

static int _wrap_gtk_icon_view_scroll_to_path(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_bool,s_double,s_double, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  int use_align;
  double row_align, col_align;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &use_align, &row_align, &col_align) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_icon_view_scroll_to_path(GTK_ICON_VIEW(self->obj),path,use_align,row_align,col_align);
  return 0;
}

#line 2635 "codegen-3.0/gtk.override"

/* similar to gtk_drag_source_set */

static GtkTargetEntry * nsp_gtk_target_entry_from_list(Stack stack,NspList *list,int *n_targets) ;

static int
_wrap_gtk_icon_view_enable_model_drag_source(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,list,obj, t_end} ;
  NspList  *nsp_targets;
  NspObject *nsp_sbmask, *nsp_actions;
  GdkModifierType sbmask;
  GtkTargetEntry *targets;
  GdkDragAction actions;
  gint n_targets;

  if (GetArgs(stack,rhs,opt,T,&nsp_sbmask, &nsp_targets, &nsp_actions) == FAIL) return RET_BUG;;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,  nsp_sbmask,&sbmask))
    return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION,  nsp_actions, &actions))
    return RET_BUG;

  targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets);
  if ( targets ==NULL && n_targets != 0)
    {
      Scierror("Error: failed to build target entries\n");
      return RET_BUG;
    }
  gtk_icon_view_enable_model_drag_source(GTK_ICON_VIEW(self->obj), sbmask, targets, n_targets, actions);
  g_free(targets);
  return 0;
}

#line 42696 "gtk.c"


#line 2670 "codegen-3.0/gtk.override"

static int
_wrap_gtk_icon_view_enable_model_drag_dest(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list,obj, t_end} ;
  NspObject *nsp_actions;
  NspList *nsp_targets;
  GtkTargetEntry *targets;
  GdkDragAction actions;
  gint n_targets;

  if (GetArgs(stack,rhs,opt,T,  &nsp_targets, &nsp_actions)   == FAIL) return RET_BUG;;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION, nsp_actions, &actions))
    return RET_BUG;

  targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets);
  if ( targets ==NULL && n_targets != 0)
    {
      Scierror("Error: failed to build target entries\n");
      return RET_BUG;
    }

  gtk_icon_view_enable_model_drag_dest(GTK_ICON_VIEW(self->obj), targets, n_targets,  actions);
  g_free(targets);
  return 0;
}

#line 42727 "gtk.c"


static int _wrap_gtk_icon_view_unset_model_drag_source(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_icon_view_unset_model_drag_source(GTK_ICON_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_icon_view_unset_model_drag_dest(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_icon_view_unset_model_drag_dest(GTK_ICON_VIEW(self->obj));
  return 0;
}

static int _wrap_gtk_icon_view_set_reorderable(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int reorderable;
  if ( GetArgs(stack,rhs,opt,T,&reorderable) == FAIL) return RET_BUG;
    gtk_icon_view_set_reorderable(GTK_ICON_VIEW(self->obj),reorderable);
  return 0;
}

static int _wrap_gtk_icon_view_get_reorderable(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_reorderable(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_view_set_drag_dest_item(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"path",obj,NULLOBJ,-1},
	{"pos",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_pos = NULL;
  GtkIconViewDropPosition pos;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_path, &nsp_pos) == FAIL) return RET_BUG;
  if ( nsp_path != NULL ) {
    if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
    else if (! IsNone(nsp_path)) {
      Scierror("Error: path should be a GtkTreePath or None\n");
      return RET_BUG;
    }
  }
  if (nspg_enum_get_value(GTK_TYPE_ICON_VIEW_DROP_POSITION, nsp_pos, &pos)== FAIL)
      return RET_BUG;
    gtk_icon_view_set_drag_dest_item(GTK_ICON_VIEW(self->obj),path,pos);
  return 0;
}

static int _wrap_gtk_icon_view_create_drag_icon(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_ret;
  cairo_surface_t *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_icon_view_create_drag_icon(GTK_ICON_VIEW(self->obj),path);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,CAIRO_GOBJECT_TYPE_SURFACE, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_cairo_surface_t))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_icon_view_convert_widget_to_bin_window_coords(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int,s_int, t_end};
  int wx, wy, bx, by;
  if ( GetArgs(stack,rhs,opt,T,&wx, &wy, &bx, &by) == FAIL) return RET_BUG;
    gtk_icon_view_convert_widget_to_bin_window_coords(GTK_ICON_VIEW(self->obj),wx,wy,&bx,&by);
  return 0;
}

#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_icon_view_get_cell_rect(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check,obj, t_end};
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_rect;
  NspGObject *cell;
  GdkRectangle rect = { 0, 0, 0, 0 };
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_path, &nsp_type_gtkcellrenderer, &cell, &nsp_rect) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (!nsp_gdk_rectangle_from_object(nsp_rect, &rect))
      return RET_BUG;
    ret =gtk_icon_view_get_cell_rect(GTK_ICON_VIEW(self->obj),path,GTK_CELL_RENDERER(cell->obj),&rect);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_icon_view_get_cell_rect(Stack stack, int rhs, int opt, int lhs) /* get_cell_rect */
{
  Scierror("Error: function gtk_icon_view_get_cell_rect not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_icon_view_set_tooltip_item(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *tooltip;
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktooltip, &tooltip, &nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_icon_view_set_tooltip_item(GTK_ICON_VIEW(self->obj),GTK_TOOLTIP(tooltip->obj),path);
  return 0;
}

static int _wrap_gtk_icon_view_set_tooltip_cell(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,obj_check, t_end};
  NspGObject *tooltip, *cell;
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktooltip, &tooltip, &nsp_path, &nsp_type_gtkcellrenderer, &cell) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_icon_view_set_tooltip_cell(GTK_ICON_VIEW(self->obj),GTK_TOOLTIP(tooltip->obj),path,GTK_CELL_RENDERER(cell->obj));
  return 0;
}

static int _wrap_gtk_icon_view_set_tooltip_column(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int column;
  if ( GetArgs(stack,rhs,opt,T,&column) == FAIL) return RET_BUG;
    gtk_icon_view_set_tooltip_column(GTK_ICON_VIEW(self->obj),column);
  return 0;
}

static int _wrap_gtk_icon_view_get_tooltip_column(NspGtkIconView *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_view_get_tooltip_column(GTK_ICON_VIEW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkiconview_methods[] = {
  {"set_model",(nsp_method *) _wrap_gtk_icon_view_set_model},
  {"get_model",(nsp_method *) _wrap_gtk_icon_view_get_model},
  {"set_text_column",(nsp_method *) _wrap_gtk_icon_view_set_text_column},
  {"get_text_column",(nsp_method *) _wrap_gtk_icon_view_get_text_column},
  {"set_markup_column",(nsp_method *) _wrap_gtk_icon_view_set_markup_column},
  {"get_markup_column",(nsp_method *) _wrap_gtk_icon_view_get_markup_column},
  {"set_pixbuf_column",(nsp_method *) _wrap_gtk_icon_view_set_pixbuf_column},
  {"get_pixbuf_column",(nsp_method *) _wrap_gtk_icon_view_get_pixbuf_column},
  {"set_item_orientation",(nsp_method *) _wrap_gtk_icon_view_set_item_orientation},
  {"get_item_orientation",(nsp_method *) _wrap_gtk_icon_view_get_item_orientation},
  {"set_columns",(nsp_method *) _wrap_gtk_icon_view_set_columns},
  {"get_columns",(nsp_method *) _wrap_gtk_icon_view_get_columns},
  {"set_item_width",(nsp_method *) _wrap_gtk_icon_view_set_item_width},
  {"get_item_width",(nsp_method *) _wrap_gtk_icon_view_get_item_width},
  {"set_spacing",(nsp_method *) _wrap_gtk_icon_view_set_spacing},
  {"get_spacing",(nsp_method *) _wrap_gtk_icon_view_get_spacing},
  {"set_row_spacing",(nsp_method *) _wrap_gtk_icon_view_set_row_spacing},
  {"get_row_spacing",(nsp_method *) _wrap_gtk_icon_view_get_row_spacing},
  {"set_column_spacing",(nsp_method *) _wrap_gtk_icon_view_set_column_spacing},
  {"get_column_spacing",(nsp_method *) _wrap_gtk_icon_view_get_column_spacing},
  {"set_margin",(nsp_method *) _wrap_gtk_icon_view_set_margin},
  {"get_margin",(nsp_method *) _wrap_gtk_icon_view_get_margin},
  {"set_item_padding",(nsp_method *) _wrap_gtk_icon_view_set_item_padding},
  {"get_item_padding",(nsp_method *) _wrap_gtk_icon_view_get_item_padding},
  {"get_path_at_pos",(nsp_method *) _wrap_gtk_icon_view_get_path_at_pos},
  {"set_activate_on_single_click",(nsp_method *) _wrap_gtk_icon_view_set_activate_on_single_click},
  {"get_activate_on_single_click",(nsp_method *) _wrap_gtk_icon_view_get_activate_on_single_click},
  {"set_selection_mode",(nsp_method *) _wrap_gtk_icon_view_set_selection_mode},
  {"get_selection_mode",(nsp_method *) _wrap_gtk_icon_view_get_selection_mode},
  {"select_path",(nsp_method *) _wrap_gtk_icon_view_select_path},
  {"unselect_path",(nsp_method *) _wrap_gtk_icon_view_unselect_path},
  {"path_is_selected",(nsp_method *) _wrap_gtk_icon_view_path_is_selected},
  {"get_item_row",(nsp_method *) _wrap_gtk_icon_view_get_item_row},
  {"get_item_column",(nsp_method *) _wrap_gtk_icon_view_get_item_column},
  {"get_selected_items",(nsp_method *) _wrap_gtk_icon_view_get_selected_items},
  {"select_all",(nsp_method *) _wrap_gtk_icon_view_select_all},
  {"unselect_all",(nsp_method *) _wrap_gtk_icon_view_unselect_all},
  {"item_activated",(nsp_method *) _wrap_gtk_icon_view_item_activated},
  {"set_cursor",(nsp_method *) _wrap_gtk_icon_view_set_cursor},
  {"scroll_to_path",(nsp_method *) _wrap_gtk_icon_view_scroll_to_path},
  {"enable_model_drag_source",(nsp_method *) _wrap_gtk_icon_view_enable_model_drag_source},
  {"enable_model_drag_dest",(nsp_method *) _wrap_gtk_icon_view_enable_model_drag_dest},
  {"unset_model_drag_source",(nsp_method *) _wrap_gtk_icon_view_unset_model_drag_source},
  {"unset_model_drag_dest",(nsp_method *) _wrap_gtk_icon_view_unset_model_drag_dest},
  {"set_reorderable",(nsp_method *) _wrap_gtk_icon_view_set_reorderable},
  {"get_reorderable",(nsp_method *) _wrap_gtk_icon_view_get_reorderable},
  {"set_drag_dest_item",(nsp_method *) _wrap_gtk_icon_view_set_drag_dest_item},
  {"create_drag_icon",(nsp_method *) _wrap_gtk_icon_view_create_drag_icon},
  {"convert_widget_to_bin_window_coords",(nsp_method *) _wrap_gtk_icon_view_convert_widget_to_bin_window_coords},
  {"get_cell_rect",(nsp_method *) _wrap_gtk_icon_view_get_cell_rect},
  {"set_tooltip_item",(nsp_method *) _wrap_gtk_icon_view_set_tooltip_item},
  {"set_tooltip_cell",(nsp_method *) _wrap_gtk_icon_view_set_tooltip_cell},
  {"set_tooltip_column",(nsp_method *) _wrap_gtk_icon_view_set_tooltip_column},
  {"get_tooltip_column",(nsp_method *) _wrap_gtk_icon_view_get_tooltip_column},
  { NULL, NULL}
};

static NspMethods *gtkiconview_get_methods(void) { return gtkiconview_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkiconview_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeModelSort ----------- */


#define  NspGtkTreeModelSort_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreemodelsort.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeModelSort inherits from GObject 
 * and implements GtkTreeModel GtkTreeSortable
 */

int nsp_type_gtktreemodelsort_id=0;
NspTypeGtkTreeModelSort *nsp_type_gtktreemodelsort=NULL;

/*
 * Type object for NspGtkTreeModelSort 
 * all the instance of NspTypeGtkTreeModelSort share the same id. 
 * nsp_type_gtktreemodelsort: is an instance of NspTypeGtkTreeModelSort 
 *    used for objects of NspGtkTreeModelSort type (i.e built with new_gtktreemodelsort) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeModelSort *new_type_gtktreemodelsort(type_mode mode)
{
  NspTypeGtkTreeModel *t_gtktreemodel;
  NspTypeGtkTreeSortable *t_gtktreesortable;
  NspTypeGtkTreeModelSort *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreemodelsort != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreemodelsort;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreemodelsort_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreemodelsort_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreemodelsort;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreemodelsort */ 

  top->s_type =  (s_type_func *) nsp_gtktreemodelsort_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreemodelsort_type_short_string;
  /* top->create = (create_func*) int_gtktreemodelsort_create;*/

  /* specific methods for gtktreemodelsort */

  type->init = (init_func *) init_gtktreemodelsort;

  /* 
   * NspGtkTreeModelSort interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtktreemodel = new_type_gtktreemodel(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtktreemodel;
  t_gtktreesortable = new_type_gtktreesortable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtktreesortable;
  if ( nsp_type_gtktreemodelsort_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeModelSort called nsp_type_gtktreemodelsort
       */
      type->id =  nsp_type_gtktreemodelsort_id = nsp_new_type_id();
      nsp_type_gtktreemodelsort = type;
      if ( nsp_register_type(nsp_type_gtktreemodelsort) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreemodelsort, GTK_TYPE_TREE_MODEL_SORT);
      return ( mode == T_BASE ) ? type : new_type_gtktreemodelsort(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreemodelsort_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeModelSort instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreemodelsort(NspGtkTreeModelSort *Obj,NspTypeGtkTreeModelSort *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeModelSort 
 */

NspGtkTreeModelSort *new_gtktreemodelsort() 
{
  NspGtkTreeModelSort *loc;
  /* type must exists */
  nsp_type_gtktreemodelsort = new_type_gtktreemodelsort(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeModelSort)))== NULLGTKTREEMODELSORT) return loc;
  /* initialize object */
  if ( init_gtktreemodelsort(loc,nsp_type_gtktreemodelsort) == FAIL) return NULLGTKTREEMODELSORT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeModelSort 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreemodelsort_type_name[]="GtkTreeModelSort";
static char gtktreemodelsort_short_type_name[]="GtkTreeModelSort";

static char *nsp_gtktreemodelsort_type_as_string(void)
{
  return(gtktreemodelsort_type_name);
}

static char *nsp_gtktreemodelsort_type_short_string(NspObject *v)
{
  return(gtktreemodelsort_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeModelSort objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeModelSort   *nsp_gtktreemodelsort_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktreemodelsort_id)  == TRUE  ) return ((NspGtkTreeModelSort *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreemodelsort));
  return NULL;
}

int IsGtkTreeModelSortObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktreemodelsort_id);
}

int IsGtkTreeModelSort(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreemodelsort_id);
}

NspGtkTreeModelSort  *GetGtkTreeModelSortCopy(Stack stack, int i)
{
  if (  GetGtkTreeModelSort(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeModelSort  *GetGtkTreeModelSort(Stack stack, int i)
{
  NspGtkTreeModelSort *M;
  if (( M = nsp_gtktreemodelsort_object(NthObj(i))) == NULLGTKTREEMODELSORT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeModelSort *gtktreemodelsort_copy(NspGtkTreeModelSort *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreemodelsort);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreemodelsort);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeModelSort
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_tree_model_sort_new_with_model (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child_model;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreemodel, &child_model) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_tree_model_sort_new_with_model(GTK_TREE_MODEL(child_model->obj)))== NULL) return RET_BUG;

  nsp_type_gtktreemodelsort = new_type_gtktreemodelsort(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreemodelsort);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_sort_get_model(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tree_model_sort_get_model(GTK_TREE_MODEL_SORT(self->obj));
  nsp_type_gtktreemodel = new_type_gtktreemodel(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreemodel))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_sort_convert_child_path_to_path(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *child_path = NULL, *ret;
  NspObject *nsp_child_path = NULL, *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_child_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_child_path, GTK_TYPE_TREE_PATH))
      child_path = nspg_boxed_get(nsp_child_path, GtkTreePath);
  else {
      Scierror( "Error: child_path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_model_sort_convert_child_path_to_path(GTK_TREE_MODEL_SORT(self->obj),child_path);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreepath))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_sort_convert_child_iter_to_iter(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreeIter *sort_iter = NULL, *child_iter = NULL;
  NspObject *nsp_sort_iter = NULL, *nsp_child_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_sort_iter, &nsp_child_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_sort_iter, GTK_TYPE_TREE_ITER))
      sort_iter = nspg_boxed_get(nsp_sort_iter, GtkTreeIter);
  else {
      Scierror( "Error: sort_iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_child_iter, GTK_TYPE_TREE_ITER))
      child_iter = nspg_boxed_get(nsp_child_iter, GtkTreeIter);
  else {
      Scierror( "Error: child_iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_model_sort_convert_child_iter_to_iter(GTK_TREE_MODEL_SORT(self->obj),sort_iter,child_iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_model_sort_convert_path_to_child_path(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *sorted_path = NULL, *ret;
  NspObject *nsp_sorted_path = NULL, *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_sorted_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_sorted_path, GTK_TYPE_TREE_PATH))
      sorted_path = nspg_boxed_get(nsp_sorted_path, GtkTreePath);
  else {
      Scierror( "Error: sorted_path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_model_sort_convert_path_to_child_path(GTK_TREE_MODEL_SORT(self->obj),sorted_path);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreepath))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_sort_convert_iter_to_child_iter(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreeIter *child_iter = NULL, *sorted_iter = NULL;
  NspObject *nsp_child_iter = NULL, *nsp_sorted_iter = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_child_iter, &nsp_sorted_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_child_iter, GTK_TYPE_TREE_ITER))
      child_iter = nspg_boxed_get(nsp_child_iter, GtkTreeIter);
  else {
      Scierror( "Error: child_iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_sorted_iter, GTK_TYPE_TREE_ITER))
      sorted_iter = nspg_boxed_get(nsp_sorted_iter, GtkTreeIter);
  else {
      Scierror( "Error: sorted_iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_model_sort_convert_iter_to_child_iter(GTK_TREE_MODEL_SORT(self->obj),child_iter,sorted_iter);
  return 0;
}

static int _wrap_gtk_tree_model_sort_reset_default_sort_func(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_model_sort_reset_default_sort_func(GTK_TREE_MODEL_SORT(self->obj));
  return 0;
}

static int _wrap_gtk_tree_model_sort_clear_cache(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_model_sort_clear_cache(GTK_TREE_MODEL_SORT(self->obj));
  return 0;
}

static int _wrap_gtk_tree_model_sort_iter_is_valid(NspGtkTreeModelSort *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_model_sort_iter_is_valid(GTK_TREE_MODEL_SORT(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktreemodelsort_methods[] = {
  {"get_model",(nsp_method *) _wrap_gtk_tree_model_sort_get_model},
  {"convert_child_path_to_path",(nsp_method *) _wrap_gtk_tree_model_sort_convert_child_path_to_path},
  {"convert_child_iter_to_iter",(nsp_method *) _wrap_gtk_tree_model_sort_convert_child_iter_to_iter},
  {"convert_path_to_child_path",(nsp_method *) _wrap_gtk_tree_model_sort_convert_path_to_child_path},
  {"convert_iter_to_child_iter",(nsp_method *) _wrap_gtk_tree_model_sort_convert_iter_to_child_iter},
  {"reset_default_sort_func",(nsp_method *) _wrap_gtk_tree_model_sort_reset_default_sort_func},
  {"clear_cache",(nsp_method *) _wrap_gtk_tree_model_sort_clear_cache},
  {"iter_is_valid",(nsp_method *) _wrap_gtk_tree_model_sort_iter_is_valid},
  { NULL, NULL}
};

static NspMethods *gtktreemodelsort_get_methods(void) { return gtktreemodelsort_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreemodelsort_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeModelFilter ----------- */


#define  NspGtkTreeModelFilter_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreemodelfilter.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeModelFilter inherits from GObject 
 * and implements GtkTreeModel GtkTreeDragSource
 */

int nsp_type_gtktreemodelfilter_id=0;
NspTypeGtkTreeModelFilter *nsp_type_gtktreemodelfilter=NULL;

/*
 * Type object for NspGtkTreeModelFilter 
 * all the instance of NspTypeGtkTreeModelFilter share the same id. 
 * nsp_type_gtktreemodelfilter: is an instance of NspTypeGtkTreeModelFilter 
 *    used for objects of NspGtkTreeModelFilter type (i.e built with new_gtktreemodelfilter) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeModelFilter *new_type_gtktreemodelfilter(type_mode mode)
{
  NspTypeGtkTreeModel *t_gtktreemodel;
  NspTypeGtkTreeDragSource *t_gtktreedragsource;
  NspTypeGtkTreeModelFilter *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreemodelfilter != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreemodelfilter;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreemodelfilter_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreemodelfilter_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreemodelfilter;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreemodelfilter */ 

  top->s_type =  (s_type_func *) nsp_gtktreemodelfilter_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreemodelfilter_type_short_string;
  /* top->create = (create_func*) int_gtktreemodelfilter_create;*/

  /* specific methods for gtktreemodelfilter */

  type->init = (init_func *) init_gtktreemodelfilter;

  /* 
   * NspGtkTreeModelFilter interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtktreemodel = new_type_gtktreemodel(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtktreemodel;
  t_gtktreedragsource = new_type_gtktreedragsource(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtktreedragsource;
  if ( nsp_type_gtktreemodelfilter_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeModelFilter called nsp_type_gtktreemodelfilter
       */
      type->id =  nsp_type_gtktreemodelfilter_id = nsp_new_type_id();
      nsp_type_gtktreemodelfilter = type;
      if ( nsp_register_type(nsp_type_gtktreemodelfilter) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreemodelfilter, GTK_TYPE_TREE_MODEL_FILTER);
      return ( mode == T_BASE ) ? type : new_type_gtktreemodelfilter(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreemodelfilter_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeModelFilter instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreemodelfilter(NspGtkTreeModelFilter *Obj,NspTypeGtkTreeModelFilter *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeModelFilter 
 */

NspGtkTreeModelFilter *new_gtktreemodelfilter() 
{
  NspGtkTreeModelFilter *loc;
  /* type must exists */
  nsp_type_gtktreemodelfilter = new_type_gtktreemodelfilter(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeModelFilter)))== NULLGTKTREEMODELFILTER) return loc;
  /* initialize object */
  if ( init_gtktreemodelfilter(loc,nsp_type_gtktreemodelfilter) == FAIL) return NULLGTKTREEMODELFILTER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeModelFilter 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreemodelfilter_type_name[]="GtkTreeModelFilter";
static char gtktreemodelfilter_short_type_name[]="GtkTreeModelFilter";

static char *nsp_gtktreemodelfilter_type_as_string(void)
{
  return(gtktreemodelfilter_type_name);
}

static char *nsp_gtktreemodelfilter_type_short_string(NspObject *v)
{
  return(gtktreemodelfilter_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeModelFilter objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeModelFilter   *nsp_gtktreemodelfilter_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktreemodelfilter_id)  == TRUE  ) return ((NspGtkTreeModelFilter *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreemodelfilter));
  return NULL;
}

int IsGtkTreeModelFilterObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktreemodelfilter_id);
}

int IsGtkTreeModelFilter(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreemodelfilter_id);
}

NspGtkTreeModelFilter  *GetGtkTreeModelFilterCopy(Stack stack, int i)
{
  if (  GetGtkTreeModelFilter(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeModelFilter  *GetGtkTreeModelFilter(Stack stack, int i)
{
  NspGtkTreeModelFilter *M;
  if (( M = nsp_gtktreemodelfilter_object(NthObj(i))) == NULLGTKTREEMODELFILTER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeModelFilter *gtktreemodelfilter_copy(NspGtkTreeModelFilter *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreemodelfilter);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreemodelfilter);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeModelFilter
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_tree_model_filter_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,new_opts, t_end};
  nsp_option opts[] = {
	{"root",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *child_model;
  GtkTreePath *root = NULL;
  NspObject *nsp_root = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreemodel, &child_model, opts, &nsp_root) == FAIL) return RET_BUG;
  if ( nsp_root != NULL ) {
    if (nspg_boxed_check(nsp_root, GTK_TYPE_TREE_PATH))
      root = nspg_boxed_get(nsp_root, GtkTreePath);
    else if (! IsNone(nsp_root)) {
      Scierror("Error: root should be a GtkTreePath or None\n");
      return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_tree_model_filter_new(GTK_TREE_MODEL(child_model->obj),root))== NULL) return RET_BUG;

  nsp_type_gtktreemodelfilter = new_type_gtktreemodelfilter(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreemodelfilter);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_filter_set_visible_column(NspGtkTreeModelFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int column;
  if ( GetArgs(stack,rhs,opt,T,&column) == FAIL) return RET_BUG;
    gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(self->obj),column);
  return 0;
}

static int _wrap_gtk_tree_model_filter_get_model(NspGtkTreeModelFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(self->obj));
  nsp_type_gtktreemodel = new_type_gtktreemodel(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreemodel))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_filter_convert_child_iter_to_iter(NspGtkTreeModelFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreeIter *filter_iter = NULL, *child_iter = NULL;
  NspObject *nsp_filter_iter = NULL, *nsp_child_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_filter_iter, &nsp_child_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_filter_iter, GTK_TYPE_TREE_ITER))
      filter_iter = nspg_boxed_get(nsp_filter_iter, GtkTreeIter);
  else {
      Scierror( "Error: filter_iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_child_iter, GTK_TYPE_TREE_ITER))
      child_iter = nspg_boxed_get(nsp_child_iter, GtkTreeIter);
  else {
      Scierror( "Error: child_iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_model_filter_convert_child_iter_to_iter(GTK_TREE_MODEL_FILTER(self->obj),filter_iter,child_iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_model_filter_convert_iter_to_child_iter(NspGtkTreeModelFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreeIter *child_iter = NULL, *filter_iter = NULL;
  NspObject *nsp_child_iter = NULL, *nsp_filter_iter = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_child_iter, &nsp_filter_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_child_iter, GTK_TYPE_TREE_ITER))
      child_iter = nspg_boxed_get(nsp_child_iter, GtkTreeIter);
  else {
      Scierror( "Error: child_iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_filter_iter, GTK_TYPE_TREE_ITER))
      filter_iter = nspg_boxed_get(nsp_filter_iter, GtkTreeIter);
  else {
      Scierror( "Error: filter_iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(self->obj),child_iter,filter_iter);
  return 0;
}

static int _wrap_gtk_tree_model_filter_convert_child_path_to_path(NspGtkTreeModelFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *child_path = NULL, *ret;
  NspObject *nsp_child_path = NULL, *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_child_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_child_path, GTK_TYPE_TREE_PATH))
      child_path = nspg_boxed_get(nsp_child_path, GtkTreePath);
  else {
      Scierror( "Error: child_path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_model_filter_convert_child_path_to_path(GTK_TREE_MODEL_FILTER(self->obj),child_path);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreepath))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_filter_convert_path_to_child_path(NspGtkTreeModelFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreePath *filter_path = NULL, *ret;
  NspObject *nsp_filter_path = NULL, *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_filter_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_filter_path, GTK_TYPE_TREE_PATH))
      filter_path = nspg_boxed_get(nsp_filter_path, GtkTreePath);
  else {
      Scierror( "Error: filter_path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_model_filter_convert_path_to_child_path(GTK_TREE_MODEL_FILTER(self->obj),filter_path);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_PATH, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtktreepath))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tree_model_filter_refilter(NspGtkTreeModelFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->obj));
  return 0;
}

static int _wrap_gtk_tree_model_filter_clear_cache(NspGtkTreeModelFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_model_filter_clear_cache(GTK_TREE_MODEL_FILTER(self->obj));
  return 0;
}

static NspMethods gtktreemodelfilter_methods[] = {
  {"set_visible_column",(nsp_method *) _wrap_gtk_tree_model_filter_set_visible_column},
  {"get_model",(nsp_method *) _wrap_gtk_tree_model_filter_get_model},
  {"convert_child_iter_to_iter",(nsp_method *) _wrap_gtk_tree_model_filter_convert_child_iter_to_iter},
  {"convert_iter_to_child_iter",(nsp_method *) _wrap_gtk_tree_model_filter_convert_iter_to_child_iter},
  {"convert_child_path_to_path",(nsp_method *) _wrap_gtk_tree_model_filter_convert_child_path_to_path},
  {"convert_path_to_child_path",(nsp_method *) _wrap_gtk_tree_model_filter_convert_path_to_child_path},
  {"refilter",(nsp_method *) _wrap_gtk_tree_model_filter_refilter},
  {"clear_cache",(nsp_method *) _wrap_gtk_tree_model_filter_clear_cache},
  { NULL, NULL}
};

static NspMethods *gtktreemodelfilter_get_methods(void) { return gtktreemodelfilter_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreemodelfilter_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellArea ----------- */


#define  NspGtkCellArea_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellarea.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellArea inherits from GObject 
 * and implements GtkCellLayout GtkBuildable
 */

int nsp_type_gtkcellarea_id=0;
NspTypeGtkCellArea *nsp_type_gtkcellarea=NULL;

/*
 * Type object for NspGtkCellArea 
 * all the instance of NspTypeGtkCellArea share the same id. 
 * nsp_type_gtkcellarea: is an instance of NspTypeGtkCellArea 
 *    used for objects of NspGtkCellArea type (i.e built with new_gtkcellarea) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellArea *new_type_gtkcellarea(type_mode mode)
{
  NspTypeGtkCellLayout *t_gtkcelllayout;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkCellArea *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellarea != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellarea;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellarea_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellarea_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellarea;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellarea */ 

  top->s_type =  (s_type_func *) nsp_gtkcellarea_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellarea_type_short_string;
  /* top->create = (create_func*) int_gtkcellarea_create;*/

  /* specific methods for gtkcellarea */

  type->init = (init_func *) init_gtkcellarea;

  /* 
   * NspGtkCellArea interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkcelllayout = new_type_gtkcelllayout(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkcelllayout;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkcellarea_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellArea called nsp_type_gtkcellarea
       */
      type->id =  nsp_type_gtkcellarea_id = nsp_new_type_id();
      nsp_type_gtkcellarea = type;
      if ( nsp_register_type(nsp_type_gtkcellarea) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellarea, GTK_TYPE_CELL_AREA);
      return ( mode == T_BASE ) ? type : new_type_gtkcellarea(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellarea_id;
      return type;
    }
}

/*
 * initialize NspGtkCellArea instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellarea(NspGtkCellArea *Obj,NspTypeGtkCellArea *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellArea 
 */

NspGtkCellArea *new_gtkcellarea() 
{
  NspGtkCellArea *loc;
  /* type must exists */
  nsp_type_gtkcellarea = new_type_gtkcellarea(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellArea)))== NULLGTKCELLAREA) return loc;
  /* initialize object */
  if ( init_gtkcellarea(loc,nsp_type_gtkcellarea) == FAIL) return NULLGTKCELLAREA;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellArea 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellarea_type_name[]="GtkCellArea";
static char gtkcellarea_short_type_name[]="GtkCellArea";

static char *nsp_gtkcellarea_type_as_string(void)
{
  return(gtkcellarea_type_name);
}

static char *nsp_gtkcellarea_type_short_string(NspObject *v)
{
  return(gtkcellarea_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellArea objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellArea   *nsp_gtkcellarea_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellarea_id)  == TRUE  ) return ((NspGtkCellArea *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellarea));
  return NULL;
}

int IsGtkCellAreaObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellarea_id);
}

int IsGtkCellArea(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellarea_id);
}

NspGtkCellArea  *GetGtkCellAreaCopy(Stack stack, int i)
{
  if (  GetGtkCellArea(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellArea  *GetGtkCellArea(Stack stack, int i)
{
  NspGtkCellArea *M;
  if (( M = nsp_gtkcellarea_object(NthObj(i))) == NULLGTKCELLAREA)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellArea *gtkcellarea_copy(NspGtkCellArea *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellarea);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellarea);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellArea
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_cell_area_add(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *renderer;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer) == FAIL) return RET_BUG;
    gtk_cell_area_add(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj));
  return 0;
}

static int _wrap_gtk_cell_area_remove(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *renderer;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer) == FAIL) return RET_BUG;
    gtk_cell_area_remove(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj));
  return 0;
}

static int _wrap_gtk_cell_area_has_renderer(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *renderer;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer) == FAIL) return RET_BUG;
    ret =gtk_cell_area_has_renderer(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_area_create_context(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkCellAreaContext *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_cell_area_create_context(GTK_CELL_AREA(self->obj));
  nsp_type_gtkcellareacontext = new_type_gtkcellareacontext(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellareacontext))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_area_copy_context(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *context;
  GtkCellAreaContext *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellareacontext, &context) == FAIL) return RET_BUG;
    ret =gtk_cell_area_copy_context(GTK_CELL_AREA(self->obj),GTK_CELL_AREA_CONTEXT(context->obj));
  nsp_type_gtkcellareacontext = new_type_gtkcellareacontext(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellareacontext))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_area_get_request_mode(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_cell_area_get_request_mode(GTK_CELL_AREA(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_area_get_preferred_width(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check,s_int,s_int, t_end};
  NspGObject *context, *widget;
  int minimum_width, natural_width;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellareacontext, &context, &nsp_type_gtkwidget, &widget, &minimum_width, &natural_width) == FAIL) return RET_BUG;
    gtk_cell_area_get_preferred_width(GTK_CELL_AREA(self->obj),GTK_CELL_AREA_CONTEXT(context->obj),GTK_WIDGET(widget->obj),&minimum_width,&natural_width);
  return 0;
}

static int _wrap_gtk_cell_area_get_preferred_height_for_width(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check,s_int,s_int,s_int, t_end};
  NspGObject *context, *widget;
  int width, minimum_height, natural_height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellareacontext, &context, &nsp_type_gtkwidget, &widget, &width, &minimum_height, &natural_height) == FAIL) return RET_BUG;
    gtk_cell_area_get_preferred_height_for_width(GTK_CELL_AREA(self->obj),GTK_CELL_AREA_CONTEXT(context->obj),GTK_WIDGET(widget->obj),width,&minimum_height,&natural_height);
  return 0;
}

static int _wrap_gtk_cell_area_get_preferred_height(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check,s_int,s_int, t_end};
  NspGObject *context, *widget;
  int minimum_height, natural_height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellareacontext, &context, &nsp_type_gtkwidget, &widget, &minimum_height, &natural_height) == FAIL) return RET_BUG;
    gtk_cell_area_get_preferred_height(GTK_CELL_AREA(self->obj),GTK_CELL_AREA_CONTEXT(context->obj),GTK_WIDGET(widget->obj),&minimum_height,&natural_height);
  return 0;
}

static int _wrap_gtk_cell_area_get_preferred_width_for_height(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check,s_int,s_int,s_int, t_end};
  NspGObject *context, *widget;
  int height, minimum_width, natural_width;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellareacontext, &context, &nsp_type_gtkwidget, &widget, &height, &minimum_width, &natural_width) == FAIL) return RET_BUG;
    gtk_cell_area_get_preferred_width_for_height(GTK_CELL_AREA(self->obj),GTK_CELL_AREA_CONTEXT(context->obj),GTK_WIDGET(widget->obj),height,&minimum_width,&natural_width);
  return 0;
}

static int _wrap_gtk_cell_area_get_current_path_string(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_cell_area_get_current_path_string(GTK_CELL_AREA(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_area_apply_attributes(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,s_bool,s_bool, t_end};
  NspGObject *tree_model;
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int is_expander, is_expanded;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktreemodel, &tree_model, &nsp_iter, &is_expander, &is_expanded) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_cell_area_apply_attributes(GTK_CELL_AREA(self->obj),GTK_TREE_MODEL(tree_model->obj),iter,is_expander,is_expanded);
  return 0;
}

static int _wrap_gtk_cell_area_attribute_connect(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string,s_int, t_end};
  NspGObject *renderer;
  char *attribute;
  int column;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer, &attribute, &column) == FAIL) return RET_BUG;
    gtk_cell_area_attribute_connect(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj),attribute,column);
  return 0;
}

static int _wrap_gtk_cell_area_attribute_disconnect(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *renderer;
  char *attribute;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer, &attribute) == FAIL) return RET_BUG;
    gtk_cell_area_attribute_disconnect(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj),attribute);
  return 0;
}

#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_cell_area_attribute_get_column(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *renderer;
  char *attribute;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer, &attribute) == FAIL) return RET_BUG;
    ret =gtk_cell_area_attribute_get_column(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj),attribute);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_cell_area_attribute_get_column(Stack stack, int rhs, int opt, int lhs) /* attribute_get_column */
{
  Scierror("Error: function gtk_cell_area_attribute_get_column not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_cell_area_is_activatable(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_cell_area_is_activatable(GTK_CELL_AREA(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_area_focus(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkDirectionType direction;
  NspObject *nsp_direction = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_direction) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_DIRECTION_TYPE, nsp_direction, &direction)== FAIL)
      return RET_BUG;
    ret =gtk_cell_area_focus(GTK_CELL_AREA(self->obj),direction);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_area_set_focus_cell(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *renderer;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer) == FAIL) return RET_BUG;
    gtk_cell_area_set_focus_cell(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj));
  return 0;
}

static int _wrap_gtk_cell_area_get_focus_cell(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkCellRenderer *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_cell_area_get_focus_cell(GTK_CELL_AREA(self->obj));
  nsp_type_gtkcellrenderer = new_type_gtkcellrenderer(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellrenderer))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_area_add_focus_sibling(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *renderer, *sibling;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer, &nsp_type_gtkcellrenderer, &sibling) == FAIL) return RET_BUG;
    gtk_cell_area_add_focus_sibling(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj),GTK_CELL_RENDERER(sibling->obj));
  return 0;
}

static int _wrap_gtk_cell_area_remove_focus_sibling(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *renderer, *sibling;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer, &nsp_type_gtkcellrenderer, &sibling) == FAIL) return RET_BUG;
    gtk_cell_area_remove_focus_sibling(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj),GTK_CELL_RENDERER(sibling->obj));
  return 0;
}

static int _wrap_gtk_cell_area_is_focus_sibling(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *renderer, *sibling;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer, &nsp_type_gtkcellrenderer, &sibling) == FAIL) return RET_BUG;
    ret =gtk_cell_area_is_focus_sibling(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj),GTK_CELL_RENDERER(sibling->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_area_get_focus_from_sibling(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *renderer;
  GtkCellRenderer *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer) == FAIL) return RET_BUG;
    ret =gtk_cell_area_get_focus_from_sibling(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj));
  nsp_type_gtkcellrenderer = new_type_gtkcellrenderer(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellrenderer))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_area_get_edited_cell(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkCellRenderer *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_cell_area_get_edited_cell(GTK_CELL_AREA(self->obj));
  nsp_type_gtkcellrenderer = new_type_gtkcellrenderer(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellrenderer))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_area_get_edit_widget(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkCellEditable *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_cell_area_get_edit_widget(GTK_CELL_AREA(self->obj));
  nsp_type_gtkcelleditable = new_type_gtkcelleditable(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcelleditable))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_area_stop_editing(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int canceled;
  if ( GetArgs(stack,rhs,opt,T,&canceled) == FAIL) return RET_BUG;
    gtk_cell_area_stop_editing(GTK_CELL_AREA(self->obj),canceled);
  return 0;
}

static int _wrap_gtk_cell_area_request_renderer(NspGtkCellArea *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,obj_check,s_int,s_int,s_int, t_end};
  NspGObject *renderer, *widget;
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;
  int for_size, minimum_size, natural_size;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer, &nsp_orientation, &nsp_type_gtkwidget, &widget, &for_size, &minimum_size, &natural_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
    gtk_cell_area_request_renderer(GTK_CELL_AREA(self->obj),GTK_CELL_RENDERER(renderer->obj),orientation,GTK_WIDGET(widget->obj),for_size,&minimum_size,&natural_size);
  return 0;
}

static NspMethods gtkcellarea_methods[] = {
  {"add",(nsp_method *) _wrap_gtk_cell_area_add},
  {"remove",(nsp_method *) _wrap_gtk_cell_area_remove},
  {"has_renderer",(nsp_method *) _wrap_gtk_cell_area_has_renderer},
  {"create_context",(nsp_method *) _wrap_gtk_cell_area_create_context},
  {"copy_context",(nsp_method *) _wrap_gtk_cell_area_copy_context},
  {"get_request_mode",(nsp_method *) _wrap_gtk_cell_area_get_request_mode},
  {"get_preferred_width",(nsp_method *) _wrap_gtk_cell_area_get_preferred_width},
  {"get_preferred_height_for_width",(nsp_method *) _wrap_gtk_cell_area_get_preferred_height_for_width},
  {"get_preferred_height",(nsp_method *) _wrap_gtk_cell_area_get_preferred_height},
  {"get_preferred_width_for_height",(nsp_method *) _wrap_gtk_cell_area_get_preferred_width_for_height},
  {"get_current_path_string",(nsp_method *) _wrap_gtk_cell_area_get_current_path_string},
  {"apply_attributes",(nsp_method *) _wrap_gtk_cell_area_apply_attributes},
  {"attribute_connect",(nsp_method *) _wrap_gtk_cell_area_attribute_connect},
  {"attribute_disconnect",(nsp_method *) _wrap_gtk_cell_area_attribute_disconnect},
  {"attribute_get_column",(nsp_method *) _wrap_gtk_cell_area_attribute_get_column},
  {"is_activatable",(nsp_method *) _wrap_gtk_cell_area_is_activatable},
  {"focus",(nsp_method *) _wrap_gtk_cell_area_focus},
  {"set_focus_cell",(nsp_method *) _wrap_gtk_cell_area_set_focus_cell},
  {"get_focus_cell",(nsp_method *) _wrap_gtk_cell_area_get_focus_cell},
  {"add_focus_sibling",(nsp_method *) _wrap_gtk_cell_area_add_focus_sibling},
  {"remove_focus_sibling",(nsp_method *) _wrap_gtk_cell_area_remove_focus_sibling},
  {"is_focus_sibling",(nsp_method *) _wrap_gtk_cell_area_is_focus_sibling},
  {"get_focus_from_sibling",(nsp_method *) _wrap_gtk_cell_area_get_focus_from_sibling},
  {"get_edited_cell",(nsp_method *) _wrap_gtk_cell_area_get_edited_cell},
  {"get_edit_widget",(nsp_method *) _wrap_gtk_cell_area_get_edit_widget},
  {"stop_editing",(nsp_method *) _wrap_gtk_cell_area_stop_editing},
  {"request_renderer",(nsp_method *) _wrap_gtk_cell_area_request_renderer},
  { NULL, NULL}
};

static NspMethods *gtkcellarea_get_methods(void) { return gtkcellarea_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellarea_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellAreaBox ----------- */


#define  NspGtkCellAreaBox_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellareabox.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellAreaBox inherits from GtkCellArea 
 * and implements GtkCellLayout GtkOrientable GtkBuildable
 */

int nsp_type_gtkcellareabox_id=0;
NspTypeGtkCellAreaBox *nsp_type_gtkcellareabox=NULL;

/*
 * Type object for NspGtkCellAreaBox 
 * all the instance of NspTypeGtkCellAreaBox share the same id. 
 * nsp_type_gtkcellareabox: is an instance of NspTypeGtkCellAreaBox 
 *    used for objects of NspGtkCellAreaBox type (i.e built with new_gtkcellareabox) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellAreaBox *new_type_gtkcellareabox(type_mode mode)
{
  NspTypeGtkCellLayout *t_gtkcelllayout;
  NspTypeGtkOrientable *t_gtkorientable;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkCellAreaBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellareabox != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellareabox;
    }
  if (( type =  malloc(sizeof(NspTypeGtkCellArea))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellarea(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellareabox_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellareabox_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellareabox;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellareabox */ 

  top->s_type =  (s_type_func *) nsp_gtkcellareabox_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellareabox_type_short_string;
  /* top->create = (create_func*) int_gtkcellareabox_create;*/

  /* specific methods for gtkcellareabox */

  type->init = (init_func *) init_gtkcellareabox;

  /* 
   * NspGtkCellAreaBox interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkcelllayout = new_type_gtkcelllayout(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkcelllayout;
  t_gtkorientable = new_type_gtkorientable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkorientable;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkcellareabox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellAreaBox called nsp_type_gtkcellareabox
       */
      type->id =  nsp_type_gtkcellareabox_id = nsp_new_type_id();
      nsp_type_gtkcellareabox = type;
      if ( nsp_register_type(nsp_type_gtkcellareabox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellareabox, GTK_TYPE_CELL_AREA_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkcellareabox(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellareabox_id;
      return type;
    }
}

/*
 * initialize NspGtkCellAreaBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellareabox(NspGtkCellAreaBox *Obj,NspTypeGtkCellAreaBox *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellAreaBox 
 */

NspGtkCellAreaBox *new_gtkcellareabox() 
{
  NspGtkCellAreaBox *loc;
  /* type must exists */
  nsp_type_gtkcellareabox = new_type_gtkcellareabox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellAreaBox)))== NULLGTKCELLAREABOX) return loc;
  /* initialize object */
  if ( init_gtkcellareabox(loc,nsp_type_gtkcellareabox) == FAIL) return NULLGTKCELLAREABOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellAreaBox 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellareabox_type_name[]="GtkCellAreaBox";
static char gtkcellareabox_short_type_name[]="GtkCellAreaBox";

static char *nsp_gtkcellareabox_type_as_string(void)
{
  return(gtkcellareabox_type_name);
}

static char *nsp_gtkcellareabox_type_short_string(NspObject *v)
{
  return(gtkcellareabox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellAreaBox objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellAreaBox   *nsp_gtkcellareabox_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellareabox_id)  == TRUE  ) return ((NspGtkCellAreaBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellareabox));
  return NULL;
}

int IsGtkCellAreaBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellareabox_id);
}

int IsGtkCellAreaBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellareabox_id);
}

NspGtkCellAreaBox  *GetGtkCellAreaBoxCopy(Stack stack, int i)
{
  if (  GetGtkCellAreaBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellAreaBox  *GetGtkCellAreaBox(Stack stack, int i)
{
  NspGtkCellAreaBox *M;
  if (( M = nsp_gtkcellareabox_object(NthObj(i))) == NULLGTKCELLAREABOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellAreaBox *gtkcellareabox_copy(NspGtkCellAreaBox *self)
{
  /* return gtkcellarea_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellareabox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellareabox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellAreaBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_cell_area_box_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_area_box_new())== NULL) return RET_BUG;

  nsp_type_gtkcellareabox = new_type_gtkcellareabox(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellareabox);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_area_box_pack_start(NspGtkCellAreaBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool,s_bool,s_bool, t_end};
  NspGObject *renderer;
  int expand, align, fixed;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer, &expand, &align, &fixed) == FAIL) return RET_BUG;
    gtk_cell_area_box_pack_start(GTK_CELL_AREA_BOX(self->obj),GTK_CELL_RENDERER(renderer->obj),expand,align,fixed);
  return 0;
}

static int _wrap_gtk_cell_area_box_pack_end(NspGtkCellAreaBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool,s_bool,s_bool, t_end};
  NspGObject *renderer;
  int expand, align, fixed;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkcellrenderer, &renderer, &expand, &align, &fixed) == FAIL) return RET_BUG;
    gtk_cell_area_box_pack_end(GTK_CELL_AREA_BOX(self->obj),GTK_CELL_RENDERER(renderer->obj),expand,align,fixed);
  return 0;
}

static int _wrap_gtk_cell_area_box_get_spacing(NspGtkCellAreaBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_cell_area_box_get_spacing(GTK_CELL_AREA_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_area_box_set_spacing(NspGtkCellAreaBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int spacing;
  if ( GetArgs(stack,rhs,opt,T,&spacing) == FAIL) return RET_BUG;
    gtk_cell_area_box_set_spacing(GTK_CELL_AREA_BOX(self->obj),spacing);
  return 0;
}

static NspMethods gtkcellareabox_methods[] = {
  {"pack_start",(nsp_method *) _wrap_gtk_cell_area_box_pack_start},
  {"pack_end",(nsp_method *) _wrap_gtk_cell_area_box_pack_end},
  {"get_spacing",(nsp_method *) _wrap_gtk_cell_area_box_get_spacing},
  {"set_spacing",(nsp_method *) _wrap_gtk_cell_area_box_set_spacing},
  { NULL, NULL}
};

static NspMethods *gtkcellareabox_get_methods(void) { return gtkcellareabox_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellareabox_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellAreaContext ----------- */


#define  NspGtkCellAreaContext_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellareacontext.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellAreaContext inherits from GObject 
 * and implements GtkCellLayout
 */

int nsp_type_gtkcellareacontext_id=0;
NspTypeGtkCellAreaContext *nsp_type_gtkcellareacontext=NULL;

/*
 * Type object for NspGtkCellAreaContext 
 * all the instance of NspTypeGtkCellAreaContext share the same id. 
 * nsp_type_gtkcellareacontext: is an instance of NspTypeGtkCellAreaContext 
 *    used for objects of NspGtkCellAreaContext type (i.e built with new_gtkcellareacontext) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellAreaContext *new_type_gtkcellareacontext(type_mode mode)
{
  NspTypeGtkCellLayout *t_gtkcelllayout;
  NspTypeGtkCellAreaContext *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellareacontext != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellareacontext;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellareacontext_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellareacontext_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellareacontext;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellareacontext */ 

  top->s_type =  (s_type_func *) nsp_gtkcellareacontext_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellareacontext_type_short_string;
  /* top->create = (create_func*) int_gtkcellareacontext_create;*/

  /* specific methods for gtkcellareacontext */

  type->init = (init_func *) init_gtkcellareacontext;

  /* 
   * NspGtkCellAreaContext interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkcelllayout = new_type_gtkcelllayout(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkcelllayout;
  if ( nsp_type_gtkcellareacontext_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellAreaContext called nsp_type_gtkcellareacontext
       */
      type->id =  nsp_type_gtkcellareacontext_id = nsp_new_type_id();
      nsp_type_gtkcellareacontext = type;
      if ( nsp_register_type(nsp_type_gtkcellareacontext) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellareacontext, GTK_TYPE_CELL_AREA_CONTEXT);
      return ( mode == T_BASE ) ? type : new_type_gtkcellareacontext(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellareacontext_id;
      return type;
    }
}

/*
 * initialize NspGtkCellAreaContext instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellareacontext(NspGtkCellAreaContext *Obj,NspTypeGtkCellAreaContext *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellAreaContext 
 */

NspGtkCellAreaContext *new_gtkcellareacontext() 
{
  NspGtkCellAreaContext *loc;
  /* type must exists */
  nsp_type_gtkcellareacontext = new_type_gtkcellareacontext(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellAreaContext)))== NULLGTKCELLAREACONTEXT) return loc;
  /* initialize object */
  if ( init_gtkcellareacontext(loc,nsp_type_gtkcellareacontext) == FAIL) return NULLGTKCELLAREACONTEXT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellAreaContext 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellareacontext_type_name[]="GtkCellAreaContext";
static char gtkcellareacontext_short_type_name[]="GtkCellAreaContext";

static char *nsp_gtkcellareacontext_type_as_string(void)
{
  return(gtkcellareacontext_type_name);
}

static char *nsp_gtkcellareacontext_type_short_string(NspObject *v)
{
  return(gtkcellareacontext_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellAreaContext objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellAreaContext   *nsp_gtkcellareacontext_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellareacontext_id)  == TRUE  ) return ((NspGtkCellAreaContext *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellareacontext));
  return NULL;
}

int IsGtkCellAreaContextObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellareacontext_id);
}

int IsGtkCellAreaContext(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellareacontext_id);
}

NspGtkCellAreaContext  *GetGtkCellAreaContextCopy(Stack stack, int i)
{
  if (  GetGtkCellAreaContext(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellAreaContext  *GetGtkCellAreaContext(Stack stack, int i)
{
  NspGtkCellAreaContext *M;
  if (( M = nsp_gtkcellareacontext_object(NthObj(i))) == NULLGTKCELLAREACONTEXT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellAreaContext *gtkcellareacontext_copy(NspGtkCellAreaContext *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellareacontext);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellareacontext);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellAreaContext
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_cell_area_context_get_area(NspGtkCellAreaContext *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkCellArea *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_cell_area_context_get_area(GTK_CELL_AREA_CONTEXT(self->obj));
  nsp_type_gtkcellarea = new_type_gtkcellarea(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellarea))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_area_context_allocate(NspGtkCellAreaContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int width, height;
  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
    gtk_cell_area_context_allocate(GTK_CELL_AREA_CONTEXT(self->obj),width,height);
  return 0;
}

static int _wrap_gtk_cell_area_context_reset(NspGtkCellAreaContext *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_cell_area_context_reset(GTK_CELL_AREA_CONTEXT(self->obj));
  return 0;
}

static int _wrap_gtk_cell_area_context_get_preferred_width(NspGtkCellAreaContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int minimum_width, natural_width;
  if ( GetArgs(stack,rhs,opt,T,&minimum_width, &natural_width) == FAIL) return RET_BUG;
    gtk_cell_area_context_get_preferred_width(GTK_CELL_AREA_CONTEXT(self->obj),&minimum_width,&natural_width);
  return 0;
}

static int _wrap_gtk_cell_area_context_get_preferred_height(NspGtkCellAreaContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int minimum_height, natural_height;
  if ( GetArgs(stack,rhs,opt,T,&minimum_height, &natural_height) == FAIL) return RET_BUG;
    gtk_cell_area_context_get_preferred_height(GTK_CELL_AREA_CONTEXT(self->obj),&minimum_height,&natural_height);
  return 0;
}

static int _wrap_gtk_cell_area_context_get_preferred_height_for_width(NspGtkCellAreaContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int, t_end};
  int width, minimum_height, natural_height;
  if ( GetArgs(stack,rhs,opt,T,&width, &minimum_height, &natural_height) == FAIL) return RET_BUG;
    gtk_cell_area_context_get_preferred_height_for_width(GTK_CELL_AREA_CONTEXT(self->obj),width,&minimum_height,&natural_height);
  return 0;
}

static int _wrap_gtk_cell_area_context_get_preferred_width_for_height(NspGtkCellAreaContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int, t_end};
  int height, minimum_width, natural_width;
  if ( GetArgs(stack,rhs,opt,T,&height, &minimum_width, &natural_width) == FAIL) return RET_BUG;
    gtk_cell_area_context_get_preferred_width_for_height(GTK_CELL_AREA_CONTEXT(self->obj),height,&minimum_width,&natural_width);
  return 0;
}

static int _wrap_gtk_cell_area_context_get_allocation(NspGtkCellAreaContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int width, height;
  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
    gtk_cell_area_context_get_allocation(GTK_CELL_AREA_CONTEXT(self->obj),&width,&height);
  return 0;
}

static int _wrap_gtk_cell_area_context_push_preferred_width(NspGtkCellAreaContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int minimum_width, natural_width;
  if ( GetArgs(stack,rhs,opt,T,&minimum_width, &natural_width) == FAIL) return RET_BUG;
    gtk_cell_area_context_push_preferred_width(GTK_CELL_AREA_CONTEXT(self->obj),minimum_width,natural_width);
  return 0;
}

static int _wrap_gtk_cell_area_context_push_preferred_height(NspGtkCellAreaContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int minimum_height, natural_height;
  if ( GetArgs(stack,rhs,opt,T,&minimum_height, &natural_height) == FAIL) return RET_BUG;
    gtk_cell_area_context_push_preferred_height(GTK_CELL_AREA_CONTEXT(self->obj),minimum_height,natural_height);
  return 0;
}

static NspMethods gtkcellareacontext_methods[] = {
  {"get_area",(nsp_method *) _wrap_gtk_cell_area_context_get_area},
  {"allocate",(nsp_method *) _wrap_gtk_cell_area_context_allocate},
  {"reset",(nsp_method *) _wrap_gtk_cell_area_context_reset},
  {"get_preferred_width",(nsp_method *) _wrap_gtk_cell_area_context_get_preferred_width},
  {"get_preferred_height",(nsp_method *) _wrap_gtk_cell_area_context_get_preferred_height},
  {"get_preferred_height_for_width",(nsp_method *) _wrap_gtk_cell_area_context_get_preferred_height_for_width},
  {"get_preferred_width_for_height",(nsp_method *) _wrap_gtk_cell_area_context_get_preferred_width_for_height},
  {"get_allocation",(nsp_method *) _wrap_gtk_cell_area_context_get_allocation},
  {"push_preferred_width",(nsp_method *) _wrap_gtk_cell_area_context_push_preferred_width},
  {"push_preferred_height",(nsp_method *) _wrap_gtk_cell_area_context_push_preferred_height},
  { NULL, NULL}
};

static NspMethods *gtkcellareacontext_get_methods(void) { return gtkcellareacontext_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellareacontext_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellRenderer ----------- */


#define  NspGtkCellRenderer_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellrenderer.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellRenderer inherits from GObject 
 */

int nsp_type_gtkcellrenderer_id=0;
NspTypeGtkCellRenderer *nsp_type_gtkcellrenderer=NULL;

/*
 * Type object for NspGtkCellRenderer 
 * all the instance of NspTypeGtkCellRenderer share the same id. 
 * nsp_type_gtkcellrenderer: is an instance of NspTypeGtkCellRenderer 
 *    used for objects of NspGtkCellRenderer type (i.e built with new_gtkcellrenderer) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellRenderer *new_type_gtkcellrenderer(type_mode mode)
{
  NspTypeGtkCellRenderer *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrenderer != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrenderer;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrenderer_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellrenderer_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellrenderer;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellrenderer */ 

  top->s_type =  (s_type_func *) nsp_gtkcellrenderer_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellrenderer_type_short_string;
  /* top->create = (create_func*) int_gtkcellrenderer_create;*/

  /* specific methods for gtkcellrenderer */

  type->init = (init_func *) init_gtkcellrenderer;

  /* 
   * NspGtkCellRenderer interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcellrenderer_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRenderer called nsp_type_gtkcellrenderer
       */
      type->id =  nsp_type_gtkcellrenderer_id = nsp_new_type_id();
      nsp_type_gtkcellrenderer = type;
      if ( nsp_register_type(nsp_type_gtkcellrenderer) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrenderer, GTK_TYPE_CELL_RENDERER);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrenderer(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellrenderer_id;
      return type;
    }
}

/*
 * initialize NspGtkCellRenderer instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrenderer(NspGtkCellRenderer *Obj,NspTypeGtkCellRenderer *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellRenderer 
 */

NspGtkCellRenderer *new_gtkcellrenderer() 
{
  NspGtkCellRenderer *loc;
  /* type must exists */
  nsp_type_gtkcellrenderer = new_type_gtkcellrenderer(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRenderer)))== NULLGTKCELLRENDERER) return loc;
  /* initialize object */
  if ( init_gtkcellrenderer(loc,nsp_type_gtkcellrenderer) == FAIL) return NULLGTKCELLRENDERER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellRenderer 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellrenderer_type_name[]="GtkCellRenderer";
static char gtkcellrenderer_short_type_name[]="GtkCellRenderer";

static char *nsp_gtkcellrenderer_type_as_string(void)
{
  return(gtkcellrenderer_type_name);
}

static char *nsp_gtkcellrenderer_type_short_string(NspObject *v)
{
  return(gtkcellrenderer_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellRenderer objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellRenderer   *nsp_gtkcellrenderer_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellrenderer_id)  == TRUE  ) return ((NspGtkCellRenderer *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrenderer));
  return NULL;
}

int IsGtkCellRendererObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellrenderer_id);
}

int IsGtkCellRenderer(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrenderer_id);
}

NspGtkCellRenderer  *GetGtkCellRendererCopy(Stack stack, int i)
{
  if (  GetGtkCellRenderer(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRenderer  *GetGtkCellRenderer(Stack stack, int i)
{
  NspGtkCellRenderer *M;
  if (( M = nsp_gtkcellrenderer_object(NthObj(i))) == NULLGTKCELLRENDERER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRenderer *gtkcellrenderer_copy(NspGtkCellRenderer *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderer);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderer);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRenderer
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_cell_renderer_get_request_mode(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_cell_renderer_get_request_mode(GTK_CELL_RENDERER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_renderer_get_preferred_width(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int, t_end};
  NspGObject *widget;
  int minimum_size, natural_size;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &minimum_size, &natural_size) == FAIL) return RET_BUG;
    gtk_cell_renderer_get_preferred_width(GTK_CELL_RENDERER(self->obj),GTK_WIDGET(widget->obj),&minimum_size,&natural_size);
  return 0;
}

static int _wrap_gtk_cell_renderer_get_preferred_height_for_width(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int,s_int, t_end};
  NspGObject *widget;
  int width, minimum_height, natural_height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &width, &minimum_height, &natural_height) == FAIL) return RET_BUG;
    gtk_cell_renderer_get_preferred_height_for_width(GTK_CELL_RENDERER(self->obj),GTK_WIDGET(widget->obj),width,&minimum_height,&natural_height);
  return 0;
}

static int _wrap_gtk_cell_renderer_get_preferred_height(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int, t_end};
  NspGObject *widget;
  int minimum_size, natural_size;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &minimum_size, &natural_size) == FAIL) return RET_BUG;
    gtk_cell_renderer_get_preferred_height(GTK_CELL_RENDERER(self->obj),GTK_WIDGET(widget->obj),&minimum_size,&natural_size);
  return 0;
}

static int _wrap_gtk_cell_renderer_get_preferred_width_for_height(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int,s_int, t_end};
  NspGObject *widget;
  int height, minimum_width, natural_width;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &height, &minimum_width, &natural_width) == FAIL) return RET_BUG;
    gtk_cell_renderer_get_preferred_width_for_height(GTK_CELL_RENDERER(self->obj),GTK_WIDGET(widget->obj),height,&minimum_width,&natural_width);
  return 0;
}

static int _wrap_gtk_cell_renderer_get_preferred_size(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,obj, t_end};
  NspGObject *widget;
  GtkRequisition *minimum_size = NULL, *natural_size = NULL;
  NspObject *nsp_minimum_size = NULL, *nsp_natural_size = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_minimum_size, &nsp_natural_size) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_minimum_size, GTK_TYPE_REQUISITION))
      minimum_size = nspg_boxed_get(nsp_minimum_size, GtkRequisition);
  else {
      Scierror( "Error: minimum_size should be a GtkRequisition\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_natural_size, GTK_TYPE_REQUISITION))
      natural_size = nspg_boxed_get(nsp_natural_size, GtkRequisition);
  else {
      Scierror( "Error: natural_size should be a GtkRequisition\n");
      return RET_BUG;
  }
    gtk_cell_renderer_get_preferred_size(GTK_CELL_RENDERER(self->obj),GTK_WIDGET(widget->obj),minimum_size,natural_size);
  return 0;
}

static int _wrap_gtk_cell_renderer_set_fixed_size(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int width, height;
  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
    gtk_cell_renderer_set_fixed_size(GTK_CELL_RENDERER(self->obj),width,height);
  return 0;
}

#line 6535 "codegen-3.0/gtk.override"
static int
_wrap_gtk_cell_renderer_get_fixed_size(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint width, height;

  gtk_cell_renderer_get_fixed_size(GTK_CELL_RENDERER(self->obj),
				   &width, &height);

  if (  nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL)
    return RET_BUG;
  return 1;
}
#line 45102 "gtk.c"


static int _wrap_gtk_cell_renderer_set_alignment(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,s_double, t_end};
  double xalign, yalign;
  if ( GetArgs(stack,rhs,opt,T,&xalign, &yalign) == FAIL) return RET_BUG;
    gtk_cell_renderer_set_alignment(GTK_CELL_RENDERER(self->obj),xalign,yalign);
  return 0;
}

#line 7104 "codegen-3.0/gtk.override"
static int
_wrap_gtk_cell_renderer_get_alignment(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gfloat xalign, yalign;

  gtk_cell_renderer_get_alignment(GTK_CELL_RENDERER(self->obj), &xalign, &yalign);
  if ( nsp_move_doubles(stack,1,1,2,(double) xalign,(double) yalign) == FAIL) return RET_BUG;
  return 1;
}
#line 45124 "gtk.c"


static int _wrap_gtk_cell_renderer_set_padding(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int xpad, ypad;
  if ( GetArgs(stack,rhs,opt,T,&xpad, &ypad) == FAIL) return RET_BUG;
    gtk_cell_renderer_set_padding(GTK_CELL_RENDERER(self->obj),xpad,ypad);
  return 0;
}

#line 7115 "codegen-3.0/gtk.override"
static int
_wrap_gtk_cell_renderer_get_padding(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gint xpad, ypad;

  gtk_cell_renderer_get_padding(GTK_CELL_RENDERER(self->obj), &xpad, &ypad);
  if ( nsp_move_doubles(stack,1,1,2,(double) xpad,(double) ypad) == FAIL) return RET_BUG;
  return 1;
}

#line 45147 "gtk.c"


static int _wrap_gtk_cell_renderer_set_visible(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int visible;
  if ( GetArgs(stack,rhs,opt,T,&visible) == FAIL) return RET_BUG;
    gtk_cell_renderer_set_visible(GTK_CELL_RENDERER(self->obj),visible);
  return 0;
}

static int _wrap_gtk_cell_renderer_get_visible(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_cell_renderer_get_visible(GTK_CELL_RENDERER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_renderer_set_sensitive(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int sensitive;
  if ( GetArgs(stack,rhs,opt,T,&sensitive) == FAIL) return RET_BUG;
    gtk_cell_renderer_set_sensitive(GTK_CELL_RENDERER(self->obj),sensitive);
  return 0;
}

static int _wrap_gtk_cell_renderer_get_sensitive(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_cell_renderer_get_sensitive(GTK_CELL_RENDERER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_renderer_is_activatable(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_cell_renderer_is_activatable(GTK_CELL_RENDERER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_renderer_stop_editing(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int canceled;
  if ( GetArgs(stack,rhs,opt,T,&canceled) == FAIL) return RET_BUG;
    gtk_cell_renderer_stop_editing(GTK_CELL_RENDERER(self->obj),canceled);
  return 0;
}

static int _wrap_gtk_cell_renderer_get_state(NspGtkCellRenderer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *widget;
  GtkCellRendererState cell_state;
  NspObject *nsp_cell_state = NULL;
  guint ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_cell_state) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_CELL_RENDERER_STATE, nsp_cell_state, &cell_state)==FAIL)
      return RET_BUG;
    ret =gtk_cell_renderer_get_state(GTK_CELL_RENDERER(self->obj),GTK_WIDGET(widget->obj),cell_state);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkcellrenderer_methods[] = {
  {"get_request_mode",(nsp_method *) _wrap_gtk_cell_renderer_get_request_mode},
  {"get_preferred_width",(nsp_method *) _wrap_gtk_cell_renderer_get_preferred_width},
  {"get_preferred_height_for_width",(nsp_method *) _wrap_gtk_cell_renderer_get_preferred_height_for_width},
  {"get_preferred_height",(nsp_method *) _wrap_gtk_cell_renderer_get_preferred_height},
  {"get_preferred_width_for_height",(nsp_method *) _wrap_gtk_cell_renderer_get_preferred_width_for_height},
  {"get_preferred_size",(nsp_method *) _wrap_gtk_cell_renderer_get_preferred_size},
  {"set_fixed_size",(nsp_method *) _wrap_gtk_cell_renderer_set_fixed_size},
  {"get_fixed_size",(nsp_method *) _wrap_gtk_cell_renderer_get_fixed_size},
  {"set_alignment",(nsp_method *) _wrap_gtk_cell_renderer_set_alignment},
  {"get_alignment",(nsp_method *) _wrap_gtk_cell_renderer_get_alignment},
  {"set_padding",(nsp_method *) _wrap_gtk_cell_renderer_set_padding},
  {"get_padding",(nsp_method *) _wrap_gtk_cell_renderer_get_padding},
  {"set_visible",(nsp_method *) _wrap_gtk_cell_renderer_set_visible},
  {"get_visible",(nsp_method *) _wrap_gtk_cell_renderer_get_visible},
  {"set_sensitive",(nsp_method *) _wrap_gtk_cell_renderer_set_sensitive},
  {"get_sensitive",(nsp_method *) _wrap_gtk_cell_renderer_get_sensitive},
  {"is_activatable",(nsp_method *) _wrap_gtk_cell_renderer_is_activatable},
  {"stop_editing",(nsp_method *) _wrap_gtk_cell_renderer_stop_editing},
  {"get_state",(nsp_method *) _wrap_gtk_cell_renderer_get_state},
  { NULL, NULL}
};

static NspMethods *gtkcellrenderer_get_methods(void) { return gtkcellrenderer_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrenderer_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellRendererAccel ----------- */


#define  NspGtkCellRendererAccel_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellrendereraccel.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellRendererAccel inherits from GtkCellRendererText 
 */

int nsp_type_gtkcellrendereraccel_id=0;
NspTypeGtkCellRendererAccel *nsp_type_gtkcellrendereraccel=NULL;

/*
 * Type object for NspGtkCellRendererAccel 
 * all the instance of NspTypeGtkCellRendererAccel share the same id. 
 * nsp_type_gtkcellrendereraccel: is an instance of NspTypeGtkCellRendererAccel 
 *    used for objects of NspGtkCellRendererAccel type (i.e built with new_gtkcellrendereraccel) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellRendererAccel *new_type_gtkcellrendereraccel(type_mode mode)
{
  NspTypeGtkCellRendererAccel *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrendereraccel != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrendereraccel;
    }
  if (( type =  malloc(sizeof(NspTypeGtkCellRendererText))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellrenderertext(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrendereraccel_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellrendereraccel_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellrendereraccel;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellrendereraccel */ 

  top->s_type =  (s_type_func *) nsp_gtkcellrendereraccel_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellrendereraccel_type_short_string;
  /* top->create = (create_func*) int_gtkcellrendereraccel_create;*/

  /* specific methods for gtkcellrendereraccel */

  type->init = (init_func *) init_gtkcellrendereraccel;

  /* 
   * NspGtkCellRendererAccel interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcellrendereraccel_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRendererAccel called nsp_type_gtkcellrendereraccel
       */
      type->id =  nsp_type_gtkcellrendereraccel_id = nsp_new_type_id();
      nsp_type_gtkcellrendereraccel = type;
      if ( nsp_register_type(nsp_type_gtkcellrendereraccel) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrendereraccel, GTK_TYPE_CELL_RENDERER_COMBO);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrendereraccel(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellrendereraccel_id;
      return type;
    }
}

/*
 * initialize NspGtkCellRendererAccel instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrendereraccel(NspGtkCellRendererAccel *Obj,NspTypeGtkCellRendererAccel *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellRendererAccel 
 */

NspGtkCellRendererAccel *new_gtkcellrendereraccel() 
{
  NspGtkCellRendererAccel *loc;
  /* type must exists */
  nsp_type_gtkcellrendereraccel = new_type_gtkcellrendereraccel(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRendererAccel)))== NULLGTKCELLRENDERERACCEL) return loc;
  /* initialize object */
  if ( init_gtkcellrendereraccel(loc,nsp_type_gtkcellrendereraccel) == FAIL) return NULLGTKCELLRENDERERACCEL;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellRendererAccel 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellrendereraccel_type_name[]="GtkCellRendererAccel";
static char gtkcellrendereraccel_short_type_name[]="GtkCellRendererAccel";

static char *nsp_gtkcellrendereraccel_type_as_string(void)
{
  return(gtkcellrendereraccel_type_name);
}

static char *nsp_gtkcellrendereraccel_type_short_string(NspObject *v)
{
  return(gtkcellrendereraccel_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellRendererAccel objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellRendererAccel   *nsp_gtkcellrendereraccel_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellrendereraccel_id)  == TRUE  ) return ((NspGtkCellRendererAccel *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrendereraccel));
  return NULL;
}

int IsGtkCellRendererAccelObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellrendereraccel_id);
}

int IsGtkCellRendererAccel(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrendereraccel_id);
}

NspGtkCellRendererAccel  *GetGtkCellRendererAccelCopy(Stack stack, int i)
{
  if (  GetGtkCellRendererAccel(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRendererAccel  *GetGtkCellRendererAccel(Stack stack, int i)
{
  NspGtkCellRendererAccel *M;
  if (( M = nsp_gtkcellrendereraccel_object(NthObj(i))) == NULLGTKCELLRENDERERACCEL)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRendererAccel *gtkcellrendereraccel_copy(NspGtkCellRendererAccel *self)
{
  /* return gtkcellrenderertext_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendereraccel);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendereraccel);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRendererAccel
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_cell_renderer_accel_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_renderer_accel_new())== NULL) return RET_BUG;

  nsp_type_gtkcellrendereraccel = new_type_gtkcellrendereraccel(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellrendereraccel);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkcellrendereraccel_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrendereraccel_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellRendererCombo ----------- */


#define  NspGtkCellRendererCombo_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellrenderercombo.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellRendererCombo inherits from GtkCellRendererText 
 */

int nsp_type_gtkcellrenderercombo_id=0;
NspTypeGtkCellRendererCombo *nsp_type_gtkcellrenderercombo=NULL;

/*
 * Type object for NspGtkCellRendererCombo 
 * all the instance of NspTypeGtkCellRendererCombo share the same id. 
 * nsp_type_gtkcellrenderercombo: is an instance of NspTypeGtkCellRendererCombo 
 *    used for objects of NspGtkCellRendererCombo type (i.e built with new_gtkcellrenderercombo) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellRendererCombo *new_type_gtkcellrenderercombo(type_mode mode)
{
  NspTypeGtkCellRendererCombo *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrenderercombo != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrenderercombo;
    }
  if (( type =  malloc(sizeof(NspTypeGtkCellRendererText))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellrenderertext(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrenderercombo_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellrenderercombo_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellrenderercombo;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellrenderercombo */ 

  top->s_type =  (s_type_func *) nsp_gtkcellrenderercombo_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellrenderercombo_type_short_string;
  /* top->create = (create_func*) int_gtkcellrenderercombo_create;*/

  /* specific methods for gtkcellrenderercombo */

  type->init = (init_func *) init_gtkcellrenderercombo;

  /* 
   * NspGtkCellRendererCombo interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcellrenderercombo_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRendererCombo called nsp_type_gtkcellrenderercombo
       */
      type->id =  nsp_type_gtkcellrenderercombo_id = nsp_new_type_id();
      nsp_type_gtkcellrenderercombo = type;
      if ( nsp_register_type(nsp_type_gtkcellrenderercombo) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrenderercombo, GTK_TYPE_CELL_RENDERER_COMBO);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrenderercombo(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellrenderercombo_id;
      return type;
    }
}

/*
 * initialize NspGtkCellRendererCombo instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrenderercombo(NspGtkCellRendererCombo *Obj,NspTypeGtkCellRendererCombo *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellRendererCombo 
 */

NspGtkCellRendererCombo *new_gtkcellrenderercombo() 
{
  NspGtkCellRendererCombo *loc;
  /* type must exists */
  nsp_type_gtkcellrenderercombo = new_type_gtkcellrenderercombo(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRendererCombo)))== NULLGTKCELLRENDERERCOMBO) return loc;
  /* initialize object */
  if ( init_gtkcellrenderercombo(loc,nsp_type_gtkcellrenderercombo) == FAIL) return NULLGTKCELLRENDERERCOMBO;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellRendererCombo 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellrenderercombo_type_name[]="GtkCellRendererCombo";
static char gtkcellrenderercombo_short_type_name[]="GtkCellRendererCombo";

static char *nsp_gtkcellrenderercombo_type_as_string(void)
{
  return(gtkcellrenderercombo_type_name);
}

static char *nsp_gtkcellrenderercombo_type_short_string(NspObject *v)
{
  return(gtkcellrenderercombo_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellRendererCombo objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellRendererCombo   *nsp_gtkcellrenderercombo_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellrenderercombo_id)  == TRUE  ) return ((NspGtkCellRendererCombo *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrenderercombo));
  return NULL;
}

int IsGtkCellRendererComboObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellrenderercombo_id);
}

int IsGtkCellRendererCombo(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrenderercombo_id);
}

NspGtkCellRendererCombo  *GetGtkCellRendererComboCopy(Stack stack, int i)
{
  if (  GetGtkCellRendererCombo(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRendererCombo  *GetGtkCellRendererCombo(Stack stack, int i)
{
  NspGtkCellRendererCombo *M;
  if (( M = nsp_gtkcellrenderercombo_object(NthObj(i))) == NULLGTKCELLRENDERERCOMBO)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRendererCombo *gtkcellrenderercombo_copy(NspGtkCellRendererCombo *self)
{
  /* return gtkcellrenderertext_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderercombo);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderercombo);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRendererCombo
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_cell_renderer_combo_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_renderer_combo_new())== NULL) return RET_BUG;

  nsp_type_gtkcellrenderercombo = new_type_gtkcellrenderercombo(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellrenderercombo);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkcellrenderercombo_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrenderercombo_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellRendererPixbuf ----------- */


#define  NspGtkCellRendererPixbuf_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellrendererpixbuf.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellRendererPixbuf inherits from GtkCellRenderer 
 */

int nsp_type_gtkcellrendererpixbuf_id=0;
NspTypeGtkCellRendererPixbuf *nsp_type_gtkcellrendererpixbuf=NULL;

/*
 * Type object for NspGtkCellRendererPixbuf 
 * all the instance of NspTypeGtkCellRendererPixbuf share the same id. 
 * nsp_type_gtkcellrendererpixbuf: is an instance of NspTypeGtkCellRendererPixbuf 
 *    used for objects of NspGtkCellRendererPixbuf type (i.e built with new_gtkcellrendererpixbuf) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellRendererPixbuf *new_type_gtkcellrendererpixbuf(type_mode mode)
{
  NspTypeGtkCellRendererPixbuf *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrendererpixbuf != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrendererpixbuf;
    }
  if (( type =  malloc(sizeof(NspTypeGtkCellRenderer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellrenderer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrendererpixbuf_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellrendererpixbuf_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellrendererpixbuf;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellrendererpixbuf */ 

  top->s_type =  (s_type_func *) nsp_gtkcellrendererpixbuf_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellrendererpixbuf_type_short_string;
  /* top->create = (create_func*) int_gtkcellrendererpixbuf_create;*/

  /* specific methods for gtkcellrendererpixbuf */

  type->init = (init_func *) init_gtkcellrendererpixbuf;

  /* 
   * NspGtkCellRendererPixbuf interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcellrendererpixbuf_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRendererPixbuf called nsp_type_gtkcellrendererpixbuf
       */
      type->id =  nsp_type_gtkcellrendererpixbuf_id = nsp_new_type_id();
      nsp_type_gtkcellrendererpixbuf = type;
      if ( nsp_register_type(nsp_type_gtkcellrendererpixbuf) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrendererpixbuf, GTK_TYPE_CELL_RENDERER_PIXBUF);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrendererpixbuf(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellrendererpixbuf_id;
      return type;
    }
}

/*
 * initialize NspGtkCellRendererPixbuf instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrendererpixbuf(NspGtkCellRendererPixbuf *Obj,NspTypeGtkCellRendererPixbuf *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellRendererPixbuf 
 */

NspGtkCellRendererPixbuf *new_gtkcellrendererpixbuf() 
{
  NspGtkCellRendererPixbuf *loc;
  /* type must exists */
  nsp_type_gtkcellrendererpixbuf = new_type_gtkcellrendererpixbuf(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRendererPixbuf)))== NULLGTKCELLRENDERERPIXBUF) return loc;
  /* initialize object */
  if ( init_gtkcellrendererpixbuf(loc,nsp_type_gtkcellrendererpixbuf) == FAIL) return NULLGTKCELLRENDERERPIXBUF;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellRendererPixbuf 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellrendererpixbuf_type_name[]="GtkCellRendererPixbuf";
static char gtkcellrendererpixbuf_short_type_name[]="GtkCellRendererPixbuf";

static char *nsp_gtkcellrendererpixbuf_type_as_string(void)
{
  return(gtkcellrendererpixbuf_type_name);
}

static char *nsp_gtkcellrendererpixbuf_type_short_string(NspObject *v)
{
  return(gtkcellrendererpixbuf_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellRendererPixbuf objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellRendererPixbuf   *nsp_gtkcellrendererpixbuf_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellrendererpixbuf_id)  == TRUE  ) return ((NspGtkCellRendererPixbuf *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrendererpixbuf));
  return NULL;
}

int IsGtkCellRendererPixbufObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellrendererpixbuf_id);
}

int IsGtkCellRendererPixbuf(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrendererpixbuf_id);
}

NspGtkCellRendererPixbuf  *GetGtkCellRendererPixbufCopy(Stack stack, int i)
{
  if (  GetGtkCellRendererPixbuf(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRendererPixbuf  *GetGtkCellRendererPixbuf(Stack stack, int i)
{
  NspGtkCellRendererPixbuf *M;
  if (( M = nsp_gtkcellrendererpixbuf_object(NthObj(i))) == NULLGTKCELLRENDERERPIXBUF)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRendererPixbuf *gtkcellrendererpixbuf_copy(NspGtkCellRendererPixbuf *self)
{
  /* return gtkcellrenderer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendererpixbuf);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendererpixbuf);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRendererPixbuf
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_cell_renderer_pixbuf_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_renderer_pixbuf_new())== NULL) return RET_BUG;

  nsp_type_gtkcellrendererpixbuf = new_type_gtkcellrendererpixbuf(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellrendererpixbuf);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkcellrendererpixbuf_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrendererpixbuf_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellRendererProgress ----------- */


#define  NspGtkCellRendererProgress_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellrendererprogress.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellRendererProgress inherits from GtkCellRenderer 
 */

int nsp_type_gtkcellrendererprogress_id=0;
NspTypeGtkCellRendererProgress *nsp_type_gtkcellrendererprogress=NULL;

/*
 * Type object for NspGtkCellRendererProgress 
 * all the instance of NspTypeGtkCellRendererProgress share the same id. 
 * nsp_type_gtkcellrendererprogress: is an instance of NspTypeGtkCellRendererProgress 
 *    used for objects of NspGtkCellRendererProgress type (i.e built with new_gtkcellrendererprogress) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellRendererProgress *new_type_gtkcellrendererprogress(type_mode mode)
{
  NspTypeGtkCellRendererProgress *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrendererprogress != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrendererprogress;
    }
  if (( type =  malloc(sizeof(NspTypeGtkCellRenderer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellrenderer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrendererprogress_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellrendererprogress_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellrendererprogress;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellrendererprogress */ 

  top->s_type =  (s_type_func *) nsp_gtkcellrendererprogress_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellrendererprogress_type_short_string;
  /* top->create = (create_func*) int_gtkcellrendererprogress_create;*/

  /* specific methods for gtkcellrendererprogress */

  type->init = (init_func *) init_gtkcellrendererprogress;

  /* 
   * NspGtkCellRendererProgress interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcellrendererprogress_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRendererProgress called nsp_type_gtkcellrendererprogress
       */
      type->id =  nsp_type_gtkcellrendererprogress_id = nsp_new_type_id();
      nsp_type_gtkcellrendererprogress = type;
      if ( nsp_register_type(nsp_type_gtkcellrendererprogress) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrendererprogress, GTK_TYPE_CELL_RENDERER_PROGRESS);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrendererprogress(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellrendererprogress_id;
      return type;
    }
}

/*
 * initialize NspGtkCellRendererProgress instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrendererprogress(NspGtkCellRendererProgress *Obj,NspTypeGtkCellRendererProgress *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellRendererProgress 
 */

NspGtkCellRendererProgress *new_gtkcellrendererprogress() 
{
  NspGtkCellRendererProgress *loc;
  /* type must exists */
  nsp_type_gtkcellrendererprogress = new_type_gtkcellrendererprogress(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRendererProgress)))== NULLGTKCELLRENDERERPROGRESS) return loc;
  /* initialize object */
  if ( init_gtkcellrendererprogress(loc,nsp_type_gtkcellrendererprogress) == FAIL) return NULLGTKCELLRENDERERPROGRESS;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellRendererProgress 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellrendererprogress_type_name[]="GtkCellRendererProgress";
static char gtkcellrendererprogress_short_type_name[]="GtkCellRendererProgress";

static char *nsp_gtkcellrendererprogress_type_as_string(void)
{
  return(gtkcellrendererprogress_type_name);
}

static char *nsp_gtkcellrendererprogress_type_short_string(NspObject *v)
{
  return(gtkcellrendererprogress_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellRendererProgress objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellRendererProgress   *nsp_gtkcellrendererprogress_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellrendererprogress_id)  == TRUE  ) return ((NspGtkCellRendererProgress *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrendererprogress));
  return NULL;
}

int IsGtkCellRendererProgressObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellrendererprogress_id);
}

int IsGtkCellRendererProgress(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrendererprogress_id);
}

NspGtkCellRendererProgress  *GetGtkCellRendererProgressCopy(Stack stack, int i)
{
  if (  GetGtkCellRendererProgress(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRendererProgress  *GetGtkCellRendererProgress(Stack stack, int i)
{
  NspGtkCellRendererProgress *M;
  if (( M = nsp_gtkcellrendererprogress_object(NthObj(i))) == NULLGTKCELLRENDERERPROGRESS)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRendererProgress *gtkcellrendererprogress_copy(NspGtkCellRendererProgress *self)
{
  /* return gtkcellrenderer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendererprogress);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendererprogress);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRendererProgress
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_cell_renderer_progress_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_renderer_progress_new())== NULL) return RET_BUG;

  nsp_type_gtkcellrendererprogress = new_type_gtkcellrendererprogress(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellrendererprogress);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkcellrendererprogress_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrendererprogress_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellRendererSpin ----------- */


#define  NspGtkCellRendererSpin_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellrendererspin.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellRendererSpin inherits from GtkCellRendererText 
 */

int nsp_type_gtkcellrendererspin_id=0;
NspTypeGtkCellRendererSpin *nsp_type_gtkcellrendererspin=NULL;

/*
 * Type object for NspGtkCellRendererSpin 
 * all the instance of NspTypeGtkCellRendererSpin share the same id. 
 * nsp_type_gtkcellrendererspin: is an instance of NspTypeGtkCellRendererSpin 
 *    used for objects of NspGtkCellRendererSpin type (i.e built with new_gtkcellrendererspin) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellRendererSpin *new_type_gtkcellrendererspin(type_mode mode)
{
  NspTypeGtkCellRendererSpin *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrendererspin != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrendererspin;
    }
  if (( type =  malloc(sizeof(NspTypeGtkCellRendererText))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellrenderertext(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrendererspin_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellrendererspin_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellrendererspin;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellrendererspin */ 

  top->s_type =  (s_type_func *) nsp_gtkcellrendererspin_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellrendererspin_type_short_string;
  /* top->create = (create_func*) int_gtkcellrendererspin_create;*/

  /* specific methods for gtkcellrendererspin */

  type->init = (init_func *) init_gtkcellrendererspin;

  /* 
   * NspGtkCellRendererSpin interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcellrendererspin_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRendererSpin called nsp_type_gtkcellrendererspin
       */
      type->id =  nsp_type_gtkcellrendererspin_id = nsp_new_type_id();
      nsp_type_gtkcellrendererspin = type;
      if ( nsp_register_type(nsp_type_gtkcellrendererspin) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrendererspin, GTK_TYPE_CELL_RENDERER_SPIN);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrendererspin(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellrendererspin_id;
      return type;
    }
}

/*
 * initialize NspGtkCellRendererSpin instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrendererspin(NspGtkCellRendererSpin *Obj,NspTypeGtkCellRendererSpin *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellRendererSpin 
 */

NspGtkCellRendererSpin *new_gtkcellrendererspin() 
{
  NspGtkCellRendererSpin *loc;
  /* type must exists */
  nsp_type_gtkcellrendererspin = new_type_gtkcellrendererspin(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRendererSpin)))== NULLGTKCELLRENDERERSPIN) return loc;
  /* initialize object */
  if ( init_gtkcellrendererspin(loc,nsp_type_gtkcellrendererspin) == FAIL) return NULLGTKCELLRENDERERSPIN;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellRendererSpin 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellrendererspin_type_name[]="GtkCellRendererSpin";
static char gtkcellrendererspin_short_type_name[]="GtkCellRendererSpin";

static char *nsp_gtkcellrendererspin_type_as_string(void)
{
  return(gtkcellrendererspin_type_name);
}

static char *nsp_gtkcellrendererspin_type_short_string(NspObject *v)
{
  return(gtkcellrendererspin_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellRendererSpin objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellRendererSpin   *nsp_gtkcellrendererspin_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellrendererspin_id)  == TRUE  ) return ((NspGtkCellRendererSpin *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrendererspin));
  return NULL;
}

int IsGtkCellRendererSpinObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellrendererspin_id);
}

int IsGtkCellRendererSpin(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrendererspin_id);
}

NspGtkCellRendererSpin  *GetGtkCellRendererSpinCopy(Stack stack, int i)
{
  if (  GetGtkCellRendererSpin(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRendererSpin  *GetGtkCellRendererSpin(Stack stack, int i)
{
  NspGtkCellRendererSpin *M;
  if (( M = nsp_gtkcellrendererspin_object(NthObj(i))) == NULLGTKCELLRENDERERSPIN)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRendererSpin *gtkcellrendererspin_copy(NspGtkCellRendererSpin *self)
{
  /* return gtkcellrenderertext_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendererspin);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendererspin);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRendererSpin
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_cell_renderer_spin_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_renderer_spin_new())== NULL) return RET_BUG;

  nsp_type_gtkcellrendererspin = new_type_gtkcellrendererspin(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellrendererspin);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkcellrendererspin_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrendererspin_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellRendererText ----------- */


#define  NspGtkCellRendererText_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellrenderertext.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellRendererText inherits from GtkCellRenderer 
 */

int nsp_type_gtkcellrenderertext_id=0;
NspTypeGtkCellRendererText *nsp_type_gtkcellrenderertext=NULL;

/*
 * Type object for NspGtkCellRendererText 
 * all the instance of NspTypeGtkCellRendererText share the same id. 
 * nsp_type_gtkcellrenderertext: is an instance of NspTypeGtkCellRendererText 
 *    used for objects of NspGtkCellRendererText type (i.e built with new_gtkcellrenderertext) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellRendererText *new_type_gtkcellrenderertext(type_mode mode)
{
  NspTypeGtkCellRendererText *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrenderertext != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrenderertext;
    }
  if (( type =  malloc(sizeof(NspTypeGtkCellRenderer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellrenderer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrenderertext_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellrenderertext_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellrenderertext;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellrenderertext */ 

  top->s_type =  (s_type_func *) nsp_gtkcellrenderertext_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellrenderertext_type_short_string;
  /* top->create = (create_func*) int_gtkcellrenderertext_create;*/

  /* specific methods for gtkcellrenderertext */

  type->init = (init_func *) init_gtkcellrenderertext;

  /* 
   * NspGtkCellRendererText interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcellrenderertext_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRendererText called nsp_type_gtkcellrenderertext
       */
      type->id =  nsp_type_gtkcellrenderertext_id = nsp_new_type_id();
      nsp_type_gtkcellrenderertext = type;
      if ( nsp_register_type(nsp_type_gtkcellrenderertext) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrenderertext, GTK_TYPE_CELL_RENDERER_TEXT);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrenderertext(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellrenderertext_id;
      return type;
    }
}

/*
 * initialize NspGtkCellRendererText instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrenderertext(NspGtkCellRendererText *Obj,NspTypeGtkCellRendererText *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellRendererText 
 */

NspGtkCellRendererText *new_gtkcellrenderertext() 
{
  NspGtkCellRendererText *loc;
  /* type must exists */
  nsp_type_gtkcellrenderertext = new_type_gtkcellrenderertext(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRendererText)))== NULLGTKCELLRENDERERTEXT) return loc;
  /* initialize object */
  if ( init_gtkcellrenderertext(loc,nsp_type_gtkcellrenderertext) == FAIL) return NULLGTKCELLRENDERERTEXT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellRendererText 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellrenderertext_type_name[]="GtkCellRendererText";
static char gtkcellrenderertext_short_type_name[]="GtkCellRendererText";

static char *nsp_gtkcellrenderertext_type_as_string(void)
{
  return(gtkcellrenderertext_type_name);
}

static char *nsp_gtkcellrenderertext_type_short_string(NspObject *v)
{
  return(gtkcellrenderertext_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellRendererText objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellRendererText   *nsp_gtkcellrenderertext_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellrenderertext_id)  == TRUE  ) return ((NspGtkCellRendererText *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrenderertext));
  return NULL;
}

int IsGtkCellRendererTextObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellrenderertext_id);
}

int IsGtkCellRendererText(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrenderertext_id);
}

NspGtkCellRendererText  *GetGtkCellRendererTextCopy(Stack stack, int i)
{
  if (  GetGtkCellRendererText(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRendererText  *GetGtkCellRendererText(Stack stack, int i)
{
  NspGtkCellRendererText *M;
  if (( M = nsp_gtkcellrenderertext_object(NthObj(i))) == NULLGTKCELLRENDERERTEXT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRendererText *gtkcellrenderertext_copy(NspGtkCellRendererText *self)
{
  /* return gtkcellrenderer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderertext);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderertext);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRendererText
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_cell_renderer_text_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_renderer_text_new())== NULL) return RET_BUG;

  nsp_type_gtkcellrenderertext = new_type_gtkcellrenderertext(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellrenderertext);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_renderer_text_set_fixed_height_from_font(NspGtkCellRendererText *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int number_of_rows;
  if ( GetArgs(stack,rhs,opt,T,&number_of_rows) == FAIL) return RET_BUG;
    gtk_cell_renderer_text_set_fixed_height_from_font(GTK_CELL_RENDERER_TEXT(self->obj),number_of_rows);
  return 0;
}

static NspMethods gtkcellrenderertext_methods[] = {
  {"set_fixed_height_from_font",(nsp_method *) _wrap_gtk_cell_renderer_text_set_fixed_height_from_font},
  { NULL, NULL}
};

static NspMethods *gtkcellrenderertext_get_methods(void) { return gtkcellrenderertext_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrenderertext_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellRendererToggle ----------- */


#define  NspGtkCellRendererToggle_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellrenderertoggle.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellRendererToggle inherits from GtkCellRenderer 
 */

int nsp_type_gtkcellrenderertoggle_id=0;
NspTypeGtkCellRendererToggle *nsp_type_gtkcellrenderertoggle=NULL;

/*
 * Type object for NspGtkCellRendererToggle 
 * all the instance of NspTypeGtkCellRendererToggle share the same id. 
 * nsp_type_gtkcellrenderertoggle: is an instance of NspTypeGtkCellRendererToggle 
 *    used for objects of NspGtkCellRendererToggle type (i.e built with new_gtkcellrenderertoggle) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellRendererToggle *new_type_gtkcellrenderertoggle(type_mode mode)
{
  NspTypeGtkCellRendererToggle *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrenderertoggle != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrenderertoggle;
    }
  if (( type =  malloc(sizeof(NspTypeGtkCellRenderer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellrenderer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrenderertoggle_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellrenderertoggle_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellrenderertoggle;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellrenderertoggle */ 

  top->s_type =  (s_type_func *) nsp_gtkcellrenderertoggle_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellrenderertoggle_type_short_string;
  /* top->create = (create_func*) int_gtkcellrenderertoggle_create;*/

  /* specific methods for gtkcellrenderertoggle */

  type->init = (init_func *) init_gtkcellrenderertoggle;

  /* 
   * NspGtkCellRendererToggle interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcellrenderertoggle_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRendererToggle called nsp_type_gtkcellrenderertoggle
       */
      type->id =  nsp_type_gtkcellrenderertoggle_id = nsp_new_type_id();
      nsp_type_gtkcellrenderertoggle = type;
      if ( nsp_register_type(nsp_type_gtkcellrenderertoggle) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrenderertoggle, GTK_TYPE_CELL_RENDERER_TOGGLE);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrenderertoggle(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellrenderertoggle_id;
      return type;
    }
}

/*
 * initialize NspGtkCellRendererToggle instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrenderertoggle(NspGtkCellRendererToggle *Obj,NspTypeGtkCellRendererToggle *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellRendererToggle 
 */

NspGtkCellRendererToggle *new_gtkcellrenderertoggle() 
{
  NspGtkCellRendererToggle *loc;
  /* type must exists */
  nsp_type_gtkcellrenderertoggle = new_type_gtkcellrenderertoggle(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRendererToggle)))== NULLGTKCELLRENDERERTOGGLE) return loc;
  /* initialize object */
  if ( init_gtkcellrenderertoggle(loc,nsp_type_gtkcellrenderertoggle) == FAIL) return NULLGTKCELLRENDERERTOGGLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellRendererToggle 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellrenderertoggle_type_name[]="GtkCellRendererToggle";
static char gtkcellrenderertoggle_short_type_name[]="GtkCellRendererToggle";

static char *nsp_gtkcellrenderertoggle_type_as_string(void)
{
  return(gtkcellrenderertoggle_type_name);
}

static char *nsp_gtkcellrenderertoggle_type_short_string(NspObject *v)
{
  return(gtkcellrenderertoggle_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellRendererToggle objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellRendererToggle   *nsp_gtkcellrenderertoggle_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellrenderertoggle_id)  == TRUE  ) return ((NspGtkCellRendererToggle *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrenderertoggle));
  return NULL;
}

int IsGtkCellRendererToggleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellrenderertoggle_id);
}

int IsGtkCellRendererToggle(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrenderertoggle_id);
}

NspGtkCellRendererToggle  *GetGtkCellRendererToggleCopy(Stack stack, int i)
{
  if (  GetGtkCellRendererToggle(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRendererToggle  *GetGtkCellRendererToggle(Stack stack, int i)
{
  NspGtkCellRendererToggle *M;
  if (( M = nsp_gtkcellrenderertoggle_object(NthObj(i))) == NULLGTKCELLRENDERERTOGGLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRendererToggle *gtkcellrenderertoggle_copy(NspGtkCellRendererToggle *self)
{
  /* return gtkcellrenderer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderertoggle);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrenderertoggle);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRendererToggle
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_cell_renderer_toggle_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_renderer_toggle_new())== NULL) return RET_BUG;

  nsp_type_gtkcellrenderertoggle = new_type_gtkcellrenderertoggle(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellrenderertoggle);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_cell_renderer_toggle_get_radio(NspGtkCellRendererToggle *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_cell_renderer_toggle_get_radio(GTK_CELL_RENDERER_TOGGLE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_renderer_toggle_set_radio(NspGtkCellRendererToggle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int radio;
  if ( GetArgs(stack,rhs,opt,T,&radio) == FAIL) return RET_BUG;
    gtk_cell_renderer_toggle_set_radio(GTK_CELL_RENDERER_TOGGLE(self->obj),radio);
  return 0;
}

static int _wrap_gtk_cell_renderer_toggle_get_active(NspGtkCellRendererToggle *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_cell_renderer_toggle_get_active(GTK_CELL_RENDERER_TOGGLE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_renderer_toggle_set_active(NspGtkCellRendererToggle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_cell_renderer_toggle_set_active(GTK_CELL_RENDERER_TOGGLE(self->obj),setting);
  return 0;
}

static int _wrap_gtk_cell_renderer_toggle_get_activatable(NspGtkCellRendererToggle *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_cell_renderer_toggle_get_activatable(GTK_CELL_RENDERER_TOGGLE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_cell_renderer_toggle_set_activatable(NspGtkCellRendererToggle *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_cell_renderer_toggle_set_activatable(GTK_CELL_RENDERER_TOGGLE(self->obj),setting);
  return 0;
}

static NspMethods gtkcellrenderertoggle_methods[] = {
  {"get_radio",(nsp_method *) _wrap_gtk_cell_renderer_toggle_get_radio},
  {"set_radio",(nsp_method *) _wrap_gtk_cell_renderer_toggle_set_radio},
  {"get_active",(nsp_method *) _wrap_gtk_cell_renderer_toggle_get_active},
  {"set_active",(nsp_method *) _wrap_gtk_cell_renderer_toggle_set_active},
  {"get_activatable",(nsp_method *) _wrap_gtk_cell_renderer_toggle_get_activatable},
  {"set_activatable",(nsp_method *) _wrap_gtk_cell_renderer_toggle_set_activatable},
  { NULL, NULL}
};

static NspMethods *gtkcellrenderertoggle_get_methods(void) { return gtkcellrenderertoggle_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrenderertoggle_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCellRendererSpinner ----------- */


#define  NspGtkCellRendererSpinner_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcellrendererspinner.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCellRendererSpinner inherits from GtkCellRenderer 
 */

int nsp_type_gtkcellrendererspinner_id=0;
NspTypeGtkCellRendererSpinner *nsp_type_gtkcellrendererspinner=NULL;

/*
 * Type object for NspGtkCellRendererSpinner 
 * all the instance of NspTypeGtkCellRendererSpinner share the same id. 
 * nsp_type_gtkcellrendererspinner: is an instance of NspTypeGtkCellRendererSpinner 
 *    used for objects of NspGtkCellRendererSpinner type (i.e built with new_gtkcellrendererspinner) 
 * other instances are used for derived classes 
 */
NspTypeGtkCellRendererSpinner *new_type_gtkcellrendererspinner(type_mode mode)
{
  NspTypeGtkCellRendererSpinner *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcellrendererspinner != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcellrendererspinner;
    }
  if (( type =  malloc(sizeof(NspTypeGtkCellRenderer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcellrenderer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcellrendererspinner_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcellrendererspinner_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcellrendererspinner;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcellrendererspinner */ 

  top->s_type =  (s_type_func *) nsp_gtkcellrendererspinner_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcellrendererspinner_type_short_string;
  /* top->create = (create_func*) int_gtkcellrendererspinner_create;*/

  /* specific methods for gtkcellrendererspinner */

  type->init = (init_func *) init_gtkcellrendererspinner;

  /* 
   * NspGtkCellRendererSpinner interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcellrendererspinner_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCellRendererSpinner called nsp_type_gtkcellrendererspinner
       */
      type->id =  nsp_type_gtkcellrendererspinner_id = nsp_new_type_id();
      nsp_type_gtkcellrendererspinner = type;
      if ( nsp_register_type(nsp_type_gtkcellrendererspinner) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcellrendererspinner, GTK_TYPE_CELL_RENDERER_SPINNER);
      return ( mode == T_BASE ) ? type : new_type_gtkcellrendererspinner(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcellrendererspinner_id;
      return type;
    }
}

/*
 * initialize NspGtkCellRendererSpinner instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcellrendererspinner(NspGtkCellRendererSpinner *Obj,NspTypeGtkCellRendererSpinner *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCellRendererSpinner 
 */

NspGtkCellRendererSpinner *new_gtkcellrendererspinner() 
{
  NspGtkCellRendererSpinner *loc;
  /* type must exists */
  nsp_type_gtkcellrendererspinner = new_type_gtkcellrendererspinner(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCellRendererSpinner)))== NULLGTKCELLRENDERERSPINNER) return loc;
  /* initialize object */
  if ( init_gtkcellrendererspinner(loc,nsp_type_gtkcellrendererspinner) == FAIL) return NULLGTKCELLRENDERERSPINNER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCellRendererSpinner 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcellrendererspinner_type_name[]="GtkCellRendererSpinner";
static char gtkcellrendererspinner_short_type_name[]="GtkCellRendererSpinner";

static char *nsp_gtkcellrendererspinner_type_as_string(void)
{
  return(gtkcellrendererspinner_type_name);
}

static char *nsp_gtkcellrendererspinner_type_short_string(NspObject *v)
{
  return(gtkcellrendererspinner_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCellRendererSpinner objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCellRendererSpinner   *nsp_gtkcellrendererspinner_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcellrendererspinner_id)  == TRUE  ) return ((NspGtkCellRendererSpinner *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcellrendererspinner));
  return NULL;
}

int IsGtkCellRendererSpinnerObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcellrendererspinner_id);
}

int IsGtkCellRendererSpinner(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcellrendererspinner_id);
}

NspGtkCellRendererSpinner  *GetGtkCellRendererSpinnerCopy(Stack stack, int i)
{
  if (  GetGtkCellRendererSpinner(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCellRendererSpinner  *GetGtkCellRendererSpinner(Stack stack, int i)
{
  NspGtkCellRendererSpinner *M;
  if (( M = nsp_gtkcellrendererspinner_object(NthObj(i))) == NULLGTKCELLRENDERERSPINNER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCellRendererSpinner *gtkcellrendererspinner_copy(NspGtkCellRendererSpinner *self)
{
  /* return gtkcellrenderer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendererspinner);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcellrendererspinner);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCellRendererSpinner
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_cell_renderer_spinner_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_cell_renderer_spinner_new())== NULL) return RET_BUG;

  nsp_type_gtkcellrendererspinner = new_type_gtkcellrendererspinner(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcellrendererspinner);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkcellrendererspinner_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcellrendererspinner_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkListStore ----------- */


#define  NspGtkListStore_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkliststore.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkListStore inherits from GObject 
 * and implements GtkTreeModel GtkTreeDragSource GtkTreeDragDest GtkTreeSortable GtkBuildable
 */

int nsp_type_gtkliststore_id=0;
NspTypeGtkListStore *nsp_type_gtkliststore=NULL;

/*
 * Type object for NspGtkListStore 
 * all the instance of NspTypeGtkListStore share the same id. 
 * nsp_type_gtkliststore: is an instance of NspTypeGtkListStore 
 *    used for objects of NspGtkListStore type (i.e built with new_gtkliststore) 
 * other instances are used for derived classes 
 */
NspTypeGtkListStore *new_type_gtkliststore(type_mode mode)
{
  NspTypeGtkTreeModel *t_gtktreemodel;
  NspTypeGtkTreeDragSource *t_gtktreedragsource;
  NspTypeGtkTreeDragDest *t_gtktreedragdest;
  NspTypeGtkTreeSortable *t_gtktreesortable;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkListStore *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkliststore != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkliststore;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkliststore_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkliststore_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkliststore;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkliststore */ 

  top->s_type =  (s_type_func *) nsp_gtkliststore_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkliststore_type_short_string;
  /* top->create = (create_func*) int_gtkliststore_create;*/

  /* specific methods for gtkliststore */

  type->init = (init_func *) init_gtkliststore;

  /* 
   * NspGtkListStore interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtktreemodel = new_type_gtktreemodel(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtktreemodel;
  t_gtktreedragsource = new_type_gtktreedragsource(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtktreedragsource;
  t_gtktreedragdest = new_type_gtktreedragdest(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gtktreedragdest;
  t_gtktreesortable = new_type_gtktreesortable(T_DERIVED);
  type->interface->interface->interface->interface = (NspTypeBase * ) t_gtktreesortable;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface->interface->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkliststore_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkListStore called nsp_type_gtkliststore
       */
      type->id =  nsp_type_gtkliststore_id = nsp_new_type_id();
      nsp_type_gtkliststore = type;
      if ( nsp_register_type(nsp_type_gtkliststore) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkliststore, GTK_TYPE_LIST_STORE);
      return ( mode == T_BASE ) ? type : new_type_gtkliststore(mode);
    }
  else 
    {
      type->id = nsp_type_gtkliststore_id;
      return type;
    }
}

/*
 * initialize NspGtkListStore instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkliststore(NspGtkListStore *Obj,NspTypeGtkListStore *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkListStore 
 */

NspGtkListStore *new_gtkliststore() 
{
  NspGtkListStore *loc;
  /* type must exists */
  nsp_type_gtkliststore = new_type_gtkliststore(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkListStore)))== NULLGTKLISTSTORE) return loc;
  /* initialize object */
  if ( init_gtkliststore(loc,nsp_type_gtkliststore) == FAIL) return NULLGTKLISTSTORE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkListStore 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkliststore_type_name[]="GtkListStore";
static char gtkliststore_short_type_name[]="GtkListStore";

static char *nsp_gtkliststore_type_as_string(void)
{
  return(gtkliststore_type_name);
}

static char *nsp_gtkliststore_type_short_string(NspObject *v)
{
  return(gtkliststore_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkListStore objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkListStore   *nsp_gtkliststore_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkliststore_id)  == TRUE  ) return ((NspGtkListStore *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkliststore));
  return NULL;
}

int IsGtkListStoreObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkliststore_id);
}

int IsGtkListStore(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkliststore_id);
}

NspGtkListStore  *GetGtkListStoreCopy(Stack stack, int i)
{
  if (  GetGtkListStore(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkListStore  *GetGtkListStore(Stack stack, int i)
{
  NspGtkListStore *M;
  if (( M = nsp_gtkliststore_object(NthObj(i))) == NULLGTKLISTSTORE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkListStore *gtkliststore_copy(NspGtkListStore *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkliststore);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkliststore);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkListStore
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 1788 "codegen-3.0/gtk.override"

static int
_wrap_gtk_list_store_new(Stack stack,int rhs,int opt,int lhs)
{
  int flag = TRUE;
  NspObject *ret;
  GObject *gobj;
  CheckRhs(1,2);
  if ( opt != 0 ) {
    Scierror("GtkListStore do not accept optional named arguments");
    return RET_BUG;
  }

  if (rhs == 2)
    {
      if ( GetScalarBool(stack,2,&flag) == FAIL) { return FAIL;}
    }

  if ( IsMatObj(stack,1))
    {
      /* building a liststore from a Matrix */
      NspMatrix *M;
      if ((M = GetRealMat(stack,1)) == NULLMAT) return RET_BUG;
      /* we build a list store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_list_store_from_mat(M))== NULL)
	return RET_BUG;
    }
  else if ( IsSMatObj(stack,1))
    {
      /* building a liststore from a string matrix  */
      NspSMatrix *M;
      if ((M = GetSMat(stack,1)) == NULLSMAT) return RET_BUG;
      /* we build a list store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_list_store_from_smat(M))== NULL)
	return RET_BUG;
    }
  else if ( IsBMatObj(stack,1))
    {
      /* building a liststore from a boolean matrix  */
      NspBMatrix *M;
      if ((M = GetBMat(stack,1)) == NULLBMAT) return RET_BUG;
      /* we build a list store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_list_store_from_bmat(M))== NULL)
	return RET_BUG;
    }
  else if ( IsListObj(stack,1))
    {
      /* building a liststore from a list */
      NspList *l;
      if ((l = GetList(stack,1)) == NULL) return RET_BUG;
      if ((gobj = (GObject *) nsp_gtk_list_store_from_list(l,flag))== NULL)
	return RET_BUG;
    }
  else
    {
      Scierror("%s: firts argument has a wrong type \n",NspFname(stack));
      return RET_BUG;
    }
  if (( ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkliststore))== NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 47303 "gtk.c"


static int _wrap_nsp_get_matrix_from_list_store(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  CheckRhs(0,0);
    ret =nsp_get_matrix_from_list_store(GTK_LIST_STORE(self->obj));
  if (ret == NULLOBJ ) return RET_BUG;
MoveObj(stack,1,ret);
  return 1;
}

static int _wrap_nsp_get_list_from_list_store(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  CheckRhs(0,0);
    ret =nsp_get_list_from_list_store(GTK_LIST_STORE(self->obj));
  if (ret == NULLOBJ ) return RET_BUG;
MoveObj(stack,1,ret);
  return 1;
}

#line 1855 "codegen-3.0/gtk.override"
/* Usage:
 *   set[iter,col,value]
 *   set[iter,list(...)]
 *   if list gives mores than one row then the list store is extented
 *   the iterator if given is not changed
 */
static int
_wrap_gtk_list_store_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_iter=NULL;GtkTreeIter *p_iter;
  gint column;
  GValue value = { 0 }; NspObject *nsp_value;
  NspList *list;
  CheckRhs(1,3);
  if ( rhs == 1 )
    {
      if ((list = GetList(stack,1))== NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj),NULL,NULL,list)== FAIL)
	return RET_BUG;
     }
  else
    {
      if (( nsp_iter = (NspObject *) GetGtkTreeIter(stack,1))== NULL) return RET_BUG;
      p_iter = nspg_boxed_get(nsp_iter,GtkTreeIter);
      if ( rhs == 2 )
	{
	  if ((list = GetList(stack,2))== NULL) return RET_BUG;
	  if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj),p_iter,NULL,list)== FAIL)
	    return RET_BUG;
	}
      else
	{
	  int n_cols = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
	  if (GetScalarInt(stack,2,&column) == FAIL) return RET_BUG;
	  if ((nsp_value =nsp_get_object(stack,3))== NULLOBJ) return RET_BUG;
	  if (column < 0 || column >= n_cols)
	    {
	      Scierror("column number is out of range [0,%d]",n_cols);
	      return RET_BUG;
	    }
	  g_value_init(&value,gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),column));
	  if (nspg_value_from_nspobject(&value, nsp_value)) {
	    Scierror("value (%s) is of the wrong type for column %d\n",nsp_value->type->s_type(),column);
	    return RET_BUG;
	  }
	  gtk_list_store_set_value(GTK_LIST_STORE(self->obj),p_iter,column, &value);
	  g_value_unset(&value);
	}
    }
  return 0;
}
#line 47378 "gtk.c"


static int _wrap_gtk_list_store_remove(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_list_store_remove(GTK_LIST_STORE(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 1910 "codegen-3.0/gtk.override"
static int
_wrap_gtk_list_store_insert(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  gint position;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(1,2);
  if ( GetScalarInt(stack,1,&position)== FAIL) return RET_BUG;
  gtk_list_store_insert(GTK_LIST_STORE(self->obj), &iter, position);

  if ( rhs == 2 )
    {
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if (  nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row)== FAIL) return RET_BUG;
    }

  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 47423 "gtk.c"


#line 1935 "codegen-3.0/gtk.override"
static int
_wrap_gtk_list_store_insert_before(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGtkTreeIter  *sibling;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(1,2);
  if (( sibling = GetGtkTreeIter(stack,1))== NULL) return RET_BUG;
  gtk_list_store_insert_before(GTK_LIST_STORE(self->obj), &iter,
			       nspg_boxed_get(sibling, GtkTreeIter));
  if ( rhs == 2)
    {
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) ==FAIL)
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 47450 "gtk.c"


#line 1960 "codegen-3.0/gtk.override"
static int
_wrap_gtk_list_store_insert_after(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGtkTreeIter  *sibling;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(1,2);
  if (( sibling = GetGtkTreeIter(stack,1))== NULL) return RET_BUG;
  gtk_list_store_insert_after(GTK_LIST_STORE(self->obj), &iter,
			       nspg_boxed_get(sibling, GtkTreeIter));
  if ( rhs == 2)
    {
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) ==FAIL)
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 47477 "gtk.c"


static int _wrap_gtk_list_store_insert_with_values(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &position) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_list_store_insert_with_values(GTK_LIST_STORE(self->obj),iter,position);
  return 0;
}

#line 1985 "codegen-3.0/gtk.override"
static int
_wrap_gtk_list_store_prepend(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(0,1);
  gtk_list_store_prepend(GTK_LIST_STORE(self->obj), &iter);

  if ( rhs == 1 )
    {
      if (( row = GetList(stack,1)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) == FAIL)
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 47519 "gtk.c"


#line 2008 "codegen-3.0/gtk.override"
static int
_wrap_gtk_list_store_append(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;

  CheckRhs(0,1);
  gtk_list_store_append(GTK_LIST_STORE(self->obj), &iter);

  if ( rhs == 1 )
    {
      if (( row = GetList(stack,1)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,NULL, row) == FAIL)
	return RET_BUG;
    }

  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 47545 "gtk.c"


static int _wrap_gtk_list_store_clear(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_list_store_clear(GTK_LIST_STORE(self->obj));
  return 0;
}

static int _wrap_gtk_list_store_iter_is_valid(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_list_store_iter_is_valid(GTK_LIST_STORE(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_list_store_reorder(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int new_order;
  if ( GetArgs(stack,rhs,opt,T,&new_order) == FAIL) return RET_BUG;
    gtk_list_store_reorder(GTK_LIST_STORE(self->obj),&new_order);
  return 0;
}

static int _wrap_gtk_list_store_swap(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreeIter *a = NULL, *b = NULL;
  NspObject *nsp_a = NULL, *nsp_b = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_a, &nsp_b) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_a, GTK_TYPE_TREE_ITER))
      a = nspg_boxed_get(nsp_a, GtkTreeIter);
  else {
      Scierror( "Error: a should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_b, GTK_TYPE_TREE_ITER))
      b = nspg_boxed_get(nsp_b, GtkTreeIter);
  else {
      Scierror( "Error: b should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_list_store_swap(GTK_LIST_STORE(self->obj),a,b);
  return 0;
}

static int _wrap_gtk_list_store_move_after(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,new_opts, t_end};
  nsp_option opts[] = {
	{"position",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreeIter *iter = NULL, *position = NULL;
  NspObject *nsp_iter = NULL, *nsp_position = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, opts, &nsp_position) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if ( nsp_position != NULL ) {
    if (nspg_boxed_check(nsp_position, GTK_TYPE_TREE_ITER))
      position = nspg_boxed_get(nsp_position, GtkTreeIter);
    else if (! IsNone(nsp_position)) {
      Scierror("Error: position should be a GtkTreeIter or None\n");
      return RET_BUG;
    }
  }
    gtk_list_store_move_after(GTK_LIST_STORE(self->obj),iter,position);
  return 0;
}

static int _wrap_gtk_list_store_move_before(NspGtkListStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,new_opts, t_end};
  nsp_option opts[] = {
	{"position",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreeIter *iter = NULL, *position = NULL;
  NspObject *nsp_iter = NULL, *nsp_position = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, opts, &nsp_position) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if ( nsp_position != NULL ) {
    if (nspg_boxed_check(nsp_position, GTK_TYPE_TREE_ITER))
      position = nspg_boxed_get(nsp_position, GtkTreeIter);
    else if (! IsNone(nsp_position)) {
      Scierror("Error: position should be a GtkTreeIter or None\n");
      return RET_BUG;
    }
  }
    gtk_list_store_move_before(GTK_LIST_STORE(self->obj),iter,position);
  return 0;
}

static NspMethods gtkliststore_methods[] = {
  {"get_matrix",(nsp_method *) _wrap_nsp_get_matrix_from_list_store},
  {"get_list",(nsp_method *) _wrap_nsp_get_list_from_list_store},
  {"set",(nsp_method *) _wrap_gtk_list_store_set},
  {"remove",(nsp_method *) _wrap_gtk_list_store_remove},
  {"insert",(nsp_method *) _wrap_gtk_list_store_insert},
  {"insert_before",(nsp_method *) _wrap_gtk_list_store_insert_before},
  {"insert_after",(nsp_method *) _wrap_gtk_list_store_insert_after},
  {"insert_with_values",(nsp_method *) _wrap_gtk_list_store_insert_with_values},
  {"prepend",(nsp_method *) _wrap_gtk_list_store_prepend},
  {"append",(nsp_method *) _wrap_gtk_list_store_append},
  {"clear",(nsp_method *) _wrap_gtk_list_store_clear},
  {"iter_is_valid",(nsp_method *) _wrap_gtk_list_store_iter_is_valid},
  {"reorder",(nsp_method *) _wrap_gtk_list_store_reorder},
  {"swap",(nsp_method *) _wrap_gtk_list_store_swap},
  {"move_after",(nsp_method *) _wrap_gtk_list_store_move_after},
  {"move_before",(nsp_method *) _wrap_gtk_list_store_move_before},
  { NULL, NULL}
};

static NspMethods *gtkliststore_get_methods(void) { return gtkliststore_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkliststore_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTreeStore ----------- */


#define  NspGtkTreeStore_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktreestore.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTreeStore inherits from GObject 
 * and implements GtkTreeModel GtkTreeDragSource GtkTreeDragDest GtkTreeSortable GtkBuildable
 */

int nsp_type_gtktreestore_id=0;
NspTypeGtkTreeStore *nsp_type_gtktreestore=NULL;

/*
 * Type object for NspGtkTreeStore 
 * all the instance of NspTypeGtkTreeStore share the same id. 
 * nsp_type_gtktreestore: is an instance of NspTypeGtkTreeStore 
 *    used for objects of NspGtkTreeStore type (i.e built with new_gtktreestore) 
 * other instances are used for derived classes 
 */
NspTypeGtkTreeStore *new_type_gtktreestore(type_mode mode)
{
  NspTypeGtkTreeModel *t_gtktreemodel;
  NspTypeGtkTreeDragSource *t_gtktreedragsource;
  NspTypeGtkTreeDragDest *t_gtktreedragdest;
  NspTypeGtkTreeSortable *t_gtktreesortable;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkTreeStore *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktreestore != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktreestore;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktreestore_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktreestore_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktreestore;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktreestore */ 

  top->s_type =  (s_type_func *) nsp_gtktreestore_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktreestore_type_short_string;
  /* top->create = (create_func*) int_gtktreestore_create;*/

  /* specific methods for gtktreestore */

  type->init = (init_func *) init_gtktreestore;

  /* 
   * NspGtkTreeStore interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtktreemodel = new_type_gtktreemodel(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtktreemodel;
  t_gtktreedragsource = new_type_gtktreedragsource(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtktreedragsource;
  t_gtktreedragdest = new_type_gtktreedragdest(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gtktreedragdest;
  t_gtktreesortable = new_type_gtktreesortable(T_DERIVED);
  type->interface->interface->interface->interface = (NspTypeBase * ) t_gtktreesortable;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface->interface->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtktreestore_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTreeStore called nsp_type_gtktreestore
       */
      type->id =  nsp_type_gtktreestore_id = nsp_new_type_id();
      nsp_type_gtktreestore = type;
      if ( nsp_register_type(nsp_type_gtktreestore) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktreestore, GTK_TYPE_TREE_STORE);
      return ( mode == T_BASE ) ? type : new_type_gtktreestore(mode);
    }
  else 
    {
      type->id = nsp_type_gtktreestore_id;
      return type;
    }
}

/*
 * initialize NspGtkTreeStore instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktreestore(NspGtkTreeStore *Obj,NspTypeGtkTreeStore *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTreeStore 
 */

NspGtkTreeStore *new_gtktreestore() 
{
  NspGtkTreeStore *loc;
  /* type must exists */
  nsp_type_gtktreestore = new_type_gtktreestore(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTreeStore)))== NULLGTKTREESTORE) return loc;
  /* initialize object */
  if ( init_gtktreestore(loc,nsp_type_gtktreestore) == FAIL) return NULLGTKTREESTORE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTreeStore 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktreestore_type_name[]="GtkTreeStore";
static char gtktreestore_short_type_name[]="GtkTreeStore";

static char *nsp_gtktreestore_type_as_string(void)
{
  return(gtktreestore_type_name);
}

static char *nsp_gtktreestore_type_short_string(NspObject *v)
{
  return(gtktreestore_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTreeStore objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTreeStore   *nsp_gtktreestore_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktreestore_id)  == TRUE  ) return ((NspGtkTreeStore *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktreestore));
  return NULL;
}

int IsGtkTreeStoreObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktreestore_id);
}

int IsGtkTreeStore(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktreestore_id);
}

NspGtkTreeStore  *GetGtkTreeStoreCopy(Stack stack, int i)
{
  if (  GetGtkTreeStore(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTreeStore  *GetGtkTreeStore(Stack stack, int i)
{
  NspGtkTreeStore *M;
  if (( M = nsp_gtktreestore_object(NthObj(i))) == NULLGTKTREESTORE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTreeStore *gtktreestore_copy(NspGtkTreeStore *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreestore);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktreestore);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTreeStore
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 2034 "codegen-3.0/gtk.override"
/* very similar to liststore :
 * we build the first level here
 */
static int
_wrap_gtk_tree_store_new(Stack stack,int rhs,int opt,int lhs)
{
  int flag = TRUE;
  NspObject *ret;
  GObject *gobj;
  CheckRhs(1,2);
  if ( opt != 0 ) {
    Scierror("GtkListStore do not accept optional named arguments");
    return RET_BUG;
  }

  if (rhs == 2)
    {
      if (  GetScalarBool(stack,2,&flag) == FAIL) {return FAIL;}
    }
  if ( IsMatObj(stack,1))
    {
      /* building a treestore from a Matrix */
      NspMatrix *M;
      if ((M = GetRealMat(stack,1)) == NULLMAT) return RET_BUG;
      /* we build a tree store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_mat(M))== NULL)
	return RET_BUG;
    }
  else if ( IsSMatObj(stack,1))
    {
      /* building a treestore from a string matrix  */
      NspSMatrix *M;
      if ((M = GetSMat(stack,1)) == NULLSMAT) return RET_BUG;
      /* we build a tree store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_smat(M))== NULL)
	return RET_BUG;
    }
  else if ( IsBMatObj(stack,1))
    {
      /* building a treestore from a boolean matrix  */
      NspBMatrix *M;
      if ((M = GetBMat(stack,1)) == NULLBMAT) return RET_BUG;
      /* we build a tree store with M->n doubles */
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_bmat(M))== NULL)
	return RET_BUG;
    }
  else if ( IsListObj(stack,1))
    {
      /* building a treestore from a list */
      NspList *l;
      if ((l = GetList(stack,1)) == NULL) return RET_BUG;
      if ((gobj = (GObject *) nsp_gtk_tree_store_from_list(l,flag))== NULL)
	return RET_BUG;
    }
  else
    {
      Scierror("%s: firts argument has a wrong type \n",NspFname(stack));
      return RET_BUG;
    }
  if (( ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtktreestore))== NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 47958 "gtk.c"


static int _wrap_nsp_get_matrix_from_tree_store(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  CheckRhs(0,0);
    ret =nsp_get_matrix_from_tree_store(GTK_TREE_STORE(self->obj));
  if (ret == NULLOBJ ) return RET_BUG;
MoveObj(stack,1,ret);
  return 1;
}

static int _wrap_nsp_get_list_from_tree_store(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  CheckRhs(0,0);
    ret =nsp_get_list_from_tree_store(GTK_TREE_STORE(self->obj));
  if (ret == NULLOBJ ) return RET_BUG;
MoveObj(stack,1,ret);
  return 1;
}

#line 2102 "codegen-3.0/gtk.override"

/* Usage:
 *   set[iter,col,value]
 *   set[iter,list(...)]
 *   if list gives mores than one row then the list store is extented
 *   the iterator if given is not changed
 */
static int
_wrap_gtk_tree_store_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGtkTreeIter *nsp_iter=NULL;GtkTreeIter *p_iter;
  gint column;
  GValue value = { 0 }; NspObject *nsp_value;
  NspList *list;
  CheckRhs(1,3);
  if ( rhs == 1 )
    {
      if ((list = GetList(stack,1))== NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj),NULL,NULL,list)== FAIL)
	return RET_BUG;
     }
  else
    {
      if (( nsp_iter = GetGtkTreeIter(stack,1))== NULL) return RET_BUG;
      p_iter = nspg_boxed_get(nsp_iter,GtkTreeIter);
      if ( rhs == 2 )
	{
	  if ((list = GetList(stack,2))== NULL) return RET_BUG;
	  if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj),p_iter,NULL,list)== FAIL)
	    return RET_BUG;
	}
      else
	{
	  int n_cols = gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj));
	  if (GetScalarInt(stack,2,&column) == FAIL) return RET_BUG;
	  if ((nsp_value =nsp_get_object(stack,3))== NULLOBJ) return RET_BUG;
	  if (column < 0 || column >= n_cols)
	    {
	      Scierror("column number is out of range [0,%d]",n_cols);
	      return RET_BUG;
	    }
	  g_value_init(&value,gtk_tree_model_get_column_type(GTK_TREE_MODEL(self->obj),column));
	  if (nspg_value_from_nspobject(&value, nsp_value)) {
	    Scierror("value (%s) is of the wrong type for column %d\n",nsp_value->type->s_type(),column);
	    return RET_BUG;
	  }
	  gtk_tree_store_set_value(GTK_TREE_STORE(self->obj),p_iter,column, &value);
	  g_value_unset(&value);
	}
    }
  return 0;
}
#line 48034 "gtk.c"


static int _wrap_gtk_tree_store_remove(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_store_remove(GTK_TREE_STORE(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 2156 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_store_insert(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter iter, *parent = NULL;
  gint position;
  NspList *row = NULL;
  NspObject *ret;
  NspGtkTreeIter  *nsp_parent;
  int pos= 0;
  CheckRhs(1,3);
  if ( IsGtkTreeIterObj(stack,1) )
    {
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG;
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      pos = 1;
    }
  CheckRhs(1+pos,2+pos);
  if ( GetScalarInt(stack,pos+1,&position)== FAIL) return RET_BUG;
  gtk_tree_store_insert(GTK_TREE_STORE(self->obj), &iter, parent, position);
  if ( rhs == 2+pos )
    {
      if (( row = GetList(stack,2+pos)) == NULL) return RET_BUG;
      if (  nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row)== FAIL) return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 48085 "gtk.c"


#line 2187 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_store_insert_before(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter  *sibling=NULL,*parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;
  NspGtkTreeIter *nsp_parent,*nsp_sibling;
  CheckRhs(2,3);
  if ( IsGtkTreeIterObj(stack,1) )
    {
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG;
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
    }
  if ( IsGtkTreeIterObj(stack,2) )
    {
      if (( nsp_sibling = GetGtkTreeIter(stack,2))== NULL) return RET_BUG;
      sibling = nspg_boxed_get(nsp_sibling, GtkTreeIter);
    }
  gtk_tree_store_insert_before(GTK_TREE_STORE(self->obj),&iter,parent,sibling);
  if ( rhs == 3)
    {
      if (( row = GetList(stack,3)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL)
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 48120 "gtk.c"


#line 2220 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_store_insert_after(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter  *sibling=NULL,*parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;
  NspGtkTreeIter *nsp_parent,*nsp_sibling;
  CheckRhs(2,3);
  if ( IsGtkTreeIterObj(stack,1) )
    {
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG;
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
    }
  if ( IsGtkTreeIterObj(stack,2) )
    {
      if (( nsp_sibling = GetGtkTreeIter(stack,2))== NULL) return RET_BUG;
      sibling = nspg_boxed_get(nsp_sibling, GtkTreeIter);
    }
  gtk_tree_store_insert_after(GTK_TREE_STORE(self->obj),&iter,parent,sibling);
  if ( rhs == 3 )
    {
      if (( row = GetList(stack,3)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL)
	return RET_BUG;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 48155 "gtk.c"


static int _wrap_gtk_tree_store_insert_with_values(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj,s_int, t_end};
  GtkTreeIter *iter = NULL, *parent = NULL;
  NspObject *nsp_iter = NULL, *nsp_parent = NULL;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_parent, &position) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_parent, GTK_TYPE_TREE_ITER))
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
  else {
      Scierror( "Error: parent should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_store_insert_with_values(GTK_TREE_STORE(self->obj),iter,parent,position);
  return 0;
}

#line 2253 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_store_prepend(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter *parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;
  NspGtkTreeIter *nsp_parent;

  CheckRhs(0,2);
  switch (rhs)
    {
    case 0: gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
      break;
    case 1:
      if ( IsGtkTreeIterObj(stack,1) )
	{
	  /* prepend[parent] */
	  if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG;
	  parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
	  gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
	}
      else
	{
	  /* prepend[row] */
	  gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
	  if (( row = GetList(stack,1)) == NULL) return RET_BUG;
	  if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL)
	    return RET_BUG;
	}
      break;
    case 2:
      /* prepend[parent,row] */
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG;
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL)
	return RET_BUG;
      break;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 48228 "gtk.c"


#line 2301 "codegen-3.0/gtk.override"
static int
_wrap_gtk_tree_store_append(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeIter  *parent=NULL;
  GtkTreeIter iter;
  NspList *row = NULL;
  NspObject *ret;
  NspGtkTreeIter *nsp_parent;

  CheckRhs(0,2);
  switch (rhs)
    {
    case 0: gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
      break;
    case 1:
      if ( IsGtkTreeIterObj(stack,1) )
	{
	  /* append a row (tree titer gives the parent position) */
	  if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG;
	  parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
	  gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
	}
      else
	{
	  /* append a row at top level  */
	  gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
	  if (( row = GetList(stack,1)) == NULL) return RET_BUG;
	  /* fill the row (or the rows if more than one row data is given) */
	  if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent, row) ==FAIL)
	    return RET_BUG;
	}
      break;
    case 2:
      /* append a row (tree iter gives the parent position ) */
      if (( nsp_parent = GetGtkTreeIter(stack,1))== NULL) return RET_BUG;
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
      gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
      if (( row = GetList(stack,2)) == NULL) return RET_BUG;
	  /* fill the row (or the rows if more than one row data is given) */
      if ( nsp_gtk_tree_model_set_row(GTK_TREE_MODEL(self->obj), &iter,parent,row) ==FAIL)
	return RET_BUG;
      break;
    }
  if ((ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,nsp_type_gtktreeiter)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;

}
#line 48281 "gtk.c"


static int _wrap_gtk_tree_store_is_ancestor(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreeIter *iter = NULL, *descendant = NULL;
  NspObject *nsp_iter = NULL, *nsp_descendant = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, &nsp_descendant) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_descendant, GTK_TYPE_TREE_ITER))
      descendant = nspg_boxed_get(nsp_descendant, GtkTreeIter);
  else {
      Scierror( "Error: descendant should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_store_is_ancestor(GTK_TREE_STORE(self->obj),iter,descendant);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_store_iter_depth(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_store_iter_depth(GTK_TREE_STORE(self->obj),iter);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_store_clear(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tree_store_clear(GTK_TREE_STORE(self->obj));
  return 0;
}

static int _wrap_gtk_tree_store_iter_is_valid(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    ret =gtk_tree_store_iter_is_valid(GTK_TREE_STORE(self->obj),iter);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tree_store_reorder(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int, t_end};
  GtkTreeIter *parent = NULL;
  NspObject *nsp_parent = NULL;
  int new_order;
  if ( GetArgs(stack,rhs,opt,T,&nsp_parent, &new_order) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_parent, GTK_TYPE_TREE_ITER))
      parent = nspg_boxed_get(nsp_parent, GtkTreeIter);
  else {
      Scierror( "Error: parent should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_store_reorder(GTK_TREE_STORE(self->obj),parent,&new_order);
  return 0;
}

static int _wrap_gtk_tree_store_swap(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkTreeIter *a = NULL, *b = NULL;
  NspObject *nsp_a = NULL, *nsp_b = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_a, &nsp_b) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_a, GTK_TYPE_TREE_ITER))
      a = nspg_boxed_get(nsp_a, GtkTreeIter);
  else {
      Scierror( "Error: a should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_b, GTK_TYPE_TREE_ITER))
      b = nspg_boxed_get(nsp_b, GtkTreeIter);
  else {
      Scierror( "Error: b should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_store_swap(GTK_TREE_STORE(self->obj),a,b);
  return 0;
}

static int _wrap_gtk_tree_store_move_before(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,new_opts, t_end};
  nsp_option opts[] = {
	{"position",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreeIter *iter = NULL, *position = NULL;
  NspObject *nsp_iter = NULL, *nsp_position = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, opts, &nsp_position) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if ( nsp_position != NULL ) {
    if (nspg_boxed_check(nsp_position, GTK_TYPE_TREE_ITER))
      position = nspg_boxed_get(nsp_position, GtkTreeIter);
    else if (! IsNone(nsp_position)) {
      Scierror("Error: position should be a GtkTreeIter or None\n");
      return RET_BUG;
    }
  }
    gtk_tree_store_move_before(GTK_TREE_STORE(self->obj),iter,position);
  return 0;
}

static int _wrap_gtk_tree_store_move_after(NspGtkTreeStore *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,new_opts, t_end};
  nsp_option opts[] = {
	{"position",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreeIter *iter = NULL, *position = NULL;
  NspObject *nsp_iter = NULL, *nsp_position = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter, opts, &nsp_position) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
  if ( nsp_position != NULL ) {
    if (nspg_boxed_check(nsp_position, GTK_TYPE_TREE_ITER))
      position = nspg_boxed_get(nsp_position, GtkTreeIter);
    else if (! IsNone(nsp_position)) {
      Scierror("Error: position should be a GtkTreeIter or None\n");
      return RET_BUG;
    }
  }
    gtk_tree_store_move_after(GTK_TREE_STORE(self->obj),iter,position);
  return 0;
}

static NspMethods gtktreestore_methods[] = {
  {"get_matrix",(nsp_method *) _wrap_nsp_get_matrix_from_tree_store},
  {"get_list",(nsp_method *) _wrap_nsp_get_list_from_tree_store},
  {"set",(nsp_method *) _wrap_gtk_tree_store_set},
  {"remove",(nsp_method *) _wrap_gtk_tree_store_remove},
  {"insert",(nsp_method *) _wrap_gtk_tree_store_insert},
  {"insert_before",(nsp_method *) _wrap_gtk_tree_store_insert_before},
  {"insert_after",(nsp_method *) _wrap_gtk_tree_store_insert_after},
  {"insert_with_values",(nsp_method *) _wrap_gtk_tree_store_insert_with_values},
  {"prepend",(nsp_method *) _wrap_gtk_tree_store_prepend},
  {"append",(nsp_method *) _wrap_gtk_tree_store_append},
  {"is_ancestor",(nsp_method *) _wrap_gtk_tree_store_is_ancestor},
  {"iter_depth",(nsp_method *) _wrap_gtk_tree_store_iter_depth},
  {"clear",(nsp_method *) _wrap_gtk_tree_store_clear},
  {"iter_is_valid",(nsp_method *) _wrap_gtk_tree_store_iter_is_valid},
  {"reorder",(nsp_method *) _wrap_gtk_tree_store_reorder},
  {"swap",(nsp_method *) _wrap_gtk_tree_store_swap},
  {"move_before",(nsp_method *) _wrap_gtk_tree_store_move_before},
  {"move_after",(nsp_method *) _wrap_gtk_tree_store_move_after},
  { NULL, NULL}
};

static NspMethods *gtktreestore_get_methods(void) { return gtktreestore_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktreestore_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkComboBox ----------- */


#define  NspGtkComboBox_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcombobox.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkComboBox inherits from GtkBin 
 * and implements GtkCellLayout GtkCellEditable GtkBuildable
 */

int nsp_type_gtkcombobox_id=0;
NspTypeGtkComboBox *nsp_type_gtkcombobox=NULL;

/*
 * Type object for NspGtkComboBox 
 * all the instance of NspTypeGtkComboBox share the same id. 
 * nsp_type_gtkcombobox: is an instance of NspTypeGtkComboBox 
 *    used for objects of NspGtkComboBox type (i.e built with new_gtkcombobox) 
 * other instances are used for derived classes 
 */
NspTypeGtkComboBox *new_type_gtkcombobox(type_mode mode)
{
  NspTypeGtkCellLayout *t_gtkcelllayout;
  NspTypeGtkCellEditable *t_gtkcelleditable;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkComboBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcombobox != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcombobox;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcombobox_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcombobox_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcombobox;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcombobox */ 

  top->s_type =  (s_type_func *) nsp_gtkcombobox_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcombobox_type_short_string;
  /* top->create = (create_func*) int_gtkcombobox_create;*/

  /* specific methods for gtkcombobox */

  type->init = (init_func *) init_gtkcombobox;

  /* 
   * NspGtkComboBox interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkcelllayout = new_type_gtkcelllayout(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkcelllayout;
  t_gtkcelleditable = new_type_gtkcelleditable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkcelleditable;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkcombobox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkComboBox called nsp_type_gtkcombobox
       */
      type->id =  nsp_type_gtkcombobox_id = nsp_new_type_id();
      nsp_type_gtkcombobox = type;
      if ( nsp_register_type(nsp_type_gtkcombobox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcombobox, GTK_TYPE_COMBO_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkcombobox(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcombobox_id;
      return type;
    }
}

/*
 * initialize NspGtkComboBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcombobox(NspGtkComboBox *Obj,NspTypeGtkComboBox *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkComboBox 
 */

NspGtkComboBox *new_gtkcombobox() 
{
  NspGtkComboBox *loc;
  /* type must exists */
  nsp_type_gtkcombobox = new_type_gtkcombobox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkComboBox)))== NULLGTKCOMBOBOX) return loc;
  /* initialize object */
  if ( init_gtkcombobox(loc,nsp_type_gtkcombobox) == FAIL) return NULLGTKCOMBOBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkComboBox 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcombobox_type_name[]="GtkComboBox";
static char gtkcombobox_short_type_name[]="GtkComboBox";

static char *nsp_gtkcombobox_type_as_string(void)
{
  return(gtkcombobox_type_name);
}

static char *nsp_gtkcombobox_type_short_string(NspObject *v)
{
  return(gtkcombobox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkComboBox objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkComboBox   *nsp_gtkcombobox_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcombobox_id)  == TRUE  ) return ((NspGtkComboBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcombobox));
  return NULL;
}

int IsGtkComboBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcombobox_id);
}

int IsGtkComboBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcombobox_id);
}

NspGtkComboBox  *GetGtkComboBoxCopy(Stack stack, int i)
{
  if (  GetGtkComboBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkComboBox  *GetGtkComboBox(Stack stack, int i)
{
  NspGtkComboBox *M;
  if (( M = nsp_gtkcombobox_object(NthObj(i))) == NULLGTKCOMBOBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkComboBox *gtkcombobox_copy(NspGtkComboBox *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcombobox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcombobox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkComboBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_combo_box_new_with_entry (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_combo_box_new_with_entry())== NULL) return RET_BUG;

  nsp_type_gtkcombobox = new_type_gtkcombobox(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcombobox);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 7132 "codegen-3.0/gtk.override"

/* merging gtkcombobox_new, new_with_entry,
 * new_with_model, new_with_model_and_entry, new_with_area, new_with_area_and_entry
 * we also build a gtkcomboboxtext when text is given
 */
static int
_wrap_gtk_combo_box_new(Stack stack, int rhs, int opt, int lhs)
{
  int with_entry = FALSE;
  GObject *ret; NspObject *nsp_ret;
  NspGObject *model = NULL;
  NspGObject *area = NULL;
  NspSMatrix *Smat = NULL;
  int_types T[] = {new_opts,t_end};
  nsp_option opts[] = {
	{"model",obj_check,NULLOBJ,-1},
	{"text",smat,NULLOBJ,-1},
	{"with_entry",s_bool,NULLOBJ,-1},
	{"area",obj_check,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  if ( GetArgs(stack,rhs,opt,T,opts,&nsp_type_gtktreemodel,&model,&Smat,&with_entry,
	       &nsp_type_gtkcellarea,&area) == FAIL)
    return RET_BUG;
  if ( area != NULL )
    {
      if ( with_entry == FALSE )
	{
	  if ((ret = (GObject *) gtk_combo_box_new_with_area(GTK_CELL_AREA(area->obj)))
	      == NULL) return RET_BUG;
	}
      else
	{
	  if ((ret = (GObject *) gtk_combo_box_new_with_area_and_entry(GTK_CELL_AREA(area->obj)))
	      == NULL) return RET_BUG;
	}
    }
  else if ( model != NULL)
    {
      if ( with_entry == FALSE )
	{
	  if ((ret = (GObject *) gtk_combo_box_new_with_model(GTK_TREE_MODEL(model->obj)))
	      == NULL) return RET_BUG;
	}
      else
	{
	  if ((ret = (GObject *) gtk_combo_box_new_with_model_and_entry(GTK_TREE_MODEL(model->obj)))
	      == NULL) return RET_BUG;
	}
    }
  else if ( Smat != NULL)
    {
      int i;
      if ( with_entry == TRUE )
	{
	  if ((ret = (GObject *) gtk_combo_box_text_new_with_entry()) == NULL) return RET_BUG;
	}
      else
	{
	  if ((ret = (GObject *) gtk_combo_box_text_new()) == NULL) return RET_BUG;
	}
      for ( i = 0 ; i < Smat->mn ; i++)
	gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(ret),Smat->S[i]);
      nsp_type_gtkcomboboxtext = new_type_gtkcomboboxtext(T_BASE);
      nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcomboboxtext );
      if ( nsp_ret == NULL) return RET_BUG;
      MoveObj(stack,1,nsp_ret);
      return 1;
    }
  else
    {
      if ( with_entry == TRUE )
	{
	  if ((ret = (GObject *)gtk_combo_box_new_with_entry())== NULL) return RET_BUG;
	}
      else
	{
	  if ((ret = (GObject *)gtk_combo_box_new())== NULL) return RET_BUG;
	}
    }
  nsp_type_gtkcombobox = new_type_gtkcombobox(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkcombobox );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 48776 "gtk.c"


static int _wrap_gtk_combo_box_get_wrap_width(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_wrap_width(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_combo_box_set_wrap_width(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int width;
  if ( GetArgs(stack,rhs,opt,T,&width) == FAIL) return RET_BUG;
    gtk_combo_box_set_wrap_width(GTK_COMBO_BOX(self->obj),width);
  return 0;
}

static int _wrap_gtk_combo_box_get_row_span_column(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_row_span_column(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_combo_box_set_row_span_column(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int row_span;
  if ( GetArgs(stack,rhs,opt,T,&row_span) == FAIL) return RET_BUG;
    gtk_combo_box_set_row_span_column(GTK_COMBO_BOX(self->obj),row_span);
  return 0;
}

static int _wrap_gtk_combo_box_get_column_span_column(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_column_span_column(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_combo_box_set_column_span_column(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int column_span;
  if ( GetArgs(stack,rhs,opt,T,&column_span) == FAIL) return RET_BUG;
    gtk_combo_box_set_column_span_column(GTK_COMBO_BOX(self->obj),column_span);
  return 0;
}

#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_combo_box_get_add_tearoffs(Stack stack, int rhs, int opt, int lhs) /* get_add_tearoffs */
{
  Scierror("Error: function gtk_combo_box_get_add_tearoffs is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_combo_box_get_add_tearoffs(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_add_tearoffs(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_combo_box_set_add_tearoffs(Stack stack, int rhs, int opt, int lhs) /* set_add_tearoffs */
{
  Scierror("Error: function gtk_combo_box_set_add_tearoffs is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_combo_box_set_add_tearoffs(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int add_tearoffs;
  if ( GetArgs(stack,rhs,opt,T,&add_tearoffs) == FAIL) return RET_BUG;
    gtk_combo_box_set_add_tearoffs(GTK_COMBO_BOX(self->obj),add_tearoffs);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_combo_box_get_title(Stack stack, int rhs, int opt, int lhs) /* get_title */
{
  Scierror("Error: function gtk_combo_box_get_title is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_combo_box_get_title(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_title(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_combo_box_set_title(Stack stack, int rhs, int opt, int lhs) /* set_title */
{
  Scierror("Error: function gtk_combo_box_set_title is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_combo_box_set_title(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *title;
  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
    gtk_combo_box_set_title(GTK_COMBO_BOX(self->obj),title);
  return 0;
}

#endif
static int _wrap_gtk_combo_box_get_focus_on_click(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_focus_on_click(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_combo_box_set_focus_on_click(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int focus_on_click;
  if ( GetArgs(stack,rhs,opt,T,&focus_on_click) == FAIL) return RET_BUG;
    gtk_combo_box_set_focus_on_click(GTK_COMBO_BOX(self->obj),focus_on_click);
  return 0;
}

static int _wrap_gtk_combo_box_get_active(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_active(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_combo_box_set_active(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int index_;
  if ( GetArgs(stack,rhs,opt,T,&index_) == FAIL) return RET_BUG;
    gtk_combo_box_set_active(GTK_COMBO_BOX(self->obj),index_);
  return 0;
}

#line 7271 "codegen-3.0/gtk.override"

static int _wrap_gtk_combo_box_get_active_iter(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  GtkTreeIter iter;
  NspObject *nsp_iter;
  CheckStdRhs(0,0);
  ret = gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->obj),&iter);
  if ( ret == FALSE )
    {
      Scierror( "Error: active iter is not set\n");
      return RET_BUG;
    }
  if ((nsp_iter = (NspObject *) gboxed_create(NVOID,GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE,NULL)) == NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_iter);
  return 1;
}


#line 48958 "gtk.c"


static int _wrap_gtk_combo_box_set_active_iter(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTreeIter *iter = NULL;
  NspObject *nsp_iter = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_iter) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_combo_box_set_active_iter(GTK_COMBO_BOX(self->obj),iter);
  return 0;
}

static int _wrap_gtk_combo_box_set_model(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"model",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkTreeModel *model = NULL;
  NspGObject *nsp_model = NULL;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_model) == FAIL) return RET_BUG;
  if ( nsp_model != NULL ) {
    if ( IsGtkTreeModel((NspObject *)nsp_model))
      model = GTK_TREE_MODEL(nsp_model->obj);
    else if (! IsNone((NspObject *)nsp_model)) {
         Scierror( "Error: model should be a GtkTreeModel or None\n");
         return RET_BUG;
    }
  }
    gtk_combo_box_set_model(GTK_COMBO_BOX(self->obj),model);
  return 0;
}

static int _wrap_gtk_combo_box_get_model(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkTreeModel *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_model(GTK_COMBO_BOX(self->obj));
  nsp_type_gtktreemodel = new_type_gtktreemodel(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktreemodel))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_combo_box_set_button_sensitivity(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSensitivityType sensitivity;
  NspObject *nsp_sensitivity = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_sensitivity) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SENSITIVITY_TYPE, nsp_sensitivity, &sensitivity)== FAIL)
      return RET_BUG;
    gtk_combo_box_set_button_sensitivity(GTK_COMBO_BOX(self->obj),sensitivity);
  return 0;
}

static int _wrap_gtk_combo_box_get_button_sensitivity(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_button_sensitivity(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_combo_box_get_has_entry(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_has_entry(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_combo_box_set_entry_text_column(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int text_column;
  if ( GetArgs(stack,rhs,opt,T,&text_column) == FAIL) return RET_BUG;
    gtk_combo_box_set_entry_text_column(GTK_COMBO_BOX(self->obj),text_column);
  return 0;
}

static int _wrap_gtk_combo_box_get_entry_text_column(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_entry_text_column(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_combo_box_set_popup_fixed_width(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int fixed;
  if ( GetArgs(stack,rhs,opt,T,&fixed) == FAIL) return RET_BUG;
    gtk_combo_box_set_popup_fixed_width(GTK_COMBO_BOX(self->obj),fixed);
  return 0;
}

static int _wrap_gtk_combo_box_get_popup_fixed_width(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_popup_fixed_width(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_combo_box_popup(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_combo_box_popup(GTK_COMBO_BOX(self->obj));
  return 0;
}

static int _wrap_gtk_combo_box_popup_for_device(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *device;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdevice, &device) == FAIL) return RET_BUG;
    gtk_combo_box_popup_for_device(GTK_COMBO_BOX(self->obj),GDK_DEVICE(device->obj));
  return 0;
}

static int _wrap_gtk_combo_box_popdown(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_combo_box_popdown(GTK_COMBO_BOX(self->obj));
  return 0;
}

static int _wrap_gtk_combo_box_get_popup_accessible(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  AtkObject *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_popup_accessible(GTK_COMBO_BOX(self->obj));
  nsp_type_atkobject = new_type_atkobject(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_atkobject))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_combo_box_get_id_column(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_id_column(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_combo_box_set_id_column(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int id_column;
  if ( GetArgs(stack,rhs,opt,T,&id_column) == FAIL) return RET_BUG;
    gtk_combo_box_set_id_column(GTK_COMBO_BOX(self->obj),id_column);
  return 0;
}

static int _wrap_gtk_combo_box_get_active_id(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_get_active_id(GTK_COMBO_BOX(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_combo_box_set_active_id(NspGtkComboBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *active_id;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&active_id) == FAIL) return RET_BUG;
    ret =gtk_combo_box_set_active_id(GTK_COMBO_BOX(self->obj),active_id);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkcombobox_methods[] = {
  {"get_wrap_width",(nsp_method *) _wrap_gtk_combo_box_get_wrap_width},
  {"set_wrap_width",(nsp_method *) _wrap_gtk_combo_box_set_wrap_width},
  {"get_row_span_column",(nsp_method *) _wrap_gtk_combo_box_get_row_span_column},
  {"set_row_span_column",(nsp_method *) _wrap_gtk_combo_box_set_row_span_column},
  {"get_column_span_column",(nsp_method *) _wrap_gtk_combo_box_get_column_span_column},
  {"set_column_span_column",(nsp_method *) _wrap_gtk_combo_box_set_column_span_column},
  {"get_add_tearoffs",(nsp_method *) _wrap_gtk_combo_box_get_add_tearoffs},
  {"set_add_tearoffs",(nsp_method *) _wrap_gtk_combo_box_set_add_tearoffs},
  {"get_title",(nsp_method *) _wrap_gtk_combo_box_get_title},
  {"set_title",(nsp_method *) _wrap_gtk_combo_box_set_title},
  {"get_focus_on_click",(nsp_method *) _wrap_gtk_combo_box_get_focus_on_click},
  {"set_focus_on_click",(nsp_method *) _wrap_gtk_combo_box_set_focus_on_click},
  {"get_active",(nsp_method *) _wrap_gtk_combo_box_get_active},
  {"set_active",(nsp_method *) _wrap_gtk_combo_box_set_active},
  {"get_active_iter",(nsp_method *) _wrap_gtk_combo_box_get_active_iter},
  {"set_active_iter",(nsp_method *) _wrap_gtk_combo_box_set_active_iter},
  {"set_model",(nsp_method *) _wrap_gtk_combo_box_set_model},
  {"get_model",(nsp_method *) _wrap_gtk_combo_box_get_model},
  {"set_button_sensitivity",(nsp_method *) _wrap_gtk_combo_box_set_button_sensitivity},
  {"get_button_sensitivity",(nsp_method *) _wrap_gtk_combo_box_get_button_sensitivity},
  {"get_has_entry",(nsp_method *) _wrap_gtk_combo_box_get_has_entry},
  {"set_entry_text_column",(nsp_method *) _wrap_gtk_combo_box_set_entry_text_column},
  {"get_entry_text_column",(nsp_method *) _wrap_gtk_combo_box_get_entry_text_column},
  {"set_popup_fixed_width",(nsp_method *) _wrap_gtk_combo_box_set_popup_fixed_width},
  {"get_popup_fixed_width",(nsp_method *) _wrap_gtk_combo_box_get_popup_fixed_width},
  {"popup",(nsp_method *) _wrap_gtk_combo_box_popup},
  {"popup_for_device",(nsp_method *) _wrap_gtk_combo_box_popup_for_device},
  {"popdown",(nsp_method *) _wrap_gtk_combo_box_popdown},
  {"get_popup_accessible",(nsp_method *) _wrap_gtk_combo_box_get_popup_accessible},
  {"get_id_column",(nsp_method *) _wrap_gtk_combo_box_get_id_column},
  {"set_id_column",(nsp_method *) _wrap_gtk_combo_box_set_id_column},
  {"get_active_id",(nsp_method *) _wrap_gtk_combo_box_get_active_id},
  {"set_active_id",(nsp_method *) _wrap_gtk_combo_box_set_active_id},
  { NULL, NULL}
};

static NspMethods *gtkcombobox_get_methods(void) { return gtkcombobox_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcombobox_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkComboBoxText ----------- */


#define  NspGtkComboBoxText_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcomboboxtext.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkComboBoxText inherits from GtkComboBox 
 * and implements GtkCellLayout GtkCellEditable GtkBuildable
 */

int nsp_type_gtkcomboboxtext_id=0;
NspTypeGtkComboBoxText *nsp_type_gtkcomboboxtext=NULL;

/*
 * Type object for NspGtkComboBoxText 
 * all the instance of NspTypeGtkComboBoxText share the same id. 
 * nsp_type_gtkcomboboxtext: is an instance of NspTypeGtkComboBoxText 
 *    used for objects of NspGtkComboBoxText type (i.e built with new_gtkcomboboxtext) 
 * other instances are used for derived classes 
 */
NspTypeGtkComboBoxText *new_type_gtkcomboboxtext(type_mode mode)
{
  NspTypeGtkCellLayout *t_gtkcelllayout;
  NspTypeGtkCellEditable *t_gtkcelleditable;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkComboBoxText *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcomboboxtext != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcomboboxtext;
    }
  if (( type =  malloc(sizeof(NspTypeGtkComboBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcombobox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcomboboxtext_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcomboboxtext_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcomboboxtext;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcomboboxtext */ 

  top->s_type =  (s_type_func *) nsp_gtkcomboboxtext_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcomboboxtext_type_short_string;
  /* top->create = (create_func*) int_gtkcomboboxtext_create;*/

  /* specific methods for gtkcomboboxtext */

  type->init = (init_func *) init_gtkcomboboxtext;

  /* 
   * NspGtkComboBoxText interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkcelllayout = new_type_gtkcelllayout(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkcelllayout;
  t_gtkcelleditable = new_type_gtkcelleditable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkcelleditable;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkcomboboxtext_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkComboBoxText called nsp_type_gtkcomboboxtext
       */
      type->id =  nsp_type_gtkcomboboxtext_id = nsp_new_type_id();
      nsp_type_gtkcomboboxtext = type;
      if ( nsp_register_type(nsp_type_gtkcomboboxtext) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcomboboxtext, GTK_TYPE_COMBO_BOX_TEXT);
      return ( mode == T_BASE ) ? type : new_type_gtkcomboboxtext(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcomboboxtext_id;
      return type;
    }
}

/*
 * initialize NspGtkComboBoxText instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcomboboxtext(NspGtkComboBoxText *Obj,NspTypeGtkComboBoxText *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkComboBoxText 
 */

NspGtkComboBoxText *new_gtkcomboboxtext() 
{
  NspGtkComboBoxText *loc;
  /* type must exists */
  nsp_type_gtkcomboboxtext = new_type_gtkcomboboxtext(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkComboBoxText)))== NULLGTKCOMBOBOXTEXT) return loc;
  /* initialize object */
  if ( init_gtkcomboboxtext(loc,nsp_type_gtkcomboboxtext) == FAIL) return NULLGTKCOMBOBOXTEXT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkComboBoxText 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcomboboxtext_type_name[]="GtkComboBoxText";
static char gtkcomboboxtext_short_type_name[]="GtkComboBoxText";

static char *nsp_gtkcomboboxtext_type_as_string(void)
{
  return(gtkcomboboxtext_type_name);
}

static char *nsp_gtkcomboboxtext_type_short_string(NspObject *v)
{
  return(gtkcomboboxtext_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkComboBoxText objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkComboBoxText   *nsp_gtkcomboboxtext_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcomboboxtext_id)  == TRUE  ) return ((NspGtkComboBoxText *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcomboboxtext));
  return NULL;
}

int IsGtkComboBoxTextObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcomboboxtext_id);
}

int IsGtkComboBoxText(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcomboboxtext_id);
}

NspGtkComboBoxText  *GetGtkComboBoxTextCopy(Stack stack, int i)
{
  if (  GetGtkComboBoxText(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkComboBoxText  *GetGtkComboBoxText(Stack stack, int i)
{
  NspGtkComboBoxText *M;
  if (( M = nsp_gtkcomboboxtext_object(NthObj(i))) == NULLGTKCOMBOBOXTEXT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkComboBoxText *gtkcomboboxtext_copy(NspGtkComboBoxText *self)
{
  /* return gtkcombobox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcomboboxtext);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcomboboxtext);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkComboBoxText
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_combo_box_text_new_with_entry (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_combo_box_text_new_with_entry())== NULL) return RET_BUG;

  nsp_type_gtkcomboboxtext = new_type_gtkcomboboxtext(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcomboboxtext);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_combo_box_text_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_combo_box_text_new())== NULL) return RET_BUG;

  nsp_type_gtkcomboboxtext = new_type_gtkcomboboxtext(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcomboboxtext);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_combo_box_text_append_text(NspGtkComboBoxText *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(self->obj),text);
  return 0;
}

static int _wrap_gtk_combo_box_text_insert_text(NspGtkComboBoxText *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,string, t_end};
  int position;
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&position, &text) == FAIL) return RET_BUG;
    gtk_combo_box_text_insert_text(GTK_COMBO_BOX_TEXT(self->obj),position,text);
  return 0;
}

static int _wrap_gtk_combo_box_text_prepend_text(NspGtkComboBoxText *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    gtk_combo_box_text_prepend_text(GTK_COMBO_BOX_TEXT(self->obj),text);
  return 0;
}

static int _wrap_gtk_combo_box_text_remove(NspGtkComboBoxText *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int position;
  if ( GetArgs(stack,rhs,opt,T,&position) == FAIL) return RET_BUG;
    gtk_combo_box_text_remove(GTK_COMBO_BOX_TEXT(self->obj),position);
  return 0;
}

static int _wrap_gtk_combo_box_text_remove_all(NspGtkComboBoxText *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_combo_box_text_remove_all(GTK_COMBO_BOX_TEXT(self->obj));
  return 0;
}

static int _wrap_gtk_combo_box_text_get_active_text(NspGtkComboBoxText *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_combo_box_text_get_active_text(GTK_COMBO_BOX_TEXT(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_combo_box_text_insert(NspGtkComboBoxText *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,string,string, t_end};
  int position;
  char *id, *text;
  if ( GetArgs(stack,rhs,opt,T,&position, &id, &text) == FAIL) return RET_BUG;
    gtk_combo_box_text_insert(GTK_COMBO_BOX_TEXT(self->obj),position,id,text);
  return 0;
}

static int _wrap_gtk_combo_box_text_append(NspGtkComboBoxText *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,string, t_end};
  char *id, *text;
  if ( GetArgs(stack,rhs,opt,T,&id, &text) == FAIL) return RET_BUG;
    gtk_combo_box_text_append(GTK_COMBO_BOX_TEXT(self->obj),id,text);
  return 0;
}

static int _wrap_gtk_combo_box_text_prepend(NspGtkComboBoxText *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,string, t_end};
  char *id, *text;
  if ( GetArgs(stack,rhs,opt,T,&id, &text) == FAIL) return RET_BUG;
    gtk_combo_box_text_prepend(GTK_COMBO_BOX_TEXT(self->obj),id,text);
  return 0;
}

static NspMethods gtkcomboboxtext_methods[] = {
  {"append_text",(nsp_method *) _wrap_gtk_combo_box_text_append_text},
  {"insert_text",(nsp_method *) _wrap_gtk_combo_box_text_insert_text},
  {"prepend_text",(nsp_method *) _wrap_gtk_combo_box_text_prepend_text},
  {"remove",(nsp_method *) _wrap_gtk_combo_box_text_remove},
  {"remove_all",(nsp_method *) _wrap_gtk_combo_box_text_remove_all},
  {"get_active_text",(nsp_method *) _wrap_gtk_combo_box_text_get_active_text},
  {"insert",(nsp_method *) _wrap_gtk_combo_box_text_insert},
  {"append",(nsp_method *) _wrap_gtk_combo_box_text_append},
  {"prepend",(nsp_method *) _wrap_gtk_combo_box_text_prepend},
  { NULL, NULL}
};

static NspMethods *gtkcomboboxtext_get_methods(void) { return gtkcomboboxtext_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcomboboxtext_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkMenu ----------- */


#define  NspGtkMenu_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkmenu.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkMenu inherits from GtkMenuShell 
 * and implements GtkBuildable
 */

int nsp_type_gtkmenu_id=0;
NspTypeGtkMenu *nsp_type_gtkmenu=NULL;

/*
 * Type object for NspGtkMenu 
 * all the instance of NspTypeGtkMenu share the same id. 
 * nsp_type_gtkmenu: is an instance of NspTypeGtkMenu 
 *    used for objects of NspGtkMenu type (i.e built with new_gtkmenu) 
 * other instances are used for derived classes 
 */
NspTypeGtkMenu *new_type_gtkmenu(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkMenu *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmenu != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmenu;
    }
  if (( type =  malloc(sizeof(NspTypeGtkMenuShell))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmenushell(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmenu_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkmenu_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkmenu;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkmenu */ 

  top->s_type =  (s_type_func *) nsp_gtkmenu_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkmenu_type_short_string;
  /* top->create = (create_func*) int_gtkmenu_create;*/

  /* specific methods for gtkmenu */

  type->init = (init_func *) init_gtkmenu;

  /* 
   * NspGtkMenu interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkmenu_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMenu called nsp_type_gtkmenu
       */
      type->id =  nsp_type_gtkmenu_id = nsp_new_type_id();
      nsp_type_gtkmenu = type;
      if ( nsp_register_type(nsp_type_gtkmenu) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmenu, GTK_TYPE_MENU);
      return ( mode == T_BASE ) ? type : new_type_gtkmenu(mode);
    }
  else 
    {
      type->id = nsp_type_gtkmenu_id;
      return type;
    }
}

/*
 * initialize NspGtkMenu instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmenu(NspGtkMenu *Obj,NspTypeGtkMenu *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkMenu 
 */

NspGtkMenu *new_gtkmenu() 
{
  NspGtkMenu *loc;
  /* type must exists */
  nsp_type_gtkmenu = new_type_gtkmenu(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMenu)))== NULLGTKMENU) return loc;
  /* initialize object */
  if ( init_gtkmenu(loc,nsp_type_gtkmenu) == FAIL) return NULLGTKMENU;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkMenu 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkmenu_type_name[]="GtkMenu";
static char gtkmenu_short_type_name[]="GtkMenu";

static char *nsp_gtkmenu_type_as_string(void)
{
  return(gtkmenu_type_name);
}

static char *nsp_gtkmenu_type_short_string(NspObject *v)
{
  return(gtkmenu_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkMenu objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkMenu   *nsp_gtkmenu_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkmenu_id)  == TRUE  ) return ((NspGtkMenu *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmenu));
  return NULL;
}

int IsGtkMenuObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkmenu_id);
}

int IsGtkMenu(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmenu_id);
}

NspGtkMenu  *GetGtkMenuCopy(Stack stack, int i)
{
  if (  GetGtkMenu(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMenu  *GetGtkMenu(Stack stack, int i)
{
  NspGtkMenu *M;
  if (( M = nsp_gtkmenu_object(NthObj(i))) == NULLGTKMENU)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMenu *gtkmenu_copy(NspGtkMenu *self)
{
  /* return gtkmenushell_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenu);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenu);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMenu
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_menu_new_from_model (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *model;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gmenumodel, &model) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_menu_new_from_model(G_MENU_MODEL(model->obj)))== NULL) return RET_BUG;

  nsp_type_gtkmenu = new_type_gtkmenu(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkmenu);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_menu_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_menu_new())== NULL) return RET_BUG;

  nsp_type_gtkmenu = new_type_gtkmenu(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkmenu);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 4136 "codegen-3.0/gtk.override"
static void
nspgtk_menu_position(GtkMenu *menu, int *x, int *y, gboolean *push_in,
		     NspObject *func)
{
  NspObject *args[1];
  NspObject *nsp_ret[3];
  int nret = 3,nargs = 2;
  nspg_block_threads();
  args[0] = (NspObject *) nspgobject_new("menu",(GObject *)menu);
  if (args[0] == NULL) return ;
  if ( nsp_gtk_eval_function((NspPList *)func ,args,nargs,nsp_ret,&nret)== FAIL)
    goto end ;
  if (nret != 3 )
    {
      Scierror("expecting three returned values\n");
      goto end;
    }
  else
    {
      int_types T[]={ s_int,s_int,s_bool,t_end};
      if ( GetFromTable(nsp_ret,T,x,y,push_in) == FAIL)
	{
	  Scierror("returned values are incorect \n");
	  goto end;
	}
    }
 end:
  {
    nspg_unblock_threads();
    return;
  }
}

static int
_wrap_gtk_menu_popup(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  nsp_option opts[] = {
    {"parent_menu_shell",obj_check,NULLOBJ,-1},
    {"parent_menu_item",obj_check,NULLOBJ,-1},
    {"func",obj_check,NULLOBJ,-1},
    {"button",s_int,NULLOBJ,-1},
    {"activate_time",s_int,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };
  int_types T[] = {new_opts, t_end} ;
  /* "parent_menu_shell", "parent_menu_item", "func", "button", "activate_time",  */
  NspGObject *nsp_pms = NULL, *nsp_pmi=NULL;
  GtkWidget *pms = NULL, *pmi = NULL;
  NspObject *func=NULL;
  int button=0, time=-1;
  if (GetArgs(stack,rhs,opt,T,&opts,&nsp_type_gtkwidget, &nsp_pms,
	      &nsp_type_gtkwidget,&nsp_pmi,
	      &nsp_type_plist,&func,&button, &time)== FAIL) return RET_BUG;
  if ( nsp_pms != NULL) pms = GTK_WIDGET(nsp_pms->obj);
  if ( nsp_pmi != NULL) pmi = GTK_WIDGET(nsp_pmi->obj);
  if ( func != NULL ) {
    if (( func = (NspObject *)nsp_object_copy(func)) == NULL ) return RET_BUG;
    if ((nsp_object_set_name(func,"f")== FAIL)) return RET_BUG;
    gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
		   (GtkMenuPositionFunc)nspgtk_menu_position,
		   func, button, time);
  } else
    gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);
  return 0;
}
#line 49816 "gtk.c"


static int _wrap_gtk_menu_reposition(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_menu_reposition(GTK_MENU(self->obj));
  return 0;
}

static int _wrap_gtk_menu_popdown(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_menu_popdown(GTK_MENU(self->obj));
  return 0;
}

static int _wrap_gtk_menu_get_active(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_menu_get_active(GTK_MENU(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_menu_set_active(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int index;
  if ( GetArgs(stack,rhs,opt,T,&index) == FAIL) return RET_BUG;
    gtk_menu_set_active(GTK_MENU(self->obj),index);
  return 0;
}

static int _wrap_gtk_menu_set_accel_group(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *accel_group;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaccelgroup, &accel_group) == FAIL) return RET_BUG;
    gtk_menu_set_accel_group(GTK_MENU(self->obj),GTK_ACCEL_GROUP(accel_group->obj));
  return 0;
}

static int _wrap_gtk_menu_get_accel_group(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAccelGroup *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_menu_get_accel_group(GTK_MENU(self->obj));
  nsp_type_gtkaccelgroup = new_type_gtkaccelgroup(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkaccelgroup))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_menu_set_accel_path(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *accel_path;
  if ( GetArgs(stack,rhs,opt,T,&accel_path) == FAIL) return RET_BUG;
    gtk_menu_set_accel_path(GTK_MENU(self->obj),accel_path);
  return 0;
}

static int _wrap_gtk_menu_get_accel_path(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_menu_get_accel_path(GTK_MENU(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#line 4638 "codegen-3.0/gtk.override"

static void
nspgtk_menu_detach (GtkWidget *attach_widget, GtkMenu *menu)
{
  NspObject *func;
  NspObject *args[2];
  int nret = 0,nargs = 2;
  /* gboolean ret = FALSE;*/
  NspObject *nsp_ret;

  if (( func = g_object_get_data (G_OBJECT (menu), "nspgtk_menu_detach_func"))== NULL) return

  nspg_block_threads();

  args[0] = (NspObject *) gobject_create("menu",(GObject *)menu,(NspTypeBase *) nsp_type_gtkmenu );
  args[1] = (NspObject *) gobject_create("attach",(GObject *)attach_widget,(NspTypeBase *) nsp_type_gtkwidget );
  if ( args[0]== NULL ||args[1]== NULL ) goto end;
  if ( nsp_gtk_eval_function((NspPList *) func ,args,nargs,&nsp_ret,&nret)== FAIL)
    goto end;
  /* returned value is unused
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  */
  goto end;
 end:
  {
    nspg_unblock_threads();
  }
}

static int
_wrap_gtk_menu_attach_to_widget (NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /*  */
  int_types T[] = {obj_check, new_opts , t_end} ;
  nsp_option opts[] = {
    {"detach",obj_check,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };
  
  NspObject *nsp_attach_widget;
  NspPList *detach_func = NULL;
  GtkWidget *attach_widget;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &nsp_attach_widget,&opts,&nsp_type_plist,&detach_func) == FAIL)
    return RET_BUG;

  attach_widget = GTK_WIDGET (((NspGObject *) nsp_attach_widget)->obj);

  if ( detach_func != NULL)
    {
      if (( detach_func =(NspPList *)nsp_object_copy((NspObject *) detach_func)) == NULLP_PLIST) return RET_BUG;
      if ((nsp_object_set_name((NspObject *)detach_func ,"detach")== FAIL)) return RET_BUG;
      g_object_set_data_full (self->obj,
			      "nspgtk_menu_detach_func",
			      detach_func,
			      nspg_destroy_notify);
    }
  else
    {
      g_object_set_data (self->obj, "nspgtk_menu_detach_func", NULL);
    }
  
  gtk_menu_attach_to_widget (GTK_MENU (self->obj), attach_widget,
			     (GtkMenuDetachFunc) nspgtk_menu_detach);
  return 0;
}
#line 49960 "gtk.c"


static int _wrap_gtk_menu_detach(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_menu_detach(GTK_MENU(self->obj));
  return 0;
}

static int _wrap_gtk_menu_get_attach_widget(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_menu_get_attach_widget(GTK_MENU(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_menu_set_tearoff_state(Stack stack, int rhs, int opt, int lhs) /* set_tearoff_state */
{
  Scierror("Error: function gtk_menu_set_tearoff_state is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_menu_set_tearoff_state(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int torn_off;
  if ( GetArgs(stack,rhs,opt,T,&torn_off) == FAIL) return RET_BUG;
    gtk_menu_set_tearoff_state(GTK_MENU(self->obj),torn_off);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_menu_get_tearoff_state(Stack stack, int rhs, int opt, int lhs) /* get_tearoff_state */
{
  Scierror("Error: function gtk_menu_get_tearoff_state is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_menu_get_tearoff_state(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_menu_get_tearoff_state(GTK_MENU(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_menu_set_title(Stack stack, int rhs, int opt, int lhs) /* set_title */
{
  Scierror("Error: function gtk_menu_set_title is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_menu_set_title(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *title;
  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
    gtk_menu_set_title(GTK_MENU(self->obj),title);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_menu_get_title(Stack stack, int rhs, int opt, int lhs) /* get_title */
{
  Scierror("Error: function gtk_menu_get_title is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_menu_get_title(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_menu_get_title(GTK_MENU(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#endif
static int _wrap_gtk_menu_reorder_child(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *child;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &position) == FAIL) return RET_BUG;
    gtk_menu_reorder_child(GTK_MENU(self->obj),GTK_WIDGET(child->obj),position);
  return 0;
}

static int _wrap_gtk_menu_set_screen(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *screen;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen) == FAIL) return RET_BUG;
    gtk_menu_set_screen(GTK_MENU(self->obj),GDK_SCREEN(screen->obj));
  return 0;
}

static int _wrap_gtk_menu_attach(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int,s_int,s_int, t_end};
  NspGObject *child;
  int left_attach, right_attach, top_attach, bottom_attach;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &left_attach, &right_attach, &top_attach, &bottom_attach) == FAIL) return RET_BUG;
    gtk_menu_attach(GTK_MENU(self->obj),GTK_WIDGET(child->obj),left_attach,right_attach,top_attach,bottom_attach);
  return 0;
}

static int _wrap_gtk_menu_set_monitor(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int monitor_num;
  if ( GetArgs(stack,rhs,opt,T,&monitor_num) == FAIL) return RET_BUG;
    gtk_menu_set_monitor(GTK_MENU(self->obj),monitor_num);
  return 0;
}

static int _wrap_gtk_menu_get_monitor(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_menu_get_monitor(GTK_MENU(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_menu_set_reserve_toggle_size(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int reserve_toggle_size;
  if ( GetArgs(stack,rhs,opt,T,&reserve_toggle_size) == FAIL) return RET_BUG;
    gtk_menu_set_reserve_toggle_size(GTK_MENU(self->obj),reserve_toggle_size);
  return 0;
}

static int _wrap_gtk_menu_get_reserve_toggle_size(NspGtkMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_menu_get_reserve_toggle_size(GTK_MENU(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkmenu_methods[] = {
  {"popup",(nsp_method *) _wrap_gtk_menu_popup},
  {"reposition",(nsp_method *) _wrap_gtk_menu_reposition},
  {"popdown",(nsp_method *) _wrap_gtk_menu_popdown},
  {"get_active",(nsp_method *) _wrap_gtk_menu_get_active},
  {"set_active",(nsp_method *) _wrap_gtk_menu_set_active},
  {"set_accel_group",(nsp_method *) _wrap_gtk_menu_set_accel_group},
  {"get_accel_group",(nsp_method *) _wrap_gtk_menu_get_accel_group},
  {"set_accel_path",(nsp_method *) _wrap_gtk_menu_set_accel_path},
  {"get_accel_path",(nsp_method *) _wrap_gtk_menu_get_accel_path},
  {"attach_to_widget",(nsp_method *) _wrap_gtk_menu_attach_to_widget},
  {"detach",(nsp_method *) _wrap_gtk_menu_detach},
  {"get_attach_widget",(nsp_method *) _wrap_gtk_menu_get_attach_widget},
  {"set_tearoff_state",(nsp_method *) _wrap_gtk_menu_set_tearoff_state},
  {"get_tearoff_state",(nsp_method *) _wrap_gtk_menu_get_tearoff_state},
  {"set_title",(nsp_method *) _wrap_gtk_menu_set_title},
  {"get_title",(nsp_method *) _wrap_gtk_menu_get_title},
  {"reorder_child",(nsp_method *) _wrap_gtk_menu_reorder_child},
  {"set_screen",(nsp_method *) _wrap_gtk_menu_set_screen},
  {"attach",(nsp_method *) _wrap_gtk_menu_attach},
  {"set_monitor",(nsp_method *) _wrap_gtk_menu_set_monitor},
  {"get_monitor",(nsp_method *) _wrap_gtk_menu_get_monitor},
  {"set_reserve_toggle_size",(nsp_method *) _wrap_gtk_menu_set_reserve_toggle_size},
  {"get_reserve_toggle_size",(nsp_method *) _wrap_gtk_menu_get_reserve_toggle_size},
  { NULL, NULL}
};

static NspMethods *gtkmenu_get_methods(void) { return gtkmenu_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmenu_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkMenuBar ----------- */


#define  NspGtkMenuBar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkmenubar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkMenuBar inherits from GtkMenuShell 
 * and implements GtkBuildable
 */

int nsp_type_gtkmenubar_id=0;
NspTypeGtkMenuBar *nsp_type_gtkmenubar=NULL;

/*
 * Type object for NspGtkMenuBar 
 * all the instance of NspTypeGtkMenuBar share the same id. 
 * nsp_type_gtkmenubar: is an instance of NspTypeGtkMenuBar 
 *    used for objects of NspGtkMenuBar type (i.e built with new_gtkmenubar) 
 * other instances are used for derived classes 
 */
NspTypeGtkMenuBar *new_type_gtkmenubar(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkMenuBar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmenubar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmenubar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkMenuShell))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmenushell(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmenubar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkmenubar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkmenubar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkmenubar */ 

  top->s_type =  (s_type_func *) nsp_gtkmenubar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkmenubar_type_short_string;
  /* top->create = (create_func*) int_gtkmenubar_create;*/

  /* specific methods for gtkmenubar */

  type->init = (init_func *) init_gtkmenubar;

  /* 
   * NspGtkMenuBar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkmenubar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMenuBar called nsp_type_gtkmenubar
       */
      type->id =  nsp_type_gtkmenubar_id = nsp_new_type_id();
      nsp_type_gtkmenubar = type;
      if ( nsp_register_type(nsp_type_gtkmenubar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmenubar, GTK_TYPE_MENU_BAR);
      return ( mode == T_BASE ) ? type : new_type_gtkmenubar(mode);
    }
  else 
    {
      type->id = nsp_type_gtkmenubar_id;
      return type;
    }
}

/*
 * initialize NspGtkMenuBar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmenubar(NspGtkMenuBar *Obj,NspTypeGtkMenuBar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkMenuBar 
 */

NspGtkMenuBar *new_gtkmenubar() 
{
  NspGtkMenuBar *loc;
  /* type must exists */
  nsp_type_gtkmenubar = new_type_gtkmenubar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMenuBar)))== NULLGTKMENUBAR) return loc;
  /* initialize object */
  if ( init_gtkmenubar(loc,nsp_type_gtkmenubar) == FAIL) return NULLGTKMENUBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkMenuBar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkmenubar_type_name[]="GtkMenuBar";
static char gtkmenubar_short_type_name[]="GtkMenuBar";

static char *nsp_gtkmenubar_type_as_string(void)
{
  return(gtkmenubar_type_name);
}

static char *nsp_gtkmenubar_type_short_string(NspObject *v)
{
  return(gtkmenubar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkMenuBar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkMenuBar   *nsp_gtkmenubar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkmenubar_id)  == TRUE  ) return ((NspGtkMenuBar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmenubar));
  return NULL;
}

int IsGtkMenuBarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkmenubar_id);
}

int IsGtkMenuBar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmenubar_id);
}

NspGtkMenuBar  *GetGtkMenuBarCopy(Stack stack, int i)
{
  if (  GetGtkMenuBar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMenuBar  *GetGtkMenuBar(Stack stack, int i)
{
  NspGtkMenuBar *M;
  if (( M = nsp_gtkmenubar_object(NthObj(i))) == NULLGTKMENUBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMenuBar *gtkmenubar_copy(NspGtkMenuBar *self)
{
  /* return gtkmenushell_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenubar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenubar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMenuBar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_menu_bar_new_from_model (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *model;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gmenumodel, &model) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_menu_bar_new_from_model(G_MENU_MODEL(model->obj)))== NULL) return RET_BUG;

  nsp_type_gtkmenubar = new_type_gtkmenubar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkmenubar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_menu_bar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_menu_bar_new())== NULL) return RET_BUG;

  nsp_type_gtkmenubar = new_type_gtkmenubar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkmenubar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_menu_bar_get_pack_direction(NspGtkMenuBar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_menu_bar_get_pack_direction(GTK_MENU_BAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_menu_bar_set_pack_direction(NspGtkMenuBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkPackDirection pack_dir;
  NspObject *nsp_pack_dir = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_pack_dir) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_PACK_DIRECTION, nsp_pack_dir, &pack_dir)== FAIL)
      return RET_BUG;
    gtk_menu_bar_set_pack_direction(GTK_MENU_BAR(self->obj),pack_dir);
  return 0;
}

static int _wrap_gtk_menu_bar_get_child_pack_direction(NspGtkMenuBar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_menu_bar_get_child_pack_direction(GTK_MENU_BAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_menu_bar_set_child_pack_direction(NspGtkMenuBar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkPackDirection child_pack_dir;
  NspObject *nsp_child_pack_dir = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_child_pack_dir) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_PACK_DIRECTION, nsp_child_pack_dir, &child_pack_dir)== FAIL)
      return RET_BUG;
    gtk_menu_bar_set_child_pack_direction(GTK_MENU_BAR(self->obj),child_pack_dir);
  return 0;
}

static NspMethods gtkmenubar_methods[] = {
  {"get_pack_direction",(nsp_method *) _wrap_gtk_menu_bar_get_pack_direction},
  {"set_pack_direction",(nsp_method *) _wrap_gtk_menu_bar_set_pack_direction},
  {"get_child_pack_direction",(nsp_method *) _wrap_gtk_menu_bar_get_child_pack_direction},
  {"set_child_pack_direction",(nsp_method *) _wrap_gtk_menu_bar_set_child_pack_direction},
  { NULL, NULL}
};

static NspMethods *gtkmenubar_get_methods(void) { return gtkmenubar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmenubar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkMenuItem ----------- */


#define  NspGtkMenuItem_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkmenuitem.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkMenuItem inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkmenuitem_id=0;
NspTypeGtkMenuItem *nsp_type_gtkmenuitem=NULL;

/*
 * Type object for NspGtkMenuItem 
 * all the instance of NspTypeGtkMenuItem share the same id. 
 * nsp_type_gtkmenuitem: is an instance of NspTypeGtkMenuItem 
 *    used for objects of NspGtkMenuItem type (i.e built with new_gtkmenuitem) 
 * other instances are used for derived classes 
 */
NspTypeGtkMenuItem *new_type_gtkmenuitem(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkMenuItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmenuitem != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmenuitem;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmenuitem_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkmenuitem_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkmenuitem;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkmenuitem */ 

  top->s_type =  (s_type_func *) nsp_gtkmenuitem_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkmenuitem_type_short_string;
  /* top->create = (create_func*) int_gtkmenuitem_create;*/

  /* specific methods for gtkmenuitem */

  type->init = (init_func *) init_gtkmenuitem;

  /* 
   * NspGtkMenuItem interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkmenuitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMenuItem called nsp_type_gtkmenuitem
       */
      type->id =  nsp_type_gtkmenuitem_id = nsp_new_type_id();
      nsp_type_gtkmenuitem = type;
      if ( nsp_register_type(nsp_type_gtkmenuitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmenuitem, GTK_TYPE_MENU_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkmenuitem(mode);
    }
  else 
    {
      type->id = nsp_type_gtkmenuitem_id;
      return type;
    }
}

/*
 * initialize NspGtkMenuItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmenuitem(NspGtkMenuItem *Obj,NspTypeGtkMenuItem *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkMenuItem 
 */

NspGtkMenuItem *new_gtkmenuitem() 
{
  NspGtkMenuItem *loc;
  /* type must exists */
  nsp_type_gtkmenuitem = new_type_gtkmenuitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMenuItem)))== NULLGTKMENUITEM) return loc;
  /* initialize object */
  if ( init_gtkmenuitem(loc,nsp_type_gtkmenuitem) == FAIL) return NULLGTKMENUITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkMenuItem 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkmenuitem_type_name[]="GtkMenuItem";
static char gtkmenuitem_short_type_name[]="GtkMenuItem";

static char *nsp_gtkmenuitem_type_as_string(void)
{
  return(gtkmenuitem_type_name);
}

static char *nsp_gtkmenuitem_type_short_string(NspObject *v)
{
  return(gtkmenuitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkMenuItem objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkMenuItem   *nsp_gtkmenuitem_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkmenuitem_id)  == TRUE  ) return ((NspGtkMenuItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmenuitem));
  return NULL;
}

int IsGtkMenuItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkmenuitem_id);
}

int IsGtkMenuItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmenuitem_id);
}

NspGtkMenuItem  *GetGtkMenuItemCopy(Stack stack, int i)
{
  if (  GetGtkMenuItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMenuItem  *GetGtkMenuItem(Stack stack, int i)
{
  NspGtkMenuItem *M;
  if (( M = nsp_gtkmenuitem_object(NthObj(i))) == NULLGTKMENUITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMenuItem *gtkmenuitem_copy(NspGtkMenuItem *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenuitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenuitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMenuItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 4611 "codegen-3.0/gtk.override"
static int
_wrap_gtk_menu_item_new(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  GObject *gobj;
  gchar *text = NULL;

  CheckRhs(0,1);
  if ( rhs == 0 )
      gobj = (GObject *)gtk_menu_item_new();
  else
    {
      if ((text = GetString(stack,1))== NULL) return RET_BUG;
      gobj = (GObject *)gtk_menu_item_new_with_mnemonic(text);
    }
  if (gobj == NULL ) {
    Scierror( "could not create GtkMenuItem object");
    return RET_BUG;
  }
  nsp_type_gtkmenuitem = new_type_gtkmenuitem(T_BASE);
  if ((ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkmenuitem))==NULL)
    return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 50654 "gtk.c"


static int _wrap_gtk_menu_item_set_submenu(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *submenu;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &submenu) == FAIL) return RET_BUG;
    gtk_menu_item_set_submenu(GTK_MENU_ITEM(self->obj),GTK_WIDGET(submenu->obj));
  return 0;
}

static int _wrap_gtk_menu_item_get_submenu(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_menu_item_get_submenu(GTK_MENU_ITEM(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_menu_item_select(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_menu_item_select(GTK_MENU_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_menu_item_deselect(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_menu_item_deselect(GTK_MENU_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_menu_item_activate(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_menu_item_activate(GTK_MENU_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_menu_item_toggle_size_request(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int requisition;
  if ( GetArgs(stack,rhs,opt,T,&requisition) == FAIL) return RET_BUG;
    gtk_menu_item_toggle_size_request(GTK_MENU_ITEM(self->obj),&requisition);
  return 0;
}

static int _wrap_gtk_menu_item_toggle_size_allocate(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int allocation;
  if ( GetArgs(stack,rhs,opt,T,&allocation) == FAIL) return RET_BUG;
    gtk_menu_item_toggle_size_allocate(GTK_MENU_ITEM(self->obj),allocation);
  return 0;
}

#if GTK_CHECK_VERSION(3,2,0)
int _wrap_gtk_menu_item_set_right_justified(Stack stack, int rhs, int opt, int lhs) /* set_right_justified */
{
  Scierror("Error: function gtk_menu_item_set_right_justified is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_menu_item_set_right_justified(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int right_justified;
  if ( GetArgs(stack,rhs,opt,T,&right_justified) == FAIL) return RET_BUG;
    gtk_menu_item_set_right_justified(GTK_MENU_ITEM(self->obj),right_justified);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,2,0)
int _wrap_gtk_menu_item_get_right_justified(Stack stack, int rhs, int opt, int lhs) /* get_right_justified */
{
  Scierror("Error: function gtk_menu_item_get_right_justified is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_menu_item_get_right_justified(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_menu_item_get_right_justified(GTK_MENU_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
static int _wrap_gtk_menu_item_set_accel_path(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *accel_path;
  if ( GetArgs(stack,rhs,opt,T,&accel_path) == FAIL) return RET_BUG;
    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(self->obj),accel_path);
  return 0;
}

static int _wrap_gtk_menu_item_get_accel_path(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_menu_item_get_accel_path(GTK_MENU_ITEM(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_menu_item_set_label(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *label;
  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
    gtk_menu_item_set_label(GTK_MENU_ITEM(self->obj),label);
  return 0;
}

static int _wrap_gtk_menu_item_get_label(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_menu_item_get_label(GTK_MENU_ITEM(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_menu_item_set_use_underline(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_menu_item_set_use_underline(GTK_MENU_ITEM(self->obj),setting);
  return 0;
}

static int _wrap_gtk_menu_item_get_use_underline(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_menu_item_get_use_underline(GTK_MENU_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_menu_item_set_reserve_indicator(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int reserve;
  if ( GetArgs(stack,rhs,opt,T,&reserve) == FAIL) return RET_BUG;
    gtk_menu_item_set_reserve_indicator(GTK_MENU_ITEM(self->obj),reserve);
  return 0;
}

static int _wrap_gtk_menu_item_get_reserve_indicator(NspGtkMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_menu_item_get_reserve_indicator(GTK_MENU_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkmenuitem_methods[] = {
  {"set_submenu",(nsp_method *) _wrap_gtk_menu_item_set_submenu},
  {"get_submenu",(nsp_method *) _wrap_gtk_menu_item_get_submenu},
  {"select",(nsp_method *) _wrap_gtk_menu_item_select},
  {"deselect",(nsp_method *) _wrap_gtk_menu_item_deselect},
  {"activate",(nsp_method *) _wrap_gtk_menu_item_activate},
  {"toggle_size_request",(nsp_method *) _wrap_gtk_menu_item_toggle_size_request},
  {"toggle_size_allocate",(nsp_method *) _wrap_gtk_menu_item_toggle_size_allocate},
  {"set_right_justified",(nsp_method *) _wrap_gtk_menu_item_set_right_justified},
  {"get_right_justified",(nsp_method *) _wrap_gtk_menu_item_get_right_justified},
  {"set_accel_path",(nsp_method *) _wrap_gtk_menu_item_set_accel_path},
  {"get_accel_path",(nsp_method *) _wrap_gtk_menu_item_get_accel_path},
  {"set_label",(nsp_method *) _wrap_gtk_menu_item_set_label},
  {"get_label",(nsp_method *) _wrap_gtk_menu_item_get_label},
  {"set_use_underline",(nsp_method *) _wrap_gtk_menu_item_set_use_underline},
  {"get_use_underline",(nsp_method *) _wrap_gtk_menu_item_get_use_underline},
  {"set_reserve_indicator",(nsp_method *) _wrap_gtk_menu_item_set_reserve_indicator},
  {"get_reserve_indicator",(nsp_method *) _wrap_gtk_menu_item_get_reserve_indicator},
  { NULL, NULL}
};

static NspMethods *gtkmenuitem_get_methods(void) { return gtkmenuitem_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmenuitem_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRadioMenuItem ----------- */


#define  NspGtkRadioMenuItem_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkradiomenuitem.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRadioMenuItem inherits from GtkCheckMenuItem 
 * and implements GtkBuildable
 */

int nsp_type_gtkradiomenuitem_id=0;
NspTypeGtkRadioMenuItem *nsp_type_gtkradiomenuitem=NULL;

/*
 * Type object for NspGtkRadioMenuItem 
 * all the instance of NspTypeGtkRadioMenuItem share the same id. 
 * nsp_type_gtkradiomenuitem: is an instance of NspTypeGtkRadioMenuItem 
 *    used for objects of NspGtkRadioMenuItem type (i.e built with new_gtkradiomenuitem) 
 * other instances are used for derived classes 
 */
NspTypeGtkRadioMenuItem *new_type_gtkradiomenuitem(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkRadioMenuItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkradiomenuitem != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkradiomenuitem;
    }
  if (( type =  malloc(sizeof(NspTypeGtkCheckMenuItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcheckmenuitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkradiomenuitem_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkradiomenuitem_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkradiomenuitem;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkradiomenuitem */ 

  top->s_type =  (s_type_func *) nsp_gtkradiomenuitem_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkradiomenuitem_type_short_string;
  /* top->create = (create_func*) int_gtkradiomenuitem_create;*/

  /* specific methods for gtkradiomenuitem */

  type->init = (init_func *) init_gtkradiomenuitem;

  /* 
   * NspGtkRadioMenuItem interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkradiomenuitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRadioMenuItem called nsp_type_gtkradiomenuitem
       */
      type->id =  nsp_type_gtkradiomenuitem_id = nsp_new_type_id();
      nsp_type_gtkradiomenuitem = type;
      if ( nsp_register_type(nsp_type_gtkradiomenuitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkradiomenuitem, GTK_TYPE_RADIO_MENU_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkradiomenuitem(mode);
    }
  else 
    {
      type->id = nsp_type_gtkradiomenuitem_id;
      return type;
    }
}

/*
 * initialize NspGtkRadioMenuItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkradiomenuitem(NspGtkRadioMenuItem *Obj,NspTypeGtkRadioMenuItem *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRadioMenuItem 
 */

NspGtkRadioMenuItem *new_gtkradiomenuitem() 
{
  NspGtkRadioMenuItem *loc;
  /* type must exists */
  nsp_type_gtkradiomenuitem = new_type_gtkradiomenuitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRadioMenuItem)))== NULLGTKRADIOMENUITEM) return loc;
  /* initialize object */
  if ( init_gtkradiomenuitem(loc,nsp_type_gtkradiomenuitem) == FAIL) return NULLGTKRADIOMENUITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRadioMenuItem 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkradiomenuitem_type_name[]="GtkRadioMenuItem";
static char gtkradiomenuitem_short_type_name[]="GtkRadioMenuItem";

static char *nsp_gtkradiomenuitem_type_as_string(void)
{
  return(gtkradiomenuitem_type_name);
}

static char *nsp_gtkradiomenuitem_type_short_string(NspObject *v)
{
  return(gtkradiomenuitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRadioMenuItem objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRadioMenuItem   *nsp_gtkradiomenuitem_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkradiomenuitem_id)  == TRUE  ) return ((NspGtkRadioMenuItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkradiomenuitem));
  return NULL;
}

int IsGtkRadioMenuItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkradiomenuitem_id);
}

int IsGtkRadioMenuItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkradiomenuitem_id);
}

NspGtkRadioMenuItem  *GetGtkRadioMenuItemCopy(Stack stack, int i)
{
  if (  GetGtkRadioMenuItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRadioMenuItem  *GetGtkRadioMenuItem(Stack stack, int i)
{
  NspGtkRadioMenuItem *M;
  if (( M = nsp_gtkradiomenuitem_object(NthObj(i))) == NULLGTKRADIOMENUITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRadioMenuItem *gtkradiomenuitem_copy(NspGtkRadioMenuItem *self)
{
  /* return gtkcheckmenuitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradiomenuitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradiomenuitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRadioMenuItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_radio_menu_item_new_with_label_from_widget (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *group;
  char *label;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkradiomenuitem, &group, &label) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_radio_menu_item_new_with_label_from_widget(GTK_RADIO_MENU_ITEM(group->obj),label))== NULL) return RET_BUG;

  nsp_type_gtkradiomenuitem = new_type_gtkradiomenuitem(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkradiomenuitem);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_radio_menu_item_new_with_mnemonic_from_widget (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *group;
  char *label;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkradiomenuitem, &group, &label) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_radio_menu_item_new_with_mnemonic_from_widget(GTK_RADIO_MENU_ITEM(group->obj),label))== NULL) return RET_BUG;

  nsp_type_gtkradiomenuitem = new_type_gtkradiomenuitem(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkradiomenuitem);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_radio_menu_item_new_from_widget (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *group;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkradiomenuitem, &group) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_radio_menu_item_new_from_widget(GTK_RADIO_MENU_ITEM(group->obj)))== NULL) return RET_BUG;

  nsp_type_gtkradiomenuitem = new_type_gtkradiomenuitem(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkradiomenuitem);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 4736 "codegen-3.0/gtk.override"
static int
_wrap_gtk_radio_menu_item_new(Stack stack,int rhs,int opt,int lhs)
{
  GObject *gobj;
  GtkRadioMenuItem *group = NULL;
  NspObject *ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"group",obj,NULLOBJ,-1},
    {"label",string,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };
  NspObject *nsp_group = NULL;
  gchar *text = NULL;
  if (GetArgs(stack,rhs,opt,T, &opts,&nsp_group, &text) == FAIL)  return RET_BUG;

  if ( nsp_group != NULL )
    {
      if (nspgobject_check(nsp_group,nsp_type_gtkradiomenuitem))
	group = GTK_RADIO_MENU_ITEM(nspgobject_get(nsp_group));
      else {
	Scierror("group argument must be a GtkRadioButton");
	return RET_BUG;
      }
    }

  if (text == NULL) {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_menu_item_new(NULL);
    else
      gobj = (GObject *)gtk_radio_menu_item_new(gtk_radio_menu_item_get_group(group));
  } else {
    if (group == NULL)
      gobj = (GObject *)gtk_radio_menu_item_new_with_mnemonic(NULL,text);
    else
      gobj = (GObject *)gtk_radio_menu_item_new_with_mnemonic(gtk_radio_menu_item_get_group(group), text);
  }
  if (gobj == NULL ) {
    Scierror( "could not create GtkRadioMenuItem object");
    return RET_BUG;
  }
  nsp_type_gtkradiomenuitem = new_type_gtkradiomenuitem(T_BASE);
  if ((ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkradiomenuitem))== NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 51143 "gtk.c"


static int _wrap_gtk_radio_menu_item_get_group(NspGtkRadioMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

static NspMethods gtkradiomenuitem_methods[] = {
  {"get_group",(nsp_method *) _wrap_gtk_radio_menu_item_get_group},
  { NULL, NULL}
};

static NspMethods *gtkradiomenuitem_get_methods(void) { return gtkradiomenuitem_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkradiomenuitem_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCheckMenuItem ----------- */


#define  NspGtkCheckMenuItem_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcheckmenuitem.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCheckMenuItem inherits from GtkMenuItem 
 * and implements GtkBuildable
 */

int nsp_type_gtkcheckmenuitem_id=0;
NspTypeGtkCheckMenuItem *nsp_type_gtkcheckmenuitem=NULL;

/*
 * Type object for NspGtkCheckMenuItem 
 * all the instance of NspTypeGtkCheckMenuItem share the same id. 
 * nsp_type_gtkcheckmenuitem: is an instance of NspTypeGtkCheckMenuItem 
 *    used for objects of NspGtkCheckMenuItem type (i.e built with new_gtkcheckmenuitem) 
 * other instances are used for derived classes 
 */
NspTypeGtkCheckMenuItem *new_type_gtkcheckmenuitem(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkCheckMenuItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcheckmenuitem != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcheckmenuitem;
    }
  if (( type =  malloc(sizeof(NspTypeGtkMenuItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmenuitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcheckmenuitem_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcheckmenuitem_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcheckmenuitem;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcheckmenuitem */ 

  top->s_type =  (s_type_func *) nsp_gtkcheckmenuitem_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcheckmenuitem_type_short_string;
  /* top->create = (create_func*) int_gtkcheckmenuitem_create;*/

  /* specific methods for gtkcheckmenuitem */

  type->init = (init_func *) init_gtkcheckmenuitem;

  /* 
   * NspGtkCheckMenuItem interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkcheckmenuitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCheckMenuItem called nsp_type_gtkcheckmenuitem
       */
      type->id =  nsp_type_gtkcheckmenuitem_id = nsp_new_type_id();
      nsp_type_gtkcheckmenuitem = type;
      if ( nsp_register_type(nsp_type_gtkcheckmenuitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcheckmenuitem, GTK_TYPE_CHECK_MENU_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkcheckmenuitem(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcheckmenuitem_id;
      return type;
    }
}

/*
 * initialize NspGtkCheckMenuItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcheckmenuitem(NspGtkCheckMenuItem *Obj,NspTypeGtkCheckMenuItem *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCheckMenuItem 
 */

NspGtkCheckMenuItem *new_gtkcheckmenuitem() 
{
  NspGtkCheckMenuItem *loc;
  /* type must exists */
  nsp_type_gtkcheckmenuitem = new_type_gtkcheckmenuitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCheckMenuItem)))== NULLGTKCHECKMENUITEM) return loc;
  /* initialize object */
  if ( init_gtkcheckmenuitem(loc,nsp_type_gtkcheckmenuitem) == FAIL) return NULLGTKCHECKMENUITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCheckMenuItem 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcheckmenuitem_type_name[]="GtkCheckMenuItem";
static char gtkcheckmenuitem_short_type_name[]="GtkCheckMenuItem";

static char *nsp_gtkcheckmenuitem_type_as_string(void)
{
  return(gtkcheckmenuitem_type_name);
}

static char *nsp_gtkcheckmenuitem_type_short_string(NspObject *v)
{
  return(gtkcheckmenuitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCheckMenuItem objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCheckMenuItem   *nsp_gtkcheckmenuitem_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcheckmenuitem_id)  == TRUE  ) return ((NspGtkCheckMenuItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcheckmenuitem));
  return NULL;
}

int IsGtkCheckMenuItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcheckmenuitem_id);
}

int IsGtkCheckMenuItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcheckmenuitem_id);
}

NspGtkCheckMenuItem  *GetGtkCheckMenuItemCopy(Stack stack, int i)
{
  if (  GetGtkCheckMenuItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCheckMenuItem  *GetGtkCheckMenuItem(Stack stack, int i)
{
  NspGtkCheckMenuItem *M;
  if (( M = nsp_gtkcheckmenuitem_object(NthObj(i))) == NULLGTKCHECKMENUITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCheckMenuItem *gtkcheckmenuitem_copy(NspGtkCheckMenuItem *self)
{
  /* return gtkmenuitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcheckmenuitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcheckmenuitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCheckMenuItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 4708 "codegen-3.0/gtk.override"
static int
_wrap_gtk_check_menu_item_new(Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  GObject *gobj;
  gchar *text = NULL;

  CheckRhs(0,1);
  if ( rhs == 0 )
      gobj = (GObject *)gtk_check_menu_item_new();
  else
    {
      if ((text = GetString(stack,1))== NULL) return RET_BUG;
      gobj = (GObject *)gtk_check_menu_item_new_with_mnemonic(text);
    }
  if (gobj == NULL ) {
    Scierror( "could not create GtkCheckMenuItem object");
    return RET_BUG;
  }
  nsp_type_gtkcheckmenuitem = new_type_gtkcheckmenuitem(T_BASE);
  if ((ret = (NspObject *) gobject_create(NVOID,gobj,(NspTypeBase *) nsp_type_gtkcheckmenuitem))== NULL) return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 51389 "gtk.c"


static int _wrap_gtk_check_menu_item_set_active(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int is_active;
  if ( GetArgs(stack,rhs,opt,T,&is_active) == FAIL) return RET_BUG;
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(self->obj),is_active);
  return 0;
}

static int _wrap_gtk_check_menu_item_get_active(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_check_menu_item_toggled(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_check_menu_item_toggled(GTK_CHECK_MENU_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_check_menu_item_set_inconsistent(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_check_menu_item_set_inconsistent(GTK_CHECK_MENU_ITEM(self->obj),setting);
  return 0;
}

static int _wrap_gtk_check_menu_item_get_inconsistent(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_check_menu_item_get_inconsistent(GTK_CHECK_MENU_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_check_menu_item_set_draw_as_radio(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int draw_as_radio;
  if ( GetArgs(stack,rhs,opt,T,&draw_as_radio) == FAIL) return RET_BUG;
    gtk_check_menu_item_set_draw_as_radio(GTK_CHECK_MENU_ITEM(self->obj),draw_as_radio);
  return 0;
}

static int _wrap_gtk_check_menu_item_get_draw_as_radio(NspGtkCheckMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_check_menu_item_get_draw_as_radio(GTK_CHECK_MENU_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkcheckmenuitem_methods[] = {
  {"set_active",(nsp_method *) _wrap_gtk_check_menu_item_set_active},
  {"get_active",(nsp_method *) _wrap_gtk_check_menu_item_get_active},
  {"toggled",(nsp_method *) _wrap_gtk_check_menu_item_toggled},
  {"set_inconsistent",(nsp_method *) _wrap_gtk_check_menu_item_set_inconsistent},
  {"get_inconsistent",(nsp_method *) _wrap_gtk_check_menu_item_get_inconsistent},
  {"set_draw_as_radio",(nsp_method *) _wrap_gtk_check_menu_item_set_draw_as_radio},
  {"get_draw_as_radio",(nsp_method *) _wrap_gtk_check_menu_item_get_draw_as_radio},
  { NULL, NULL}
};

static NspMethods *gtkcheckmenuitem_get_methods(void) { return gtkcheckmenuitem_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcheckmenuitem_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkSeparatorMenuItem ----------- */


#define  NspGtkSeparatorMenuItem_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkseparatormenuitem.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkSeparatorMenuItem inherits from GtkMenuItem 
 * and implements GtkBuildable
 */

int nsp_type_gtkseparatormenuitem_id=0;
NspTypeGtkSeparatorMenuItem *nsp_type_gtkseparatormenuitem=NULL;

/*
 * Type object for NspGtkSeparatorMenuItem 
 * all the instance of NspTypeGtkSeparatorMenuItem share the same id. 
 * nsp_type_gtkseparatormenuitem: is an instance of NspTypeGtkSeparatorMenuItem 
 *    used for objects of NspGtkSeparatorMenuItem type (i.e built with new_gtkseparatormenuitem) 
 * other instances are used for derived classes 
 */
NspTypeGtkSeparatorMenuItem *new_type_gtkseparatormenuitem(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkSeparatorMenuItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkseparatormenuitem != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkseparatormenuitem;
    }
  if (( type =  malloc(sizeof(NspTypeGtkMenuItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmenuitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkseparatormenuitem_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkseparatormenuitem_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkseparatormenuitem;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkseparatormenuitem */ 

  top->s_type =  (s_type_func *) nsp_gtkseparatormenuitem_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkseparatormenuitem_type_short_string;
  /* top->create = (create_func*) int_gtkseparatormenuitem_create;*/

  /* specific methods for gtkseparatormenuitem */

  type->init = (init_func *) init_gtkseparatormenuitem;

  /* 
   * NspGtkSeparatorMenuItem interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkseparatormenuitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSeparatorMenuItem called nsp_type_gtkseparatormenuitem
       */
      type->id =  nsp_type_gtkseparatormenuitem_id = nsp_new_type_id();
      nsp_type_gtkseparatormenuitem = type;
      if ( nsp_register_type(nsp_type_gtkseparatormenuitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkseparatormenuitem, GTK_TYPE_SEPARATOR_MENU_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkseparatormenuitem(mode);
    }
  else 
    {
      type->id = nsp_type_gtkseparatormenuitem_id;
      return type;
    }
}

/*
 * initialize NspGtkSeparatorMenuItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkseparatormenuitem(NspGtkSeparatorMenuItem *Obj,NspTypeGtkSeparatorMenuItem *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkSeparatorMenuItem 
 */

NspGtkSeparatorMenuItem *new_gtkseparatormenuitem() 
{
  NspGtkSeparatorMenuItem *loc;
  /* type must exists */
  nsp_type_gtkseparatormenuitem = new_type_gtkseparatormenuitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSeparatorMenuItem)))== NULLGTKSEPARATORMENUITEM) return loc;
  /* initialize object */
  if ( init_gtkseparatormenuitem(loc,nsp_type_gtkseparatormenuitem) == FAIL) return NULLGTKSEPARATORMENUITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkSeparatorMenuItem 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkseparatormenuitem_type_name[]="GtkSeparatorMenuItem";
static char gtkseparatormenuitem_short_type_name[]="GtkSeparatorMenuItem";

static char *nsp_gtkseparatormenuitem_type_as_string(void)
{
  return(gtkseparatormenuitem_type_name);
}

static char *nsp_gtkseparatormenuitem_type_short_string(NspObject *v)
{
  return(gtkseparatormenuitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkSeparatorMenuItem objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkSeparatorMenuItem   *nsp_gtkseparatormenuitem_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkseparatormenuitem_id)  == TRUE  ) return ((NspGtkSeparatorMenuItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkseparatormenuitem));
  return NULL;
}

int IsGtkSeparatorMenuItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkseparatormenuitem_id);
}

int IsGtkSeparatorMenuItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkseparatormenuitem_id);
}

NspGtkSeparatorMenuItem  *GetGtkSeparatorMenuItemCopy(Stack stack, int i)
{
  if (  GetGtkSeparatorMenuItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSeparatorMenuItem  *GetGtkSeparatorMenuItem(Stack stack, int i)
{
  NspGtkSeparatorMenuItem *M;
  if (( M = nsp_gtkseparatormenuitem_object(NthObj(i))) == NULLGTKSEPARATORMENUITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSeparatorMenuItem *gtkseparatormenuitem_copy(NspGtkSeparatorMenuItem *self)
{
  /* return gtkmenuitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkseparatormenuitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkseparatormenuitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSeparatorMenuItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_separator_menu_item_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_separator_menu_item_new())== NULL) return RET_BUG;

  nsp_type_gtkseparatormenuitem = new_type_gtkseparatormenuitem(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkseparatormenuitem);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkseparatormenuitem_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkseparatormenuitem_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkToolbar ----------- */


#define  NspGtkToolbar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktoolbar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkToolbar inherits from GtkContainer 
 * and implements GtkBuildable GtkOrientable GtkToolShell
 */

int nsp_type_gtktoolbar_id=0;
NspTypeGtkToolbar *nsp_type_gtktoolbar=NULL;

/*
 * Type object for NspGtkToolbar 
 * all the instance of NspTypeGtkToolbar share the same id. 
 * nsp_type_gtktoolbar: is an instance of NspTypeGtkToolbar 
 *    used for objects of NspGtkToolbar type (i.e built with new_gtktoolbar) 
 * other instances are used for derived classes 
 */
NspTypeGtkToolbar *new_type_gtktoolbar(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkOrientable *t_gtkorientable;
  NspTypeGtkToolShell *t_gtktoolshell;
  NspTypeGtkToolbar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktoolbar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktoolbar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktoolbar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktoolbar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktoolbar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktoolbar */ 

  top->s_type =  (s_type_func *) nsp_gtktoolbar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktoolbar_type_short_string;
  /* top->create = (create_func*) int_gtktoolbar_create;*/

  /* specific methods for gtktoolbar */

  type->init = (init_func *) init_gtktoolbar;

  /* 
   * NspGtkToolbar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  t_gtkorientable = new_type_gtkorientable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkorientable;
  t_gtktoolshell = new_type_gtktoolshell(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gtktoolshell;
  if ( nsp_type_gtktoolbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkToolbar called nsp_type_gtktoolbar
       */
      type->id =  nsp_type_gtktoolbar_id = nsp_new_type_id();
      nsp_type_gtktoolbar = type;
      if ( nsp_register_type(nsp_type_gtktoolbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktoolbar, GTK_TYPE_TOOLBAR);
      return ( mode == T_BASE ) ? type : new_type_gtktoolbar(mode);
    }
  else 
    {
      type->id = nsp_type_gtktoolbar_id;
      return type;
    }
}

/*
 * initialize NspGtkToolbar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktoolbar(NspGtkToolbar *Obj,NspTypeGtkToolbar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkToolbar 
 */

NspGtkToolbar *new_gtktoolbar() 
{
  NspGtkToolbar *loc;
  /* type must exists */
  nsp_type_gtktoolbar = new_type_gtktoolbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkToolbar)))== NULLGTKTOOLBAR) return loc;
  /* initialize object */
  if ( init_gtktoolbar(loc,nsp_type_gtktoolbar) == FAIL) return NULLGTKTOOLBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkToolbar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktoolbar_type_name[]="GtkToolbar";
static char gtktoolbar_short_type_name[]="GtkToolbar";

static char *nsp_gtktoolbar_type_as_string(void)
{
  return(gtktoolbar_type_name);
}

static char *nsp_gtktoolbar_type_short_string(NspObject *v)
{
  return(gtktoolbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkToolbar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkToolbar   *nsp_gtktoolbar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktoolbar_id)  == TRUE  ) return ((NspGtkToolbar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktoolbar));
  return NULL;
}

int IsGtkToolbarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktoolbar_id);
}

int IsGtkToolbar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktoolbar_id);
}

NspGtkToolbar  *GetGtkToolbarCopy(Stack stack, int i)
{
  if (  GetGtkToolbar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkToolbar  *GetGtkToolbar(Stack stack, int i)
{
  NspGtkToolbar *M;
  if (( M = nsp_gtktoolbar_object(NthObj(i))) == NULLGTKTOOLBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkToolbar *gtktoolbar_copy(NspGtkToolbar *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkToolbar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_toolbar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_toolbar_new())== NULL) return RET_BUG;

  nsp_type_gtktoolbar = new_type_gtktoolbar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktoolbar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_toolbar_insert(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *item;
  int pos;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktoolitem, &item, &pos) == FAIL) return RET_BUG;
    gtk_toolbar_insert(GTK_TOOLBAR(self->obj),GTK_TOOL_ITEM(item->obj),pos);
  return 0;
}

static int _wrap_gtk_toolbar_get_item_index(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *item;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktoolitem, &item) == FAIL) return RET_BUG;
    ret =gtk_toolbar_get_item_index(GTK_TOOLBAR(self->obj),GTK_TOOL_ITEM(item->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toolbar_get_n_items(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_toolbar_get_n_items(GTK_TOOLBAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toolbar_get_nth_item(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int n;
  GtkToolItem *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&n) == FAIL) return RET_BUG;
    ret =gtk_toolbar_get_nth_item(GTK_TOOLBAR(self->obj),n);
  nsp_type_gtktoolitem = new_type_gtktoolitem(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktoolitem))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_toolbar_get_show_arrow(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_toolbar_get_show_arrow(GTK_TOOLBAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toolbar_set_show_arrow(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_arrow;
  if ( GetArgs(stack,rhs,opt,T,&show_arrow) == FAIL) return RET_BUG;
    gtk_toolbar_set_show_arrow(GTK_TOOLBAR(self->obj),show_arrow);
  return 0;
}

static int _wrap_gtk_toolbar_get_style(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_toolbar_get_style(GTK_TOOLBAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toolbar_set_style(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkToolbarStyle style;
  NspObject *nsp_style = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_style) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TOOLBAR_STYLE, nsp_style, &style)== FAIL)
      return RET_BUG;
    gtk_toolbar_set_style(GTK_TOOLBAR(self->obj),style);
  return 0;
}

static int _wrap_gtk_toolbar_unset_style(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_toolbar_unset_style(GTK_TOOLBAR(self->obj));
  return 0;
}

static int _wrap_gtk_toolbar_get_icon_size(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_toolbar_get_icon_size(GTK_TOOLBAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toolbar_set_icon_size(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkIconSize icon_size;
  NspObject *nsp_icon_size = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_icon_size, &icon_size)== FAIL)
      return RET_BUG;
    gtk_toolbar_set_icon_size(GTK_TOOLBAR(self->obj),icon_size);
  return 0;
}

static int _wrap_gtk_toolbar_unset_icon_size(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_toolbar_unset_icon_size(GTK_TOOLBAR(self->obj));
  return 0;
}

static int _wrap_gtk_toolbar_get_relief_style(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_toolbar_get_relief_style(GTK_TOOLBAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toolbar_get_drop_index(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int x, y, ret;
  if ( GetArgs(stack,rhs,opt,T,&x, &y) == FAIL) return RET_BUG;
    ret =gtk_toolbar_get_drop_index(GTK_TOOLBAR(self->obj),x,y);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_toolbar_set_drop_highlight_item(NspGtkToolbar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"tool_item",obj,NULLOBJ,-1},
	{"index_",s_int,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkToolItem *tool_item = NULL;
  NspGObject *nsp_tool_item = NULL;
  int index_;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_tool_item, &index_) == FAIL) return RET_BUG;
  if ( nsp_tool_item != NULL ) {
    if ( IsGtkToolItem((NspObject *)nsp_tool_item))
      tool_item = GTK_TOOL_ITEM(nsp_tool_item->obj);
    else if (! IsNone((NspObject *)nsp_tool_item)) {
         Scierror( "Error: tool_item should be a GtkToolItem or None\n");
         return RET_BUG;
    }
  }
    gtk_toolbar_set_drop_highlight_item(GTK_TOOLBAR(self->obj),tool_item,index_);
  return 0;
}

static NspMethods gtktoolbar_methods[] = {
  {"insert",(nsp_method *) _wrap_gtk_toolbar_insert},
  {"get_item_index",(nsp_method *) _wrap_gtk_toolbar_get_item_index},
  {"get_n_items",(nsp_method *) _wrap_gtk_toolbar_get_n_items},
  {"get_nth_item",(nsp_method *) _wrap_gtk_toolbar_get_nth_item},
  {"get_show_arrow",(nsp_method *) _wrap_gtk_toolbar_get_show_arrow},
  {"set_show_arrow",(nsp_method *) _wrap_gtk_toolbar_set_show_arrow},
  {"get_style",(nsp_method *) _wrap_gtk_toolbar_get_style},
  {"set_style",(nsp_method *) _wrap_gtk_toolbar_set_style},
  {"unset_style",(nsp_method *) _wrap_gtk_toolbar_unset_style},
  {"get_icon_size",(nsp_method *) _wrap_gtk_toolbar_get_icon_size},
  {"set_icon_size",(nsp_method *) _wrap_gtk_toolbar_set_icon_size},
  {"unset_icon_size",(nsp_method *) _wrap_gtk_toolbar_unset_icon_size},
  {"get_relief_style",(nsp_method *) _wrap_gtk_toolbar_get_relief_style},
  {"get_drop_index",(nsp_method *) _wrap_gtk_toolbar_get_drop_index},
  {"set_drop_highlight_item",(nsp_method *) _wrap_gtk_toolbar_set_drop_highlight_item},
  { NULL, NULL}
};

static NspMethods *gtktoolbar_get_methods(void) { return gtktoolbar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktoolbar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkToolItem ----------- */


#define  NspGtkToolItem_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktoolitem.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkToolItem inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtktoolitem_id=0;
NspTypeGtkToolItem *nsp_type_gtktoolitem=NULL;

/*
 * Type object for NspGtkToolItem 
 * all the instance of NspTypeGtkToolItem share the same id. 
 * nsp_type_gtktoolitem: is an instance of NspTypeGtkToolItem 
 *    used for objects of NspGtkToolItem type (i.e built with new_gtktoolitem) 
 * other instances are used for derived classes 
 */
NspTypeGtkToolItem *new_type_gtktoolitem(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkToolItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktoolitem != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktoolitem;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktoolitem_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktoolitem_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktoolitem;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktoolitem */ 

  top->s_type =  (s_type_func *) nsp_gtktoolitem_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktoolitem_type_short_string;
  /* top->create = (create_func*) int_gtktoolitem_create;*/

  /* specific methods for gtktoolitem */

  type->init = (init_func *) init_gtktoolitem;

  /* 
   * NspGtkToolItem interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtktoolitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkToolItem called nsp_type_gtktoolitem
       */
      type->id =  nsp_type_gtktoolitem_id = nsp_new_type_id();
      nsp_type_gtktoolitem = type;
      if ( nsp_register_type(nsp_type_gtktoolitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktoolitem, GTK_TYPE_TOOL_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtktoolitem(mode);
    }
  else 
    {
      type->id = nsp_type_gtktoolitem_id;
      return type;
    }
}

/*
 * initialize NspGtkToolItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktoolitem(NspGtkToolItem *Obj,NspTypeGtkToolItem *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkToolItem 
 */

NspGtkToolItem *new_gtktoolitem() 
{
  NspGtkToolItem *loc;
  /* type must exists */
  nsp_type_gtktoolitem = new_type_gtktoolitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkToolItem)))== NULLGTKTOOLITEM) return loc;
  /* initialize object */
  if ( init_gtktoolitem(loc,nsp_type_gtktoolitem) == FAIL) return NULLGTKTOOLITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkToolItem 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktoolitem_type_name[]="GtkToolItem";
static char gtktoolitem_short_type_name[]="GtkToolItem";

static char *nsp_gtktoolitem_type_as_string(void)
{
  return(gtktoolitem_type_name);
}

static char *nsp_gtktoolitem_type_short_string(NspObject *v)
{
  return(gtktoolitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkToolItem objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkToolItem   *nsp_gtktoolitem_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktoolitem_id)  == TRUE  ) return ((NspGtkToolItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktoolitem));
  return NULL;
}

int IsGtkToolItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktoolitem_id);
}

int IsGtkToolItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktoolitem_id);
}

NspGtkToolItem  *GetGtkToolItemCopy(Stack stack, int i)
{
  if (  GetGtkToolItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkToolItem  *GetGtkToolItem(Stack stack, int i)
{
  NspGtkToolItem *M;
  if (( M = nsp_gtktoolitem_object(NthObj(i))) == NULLGTKTOOLITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkToolItem *gtktoolitem_copy(NspGtkToolItem *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkToolItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_tool_item_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_tool_item_new())== NULL) return RET_BUG;

  nsp_type_gtktoolitem = new_type_gtktoolitem(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktoolitem);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_item_set_homogeneous(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int homogeneous;
  if ( GetArgs(stack,rhs,opt,T,&homogeneous) == FAIL) return RET_BUG;
    gtk_tool_item_set_homogeneous(GTK_TOOL_ITEM(self->obj),homogeneous);
  return 0;
}

static int _wrap_gtk_tool_item_get_homogeneous(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_homogeneous(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_set_expand(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int expand;
  if ( GetArgs(stack,rhs,opt,T,&expand) == FAIL) return RET_BUG;
    gtk_tool_item_set_expand(GTK_TOOL_ITEM(self->obj),expand);
  return 0;
}

static int _wrap_gtk_tool_item_get_expand(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_expand(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_set_tooltip_text(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    gtk_tool_item_set_tooltip_text(GTK_TOOL_ITEM(self->obj),text);
  return 0;
}

static int _wrap_gtk_tool_item_set_tooltip_markup(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *markup;
  if ( GetArgs(stack,rhs,opt,T,&markup) == FAIL) return RET_BUG;
    gtk_tool_item_set_tooltip_markup(GTK_TOOL_ITEM(self->obj),markup);
  return 0;
}

static int _wrap_gtk_tool_item_set_use_drag_window(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_drag_window;
  if ( GetArgs(stack,rhs,opt,T,&use_drag_window) == FAIL) return RET_BUG;
    gtk_tool_item_set_use_drag_window(GTK_TOOL_ITEM(self->obj),use_drag_window);
  return 0;
}

static int _wrap_gtk_tool_item_get_use_drag_window(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_use_drag_window(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_set_visible_horizontal(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int visible_horizontal;
  if ( GetArgs(stack,rhs,opt,T,&visible_horizontal) == FAIL) return RET_BUG;
    gtk_tool_item_set_visible_horizontal(GTK_TOOL_ITEM(self->obj),visible_horizontal);
  return 0;
}

static int _wrap_gtk_tool_item_get_visible_horizontal(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_visible_horizontal(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_set_visible_vertical(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int visible_vertical;
  if ( GetArgs(stack,rhs,opt,T,&visible_vertical) == FAIL) return RET_BUG;
    gtk_tool_item_set_visible_vertical(GTK_TOOL_ITEM(self->obj),visible_vertical);
  return 0;
}

static int _wrap_gtk_tool_item_get_visible_vertical(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_visible_vertical(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_get_is_important(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_is_important(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_set_is_important(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int is_important;
  if ( GetArgs(stack,rhs,opt,T,&is_important) == FAIL) return RET_BUG;
    gtk_tool_item_set_is_important(GTK_TOOL_ITEM(self->obj),is_important);
  return 0;
}

static int _wrap_gtk_tool_item_get_ellipsize_mode(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_ellipsize_mode(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_get_icon_size(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_icon_size(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_get_orientation(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_orientation(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_get_toolbar_style(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_toolbar_style(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_get_relief_style(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_relief_style(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_get_text_alignment(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_text_alignment(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_get_text_orientation(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_text_orientation(GTK_TOOL_ITEM(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_get_text_size_group(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkSizeGroup *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_get_text_size_group(GTK_TOOL_ITEM(self->obj));
  nsp_type_gtksizegroup = new_type_gtksizegroup(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtksizegroup))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_item_retrieve_proxy_menu_item(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_retrieve_proxy_menu_item(GTK_TOOL_ITEM(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_item_get_proxy_menu_item(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *menu_item_id;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&menu_item_id) == FAIL) return RET_BUG;
    ret =gtk_tool_item_get_proxy_menu_item(GTK_TOOL_ITEM(self->obj),menu_item_id);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_item_set_proxy_menu_item(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,new_opts, t_end};
  nsp_option opts[] = {
	{"menu_item",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  char *menu_item_id;
  GtkWidget *menu_item = NULL;
  NspGObject *nsp_menu_item = NULL;
  if ( GetArgs(stack,rhs,opt,T,&menu_item_id, opts, &nsp_menu_item) == FAIL) return RET_BUG;
  if ( nsp_menu_item != NULL ) {
    if ( IsGtkWidget((NspObject *)nsp_menu_item))
      menu_item = GTK_WIDGET(nsp_menu_item->obj);
    else if (! IsNone((NspObject *)nsp_menu_item)) {
         Scierror( "Error: menu_item should be a GtkWidget or None\n");
         return RET_BUG;
    }
  }
    gtk_tool_item_set_proxy_menu_item(GTK_TOOL_ITEM(self->obj),menu_item_id,menu_item);
  return 0;
}

static int _wrap_gtk_tool_item_rebuild_menu(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tool_item_rebuild_menu(GTK_TOOL_ITEM(self->obj));
  return 0;
}

static int _wrap_gtk_tool_item_toolbar_reconfigured(NspGtkToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tool_item_toolbar_reconfigured(GTK_TOOL_ITEM(self->obj));
  return 0;
}

static NspMethods gtktoolitem_methods[] = {
  {"set_homogeneous",(nsp_method *) _wrap_gtk_tool_item_set_homogeneous},
  {"get_homogeneous",(nsp_method *) _wrap_gtk_tool_item_get_homogeneous},
  {"set_expand",(nsp_method *) _wrap_gtk_tool_item_set_expand},
  {"get_expand",(nsp_method *) _wrap_gtk_tool_item_get_expand},
  {"set_tooltip_text",(nsp_method *) _wrap_gtk_tool_item_set_tooltip_text},
  {"set_tooltip_markup",(nsp_method *) _wrap_gtk_tool_item_set_tooltip_markup},
  {"set_use_drag_window",(nsp_method *) _wrap_gtk_tool_item_set_use_drag_window},
  {"get_use_drag_window",(nsp_method *) _wrap_gtk_tool_item_get_use_drag_window},
  {"set_visible_horizontal",(nsp_method *) _wrap_gtk_tool_item_set_visible_horizontal},
  {"get_visible_horizontal",(nsp_method *) _wrap_gtk_tool_item_get_visible_horizontal},
  {"set_visible_vertical",(nsp_method *) _wrap_gtk_tool_item_set_visible_vertical},
  {"get_visible_vertical",(nsp_method *) _wrap_gtk_tool_item_get_visible_vertical},
  {"get_is_important",(nsp_method *) _wrap_gtk_tool_item_get_is_important},
  {"set_is_important",(nsp_method *) _wrap_gtk_tool_item_set_is_important},
  {"get_ellipsize_mode",(nsp_method *) _wrap_gtk_tool_item_get_ellipsize_mode},
  {"get_icon_size",(nsp_method *) _wrap_gtk_tool_item_get_icon_size},
  {"get_orientation",(nsp_method *) _wrap_gtk_tool_item_get_orientation},
  {"get_toolbar_style",(nsp_method *) _wrap_gtk_tool_item_get_toolbar_style},
  {"get_relief_style",(nsp_method *) _wrap_gtk_tool_item_get_relief_style},
  {"get_text_alignment",(nsp_method *) _wrap_gtk_tool_item_get_text_alignment},
  {"get_text_orientation",(nsp_method *) _wrap_gtk_tool_item_get_text_orientation},
  {"get_text_size_group",(nsp_method *) _wrap_gtk_tool_item_get_text_size_group},
  {"retrieve_proxy_menu_item",(nsp_method *) _wrap_gtk_tool_item_retrieve_proxy_menu_item},
  {"get_proxy_menu_item",(nsp_method *) _wrap_gtk_tool_item_get_proxy_menu_item},
  {"set_proxy_menu_item",(nsp_method *) _wrap_gtk_tool_item_set_proxy_menu_item},
  {"rebuild_menu",(nsp_method *) _wrap_gtk_tool_item_rebuild_menu},
  {"toolbar_reconfigured",(nsp_method *) _wrap_gtk_tool_item_toolbar_reconfigured},
  { NULL, NULL}
};

static NspMethods *gtktoolitem_get_methods(void) { return gtktoolitem_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktoolitem_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkToolPalette ----------- */


#define  NspGtkToolPalette_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktoolpalette.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkToolPalette inherits from GtkContainer 
 * and implements GtkOrientable GtkScrollable GtkBuildable
 */

int nsp_type_gtktoolpalette_id=0;
NspTypeGtkToolPalette *nsp_type_gtktoolpalette=NULL;

/*
 * Type object for NspGtkToolPalette 
 * all the instance of NspTypeGtkToolPalette share the same id. 
 * nsp_type_gtktoolpalette: is an instance of NspTypeGtkToolPalette 
 *    used for objects of NspGtkToolPalette type (i.e built with new_gtktoolpalette) 
 * other instances are used for derived classes 
 */
NspTypeGtkToolPalette *new_type_gtktoolpalette(type_mode mode)
{
  NspTypeGtkOrientable *t_gtkorientable;
  NspTypeGtkScrollable *t_gtkscrollable;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkToolPalette *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktoolpalette != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktoolpalette;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktoolpalette_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktoolpalette_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktoolpalette;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktoolpalette */ 

  top->s_type =  (s_type_func *) nsp_gtktoolpalette_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktoolpalette_type_short_string;
  /* top->create = (create_func*) int_gtktoolpalette_create;*/

  /* specific methods for gtktoolpalette */

  type->init = (init_func *) init_gtktoolpalette;

  /* 
   * NspGtkToolPalette interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkorientable = new_type_gtkorientable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkorientable;
  t_gtkscrollable = new_type_gtkscrollable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkscrollable;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtktoolpalette_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkToolPalette called nsp_type_gtktoolpalette
       */
      type->id =  nsp_type_gtktoolpalette_id = nsp_new_type_id();
      nsp_type_gtktoolpalette = type;
      if ( nsp_register_type(nsp_type_gtktoolpalette) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktoolpalette, GTK_TYPE_TOOL_PALETTE);
      return ( mode == T_BASE ) ? type : new_type_gtktoolpalette(mode);
    }
  else 
    {
      type->id = nsp_type_gtktoolpalette_id;
      return type;
    }
}

/*
 * initialize NspGtkToolPalette instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktoolpalette(NspGtkToolPalette *Obj,NspTypeGtkToolPalette *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkToolPalette 
 */

NspGtkToolPalette *new_gtktoolpalette() 
{
  NspGtkToolPalette *loc;
  /* type must exists */
  nsp_type_gtktoolpalette = new_type_gtktoolpalette(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkToolPalette)))== NULLGTKTOOLPALETTE) return loc;
  /* initialize object */
  if ( init_gtktoolpalette(loc,nsp_type_gtktoolpalette) == FAIL) return NULLGTKTOOLPALETTE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkToolPalette 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktoolpalette_type_name[]="GtkToolPalette";
static char gtktoolpalette_short_type_name[]="GtkToolPalette";

static char *nsp_gtktoolpalette_type_as_string(void)
{
  return(gtktoolpalette_type_name);
}

static char *nsp_gtktoolpalette_type_short_string(NspObject *v)
{
  return(gtktoolpalette_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkToolPalette objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkToolPalette   *nsp_gtktoolpalette_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktoolpalette_id)  == TRUE  ) return ((NspGtkToolPalette *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktoolpalette));
  return NULL;
}

int IsGtkToolPaletteObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktoolpalette_id);
}

int IsGtkToolPalette(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktoolpalette_id);
}

NspGtkToolPalette  *GetGtkToolPaletteCopy(Stack stack, int i)
{
  if (  GetGtkToolPalette(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkToolPalette  *GetGtkToolPalette(Stack stack, int i)
{
  NspGtkToolPalette *M;
  if (( M = nsp_gtktoolpalette_object(NthObj(i))) == NULLGTKTOOLPALETTE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkToolPalette *gtktoolpalette_copy(NspGtkToolPalette *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolpalette);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolpalette);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkToolPalette
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_tool_palette_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_tool_palette_new())== NULL) return RET_BUG;

  nsp_type_gtktoolpalette = new_type_gtktoolpalette(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktoolpalette);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_palette_set_group_position(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *group;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktoolitemgroup, &group, &position) == FAIL) return RET_BUG;
    gtk_tool_palette_set_group_position(GTK_TOOL_PALETTE(self->obj),GTK_TOOL_ITEM_GROUP(group->obj),position);
  return 0;
}

static int _wrap_gtk_tool_palette_set_exclusive(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *group;
  int exclusive;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktoolitemgroup, &group, &exclusive) == FAIL) return RET_BUG;
    gtk_tool_palette_set_exclusive(GTK_TOOL_PALETTE(self->obj),GTK_TOOL_ITEM_GROUP(group->obj),exclusive);
  return 0;
}

static int _wrap_gtk_tool_palette_set_expand(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *group;
  int expand;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktoolitemgroup, &group, &expand) == FAIL) return RET_BUG;
    gtk_tool_palette_set_expand(GTK_TOOL_PALETTE(self->obj),GTK_TOOL_ITEM_GROUP(group->obj),expand);
  return 0;
}

static int _wrap_gtk_tool_palette_get_group_position(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *group;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktoolitemgroup, &group) == FAIL) return RET_BUG;
    ret =gtk_tool_palette_get_group_position(GTK_TOOL_PALETTE(self->obj),GTK_TOOL_ITEM_GROUP(group->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_palette_get_exclusive(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *group;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktoolitemgroup, &group) == FAIL) return RET_BUG;
    ret =gtk_tool_palette_get_exclusive(GTK_TOOL_PALETTE(self->obj),GTK_TOOL_ITEM_GROUP(group->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_palette_get_expand(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *group;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktoolitemgroup, &group) == FAIL) return RET_BUG;
    ret =gtk_tool_palette_get_expand(GTK_TOOL_PALETTE(self->obj),GTK_TOOL_ITEM_GROUP(group->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_palette_set_icon_size(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkIconSize icon_size;
  NspObject *nsp_icon_size = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_icon_size, &icon_size)== FAIL)
      return RET_BUG;
    gtk_tool_palette_set_icon_size(GTK_TOOL_PALETTE(self->obj),icon_size);
  return 0;
}

static int _wrap_gtk_tool_palette_unset_icon_size(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tool_palette_unset_icon_size(GTK_TOOL_PALETTE(self->obj));
  return 0;
}

static int _wrap_gtk_tool_palette_set_style(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkToolbarStyle style;
  NspObject *nsp_style = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_style) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TOOLBAR_STYLE, nsp_style, &style)== FAIL)
      return RET_BUG;
    gtk_tool_palette_set_style(GTK_TOOL_PALETTE(self->obj),style);
  return 0;
}

static int _wrap_gtk_tool_palette_unset_style(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_tool_palette_unset_style(GTK_TOOL_PALETTE(self->obj));
  return 0;
}

static int _wrap_gtk_tool_palette_get_icon_size(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_palette_get_icon_size(GTK_TOOL_PALETTE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_palette_get_style(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_palette_get_style(GTK_TOOL_PALETTE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_palette_get_drop_item(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int x, y;
  GtkToolItem *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&x, &y) == FAIL) return RET_BUG;
    ret =gtk_tool_palette_get_drop_item(GTK_TOOL_PALETTE(self->obj),x,y);
  nsp_type_gtktoolitem = new_type_gtktoolitem(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktoolitem))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_palette_get_drop_group(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int x, y;
  GtkToolItemGroup *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&x, &y) == FAIL) return RET_BUG;
    ret =gtk_tool_palette_get_drop_group(GTK_TOOL_PALETTE(self->obj),x,y);
  nsp_type_gtktoolitemgroup = new_type_gtktoolitemgroup(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktoolitemgroup))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_palette_get_drag_item(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSelectionData *selection = NULL;
  NspObject *nsp_selection = NULL, *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_selection) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_selection, GTK_TYPE_SELECTION_DATA))
      selection = nspg_boxed_get(nsp_selection, GtkSelectionData);
  else {
      Scierror( "Error: selection should be a GtkSelectionData\n");
      return RET_BUG;
  }
    ret =gtk_tool_palette_get_drag_item(GTK_TOOL_PALETTE(self->obj),selection);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_palette_set_drag_source(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkToolPaletteDragTargets targets;
  NspObject *nsp_targets = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_targets) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_TOOL_PALETTE_DRAG_TARGETS, nsp_targets, &targets)==FAIL)
      return RET_BUG;
    gtk_tool_palette_set_drag_source(GTK_TOOL_PALETTE(self->obj),targets);
  return 0;
}

static int _wrap_gtk_tool_palette_add_drag_dest(NspGtkToolPalette *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj,obj,obj, t_end};
  NspGObject *widget;
  GtkDestDefaults flags;
  NspObject *nsp_flags = NULL, *nsp_targets = NULL, *nsp_actions = NULL;
  GtkToolPaletteDragTargets targets;
  GdkDragAction actions;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_flags, &nsp_targets, &nsp_actions) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_TOOL_PALETTE_DRAG_TARGETS, nsp_targets, &targets)==FAIL)
      return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION, nsp_actions, &actions)==FAIL)
      return RET_BUG;
    gtk_tool_palette_add_drag_dest(GTK_TOOL_PALETTE(self->obj),GTK_WIDGET(widget->obj),flags,targets,actions);
  return 0;
}

static NspMethods gtktoolpalette_methods[] = {
  {"set_group_position",(nsp_method *) _wrap_gtk_tool_palette_set_group_position},
  {"set_exclusive",(nsp_method *) _wrap_gtk_tool_palette_set_exclusive},
  {"set_expand",(nsp_method *) _wrap_gtk_tool_palette_set_expand},
  {"get_group_position",(nsp_method *) _wrap_gtk_tool_palette_get_group_position},
  {"get_exclusive",(nsp_method *) _wrap_gtk_tool_palette_get_exclusive},
  {"get_expand",(nsp_method *) _wrap_gtk_tool_palette_get_expand},
  {"set_icon_size",(nsp_method *) _wrap_gtk_tool_palette_set_icon_size},
  {"unset_icon_size",(nsp_method *) _wrap_gtk_tool_palette_unset_icon_size},
  {"set_style",(nsp_method *) _wrap_gtk_tool_palette_set_style},
  {"unset_style",(nsp_method *) _wrap_gtk_tool_palette_unset_style},
  {"get_icon_size",(nsp_method *) _wrap_gtk_tool_palette_get_icon_size},
  {"get_style",(nsp_method *) _wrap_gtk_tool_palette_get_style},
  {"get_drop_item",(nsp_method *) _wrap_gtk_tool_palette_get_drop_item},
  {"get_drop_group",(nsp_method *) _wrap_gtk_tool_palette_get_drop_group},
  {"get_drag_item",(nsp_method *) _wrap_gtk_tool_palette_get_drag_item},
  {"set_drag_source",(nsp_method *) _wrap_gtk_tool_palette_set_drag_source},
  {"add_drag_dest",(nsp_method *) _wrap_gtk_tool_palette_add_drag_dest},
  { NULL, NULL}
};

static NspMethods *gtktoolpalette_get_methods(void) { return gtktoolpalette_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktoolpalette_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkToolItemGroup ----------- */


#define  NspGtkToolItemGroup_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktoolitemgroup.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkToolItemGroup inherits from GtkContainer 
 * and implements GtkToolShell GtkBuildable
 */

int nsp_type_gtktoolitemgroup_id=0;
NspTypeGtkToolItemGroup *nsp_type_gtktoolitemgroup=NULL;

/*
 * Type object for NspGtkToolItemGroup 
 * all the instance of NspTypeGtkToolItemGroup share the same id. 
 * nsp_type_gtktoolitemgroup: is an instance of NspTypeGtkToolItemGroup 
 *    used for objects of NspGtkToolItemGroup type (i.e built with new_gtktoolitemgroup) 
 * other instances are used for derived classes 
 */
NspTypeGtkToolItemGroup *new_type_gtktoolitemgroup(type_mode mode)
{
  NspTypeGtkToolShell *t_gtktoolshell;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkToolItemGroup *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktoolitemgroup != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktoolitemgroup;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktoolitemgroup_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktoolitemgroup_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktoolitemgroup;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktoolitemgroup */ 

  top->s_type =  (s_type_func *) nsp_gtktoolitemgroup_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktoolitemgroup_type_short_string;
  /* top->create = (create_func*) int_gtktoolitemgroup_create;*/

  /* specific methods for gtktoolitemgroup */

  type->init = (init_func *) init_gtktoolitemgroup;

  /* 
   * NspGtkToolItemGroup interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtktoolshell = new_type_gtktoolshell(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtktoolshell;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtktoolitemgroup_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkToolItemGroup called nsp_type_gtktoolitemgroup
       */
      type->id =  nsp_type_gtktoolitemgroup_id = nsp_new_type_id();
      nsp_type_gtktoolitemgroup = type;
      if ( nsp_register_type(nsp_type_gtktoolitemgroup) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktoolitemgroup, GTK_TYPE_TOOL_ITEM_GROUP);
      return ( mode == T_BASE ) ? type : new_type_gtktoolitemgroup(mode);
    }
  else 
    {
      type->id = nsp_type_gtktoolitemgroup_id;
      return type;
    }
}

/*
 * initialize NspGtkToolItemGroup instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktoolitemgroup(NspGtkToolItemGroup *Obj,NspTypeGtkToolItemGroup *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkToolItemGroup 
 */

NspGtkToolItemGroup *new_gtktoolitemgroup() 
{
  NspGtkToolItemGroup *loc;
  /* type must exists */
  nsp_type_gtktoolitemgroup = new_type_gtktoolitemgroup(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkToolItemGroup)))== NULLGTKTOOLITEMGROUP) return loc;
  /* initialize object */
  if ( init_gtktoolitemgroup(loc,nsp_type_gtktoolitemgroup) == FAIL) return NULLGTKTOOLITEMGROUP;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkToolItemGroup 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktoolitemgroup_type_name[]="GtkToolItemGroup";
static char gtktoolitemgroup_short_type_name[]="GtkToolItemGroup";

static char *nsp_gtktoolitemgroup_type_as_string(void)
{
  return(gtktoolitemgroup_type_name);
}

static char *nsp_gtktoolitemgroup_type_short_string(NspObject *v)
{
  return(gtktoolitemgroup_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkToolItemGroup objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkToolItemGroup   *nsp_gtktoolitemgroup_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktoolitemgroup_id)  == TRUE  ) return ((NspGtkToolItemGroup *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktoolitemgroup));
  return NULL;
}

int IsGtkToolItemGroupObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktoolitemgroup_id);
}

int IsGtkToolItemGroup(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktoolitemgroup_id);
}

NspGtkToolItemGroup  *GetGtkToolItemGroupCopy(Stack stack, int i)
{
  if (  GetGtkToolItemGroup(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkToolItemGroup  *GetGtkToolItemGroup(Stack stack, int i)
{
  NspGtkToolItemGroup *M;
  if (( M = nsp_gtktoolitemgroup_object(NthObj(i))) == NULLGTKTOOLITEMGROUP)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkToolItemGroup *gtktoolitemgroup_copy(NspGtkToolItemGroup *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolitemgroup);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolitemgroup);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkToolItemGroup
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_tool_item_group_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *label;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_tool_item_group_new(label))== NULL) return RET_BUG;

  nsp_type_gtktoolitemgroup = new_type_gtktoolitemgroup(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktoolitemgroup);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_item_group_set_label(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *label;
  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
    gtk_tool_item_group_set_label(GTK_TOOL_ITEM_GROUP(self->obj),label);
  return 0;
}

static int _wrap_gtk_tool_item_group_set_label_widget(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *label_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &label_widget) == FAIL) return RET_BUG;
    gtk_tool_item_group_set_label_widget(GTK_TOOL_ITEM_GROUP(self->obj),GTK_WIDGET(label_widget->obj));
  return 0;
}

static int _wrap_gtk_tool_item_group_set_collapsed(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int collapsed;
  if ( GetArgs(stack,rhs,opt,T,&collapsed) == FAIL) return RET_BUG;
    gtk_tool_item_group_set_collapsed(GTK_TOOL_ITEM_GROUP(self->obj),collapsed);
  return 0;
}

static int _wrap_gtk_tool_item_group_set_ellipsize(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  PangoEllipsizeMode ellipsize;
  NspObject *nsp_ellipsize = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_ellipsize) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(PANGO_TYPE_ELLIPSIZE_MODE, nsp_ellipsize, &ellipsize)== FAIL)
      return RET_BUG;
    gtk_tool_item_group_set_ellipsize(GTK_TOOL_ITEM_GROUP(self->obj),ellipsize);
  return 0;
}

static int _wrap_gtk_tool_item_group_set_header_relief(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkReliefStyle style;
  NspObject *nsp_style = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_style) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_RELIEF_STYLE, nsp_style, &style)== FAIL)
      return RET_BUG;
    gtk_tool_item_group_set_header_relief(GTK_TOOL_ITEM_GROUP(self->obj),style);
  return 0;
}

static int _wrap_gtk_tool_item_group_get_label(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_group_get_label(GTK_TOOL_ITEM_GROUP(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_group_get_label_widget(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_group_get_label_widget(GTK_TOOL_ITEM_GROUP(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_item_group_get_collapsed(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_group_get_collapsed(GTK_TOOL_ITEM_GROUP(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_group_get_ellipsize(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_group_get_ellipsize(GTK_TOOL_ITEM_GROUP(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_group_get_header_relief(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_group_get_header_relief(GTK_TOOL_ITEM_GROUP(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_group_insert(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *item;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktoolitem, &item, &position) == FAIL) return RET_BUG;
    gtk_tool_item_group_insert(GTK_TOOL_ITEM_GROUP(self->obj),GTK_TOOL_ITEM(item->obj),position);
  return 0;
}

static int _wrap_gtk_tool_item_group_set_item_position(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *item;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktoolitem, &item, &position) == FAIL) return RET_BUG;
    gtk_tool_item_group_set_item_position(GTK_TOOL_ITEM_GROUP(self->obj),GTK_TOOL_ITEM(item->obj),position);
  return 0;
}

static int _wrap_gtk_tool_item_group_get_item_position(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *item;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktoolitem, &item) == FAIL) return RET_BUG;
    ret =gtk_tool_item_group_get_item_position(GTK_TOOL_ITEM_GROUP(self->obj),GTK_TOOL_ITEM(item->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_group_get_n_items(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tool_item_group_get_n_items(GTK_TOOL_ITEM_GROUP(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_item_group_get_nth_item(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int index;
  GtkToolItem *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&index) == FAIL) return RET_BUG;
    ret =gtk_tool_item_group_get_nth_item(GTK_TOOL_ITEM_GROUP(self->obj),index);
  nsp_type_gtktoolitem = new_type_gtktoolitem(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktoolitem))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_item_group_get_drop_item(NspGtkToolItemGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int x, y;
  GtkToolItem *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&x, &y) == FAIL) return RET_BUG;
    ret =gtk_tool_item_group_get_drop_item(GTK_TOOL_ITEM_GROUP(self->obj),x,y);
  nsp_type_gtktoolitem = new_type_gtktoolitem(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktoolitem))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtktoolitemgroup_methods[] = {
  {"set_label",(nsp_method *) _wrap_gtk_tool_item_group_set_label},
  {"set_label_widget",(nsp_method *) _wrap_gtk_tool_item_group_set_label_widget},
  {"set_collapsed",(nsp_method *) _wrap_gtk_tool_item_group_set_collapsed},
  {"set_ellipsize",(nsp_method *) _wrap_gtk_tool_item_group_set_ellipsize},
  {"set_header_relief",(nsp_method *) _wrap_gtk_tool_item_group_set_header_relief},
  {"get_label",(nsp_method *) _wrap_gtk_tool_item_group_get_label},
  {"get_label_widget",(nsp_method *) _wrap_gtk_tool_item_group_get_label_widget},
  {"get_collapsed",(nsp_method *) _wrap_gtk_tool_item_group_get_collapsed},
  {"get_ellipsize",(nsp_method *) _wrap_gtk_tool_item_group_get_ellipsize},
  {"get_header_relief",(nsp_method *) _wrap_gtk_tool_item_group_get_header_relief},
  {"insert",(nsp_method *) _wrap_gtk_tool_item_group_insert},
  {"set_item_position",(nsp_method *) _wrap_gtk_tool_item_group_set_item_position},
  {"get_item_position",(nsp_method *) _wrap_gtk_tool_item_group_get_item_position},
  {"get_n_items",(nsp_method *) _wrap_gtk_tool_item_group_get_n_items},
  {"get_nth_item",(nsp_method *) _wrap_gtk_tool_item_group_get_nth_item},
  {"get_drop_item",(nsp_method *) _wrap_gtk_tool_item_group_get_drop_item},
  { NULL, NULL}
};

static NspMethods *gtktoolitemgroup_get_methods(void) { return gtktoolitemgroup_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktoolitemgroup_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkSeparatorToolItem ----------- */


#define  NspGtkSeparatorToolItem_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkseparatortoolitem.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkSeparatorToolItem inherits from GtkToolItem 
 * and implements GtkBuildable
 */

int nsp_type_gtkseparatortoolitem_id=0;
NspTypeGtkSeparatorToolItem *nsp_type_gtkseparatortoolitem=NULL;

/*
 * Type object for NspGtkSeparatorToolItem 
 * all the instance of NspTypeGtkSeparatorToolItem share the same id. 
 * nsp_type_gtkseparatortoolitem: is an instance of NspTypeGtkSeparatorToolItem 
 *    used for objects of NspGtkSeparatorToolItem type (i.e built with new_gtkseparatortoolitem) 
 * other instances are used for derived classes 
 */
NspTypeGtkSeparatorToolItem *new_type_gtkseparatortoolitem(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkSeparatorToolItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkseparatortoolitem != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkseparatortoolitem;
    }
  if (( type =  malloc(sizeof(NspTypeGtkToolItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtktoolitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkseparatortoolitem_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkseparatortoolitem_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkseparatortoolitem;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkseparatortoolitem */ 

  top->s_type =  (s_type_func *) nsp_gtkseparatortoolitem_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkseparatortoolitem_type_short_string;
  /* top->create = (create_func*) int_gtkseparatortoolitem_create;*/

  /* specific methods for gtkseparatortoolitem */

  type->init = (init_func *) init_gtkseparatortoolitem;

  /* 
   * NspGtkSeparatorToolItem interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkseparatortoolitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSeparatorToolItem called nsp_type_gtkseparatortoolitem
       */
      type->id =  nsp_type_gtkseparatortoolitem_id = nsp_new_type_id();
      nsp_type_gtkseparatortoolitem = type;
      if ( nsp_register_type(nsp_type_gtkseparatortoolitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkseparatortoolitem, GTK_TYPE_SEPARATOR_TOOL_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkseparatortoolitem(mode);
    }
  else 
    {
      type->id = nsp_type_gtkseparatortoolitem_id;
      return type;
    }
}

/*
 * initialize NspGtkSeparatorToolItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkseparatortoolitem(NspGtkSeparatorToolItem *Obj,NspTypeGtkSeparatorToolItem *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkSeparatorToolItem 
 */

NspGtkSeparatorToolItem *new_gtkseparatortoolitem() 
{
  NspGtkSeparatorToolItem *loc;
  /* type must exists */
  nsp_type_gtkseparatortoolitem = new_type_gtkseparatortoolitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSeparatorToolItem)))== NULLGTKSEPARATORTOOLITEM) return loc;
  /* initialize object */
  if ( init_gtkseparatortoolitem(loc,nsp_type_gtkseparatortoolitem) == FAIL) return NULLGTKSEPARATORTOOLITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkSeparatorToolItem 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkseparatortoolitem_type_name[]="GtkSeparatorToolItem";
static char gtkseparatortoolitem_short_type_name[]="GtkSeparatorToolItem";

static char *nsp_gtkseparatortoolitem_type_as_string(void)
{
  return(gtkseparatortoolitem_type_name);
}

static char *nsp_gtkseparatortoolitem_type_short_string(NspObject *v)
{
  return(gtkseparatortoolitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkSeparatorToolItem objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkSeparatorToolItem   *nsp_gtkseparatortoolitem_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkseparatortoolitem_id)  == TRUE  ) return ((NspGtkSeparatorToolItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkseparatortoolitem));
  return NULL;
}

int IsGtkSeparatorToolItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkseparatortoolitem_id);
}

int IsGtkSeparatorToolItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkseparatortoolitem_id);
}

NspGtkSeparatorToolItem  *GetGtkSeparatorToolItemCopy(Stack stack, int i)
{
  if (  GetGtkSeparatorToolItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSeparatorToolItem  *GetGtkSeparatorToolItem(Stack stack, int i)
{
  NspGtkSeparatorToolItem *M;
  if (( M = nsp_gtkseparatortoolitem_object(NthObj(i))) == NULLGTKSEPARATORTOOLITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSeparatorToolItem *gtkseparatortoolitem_copy(NspGtkSeparatorToolItem *self)
{
  /* return gtktoolitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkseparatortoolitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkseparatortoolitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSeparatorToolItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_separator_tool_item_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_separator_tool_item_new())== NULL) return RET_BUG;

  nsp_type_gtkseparatortoolitem = new_type_gtkseparatortoolitem(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkseparatortoolitem);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_separator_tool_item_get_draw(NspGtkSeparatorToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_separator_tool_item_get_draw(GTK_SEPARATOR_TOOL_ITEM(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_separator_tool_item_set_draw(NspGtkSeparatorToolItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int draw;
  if ( GetArgs(stack,rhs,opt,T,&draw) == FAIL) return RET_BUG;
    gtk_separator_tool_item_set_draw(GTK_SEPARATOR_TOOL_ITEM(self->obj),draw);
  return 0;
}

static NspMethods gtkseparatortoolitem_methods[] = {
  {"get_draw",(nsp_method *) _wrap_gtk_separator_tool_item_get_draw},
  {"set_draw",(nsp_method *) _wrap_gtk_separator_tool_item_set_draw},
  { NULL, NULL}
};

static NspMethods *gtkseparatortoolitem_get_methods(void) { return gtkseparatortoolitem_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkseparatortoolitem_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkToolButton ----------- */


#define  NspGtkToolButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktoolbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkToolButton inherits from GtkToolItem 
 * and implements GtkBuildable
 */

int nsp_type_gtktoolbutton_id=0;
NspTypeGtkToolButton *nsp_type_gtktoolbutton=NULL;

/*
 * Type object for NspGtkToolButton 
 * all the instance of NspTypeGtkToolButton share the same id. 
 * nsp_type_gtktoolbutton: is an instance of NspTypeGtkToolButton 
 *    used for objects of NspGtkToolButton type (i.e built with new_gtktoolbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkToolButton *new_type_gtktoolbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkToolButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktoolbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktoolbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkToolItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtktoolitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktoolbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktoolbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktoolbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktoolbutton */ 

  top->s_type =  (s_type_func *) nsp_gtktoolbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktoolbutton_type_short_string;
  /* top->create = (create_func*) int_gtktoolbutton_create;*/

  /* specific methods for gtktoolbutton */

  type->init = (init_func *) init_gtktoolbutton;

  /* 
   * NspGtkToolButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtktoolbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkToolButton called nsp_type_gtktoolbutton
       */
      type->id =  nsp_type_gtktoolbutton_id = nsp_new_type_id();
      nsp_type_gtktoolbutton = type;
      if ( nsp_register_type(nsp_type_gtktoolbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktoolbutton, GTK_TYPE_TOOL_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtktoolbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtktoolbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkToolButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktoolbutton(NspGtkToolButton *Obj,NspTypeGtkToolButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkToolButton 
 */

NspGtkToolButton *new_gtktoolbutton() 
{
  NspGtkToolButton *loc;
  /* type must exists */
  nsp_type_gtktoolbutton = new_type_gtktoolbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkToolButton)))== NULLGTKTOOLBUTTON) return loc;
  /* initialize object */
  if ( init_gtktoolbutton(loc,nsp_type_gtktoolbutton) == FAIL) return NULLGTKTOOLBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkToolButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktoolbutton_type_name[]="GtkToolButton";
static char gtktoolbutton_short_type_name[]="GtkToolButton";

static char *nsp_gtktoolbutton_type_as_string(void)
{
  return(gtktoolbutton_type_name);
}

static char *nsp_gtktoolbutton_type_short_string(NspObject *v)
{
  return(gtktoolbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkToolButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkToolButton   *nsp_gtktoolbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktoolbutton_id)  == TRUE  ) return ((NspGtkToolButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktoolbutton));
  return NULL;
}

int IsGtkToolButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktoolbutton_id);
}

int IsGtkToolButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktoolbutton_id);
}

NspGtkToolButton  *GetGtkToolButtonCopy(Stack stack, int i)
{
  if (  GetGtkToolButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkToolButton  *GetGtkToolButton(Stack stack, int i)
{
  NspGtkToolButton *M;
  if (( M = nsp_gtktoolbutton_object(NthObj(i))) == NULLGTKTOOLBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkToolButton *gtktoolbutton_copy(NspGtkToolButton *self)
{
  /* return gtktoolitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoolbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkToolButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_tool_button_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"icon_widget",obj,NULLOBJ,-1},
	{"label",string,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkWidget *icon_widget = NULL;
  NspGObject *nsp_icon_widget = NULL;
  char *label = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_icon_widget, &label) == FAIL) return RET_BUG;
  if ( nsp_icon_widget != NULL ) {
    if ( IsGtkWidget((NspObject *)nsp_icon_widget))
      icon_widget = GTK_WIDGET(nsp_icon_widget->obj);
    else if (! IsNone((NspObject *)nsp_icon_widget)) {
         Scierror( "Error: icon_widget should be a GtkWidget or None\n");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_tool_button_new(icon_widget,label))== NULL) return RET_BUG;

  nsp_type_gtktoolbutton = new_type_gtktoolbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktoolbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_button_set_label(NspGtkToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *label;
  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
    gtk_tool_button_set_label(GTK_TOOL_BUTTON(self->obj),label);
  return 0;
}

static int _wrap_gtk_tool_button_get_label(NspGtkToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_tool_button_get_label(GTK_TOOL_BUTTON(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_button_set_use_underline(NspGtkToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_underline;
  if ( GetArgs(stack,rhs,opt,T,&use_underline) == FAIL) return RET_BUG;
    gtk_tool_button_set_use_underline(GTK_TOOL_BUTTON(self->obj),use_underline);
  return 0;
}

static int _wrap_gtk_tool_button_get_use_underline(NspGtkToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_tool_button_get_use_underline(GTK_TOOL_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_button_set_icon_name(NspGtkToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *icon_name;
  if ( GetArgs(stack,rhs,opt,T,&icon_name) == FAIL) return RET_BUG;
    gtk_tool_button_set_icon_name(GTK_TOOL_BUTTON(self->obj),icon_name);
  return 0;
}

static int _wrap_gtk_tool_button_get_icon_name(NspGtkToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_tool_button_get_icon_name(GTK_TOOL_BUTTON(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_tool_button_set_icon_widget(NspGtkToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *icon_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &icon_widget) == FAIL) return RET_BUG;
    gtk_tool_button_set_icon_widget(GTK_TOOL_BUTTON(self->obj),GTK_WIDGET(icon_widget->obj));
  return 0;
}

static int _wrap_gtk_tool_button_get_icon_widget(NspGtkToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tool_button_get_icon_widget(GTK_TOOL_BUTTON(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_tool_button_set_label_widget(NspGtkToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *label_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &label_widget) == FAIL) return RET_BUG;
    gtk_tool_button_set_label_widget(GTK_TOOL_BUTTON(self->obj),GTK_WIDGET(label_widget->obj));
  return 0;
}

static int _wrap_gtk_tool_button_get_label_widget(NspGtkToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_tool_button_get_label_widget(GTK_TOOL_BUTTON(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtktoolbutton_methods[] = {
  {"set_label",(nsp_method *) _wrap_gtk_tool_button_set_label},
  {"get_label",(nsp_method *) _wrap_gtk_tool_button_get_label},
  {"set_use_underline",(nsp_method *) _wrap_gtk_tool_button_set_use_underline},
  {"get_use_underline",(nsp_method *) _wrap_gtk_tool_button_get_use_underline},
  {"set_icon_name",(nsp_method *) _wrap_gtk_tool_button_set_icon_name},
  {"get_icon_name",(nsp_method *) _wrap_gtk_tool_button_get_icon_name},
  {"set_icon_widget",(nsp_method *) _wrap_gtk_tool_button_set_icon_widget},
  {"get_icon_widget",(nsp_method *) _wrap_gtk_tool_button_get_icon_widget},
  {"set_label_widget",(nsp_method *) _wrap_gtk_tool_button_set_label_widget},
  {"get_label_widget",(nsp_method *) _wrap_gtk_tool_button_get_label_widget},
  { NULL, NULL}
};

static NspMethods *gtktoolbutton_get_methods(void) { return gtktoolbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktoolbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkMenuToolButton ----------- */


#define  NspGtkMenuToolButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkmenutoolbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkMenuToolButton inherits from GtkToolButton 
 * and implements GtkBuildable
 */

int nsp_type_gtkmenutoolbutton_id=0;
NspTypeGtkMenuToolButton *nsp_type_gtkmenutoolbutton=NULL;

/*
 * Type object for NspGtkMenuToolButton 
 * all the instance of NspTypeGtkMenuToolButton share the same id. 
 * nsp_type_gtkmenutoolbutton: is an instance of NspTypeGtkMenuToolButton 
 *    used for objects of NspGtkMenuToolButton type (i.e built with new_gtkmenutoolbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkMenuToolButton *new_type_gtkmenutoolbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkMenuToolButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmenutoolbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmenutoolbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkToolButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtktoolbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmenutoolbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkmenutoolbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkmenutoolbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkmenutoolbutton */ 

  top->s_type =  (s_type_func *) nsp_gtkmenutoolbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkmenutoolbutton_type_short_string;
  /* top->create = (create_func*) int_gtkmenutoolbutton_create;*/

  /* specific methods for gtkmenutoolbutton */

  type->init = (init_func *) init_gtkmenutoolbutton;

  /* 
   * NspGtkMenuToolButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkmenutoolbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMenuToolButton called nsp_type_gtkmenutoolbutton
       */
      type->id =  nsp_type_gtkmenutoolbutton_id = nsp_new_type_id();
      nsp_type_gtkmenutoolbutton = type;
      if ( nsp_register_type(nsp_type_gtkmenutoolbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmenutoolbutton, GTK_TYPE_MENU_TOOL_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkmenutoolbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkmenutoolbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkMenuToolButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmenutoolbutton(NspGtkMenuToolButton *Obj,NspTypeGtkMenuToolButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkMenuToolButton 
 */

NspGtkMenuToolButton *new_gtkmenutoolbutton() 
{
  NspGtkMenuToolButton *loc;
  /* type must exists */
  nsp_type_gtkmenutoolbutton = new_type_gtkmenutoolbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMenuToolButton)))== NULLGTKMENUTOOLBUTTON) return loc;
  /* initialize object */
  if ( init_gtkmenutoolbutton(loc,nsp_type_gtkmenutoolbutton) == FAIL) return NULLGTKMENUTOOLBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkMenuToolButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkmenutoolbutton_type_name[]="GtkMenuToolButton";
static char gtkmenutoolbutton_short_type_name[]="GtkMenuToolButton";

static char *nsp_gtkmenutoolbutton_type_as_string(void)
{
  return(gtkmenutoolbutton_type_name);
}

static char *nsp_gtkmenutoolbutton_type_short_string(NspObject *v)
{
  return(gtkmenutoolbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkMenuToolButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkMenuToolButton   *nsp_gtkmenutoolbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkmenutoolbutton_id)  == TRUE  ) return ((NspGtkMenuToolButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmenutoolbutton));
  return NULL;
}

int IsGtkMenuToolButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkmenutoolbutton_id);
}

int IsGtkMenuToolButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmenutoolbutton_id);
}

NspGtkMenuToolButton  *GetGtkMenuToolButtonCopy(Stack stack, int i)
{
  if (  GetGtkMenuToolButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMenuToolButton  *GetGtkMenuToolButton(Stack stack, int i)
{
  NspGtkMenuToolButton *M;
  if (( M = nsp_gtkmenutoolbutton_object(NthObj(i))) == NULLGTKMENUTOOLBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMenuToolButton *gtkmenutoolbutton_copy(NspGtkMenuToolButton *self)
{
  /* return gtktoolbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenutoolbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenutoolbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMenuToolButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_menu_tool_button_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"icon_widget",obj,NULLOBJ,-1},
	{"label",string,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkWidget *icon_widget = NULL;
  NspGObject *nsp_icon_widget = NULL;
  char *label = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_icon_widget, &label) == FAIL) return RET_BUG;
  if ( nsp_icon_widget != NULL ) {
    if ( IsGtkWidget((NspObject *)nsp_icon_widget))
      icon_widget = GTK_WIDGET(nsp_icon_widget->obj);
    else if (! IsNone((NspObject *)nsp_icon_widget)) {
         Scierror( "Error: icon_widget should be a GtkWidget or None\n");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_menu_tool_button_new(icon_widget,label))== NULL) return RET_BUG;

  nsp_type_gtkmenutoolbutton = new_type_gtkmenutoolbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkmenutoolbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_menu_tool_button_set_menu(NspGtkMenuToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *menu;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &menu) == FAIL) return RET_BUG;
    gtk_menu_tool_button_set_menu(GTK_MENU_TOOL_BUTTON(self->obj),GTK_WIDGET(menu->obj));
  return 0;
}

static int _wrap_gtk_menu_tool_button_get_menu(NspGtkMenuToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_menu_tool_button_get_menu(GTK_MENU_TOOL_BUTTON(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_menu_tool_button_set_arrow_tooltip_text(NspGtkMenuToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    gtk_menu_tool_button_set_arrow_tooltip_text(GTK_MENU_TOOL_BUTTON(self->obj),text);
  return 0;
}

static int _wrap_gtk_menu_tool_button_set_arrow_tooltip_markup(NspGtkMenuToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *markup;
  if ( GetArgs(stack,rhs,opt,T,&markup) == FAIL) return RET_BUG;
    gtk_menu_tool_button_set_arrow_tooltip_markup(GTK_MENU_TOOL_BUTTON(self->obj),markup);
  return 0;
}

static NspMethods gtkmenutoolbutton_methods[] = {
  {"set_menu",(nsp_method *) _wrap_gtk_menu_tool_button_set_menu},
  {"get_menu",(nsp_method *) _wrap_gtk_menu_tool_button_get_menu},
  {"set_arrow_tooltip_text",(nsp_method *) _wrap_gtk_menu_tool_button_set_arrow_tooltip_text},
  {"set_arrow_tooltip_markup",(nsp_method *) _wrap_gtk_menu_tool_button_set_arrow_tooltip_markup},
  { NULL, NULL}
};

static NspMethods *gtkmenutoolbutton_get_methods(void) { return gtkmenutoolbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmenutoolbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkToggleToolButton ----------- */


#define  NspGtkToggleToolButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktoggletoolbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkToggleToolButton inherits from GtkToolButton 
 * and implements GtkBuildable
 */

int nsp_type_gtktoggletoolbutton_id=0;
NspTypeGtkToggleToolButton *nsp_type_gtktoggletoolbutton=NULL;

/*
 * Type object for NspGtkToggleToolButton 
 * all the instance of NspTypeGtkToggleToolButton share the same id. 
 * nsp_type_gtktoggletoolbutton: is an instance of NspTypeGtkToggleToolButton 
 *    used for objects of NspGtkToggleToolButton type (i.e built with new_gtktoggletoolbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkToggleToolButton *new_type_gtktoggletoolbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkToggleToolButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktoggletoolbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktoggletoolbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkToolButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtktoolbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktoggletoolbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktoggletoolbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktoggletoolbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktoggletoolbutton */ 

  top->s_type =  (s_type_func *) nsp_gtktoggletoolbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktoggletoolbutton_type_short_string;
  /* top->create = (create_func*) int_gtktoggletoolbutton_create;*/

  /* specific methods for gtktoggletoolbutton */

  type->init = (init_func *) init_gtktoggletoolbutton;

  /* 
   * NspGtkToggleToolButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtktoggletoolbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkToggleToolButton called nsp_type_gtktoggletoolbutton
       */
      type->id =  nsp_type_gtktoggletoolbutton_id = nsp_new_type_id();
      nsp_type_gtktoggletoolbutton = type;
      if ( nsp_register_type(nsp_type_gtktoggletoolbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktoggletoolbutton, GTK_TYPE_TOGGLE_TOOL_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtktoggletoolbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtktoggletoolbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkToggleToolButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktoggletoolbutton(NspGtkToggleToolButton *Obj,NspTypeGtkToggleToolButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkToggleToolButton 
 */

NspGtkToggleToolButton *new_gtktoggletoolbutton() 
{
  NspGtkToggleToolButton *loc;
  /* type must exists */
  nsp_type_gtktoggletoolbutton = new_type_gtktoggletoolbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkToggleToolButton)))== NULLGTKTOGGLETOOLBUTTON) return loc;
  /* initialize object */
  if ( init_gtktoggletoolbutton(loc,nsp_type_gtktoggletoolbutton) == FAIL) return NULLGTKTOGGLETOOLBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkToggleToolButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktoggletoolbutton_type_name[]="GtkToggleToolButton";
static char gtktoggletoolbutton_short_type_name[]="GtkToggleToolButton";

static char *nsp_gtktoggletoolbutton_type_as_string(void)
{
  return(gtktoggletoolbutton_type_name);
}

static char *nsp_gtktoggletoolbutton_type_short_string(NspObject *v)
{
  return(gtktoggletoolbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkToggleToolButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkToggleToolButton   *nsp_gtktoggletoolbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktoggletoolbutton_id)  == TRUE  ) return ((NspGtkToggleToolButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktoggletoolbutton));
  return NULL;
}

int IsGtkToggleToolButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktoggletoolbutton_id);
}

int IsGtkToggleToolButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktoggletoolbutton_id);
}

NspGtkToggleToolButton  *GetGtkToggleToolButtonCopy(Stack stack, int i)
{
  if (  GetGtkToggleToolButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkToggleToolButton  *GetGtkToggleToolButton(Stack stack, int i)
{
  NspGtkToggleToolButton *M;
  if (( M = nsp_gtktoggletoolbutton_object(NthObj(i))) == NULLGTKTOGGLETOOLBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkToggleToolButton *gtktoggletoolbutton_copy(NspGtkToggleToolButton *self)
{
  /* return gtktoolbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoggletoolbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoggletoolbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkToggleToolButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_toggle_tool_button_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_toggle_tool_button_new())== NULL) return RET_BUG;

  nsp_type_gtktoggletoolbutton = new_type_gtktoggletoolbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtktoggletoolbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_toggle_tool_button_set_active(NspGtkToggleToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int is_active;
  if ( GetArgs(stack,rhs,opt,T,&is_active) == FAIL) return RET_BUG;
    gtk_toggle_tool_button_set_active(GTK_TOGGLE_TOOL_BUTTON(self->obj),is_active);
  return 0;
}

static int _wrap_gtk_toggle_tool_button_get_active(NspGtkToggleToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_toggle_tool_button_get_active(GTK_TOGGLE_TOOL_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtktoggletoolbutton_methods[] = {
  {"set_active",(nsp_method *) _wrap_gtk_toggle_tool_button_set_active},
  {"get_active",(nsp_method *) _wrap_gtk_toggle_tool_button_get_active},
  { NULL, NULL}
};

static NspMethods *gtktoggletoolbutton_get_methods(void) { return gtktoggletoolbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktoggletoolbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRadioToolButton ----------- */


#define  NspGtkRadioToolButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkradiotoolbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRadioToolButton inherits from GtkToggleToolButton 
 * and implements GtkBuildable
 */

int nsp_type_gtkradiotoolbutton_id=0;
NspTypeGtkRadioToolButton *nsp_type_gtkradiotoolbutton=NULL;

/*
 * Type object for NspGtkRadioToolButton 
 * all the instance of NspTypeGtkRadioToolButton share the same id. 
 * nsp_type_gtkradiotoolbutton: is an instance of NspTypeGtkRadioToolButton 
 *    used for objects of NspGtkRadioToolButton type (i.e built with new_gtkradiotoolbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkRadioToolButton *new_type_gtkradiotoolbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkRadioToolButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkradiotoolbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkradiotoolbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkToggleToolButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtktoggletoolbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkradiotoolbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkradiotoolbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkradiotoolbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkradiotoolbutton */ 

  top->s_type =  (s_type_func *) nsp_gtkradiotoolbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkradiotoolbutton_type_short_string;
  /* top->create = (create_func*) int_gtkradiotoolbutton_create;*/

  /* specific methods for gtkradiotoolbutton */

  type->init = (init_func *) init_gtkradiotoolbutton;

  /* 
   * NspGtkRadioToolButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkradiotoolbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRadioToolButton called nsp_type_gtkradiotoolbutton
       */
      type->id =  nsp_type_gtkradiotoolbutton_id = nsp_new_type_id();
      nsp_type_gtkradiotoolbutton = type;
      if ( nsp_register_type(nsp_type_gtkradiotoolbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkradiotoolbutton, GTK_TYPE_RADIO_TOOL_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkradiotoolbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkradiotoolbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkRadioToolButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkradiotoolbutton(NspGtkRadioToolButton *Obj,NspTypeGtkRadioToolButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRadioToolButton 
 */

NspGtkRadioToolButton *new_gtkradiotoolbutton() 
{
  NspGtkRadioToolButton *loc;
  /* type must exists */
  nsp_type_gtkradiotoolbutton = new_type_gtkradiotoolbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRadioToolButton)))== NULLGTKRADIOTOOLBUTTON) return loc;
  /* initialize object */
  if ( init_gtkradiotoolbutton(loc,nsp_type_gtkradiotoolbutton) == FAIL) return NULLGTKRADIOTOOLBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRadioToolButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkradiotoolbutton_type_name[]="GtkRadioToolButton";
static char gtkradiotoolbutton_short_type_name[]="GtkRadioToolButton";

static char *nsp_gtkradiotoolbutton_type_as_string(void)
{
  return(gtkradiotoolbutton_type_name);
}

static char *nsp_gtkradiotoolbutton_type_short_string(NspObject *v)
{
  return(gtkradiotoolbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRadioToolButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRadioToolButton   *nsp_gtkradiotoolbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkradiotoolbutton_id)  == TRUE  ) return ((NspGtkRadioToolButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkradiotoolbutton));
  return NULL;
}

int IsGtkRadioToolButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkradiotoolbutton_id);
}

int IsGtkRadioToolButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkradiotoolbutton_id);
}

NspGtkRadioToolButton  *GetGtkRadioToolButtonCopy(Stack stack, int i)
{
  if (  GetGtkRadioToolButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRadioToolButton  *GetGtkRadioToolButton(Stack stack, int i)
{
  NspGtkRadioToolButton *M;
  if (( M = nsp_gtkradiotoolbutton_object(NthObj(i))) == NULLGTKRADIOTOOLBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRadioToolButton *gtkradiotoolbutton_copy(NspGtkRadioToolButton *self)
{
  /* return gtktoggletoolbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradiotoolbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradiotoolbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRadioToolButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_radio_tool_button_new_from_widget (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *group;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkradiotoolbutton, &group) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_radio_tool_button_new_from_widget(GTK_RADIO_TOOL_BUTTON(group->obj)))== NULL) return RET_BUG;

  nsp_type_gtkradiotoolbutton = new_type_gtkradiotoolbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkradiotoolbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 7484 "codegen-3.0/gtk.override"

/* mixes all the constructors */
static int
_wrap_gtk_radio_tool_button_new(Stack stack, int rhs, int opt, int lhs)
{
  NspObject *nsp_group = NULL;
  gchar *stock = NULL;
  GtkRadioToolButton *group= NULL;
  GtkToolItem *ret;
  NspObject *nsp_ret;
  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"group",obj,NULLOBJ,-1},
    {"stock",string,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };
  if (GetArgs(stack,rhs,opt,T, &opts,&nsp_group, &stock) == FAIL)  return RET_BUG;
  if ( nsp_group != NULL )
    {
      if (nspgobject_check(nsp_group,nsp_type_gtkradiotoolbutton))
	group = GTK_RADIO_TOOL_BUTTON(nspgobject_get(nsp_group));
      else {
	Scierror("group argument must be a GtkRadioToolButton");
	return RET_BUG;
      }
    }
  if ( stock != NULL)
    {
      if ( group == NULL)
	{
	  /* if ((ret = gtk_radio_tool_button_new_from_stock(NULL,stock)) == NULL) return RET_BUG; */
	  return RET_BUG;
	}
      else
	{
	  /* if ((ret = gtk_radio_tool_button_new_with_stock_from_widget(group,stock)) == NULL) return RET_BUG;*/
	  return RET_BUG;
	}
    }
  else
    {
      if ( group == NULL)
	{
	  if ((ret = gtk_radio_tool_button_new(NULL)) == NULL) return RET_BUG;
	}
      else
	{
	  if ((ret = gtk_radio_tool_button_new_from_widget(group)) == NULL) return RET_BUG;
	}
    }
  nsp_type_gtkradiotoolbutton = new_type_gtkradiotoolbutton(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *) ret,(NspTypeBase *) nsp_type_gtkradiotoolbutton );
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 54826 "gtk.c"


#line 7542 "codegen-3.0/gtk.override"
static int
_wrap_gtk_radio_tool_button_get_group(NspGObject *self,Stack stack,int rhs,int opt,int lhs) {
  NspList *nsp_list;
  GSList *list, *tmp;
  list = gtk_radio_tool_button_get_group(GTK_RADIO_TOOL_BUTTON(self->obj));
  NSP_LIST_FROM_GLIST(list, nspgobject_new("lel",G_OBJECT(tmp->data)),g_slist_free);
}


#line 54839 "gtk.c"


static int _wrap_gtk_radio_tool_button_set_group(NspGtkRadioToolButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list, t_end};
  NspList *nsp_group;
  GSList *group;
  if ( GetArgs(stack,rhs,opt,T,&nsp_group) == FAIL) return RET_BUG;
  group=nsp_gslist_from_nsplist(stack,nsp_group);
  if (group== NULL) return RET_BUG;
    gtk_radio_tool_button_set_group(GTK_RADIO_TOOL_BUTTON(self->obj),group);
  return 0;
}

static NspMethods gtkradiotoolbutton_methods[] = {
  {"get_group",(nsp_method *) _wrap_gtk_radio_tool_button_get_group},
  {"set_group",(nsp_method *) _wrap_gtk_radio_tool_button_set_group},
  { NULL, NULL}
};

static NspMethods *gtkradiotoolbutton_get_methods(void) { return gtkradiotoolbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkradiotoolbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;

#if GTK_CHECK_VERSION(3,12,0) 

/* -----------NspGtkPopover ----------- */


#define  NspGtkPopover_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkpopover.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkPopover inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkpopover_id=0;
NspTypeGtkPopover *nsp_type_gtkpopover=NULL;

/*
 * Type object for NspGtkPopover 
 * all the instance of NspTypeGtkPopover share the same id. 
 * nsp_type_gtkpopover: is an instance of NspTypeGtkPopover 
 *    used for objects of NspGtkPopover type (i.e built with new_gtkpopover) 
 * other instances are used for derived classes 
 */
NspTypeGtkPopover *new_type_gtkpopover(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkPopover *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkpopover != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkpopover;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkpopover_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkpopover_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkpopover;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkpopover */ 

  top->s_type =  (s_type_func *) nsp_gtkpopover_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkpopover_type_short_string;
  /* top->create = (create_func*) int_gtkpopover_create;*/

  /* specific methods for gtkpopover */

  type->init = (init_func *) init_gtkpopover;

  /* 
   * NspGtkPopover interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkpopover_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkPopover called nsp_type_gtkpopover
       */
      type->id =  nsp_type_gtkpopover_id = nsp_new_type_id();
      nsp_type_gtkpopover = type;
      if ( nsp_register_type(nsp_type_gtkpopover) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkpopover, GTK_TYPE_POPOVER);
      return ( mode == T_BASE ) ? type : new_type_gtkpopover(mode);
    }
  else 
    {
      type->id = nsp_type_gtkpopover_id;
      return type;
    }
}

/*
 * initialize NspGtkPopover instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkpopover(NspGtkPopover *Obj,NspTypeGtkPopover *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkPopover 
 */

NspGtkPopover *new_gtkpopover() 
{
  NspGtkPopover *loc;
  /* type must exists */
  nsp_type_gtkpopover = new_type_gtkpopover(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkPopover)))== NULLGTKPOPOVER) return loc;
  /* initialize object */
  if ( init_gtkpopover(loc,nsp_type_gtkpopover) == FAIL) return NULLGTKPOPOVER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkPopover 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkpopover_type_name[]="GtkPopover";
static char gtkpopover_short_type_name[]="GtkPopover";

static char *nsp_gtkpopover_type_as_string(void)
{
  return(gtkpopover_type_name);
}

static char *nsp_gtkpopover_type_short_string(NspObject *v)
{
  return(gtkpopover_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkPopover objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkPopover   *nsp_gtkpopover_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkpopover_id)  == TRUE  ) return ((NspGtkPopover *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkpopover));
  return NULL;
}

int IsGtkPopoverObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkpopover_id);
}

int IsGtkPopover(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkpopover_id);
}

NspGtkPopover  *GetGtkPopoverCopy(Stack stack, int i)
{
  if (  GetGtkPopover(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkPopover  *GetGtkPopover(Stack stack, int i)
{
  NspGtkPopover *M;
  if (( M = nsp_gtkpopover_object(NthObj(i))) == NULLGTKPOPOVER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkPopover *gtkpopover_copy(NspGtkPopover *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkpopover);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkpopover);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkPopover
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
#endif /* GTK_CHECK_VERSION */
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,12,0)
static int
_wrap_gtk_popover_new_from_model (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *relative_to, *model;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &relative_to, &nsp_type_gmenumodel, &model) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_popover_new_from_model(GTK_WIDGET(relative_to->obj),G_MENU_MODEL(model->obj)))== NULL) return RET_BUG;

  nsp_type_gtkpopover = new_type_gtkpopover(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkpopover);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_popover_new_from_model(Stack stack, int rhs, int opt, int lhs) /* gtk_popover_new_from_model */
{
  Scierror("Error: function gtk_popover_new_from_model not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int
_wrap_gtk_popover_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *relative_to;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &relative_to) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_popover_new(GTK_WIDGET(relative_to->obj)))== NULL) return RET_BUG;

  nsp_type_gtkpopover = new_type_gtkpopover(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkpopover);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_popover_new(Stack stack, int rhs, int opt, int lhs) /* gtk_popover_new */
{
  Scierror("Error: function gtk_popover_new not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0) 
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_popover_set_relative_to(NspGtkPopover *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *relative_to;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &relative_to) == FAIL) return RET_BUG;
    gtk_popover_set_relative_to(GTK_POPOVER(self->obj),GTK_WIDGET(relative_to->obj));
  return 0;
}

#else
int _wrap_gtk_popover_set_relative_to(Stack stack, int rhs, int opt, int lhs) /* set_relative_to */
{
  Scierror("Error: function gtk_popover_set_relative_to not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_popover_get_relative_to(NspGtkPopover *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_popover_get_relative_to(GTK_POPOVER(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_popover_get_relative_to(Stack stack, int rhs, int opt, int lhs) /* get_relative_to */
{
  Scierror("Error: function gtk_popover_get_relative_to not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_popover_set_pointing_to(NspGtkPopover *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkRectangle rect = { 0, 0, 0, 0 };
  NspObject *nsp_rect;
  if ( GetArgs(stack,rhs,opt,T,&nsp_rect) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_rect, &rect))
      return RET_BUG;
    gtk_popover_set_pointing_to(GTK_POPOVER(self->obj),&rect);
  return 0;
}

#else
int _wrap_gtk_popover_set_pointing_to(Stack stack, int rhs, int opt, int lhs) /* set_pointing_to */
{
  Scierror("Error: function gtk_popover_set_pointing_to not available\n");
  return RET_BUG;
}
#endif
#line 8111 "codegen-3.0/gtk.override"

#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_popover_get_pointing_to(NspGtkPopover *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkRectangle rect = { 0, 0, 0, 0 };
  NspObject *nsp_rect;
  int ret;
  CheckRhs(0,0);
  ret =gtk_popover_get_pointing_to(GTK_POPOVER(self->obj),&rect);
  if ( ret )
    {
      if ((nsp_rect = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE,
						  (NspTypeBase *) nsp_type_gdkrectangle)) == NULL) return RET_BUG;
      MoveObj(stack,1,nsp_rect);
      return 1;
    }
  Scierror("Error: failed to get pointing_to rectangle\n");
  return RET_BUG;
}
#else
int _wrap_gtk_popover_get_pointing_to(Stack stack, int rhs, int opt, int lhs) /* get_pointing_to */
{
  Scierror("Error: function gtk_popover_get_pointing_to not available\n");
  return RET_BUG;
}
#endif



#line 55201 "gtk.c"


#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_popover_set_position(NspGtkPopover *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkPositionType position;
  NspObject *nsp_position = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_position) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_position, &position)== FAIL)
      return RET_BUG;
    gtk_popover_set_position(GTK_POPOVER(self->obj),position);
  return 0;
}

#else
int _wrap_gtk_popover_set_position(Stack stack, int rhs, int opt, int lhs) /* set_position */
{
  Scierror("Error: function gtk_popover_set_position not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_popover_get_position(NspGtkPopover *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_popover_get_position(GTK_POPOVER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_popover_get_position(Stack stack, int rhs, int opt, int lhs) /* get_position */
{
  Scierror("Error: function gtk_popover_get_position not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_popover_set_modal(NspGtkPopover *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int modal;
  if ( GetArgs(stack,rhs,opt,T,&modal) == FAIL) return RET_BUG;
    gtk_popover_set_modal(GTK_POPOVER(self->obj),modal);
  return 0;
}

#else
int _wrap_gtk_popover_set_modal(Stack stack, int rhs, int opt, int lhs) /* set_modal */
{
  Scierror("Error: function gtk_popover_set_modal not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_popover_get_modal(NspGtkPopover *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_popover_get_modal(GTK_POPOVER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_popover_get_modal(Stack stack, int rhs, int opt, int lhs) /* get_modal */
{
  Scierror("Error: function gtk_popover_get_modal not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_popover_bind_model(NspGtkPopover *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *model;
  char *action_namespace;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gmenumodel, &model, &action_namespace) == FAIL) return RET_BUG;
    gtk_popover_bind_model(GTK_POPOVER(self->obj),G_MENU_MODEL(model->obj),action_namespace);
  return 0;
}

#else
int _wrap_gtk_popover_bind_model(Stack stack, int rhs, int opt, int lhs) /* bind_model */
{
  Scierror("Error: function gtk_popover_bind_model not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_popover_set_transitions_enabled(NspGtkPopover *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int transitions_enabled;
  if ( GetArgs(stack,rhs,opt,T,&transitions_enabled) == FAIL) return RET_BUG;
    gtk_popover_set_transitions_enabled(GTK_POPOVER(self->obj),transitions_enabled);
  return 0;
}

#else
int _wrap_gtk_popover_set_transitions_enabled(Stack stack, int rhs, int opt, int lhs) /* set_transitions_enabled */
{
  Scierror("Error: function gtk_popover_set_transitions_enabled not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_popover_get_transitions_enabled(NspGtkPopover *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_popover_get_transitions_enabled(GTK_POPOVER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_popover_get_transitions_enabled(Stack stack, int rhs, int opt, int lhs) /* get_transitions_enabled */
{
  Scierror("Error: function gtk_popover_get_transitions_enabled not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkpopover_methods[] = {
  {"set_relative_to",(nsp_method *) _wrap_gtk_popover_set_relative_to},
  {"get_relative_to",(nsp_method *) _wrap_gtk_popover_get_relative_to},
  {"set_pointing_to",(nsp_method *) _wrap_gtk_popover_set_pointing_to},
  {"get_pointing_to",(nsp_method *) _wrap_gtk_popover_get_pointing_to},
  {"set_position",(nsp_method *) _wrap_gtk_popover_set_position},
  {"get_position",(nsp_method *) _wrap_gtk_popover_get_position},
  {"set_modal",(nsp_method *) _wrap_gtk_popover_set_modal},
  {"get_modal",(nsp_method *) _wrap_gtk_popover_get_modal},
  {"bind_model",(nsp_method *) _wrap_gtk_popover_bind_model},
  {"set_transitions_enabled",(nsp_method *) _wrap_gtk_popover_set_transitions_enabled},
  {"get_transitions_enabled",(nsp_method *) _wrap_gtk_popover_get_transitions_enabled},
  { NULL, NULL}
};

static NspMethods *gtkpopover_get_methods(void) { return gtkpopover_methods;};
#endif /* GTK_CHECK_VERSION */
#if GTK_CHECK_VERSION(3,12,0) 
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkpopover_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;
#endif /* GTK_CHECK_VERSION */

#if GTK_CHECK_VERSION(3,16,0) 

/* -----------NspGtkPopoverMenu ----------- */


#define  NspGtkPopoverMenu_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkpopovermenu.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkPopoverMenu inherits from GtkPopover 
 * and implements GtkBuildable
 */

int nsp_type_gtkpopovermenu_id=0;
NspTypeGtkPopoverMenu *nsp_type_gtkpopovermenu=NULL;

/*
 * Type object for NspGtkPopoverMenu 
 * all the instance of NspTypeGtkPopoverMenu share the same id. 
 * nsp_type_gtkpopovermenu: is an instance of NspTypeGtkPopoverMenu 
 *    used for objects of NspGtkPopoverMenu type (i.e built with new_gtkpopovermenu) 
 * other instances are used for derived classes 
 */
NspTypeGtkPopoverMenu *new_type_gtkpopovermenu(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkPopoverMenu *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkpopovermenu != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkpopovermenu;
    }
  if (( type =  malloc(sizeof(NspTypeGtkPopover))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkpopover(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkpopovermenu_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkpopovermenu_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkpopovermenu;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkpopovermenu */ 

  top->s_type =  (s_type_func *) nsp_gtkpopovermenu_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkpopovermenu_type_short_string;
  /* top->create = (create_func*) int_gtkpopovermenu_create;*/

  /* specific methods for gtkpopovermenu */

  type->init = (init_func *) init_gtkpopovermenu;

  /* 
   * NspGtkPopoverMenu interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkpopovermenu_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkPopoverMenu called nsp_type_gtkpopovermenu
       */
      type->id =  nsp_type_gtkpopovermenu_id = nsp_new_type_id();
      nsp_type_gtkpopovermenu = type;
      if ( nsp_register_type(nsp_type_gtkpopovermenu) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkpopovermenu, GTK_TYPE_POPOVER_MENU);
      return ( mode == T_BASE ) ? type : new_type_gtkpopovermenu(mode);
    }
  else 
    {
      type->id = nsp_type_gtkpopovermenu_id;
      return type;
    }
}

/*
 * initialize NspGtkPopoverMenu instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkpopovermenu(NspGtkPopoverMenu *Obj,NspTypeGtkPopoverMenu *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkPopoverMenu 
 */

NspGtkPopoverMenu *new_gtkpopovermenu() 
{
  NspGtkPopoverMenu *loc;
  /* type must exists */
  nsp_type_gtkpopovermenu = new_type_gtkpopovermenu(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkPopoverMenu)))== NULLGTKPOPOVERMENU) return loc;
  /* initialize object */
  if ( init_gtkpopovermenu(loc,nsp_type_gtkpopovermenu) == FAIL) return NULLGTKPOPOVERMENU;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkPopoverMenu 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkpopovermenu_type_name[]="GtkPopoverMenu";
static char gtkpopovermenu_short_type_name[]="GtkPopoverMenu";

static char *nsp_gtkpopovermenu_type_as_string(void)
{
  return(gtkpopovermenu_type_name);
}

static char *nsp_gtkpopovermenu_type_short_string(NspObject *v)
{
  return(gtkpopovermenu_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkPopoverMenu objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkPopoverMenu   *nsp_gtkpopovermenu_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkpopovermenu_id)  == TRUE  ) return ((NspGtkPopoverMenu *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkpopovermenu));
  return NULL;
}

int IsGtkPopoverMenuObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkpopovermenu_id);
}

int IsGtkPopoverMenu(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkpopovermenu_id);
}

NspGtkPopoverMenu  *GetGtkPopoverMenuCopy(Stack stack, int i)
{
  if (  GetGtkPopoverMenu(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkPopoverMenu  *GetGtkPopoverMenu(Stack stack, int i)
{
  NspGtkPopoverMenu *M;
  if (( M = nsp_gtkpopovermenu_object(NthObj(i))) == NULLGTKPOPOVERMENU)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkPopoverMenu *gtkpopovermenu_copy(NspGtkPopoverMenu *self)
{
  /* return gtkpopover_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkpopovermenu);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkpopovermenu);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkPopoverMenu
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
#endif /* GTK_CHECK_VERSION */
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,16,0)
static int
_wrap_gtk_popover_menu_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_popover_menu_new())== NULL) return RET_BUG;

  nsp_type_gtkpopovermenu = new_type_gtkpopovermenu(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkpopovermenu);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_popover_menu_new(Stack stack, int rhs, int opt, int lhs) /* gtk_popover_menu_new */
{
  Scierror("Error: function gtk_popover_menu_new not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0) 
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_popover_menu_open_submenu(NspGtkPopoverMenu *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_popover_menu_open_submenu(GTK_POPOVER_MENU(self->obj),name);
  return 0;
}

#else
int _wrap_gtk_popover_menu_open_submenu(Stack stack, int rhs, int opt, int lhs) /* open_submenu */
{
  Scierror("Error: function gtk_popover_menu_open_submenu not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkpopovermenu_methods[] = {
  {"open_submenu",(nsp_method *) _wrap_gtk_popover_menu_open_submenu},
  { NULL, NULL}
};

static NspMethods *gtkpopovermenu_get_methods(void) { return gtkpopovermenu_methods;};
#endif /* GTK_CHECK_VERSION */
#if GTK_CHECK_VERSION(3,16,0) 
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkpopovermenu_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;
#endif /* GTK_CHECK_VERSION */


/* -----------NspGtkColorButton ----------- */


#define  NspGtkColorButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcolorbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkColorButton inherits from GtkButton 
 * and implements GtkBuildable GtkActionable GtkColorChooser
 */

int nsp_type_gtkcolorbutton_id=0;
NspTypeGtkColorButton *nsp_type_gtkcolorbutton=NULL;

/*
 * Type object for NspGtkColorButton 
 * all the instance of NspTypeGtkColorButton share the same id. 
 * nsp_type_gtkcolorbutton: is an instance of NspTypeGtkColorButton 
 *    used for objects of NspGtkColorButton type (i.e built with new_gtkcolorbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkColorButton *new_type_gtkcolorbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkActionable *t_gtkactionable;
  NspTypeGtkColorChooser *t_gtkcolorchooser;
  NspTypeGtkColorButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcolorbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcolorbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcolorbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcolorbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcolorbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcolorbutton */ 

  top->s_type =  (s_type_func *) nsp_gtkcolorbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcolorbutton_type_short_string;
  /* top->create = (create_func*) int_gtkcolorbutton_create;*/

  /* specific methods for gtkcolorbutton */

  type->init = (init_func *) init_gtkcolorbutton;

  /* 
   * NspGtkColorButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  t_gtkactionable = new_type_gtkactionable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkactionable;
  t_gtkcolorchooser = new_type_gtkcolorchooser(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gtkcolorchooser;
  if ( nsp_type_gtkcolorbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkColorButton called nsp_type_gtkcolorbutton
       */
      type->id =  nsp_type_gtkcolorbutton_id = nsp_new_type_id();
      nsp_type_gtkcolorbutton = type;
      if ( nsp_register_type(nsp_type_gtkcolorbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcolorbutton, GTK_TYPE_COLOR_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkcolorbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcolorbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkColorButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcolorbutton(NspGtkColorButton *Obj,NspTypeGtkColorButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkColorButton 
 */

NspGtkColorButton *new_gtkcolorbutton() 
{
  NspGtkColorButton *loc;
  /* type must exists */
  nsp_type_gtkcolorbutton = new_type_gtkcolorbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkColorButton)))== NULLGTKCOLORBUTTON) return loc;
  /* initialize object */
  if ( init_gtkcolorbutton(loc,nsp_type_gtkcolorbutton) == FAIL) return NULLGTKCOLORBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkColorButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcolorbutton_type_name[]="GtkColorButton";
static char gtkcolorbutton_short_type_name[]="GtkColorButton";

static char *nsp_gtkcolorbutton_type_as_string(void)
{
  return(gtkcolorbutton_type_name);
}

static char *nsp_gtkcolorbutton_type_short_string(NspObject *v)
{
  return(gtkcolorbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkColorButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkColorButton   *nsp_gtkcolorbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcolorbutton_id)  == TRUE  ) return ((NspGtkColorButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcolorbutton));
  return NULL;
}

int IsGtkColorButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcolorbutton_id);
}

int IsGtkColorButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcolorbutton_id);
}

NspGtkColorButton  *GetGtkColorButtonCopy(Stack stack, int i)
{
  if (  GetGtkColorButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkColorButton  *GetGtkColorButton(Stack stack, int i)
{
  NspGtkColorButton *M;
  if (( M = nsp_gtkcolorbutton_object(NthObj(i))) == NULLGTKCOLORBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkColorButton *gtkcolorbutton_copy(NspGtkColorButton *self)
{
  /* return gtkbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkColorButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_color_button_new_with_rgba (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj, t_end};
  GdkRGBA *rgba = NULL;
  NspObject *nsp_rgba = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_rgba) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_rgba, GDK_TYPE_RGBA))
      rgba = nspg_boxed_get(nsp_rgba, GdkRGBA);
  else {
      Scierror( "Error: rgba should be a GdkRGBA\n");
      return RET_BUG;
  }
  if ((ret = (GObject *)gtk_color_button_new_with_rgba(rgba))== NULL) return RET_BUG;

  nsp_type_gtkcolorbutton = new_type_gtkcolorbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcolorbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_color_button_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_color_button_new())== NULL) return RET_BUG;

  nsp_type_gtkcolorbutton = new_type_gtkcolorbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcolorbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_color_button_set_title(NspGtkColorButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *title;
  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
    gtk_color_button_set_title(GTK_COLOR_BUTTON(self->obj),title);
  return 0;
}

static int _wrap_gtk_color_button_get_title(NspGtkColorButton *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_color_button_get_title(GTK_COLOR_BUTTON(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkcolorbutton_methods[] = {
  {"set_title",(nsp_method *) _wrap_gtk_color_button_set_title},
  {"get_title",(nsp_method *) _wrap_gtk_color_button_get_title},
  { NULL, NULL}
};

static NspMethods *gtkcolorbutton_get_methods(void) { return gtkcolorbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcolorbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkColorChooserWidget ----------- */


#define  NspGtkColorChooserWidget_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcolorchooserwidget.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkColorChooserWidget inherits from GtkBox 
 * and implements GtkColorChooser GtkBuildable GtkOrientable
 */

int nsp_type_gtkcolorchooserwidget_id=0;
NspTypeGtkColorChooserWidget *nsp_type_gtkcolorchooserwidget=NULL;

/*
 * Type object for NspGtkColorChooserWidget 
 * all the instance of NspTypeGtkColorChooserWidget share the same id. 
 * nsp_type_gtkcolorchooserwidget: is an instance of NspTypeGtkColorChooserWidget 
 *    used for objects of NspGtkColorChooserWidget type (i.e built with new_gtkcolorchooserwidget) 
 * other instances are used for derived classes 
 */
NspTypeGtkColorChooserWidget *new_type_gtkcolorchooserwidget(type_mode mode)
{
  NspTypeGtkColorChooser *t_gtkcolorchooser;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkOrientable *t_gtkorientable;
  NspTypeGtkColorChooserWidget *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcolorchooserwidget != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcolorchooserwidget;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcolorchooserwidget_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcolorchooserwidget_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcolorchooserwidget;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcolorchooserwidget */ 

  top->s_type =  (s_type_func *) nsp_gtkcolorchooserwidget_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcolorchooserwidget_type_short_string;
  /* top->create = (create_func*) int_gtkcolorchooserwidget_create;*/

  /* specific methods for gtkcolorchooserwidget */

  type->init = (init_func *) init_gtkcolorchooserwidget;

  /* 
   * NspGtkColorChooserWidget interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkcolorchooser = new_type_gtkcolorchooser(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkcolorchooser;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  t_gtkorientable = new_type_gtkorientable(T_DERIVED);
  type->interface->interface->interface = (NspTypeBase * ) t_gtkorientable;
  if ( nsp_type_gtkcolorchooserwidget_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkColorChooserWidget called nsp_type_gtkcolorchooserwidget
       */
      type->id =  nsp_type_gtkcolorchooserwidget_id = nsp_new_type_id();
      nsp_type_gtkcolorchooserwidget = type;
      if ( nsp_register_type(nsp_type_gtkcolorchooserwidget) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcolorchooserwidget, GTK_TYPE_COLOR_CHOOSER_WIDGET);
      return ( mode == T_BASE ) ? type : new_type_gtkcolorchooserwidget(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcolorchooserwidget_id;
      return type;
    }
}

/*
 * initialize NspGtkColorChooserWidget instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcolorchooserwidget(NspGtkColorChooserWidget *Obj,NspTypeGtkColorChooserWidget *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkColorChooserWidget 
 */

NspGtkColorChooserWidget *new_gtkcolorchooserwidget() 
{
  NspGtkColorChooserWidget *loc;
  /* type must exists */
  nsp_type_gtkcolorchooserwidget = new_type_gtkcolorchooserwidget(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkColorChooserWidget)))== NULLGTKCOLORCHOOSERWIDGET) return loc;
  /* initialize object */
  if ( init_gtkcolorchooserwidget(loc,nsp_type_gtkcolorchooserwidget) == FAIL) return NULLGTKCOLORCHOOSERWIDGET;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkColorChooserWidget 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcolorchooserwidget_type_name[]="GtkColorChooserWidget";
static char gtkcolorchooserwidget_short_type_name[]="GtkColorChooserWidget";

static char *nsp_gtkcolorchooserwidget_type_as_string(void)
{
  return(gtkcolorchooserwidget_type_name);
}

static char *nsp_gtkcolorchooserwidget_type_short_string(NspObject *v)
{
  return(gtkcolorchooserwidget_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkColorChooserWidget objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkColorChooserWidget   *nsp_gtkcolorchooserwidget_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcolorchooserwidget_id)  == TRUE  ) return ((NspGtkColorChooserWidget *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcolorchooserwidget));
  return NULL;
}

int IsGtkColorChooserWidgetObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcolorchooserwidget_id);
}

int IsGtkColorChooserWidget(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcolorchooserwidget_id);
}

NspGtkColorChooserWidget  *GetGtkColorChooserWidgetCopy(Stack stack, int i)
{
  if (  GetGtkColorChooserWidget(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkColorChooserWidget  *GetGtkColorChooserWidget(Stack stack, int i)
{
  NspGtkColorChooserWidget *M;
  if (( M = nsp_gtkcolorchooserwidget_object(NthObj(i))) == NULLGTKCOLORCHOOSERWIDGET)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkColorChooserWidget *gtkcolorchooserwidget_copy(NspGtkColorChooserWidget *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorchooserwidget);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorchooserwidget);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkColorChooserWidget
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_color_chooser_widget_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_color_chooser_widget_new())== NULL) return RET_BUG;

  nsp_type_gtkcolorchooserwidget = new_type_gtkcolorchooserwidget(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcolorchooserwidget);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkcolorchooserwidget_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcolorchooserwidget_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkColorChooserDialog ----------- */


#define  NspGtkColorChooserDialog_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcolorchooserdialog.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkColorChooserDialog inherits from GtkDialog 
 * and implements GtkBuildable GtkColorChooser
 */

int nsp_type_gtkcolorchooserdialog_id=0;
NspTypeGtkColorChooserDialog *nsp_type_gtkcolorchooserdialog=NULL;

/*
 * Type object for NspGtkColorChooserDialog 
 * all the instance of NspTypeGtkColorChooserDialog share the same id. 
 * nsp_type_gtkcolorchooserdialog: is an instance of NspTypeGtkColorChooserDialog 
 *    used for objects of NspGtkColorChooserDialog type (i.e built with new_gtkcolorchooserdialog) 
 * other instances are used for derived classes 
 */
NspTypeGtkColorChooserDialog *new_type_gtkcolorchooserdialog(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkColorChooser *t_gtkcolorchooser;
  NspTypeGtkColorChooserDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcolorchooserdialog != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcolorchooserdialog;
    }
  if (( type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcolorchooserdialog_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcolorchooserdialog_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcolorchooserdialog;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcolorchooserdialog */ 

  top->s_type =  (s_type_func *) nsp_gtkcolorchooserdialog_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcolorchooserdialog_type_short_string;
  /* top->create = (create_func*) int_gtkcolorchooserdialog_create;*/

  /* specific methods for gtkcolorchooserdialog */

  type->init = (init_func *) init_gtkcolorchooserdialog;

  /* 
   * NspGtkColorChooserDialog interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  t_gtkcolorchooser = new_type_gtkcolorchooser(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkcolorchooser;
  if ( nsp_type_gtkcolorchooserdialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkColorChooserDialog called nsp_type_gtkcolorchooserdialog
       */
      type->id =  nsp_type_gtkcolorchooserdialog_id = nsp_new_type_id();
      nsp_type_gtkcolorchooserdialog = type;
      if ( nsp_register_type(nsp_type_gtkcolorchooserdialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcolorchooserdialog, GTK_TYPE_COLOR_CHOOSER_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkcolorchooserdialog(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcolorchooserdialog_id;
      return type;
    }
}

/*
 * initialize NspGtkColorChooserDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcolorchooserdialog(NspGtkColorChooserDialog *Obj,NspTypeGtkColorChooserDialog *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkColorChooserDialog 
 */

NspGtkColorChooserDialog *new_gtkcolorchooserdialog() 
{
  NspGtkColorChooserDialog *loc;
  /* type must exists */
  nsp_type_gtkcolorchooserdialog = new_type_gtkcolorchooserdialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkColorChooserDialog)))== NULLGTKCOLORCHOOSERDIALOG) return loc;
  /* initialize object */
  if ( init_gtkcolorchooserdialog(loc,nsp_type_gtkcolorchooserdialog) == FAIL) return NULLGTKCOLORCHOOSERDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkColorChooserDialog 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcolorchooserdialog_type_name[]="GtkColorChooserDialog";
static char gtkcolorchooserdialog_short_type_name[]="GtkColorChooserDialog";

static char *nsp_gtkcolorchooserdialog_type_as_string(void)
{
  return(gtkcolorchooserdialog_type_name);
}

static char *nsp_gtkcolorchooserdialog_type_short_string(NspObject *v)
{
  return(gtkcolorchooserdialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkColorChooserDialog objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkColorChooserDialog   *nsp_gtkcolorchooserdialog_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcolorchooserdialog_id)  == TRUE  ) return ((NspGtkColorChooserDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcolorchooserdialog));
  return NULL;
}

int IsGtkColorChooserDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcolorchooserdialog_id);
}

int IsGtkColorChooserDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcolorchooserdialog_id);
}

NspGtkColorChooserDialog  *GetGtkColorChooserDialogCopy(Stack stack, int i)
{
  if (  GetGtkColorChooserDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkColorChooserDialog  *GetGtkColorChooserDialog(Stack stack, int i)
{
  NspGtkColorChooserDialog *M;
  if (( M = nsp_gtkcolorchooserdialog_object(NthObj(i))) == NULLGTKCOLORCHOOSERDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkColorChooserDialog *gtkcolorchooserdialog_copy(NspGtkColorChooserDialog *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorchooserdialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcolorchooserdialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkColorChooserDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_color_chooser_dialog_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,obj_check, t_end};
  char *title;
  NspGObject *parent;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&title, &nsp_type_gtkwindow, &parent) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_color_chooser_dialog_new(title,GTK_WINDOW(parent->obj)))== NULL) return RET_BUG;

  nsp_type_gtkcolorchooserdialog = new_type_gtkcolorchooserdialog(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcolorchooserdialog);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkcolorchooserdialog_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcolorchooserdialog_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkFileChooserButton ----------- */


#define  NspGtkFileChooserButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkfilechooserbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFileChooserButton inherits from GtkBox 
 * and implements GtkFileChooser GtkBuildable
 */

int nsp_type_gtkfilechooserbutton_id=0;
NspTypeGtkFileChooserButton *nsp_type_gtkfilechooserbutton=NULL;

/*
 * Type object for NspGtkFileChooserButton 
 * all the instance of NspTypeGtkFileChooserButton share the same id. 
 * nsp_type_gtkfilechooserbutton: is an instance of NspTypeGtkFileChooserButton 
 *    used for objects of NspGtkFileChooserButton type (i.e built with new_gtkfilechooserbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkFileChooserButton *new_type_gtkfilechooserbutton(type_mode mode)
{
  NspTypeGtkFileChooser *t_gtkfilechooser;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkFileChooserButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfilechooserbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfilechooserbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfilechooserbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkfilechooserbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkfilechooserbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkfilechooserbutton */ 

  top->s_type =  (s_type_func *) nsp_gtkfilechooserbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkfilechooserbutton_type_short_string;
  /* top->create = (create_func*) int_gtkfilechooserbutton_create;*/

  /* specific methods for gtkfilechooserbutton */

  type->init = (init_func *) init_gtkfilechooserbutton;

  /* 
   * NspGtkFileChooserButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkfilechooser = new_type_gtkfilechooser(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkfilechooser;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkfilechooserbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFileChooserButton called nsp_type_gtkfilechooserbutton
       */
      type->id =  nsp_type_gtkfilechooserbutton_id = nsp_new_type_id();
      nsp_type_gtkfilechooserbutton = type;
      if ( nsp_register_type(nsp_type_gtkfilechooserbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfilechooserbutton, GTK_TYPE_FILE_CHOOSER_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkfilechooserbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkfilechooserbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkFileChooserButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfilechooserbutton(NspGtkFileChooserButton *Obj,NspTypeGtkFileChooserButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFileChooserButton 
 */

NspGtkFileChooserButton *new_gtkfilechooserbutton() 
{
  NspGtkFileChooserButton *loc;
  /* type must exists */
  nsp_type_gtkfilechooserbutton = new_type_gtkfilechooserbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFileChooserButton)))== NULLGTKFILECHOOSERBUTTON) return loc;
  /* initialize object */
  if ( init_gtkfilechooserbutton(loc,nsp_type_gtkfilechooserbutton) == FAIL) return NULLGTKFILECHOOSERBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFileChooserButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkfilechooserbutton_type_name[]="GtkFileChooserButton";
static char gtkfilechooserbutton_short_type_name[]="GtkFileChooserButton";

static char *nsp_gtkfilechooserbutton_type_as_string(void)
{
  return(gtkfilechooserbutton_type_name);
}

static char *nsp_gtkfilechooserbutton_type_short_string(NspObject *v)
{
  return(gtkfilechooserbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFileChooserButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFileChooserButton   *nsp_gtkfilechooserbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkfilechooserbutton_id)  == TRUE  ) return ((NspGtkFileChooserButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfilechooserbutton));
  return NULL;
}

int IsGtkFileChooserButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkfilechooserbutton_id);
}

int IsGtkFileChooserButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfilechooserbutton_id);
}

NspGtkFileChooserButton  *GetGtkFileChooserButtonCopy(Stack stack, int i)
{
  if (  GetGtkFileChooserButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFileChooserButton  *GetGtkFileChooserButton(Stack stack, int i)
{
  NspGtkFileChooserButton *M;
  if (( M = nsp_gtkfilechooserbutton_object(NthObj(i))) == NULLGTKFILECHOOSERBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFileChooserButton *gtkfilechooserbutton_copy(NspGtkFileChooserButton *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfilechooserbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfilechooserbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFileChooserButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_file_chooser_button_new_with_dialog (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *dialog;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &dialog) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_file_chooser_button_new_with_dialog(GTK_WIDGET(dialog->obj)))== NULL) return RET_BUG;

  nsp_type_gtkfilechooserbutton = new_type_gtkfilechooserbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkfilechooserbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_file_chooser_button_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *title;
  GtkFileChooserAction action;
  NspObject *nsp_action = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&title, &nsp_action) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_FILE_CHOOSER_ACTION, nsp_action, &action)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_file_chooser_button_new(title,action))== NULL) return RET_BUG;

  nsp_type_gtkfilechooserbutton = new_type_gtkfilechooserbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkfilechooserbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_file_chooser_button_get_title(NspGtkFileChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_button_get_title(GTK_FILE_CHOOSER_BUTTON(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_button_set_title(NspGtkFileChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *title;
  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
    gtk_file_chooser_button_set_title(GTK_FILE_CHOOSER_BUTTON(self->obj),title);
  return 0;
}

static int _wrap_gtk_file_chooser_button_get_width_chars(NspGtkFileChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_button_get_width_chars(GTK_FILE_CHOOSER_BUTTON(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_button_set_width_chars(NspGtkFileChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int n_chars;
  if ( GetArgs(stack,rhs,opt,T,&n_chars) == FAIL) return RET_BUG;
    gtk_file_chooser_button_set_width_chars(GTK_FILE_CHOOSER_BUTTON(self->obj),n_chars);
  return 0;
}

static int _wrap_gtk_file_chooser_button_get_focus_on_click(NspGtkFileChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_file_chooser_button_get_focus_on_click(GTK_FILE_CHOOSER_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_chooser_button_set_focus_on_click(NspGtkFileChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int focus_on_click;
  if ( GetArgs(stack,rhs,opt,T,&focus_on_click) == FAIL) return RET_BUG;
    gtk_file_chooser_button_set_focus_on_click(GTK_FILE_CHOOSER_BUTTON(self->obj),focus_on_click);
  return 0;
}

static NspMethods gtkfilechooserbutton_methods[] = {
  {"get_title",(nsp_method *) _wrap_gtk_file_chooser_button_get_title},
  {"set_title",(nsp_method *) _wrap_gtk_file_chooser_button_set_title},
  {"get_width_chars",(nsp_method *) _wrap_gtk_file_chooser_button_get_width_chars},
  {"set_width_chars",(nsp_method *) _wrap_gtk_file_chooser_button_set_width_chars},
  {"get_focus_on_click",(nsp_method *) _wrap_gtk_file_chooser_button_get_focus_on_click},
  {"set_focus_on_click",(nsp_method *) _wrap_gtk_file_chooser_button_set_focus_on_click},
  { NULL, NULL}
};

static NspMethods *gtkfilechooserbutton_get_methods(void) { return gtkfilechooserbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfilechooserbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkFileChooserDialog ----------- */


#define  NspGtkFileChooserDialog_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkfilechooserdialog.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFileChooserDialog inherits from GtkDialog 
 * and implements GtkFileChooser GtkBuildable
 */

int nsp_type_gtkfilechooserdialog_id=0;
NspTypeGtkFileChooserDialog *nsp_type_gtkfilechooserdialog=NULL;

/*
 * Type object for NspGtkFileChooserDialog 
 * all the instance of NspTypeGtkFileChooserDialog share the same id. 
 * nsp_type_gtkfilechooserdialog: is an instance of NspTypeGtkFileChooserDialog 
 *    used for objects of NspGtkFileChooserDialog type (i.e built with new_gtkfilechooserdialog) 
 * other instances are used for derived classes 
 */
NspTypeGtkFileChooserDialog *new_type_gtkfilechooserdialog(type_mode mode)
{
  NspTypeGtkFileChooser *t_gtkfilechooser;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkFileChooserDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfilechooserdialog != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfilechooserdialog;
    }
  if (( type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfilechooserdialog_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkfilechooserdialog_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkfilechooserdialog;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkfilechooserdialog */ 

  top->s_type =  (s_type_func *) nsp_gtkfilechooserdialog_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkfilechooserdialog_type_short_string;
  /* top->create = (create_func*) int_gtkfilechooserdialog_create;*/

  /* specific methods for gtkfilechooserdialog */

  type->init = (init_func *) init_gtkfilechooserdialog;

  /* 
   * NspGtkFileChooserDialog interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkfilechooser = new_type_gtkfilechooser(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkfilechooser;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkfilechooserdialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFileChooserDialog called nsp_type_gtkfilechooserdialog
       */
      type->id =  nsp_type_gtkfilechooserdialog_id = nsp_new_type_id();
      nsp_type_gtkfilechooserdialog = type;
      if ( nsp_register_type(nsp_type_gtkfilechooserdialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfilechooserdialog, GTK_TYPE_FILE_CHOOSER_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkfilechooserdialog(mode);
    }
  else 
    {
      type->id = nsp_type_gtkfilechooserdialog_id;
      return type;
    }
}

/*
 * initialize NspGtkFileChooserDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfilechooserdialog(NspGtkFileChooserDialog *Obj,NspTypeGtkFileChooserDialog *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFileChooserDialog 
 */

NspGtkFileChooserDialog *new_gtkfilechooserdialog() 
{
  NspGtkFileChooserDialog *loc;
  /* type must exists */
  nsp_type_gtkfilechooserdialog = new_type_gtkfilechooserdialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFileChooserDialog)))== NULLGTKFILECHOOSERDIALOG) return loc;
  /* initialize object */
  if ( init_gtkfilechooserdialog(loc,nsp_type_gtkfilechooserdialog) == FAIL) return NULLGTKFILECHOOSERDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFileChooserDialog 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkfilechooserdialog_type_name[]="GtkFileChooserDialog";
static char gtkfilechooserdialog_short_type_name[]="GtkFileChooserDialog";

static char *nsp_gtkfilechooserdialog_type_as_string(void)
{
  return(gtkfilechooserdialog_type_name);
}

static char *nsp_gtkfilechooserdialog_type_short_string(NspObject *v)
{
  return(gtkfilechooserdialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFileChooserDialog objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFileChooserDialog   *nsp_gtkfilechooserdialog_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkfilechooserdialog_id)  == TRUE  ) return ((NspGtkFileChooserDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfilechooserdialog));
  return NULL;
}

int IsGtkFileChooserDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkfilechooserdialog_id);
}

int IsGtkFileChooserDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfilechooserdialog_id);
}

NspGtkFileChooserDialog  *GetGtkFileChooserDialogCopy(Stack stack, int i)
{
  if (  GetGtkFileChooserDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFileChooserDialog  *GetGtkFileChooserDialog(Stack stack, int i)
{
  NspGtkFileChooserDialog *M;
  if (( M = nsp_gtkfilechooserdialog_object(NthObj(i))) == NULLGTKFILECHOOSERDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFileChooserDialog *gtkfilechooserdialog_copy(NspGtkFileChooserDialog *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfilechooserdialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfilechooserdialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFileChooserDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 6341 "codegen-3.0/gtk.override"

static int
_wrap_gtk_file_chooser_dialog_new(Stack stack,int rhs,int opt,int lhs)
{
  gchar *title = NULL;
  NspGObject *nsp_window = NULL;
  GObject *ret;
  NspSMatrix *nsp_buttons = NULL;
  NspObject *nsp_ret;
  GtkFileChooserAction action = 0;
  int i;

  int_types T[] = {new_opts,  t_end} ;
  nsp_option opts[] = {
    {"title",string,NULLOBJ,-1},
    {"parent",obj,NULLOBJ,-1},
    {"action",s_int,NULLOBJ,-1},
    {"buttons",smat,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };

  if (GetArgs(stack,rhs,opt,T,&opts, &title, &nsp_window, &action, &nsp_buttons)== FAIL) return RET_BUG;

  if ( nsp_window != NULL && ! nspgobject_check(nsp_window, nsp_type_gtkwindow)) {
    Scierror("window must be a GtkWindow");
    return RET_BUG;
  }
  ret =(GObject *)  gtk_file_chooser_dialog_new(title, (nsp_window != NULL) ? GTK_WINDOW(nsp_window->obj) : NULL,
						action, NULL,NULL);
  if ( ret == NULL) {
    Scierror("could not create GtkFileChooserDialog object");
    return RET_BUG;
  }
  if ( nsp_buttons != NULL)
    {
      for (i = 0; i < nsp_buttons->mn ; i ++)
	{
	  gtk_dialog_add_button(GTK_DIALOG(ret), nsp_buttons->S[i],i+1);
	}
    }

  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *) ret,(NspTypeBase *) nsp_type_gtkfilechooserdialog))== NULL)
    return RET_BUG;

  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 56874 "gtk.c"


static NspMethods *gtkfilechooserdialog_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfilechooserdialog_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkFileChooserWidget ----------- */


#define  NspGtkFileChooserWidget_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkfilechooserwidget.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFileChooserWidget inherits from GtkBox 
 * and implements GtkFileChooser GtkBuildable
 */

int nsp_type_gtkfilechooserwidget_id=0;
NspTypeGtkFileChooserWidget *nsp_type_gtkfilechooserwidget=NULL;

/*
 * Type object for NspGtkFileChooserWidget 
 * all the instance of NspTypeGtkFileChooserWidget share the same id. 
 * nsp_type_gtkfilechooserwidget: is an instance of NspTypeGtkFileChooserWidget 
 *    used for objects of NspGtkFileChooserWidget type (i.e built with new_gtkfilechooserwidget) 
 * other instances are used for derived classes 
 */
NspTypeGtkFileChooserWidget *new_type_gtkfilechooserwidget(type_mode mode)
{
  NspTypeGtkFileChooser *t_gtkfilechooser;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkFileChooserWidget *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfilechooserwidget != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfilechooserwidget;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfilechooserwidget_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkfilechooserwidget_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkfilechooserwidget;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkfilechooserwidget */ 

  top->s_type =  (s_type_func *) nsp_gtkfilechooserwidget_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkfilechooserwidget_type_short_string;
  /* top->create = (create_func*) int_gtkfilechooserwidget_create;*/

  /* specific methods for gtkfilechooserwidget */

  type->init = (init_func *) init_gtkfilechooserwidget;

  /* 
   * NspGtkFileChooserWidget interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkfilechooser = new_type_gtkfilechooser(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkfilechooser;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkfilechooserwidget_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFileChooserWidget called nsp_type_gtkfilechooserwidget
       */
      type->id =  nsp_type_gtkfilechooserwidget_id = nsp_new_type_id();
      nsp_type_gtkfilechooserwidget = type;
      if ( nsp_register_type(nsp_type_gtkfilechooserwidget) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfilechooserwidget, GTK_TYPE_FILE_CHOOSER_WIDGET);
      return ( mode == T_BASE ) ? type : new_type_gtkfilechooserwidget(mode);
    }
  else 
    {
      type->id = nsp_type_gtkfilechooserwidget_id;
      return type;
    }
}

/*
 * initialize NspGtkFileChooserWidget instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfilechooserwidget(NspGtkFileChooserWidget *Obj,NspTypeGtkFileChooserWidget *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFileChooserWidget 
 */

NspGtkFileChooserWidget *new_gtkfilechooserwidget() 
{
  NspGtkFileChooserWidget *loc;
  /* type must exists */
  nsp_type_gtkfilechooserwidget = new_type_gtkfilechooserwidget(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFileChooserWidget)))== NULLGTKFILECHOOSERWIDGET) return loc;
  /* initialize object */
  if ( init_gtkfilechooserwidget(loc,nsp_type_gtkfilechooserwidget) == FAIL) return NULLGTKFILECHOOSERWIDGET;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFileChooserWidget 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkfilechooserwidget_type_name[]="GtkFileChooserWidget";
static char gtkfilechooserwidget_short_type_name[]="GtkFileChooserWidget";

static char *nsp_gtkfilechooserwidget_type_as_string(void)
{
  return(gtkfilechooserwidget_type_name);
}

static char *nsp_gtkfilechooserwidget_type_short_string(NspObject *v)
{
  return(gtkfilechooserwidget_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFileChooserWidget objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFileChooserWidget   *nsp_gtkfilechooserwidget_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkfilechooserwidget_id)  == TRUE  ) return ((NspGtkFileChooserWidget *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfilechooserwidget));
  return NULL;
}

int IsGtkFileChooserWidgetObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkfilechooserwidget_id);
}

int IsGtkFileChooserWidget(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfilechooserwidget_id);
}

NspGtkFileChooserWidget  *GetGtkFileChooserWidgetCopy(Stack stack, int i)
{
  if (  GetGtkFileChooserWidget(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFileChooserWidget  *GetGtkFileChooserWidget(Stack stack, int i)
{
  NspGtkFileChooserWidget *M;
  if (( M = nsp_gtkfilechooserwidget_object(NthObj(i))) == NULLGTKFILECHOOSERWIDGET)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFileChooserWidget *gtkfilechooserwidget_copy(NspGtkFileChooserWidget *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfilechooserwidget);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfilechooserwidget);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFileChooserWidget
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_file_chooser_widget_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj, t_end};
  GtkFileChooserAction action;
  NspObject *nsp_action = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_action) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_FILE_CHOOSER_ACTION, nsp_action, &action)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_file_chooser_widget_new(action))== NULL) return RET_BUG;

  nsp_type_gtkfilechooserwidget = new_type_gtkfilechooserwidget(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkfilechooserwidget);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkfilechooserwidget_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfilechooserwidget_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkFileFilter ----------- */


#define  NspGtkFileFilter_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkfilefilter.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFileFilter inherits from GObject 
 * and implements GtkBuildable
 */

int nsp_type_gtkfilefilter_id=0;
NspTypeGtkFileFilter *nsp_type_gtkfilefilter=NULL;

/*
 * Type object for NspGtkFileFilter 
 * all the instance of NspTypeGtkFileFilter share the same id. 
 * nsp_type_gtkfilefilter: is an instance of NspTypeGtkFileFilter 
 *    used for objects of NspGtkFileFilter type (i.e built with new_gtkfilefilter) 
 * other instances are used for derived classes 
 */
NspTypeGtkFileFilter *new_type_gtkfilefilter(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkFileFilter *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfilefilter != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfilefilter;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfilefilter_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkfilefilter_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkfilefilter;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkfilefilter */ 

  top->s_type =  (s_type_func *) nsp_gtkfilefilter_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkfilefilter_type_short_string;
  /* top->create = (create_func*) int_gtkfilefilter_create;*/

  /* specific methods for gtkfilefilter */

  type->init = (init_func *) init_gtkfilefilter;

  /* 
   * NspGtkFileFilter interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkfilefilter_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFileFilter called nsp_type_gtkfilefilter
       */
      type->id =  nsp_type_gtkfilefilter_id = nsp_new_type_id();
      nsp_type_gtkfilefilter = type;
      if ( nsp_register_type(nsp_type_gtkfilefilter) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfilefilter, GTK_TYPE_FILE_FILTER);
      return ( mode == T_BASE ) ? type : new_type_gtkfilefilter(mode);
    }
  else 
    {
      type->id = nsp_type_gtkfilefilter_id;
      return type;
    }
}

/*
 * initialize NspGtkFileFilter instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfilefilter(NspGtkFileFilter *Obj,NspTypeGtkFileFilter *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFileFilter 
 */

NspGtkFileFilter *new_gtkfilefilter() 
{
  NspGtkFileFilter *loc;
  /* type must exists */
  nsp_type_gtkfilefilter = new_type_gtkfilefilter(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFileFilter)))== NULLGTKFILEFILTER) return loc;
  /* initialize object */
  if ( init_gtkfilefilter(loc,nsp_type_gtkfilefilter) == FAIL) return NULLGTKFILEFILTER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFileFilter 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkfilefilter_type_name[]="GtkFileFilter";
static char gtkfilefilter_short_type_name[]="GtkFileFilter";

static char *nsp_gtkfilefilter_type_as_string(void)
{
  return(gtkfilefilter_type_name);
}

static char *nsp_gtkfilefilter_type_short_string(NspObject *v)
{
  return(gtkfilefilter_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFileFilter objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFileFilter   *nsp_gtkfilefilter_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkfilefilter_id)  == TRUE  ) return ((NspGtkFileFilter *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfilefilter));
  return NULL;
}

int IsGtkFileFilterObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkfilefilter_id);
}

int IsGtkFileFilter(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfilefilter_id);
}

NspGtkFileFilter  *GetGtkFileFilterCopy(Stack stack, int i)
{
  if (  GetGtkFileFilter(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFileFilter  *GetGtkFileFilter(Stack stack, int i)
{
  NspGtkFileFilter *M;
  if (( M = nsp_gtkfilefilter_object(NthObj(i))) == NULLGTKFILEFILTER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFileFilter *gtkfilefilter_copy(NspGtkFileFilter *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfilefilter);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfilefilter);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFileFilter
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_file_filter_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_file_filter_new())== NULL) return RET_BUG;

  nsp_type_gtkfilefilter = new_type_gtkfilefilter(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkfilefilter);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_file_filter_set_name(NspGtkFileFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_file_filter_set_name(GTK_FILE_FILTER(self->obj),name);
  return 0;
}

static int _wrap_gtk_file_filter_get_name(NspGtkFileFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_file_filter_get_name(GTK_FILE_FILTER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_file_filter_add_mime_type(NspGtkFileFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *mime_type;
  if ( GetArgs(stack,rhs,opt,T,&mime_type) == FAIL) return RET_BUG;
    gtk_file_filter_add_mime_type(GTK_FILE_FILTER(self->obj),mime_type);
  return 0;
}

static int _wrap_gtk_file_filter_add_pattern(NspGtkFileFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *pattern;
  if ( GetArgs(stack,rhs,opt,T,&pattern) == FAIL) return RET_BUG;
    gtk_file_filter_add_pattern(GTK_FILE_FILTER(self->obj),pattern);
  return 0;
}

static int _wrap_gtk_file_filter_add_pixbuf_formats(NspGtkFileFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_file_filter_add_pixbuf_formats(GTK_FILE_FILTER(self->obj));
  return 0;
}

static int _wrap_gtk_file_filter_get_needed(NspGtkFileFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_file_filter_get_needed(GTK_FILE_FILTER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkfilefilter_methods[] = {
  {"set_name",(nsp_method *) _wrap_gtk_file_filter_set_name},
  {"get_name",(nsp_method *) _wrap_gtk_file_filter_get_name},
  {"add_mime_type",(nsp_method *) _wrap_gtk_file_filter_add_mime_type},
  {"add_pattern",(nsp_method *) _wrap_gtk_file_filter_add_pattern},
  {"add_pixbuf_formats",(nsp_method *) _wrap_gtk_file_filter_add_pixbuf_formats},
  {"get_needed",(nsp_method *) _wrap_gtk_file_filter_get_needed},
  { NULL, NULL}
};

static NspMethods *gtkfilefilter_get_methods(void) { return gtkfilefilter_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfilefilter_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkFontButton ----------- */


#define  NspGtkFontButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkfontbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFontButton inherits from GtkButton 
 * and implements GtkBuildable
 */

int nsp_type_gtkfontbutton_id=0;
NspTypeGtkFontButton *nsp_type_gtkfontbutton=NULL;

/*
 * Type object for NspGtkFontButton 
 * all the instance of NspTypeGtkFontButton share the same id. 
 * nsp_type_gtkfontbutton: is an instance of NspTypeGtkFontButton 
 *    used for objects of NspGtkFontButton type (i.e built with new_gtkfontbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkFontButton *new_type_gtkfontbutton(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkFontButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfontbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfontbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkButton))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbutton(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfontbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkfontbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkfontbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkfontbutton */ 

  top->s_type =  (s_type_func *) nsp_gtkfontbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkfontbutton_type_short_string;
  /* top->create = (create_func*) int_gtkfontbutton_create;*/

  /* specific methods for gtkfontbutton */

  type->init = (init_func *) init_gtkfontbutton;

  /* 
   * NspGtkFontButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkfontbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFontButton called nsp_type_gtkfontbutton
       */
      type->id =  nsp_type_gtkfontbutton_id = nsp_new_type_id();
      nsp_type_gtkfontbutton = type;
      if ( nsp_register_type(nsp_type_gtkfontbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfontbutton, GTK_TYPE_FONT_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkfontbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkfontbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkFontButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfontbutton(NspGtkFontButton *Obj,NspTypeGtkFontButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFontButton 
 */

NspGtkFontButton *new_gtkfontbutton() 
{
  NspGtkFontButton *loc;
  /* type must exists */
  nsp_type_gtkfontbutton = new_type_gtkfontbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFontButton)))== NULLGTKFONTBUTTON) return loc;
  /* initialize object */
  if ( init_gtkfontbutton(loc,nsp_type_gtkfontbutton) == FAIL) return NULLGTKFONTBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFontButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkfontbutton_type_name[]="GtkFontButton";
static char gtkfontbutton_short_type_name[]="GtkFontButton";

static char *nsp_gtkfontbutton_type_as_string(void)
{
  return(gtkfontbutton_type_name);
}

static char *nsp_gtkfontbutton_type_short_string(NspObject *v)
{
  return(gtkfontbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFontButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFontButton   *nsp_gtkfontbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkfontbutton_id)  == TRUE  ) return ((NspGtkFontButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfontbutton));
  return NULL;
}

int IsGtkFontButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkfontbutton_id);
}

int IsGtkFontButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfontbutton_id);
}

NspGtkFontButton  *GetGtkFontButtonCopy(Stack stack, int i)
{
  if (  GetGtkFontButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFontButton  *GetGtkFontButton(Stack stack, int i)
{
  NspGtkFontButton *M;
  if (( M = nsp_gtkfontbutton_object(NthObj(i))) == NULLGTKFONTBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFontButton *gtkfontbutton_copy(NspGtkFontButton *self)
{
  /* return gtkbutton_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFontButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_font_button_new_with_font (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *fontname;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&fontname) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_font_button_new_with_font(fontname))== NULL) return RET_BUG;

  nsp_type_gtkfontbutton = new_type_gtkfontbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkfontbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_font_button_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_font_button_new())== NULL) return RET_BUG;

  nsp_type_gtkfontbutton = new_type_gtkfontbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkfontbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_font_button_get_title(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_font_button_get_title(GTK_FONT_BUTTON(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_font_button_set_title(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *title;
  if ( GetArgs(stack,rhs,opt,T,&title) == FAIL) return RET_BUG;
    gtk_font_button_set_title(GTK_FONT_BUTTON(self->obj),title);
  return 0;
}

static int _wrap_gtk_font_button_get_use_font(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_font_button_get_use_font(GTK_FONT_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_font_button_set_use_font(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_font;
  if ( GetArgs(stack,rhs,opt,T,&use_font) == FAIL) return RET_BUG;
    gtk_font_button_set_use_font(GTK_FONT_BUTTON(self->obj),use_font);
  return 0;
}

static int _wrap_gtk_font_button_get_use_size(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_font_button_get_use_size(GTK_FONT_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_font_button_set_use_size(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_size;
  if ( GetArgs(stack,rhs,opt,T,&use_size) == FAIL) return RET_BUG;
    gtk_font_button_set_use_size(GTK_FONT_BUTTON(self->obj),use_size);
  return 0;
}

static int _wrap_gtk_font_button_get_font_name(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_font_button_get_font_name(GTK_FONT_BUTTON(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_font_button_set_font_name(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *fontname;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&fontname) == FAIL) return RET_BUG;
    ret =gtk_font_button_set_font_name(GTK_FONT_BUTTON(self->obj),fontname);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_font_button_get_show_style(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_font_button_get_show_style(GTK_FONT_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_font_button_set_show_style(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_style;
  if ( GetArgs(stack,rhs,opt,T,&show_style) == FAIL) return RET_BUG;
    gtk_font_button_set_show_style(GTK_FONT_BUTTON(self->obj),show_style);
  return 0;
}

static int _wrap_gtk_font_button_get_show_size(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_font_button_get_show_size(GTK_FONT_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_font_button_set_show_size(NspGtkFontButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_size;
  if ( GetArgs(stack,rhs,opt,T,&show_size) == FAIL) return RET_BUG;
    gtk_font_button_set_show_size(GTK_FONT_BUTTON(self->obj),show_size);
  return 0;
}

static NspMethods gtkfontbutton_methods[] = {
  {"get_title",(nsp_method *) _wrap_gtk_font_button_get_title},
  {"set_title",(nsp_method *) _wrap_gtk_font_button_set_title},
  {"get_use_font",(nsp_method *) _wrap_gtk_font_button_get_use_font},
  {"set_use_font",(nsp_method *) _wrap_gtk_font_button_set_use_font},
  {"get_use_size",(nsp_method *) _wrap_gtk_font_button_get_use_size},
  {"set_use_size",(nsp_method *) _wrap_gtk_font_button_set_use_size},
  {"get_font_name",(nsp_method *) _wrap_gtk_font_button_get_font_name},
  {"set_font_name",(nsp_method *) _wrap_gtk_font_button_set_font_name},
  {"get_show_style",(nsp_method *) _wrap_gtk_font_button_get_show_style},
  {"set_show_style",(nsp_method *) _wrap_gtk_font_button_set_show_style},
  {"get_show_size",(nsp_method *) _wrap_gtk_font_button_get_show_size},
  {"set_show_size",(nsp_method *) _wrap_gtk_font_button_set_show_size},
  { NULL, NULL}
};

static NspMethods *gtkfontbutton_get_methods(void) { return gtkfontbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfontbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkFontChooserWidget ----------- */


#define  NspGtkFontChooserWidget_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkfontchooserwidget.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFontChooserWidget inherits from GtkBox 
 * and implements GtkFontChooser GtkBuildable
 */

int nsp_type_gtkfontchooserwidget_id=0;
NspTypeGtkFontChooserWidget *nsp_type_gtkfontchooserwidget=NULL;

/*
 * Type object for NspGtkFontChooserWidget 
 * all the instance of NspTypeGtkFontChooserWidget share the same id. 
 * nsp_type_gtkfontchooserwidget: is an instance of NspTypeGtkFontChooserWidget 
 *    used for objects of NspGtkFontChooserWidget type (i.e built with new_gtkfontchooserwidget) 
 * other instances are used for derived classes 
 */
NspTypeGtkFontChooserWidget *new_type_gtkfontchooserwidget(type_mode mode)
{
  NspTypeGtkFontChooser *t_gtkfontchooser;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkFontChooserWidget *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfontchooserwidget != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfontchooserwidget;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfontchooserwidget_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkfontchooserwidget_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkfontchooserwidget;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkfontchooserwidget */ 

  top->s_type =  (s_type_func *) nsp_gtkfontchooserwidget_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkfontchooserwidget_type_short_string;
  /* top->create = (create_func*) int_gtkfontchooserwidget_create;*/

  /* specific methods for gtkfontchooserwidget */

  type->init = (init_func *) init_gtkfontchooserwidget;

  /* 
   * NspGtkFontChooserWidget interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkfontchooser = new_type_gtkfontchooser(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkfontchooser;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkfontchooserwidget_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFontChooserWidget called nsp_type_gtkfontchooserwidget
       */
      type->id =  nsp_type_gtkfontchooserwidget_id = nsp_new_type_id();
      nsp_type_gtkfontchooserwidget = type;
      if ( nsp_register_type(nsp_type_gtkfontchooserwidget) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfontchooserwidget, GTK_TYPE_FONT_CHOOSER_WIDGET);
      return ( mode == T_BASE ) ? type : new_type_gtkfontchooserwidget(mode);
    }
  else 
    {
      type->id = nsp_type_gtkfontchooserwidget_id;
      return type;
    }
}

/*
 * initialize NspGtkFontChooserWidget instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfontchooserwidget(NspGtkFontChooserWidget *Obj,NspTypeGtkFontChooserWidget *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFontChooserWidget 
 */

NspGtkFontChooserWidget *new_gtkfontchooserwidget() 
{
  NspGtkFontChooserWidget *loc;
  /* type must exists */
  nsp_type_gtkfontchooserwidget = new_type_gtkfontchooserwidget(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFontChooserWidget)))== NULLGTKFONTCHOOSERWIDGET) return loc;
  /* initialize object */
  if ( init_gtkfontchooserwidget(loc,nsp_type_gtkfontchooserwidget) == FAIL) return NULLGTKFONTCHOOSERWIDGET;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFontChooserWidget 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkfontchooserwidget_type_name[]="GtkFontChooserWidget";
static char gtkfontchooserwidget_short_type_name[]="GtkFontChooserWidget";

static char *nsp_gtkfontchooserwidget_type_as_string(void)
{
  return(gtkfontchooserwidget_type_name);
}

static char *nsp_gtkfontchooserwidget_type_short_string(NspObject *v)
{
  return(gtkfontchooserwidget_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFontChooserWidget objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFontChooserWidget   *nsp_gtkfontchooserwidget_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkfontchooserwidget_id)  == TRUE  ) return ((NspGtkFontChooserWidget *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfontchooserwidget));
  return NULL;
}

int IsGtkFontChooserWidgetObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkfontchooserwidget_id);
}

int IsGtkFontChooserWidget(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfontchooserwidget_id);
}

NspGtkFontChooserWidget  *GetGtkFontChooserWidgetCopy(Stack stack, int i)
{
  if (  GetGtkFontChooserWidget(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFontChooserWidget  *GetGtkFontChooserWidget(Stack stack, int i)
{
  NspGtkFontChooserWidget *M;
  if (( M = nsp_gtkfontchooserwidget_object(NthObj(i))) == NULLGTKFONTCHOOSERWIDGET)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFontChooserWidget *gtkfontchooserwidget_copy(NspGtkFontChooserWidget *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontchooserwidget);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontchooserwidget);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFontChooserWidget
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_font_chooser_widget_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_font_chooser_widget_new())== NULL) return RET_BUG;

  nsp_type_gtkfontchooserwidget = new_type_gtkfontchooserwidget(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkfontchooserwidget);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkfontchooserwidget_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfontchooserwidget_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkFontChooserDialog ----------- */


#define  NspGtkFontChooserDialog_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkfontchooserdialog.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFontChooserDialog inherits from GtkDialog 
 * and implements GtkFontChooser GtkBuildable
 */

int nsp_type_gtkfontchooserdialog_id=0;
NspTypeGtkFontChooserDialog *nsp_type_gtkfontchooserdialog=NULL;

/*
 * Type object for NspGtkFontChooserDialog 
 * all the instance of NspTypeGtkFontChooserDialog share the same id. 
 * nsp_type_gtkfontchooserdialog: is an instance of NspTypeGtkFontChooserDialog 
 *    used for objects of NspGtkFontChooserDialog type (i.e built with new_gtkfontchooserdialog) 
 * other instances are used for derived classes 
 */
NspTypeGtkFontChooserDialog *new_type_gtkfontchooserdialog(type_mode mode)
{
  NspTypeGtkFontChooser *t_gtkfontchooser;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkFontChooserDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkfontchooserdialog != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkfontchooserdialog;
    }
  if (( type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkfontchooserdialog_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkfontchooserdialog_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkfontchooserdialog;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkfontchooserdialog */ 

  top->s_type =  (s_type_func *) nsp_gtkfontchooserdialog_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkfontchooserdialog_type_short_string;
  /* top->create = (create_func*) int_gtkfontchooserdialog_create;*/

  /* specific methods for gtkfontchooserdialog */

  type->init = (init_func *) init_gtkfontchooserdialog;

  /* 
   * NspGtkFontChooserDialog interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkfontchooser = new_type_gtkfontchooser(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkfontchooser;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkfontchooserdialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFontChooserDialog called nsp_type_gtkfontchooserdialog
       */
      type->id =  nsp_type_gtkfontchooserdialog_id = nsp_new_type_id();
      nsp_type_gtkfontchooserdialog = type;
      if ( nsp_register_type(nsp_type_gtkfontchooserdialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkfontchooserdialog, GTK_TYPE_FONT_CHOOSER_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkfontchooserdialog(mode);
    }
  else 
    {
      type->id = nsp_type_gtkfontchooserdialog_id;
      return type;
    }
}

/*
 * initialize NspGtkFontChooserDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkfontchooserdialog(NspGtkFontChooserDialog *Obj,NspTypeGtkFontChooserDialog *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFontChooserDialog 
 */

NspGtkFontChooserDialog *new_gtkfontchooserdialog() 
{
  NspGtkFontChooserDialog *loc;
  /* type must exists */
  nsp_type_gtkfontchooserdialog = new_type_gtkfontchooserdialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFontChooserDialog)))== NULLGTKFONTCHOOSERDIALOG) return loc;
  /* initialize object */
  if ( init_gtkfontchooserdialog(loc,nsp_type_gtkfontchooserdialog) == FAIL) return NULLGTKFONTCHOOSERDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFontChooserDialog 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkfontchooserdialog_type_name[]="GtkFontChooserDialog";
static char gtkfontchooserdialog_short_type_name[]="GtkFontChooserDialog";

static char *nsp_gtkfontchooserdialog_type_as_string(void)
{
  return(gtkfontchooserdialog_type_name);
}

static char *nsp_gtkfontchooserdialog_type_short_string(NspObject *v)
{
  return(gtkfontchooserdialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFontChooserDialog objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFontChooserDialog   *nsp_gtkfontchooserdialog_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkfontchooserdialog_id)  == TRUE  ) return ((NspGtkFontChooserDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkfontchooserdialog));
  return NULL;
}

int IsGtkFontChooserDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkfontchooserdialog_id);
}

int IsGtkFontChooserDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkfontchooserdialog_id);
}

NspGtkFontChooserDialog  *GetGtkFontChooserDialogCopy(Stack stack, int i)
{
  if (  GetGtkFontChooserDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFontChooserDialog  *GetGtkFontChooserDialog(Stack stack, int i)
{
  NspGtkFontChooserDialog *M;
  if (( M = nsp_gtkfontchooserdialog_object(NthObj(i))) == NULLGTKFONTCHOOSERDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFontChooserDialog *gtkfontchooserdialog_copy(NspGtkFontChooserDialog *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontchooserdialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkfontchooserdialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFontChooserDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_font_chooser_dialog_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string,obj_check, t_end};
  char *title;
  NspGObject *parent;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&title, &nsp_type_gtkwindow, &parent) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_font_chooser_dialog_new(title,GTK_WINDOW(parent->obj)))== NULL) return RET_BUG;

  nsp_type_gtkfontchooserdialog = new_type_gtkfontchooserdialog(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkfontchooserdialog);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkfontchooserdialog_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkfontchooserdialog_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkPlacesSidebar ----------- */


#define  NspGtkPlacesSidebar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkplacessidebar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkPlacesSidebar inherits from GtkScrolledWindow 
 * and implements GtkBuildable
 */

int nsp_type_gtkplacessidebar_id=0;
NspTypeGtkPlacesSidebar *nsp_type_gtkplacessidebar=NULL;

/*
 * Type object for NspGtkPlacesSidebar 
 * all the instance of NspTypeGtkPlacesSidebar share the same id. 
 * nsp_type_gtkplacessidebar: is an instance of NspTypeGtkPlacesSidebar 
 *    used for objects of NspGtkPlacesSidebar type (i.e built with new_gtkplacessidebar) 
 * other instances are used for derived classes 
 */
NspTypeGtkPlacesSidebar *new_type_gtkplacessidebar(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkPlacesSidebar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkplacessidebar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkplacessidebar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkScrolledWindow))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkscrolledwindow(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkplacessidebar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkplacessidebar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkplacessidebar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkplacessidebar */ 

  top->s_type =  (s_type_func *) nsp_gtkplacessidebar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkplacessidebar_type_short_string;
  /* top->create = (create_func*) int_gtkplacessidebar_create;*/

  /* specific methods for gtkplacessidebar */

  type->init = (init_func *) init_gtkplacessidebar;

  /* 
   * NspGtkPlacesSidebar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkplacessidebar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkPlacesSidebar called nsp_type_gtkplacessidebar
       */
      type->id =  nsp_type_gtkplacessidebar_id = nsp_new_type_id();
      nsp_type_gtkplacessidebar = type;
      if ( nsp_register_type(nsp_type_gtkplacessidebar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkplacessidebar, GTK_TYPE_PLACES_SIDEBAR);
      return ( mode == T_BASE ) ? type : new_type_gtkplacessidebar(mode);
    }
  else 
    {
      type->id = nsp_type_gtkplacessidebar_id;
      return type;
    }
}

/*
 * initialize NspGtkPlacesSidebar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkplacessidebar(NspGtkPlacesSidebar *Obj,NspTypeGtkPlacesSidebar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkPlacesSidebar 
 */

NspGtkPlacesSidebar *new_gtkplacessidebar() 
{
  NspGtkPlacesSidebar *loc;
  /* type must exists */
  nsp_type_gtkplacessidebar = new_type_gtkplacessidebar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkPlacesSidebar)))== NULLGTKPLACESSIDEBAR) return loc;
  /* initialize object */
  if ( init_gtkplacessidebar(loc,nsp_type_gtkplacessidebar) == FAIL) return NULLGTKPLACESSIDEBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkPlacesSidebar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkplacessidebar_type_name[]="GtkPlacesSidebar";
static char gtkplacessidebar_short_type_name[]="GtkPlacesSidebar";

static char *nsp_gtkplacessidebar_type_as_string(void)
{
  return(gtkplacessidebar_type_name);
}

static char *nsp_gtkplacessidebar_type_short_string(NspObject *v)
{
  return(gtkplacessidebar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkPlacesSidebar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkPlacesSidebar   *nsp_gtkplacessidebar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkplacessidebar_id)  == TRUE  ) return ((NspGtkPlacesSidebar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkplacessidebar));
  return NULL;
}

int IsGtkPlacesSidebarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkplacessidebar_id);
}

int IsGtkPlacesSidebar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkplacessidebar_id);
}

NspGtkPlacesSidebar  *GetGtkPlacesSidebarCopy(Stack stack, int i)
{
  if (  GetGtkPlacesSidebar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkPlacesSidebar  *GetGtkPlacesSidebar(Stack stack, int i)
{
  NspGtkPlacesSidebar *M;
  if (( M = nsp_gtkplacessidebar_object(NthObj(i))) == NULLGTKPLACESSIDEBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkPlacesSidebar *gtkplacessidebar_copy(NspGtkPlacesSidebar *self)
{
  /* return gtkscrolledwindow_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkplacessidebar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkplacessidebar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkPlacesSidebar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_places_sidebar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_places_sidebar_new())== NULL) return RET_BUG;

  nsp_type_gtkplacessidebar = new_type_gtkplacessidebar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkplacessidebar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_get_open_flags(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_places_sidebar_get_open_flags(GTK_PLACES_SIDEBAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_places_sidebar_get_open_flags(Stack stack, int rhs, int opt, int lhs) /* get_open_flags */
{
  Scierror("Error: function gtk_places_sidebar_get_open_flags not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_set_open_flags(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkPlacesOpenFlags flags;
  NspObject *nsp_flags = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_PLACES_OPEN_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    gtk_places_sidebar_set_open_flags(GTK_PLACES_SIDEBAR(self->obj),flags);
  return 0;
}

#else
int _wrap_gtk_places_sidebar_set_open_flags(Stack stack, int rhs, int opt, int lhs) /* set_open_flags */
{
  Scierror("Error: function gtk_places_sidebar_set_open_flags not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_get_location(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  GFile *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_places_sidebar_get_location(GTK_PLACES_SIDEBAR(self->obj));
  nsp_type_gfile = new_type_gfile(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gfile))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_places_sidebar_get_location(Stack stack, int rhs, int opt, int lhs) /* get_location */
{
  Scierror("Error: function gtk_places_sidebar_get_location not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_set_location(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *location;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gfile, &location) == FAIL) return RET_BUG;
    gtk_places_sidebar_set_location(GTK_PLACES_SIDEBAR(self->obj),G_FILE(location->obj));
  return 0;
}

#else
int _wrap_gtk_places_sidebar_set_location(Stack stack, int rhs, int opt, int lhs) /* set_location */
{
  Scierror("Error: function gtk_places_sidebar_set_location not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_get_show_desktop(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_places_sidebar_get_show_desktop(GTK_PLACES_SIDEBAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_places_sidebar_get_show_desktop(Stack stack, int rhs, int opt, int lhs) /* get_show_desktop */
{
  Scierror("Error: function gtk_places_sidebar_get_show_desktop not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_set_show_desktop(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_desktop;
  if ( GetArgs(stack,rhs,opt,T,&show_desktop) == FAIL) return RET_BUG;
    gtk_places_sidebar_set_show_desktop(GTK_PLACES_SIDEBAR(self->obj),show_desktop);
  return 0;
}

#else
int _wrap_gtk_places_sidebar_set_show_desktop(Stack stack, int rhs, int opt, int lhs) /* set_show_desktop */
{
  Scierror("Error: function gtk_places_sidebar_set_show_desktop not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_get_show_connect_to_server(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_places_sidebar_get_show_connect_to_server(GTK_PLACES_SIDEBAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_places_sidebar_get_show_connect_to_server(Stack stack, int rhs, int opt, int lhs) /* get_show_connect_to_server */
{
  Scierror("Error: function gtk_places_sidebar_get_show_connect_to_server not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_set_show_connect_to_server(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_connect_to_server;
  if ( GetArgs(stack,rhs,opt,T,&show_connect_to_server) == FAIL) return RET_BUG;
    gtk_places_sidebar_set_show_connect_to_server(GTK_PLACES_SIDEBAR(self->obj),show_connect_to_server);
  return 0;
}

#else
int _wrap_gtk_places_sidebar_set_show_connect_to_server(Stack stack, int rhs, int opt, int lhs) /* set_show_connect_to_server */
{
  Scierror("Error: function gtk_places_sidebar_set_show_connect_to_server not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_places_sidebar_get_show_enter_location(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_places_sidebar_get_show_enter_location(GTK_PLACES_SIDEBAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_places_sidebar_get_show_enter_location(Stack stack, int rhs, int opt, int lhs) /* get_show_enter_location */
{
  Scierror("Error: function gtk_places_sidebar_get_show_enter_location not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_places_sidebar_set_show_enter_location(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_enter_location;
  if ( GetArgs(stack,rhs,opt,T,&show_enter_location) == FAIL) return RET_BUG;
    gtk_places_sidebar_set_show_enter_location(GTK_PLACES_SIDEBAR(self->obj),show_enter_location);
  return 0;
}

#else
int _wrap_gtk_places_sidebar_set_show_enter_location(Stack stack, int rhs, int opt, int lhs) /* set_show_enter_location */
{
  Scierror("Error: function gtk_places_sidebar_set_show_enter_location not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_places_sidebar_set_local_only(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int local_only;
  if ( GetArgs(stack,rhs,opt,T,&local_only) == FAIL) return RET_BUG;
    gtk_places_sidebar_set_local_only(GTK_PLACES_SIDEBAR(self->obj),local_only);
  return 0;
}

#else
int _wrap_gtk_places_sidebar_set_local_only(Stack stack, int rhs, int opt, int lhs) /* set_local_only */
{
  Scierror("Error: function gtk_places_sidebar_set_local_only not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_places_sidebar_get_local_only(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_places_sidebar_get_local_only(GTK_PLACES_SIDEBAR(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_places_sidebar_get_local_only(Stack stack, int rhs, int opt, int lhs) /* get_local_only */
{
  Scierror("Error: function gtk_places_sidebar_get_local_only not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_add_shortcut(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *location;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gfile, &location) == FAIL) return RET_BUG;
    gtk_places_sidebar_add_shortcut(GTK_PLACES_SIDEBAR(self->obj),G_FILE(location->obj));
  return 0;
}

#else
int _wrap_gtk_places_sidebar_add_shortcut(Stack stack, int rhs, int opt, int lhs) /* add_shortcut */
{
  Scierror("Error: function gtk_places_sidebar_add_shortcut not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_remove_shortcut(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *location;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gfile, &location) == FAIL) return RET_BUG;
    gtk_places_sidebar_remove_shortcut(GTK_PLACES_SIDEBAR(self->obj),G_FILE(location->obj));
  return 0;
}

#else
int _wrap_gtk_places_sidebar_remove_shortcut(Stack stack, int rhs, int opt, int lhs) /* remove_shortcut */
{
  Scierror("Error: function gtk_places_sidebar_remove_shortcut not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_list_shortcuts(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_places_sidebar_list_shortcuts(GTK_PLACES_SIDEBAR(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

#else
int _wrap_gtk_places_sidebar_list_shortcuts(Stack stack, int rhs, int opt, int lhs) /* list_shortcuts */
{
  Scierror("Error: function gtk_places_sidebar_list_shortcuts not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_places_sidebar_get_nth_bookmark(NspGtkPlacesSidebar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int n;
  GFile *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&n) == FAIL) return RET_BUG;
    ret =gtk_places_sidebar_get_nth_bookmark(GTK_PLACES_SIDEBAR(self->obj),n);
  nsp_type_gfile = new_type_gfile(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gfile))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_places_sidebar_get_nth_bookmark(Stack stack, int rhs, int opt, int lhs) /* get_nth_bookmark */
{
  Scierror("Error: function gtk_places_sidebar_get_nth_bookmark not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkplacessidebar_methods[] = {
  {"get_open_flags",(nsp_method *) _wrap_gtk_places_sidebar_get_open_flags},
  {"set_open_flags",(nsp_method *) _wrap_gtk_places_sidebar_set_open_flags},
  {"get_location",(nsp_method *) _wrap_gtk_places_sidebar_get_location},
  {"set_location",(nsp_method *) _wrap_gtk_places_sidebar_set_location},
  {"get_show_desktop",(nsp_method *) _wrap_gtk_places_sidebar_get_show_desktop},
  {"set_show_desktop",(nsp_method *) _wrap_gtk_places_sidebar_set_show_desktop},
  {"get_show_connect_to_server",(nsp_method *) _wrap_gtk_places_sidebar_get_show_connect_to_server},
  {"set_show_connect_to_server",(nsp_method *) _wrap_gtk_places_sidebar_set_show_connect_to_server},
  {"get_show_enter_location",(nsp_method *) _wrap_gtk_places_sidebar_get_show_enter_location},
  {"set_show_enter_location",(nsp_method *) _wrap_gtk_places_sidebar_set_show_enter_location},
  {"set_local_only",(nsp_method *) _wrap_gtk_places_sidebar_set_local_only},
  {"get_local_only",(nsp_method *) _wrap_gtk_places_sidebar_get_local_only},
  {"add_shortcut",(nsp_method *) _wrap_gtk_places_sidebar_add_shortcut},
  {"remove_shortcut",(nsp_method *) _wrap_gtk_places_sidebar_remove_shortcut},
  {"list_shortcuts",(nsp_method *) _wrap_gtk_places_sidebar_list_shortcuts},
  {"get_nth_bookmark",(nsp_method *) _wrap_gtk_places_sidebar_get_nth_bookmark},
  { NULL, NULL}
};

static NspMethods *gtkplacessidebar_get_methods(void) { return gtkplacessidebar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkplacessidebar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkFrame ----------- */


#define  NspGtkFrame_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkframe.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkFrame inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkframe_id=0;
NspTypeGtkFrame *nsp_type_gtkframe=NULL;

/*
 * Type object for NspGtkFrame 
 * all the instance of NspTypeGtkFrame share the same id. 
 * nsp_type_gtkframe: is an instance of NspTypeGtkFrame 
 *    used for objects of NspGtkFrame type (i.e built with new_gtkframe) 
 * other instances are used for derived classes 
 */
NspTypeGtkFrame *new_type_gtkframe(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkFrame *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkframe != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkframe;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkframe_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkframe_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkframe;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkframe */ 

  top->s_type =  (s_type_func *) nsp_gtkframe_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkframe_type_short_string;
  /* top->create = (create_func*) int_gtkframe_create;*/

  /* specific methods for gtkframe */

  type->init = (init_func *) init_gtkframe;

  /* 
   * NspGtkFrame interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkframe_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkFrame called nsp_type_gtkframe
       */
      type->id =  nsp_type_gtkframe_id = nsp_new_type_id();
      nsp_type_gtkframe = type;
      if ( nsp_register_type(nsp_type_gtkframe) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkframe, GTK_TYPE_FRAME);
      return ( mode == T_BASE ) ? type : new_type_gtkframe(mode);
    }
  else 
    {
      type->id = nsp_type_gtkframe_id;
      return type;
    }
}

/*
 * initialize NspGtkFrame instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkframe(NspGtkFrame *Obj,NspTypeGtkFrame *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkFrame 
 */

NspGtkFrame *new_gtkframe() 
{
  NspGtkFrame *loc;
  /* type must exists */
  nsp_type_gtkframe = new_type_gtkframe(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkFrame)))== NULLGTKFRAME) return loc;
  /* initialize object */
  if ( init_gtkframe(loc,nsp_type_gtkframe) == FAIL) return NULLGTKFRAME;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkFrame 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkframe_type_name[]="GtkFrame";
static char gtkframe_short_type_name[]="GtkFrame";

static char *nsp_gtkframe_type_as_string(void)
{
  return(gtkframe_type_name);
}

static char *nsp_gtkframe_type_short_string(NspObject *v)
{
  return(gtkframe_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkFrame objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkFrame   *nsp_gtkframe_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkframe_id)  == TRUE  ) return ((NspGtkFrame *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkframe));
  return NULL;
}

int IsGtkFrameObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkframe_id);
}

int IsGtkFrame(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkframe_id);
}

NspGtkFrame  *GetGtkFrameCopy(Stack stack, int i)
{
  if (  GetGtkFrame(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkFrame  *GetGtkFrame(Stack stack, int i)
{
  NspGtkFrame *M;
  if (( M = nsp_gtkframe_object(NthObj(i))) == NULLGTKFRAME)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkFrame *gtkframe_copy(NspGtkFrame *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkframe);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkframe);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkFrame
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_frame_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"label",string,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  char *label = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &label) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_frame_new(label))== NULL) return RET_BUG;

  nsp_type_gtkframe = new_type_gtkframe(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkframe);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_frame_set_label(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *label;
  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
    gtk_frame_set_label(GTK_FRAME(self->obj),label);
  return 0;
}

static int _wrap_gtk_frame_get_label(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_frame_get_label(GTK_FRAME(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_frame_set_label_widget(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *label_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &label_widget) == FAIL) return RET_BUG;
    gtk_frame_set_label_widget(GTK_FRAME(self->obj),GTK_WIDGET(label_widget->obj));
  return 0;
}

static int _wrap_gtk_frame_get_label_widget(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_frame_get_label_widget(GTK_FRAME(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_frame_set_label_align(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,s_double, t_end};
  double xalign, yalign;
  if ( GetArgs(stack,rhs,opt,T,&xalign, &yalign) == FAIL) return RET_BUG;
    gtk_frame_set_label_align(GTK_FRAME(self->obj),xalign,yalign);
  return 0;
}

#line 6641 "codegen-3.0/gtk.override"
static int
_wrap_gtk_frame_get_label_align(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gfloat xalign, yalign;

  gtk_frame_get_label_align(GTK_FRAME(self->obj), &xalign, &yalign);
  if ( nsp_move_doubles(stack,1,1,2,(double) xalign,(double) yalign) == FAIL) return RET_BUG;
  return 1;

}
#line 58985 "gtk.c"


static int _wrap_gtk_frame_set_shadow_type(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkShadowType type;
  NspObject *nsp_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
    gtk_frame_set_shadow_type(GTK_FRAME(self->obj),type);
  return 0;
}

static int _wrap_gtk_frame_get_shadow_type(NspGtkFrame *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_frame_get_shadow_type(GTK_FRAME(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkframe_methods[] = {
  {"set_label",(nsp_method *) _wrap_gtk_frame_set_label},
  {"get_label",(nsp_method *) _wrap_gtk_frame_get_label},
  {"set_label_widget",(nsp_method *) _wrap_gtk_frame_set_label_widget},
  {"get_label_widget",(nsp_method *) _wrap_gtk_frame_get_label_widget},
  {"set_label_align",(nsp_method *) _wrap_gtk_frame_set_label_align},
  {"get_label_align",(nsp_method *) _wrap_gtk_frame_get_label_align},
  {"set_shadow_type",(nsp_method *) _wrap_gtk_frame_set_shadow_type},
  {"get_shadow_type",(nsp_method *) _wrap_gtk_frame_get_shadow_type},
  { NULL, NULL}
};

static NspMethods *gtkframe_get_methods(void) { return gtkframe_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkframe_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkSeparator ----------- */


#define  NspGtkSeparator_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkseparator.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkSeparator inherits from GtkWidget 
 * and implements GtkBuildable
 */

int nsp_type_gtkseparator_id=0;
NspTypeGtkSeparator *nsp_type_gtkseparator=NULL;

/*
 * Type object for NspGtkSeparator 
 * all the instance of NspTypeGtkSeparator share the same id. 
 * nsp_type_gtkseparator: is an instance of NspTypeGtkSeparator 
 *    used for objects of NspGtkSeparator type (i.e built with new_gtkseparator) 
 * other instances are used for derived classes 
 */
NspTypeGtkSeparator *new_type_gtkseparator(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkSeparator *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkseparator != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkseparator;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkseparator_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkseparator_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkseparator;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkseparator */ 

  top->s_type =  (s_type_func *) nsp_gtkseparator_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkseparator_type_short_string;
  /* top->create = (create_func*) int_gtkseparator_create;*/

  /* specific methods for gtkseparator */

  type->init = (init_func *) init_gtkseparator;

  /* 
   * NspGtkSeparator interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkseparator_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSeparator called nsp_type_gtkseparator
       */
      type->id =  nsp_type_gtkseparator_id = nsp_new_type_id();
      nsp_type_gtkseparator = type;
      if ( nsp_register_type(nsp_type_gtkseparator) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkseparator, GTK_TYPE_SEPARATOR);
      return ( mode == T_BASE ) ? type : new_type_gtkseparator(mode);
    }
  else 
    {
      type->id = nsp_type_gtkseparator_id;
      return type;
    }
}

/*
 * initialize NspGtkSeparator instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkseparator(NspGtkSeparator *Obj,NspTypeGtkSeparator *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkSeparator 
 */

NspGtkSeparator *new_gtkseparator() 
{
  NspGtkSeparator *loc;
  /* type must exists */
  nsp_type_gtkseparator = new_type_gtkseparator(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSeparator)))== NULLGTKSEPARATOR) return loc;
  /* initialize object */
  if ( init_gtkseparator(loc,nsp_type_gtkseparator) == FAIL) return NULLGTKSEPARATOR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkSeparator 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkseparator_type_name[]="GtkSeparator";
static char gtkseparator_short_type_name[]="GtkSeparator";

static char *nsp_gtkseparator_type_as_string(void)
{
  return(gtkseparator_type_name);
}

static char *nsp_gtkseparator_type_short_string(NspObject *v)
{
  return(gtkseparator_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkSeparator objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkSeparator   *nsp_gtkseparator_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkseparator_id)  == TRUE  ) return ((NspGtkSeparator *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkseparator));
  return NULL;
}

int IsGtkSeparatorObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkseparator_id);
}

int IsGtkSeparator(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkseparator_id);
}

NspGtkSeparator  *GetGtkSeparatorCopy(Stack stack, int i)
{
  if (  GetGtkSeparator(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSeparator  *GetGtkSeparator(Stack stack, int i)
{
  NspGtkSeparator *M;
  if (( M = nsp_gtkseparator_object(NthObj(i))) == NULLGTKSEPARATOR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSeparator *gtkseparator_copy(NspGtkSeparator *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkseparator);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkseparator);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSeparator
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_separator_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj, t_end};
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_separator_new(orientation))== NULL) return RET_BUG;

  nsp_type_gtkseparator = new_type_gtkseparator(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkseparator);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkseparator_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkseparator_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkScrollbar ----------- */


#define  NspGtkScrollbar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkscrollbar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkScrollbar inherits from GtkRange 
 * and implements GtkOrientable GtkBuildable
 */

int nsp_type_gtkscrollbar_id=0;
NspTypeGtkScrollbar *nsp_type_gtkscrollbar=NULL;

/*
 * Type object for NspGtkScrollbar 
 * all the instance of NspTypeGtkScrollbar share the same id. 
 * nsp_type_gtkscrollbar: is an instance of NspTypeGtkScrollbar 
 *    used for objects of NspGtkScrollbar type (i.e built with new_gtkscrollbar) 
 * other instances are used for derived classes 
 */
NspTypeGtkScrollbar *new_type_gtkscrollbar(type_mode mode)
{
  NspTypeGtkOrientable *t_gtkorientable;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkScrollbar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkscrollbar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkscrollbar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkRange))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkrange(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkscrollbar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkscrollbar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkscrollbar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkscrollbar */ 

  top->s_type =  (s_type_func *) nsp_gtkscrollbar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkscrollbar_type_short_string;
  /* top->create = (create_func*) int_gtkscrollbar_create;*/

  /* specific methods for gtkscrollbar */

  type->init = (init_func *) init_gtkscrollbar;

  /* 
   * NspGtkScrollbar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkorientable = new_type_gtkorientable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkorientable;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkscrollbar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkScrollbar called nsp_type_gtkscrollbar
       */
      type->id =  nsp_type_gtkscrollbar_id = nsp_new_type_id();
      nsp_type_gtkscrollbar = type;
      if ( nsp_register_type(nsp_type_gtkscrollbar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkscrollbar, GTK_TYPE_SCROLLBAR);
      return ( mode == T_BASE ) ? type : new_type_gtkscrollbar(mode);
    }
  else 
    {
      type->id = nsp_type_gtkscrollbar_id;
      return type;
    }
}

/*
 * initialize NspGtkScrollbar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkscrollbar(NspGtkScrollbar *Obj,NspTypeGtkScrollbar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkScrollbar 
 */

NspGtkScrollbar *new_gtkscrollbar() 
{
  NspGtkScrollbar *loc;
  /* type must exists */
  nsp_type_gtkscrollbar = new_type_gtkscrollbar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkScrollbar)))== NULLGTKSCROLLBAR) return loc;
  /* initialize object */
  if ( init_gtkscrollbar(loc,nsp_type_gtkscrollbar) == FAIL) return NULLGTKSCROLLBAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkScrollbar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkscrollbar_type_name[]="GtkScrollbar";
static char gtkscrollbar_short_type_name[]="GtkScrollbar";

static char *nsp_gtkscrollbar_type_as_string(void)
{
  return(gtkscrollbar_type_name);
}

static char *nsp_gtkscrollbar_type_short_string(NspObject *v)
{
  return(gtkscrollbar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkScrollbar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkScrollbar   *nsp_gtkscrollbar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkscrollbar_id)  == TRUE  ) return ((NspGtkScrollbar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkscrollbar));
  return NULL;
}

int IsGtkScrollbarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkscrollbar_id);
}

int IsGtkScrollbar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkscrollbar_id);
}

NspGtkScrollbar  *GetGtkScrollbarCopy(Stack stack, int i)
{
  if (  GetGtkScrollbar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkScrollbar  *GetGtkScrollbar(Stack stack, int i)
{
  NspGtkScrollbar *M;
  if (( M = nsp_gtkscrollbar_object(NthObj(i))) == NULLGTKSCROLLBAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkScrollbar *gtkscrollbar_copy(NspGtkScrollbar *self)
{
  /* return gtkrange_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscrollbar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscrollbar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkScrollbar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_scrollbar_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj,new_opts, t_end};
  nsp_option opts[] = {
	{"adjustment",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;
  GtkAdjustment *adjustment = NULL;
  NspGObject *nsp_adjustment = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation, opts, &nsp_adjustment) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
  if ( nsp_adjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_adjustment))
      adjustment = GTK_ADJUSTMENT(nsp_adjustment->obj);
    else if (! IsNone((NspObject *)nsp_adjustment)) {
         Scierror( "Error: adjustment should be a GtkAdjustment or None\n");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_scrollbar_new(orientation,adjustment))== NULL) return RET_BUG;

  nsp_type_gtkscrollbar = new_type_gtkscrollbar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkscrollbar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkscrollbar_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkscrollbar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkScrolledWindow ----------- */


#define  NspGtkScrolledWindow_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkscrolledwindow.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkScrolledWindow inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkscrolledwindow_id=0;
NspTypeGtkScrolledWindow *nsp_type_gtkscrolledwindow=NULL;

/*
 * Type object for NspGtkScrolledWindow 
 * all the instance of NspTypeGtkScrolledWindow share the same id. 
 * nsp_type_gtkscrolledwindow: is an instance of NspTypeGtkScrolledWindow 
 *    used for objects of NspGtkScrolledWindow type (i.e built with new_gtkscrolledwindow) 
 * other instances are used for derived classes 
 */
NspTypeGtkScrolledWindow *new_type_gtkscrolledwindow(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkScrolledWindow *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkscrolledwindow != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkscrolledwindow;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkscrolledwindow_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkscrolledwindow_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkscrolledwindow;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkscrolledwindow */ 

  top->s_type =  (s_type_func *) nsp_gtkscrolledwindow_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkscrolledwindow_type_short_string;
  /* top->create = (create_func*) int_gtkscrolledwindow_create;*/

  /* specific methods for gtkscrolledwindow */

  type->init = (init_func *) init_gtkscrolledwindow;

  /* 
   * NspGtkScrolledWindow interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkscrolledwindow_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkScrolledWindow called nsp_type_gtkscrolledwindow
       */
      type->id =  nsp_type_gtkscrolledwindow_id = nsp_new_type_id();
      nsp_type_gtkscrolledwindow = type;
      if ( nsp_register_type(nsp_type_gtkscrolledwindow) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkscrolledwindow, GTK_TYPE_SCROLLED_WINDOW);
      return ( mode == T_BASE ) ? type : new_type_gtkscrolledwindow(mode);
    }
  else 
    {
      type->id = nsp_type_gtkscrolledwindow_id;
      return type;
    }
}

/*
 * initialize NspGtkScrolledWindow instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkscrolledwindow(NspGtkScrolledWindow *Obj,NspTypeGtkScrolledWindow *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkScrolledWindow 
 */

NspGtkScrolledWindow *new_gtkscrolledwindow() 
{
  NspGtkScrolledWindow *loc;
  /* type must exists */
  nsp_type_gtkscrolledwindow = new_type_gtkscrolledwindow(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkScrolledWindow)))== NULLGTKSCROLLEDWINDOW) return loc;
  /* initialize object */
  if ( init_gtkscrolledwindow(loc,nsp_type_gtkscrolledwindow) == FAIL) return NULLGTKSCROLLEDWINDOW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkScrolledWindow 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkscrolledwindow_type_name[]="GtkScrolledWindow";
static char gtkscrolledwindow_short_type_name[]="GtkScrolledWindow";

static char *nsp_gtkscrolledwindow_type_as_string(void)
{
  return(gtkscrolledwindow_type_name);
}

static char *nsp_gtkscrolledwindow_type_short_string(NspObject *v)
{
  return(gtkscrolledwindow_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkScrolledWindow objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkScrolledWindow   *nsp_gtkscrolledwindow_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkscrolledwindow_id)  == TRUE  ) return ((NspGtkScrolledWindow *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkscrolledwindow));
  return NULL;
}

int IsGtkScrolledWindowObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkscrolledwindow_id);
}

int IsGtkScrolledWindow(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkscrolledwindow_id);
}

NspGtkScrolledWindow  *GetGtkScrolledWindowCopy(Stack stack, int i)
{
  if (  GetGtkScrolledWindow(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkScrolledWindow  *GetGtkScrolledWindow(Stack stack, int i)
{
  NspGtkScrolledWindow *M;
  if (( M = nsp_gtkscrolledwindow_object(NthObj(i))) == NULLGTKSCROLLEDWINDOW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkScrolledWindow *gtkscrolledwindow_copy(NspGtkScrolledWindow *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscrolledwindow);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkscrolledwindow);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkScrolledWindow
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_scrolled_window_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"hadjustment",obj,NULLOBJ,-1},
	{"vadjustment",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkAdjustment *hadjustment = NULL, *vadjustment = NULL;
  NspGObject *nsp_hadjustment = NULL, *nsp_vadjustment = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_hadjustment, &nsp_vadjustment) == FAIL) return RET_BUG;
  if ( nsp_hadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_hadjustment))
      hadjustment = GTK_ADJUSTMENT(nsp_hadjustment->obj);
    else if (! IsNone((NspObject *)nsp_hadjustment)) {
         Scierror( "Error: hadjustment should be a GtkAdjustment or None\n");
         return RET_BUG;
    }
  }
  if ( nsp_vadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_vadjustment))
      vadjustment = GTK_ADJUSTMENT(nsp_vadjustment->obj);
    else if (! IsNone((NspObject *)nsp_vadjustment)) {
         Scierror( "Error: vadjustment should be a GtkAdjustment or None\n");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_scrolled_window_new(hadjustment,vadjustment))== NULL) return RET_BUG;

  nsp_type_gtkscrolledwindow = new_type_gtkscrolledwindow(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkscrolledwindow);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scrolled_window_set_hadjustment(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *hadjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &hadjustment) == FAIL) return RET_BUG;
    gtk_scrolled_window_set_hadjustment(GTK_SCROLLED_WINDOW(self->obj),GTK_ADJUSTMENT(hadjustment->obj));
  return 0;
}

static int _wrap_gtk_scrolled_window_set_vadjustment(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *vadjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &vadjustment) == FAIL) return RET_BUG;
    gtk_scrolled_window_set_vadjustment(GTK_SCROLLED_WINDOW(self->obj),GTK_ADJUSTMENT(vadjustment->obj));
  return 0;
}

static int _wrap_gtk_scrolled_window_get_hadjustment(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAdjustment *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_scrolled_window_get_hadjustment(GTK_SCROLLED_WINDOW(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scrolled_window_get_vadjustment(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAdjustment *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scrolled_window_get_hscrollbar(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_scrolled_window_get_hscrollbar(GTK_SCROLLED_WINDOW(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scrolled_window_get_vscrollbar(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_scrolled_window_get_vscrollbar(GTK_SCROLLED_WINDOW(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_scrolled_window_set_policy(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkPolicyType hscrollbar_policy, vscrollbar_policy;
  NspObject *nsp_hscrollbar_policy = NULL, *nsp_vscrollbar_policy = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_hscrollbar_policy, &nsp_vscrollbar_policy) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POLICY_TYPE, nsp_hscrollbar_policy, &hscrollbar_policy)== FAIL)
      return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_POLICY_TYPE, nsp_vscrollbar_policy, &vscrollbar_policy)== FAIL)
      return RET_BUG;
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(self->obj),hscrollbar_policy,vscrollbar_policy);
  return 0;
}

static int _wrap_gtk_scrolled_window_set_placement(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkCornerType window_placement;
  NspObject *nsp_window_placement = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_window_placement) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_CORNER_TYPE, nsp_window_placement, &window_placement)== FAIL)
      return RET_BUG;
    gtk_scrolled_window_set_placement(GTK_SCROLLED_WINDOW(self->obj),window_placement);
  return 0;
}

static int _wrap_gtk_scrolled_window_unset_placement(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_scrolled_window_unset_placement(GTK_SCROLLED_WINDOW(self->obj));
  return 0;
}

static int _wrap_gtk_scrolled_window_get_placement(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_scrolled_window_get_placement(GTK_SCROLLED_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scrolled_window_set_shadow_type(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkShadowType type;
  NspObject *nsp_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
    gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(self->obj),type);
  return 0;
}

static int _wrap_gtk_scrolled_window_get_shadow_type(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_scrolled_window_get_shadow_type(GTK_SCROLLED_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scrolled_window_get_min_content_width(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_scrolled_window_get_min_content_width(GTK_SCROLLED_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scrolled_window_set_min_content_width(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int width;
  if ( GetArgs(stack,rhs,opt,T,&width) == FAIL) return RET_BUG;
    gtk_scrolled_window_set_min_content_width(GTK_SCROLLED_WINDOW(self->obj),width);
  return 0;
}

static int _wrap_gtk_scrolled_window_get_min_content_height(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_scrolled_window_get_min_content_height(GTK_SCROLLED_WINDOW(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_scrolled_window_set_min_content_height(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int height;
  if ( GetArgs(stack,rhs,opt,T,&height) == FAIL) return RET_BUG;
    gtk_scrolled_window_set_min_content_height(GTK_SCROLLED_WINDOW(self->obj),height);
  return 0;
}

#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_scrolled_window_set_kinetic_scrolling(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int kinetic_scrolling;
  if ( GetArgs(stack,rhs,opt,T,&kinetic_scrolling) == FAIL) return RET_BUG;
    gtk_scrolled_window_set_kinetic_scrolling(GTK_SCROLLED_WINDOW(self->obj),kinetic_scrolling);
  return 0;
}

#else
int _wrap_gtk_scrolled_window_set_kinetic_scrolling(Stack stack, int rhs, int opt, int lhs) /* set_kinetic_scrolling */
{
  Scierror("Error: function gtk_scrolled_window_set_kinetic_scrolling not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_scrolled_window_get_kinetic_scrolling(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_scrolled_window_get_kinetic_scrolling(GTK_SCROLLED_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_scrolled_window_get_kinetic_scrolling(Stack stack, int rhs, int opt, int lhs) /* get_kinetic_scrolling */
{
  Scierror("Error: function gtk_scrolled_window_get_kinetic_scrolling not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_scrolled_window_set_capture_button_press(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int capture_button_press;
  if ( GetArgs(stack,rhs,opt,T,&capture_button_press) == FAIL) return RET_BUG;
    gtk_scrolled_window_set_capture_button_press(GTK_SCROLLED_WINDOW(self->obj),capture_button_press);
  return 0;
}

#else
int _wrap_gtk_scrolled_window_set_capture_button_press(Stack stack, int rhs, int opt, int lhs) /* set_capture_button_press */
{
  Scierror("Error: function gtk_scrolled_window_set_capture_button_press not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_scrolled_window_get_capture_button_press(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_scrolled_window_get_capture_button_press(GTK_SCROLLED_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_scrolled_window_get_capture_button_press(Stack stack, int rhs, int opt, int lhs) /* get_capture_button_press */
{
  Scierror("Error: function gtk_scrolled_window_get_capture_button_press not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_scrolled_window_set_overlay_scrolling(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int overlay_scrolling;
  if ( GetArgs(stack,rhs,opt,T,&overlay_scrolling) == FAIL) return RET_BUG;
    gtk_scrolled_window_set_overlay_scrolling(GTK_SCROLLED_WINDOW(self->obj),overlay_scrolling);
  return 0;
}

#else
int _wrap_gtk_scrolled_window_set_overlay_scrolling(Stack stack, int rhs, int opt, int lhs) /* set_overlay_scrolling */
{
  Scierror("Error: function gtk_scrolled_window_set_overlay_scrolling not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_scrolled_window_get_overlay_scrolling(NspGtkScrolledWindow *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_scrolled_window_get_overlay_scrolling(GTK_SCROLLED_WINDOW(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_scrolled_window_get_overlay_scrolling(Stack stack, int rhs, int opt, int lhs) /* get_overlay_scrolling */
{
  Scierror("Error: function gtk_scrolled_window_get_overlay_scrolling not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkscrolledwindow_methods[] = {
  {"set_hadjustment",(nsp_method *) _wrap_gtk_scrolled_window_set_hadjustment},
  {"set_vadjustment",(nsp_method *) _wrap_gtk_scrolled_window_set_vadjustment},
  {"get_hadjustment",(nsp_method *) _wrap_gtk_scrolled_window_get_hadjustment},
  {"get_vadjustment",(nsp_method *) _wrap_gtk_scrolled_window_get_vadjustment},
  {"get_hscrollbar",(nsp_method *) _wrap_gtk_scrolled_window_get_hscrollbar},
  {"get_vscrollbar",(nsp_method *) _wrap_gtk_scrolled_window_get_vscrollbar},
  {"set_policy",(nsp_method *) _wrap_gtk_scrolled_window_set_policy},
  {"set_placement",(nsp_method *) _wrap_gtk_scrolled_window_set_placement},
  {"unset_placement",(nsp_method *) _wrap_gtk_scrolled_window_unset_placement},
  {"get_placement",(nsp_method *) _wrap_gtk_scrolled_window_get_placement},
  {"set_shadow_type",(nsp_method *) _wrap_gtk_scrolled_window_set_shadow_type},
  {"get_shadow_type",(nsp_method *) _wrap_gtk_scrolled_window_get_shadow_type},
  {"get_min_content_width",(nsp_method *) _wrap_gtk_scrolled_window_get_min_content_width},
  {"set_min_content_width",(nsp_method *) _wrap_gtk_scrolled_window_set_min_content_width},
  {"get_min_content_height",(nsp_method *) _wrap_gtk_scrolled_window_get_min_content_height},
  {"set_min_content_height",(nsp_method *) _wrap_gtk_scrolled_window_set_min_content_height},
  {"set_kinetic_scrolling",(nsp_method *) _wrap_gtk_scrolled_window_set_kinetic_scrolling},
  {"get_kinetic_scrolling",(nsp_method *) _wrap_gtk_scrolled_window_get_kinetic_scrolling},
  {"set_capture_button_press",(nsp_method *) _wrap_gtk_scrolled_window_set_capture_button_press},
  {"get_capture_button_press",(nsp_method *) _wrap_gtk_scrolled_window_get_capture_button_press},
  {"set_overlay_scrolling",(nsp_method *) _wrap_gtk_scrolled_window_set_overlay_scrolling},
  {"get_overlay_scrolling",(nsp_method *) _wrap_gtk_scrolled_window_get_overlay_scrolling},
  { NULL, NULL}
};

static NspMethods *gtkscrolledwindow_get_methods(void) { return gtkscrolledwindow_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkscrolledwindow_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkPrintOperation ----------- */


#define  NspGtkPrintOperation_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkprintoperation.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkPrintOperation inherits from GObject 
 */

int nsp_type_gtkprintoperation_id=0;
NspTypeGtkPrintOperation *nsp_type_gtkprintoperation=NULL;

/*
 * Type object for NspGtkPrintOperation 
 * all the instance of NspTypeGtkPrintOperation share the same id. 
 * nsp_type_gtkprintoperation: is an instance of NspTypeGtkPrintOperation 
 *    used for objects of NspGtkPrintOperation type (i.e built with new_gtkprintoperation) 
 * other instances are used for derived classes 
 */
NspTypeGtkPrintOperation *new_type_gtkprintoperation(type_mode mode)
{
  NspTypeGtkPrintOperation *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkprintoperation != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkprintoperation;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkprintoperation_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkprintoperation_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkprintoperation;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkprintoperation */ 

  top->s_type =  (s_type_func *) nsp_gtkprintoperation_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkprintoperation_type_short_string;
  /* top->create = (create_func*) int_gtkprintoperation_create;*/

  /* specific methods for gtkprintoperation */

  type->init = (init_func *) init_gtkprintoperation;

  /* 
   * NspGtkPrintOperation interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkprintoperation_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkPrintOperation called nsp_type_gtkprintoperation
       */
      type->id =  nsp_type_gtkprintoperation_id = nsp_new_type_id();
      nsp_type_gtkprintoperation = type;
      if ( nsp_register_type(nsp_type_gtkprintoperation) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkprintoperation, GTK_TYPE_PRINT_OPERATION);
      return ( mode == T_BASE ) ? type : new_type_gtkprintoperation(mode);
    }
  else 
    {
      type->id = nsp_type_gtkprintoperation_id;
      return type;
    }
}

/*
 * initialize NspGtkPrintOperation instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkprintoperation(NspGtkPrintOperation *Obj,NspTypeGtkPrintOperation *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkPrintOperation 
 */

NspGtkPrintOperation *new_gtkprintoperation() 
{
  NspGtkPrintOperation *loc;
  /* type must exists */
  nsp_type_gtkprintoperation = new_type_gtkprintoperation(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkPrintOperation)))== NULLGTKPRINTOPERATION) return loc;
  /* initialize object */
  if ( init_gtkprintoperation(loc,nsp_type_gtkprintoperation) == FAIL) return NULLGTKPRINTOPERATION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkPrintOperation 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkprintoperation_type_name[]="GtkPrintOperation";
static char gtkprintoperation_short_type_name[]="GtkPrintOperation";

static char *nsp_gtkprintoperation_type_as_string(void)
{
  return(gtkprintoperation_type_name);
}

static char *nsp_gtkprintoperation_type_short_string(NspObject *v)
{
  return(gtkprintoperation_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkPrintOperation objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkPrintOperation   *nsp_gtkprintoperation_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkprintoperation_id)  == TRUE  ) return ((NspGtkPrintOperation *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkprintoperation));
  return NULL;
}

int IsGtkPrintOperationObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkprintoperation_id);
}

int IsGtkPrintOperation(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkprintoperation_id);
}

NspGtkPrintOperation  *GetGtkPrintOperationCopy(Stack stack, int i)
{
  if (  GetGtkPrintOperation(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkPrintOperation  *GetGtkPrintOperation(Stack stack, int i)
{
  NspGtkPrintOperation *M;
  if (( M = nsp_gtkprintoperation_object(NthObj(i))) == NULLGTKPRINTOPERATION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkPrintOperation *gtkprintoperation_copy(NspGtkPrintOperation *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprintoperation);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprintoperation);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkPrintOperation
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_print_operation_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_print_operation_new())== NULL) return RET_BUG;

  nsp_type_gtkprintoperation = new_type_gtkprintoperation(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkprintoperation);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_print_operation_set_job_name(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *job_name;
  if ( GetArgs(stack,rhs,opt,T,&job_name) == FAIL) return RET_BUG;
    gtk_print_operation_set_job_name(GTK_PRINT_OPERATION(self->obj),job_name);
  return 0;
}

static int _wrap_gtk_print_operation_set_n_pages(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int n_pages;
  if ( GetArgs(stack,rhs,opt,T,&n_pages) == FAIL) return RET_BUG;
    gtk_print_operation_set_n_pages(GTK_PRINT_OPERATION(self->obj),n_pages);
  return 0;
}

static int _wrap_gtk_print_operation_set_current_page(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int current_page;
  if ( GetArgs(stack,rhs,opt,T,&current_page) == FAIL) return RET_BUG;
    gtk_print_operation_set_current_page(GTK_PRINT_OPERATION(self->obj),current_page);
  return 0;
}

static int _wrap_gtk_print_operation_set_use_full_page(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int full_page;
  if ( GetArgs(stack,rhs,opt,T,&full_page) == FAIL) return RET_BUG;
    gtk_print_operation_set_use_full_page(GTK_PRINT_OPERATION(self->obj),full_page);
  return 0;
}

static int _wrap_gtk_print_operation_set_unit(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkUnit unit;
  NspObject *nsp_unit = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_unit) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_UNIT, nsp_unit, &unit)== FAIL)
      return RET_BUG;
    gtk_print_operation_set_unit(GTK_PRINT_OPERATION(self->obj),unit);
  return 0;
}

static int _wrap_gtk_print_operation_set_export_filename(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *filename;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    gtk_print_operation_set_export_filename(GTK_PRINT_OPERATION(self->obj),filename);
  return 0;
}

static int _wrap_gtk_print_operation_set_track_print_status(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int track_status;
  if ( GetArgs(stack,rhs,opt,T,&track_status) == FAIL) return RET_BUG;
    gtk_print_operation_set_track_print_status(GTK_PRINT_OPERATION(self->obj),track_status);
  return 0;
}

static int _wrap_gtk_print_operation_set_show_progress(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_progress;
  if ( GetArgs(stack,rhs,opt,T,&show_progress) == FAIL) return RET_BUG;
    gtk_print_operation_set_show_progress(GTK_PRINT_OPERATION(self->obj),show_progress);
  return 0;
}

static int _wrap_gtk_print_operation_set_allow_async(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int allow_async;
  if ( GetArgs(stack,rhs,opt,T,&allow_async) == FAIL) return RET_BUG;
    gtk_print_operation_set_allow_async(GTK_PRINT_OPERATION(self->obj),allow_async);
  return 0;
}

static int _wrap_gtk_print_operation_set_custom_tab_label(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *label;
  if ( GetArgs(stack,rhs,opt,T,&label) == FAIL) return RET_BUG;
    gtk_print_operation_set_custom_tab_label(GTK_PRINT_OPERATION(self->obj),label);
  return 0;
}

static int _wrap_gtk_print_operation_run(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj_check, t_end};
  GtkPrintOperationAction action;
  NspObject *nsp_action = NULL;
  NspGObject *parent;
  GError *error = NULL;
  gint ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_action, &nsp_type_gtkwindow, &parent) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_PRINT_OPERATION_ACTION, nsp_action, &action)== FAIL)
      return RET_BUG;
    ret =gtk_print_operation_run(GTK_PRINT_OPERATION(self->obj),action,GTK_WINDOW(parent->obj),&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_operation_get_error(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  GError *error = NULL;
  CheckRhs(0,0);
    gtk_print_operation_get_error(GTK_PRINT_OPERATION(self->obj),&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  return 0;
}

static int _wrap_gtk_print_operation_get_status(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_print_operation_get_status(GTK_PRINT_OPERATION(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_operation_get_status_string(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_print_operation_get_status_string(GTK_PRINT_OPERATION(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_operation_is_finished(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_print_operation_is_finished(GTK_PRINT_OPERATION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_operation_cancel(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_print_operation_cancel(GTK_PRINT_OPERATION(self->obj));
  return 0;
}

static int _wrap_gtk_print_operation_draw_page_finish(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_print_operation_draw_page_finish(GTK_PRINT_OPERATION(self->obj));
  return 0;
}

static int _wrap_gtk_print_operation_set_defer_drawing(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_print_operation_set_defer_drawing(GTK_PRINT_OPERATION(self->obj));
  return 0;
}

static int _wrap_gtk_print_operation_set_support_selection(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int support_selection;
  if ( GetArgs(stack,rhs,opt,T,&support_selection) == FAIL) return RET_BUG;
    gtk_print_operation_set_support_selection(GTK_PRINT_OPERATION(self->obj),support_selection);
  return 0;
}

static int _wrap_gtk_print_operation_get_support_selection(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_print_operation_get_support_selection(GTK_PRINT_OPERATION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_operation_set_has_selection(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int has_selection;
  if ( GetArgs(stack,rhs,opt,T,&has_selection) == FAIL) return RET_BUG;
    gtk_print_operation_set_has_selection(GTK_PRINT_OPERATION(self->obj),has_selection);
  return 0;
}

static int _wrap_gtk_print_operation_get_has_selection(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_print_operation_get_has_selection(GTK_PRINT_OPERATION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_operation_set_embed_page_setup(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int embed;
  if ( GetArgs(stack,rhs,opt,T,&embed) == FAIL) return RET_BUG;
    gtk_print_operation_set_embed_page_setup(GTK_PRINT_OPERATION(self->obj),embed);
  return 0;
}

static int _wrap_gtk_print_operation_get_embed_page_setup(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_print_operation_get_embed_page_setup(GTK_PRINT_OPERATION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_operation_get_n_pages_to_print(NspGtkPrintOperation *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_print_operation_get_n_pages_to_print(GTK_PRINT_OPERATION(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkprintoperation_methods[] = {
  {"set_job_name",(nsp_method *) _wrap_gtk_print_operation_set_job_name},
  {"set_n_pages",(nsp_method *) _wrap_gtk_print_operation_set_n_pages},
  {"set_current_page",(nsp_method *) _wrap_gtk_print_operation_set_current_page},
  {"set_use_full_page",(nsp_method *) _wrap_gtk_print_operation_set_use_full_page},
  {"set_unit",(nsp_method *) _wrap_gtk_print_operation_set_unit},
  {"set_export_filename",(nsp_method *) _wrap_gtk_print_operation_set_export_filename},
  {"set_track_print_status",(nsp_method *) _wrap_gtk_print_operation_set_track_print_status},
  {"set_show_progress",(nsp_method *) _wrap_gtk_print_operation_set_show_progress},
  {"set_allow_async",(nsp_method *) _wrap_gtk_print_operation_set_allow_async},
  {"set_custom_tab_label",(nsp_method *) _wrap_gtk_print_operation_set_custom_tab_label},
  {"run",(nsp_method *) _wrap_gtk_print_operation_run},
  {"get_error",(nsp_method *) _wrap_gtk_print_operation_get_error},
  {"get_status",(nsp_method *) _wrap_gtk_print_operation_get_status},
  {"get_status_string",(nsp_method *) _wrap_gtk_print_operation_get_status_string},
  {"is_finished",(nsp_method *) _wrap_gtk_print_operation_is_finished},
  {"cancel",(nsp_method *) _wrap_gtk_print_operation_cancel},
  {"draw_page_finish",(nsp_method *) _wrap_gtk_print_operation_draw_page_finish},
  {"set_defer_drawing",(nsp_method *) _wrap_gtk_print_operation_set_defer_drawing},
  {"set_support_selection",(nsp_method *) _wrap_gtk_print_operation_set_support_selection},
  {"get_support_selection",(nsp_method *) _wrap_gtk_print_operation_get_support_selection},
  {"set_has_selection",(nsp_method *) _wrap_gtk_print_operation_set_has_selection},
  {"get_has_selection",(nsp_method *) _wrap_gtk_print_operation_get_has_selection},
  {"set_embed_page_setup",(nsp_method *) _wrap_gtk_print_operation_set_embed_page_setup},
  {"get_embed_page_setup",(nsp_method *) _wrap_gtk_print_operation_get_embed_page_setup},
  {"get_n_pages_to_print",(nsp_method *) _wrap_gtk_print_operation_get_n_pages_to_print},
  { NULL, NULL}
};

static NspMethods *gtkprintoperation_get_methods(void) { return gtkprintoperation_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkprintoperation_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkPrintOperationPreview ----------- */


#define  NspGtkPrintOperationPreview_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkprintoperationpreview.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkPrintOperationPreview inherits from GObject 
 */

int nsp_type_gtkprintoperationpreview_id=0;
NspTypeGtkPrintOperationPreview *nsp_type_gtkprintoperationpreview=NULL;

/*
 * Type object for NspGtkPrintOperationPreview 
 * all the instance of NspTypeGtkPrintOperationPreview share the same id. 
 * nsp_type_gtkprintoperationpreview: is an instance of NspTypeGtkPrintOperationPreview 
 *    used for objects of NspGtkPrintOperationPreview type (i.e built with new_gtkprintoperationpreview) 
 * other instances are used for derived classes 
 */
NspTypeGtkPrintOperationPreview *new_type_gtkprintoperationpreview(type_mode mode)
{
  NspTypeGtkPrintOperationPreview *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkprintoperationpreview != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkprintoperationpreview;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkprintoperationpreview_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkprintoperationpreview_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkprintoperationpreview;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkprintoperationpreview */ 

  top->s_type =  (s_type_func *) nsp_gtkprintoperationpreview_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkprintoperationpreview_type_short_string;
  /* top->create = (create_func*) int_gtkprintoperationpreview_create;*/

  /* specific methods for gtkprintoperationpreview */

  type->init = (init_func *) init_gtkprintoperationpreview;

  /* 
   * NspGtkPrintOperationPreview interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkprintoperationpreview_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkPrintOperationPreview called nsp_type_gtkprintoperationpreview
       */
      type->id =  nsp_type_gtkprintoperationpreview_id = nsp_new_type_id();
      nsp_type_gtkprintoperationpreview = type;
      if ( nsp_register_type(nsp_type_gtkprintoperationpreview) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkprintoperationpreview, GTK_TYPE_PRINT_OPERATION_PREVIEW);
      return ( mode == T_BASE ) ? type : new_type_gtkprintoperationpreview(mode);
    }
  else 
    {
      type->id = nsp_type_gtkprintoperationpreview_id;
      return type;
    }
}

/*
 * initialize NspGtkPrintOperationPreview instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkprintoperationpreview(NspGtkPrintOperationPreview *Obj,NspTypeGtkPrintOperationPreview *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkPrintOperationPreview 
 */

NspGtkPrintOperationPreview *new_gtkprintoperationpreview() 
{
  NspGtkPrintOperationPreview *loc;
  /* type must exists */
  nsp_type_gtkprintoperationpreview = new_type_gtkprintoperationpreview(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkPrintOperationPreview)))== NULLGTKPRINTOPERATIONPREVIEW) return loc;
  /* initialize object */
  if ( init_gtkprintoperationpreview(loc,nsp_type_gtkprintoperationpreview) == FAIL) return NULLGTKPRINTOPERATIONPREVIEW;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkPrintOperationPreview 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkprintoperationpreview_type_name[]="GtkPrintOperationPreview";
static char gtkprintoperationpreview_short_type_name[]="GtkPrintOperationPreview";

static char *nsp_gtkprintoperationpreview_type_as_string(void)
{
  return(gtkprintoperationpreview_type_name);
}

static char *nsp_gtkprintoperationpreview_type_short_string(NspObject *v)
{
  return(gtkprintoperationpreview_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkPrintOperationPreview objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkPrintOperationPreview   *nsp_gtkprintoperationpreview_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkprintoperationpreview_id)  == TRUE  ) return ((NspGtkPrintOperationPreview *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkprintoperationpreview));
  return NULL;
}

int IsGtkPrintOperationPreviewObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkprintoperationpreview_id);
}

int IsGtkPrintOperationPreview(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkprintoperationpreview_id);
}

NspGtkPrintOperationPreview  *GetGtkPrintOperationPreviewCopy(Stack stack, int i)
{
  if (  GetGtkPrintOperationPreview(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkPrintOperationPreview  *GetGtkPrintOperationPreview(Stack stack, int i)
{
  NspGtkPrintOperationPreview *M;
  if (( M = nsp_gtkprintoperationpreview_object(NthObj(i))) == NULLGTKPRINTOPERATIONPREVIEW)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkPrintOperationPreview *gtkprintoperationpreview_copy(NspGtkPrintOperationPreview *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprintoperationpreview);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprintoperationpreview);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkPrintOperationPreview
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_print_operation_preview_render_page(NspGtkPrintOperationPreview *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int page_nr;
  if ( GetArgs(stack,rhs,opt,T,&page_nr) == FAIL) return RET_BUG;
    gtk_print_operation_preview_render_page(GTK_PRINT_OPERATION_PREVIEW(self->obj),page_nr);
  return 0;
}

static int _wrap_gtk_print_operation_preview_end_preview(NspGtkPrintOperationPreview *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_print_operation_preview_end_preview(GTK_PRINT_OPERATION_PREVIEW(self->obj));
  return 0;
}

static int _wrap_gtk_print_operation_preview_is_selected(NspGtkPrintOperationPreview *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int page_nr, ret;
  if ( GetArgs(stack,rhs,opt,T,&page_nr) == FAIL) return RET_BUG;
    ret =gtk_print_operation_preview_is_selected(GTK_PRINT_OPERATION_PREVIEW(self->obj),page_nr);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkprintoperationpreview_methods[] = {
  {"render_page",(nsp_method *) _wrap_gtk_print_operation_preview_render_page},
  {"end_preview",(nsp_method *) _wrap_gtk_print_operation_preview_end_preview},
  {"is_selected",(nsp_method *) _wrap_gtk_print_operation_preview_is_selected},
  { NULL, NULL}
};

static NspMethods *gtkprintoperationpreview_get_methods(void) { return gtkprintoperationpreview_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkprintoperationpreview_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkPrintContext ----------- */


#define  NspGtkPrintContext_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkprintcontext.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkPrintContext inherits from GObject 
 */

int nsp_type_gtkprintcontext_id=0;
NspTypeGtkPrintContext *nsp_type_gtkprintcontext=NULL;

/*
 * Type object for NspGtkPrintContext 
 * all the instance of NspTypeGtkPrintContext share the same id. 
 * nsp_type_gtkprintcontext: is an instance of NspTypeGtkPrintContext 
 *    used for objects of NspGtkPrintContext type (i.e built with new_gtkprintcontext) 
 * other instances are used for derived classes 
 */
NspTypeGtkPrintContext *new_type_gtkprintcontext(type_mode mode)
{
  NspTypeGtkPrintContext *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkprintcontext != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkprintcontext;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkprintcontext_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkprintcontext_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkprintcontext;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkprintcontext */ 

  top->s_type =  (s_type_func *) nsp_gtkprintcontext_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkprintcontext_type_short_string;
  /* top->create = (create_func*) int_gtkprintcontext_create;*/

  /* specific methods for gtkprintcontext */

  type->init = (init_func *) init_gtkprintcontext;

  /* 
   * NspGtkPrintContext interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkprintcontext_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkPrintContext called nsp_type_gtkprintcontext
       */
      type->id =  nsp_type_gtkprintcontext_id = nsp_new_type_id();
      nsp_type_gtkprintcontext = type;
      if ( nsp_register_type(nsp_type_gtkprintcontext) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkprintcontext, GTK_TYPE_PRINT_CONTEXT);
      return ( mode == T_BASE ) ? type : new_type_gtkprintcontext(mode);
    }
  else 
    {
      type->id = nsp_type_gtkprintcontext_id;
      return type;
    }
}

/*
 * initialize NspGtkPrintContext instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkprintcontext(NspGtkPrintContext *Obj,NspTypeGtkPrintContext *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkPrintContext 
 */

NspGtkPrintContext *new_gtkprintcontext() 
{
  NspGtkPrintContext *loc;
  /* type must exists */
  nsp_type_gtkprintcontext = new_type_gtkprintcontext(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkPrintContext)))== NULLGTKPRINTCONTEXT) return loc;
  /* initialize object */
  if ( init_gtkprintcontext(loc,nsp_type_gtkprintcontext) == FAIL) return NULLGTKPRINTCONTEXT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkPrintContext 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkprintcontext_type_name[]="GtkPrintContext";
static char gtkprintcontext_short_type_name[]="GtkPrintContext";

static char *nsp_gtkprintcontext_type_as_string(void)
{
  return(gtkprintcontext_type_name);
}

static char *nsp_gtkprintcontext_type_short_string(NspObject *v)
{
  return(gtkprintcontext_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkPrintContext objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkPrintContext   *nsp_gtkprintcontext_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkprintcontext_id)  == TRUE  ) return ((NspGtkPrintContext *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkprintcontext));
  return NULL;
}

int IsGtkPrintContextObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkprintcontext_id);
}

int IsGtkPrintContext(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkprintcontext_id);
}

NspGtkPrintContext  *GetGtkPrintContextCopy(Stack stack, int i)
{
  if (  GetGtkPrintContext(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkPrintContext  *GetGtkPrintContext(Stack stack, int i)
{
  NspGtkPrintContext *M;
  if (( M = nsp_gtkprintcontext_object(NthObj(i))) == NULLGTKPRINTCONTEXT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkPrintContext *gtkprintcontext_copy(NspGtkPrintContext *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprintcontext);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkprintcontext);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkPrintContext
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_print_context_get_cairo_context(NspGtkPrintContext *self,Stack stack,int rhs,int opt,int lhs)
{
  cairo_t *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_print_context_get_cairo_context(GTK_PRINT_CONTEXT(self->obj));
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,CAIRO_GOBJECT_TYPE_CONTEXT, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_cairo_t))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_print_context_get_width(NspGtkPrintContext *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_print_context_get_width(GTK_PRINT_CONTEXT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_context_get_height(NspGtkPrintContext *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_print_context_get_height(GTK_PRINT_CONTEXT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_context_get_dpi_x(NspGtkPrintContext *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_print_context_get_dpi_x(GTK_PRINT_CONTEXT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_context_get_dpi_y(NspGtkPrintContext *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_print_context_get_dpi_y(GTK_PRINT_CONTEXT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_context_get_hard_margins(NspGtkPrintContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,s_double,s_double,s_double, t_end};
  double top, bottom, left, right;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&top, &bottom, &left, &right) == FAIL) return RET_BUG;
    ret =gtk_print_context_get_hard_margins(GTK_PRINT_CONTEXT(self->obj),&top,&bottom,&left,&right);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_print_context_get_pango_fontmap(NspGtkPrintContext *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoFontMap *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_print_context_get_pango_fontmap(GTK_PRINT_CONTEXT(self->obj));
  nsp_type_pangofontmap = new_type_pangofontmap(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangofontmap))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_print_context_create_pango_context(NspGtkPrintContext *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoContext *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_print_context_create_pango_context(GTK_PRINT_CONTEXT(self->obj));
  nsp_type_pangocontext = new_type_pangocontext(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangocontext))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_print_context_create_pango_layout(NspGtkPrintContext *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoLayout *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_print_context_create_pango_layout(GTK_PRINT_CONTEXT(self->obj));
  nsp_type_pangolayout = new_type_pangolayout(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangolayout))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_print_context_set_cairo_context(NspGtkPrintContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_double,s_double, t_end};
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double dpi_x, dpi_y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_cr, &dpi_x, &dpi_y) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_print_context_set_cairo_context(GTK_PRINT_CONTEXT(self->obj),cr,dpi_x,dpi_y);
  return 0;
}

static NspMethods gtkprintcontext_methods[] = {
  {"get_cairo_context",(nsp_method *) _wrap_gtk_print_context_get_cairo_context},
  {"get_width",(nsp_method *) _wrap_gtk_print_context_get_width},
  {"get_height",(nsp_method *) _wrap_gtk_print_context_get_height},
  {"get_dpi_x",(nsp_method *) _wrap_gtk_print_context_get_dpi_x},
  {"get_dpi_y",(nsp_method *) _wrap_gtk_print_context_get_dpi_y},
  {"get_hard_margins",(nsp_method *) _wrap_gtk_print_context_get_hard_margins},
  {"get_pango_fontmap",(nsp_method *) _wrap_gtk_print_context_get_pango_fontmap},
  {"create_pango_context",(nsp_method *) _wrap_gtk_print_context_create_pango_context},
  {"create_pango_layout",(nsp_method *) _wrap_gtk_print_context_create_pango_layout},
  {"set_cairo_context",(nsp_method *) _wrap_gtk_print_context_set_cairo_context},
  { NULL, NULL}
};

static NspMethods *gtkprintcontext_get_methods(void) { return gtkprintcontext_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkprintcontext_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAdjustment ----------- */


#define  NspGtkAdjustment_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkadjustment.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAdjustment inherits from GObject 
 */

int nsp_type_gtkadjustment_id=0;
NspTypeGtkAdjustment *nsp_type_gtkadjustment=NULL;

/*
 * Type object for NspGtkAdjustment 
 * all the instance of NspTypeGtkAdjustment share the same id. 
 * nsp_type_gtkadjustment: is an instance of NspTypeGtkAdjustment 
 *    used for objects of NspGtkAdjustment type (i.e built with new_gtkadjustment) 
 * other instances are used for derived classes 
 */
NspTypeGtkAdjustment *new_type_gtkadjustment(type_mode mode)
{
  NspTypeGtkAdjustment *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkadjustment != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkadjustment;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkadjustment_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkadjustment_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkadjustment;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkadjustment */ 

  top->s_type =  (s_type_func *) nsp_gtkadjustment_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkadjustment_type_short_string;
  /* top->create = (create_func*) int_gtkadjustment_create;*/

  /* specific methods for gtkadjustment */

  type->init = (init_func *) init_gtkadjustment;

  /* 
   * NspGtkAdjustment interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkadjustment_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAdjustment called nsp_type_gtkadjustment
       */
      type->id =  nsp_type_gtkadjustment_id = nsp_new_type_id();
      nsp_type_gtkadjustment = type;
      if ( nsp_register_type(nsp_type_gtkadjustment) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkadjustment, GTK_TYPE_ADJUSTMENT);
      return ( mode == T_BASE ) ? type : new_type_gtkadjustment(mode);
    }
  else 
    {
      type->id = nsp_type_gtkadjustment_id;
      return type;
    }
}

/*
 * initialize NspGtkAdjustment instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkadjustment(NspGtkAdjustment *Obj,NspTypeGtkAdjustment *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAdjustment 
 */

NspGtkAdjustment *new_gtkadjustment() 
{
  NspGtkAdjustment *loc;
  /* type must exists */
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAdjustment)))== NULLGTKADJUSTMENT) return loc;
  /* initialize object */
  if ( init_gtkadjustment(loc,nsp_type_gtkadjustment) == FAIL) return NULLGTKADJUSTMENT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAdjustment 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkadjustment_type_name[]="GtkAdjustment";
static char gtkadjustment_short_type_name[]="GtkAdjustment";

static char *nsp_gtkadjustment_type_as_string(void)
{
  return(gtkadjustment_type_name);
}

static char *nsp_gtkadjustment_type_short_string(NspObject *v)
{
  return(gtkadjustment_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAdjustment objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAdjustment   *nsp_gtkadjustment_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkadjustment_id)  == TRUE  ) return ((NspGtkAdjustment *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkadjustment));
  return NULL;
}

int IsGtkAdjustmentObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkadjustment_id);
}

int IsGtkAdjustment(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkadjustment_id);
}

NspGtkAdjustment  *GetGtkAdjustmentCopy(Stack stack, int i)
{
  if (  GetGtkAdjustment(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAdjustment  *GetGtkAdjustment(Stack stack, int i)
{
  NspGtkAdjustment *M;
  if (( M = nsp_gtkadjustment_object(NthObj(i))) == NULLGTKADJUSTMENT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAdjustment *gtkadjustment_copy(NspGtkAdjustment *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkadjustment);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkadjustment);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAdjustment
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_adjustment_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"value",s_double,NULLOBJ,-1},
	{"lower",s_double,NULLOBJ,-1},
	{"upper",s_double,NULLOBJ,-1},
	{"step_incr",s_double,NULLOBJ,-1},
	{"page_incr",s_double,NULLOBJ,-1},
	{"page_size",s_double,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  double value = 0, lower = 0, upper = 0, step_incr = 0, page_incr = 0, page_size = 0;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &value, &lower, &upper, &step_incr, &page_incr, &page_size) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_adjustment_new(value,lower,upper,step_incr,page_incr,page_size))== NULL) return RET_BUG;

  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_adjustment_changed(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_adjustment_changed(GTK_ADJUSTMENT(self->obj));
  return 0;
}

static int _wrap_gtk_adjustment_value_changed(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_adjustment_value_changed(GTK_ADJUSTMENT(self->obj));
  return 0;
}

static int _wrap_gtk_adjustment_clamp_page(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,s_double, t_end};
  double lower, upper;
  if ( GetArgs(stack,rhs,opt,T,&lower, &upper) == FAIL) return RET_BUG;
    gtk_adjustment_clamp_page(GTK_ADJUSTMENT(self->obj),lower,upper);
  return 0;
}

static int _wrap_gtk_adjustment_get_value(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_adjustment_get_value(GTK_ADJUSTMENT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_adjustment_set_value(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double value;
  if ( GetArgs(stack,rhs,opt,T,&value) == FAIL) return RET_BUG;
    gtk_adjustment_set_value(GTK_ADJUSTMENT(self->obj),value);
  return 0;
}

static int _wrap_gtk_adjustment_get_lower(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_adjustment_get_lower(GTK_ADJUSTMENT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_adjustment_set_lower(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double lower;
  if ( GetArgs(stack,rhs,opt,T,&lower) == FAIL) return RET_BUG;
    gtk_adjustment_set_lower(GTK_ADJUSTMENT(self->obj),lower);
  return 0;
}

static int _wrap_gtk_adjustment_get_upper(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_adjustment_get_upper(GTK_ADJUSTMENT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_adjustment_set_upper(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double upper;
  if ( GetArgs(stack,rhs,opt,T,&upper) == FAIL) return RET_BUG;
    gtk_adjustment_set_upper(GTK_ADJUSTMENT(self->obj),upper);
  return 0;
}

static int _wrap_gtk_adjustment_get_step_increment(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_adjustment_get_step_increment(GTK_ADJUSTMENT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_adjustment_set_step_increment(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double step_increment;
  if ( GetArgs(stack,rhs,opt,T,&step_increment) == FAIL) return RET_BUG;
    gtk_adjustment_set_step_increment(GTK_ADJUSTMENT(self->obj),step_increment);
  return 0;
}

static int _wrap_gtk_adjustment_get_page_increment(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_adjustment_get_page_increment(GTK_ADJUSTMENT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_adjustment_set_page_increment(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double page_increment;
  if ( GetArgs(stack,rhs,opt,T,&page_increment) == FAIL) return RET_BUG;
    gtk_adjustment_set_page_increment(GTK_ADJUSTMENT(self->obj),page_increment);
  return 0;
}

static int _wrap_gtk_adjustment_get_page_size(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_adjustment_get_page_size(GTK_ADJUSTMENT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_adjustment_set_page_size(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double page_size;
  if ( GetArgs(stack,rhs,opt,T,&page_size) == FAIL) return RET_BUG;
    gtk_adjustment_set_page_size(GTK_ADJUSTMENT(self->obj),page_size);
  return 0;
}

static int _wrap_gtk_adjustment_configure(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,s_double,s_double,s_double,s_double,s_double, t_end};
  double value, lower, upper, step_increment, page_increment, page_size;
  if ( GetArgs(stack,rhs,opt,T,&value, &lower, &upper, &step_increment, &page_increment, &page_size) == FAIL) return RET_BUG;
    gtk_adjustment_configure(GTK_ADJUSTMENT(self->obj),value,lower,upper,step_increment,page_increment,page_size);
  return 0;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_adjustment_get_minimum_increment(NspGtkAdjustment *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_adjustment_get_minimum_increment(GTK_ADJUSTMENT(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_adjustment_get_minimum_increment(Stack stack, int rhs, int opt, int lhs) /* get_minimum_increment */
{
  Scierror("Error: function gtk_adjustment_get_minimum_increment not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkadjustment_methods[] = {
  {"changed",(nsp_method *) _wrap_gtk_adjustment_changed},
  {"value_changed",(nsp_method *) _wrap_gtk_adjustment_value_changed},
  {"clamp_page",(nsp_method *) _wrap_gtk_adjustment_clamp_page},
  {"get_value",(nsp_method *) _wrap_gtk_adjustment_get_value},
  {"set_value",(nsp_method *) _wrap_gtk_adjustment_set_value},
  {"get_lower",(nsp_method *) _wrap_gtk_adjustment_get_lower},
  {"set_lower",(nsp_method *) _wrap_gtk_adjustment_set_lower},
  {"get_upper",(nsp_method *) _wrap_gtk_adjustment_get_upper},
  {"set_upper",(nsp_method *) _wrap_gtk_adjustment_set_upper},
  {"get_step_increment",(nsp_method *) _wrap_gtk_adjustment_get_step_increment},
  {"set_step_increment",(nsp_method *) _wrap_gtk_adjustment_set_step_increment},
  {"get_page_increment",(nsp_method *) _wrap_gtk_adjustment_get_page_increment},
  {"set_page_increment",(nsp_method *) _wrap_gtk_adjustment_set_page_increment},
  {"get_page_size",(nsp_method *) _wrap_gtk_adjustment_get_page_size},
  {"set_page_size",(nsp_method *) _wrap_gtk_adjustment_set_page_size},
  {"configure",(nsp_method *) _wrap_gtk_adjustment_configure},
  {"get_minimum_increment",(nsp_method *) _wrap_gtk_adjustment_get_minimum_increment},
  { NULL, NULL}
};

static NspMethods *gtkadjustment_get_methods(void) { return gtkadjustment_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkadjustment_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCalendar ----------- */


#define  NspGtkCalendar_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcalendar.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCalendar inherits from GtkWidget 
 * and implements GtkBuildable
 */

int nsp_type_gtkcalendar_id=0;
NspTypeGtkCalendar *nsp_type_gtkcalendar=NULL;

/*
 * Type object for NspGtkCalendar 
 * all the instance of NspTypeGtkCalendar share the same id. 
 * nsp_type_gtkcalendar: is an instance of NspTypeGtkCalendar 
 *    used for objects of NspGtkCalendar type (i.e built with new_gtkcalendar) 
 * other instances are used for derived classes 
 */
NspTypeGtkCalendar *new_type_gtkcalendar(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkCalendar *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcalendar != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcalendar;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcalendar_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcalendar_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcalendar;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcalendar */ 

  top->s_type =  (s_type_func *) nsp_gtkcalendar_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcalendar_type_short_string;
  /* top->create = (create_func*) int_gtkcalendar_create;*/

  /* specific methods for gtkcalendar */

  type->init = (init_func *) init_gtkcalendar;

  /* 
   * NspGtkCalendar interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkcalendar_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCalendar called nsp_type_gtkcalendar
       */
      type->id =  nsp_type_gtkcalendar_id = nsp_new_type_id();
      nsp_type_gtkcalendar = type;
      if ( nsp_register_type(nsp_type_gtkcalendar) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcalendar, GTK_TYPE_CALENDAR);
      return ( mode == T_BASE ) ? type : new_type_gtkcalendar(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcalendar_id;
      return type;
    }
}

/*
 * initialize NspGtkCalendar instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcalendar(NspGtkCalendar *Obj,NspTypeGtkCalendar *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCalendar 
 */

NspGtkCalendar *new_gtkcalendar() 
{
  NspGtkCalendar *loc;
  /* type must exists */
  nsp_type_gtkcalendar = new_type_gtkcalendar(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCalendar)))== NULLGTKCALENDAR) return loc;
  /* initialize object */
  if ( init_gtkcalendar(loc,nsp_type_gtkcalendar) == FAIL) return NULLGTKCALENDAR;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCalendar 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcalendar_type_name[]="GtkCalendar";
static char gtkcalendar_short_type_name[]="GtkCalendar";

static char *nsp_gtkcalendar_type_as_string(void)
{
  return(gtkcalendar_type_name);
}

static char *nsp_gtkcalendar_type_short_string(NspObject *v)
{
  return(gtkcalendar_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCalendar objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCalendar   *nsp_gtkcalendar_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcalendar_id)  == TRUE  ) return ((NspGtkCalendar *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcalendar));
  return NULL;
}

int IsGtkCalendarObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcalendar_id);
}

int IsGtkCalendar(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcalendar_id);
}

NspGtkCalendar  *GetGtkCalendarCopy(Stack stack, int i)
{
  if (  GetGtkCalendar(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCalendar  *GetGtkCalendar(Stack stack, int i)
{
  NspGtkCalendar *M;
  if (( M = nsp_gtkcalendar_object(NthObj(i))) == NULLGTKCALENDAR)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCalendar *gtkcalendar_copy(NspGtkCalendar *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcalendar);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcalendar);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCalendar
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_calendar_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_calendar_new())== NULL) return RET_BUG;

  nsp_type_gtkcalendar = new_type_gtkcalendar(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcalendar);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_calendar_select_month(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int month, year;
  if ( GetArgs(stack,rhs,opt,T,&month, &year) == FAIL) return RET_BUG;
    gtk_calendar_select_month(GTK_CALENDAR(self->obj),month,year);
  return 0;
}

static int _wrap_gtk_calendar_select_day(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int day;
  if ( GetArgs(stack,rhs,opt,T,&day) == FAIL) return RET_BUG;
    gtk_calendar_select_day(GTK_CALENDAR(self->obj),day);
  return 0;
}

static int _wrap_gtk_calendar_mark_day(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int day;
  if ( GetArgs(stack,rhs,opt,T,&day) == FAIL) return RET_BUG;
    gtk_calendar_mark_day(GTK_CALENDAR(self->obj),day);
  return 0;
}

static int _wrap_gtk_calendar_unmark_day(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int day;
  if ( GetArgs(stack,rhs,opt,T,&day) == FAIL) return RET_BUG;
    gtk_calendar_unmark_day(GTK_CALENDAR(self->obj),day);
  return 0;
}

static int _wrap_gtk_calendar_clear_marks(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_calendar_clear_marks(GTK_CALENDAR(self->obj));
  return 0;
}

static int _wrap_gtk_calendar_set_display_options(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkCalendarDisplayOptions flags;
  NspObject *nsp_flags = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_CALENDAR_DISPLAY_OPTIONS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    gtk_calendar_set_display_options(GTK_CALENDAR(self->obj),flags);
  return 0;
}

static int _wrap_gtk_calendar_get_display_options(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_calendar_get_display_options(GTK_CALENDAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#line 5306 "codegen-3.0/gtk.override"
static int
_wrap_gtk_calendar_get_date(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  guint year, month, day;

  gtk_calendar_get_date(GTK_CALENDAR(self->obj), &year, &month, &day);
  if ( nsp_move_doubles(stack,1,1,3,(double) year,(double) month,(double) day) == FAIL) return RET_BUG;
  return 1;
}
#line 61742 "gtk.c"


#line 5250 "codegen-3.0/gtk.override"

typedef struct _calendar_detail_func_data calendar_detail_func_data;
 
struct _calendar_detail_func_data
{
  NspMatrix *ymd;      /* year, month, day */
  NspObject *func;   /* function to integrate */
  NspObject **targs;
  int nargs;
  int errcatch;
  int pausecatch;
};

/* static void calendar_detail_func_clean(calendar_detail_func_data *obj); */
static gchar *calendar_detail_func(GtkCalendar *calendar, guint year, guint month, 
				   guint day, gpointer user_data);

static int _wrap_gtk_calendar_set_detail_func(NspGObject *self, Stack stack,int rhs,int opt,int lhs,int flag)
{
  NspGtkCalendar *nsp_calendar = (NspGtkCalendar *) self;
  GtkCalendar *calendar = (GtkCalendar *) nsp_calendar->obj;
  static calendar_detail_func_data data;
  NspPList  *callback;
  CheckRhs(0,1);
  CheckLhs(1,1);
  if ( rhs >= 1 ) 
    {
      NspObject *nsp_calendar_copy;
      GQuark quark;
      if (( callback = GetNspPListCopy(stack,1)) == NULLP_PLIST) return RET_BUG;
      if (( nsp_object_set_name((NspObject *) callback,"calendar_detail_func")== FAIL)) return RET_BUG;
      data.func =(NspObject *) callback;
      if ((data.ymd = nsp_matrix_create("ymd",'r',1,3))== NULL) return RET_BUG;
      if ((data.targs = malloc(2*sizeof(NspObject *))) == NULL ) return RET_BUG;
      if ((nsp_calendar_copy = nsp_object_copy_and_name("calendar", NSP_OBJECT(nsp_calendar))) == NULL) return RET_BUG;
      data.targs[0] =  nsp_calendar_copy;
      data.targs[1] =  NSP_OBJECT(data.ymd);
      data.nargs = 2;
      data.errcatch = FALSE;
      data.pausecatch =FALSE;
      
      /*get a copy of object (GetObj takes care of Hobj pointers) **/
      quark = g_quark_from_string("calendar_detail");
      g_object_set_qdata_full( G_OBJECT(calendar), quark, &data, NULL);
      gtk_calendar_set_detail_func(calendar, calendar_detail_func,NULL,NULL);
    }
  else
    {
      gtk_calendar_set_detail_func( (GtkCalendar *) ((NspGtkCalendar *) self)->obj,
				    NULL,NULL,NULL);
    }
  return 0;
}

#line 61800 "gtk.c"


static int _wrap_gtk_calendar_set_detail_width_chars(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int chars;
  if ( GetArgs(stack,rhs,opt,T,&chars) == FAIL) return RET_BUG;
    gtk_calendar_set_detail_width_chars(GTK_CALENDAR(self->obj),chars);
  return 0;
}

static int _wrap_gtk_calendar_set_detail_height_rows(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int rows;
  if ( GetArgs(stack,rhs,opt,T,&rows) == FAIL) return RET_BUG;
    gtk_calendar_set_detail_height_rows(GTK_CALENDAR(self->obj),rows);
  return 0;
}

static int _wrap_gtk_calendar_get_detail_width_chars(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_calendar_get_detail_width_chars(GTK_CALENDAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_calendar_get_detail_height_rows(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_calendar_get_detail_height_rows(GTK_CALENDAR(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_calendar_get_day_is_marked(NspGtkCalendar *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int day, ret;
  if ( GetArgs(stack,rhs,opt,T,&day) == FAIL) return RET_BUG;
    ret =gtk_calendar_get_day_is_marked(GTK_CALENDAR(self->obj),day);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkcalendar_methods[] = {
  {"select_month",(nsp_method *) _wrap_gtk_calendar_select_month},
  {"select_day",(nsp_method *) _wrap_gtk_calendar_select_day},
  {"mark_day",(nsp_method *) _wrap_gtk_calendar_mark_day},
  {"unmark_day",(nsp_method *) _wrap_gtk_calendar_unmark_day},
  {"clear_marks",(nsp_method *) _wrap_gtk_calendar_clear_marks},
  {"set_display_options",(nsp_method *) _wrap_gtk_calendar_set_display_options},
  {"get_display_options",(nsp_method *) _wrap_gtk_calendar_get_display_options},
  {"get_date",(nsp_method *) _wrap_gtk_calendar_get_date},
  {"set_detail_func",(nsp_method *) _wrap_gtk_calendar_set_detail_func},
  {"set_detail_width_chars",(nsp_method *) _wrap_gtk_calendar_set_detail_width_chars},
  {"set_detail_height_rows",(nsp_method *) _wrap_gtk_calendar_set_detail_height_rows},
  {"get_detail_width_chars",(nsp_method *) _wrap_gtk_calendar_get_detail_width_chars},
  {"get_detail_height_rows",(nsp_method *) _wrap_gtk_calendar_get_detail_height_rows},
  {"get_day_is_marked",(nsp_method *) _wrap_gtk_calendar_get_day_is_marked},
  { NULL, NULL}
};

static NspMethods *gtkcalendar_get_methods(void) { return gtkcalendar_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcalendar_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkDrawingArea ----------- */


#define  NspGtkDrawingArea_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkdrawingarea.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkDrawingArea inherits from GtkWidget 
 * and implements GtkBuildable
 */

int nsp_type_gtkdrawingarea_id=0;
NspTypeGtkDrawingArea *nsp_type_gtkdrawingarea=NULL;

/*
 * Type object for NspGtkDrawingArea 
 * all the instance of NspTypeGtkDrawingArea share the same id. 
 * nsp_type_gtkdrawingarea: is an instance of NspTypeGtkDrawingArea 
 *    used for objects of NspGtkDrawingArea type (i.e built with new_gtkdrawingarea) 
 * other instances are used for derived classes 
 */
NspTypeGtkDrawingArea *new_type_gtkdrawingarea(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkDrawingArea *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkdrawingarea != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkdrawingarea;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkdrawingarea_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkdrawingarea_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkdrawingarea;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkdrawingarea */ 

  top->s_type =  (s_type_func *) nsp_gtkdrawingarea_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkdrawingarea_type_short_string;
  /* top->create = (create_func*) int_gtkdrawingarea_create;*/

  /* specific methods for gtkdrawingarea */

  type->init = (init_func *) init_gtkdrawingarea;

  /* 
   * NspGtkDrawingArea interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkdrawingarea_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkDrawingArea called nsp_type_gtkdrawingarea
       */
      type->id =  nsp_type_gtkdrawingarea_id = nsp_new_type_id();
      nsp_type_gtkdrawingarea = type;
      if ( nsp_register_type(nsp_type_gtkdrawingarea) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkdrawingarea, GTK_TYPE_DRAWING_AREA);
      return ( mode == T_BASE ) ? type : new_type_gtkdrawingarea(mode);
    }
  else 
    {
      type->id = nsp_type_gtkdrawingarea_id;
      return type;
    }
}

/*
 * initialize NspGtkDrawingArea instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkdrawingarea(NspGtkDrawingArea *Obj,NspTypeGtkDrawingArea *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkDrawingArea 
 */

NspGtkDrawingArea *new_gtkdrawingarea() 
{
  NspGtkDrawingArea *loc;
  /* type must exists */
  nsp_type_gtkdrawingarea = new_type_gtkdrawingarea(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkDrawingArea)))== NULLGTKDRAWINGAREA) return loc;
  /* initialize object */
  if ( init_gtkdrawingarea(loc,nsp_type_gtkdrawingarea) == FAIL) return NULLGTKDRAWINGAREA;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkDrawingArea 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkdrawingarea_type_name[]="GtkDrawingArea";
static char gtkdrawingarea_short_type_name[]="GtkDrawingArea";

static char *nsp_gtkdrawingarea_type_as_string(void)
{
  return(gtkdrawingarea_type_name);
}

static char *nsp_gtkdrawingarea_type_short_string(NspObject *v)
{
  return(gtkdrawingarea_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkDrawingArea objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkDrawingArea   *nsp_gtkdrawingarea_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkdrawingarea_id)  == TRUE  ) return ((NspGtkDrawingArea *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkdrawingarea));
  return NULL;
}

int IsGtkDrawingAreaObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkdrawingarea_id);
}

int IsGtkDrawingArea(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkdrawingarea_id);
}

NspGtkDrawingArea  *GetGtkDrawingAreaCopy(Stack stack, int i)
{
  if (  GetGtkDrawingArea(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkDrawingArea  *GetGtkDrawingArea(Stack stack, int i)
{
  NspGtkDrawingArea *M;
  if (( M = nsp_gtkdrawingarea_object(NthObj(i))) == NULLGTKDRAWINGAREA)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkDrawingArea *gtkdrawingarea_copy(NspGtkDrawingArea *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkdrawingarea);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkdrawingarea);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkDrawingArea
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_drawing_area_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_drawing_area_new())== NULL) return RET_BUG;

  nsp_type_gtkdrawingarea = new_type_gtkdrawingarea(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkdrawingarea);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkdrawingarea_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkdrawingarea_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkEventBox ----------- */


#define  NspGtkEventBox_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkeventbox.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkEventBox inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkeventbox_id=0;
NspTypeGtkEventBox *nsp_type_gtkeventbox=NULL;

/*
 * Type object for NspGtkEventBox 
 * all the instance of NspTypeGtkEventBox share the same id. 
 * nsp_type_gtkeventbox: is an instance of NspTypeGtkEventBox 
 *    used for objects of NspGtkEventBox type (i.e built with new_gtkeventbox) 
 * other instances are used for derived classes 
 */
NspTypeGtkEventBox *new_type_gtkeventbox(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkEventBox *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkeventbox != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkeventbox;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkeventbox_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkeventbox_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkeventbox;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkeventbox */ 

  top->s_type =  (s_type_func *) nsp_gtkeventbox_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkeventbox_type_short_string;
  /* top->create = (create_func*) int_gtkeventbox_create;*/

  /* specific methods for gtkeventbox */

  type->init = (init_func *) init_gtkeventbox;

  /* 
   * NspGtkEventBox interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkeventbox_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkEventBox called nsp_type_gtkeventbox
       */
      type->id =  nsp_type_gtkeventbox_id = nsp_new_type_id();
      nsp_type_gtkeventbox = type;
      if ( nsp_register_type(nsp_type_gtkeventbox) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkeventbox, GTK_TYPE_EVENT_BOX);
      return ( mode == T_BASE ) ? type : new_type_gtkeventbox(mode);
    }
  else 
    {
      type->id = nsp_type_gtkeventbox_id;
      return type;
    }
}

/*
 * initialize NspGtkEventBox instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkeventbox(NspGtkEventBox *Obj,NspTypeGtkEventBox *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkEventBox 
 */

NspGtkEventBox *new_gtkeventbox() 
{
  NspGtkEventBox *loc;
  /* type must exists */
  nsp_type_gtkeventbox = new_type_gtkeventbox(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkEventBox)))== NULLGTKEVENTBOX) return loc;
  /* initialize object */
  if ( init_gtkeventbox(loc,nsp_type_gtkeventbox) == FAIL) return NULLGTKEVENTBOX;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkEventBox 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkeventbox_type_name[]="GtkEventBox";
static char gtkeventbox_short_type_name[]="GtkEventBox";

static char *nsp_gtkeventbox_type_as_string(void)
{
  return(gtkeventbox_type_name);
}

static char *nsp_gtkeventbox_type_short_string(NspObject *v)
{
  return(gtkeventbox_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkEventBox objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkEventBox   *nsp_gtkeventbox_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkeventbox_id)  == TRUE  ) return ((NspGtkEventBox *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkeventbox));
  return NULL;
}

int IsGtkEventBoxObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkeventbox_id);
}

int IsGtkEventBox(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkeventbox_id);
}

NspGtkEventBox  *GetGtkEventBoxCopy(Stack stack, int i)
{
  if (  GetGtkEventBox(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkEventBox  *GetGtkEventBox(Stack stack, int i)
{
  NspGtkEventBox *M;
  if (( M = nsp_gtkeventbox_object(NthObj(i))) == NULLGTKEVENTBOX)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkEventBox *gtkeventbox_copy(NspGtkEventBox *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkeventbox);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkeventbox);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkEventBox
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_event_box_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_event_box_new())== NULL) return RET_BUG;

  nsp_type_gtkeventbox = new_type_gtkeventbox(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkeventbox);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_event_box_get_visible_window(NspGtkEventBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_event_box_get_visible_window(GTK_EVENT_BOX(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_event_box_set_visible_window(NspGtkEventBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int visible_window;
  if ( GetArgs(stack,rhs,opt,T,&visible_window) == FAIL) return RET_BUG;
    gtk_event_box_set_visible_window(GTK_EVENT_BOX(self->obj),visible_window);
  return 0;
}

static int _wrap_gtk_event_box_get_above_child(NspGtkEventBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_event_box_get_above_child(GTK_EVENT_BOX(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_event_box_set_above_child(NspGtkEventBox *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int above_child;
  if ( GetArgs(stack,rhs,opt,T,&above_child) == FAIL) return RET_BUG;
    gtk_event_box_set_above_child(GTK_EVENT_BOX(self->obj),above_child);
  return 0;
}

static NspMethods gtkeventbox_methods[] = {
  {"get_visible_window",(nsp_method *) _wrap_gtk_event_box_get_visible_window},
  {"set_visible_window",(nsp_method *) _wrap_gtk_event_box_set_visible_window},
  {"get_above_child",(nsp_method *) _wrap_gtk_event_box_get_above_child},
  {"set_above_child",(nsp_method *) _wrap_gtk_event_box_set_above_child},
  { NULL, NULL}
};

static NspMethods *gtkeventbox_get_methods(void) { return gtkeventbox_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkeventbox_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkIMContextSimple ----------- */


#define  NspGtkIMContextSimple_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkimcontextsimple.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkIMContextSimple inherits from GtkIMContext 
 */

int nsp_type_gtkimcontextsimple_id=0;
NspTypeGtkIMContextSimple *nsp_type_gtkimcontextsimple=NULL;

/*
 * Type object for NspGtkIMContextSimple 
 * all the instance of NspTypeGtkIMContextSimple share the same id. 
 * nsp_type_gtkimcontextsimple: is an instance of NspTypeGtkIMContextSimple 
 *    used for objects of NspGtkIMContextSimple type (i.e built with new_gtkimcontextsimple) 
 * other instances are used for derived classes 
 */
NspTypeGtkIMContextSimple *new_type_gtkimcontextsimple(type_mode mode)
{
  NspTypeGtkIMContextSimple *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkimcontextsimple != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkimcontextsimple;
    }
  if (( type =  malloc(sizeof(NspTypeGtkIMContext))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkimcontext(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkimcontextsimple_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkimcontextsimple_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkimcontextsimple;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkimcontextsimple */ 

  top->s_type =  (s_type_func *) nsp_gtkimcontextsimple_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkimcontextsimple_type_short_string;
  /* top->create = (create_func*) int_gtkimcontextsimple_create;*/

  /* specific methods for gtkimcontextsimple */

  type->init = (init_func *) init_gtkimcontextsimple;

  /* 
   * NspGtkIMContextSimple interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkimcontextsimple_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIMContextSimple called nsp_type_gtkimcontextsimple
       */
      type->id =  nsp_type_gtkimcontextsimple_id = nsp_new_type_id();
      nsp_type_gtkimcontextsimple = type;
      if ( nsp_register_type(nsp_type_gtkimcontextsimple) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkimcontextsimple, GTK_TYPE_IM_CONTEXT_SIMPLE);
      return ( mode == T_BASE ) ? type : new_type_gtkimcontextsimple(mode);
    }
  else 
    {
      type->id = nsp_type_gtkimcontextsimple_id;
      return type;
    }
}

/*
 * initialize NspGtkIMContextSimple instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkimcontextsimple(NspGtkIMContextSimple *Obj,NspTypeGtkIMContextSimple *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkIMContextSimple 
 */

NspGtkIMContextSimple *new_gtkimcontextsimple() 
{
  NspGtkIMContextSimple *loc;
  /* type must exists */
  nsp_type_gtkimcontextsimple = new_type_gtkimcontextsimple(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIMContextSimple)))== NULLGTKIMCONTEXTSIMPLE) return loc;
  /* initialize object */
  if ( init_gtkimcontextsimple(loc,nsp_type_gtkimcontextsimple) == FAIL) return NULLGTKIMCONTEXTSIMPLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkIMContextSimple 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkimcontextsimple_type_name[]="GtkIMContextSimple";
static char gtkimcontextsimple_short_type_name[]="GtkIMContextSimple";

static char *nsp_gtkimcontextsimple_type_as_string(void)
{
  return(gtkimcontextsimple_type_name);
}

static char *nsp_gtkimcontextsimple_type_short_string(NspObject *v)
{
  return(gtkimcontextsimple_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkIMContextSimple objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkIMContextSimple   *nsp_gtkimcontextsimple_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkimcontextsimple_id)  == TRUE  ) return ((NspGtkIMContextSimple *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkimcontextsimple));
  return NULL;
}

int IsGtkIMContextSimpleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkimcontextsimple_id);
}

int IsGtkIMContextSimple(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkimcontextsimple_id);
}

NspGtkIMContextSimple  *GetGtkIMContextSimpleCopy(Stack stack, int i)
{
  if (  GetGtkIMContextSimple(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIMContextSimple  *GetGtkIMContextSimple(Stack stack, int i)
{
  NspGtkIMContextSimple *M;
  if (( M = nsp_gtkimcontextsimple_object(NthObj(i))) == NULLGTKIMCONTEXTSIMPLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkIMContextSimple *gtkimcontextsimple_copy(NspGtkIMContextSimple *self)
{
  /* return gtkimcontext_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimcontextsimple);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimcontextsimple);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIMContextSimple
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static NspMethods *gtkimcontextsimple_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkimcontextsimple_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkIMMulticontext ----------- */


#define  NspGtkIMMulticontext_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkimmulticontext.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkIMMulticontext inherits from GtkIMContext 
 */

int nsp_type_gtkimmulticontext_id=0;
NspTypeGtkIMMulticontext *nsp_type_gtkimmulticontext=NULL;

/*
 * Type object for NspGtkIMMulticontext 
 * all the instance of NspTypeGtkIMMulticontext share the same id. 
 * nsp_type_gtkimmulticontext: is an instance of NspTypeGtkIMMulticontext 
 *    used for objects of NspGtkIMMulticontext type (i.e built with new_gtkimmulticontext) 
 * other instances are used for derived classes 
 */
NspTypeGtkIMMulticontext *new_type_gtkimmulticontext(type_mode mode)
{
  NspTypeGtkIMMulticontext *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkimmulticontext != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkimmulticontext;
    }
  if (( type =  malloc(sizeof(NspTypeGtkIMContext))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkimcontext(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkimmulticontext_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkimmulticontext_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkimmulticontext;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkimmulticontext */ 

  top->s_type =  (s_type_func *) nsp_gtkimmulticontext_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkimmulticontext_type_short_string;
  /* top->create = (create_func*) int_gtkimmulticontext_create;*/

  /* specific methods for gtkimmulticontext */

  type->init = (init_func *) init_gtkimmulticontext;

  /* 
   * NspGtkIMMulticontext interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkimmulticontext_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIMMulticontext called nsp_type_gtkimmulticontext
       */
      type->id =  nsp_type_gtkimmulticontext_id = nsp_new_type_id();
      nsp_type_gtkimmulticontext = type;
      if ( nsp_register_type(nsp_type_gtkimmulticontext) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkimmulticontext, GTK_TYPE_IM_MULTICONTEXT);
      return ( mode == T_BASE ) ? type : new_type_gtkimmulticontext(mode);
    }
  else 
    {
      type->id = nsp_type_gtkimmulticontext_id;
      return type;
    }
}

/*
 * initialize NspGtkIMMulticontext instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkimmulticontext(NspGtkIMMulticontext *Obj,NspTypeGtkIMMulticontext *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkIMMulticontext 
 */

NspGtkIMMulticontext *new_gtkimmulticontext() 
{
  NspGtkIMMulticontext *loc;
  /* type must exists */
  nsp_type_gtkimmulticontext = new_type_gtkimmulticontext(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIMMulticontext)))== NULLGTKIMMULTICONTEXT) return loc;
  /* initialize object */
  if ( init_gtkimmulticontext(loc,nsp_type_gtkimmulticontext) == FAIL) return NULLGTKIMMULTICONTEXT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkIMMulticontext 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkimmulticontext_type_name[]="GtkIMMulticontext";
static char gtkimmulticontext_short_type_name[]="GtkIMMulticontext";

static char *nsp_gtkimmulticontext_type_as_string(void)
{
  return(gtkimmulticontext_type_name);
}

static char *nsp_gtkimmulticontext_type_short_string(NspObject *v)
{
  return(gtkimmulticontext_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkIMMulticontext objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkIMMulticontext   *nsp_gtkimmulticontext_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkimmulticontext_id)  == TRUE  ) return ((NspGtkIMMulticontext *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkimmulticontext));
  return NULL;
}

int IsGtkIMMulticontextObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkimmulticontext_id);
}

int IsGtkIMMulticontext(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkimmulticontext_id);
}

NspGtkIMMulticontext  *GetGtkIMMulticontextCopy(Stack stack, int i)
{
  if (  GetGtkIMMulticontext(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIMMulticontext  *GetGtkIMMulticontext(Stack stack, int i)
{
  NspGtkIMMulticontext *M;
  if (( M = nsp_gtkimmulticontext_object(NthObj(i))) == NULLGTKIMMULTICONTEXT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkIMMulticontext *gtkimmulticontext_copy(NspGtkIMMulticontext *self)
{
  /* return gtkimcontext_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimmulticontext);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimmulticontext);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIMMulticontext
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_im_multicontext_append_menuitems(Stack stack, int rhs, int opt, int lhs) /* append_menuitems */
{
  Scierror("Error: function gtk_im_multicontext_append_menuitems is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_im_multicontext_append_menuitems(NspGtkIMMulticontext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *menushell;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkmenushell, &menushell) == FAIL) return RET_BUG;
    gtk_im_multicontext_append_menuitems(GTK_IM_MULTICONTEXT(self->obj),GTK_MENU_SHELL(menushell->obj));
  return 0;
}

#endif
static int _wrap_gtk_im_multicontext_get_context_id(NspGtkIMMulticontext *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_im_multicontext_get_context_id(GTK_IM_MULTICONTEXT(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_im_multicontext_set_context_id(NspGtkIMMulticontext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *context_id;
  if ( GetArgs(stack,rhs,opt,T,&context_id) == FAIL) return RET_BUG;
    gtk_im_multicontext_set_context_id(GTK_IM_MULTICONTEXT(self->obj),context_id);
  return 0;
}

static NspMethods gtkimmulticontext_methods[] = {
  {"append_menuitems",(nsp_method *) _wrap_gtk_im_multicontext_append_menuitems},
  {"get_context_id",(nsp_method *) _wrap_gtk_im_multicontext_get_context_id},
  {"set_context_id",(nsp_method *) _wrap_gtk_im_multicontext_set_context_id},
  { NULL, NULL}
};

static NspMethods *gtkimmulticontext_get_methods(void) { return gtkimmulticontext_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkimmulticontext_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkSizeGroup ----------- */


#define  NspGtkSizeGroup_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtksizegroup.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkSizeGroup inherits from GObject 
 * and implements GtkBuildable
 */

int nsp_type_gtksizegroup_id=0;
NspTypeGtkSizeGroup *nsp_type_gtksizegroup=NULL;

/*
 * Type object for NspGtkSizeGroup 
 * all the instance of NspTypeGtkSizeGroup share the same id. 
 * nsp_type_gtksizegroup: is an instance of NspTypeGtkSizeGroup 
 *    used for objects of NspGtkSizeGroup type (i.e built with new_gtksizegroup) 
 * other instances are used for derived classes 
 */
NspTypeGtkSizeGroup *new_type_gtksizegroup(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkSizeGroup *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtksizegroup != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtksizegroup;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtksizegroup_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtksizegroup_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtksizegroup;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtksizegroup */ 

  top->s_type =  (s_type_func *) nsp_gtksizegroup_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtksizegroup_type_short_string;
  /* top->create = (create_func*) int_gtksizegroup_create;*/

  /* specific methods for gtksizegroup */

  type->init = (init_func *) init_gtksizegroup;

  /* 
   * NspGtkSizeGroup interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtksizegroup_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSizeGroup called nsp_type_gtksizegroup
       */
      type->id =  nsp_type_gtksizegroup_id = nsp_new_type_id();
      nsp_type_gtksizegroup = type;
      if ( nsp_register_type(nsp_type_gtksizegroup) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtksizegroup, GTK_TYPE_SIZE_GROUP);
      return ( mode == T_BASE ) ? type : new_type_gtksizegroup(mode);
    }
  else 
    {
      type->id = nsp_type_gtksizegroup_id;
      return type;
    }
}

/*
 * initialize NspGtkSizeGroup instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtksizegroup(NspGtkSizeGroup *Obj,NspTypeGtkSizeGroup *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkSizeGroup 
 */

NspGtkSizeGroup *new_gtksizegroup() 
{
  NspGtkSizeGroup *loc;
  /* type must exists */
  nsp_type_gtksizegroup = new_type_gtksizegroup(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSizeGroup)))== NULLGTKSIZEGROUP) return loc;
  /* initialize object */
  if ( init_gtksizegroup(loc,nsp_type_gtksizegroup) == FAIL) return NULLGTKSIZEGROUP;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkSizeGroup 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtksizegroup_type_name[]="GtkSizeGroup";
static char gtksizegroup_short_type_name[]="GtkSizeGroup";

static char *nsp_gtksizegroup_type_as_string(void)
{
  return(gtksizegroup_type_name);
}

static char *nsp_gtksizegroup_type_short_string(NspObject *v)
{
  return(gtksizegroup_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkSizeGroup objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkSizeGroup   *nsp_gtksizegroup_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtksizegroup_id)  == TRUE  ) return ((NspGtkSizeGroup *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtksizegroup));
  return NULL;
}

int IsGtkSizeGroupObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtksizegroup_id);
}

int IsGtkSizeGroup(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtksizegroup_id);
}

NspGtkSizeGroup  *GetGtkSizeGroupCopy(Stack stack, int i)
{
  if (  GetGtkSizeGroup(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSizeGroup  *GetGtkSizeGroup(Stack stack, int i)
{
  NspGtkSizeGroup *M;
  if (( M = nsp_gtksizegroup_object(NthObj(i))) == NULLGTKSIZEGROUP)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSizeGroup *gtksizegroup_copy(NspGtkSizeGroup *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksizegroup);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksizegroup);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSizeGroup
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_size_group_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSizeGroupMode mode;
  NspObject *nsp_mode = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SIZE_GROUP_MODE, nsp_mode, &mode)== FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_size_group_new(mode))== NULL) return RET_BUG;

  nsp_type_gtksizegroup = new_type_gtksizegroup(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtksizegroup);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_size_group_set_mode(NspGtkSizeGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSizeGroupMode mode;
  NspObject *nsp_mode = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SIZE_GROUP_MODE, nsp_mode, &mode)== FAIL)
      return RET_BUG;
    gtk_size_group_set_mode(GTK_SIZE_GROUP(self->obj),mode);
  return 0;
}

static int _wrap_gtk_size_group_get_mode(NspGtkSizeGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_size_group_get_mode(GTK_SIZE_GROUP(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_size_group_set_ignore_hidden(NspGtkSizeGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int ignore_hidden;
  if ( GetArgs(stack,rhs,opt,T,&ignore_hidden) == FAIL) return RET_BUG;
    gtk_size_group_set_ignore_hidden(GTK_SIZE_GROUP(self->obj),ignore_hidden);
  return 0;
}

static int _wrap_gtk_size_group_get_ignore_hidden(NspGtkSizeGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_size_group_get_ignore_hidden(GTK_SIZE_GROUP(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_size_group_add_widget(NspGtkSizeGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_size_group_add_widget(GTK_SIZE_GROUP(self->obj),GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_size_group_remove_widget(NspGtkSizeGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_size_group_remove_widget(GTK_SIZE_GROUP(self->obj),GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_size_group_get_widgets(NspGtkSizeGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_size_group_get_widgets(GTK_SIZE_GROUP(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

static NspMethods gtksizegroup_methods[] = {
  {"set_mode",(nsp_method *) _wrap_gtk_size_group_set_mode},
  {"get_mode",(nsp_method *) _wrap_gtk_size_group_get_mode},
  {"set_ignore_hidden",(nsp_method *) _wrap_gtk_size_group_set_ignore_hidden},
  {"get_ignore_hidden",(nsp_method *) _wrap_gtk_size_group_get_ignore_hidden},
  {"add_widget",(nsp_method *) _wrap_gtk_size_group_add_widget},
  {"remove_widget",(nsp_method *) _wrap_gtk_size_group_remove_widget},
  {"get_widgets",(nsp_method *) _wrap_gtk_size_group_get_widgets},
  { NULL, NULL}
};

static NspMethods *gtksizegroup_get_methods(void) { return gtksizegroup_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtksizegroup_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkTooltip ----------- */


#define  NspGtkTooltip_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktooltip.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkTooltip inherits from GObject 
 */

int nsp_type_gtktooltip_id=0;
NspTypeGtkTooltip *nsp_type_gtktooltip=NULL;

/*
 * Type object for NspGtkTooltip 
 * all the instance of NspTypeGtkTooltip share the same id. 
 * nsp_type_gtktooltip: is an instance of NspTypeGtkTooltip 
 *    used for objects of NspGtkTooltip type (i.e built with new_gtktooltip) 
 * other instances are used for derived classes 
 */
NspTypeGtkTooltip *new_type_gtktooltip(type_mode mode)
{
  NspTypeGtkTooltip *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktooltip != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktooltip;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktooltip_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktooltip_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktooltip;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktooltip */ 

  top->s_type =  (s_type_func *) nsp_gtktooltip_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktooltip_type_short_string;
  /* top->create = (create_func*) int_gtktooltip_create;*/

  /* specific methods for gtktooltip */

  type->init = (init_func *) init_gtktooltip;

  /* 
   * NspGtkTooltip interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktooltip_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkTooltip called nsp_type_gtktooltip
       */
      type->id =  nsp_type_gtktooltip_id = nsp_new_type_id();
      nsp_type_gtktooltip = type;
      if ( nsp_register_type(nsp_type_gtktooltip) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktooltip, GTK_TYPE_TOOLTIP);
      return ( mode == T_BASE ) ? type : new_type_gtktooltip(mode);
    }
  else 
    {
      type->id = nsp_type_gtktooltip_id;
      return type;
    }
}

/*
 * initialize NspGtkTooltip instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktooltip(NspGtkTooltip *Obj,NspTypeGtkTooltip *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkTooltip 
 */

NspGtkTooltip *new_gtktooltip() 
{
  NspGtkTooltip *loc;
  /* type must exists */
  nsp_type_gtktooltip = new_type_gtktooltip(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkTooltip)))== NULLGTKTOOLTIP) return loc;
  /* initialize object */
  if ( init_gtktooltip(loc,nsp_type_gtktooltip) == FAIL) return NULLGTKTOOLTIP;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkTooltip 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktooltip_type_name[]="GtkTooltip";
static char gtktooltip_short_type_name[]="GtkTooltip";

static char *nsp_gtktooltip_type_as_string(void)
{
  return(gtktooltip_type_name);
}

static char *nsp_gtktooltip_type_short_string(NspObject *v)
{
  return(gtktooltip_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkTooltip objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkTooltip   *nsp_gtktooltip_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktooltip_id)  == TRUE  ) return ((NspGtkTooltip *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktooltip));
  return NULL;
}

int IsGtkTooltipObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktooltip_id);
}

int IsGtkTooltip(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktooltip_id);
}

NspGtkTooltip  *GetGtkTooltipCopy(Stack stack, int i)
{
  if (  GetGtkTooltip(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkTooltip  *GetGtkTooltip(Stack stack, int i)
{
  NspGtkTooltip *M;
  if (( M = nsp_gtktooltip_object(NthObj(i))) == NULLGTKTOOLTIP)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkTooltip *gtktooltip_copy(NspGtkTooltip *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktooltip);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktooltip);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkTooltip
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_tooltip_set_markup(NspGtkTooltip *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *markup;
  if ( GetArgs(stack,rhs,opt,T,&markup) == FAIL) return RET_BUG;
    gtk_tooltip_set_markup(GTK_TOOLTIP(self->obj),markup);
  return 0;
}

static int _wrap_gtk_tooltip_set_text(NspGtkTooltip *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    gtk_tooltip_set_text(GTK_TOOLTIP(self->obj),text);
  return 0;
}

static int _wrap_gtk_tooltip_set_icon(NspGtkTooltip *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *pixbuf;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
    gtk_tooltip_set_icon(GTK_TOOLTIP(self->obj),GDK_PIXBUF(pixbuf->obj));
  return 0;
}

static int _wrap_gtk_tooltip_set_icon_from_icon_name(NspGtkTooltip *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *icon_name;
  GtkIconSize size;
  NspObject *nsp_size = NULL;
  if ( GetArgs(stack,rhs,opt,T,&icon_name, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
    gtk_tooltip_set_icon_from_icon_name(GTK_TOOLTIP(self->obj),icon_name,size);
  return 0;
}

static int _wrap_gtk_tooltip_set_icon_from_gicon(NspGtkTooltip *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *gicon;
  GtkIconSize size;
  NspObject *nsp_size = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gicon, &gicon, &nsp_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
    gtk_tooltip_set_icon_from_gicon(GTK_TOOLTIP(self->obj),G_ICON(gicon->obj),size);
  return 0;
}

static int _wrap_gtk_tooltip_set_custom(NspGtkTooltip *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *custom_widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &custom_widget) == FAIL) return RET_BUG;
    gtk_tooltip_set_custom(GTK_TOOLTIP(self->obj),GTK_WIDGET(custom_widget->obj));
  return 0;
}

static NspMethods gtktooltip_methods[] = {
  {"set_markup",(nsp_method *) _wrap_gtk_tooltip_set_markup},
  {"set_text",(nsp_method *) _wrap_gtk_tooltip_set_text},
  {"set_icon",(nsp_method *) _wrap_gtk_tooltip_set_icon},
  {"set_icon_from_icon_name",(nsp_method *) _wrap_gtk_tooltip_set_icon_from_icon_name},
  {"set_icon_from_gicon",(nsp_method *) _wrap_gtk_tooltip_set_icon_from_gicon},
  {"set_custom",(nsp_method *) _wrap_gtk_tooltip_set_custom},
  { NULL, NULL}
};

static NspMethods *gtktooltip_get_methods(void) { return gtktooltip_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktooltip_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkViewport ----------- */


#define  NspGtkViewport_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkviewport.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkViewport inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkviewport_id=0;
NspTypeGtkViewport *nsp_type_gtkviewport=NULL;

/*
 * Type object for NspGtkViewport 
 * all the instance of NspTypeGtkViewport share the same id. 
 * nsp_type_gtkviewport: is an instance of NspTypeGtkViewport 
 *    used for objects of NspGtkViewport type (i.e built with new_gtkviewport) 
 * other instances are used for derived classes 
 */
NspTypeGtkViewport *new_type_gtkviewport(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkViewport *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkviewport != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkviewport;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkviewport_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkviewport_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkviewport;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkviewport */ 

  top->s_type =  (s_type_func *) nsp_gtkviewport_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkviewport_type_short_string;
  /* top->create = (create_func*) int_gtkviewport_create;*/

  /* specific methods for gtkviewport */

  type->init = (init_func *) init_gtkviewport;

  /* 
   * NspGtkViewport interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkviewport_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkViewport called nsp_type_gtkviewport
       */
      type->id =  nsp_type_gtkviewport_id = nsp_new_type_id();
      nsp_type_gtkviewport = type;
      if ( nsp_register_type(nsp_type_gtkviewport) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkviewport, GTK_TYPE_VIEWPORT);
      return ( mode == T_BASE ) ? type : new_type_gtkviewport(mode);
    }
  else 
    {
      type->id = nsp_type_gtkviewport_id;
      return type;
    }
}

/*
 * initialize NspGtkViewport instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkviewport(NspGtkViewport *Obj,NspTypeGtkViewport *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkViewport 
 */

NspGtkViewport *new_gtkviewport() 
{
  NspGtkViewport *loc;
  /* type must exists */
  nsp_type_gtkviewport = new_type_gtkviewport(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkViewport)))== NULLGTKVIEWPORT) return loc;
  /* initialize object */
  if ( init_gtkviewport(loc,nsp_type_gtkviewport) == FAIL) return NULLGTKVIEWPORT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkViewport 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkviewport_type_name[]="GtkViewport";
static char gtkviewport_short_type_name[]="GtkViewport";

static char *nsp_gtkviewport_type_as_string(void)
{
  return(gtkviewport_type_name);
}

static char *nsp_gtkviewport_type_short_string(NspObject *v)
{
  return(gtkviewport_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkViewport objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkViewport   *nsp_gtkviewport_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkviewport_id)  == TRUE  ) return ((NspGtkViewport *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkviewport));
  return NULL;
}

int IsGtkViewportObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkviewport_id);
}

int IsGtkViewport(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkviewport_id);
}

NspGtkViewport  *GetGtkViewportCopy(Stack stack, int i)
{
  if (  GetGtkViewport(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkViewport  *GetGtkViewport(Stack stack, int i)
{
  NspGtkViewport *M;
  if (( M = nsp_gtkviewport_object(NthObj(i))) == NULLGTKVIEWPORT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkViewport *gtkviewport_copy(NspGtkViewport *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkviewport);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkviewport);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkViewport
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_viewport_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"hadjustment",obj,NULLOBJ,-1},
	{"vadjustment",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GtkAdjustment *hadjustment = NULL, *vadjustment = NULL;
  NspGObject *nsp_hadjustment = NULL, *nsp_vadjustment = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_hadjustment, &nsp_vadjustment) == FAIL) return RET_BUG;
  if ( nsp_hadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_hadjustment))
      hadjustment = GTK_ADJUSTMENT(nsp_hadjustment->obj);
    else if (! IsNone((NspObject *)nsp_hadjustment)) {
         Scierror( "Error: hadjustment should be a GtkAdjustment or None\n");
         return RET_BUG;
    }
  }
  if ( nsp_vadjustment != NULL ) {
    if ( IsGtkAdjustment((NspObject *)nsp_vadjustment))
      vadjustment = GTK_ADJUSTMENT(nsp_vadjustment->obj);
    else if (! IsNone((NspObject *)nsp_vadjustment)) {
         Scierror( "Error: vadjustment should be a GtkAdjustment or None\n");
         return RET_BUG;
    }
  }
  if ((ret = (GObject *)gtk_viewport_new(hadjustment,vadjustment))== NULL) return RET_BUG;

  nsp_type_gtkviewport = new_type_gtkviewport(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkviewport);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_viewport_set_shadow_type(NspGtkViewport *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkShadowType type;
  NspObject *nsp_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SHADOW_TYPE, nsp_type, &type)== FAIL)
      return RET_BUG;
    gtk_viewport_set_shadow_type(GTK_VIEWPORT(self->obj),type);
  return 0;
}

static int _wrap_gtk_viewport_get_shadow_type(NspGtkViewport *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_viewport_get_shadow_type(GTK_VIEWPORT(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_viewport_get_bin_window(NspGtkViewport *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_viewport_get_bin_window(GTK_VIEWPORT(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_viewport_get_view_window(NspGtkViewport *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_viewport_get_view_window(GTK_VIEWPORT(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkviewport_methods[] = {
  {"set_shadow_type",(nsp_method *) _wrap_gtk_viewport_set_shadow_type},
  {"get_shadow_type",(nsp_method *) _wrap_gtk_viewport_get_shadow_type},
  {"get_bin_window",(nsp_method *) _wrap_gtk_viewport_get_bin_window},
  {"get_view_window",(nsp_method *) _wrap_gtk_viewport_get_view_window},
  { NULL, NULL}
};

static NspMethods *gtkviewport_get_methods(void) { return gtkviewport_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkviewport_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAccessible ----------- */


#define  NspGtkAccessible_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkaccessible.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAccessible inherits from AtkObject 
 */

int nsp_type_gtkaccessible_id=0;
NspTypeGtkAccessible *nsp_type_gtkaccessible=NULL;

/*
 * Type object for NspGtkAccessible 
 * all the instance of NspTypeGtkAccessible share the same id. 
 * nsp_type_gtkaccessible: is an instance of NspTypeGtkAccessible 
 *    used for objects of NspGtkAccessible type (i.e built with new_gtkaccessible) 
 * other instances are used for derived classes 
 */
NspTypeGtkAccessible *new_type_gtkaccessible(type_mode mode)
{
  NspTypeGtkAccessible *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkaccessible != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkaccessible;
    }
  if (( type =  malloc(sizeof(NspTypeAtkObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_atkobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkaccessible_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkaccessible_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkaccessible;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkaccessible */ 

  top->s_type =  (s_type_func *) nsp_gtkaccessible_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkaccessible_type_short_string;
  /* top->create = (create_func*) int_gtkaccessible_create;*/

  /* specific methods for gtkaccessible */

  type->init = (init_func *) init_gtkaccessible;

  /* 
   * NspGtkAccessible interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkaccessible_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAccessible called nsp_type_gtkaccessible
       */
      type->id =  nsp_type_gtkaccessible_id = nsp_new_type_id();
      nsp_type_gtkaccessible = type;
      if ( nsp_register_type(nsp_type_gtkaccessible) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkaccessible, GTK_TYPE_ACCESSIBLE);
      return ( mode == T_BASE ) ? type : new_type_gtkaccessible(mode);
    }
  else 
    {
      type->id = nsp_type_gtkaccessible_id;
      return type;
    }
}

/*
 * initialize NspGtkAccessible instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkaccessible(NspGtkAccessible *Obj,NspTypeGtkAccessible *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAccessible 
 */

NspGtkAccessible *new_gtkaccessible() 
{
  NspGtkAccessible *loc;
  /* type must exists */
  nsp_type_gtkaccessible = new_type_gtkaccessible(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAccessible)))== NULLGTKACCESSIBLE) return loc;
  /* initialize object */
  if ( init_gtkaccessible(loc,nsp_type_gtkaccessible) == FAIL) return NULLGTKACCESSIBLE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAccessible 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkaccessible_type_name[]="GtkAccessible";
static char gtkaccessible_short_type_name[]="GtkAccessible";

static char *nsp_gtkaccessible_type_as_string(void)
{
  return(gtkaccessible_type_name);
}

static char *nsp_gtkaccessible_type_short_string(NspObject *v)
{
  return(gtkaccessible_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAccessible objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAccessible   *nsp_gtkaccessible_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkaccessible_id)  == TRUE  ) return ((NspGtkAccessible *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkaccessible));
  return NULL;
}

int IsGtkAccessibleObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkaccessible_id);
}

int IsGtkAccessible(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkaccessible_id);
}

NspGtkAccessible  *GetGtkAccessibleCopy(Stack stack, int i)
{
  if (  GetGtkAccessible(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAccessible  *GetGtkAccessible(Stack stack, int i)
{
  NspGtkAccessible *M;
  if (( M = nsp_gtkaccessible_object(NthObj(i))) == NULLGTKACCESSIBLE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAccessible *gtkaccessible_copy(NspGtkAccessible *self)
{
  /* return atkobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccessible);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccessible);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAccessible
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_accessible_set_widget(NspGtkAccessible *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_accessible_set_widget(GTK_ACCESSIBLE(self->obj),GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_accessible_get_widget(NspGtkAccessible *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_accessible_get_widget(GTK_ACCESSIBLE(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkaccessible_methods[] = {
  {"set_widget",(nsp_method *) _wrap_gtk_accessible_set_widget},
  {"get_widget",(nsp_method *) _wrap_gtk_accessible_get_widget},
  { NULL, NULL}
};

static NspMethods *gtkaccessible_get_methods(void) { return gtkaccessible_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkaccessible_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkWidget ----------- */


#define  NspGtkWidget_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkwidget.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkWidget inherits from GObject 
 * and implements GtkBuildable
 */

int nsp_type_gtkwidget_id=0;
NspTypeGtkWidget *nsp_type_gtkwidget=NULL;

/*
 * Type object for NspGtkWidget 
 * all the instance of NspTypeGtkWidget share the same id. 
 * nsp_type_gtkwidget: is an instance of NspTypeGtkWidget 
 *    used for objects of NspGtkWidget type (i.e built with new_gtkwidget) 
 * other instances are used for derived classes 
 */
NspTypeGtkWidget *new_type_gtkwidget(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkWidget *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkwidget != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkwidget;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkwidget_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkwidget_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkwidget;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkwidget */ 

  top->s_type =  (s_type_func *) nsp_gtkwidget_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkwidget_type_short_string;
  /* top->create = (create_func*) int_gtkwidget_create;*/

  /* specific methods for gtkwidget */

  type->init = (init_func *) init_gtkwidget;

  /* 
   * NspGtkWidget interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkwidget_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkWidget called nsp_type_gtkwidget
       */
      type->id =  nsp_type_gtkwidget_id = nsp_new_type_id();
      nsp_type_gtkwidget = type;
      if ( nsp_register_type(nsp_type_gtkwidget) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkwidget, GTK_TYPE_WIDGET);
      return ( mode == T_BASE ) ? type : new_type_gtkwidget(mode);
    }
  else 
    {
      type->id = nsp_type_gtkwidget_id;
      return type;
    }
}

/*
 * initialize NspGtkWidget instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkwidget(NspGtkWidget *Obj,NspTypeGtkWidget *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkWidget 
 */

NspGtkWidget *new_gtkwidget() 
{
  NspGtkWidget *loc;
  /* type must exists */
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkWidget)))== NULLGTKWIDGET) return loc;
  /* initialize object */
  if ( init_gtkwidget(loc,nsp_type_gtkwidget) == FAIL) return NULLGTKWIDGET;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkWidget 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkwidget_type_name[]="GtkWidget";
static char gtkwidget_short_type_name[]="GtkWidget";

static char *nsp_gtkwidget_type_as_string(void)
{
  return(gtkwidget_type_name);
}

static char *nsp_gtkwidget_type_short_string(NspObject *v)
{
  return(gtkwidget_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkWidget objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkWidget   *nsp_gtkwidget_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkwidget_id)  == TRUE  ) return ((NspGtkWidget *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkwidget));
  return NULL;
}

int IsGtkWidgetObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkwidget_id);
}

int IsGtkWidget(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkwidget_id);
}

NspGtkWidget  *GetGtkWidgetCopy(Stack stack, int i)
{
  if (  GetGtkWidget(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkWidget  *GetGtkWidget(Stack stack, int i)
{
  NspGtkWidget *M;
  if (( M = nsp_gtkwidget_object(NthObj(i))) == NULLGTKWIDGET)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkWidget *gtkwidget_copy(NspGtkWidget *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwidget);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkwidget);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkWidget
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 521 "codegen-3.0/gtk.override"
extern int int_gobj_create(Stack stack,int rhs,int opt,int lhs);
static int
_wrap_gtk_widget_new(Stack stack, int rhs, int opt, int lhs)
{
  return int_gobj_create( stack, rhs, opt, lhs) ;
}

#line 64086 "gtk.c"


#line 636 "codegen-3.0/gtk.override"
static int
_wrap_gtk_widget_get_allocation(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAllocation allocation;
  NspObject *ret;
  gtk_widget_get_allocation(GTK_WIDGET(self->obj),&allocation);
  if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &allocation, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL)
     return RET_BUG;
  MoveObj(stack,1,ret);
  return 1;
}
#line 64101 "gtk.c"


static int _wrap_gtk_widget_destroy(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_destroy(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_unparent(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_unparent(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_show(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_show(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_hide(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_hide(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_show_now(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_show_now(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_show_all(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_show_all(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_set_no_show_all(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int no_show_all;
  if ( GetArgs(stack,rhs,opt,T,&no_show_all) == FAIL) return RET_BUG;
    gtk_widget_set_no_show_all(GTK_WIDGET(self->obj),no_show_all);
  return 0;
}

static int _wrap_gtk_widget_get_no_show_all(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_no_show_all(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_map(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_map(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_unmap(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_unmap(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_realize(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_realize(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_unrealize(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_unrealize(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_draw(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_cr) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_widget_draw(GTK_WIDGET(self->obj),cr);
  return 0;
}

static int _wrap_gtk_widget_queue_draw(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_queue_draw(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_queue_draw_area(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int,s_int, t_end};
  int x, y, width, height;
  if ( GetArgs(stack,rhs,opt,T,&x, &y, &width, &height) == FAIL) return RET_BUG;
    gtk_widget_queue_draw_area(GTK_WIDGET(self->obj),x,y,width,height);
  return 0;
}

static int _wrap_gtk_widget_queue_draw_region(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  cairo_region_t *region = NULL;
  NspObject *nsp_region = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_region) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_region, CAIRO_GOBJECT_TYPE_REGION))
      region = nspg_boxed_get(nsp_region, cairo_region_t);
  else {
      Scierror( "Error: region should be a cairo_region_t\n");
      return RET_BUG;
  }
    gtk_widget_queue_draw_region(GTK_WIDGET(self->obj),region);
  return 0;
}

static int _wrap_gtk_widget_queue_resize(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_queue_resize(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_queue_resize_no_redraw(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_queue_resize_no_redraw(GTK_WIDGET(self->obj));
  return 0;
}

#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_widget_get_frame_clock(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkFrameClock *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_frame_clock(GTK_WIDGET(self->obj));
  nsp_type_gdkframeclock = new_type_gdkframeclock(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkframeclock))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_widget_get_frame_clock(Stack stack, int rhs, int opt, int lhs) /* get_frame_clock */
{
  Scierror("Error: function gtk_widget_get_frame_clock not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_widget_size_allocate(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkRectangle allocation = { 0, 0, 0, 0 };
  NspObject *nsp_allocation;
  if ( GetArgs(stack,rhs,opt,T,&nsp_allocation) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_allocation, &allocation))
      return RET_BUG;
    gtk_widget_size_allocate(GTK_WIDGET(self->obj),&allocation);
  return 0;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_widget_size_allocate_with_baseline(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int, t_end};
  GdkRectangle allocation = { 0, 0, 0, 0 };
  NspObject *nsp_allocation;
  int baseline;
  if ( GetArgs(stack,rhs,opt,T,&nsp_allocation, &baseline) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_allocation, &allocation))
      return RET_BUG;
    gtk_widget_size_allocate_with_baseline(GTK_WIDGET(self->obj),&allocation,baseline);
  return 0;
}

#else
int _wrap_gtk_widget_size_allocate_with_baseline(Stack stack, int rhs, int opt, int lhs) /* size_allocate_with_baseline */
{
  Scierror("Error: function gtk_widget_size_allocate_with_baseline not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_widget_get_request_mode(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_request_mode(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_get_preferred_width(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int minimum_width, natural_width;
  if ( GetArgs(stack,rhs,opt,T,&minimum_width, &natural_width) == FAIL) return RET_BUG;
    gtk_widget_get_preferred_width(GTK_WIDGET(self->obj),&minimum_width,&natural_width);
  return 0;
}

static int _wrap_gtk_widget_get_preferred_height_for_width(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int, t_end};
  int width, minimum_height, natural_height;
  if ( GetArgs(stack,rhs,opt,T,&width, &minimum_height, &natural_height) == FAIL) return RET_BUG;
    gtk_widget_get_preferred_height_for_width(GTK_WIDGET(self->obj),width,&minimum_height,&natural_height);
  return 0;
}

static int _wrap_gtk_widget_get_preferred_height(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int minimum_height, natural_height;
  if ( GetArgs(stack,rhs,opt,T,&minimum_height, &natural_height) == FAIL) return RET_BUG;
    gtk_widget_get_preferred_height(GTK_WIDGET(self->obj),&minimum_height,&natural_height);
  return 0;
}

static int _wrap_gtk_widget_get_preferred_width_for_height(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int, t_end};
  int height, minimum_width, natural_width;
  if ( GetArgs(stack,rhs,opt,T,&height, &minimum_width, &natural_width) == FAIL) return RET_BUG;
    gtk_widget_get_preferred_width_for_height(GTK_WIDGET(self->obj),height,&minimum_width,&natural_width);
  return 0;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_widget_get_preferred_height_and_baseline_for_width(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int,s_int,s_int,s_int, t_end};
  int width, minimum_height, natural_height, minimum_baseline, natural_baseline;
  if ( GetArgs(stack,rhs,opt,T,&width, &minimum_height, &natural_height, &minimum_baseline, &natural_baseline) == FAIL) return RET_BUG;
    gtk_widget_get_preferred_height_and_baseline_for_width(GTK_WIDGET(self->obj),width,&minimum_height,&natural_height,&minimum_baseline,&natural_baseline);
  return 0;
}

#else
int _wrap_gtk_widget_get_preferred_height_and_baseline_for_width(Stack stack, int rhs, int opt, int lhs) /* get_preferred_height_and_baseline_for_width */
{
  Scierror("Error: function gtk_widget_get_preferred_height_and_baseline_for_width not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_widget_get_preferred_size(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkRequisition *minimum_size = NULL, *natural_size = NULL;
  NspObject *nsp_minimum_size = NULL, *nsp_natural_size = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_minimum_size, &nsp_natural_size) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_minimum_size, GTK_TYPE_REQUISITION))
      minimum_size = nspg_boxed_get(nsp_minimum_size, GtkRequisition);
  else {
      Scierror( "Error: minimum_size should be a GtkRequisition\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_natural_size, GTK_TYPE_REQUISITION))
      natural_size = nspg_boxed_get(nsp_natural_size, GtkRequisition);
  else {
      Scierror( "Error: natural_size should be a GtkRequisition\n");
      return RET_BUG;
  }
    gtk_widget_get_preferred_size(GTK_WIDGET(self->obj),minimum_size,natural_size);
  return 0;
}

#line 583 "codegen-3.0/gtk.override"
/* adding the case where the accelerator is transmited as a string to be decoded */

static int _wrap_gtk_widget_add_string_accelerator(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs);

static int _wrap_gtk_widget_add_accelerator(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj_check, s_int, obj, obj,t_end};
  NspObject *nsp_accel_mods = NULL, *nsp_accel_flags = NULL;
  int accel_key;
  NspGObject *accel_group;
  GdkModifierType accel_mods;
  GtkAccelFlags accel_flags;
  char *accel_signal;
  if ( rhs == 4 )  return _wrap_gtk_widget_add_string_accelerator(self,stack,rhs,opt,lhs);
  if ( GetArgs(stack,rhs,opt,T,&accel_signal, &nsp_type_gtkaccelgroup, &accel_group, &accel_key, &nsp_accel_mods, &nsp_accel_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accel_mods, &accel_mods)==FAIL)
      return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ACCEL_FLAGS, nsp_accel_flags, &accel_flags)==FAIL)
      return RET_BUG;
  gtk_widget_add_accelerator(GTK_WIDGET(self->obj), accel_signal, GTK_ACCEL_GROUP(accel_group->obj), accel_key, accel_mods, accel_flags);
  return 0;
}

/* added */
static int _wrap_gtk_widget_add_string_accelerator(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, obj_check,string , obj,t_end};
  NspObject *nsp_accel_flags = NULL;
  guint accel_key;
  NspGObject *accel_group;
  GdkModifierType accel_mods;
  GtkAccelFlags accel_flags;
  char *accel_signal;
  char *accel_string;

  if ( GetArgs(stack,rhs,opt,T,&accel_signal, &nsp_type_gtkaccelgroup, &accel_group,&accel_string,
	       &nsp_accel_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ACCEL_FLAGS, nsp_accel_flags, &accel_flags)==FAIL)
    return RET_BUG;
  gtk_accelerator_parse (accel_string, &accel_key, &accel_mods);
  if ( accel_key == 0 && accel_mods == 0)
    {
      Scierror("Error: invalid accelerator %s\n",accel_string);
      return RET_BUG;
    }
  gtk_widget_add_accelerator(GTK_WIDGET(self->obj), accel_signal, GTK_ACCEL_GROUP(accel_group->obj), accel_key, accel_mods, accel_flags);
  return 0;
}



#line 64443 "gtk.c"


static int _wrap_gtk_widget_remove_accelerator(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,obj, t_end};
  NspGObject *accel_group;
  int accel_key, ret;
  GdkModifierType accel_mods;
  NspObject *nsp_accel_mods = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaccelgroup, &accel_group, &accel_key, &nsp_accel_mods) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accel_mods, &accel_mods)==FAIL)
      return RET_BUG;
    ret =gtk_widget_remove_accelerator(GTK_WIDGET(self->obj),GTK_ACCEL_GROUP(accel_group->obj),accel_key,accel_mods);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_accel_path(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj_check, t_end};
  char *accel_path;
  NspGObject *accel_group;
  if ( GetArgs(stack,rhs,opt,T,&accel_path, &nsp_type_gtkaccelgroup, &accel_group) == FAIL) return RET_BUG;
    gtk_widget_set_accel_path(GTK_WIDGET(self->obj),accel_path,GTK_ACCEL_GROUP(accel_group->obj));
  return 0;
}

static int _wrap_gtk_widget_list_accel_closures(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_widget_list_accel_closures(GTK_WIDGET(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

static int _wrap_gtk_widget_can_activate_accel(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int signal_id, ret;
  if ( GetArgs(stack,rhs,opt,T,&signal_id) == FAIL) return RET_BUG;
    ret =gtk_widget_can_activate_accel(GTK_WIDGET(self->obj),signal_id);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_mnemonic_activate(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int group_cycling, ret;
  if ( GetArgs(stack,rhs,opt,T,&group_cycling) == FAIL) return RET_BUG;
    ret =gtk_widget_mnemonic_activate(GTK_WIDGET(self->obj),group_cycling);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_event(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    ret =gtk_widget_event(GTK_WIDGET(self->obj),event);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_send_expose(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    ret =gtk_widget_send_expose(GTK_WIDGET(self->obj),event);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_send_focus_change(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    ret =gtk_widget_send_focus_change(GTK_WIDGET(self->obj),event);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_activate(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_activate(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_widget_reparent(Stack stack, int rhs, int opt, int lhs) /* reparent */
{
  Scierror("Error: function gtk_widget_reparent is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_widget_reparent(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *new_parent;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &new_parent) == FAIL) return RET_BUG;
    gtk_widget_reparent(GTK_WIDGET(self->obj),GTK_WIDGET(new_parent->obj));
  return 0;
}

#endif
#line 649 "codegen-3.0/gtk.override"
static int
_wrap_gtk_widget_intersect(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "area", NULL };*/
  NspObject *nsp_area, * ret;
  GdkRectangle area, intersect;

  if(GetArgs(stack,rhs,opt,T, &nsp_area) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_area, &area))  return RET_BUG;
  if (gtk_widget_intersect(GTK_WIDGET(self->obj), &area, &intersect))
    {
      if ((ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_RECTANGLE, &intersect, TRUE, TRUE,(NspTypeBase *) nsp_type_gdkrectangle)) == NULL)
	return RET_BUG;
      MoveObj(stack,1,ret);
      return 1;
    }
  else
    return RET_BUG;
}
#line 64602 "gtk.c"


#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_widget_region_intersect(Stack stack, int rhs, int opt, int lhs) /* region_intersect */
{
  Scierror("Error: function gtk_widget_region_intersect is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_widget_region_intersect(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  cairo_region_t *region = NULL, *ret;
  NspObject *nsp_region = NULL, *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_region) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_region, CAIRO_GOBJECT_TYPE_REGION))
      region = nspg_boxed_get(nsp_region, cairo_region_t);
  else {
      Scierror( "Error: region should be a cairo_region_t\n");
      return RET_BUG;
  }
    ret =gtk_widget_region_intersect(GTK_WIDGET(self->obj),region);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,CAIRO_GOBJECT_TYPE_REGION, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_cairo_region_t))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#endif
static int _wrap_gtk_widget_freeze_child_notify(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_freeze_child_notify(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_child_notify(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *child_property;
  if ( GetArgs(stack,rhs,opt,T,&child_property) == FAIL) return RET_BUG;
    gtk_widget_child_notify(GTK_WIDGET(self->obj),child_property);
  return 0;
}

static int _wrap_gtk_widget_thaw_child_notify(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_thaw_child_notify(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_set_can_focus(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int can_focus;
  if ( GetArgs(stack,rhs,opt,T,&can_focus) == FAIL) return RET_BUG;
    gtk_widget_set_can_focus(GTK_WIDGET(self->obj),can_focus);
  return 0;
}

static int _wrap_gtk_widget_get_can_focus(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_can_focus(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_has_focus(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_has_focus(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_is_focus(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_is_focus(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_widget_has_visible_focus(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_has_visible_focus(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_widget_has_visible_focus(Stack stack, int rhs, int opt, int lhs) /* has_visible_focus */
{
  Scierror("Error: function gtk_widget_has_visible_focus not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_widget_grab_focus(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_grab_focus(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_set_can_default(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int can_default;
  if ( GetArgs(stack,rhs,opt,T,&can_default) == FAIL) return RET_BUG;
    gtk_widget_set_can_default(GTK_WIDGET(self->obj),can_default);
  return 0;
}

static int _wrap_gtk_widget_get_can_default(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_can_default(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_has_default(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_has_default(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_grab_default(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_grab_default(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_set_receives_default(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int receives_default;
  if ( GetArgs(stack,rhs,opt,T,&receives_default) == FAIL) return RET_BUG;
    gtk_widget_set_receives_default(GTK_WIDGET(self->obj),receives_default);
  return 0;
}

static int _wrap_gtk_widget_get_receives_default(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_receives_default(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_has_grab(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_has_grab(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_device_is_shadowed(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *device;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdevice, &device) == FAIL) return RET_BUG;
    ret =gtk_widget_device_is_shadowed(GTK_WIDGET(self->obj),GDK_DEVICE(device->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_name(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_widget_set_name(GTK_WIDGET(self->obj),name);
  return 0;
}

static int _wrap_gtk_widget_get_name(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_name(GTK_WIDGET(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_state_flags(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_bool, t_end};
  GtkStateFlags flags;
  NspObject *nsp_flags = NULL;
  int clear;
  if ( GetArgs(stack,rhs,opt,T,&nsp_flags, &clear) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_STATE_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    gtk_widget_set_state_flags(GTK_WIDGET(self->obj),flags,clear);
  return 0;
}

static int _wrap_gtk_widget_unset_state_flags(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkStateFlags flags;
  NspObject *nsp_flags = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_STATE_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    gtk_widget_unset_state_flags(GTK_WIDGET(self->obj),flags);
  return 0;
}

static int _wrap_gtk_widget_get_state_flags(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_state_flags(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_sensitive(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int sensitive;
  if ( GetArgs(stack,rhs,opt,T,&sensitive) == FAIL) return RET_BUG;
    gtk_widget_set_sensitive(GTK_WIDGET(self->obj),sensitive);
  return 0;
}

static int _wrap_gtk_widget_get_sensitive(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_sensitive(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_is_sensitive(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_is_sensitive(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_visible(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int visible;
  if ( GetArgs(stack,rhs,opt,T,&visible) == FAIL) return RET_BUG;
    gtk_widget_set_visible(GTK_WIDGET(self->obj),visible);
  return 0;
}

static int _wrap_gtk_widget_get_visible(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_visible(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_is_visible(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_is_visible(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_has_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int has_window;
  if ( GetArgs(stack,rhs,opt,T,&has_window) == FAIL) return RET_BUG;
    gtk_widget_set_has_window(GTK_WIDGET(self->obj),has_window);
  return 0;
}

static int _wrap_gtk_widget_get_has_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_has_window(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_is_toplevel(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_is_toplevel(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_is_drawable(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_is_drawable(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_realized(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int realized;
  if ( GetArgs(stack,rhs,opt,T,&realized) == FAIL) return RET_BUG;
    gtk_widget_set_realized(GTK_WIDGET(self->obj),realized);
  return 0;
}

static int _wrap_gtk_widget_get_realized(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_realized(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_mapped(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int mapped;
  if ( GetArgs(stack,rhs,opt,T,&mapped) == FAIL) return RET_BUG;
    gtk_widget_set_mapped(GTK_WIDGET(self->obj),mapped);
  return 0;
}

static int _wrap_gtk_widget_get_mapped(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_mapped(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_app_paintable(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int app_paintable;
  if ( GetArgs(stack,rhs,opt,T,&app_paintable) == FAIL) return RET_BUG;
    gtk_widget_set_app_paintable(GTK_WIDGET(self->obj),app_paintable);
  return 0;
}

static int _wrap_gtk_widget_get_app_paintable(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_app_paintable(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_widget_set_double_buffered(Stack stack, int rhs, int opt, int lhs) /* set_double_buffered */
{
  Scierror("Error: function gtk_widget_set_double_buffered is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_widget_set_double_buffered(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int double_buffered;
  if ( GetArgs(stack,rhs,opt,T,&double_buffered) == FAIL) return RET_BUG;
    gtk_widget_set_double_buffered(GTK_WIDGET(self->obj),double_buffered);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_widget_get_double_buffered(Stack stack, int rhs, int opt, int lhs) /* get_double_buffered */
{
  Scierror("Error: function gtk_widget_get_double_buffered is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_widget_get_double_buffered(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_double_buffered(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
static int _wrap_gtk_widget_set_redraw_on_allocate(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int redraw_on_allocate;
  if ( GetArgs(stack,rhs,opt,T,&redraw_on_allocate) == FAIL) return RET_BUG;
    gtk_widget_set_redraw_on_allocate(GTK_WIDGET(self->obj),redraw_on_allocate);
  return 0;
}

static int _wrap_gtk_widget_set_parent(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *parent;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &parent) == FAIL) return RET_BUG;
    gtk_widget_set_parent(GTK_WIDGET(self->obj),GTK_WIDGET(parent->obj));
  return 0;
}

#line 685 "codegen-3.0/gtk.override"
/* the returned value is more specific than nsp_type_gtkwidget */
static int
_wrap_gtk_widget_get_parent(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWidget *ret;
  CheckRhs(0,0);
  ret = gtk_widget_get_parent(GTK_WIDGET(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new(NVOID,(GObject *)ret))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 65051 "gtk.c"


static int _wrap_gtk_widget_set_parent_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *parent_window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &parent_window) == FAIL) return RET_BUG;
    gtk_widget_set_parent_window(GTK_WIDGET(self->obj),GDK_WINDOW(parent_window->obj));
  return 0;
}

static int _wrap_gtk_widget_get_parent_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_parent_window(GTK_WIDGET(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_set_child_visible(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int is_visible;
  if ( GetArgs(stack,rhs,opt,T,&is_visible) == FAIL) return RET_BUG;
    gtk_widget_set_child_visible(GTK_WIDGET(self->obj),is_visible);
  return 0;
}

static int _wrap_gtk_widget_get_child_visible(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_child_visible(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window) == FAIL) return RET_BUG;
    gtk_widget_set_window(GTK_WIDGET(self->obj),GDK_WINDOW(window->obj));
  return 0;
}

static int _wrap_gtk_widget_get_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_window(GTK_WIDGET(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_widget_register_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window) == FAIL) return RET_BUG;
    gtk_widget_register_window(GTK_WIDGET(self->obj),GDK_WINDOW(window->obj));
  return 0;
}

#else
int _wrap_gtk_widget_register_window(Stack stack, int rhs, int opt, int lhs) /* register_window */
{
  Scierror("Error: function gtk_widget_register_window not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_widget_unregister_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window) == FAIL) return RET_BUG;
    gtk_widget_unregister_window(GTK_WIDGET(self->obj),GDK_WINDOW(window->obj));
  return 0;
}

#else
int _wrap_gtk_widget_unregister_window(Stack stack, int rhs, int opt, int lhs) /* unregister_window */
{
  Scierror("Error: function gtk_widget_unregister_window not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_widget_get_allocated_width(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_allocated_width(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_get_allocated_height(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_allocated_height(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_widget_get_allocated_baseline(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_allocated_baseline(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_widget_get_allocated_baseline(Stack stack, int rhs, int opt, int lhs) /* get_allocated_baseline */
{
  Scierror("Error: function gtk_widget_get_allocated_baseline not available\n");
  return RET_BUG;
}
#endif


#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_widget_get_clip(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkRectangle clip = { 0, 0, 0, 0 };
  NspObject *nsp_clip;
  if ( GetArgs(stack,rhs,opt,T,&nsp_clip) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_clip, &clip))
      return RET_BUG;
    gtk_widget_get_clip(GTK_WIDGET(self->obj),&clip);
  return 0;
}

#else
int _wrap_gtk_widget_get_clip(Stack stack, int rhs, int opt, int lhs) /* get_clip */
{
  Scierror("Error: function gtk_widget_get_clip not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_widget_child_focus(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkDirectionType direction;
  NspObject *nsp_direction = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_direction) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_DIRECTION_TYPE, nsp_direction, &direction)== FAIL)
      return RET_BUG;
    ret =gtk_widget_child_focus(GTK_WIDGET(self->obj),direction);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_keynav_failed(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkDirectionType direction;
  NspObject *nsp_direction = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_direction) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_DIRECTION_TYPE, nsp_direction, &direction)== FAIL)
      return RET_BUG;
    ret =gtk_widget_keynav_failed(GTK_WIDGET(self->obj),direction);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_error_bell(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_error_bell(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_set_size_request(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int width, height;
  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
    gtk_widget_set_size_request(GTK_WIDGET(self->obj),width,height);
  return 0;
}

static int _wrap_gtk_widget_get_size_request(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int width, height;
  if ( GetArgs(stack,rhs,opt,T,&width, &height) == FAIL) return RET_BUG;
    gtk_widget_get_size_request(GTK_WIDGET(self->obj),&width,&height);
  return 0;
}

static int _wrap_gtk_widget_set_events(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int events;
  if ( GetArgs(stack,rhs,opt,T,&events) == FAIL) return RET_BUG;
    gtk_widget_set_events(GTK_WIDGET(self->obj),events);
  return 0;
}

static int _wrap_gtk_widget_add_events(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int events;
  if ( GetArgs(stack,rhs,opt,T,&events) == FAIL) return RET_BUG;
    gtk_widget_add_events(GTK_WIDGET(self->obj),events);
  return 0;
}

static int _wrap_gtk_widget_set_device_events(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *device;
  GdkEventMask events;
  NspObject *nsp_events = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdevice, &device, &nsp_events) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_EVENT_MASK, nsp_events, &events)==FAIL)
      return RET_BUG;
    gtk_widget_set_device_events(GTK_WIDGET(self->obj),GDK_DEVICE(device->obj),events);
  return 0;
}

static int _wrap_gtk_widget_add_device_events(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *device;
  GdkEventMask events;
  NspObject *nsp_events = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdevice, &device, &nsp_events) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_EVENT_MASK, nsp_events, &events)==FAIL)
      return RET_BUG;
    gtk_widget_add_device_events(GTK_WIDGET(self->obj),GDK_DEVICE(device->obj),events);
  return 0;
}

#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_widget_set_opacity(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double opacity;
  if ( GetArgs(stack,rhs,opt,T,&opacity) == FAIL) return RET_BUG;
    gtk_widget_set_opacity(GTK_WIDGET(self->obj),opacity);
  return 0;
}

#else
int _wrap_gtk_widget_set_opacity(Stack stack, int rhs, int opt, int lhs) /* set_opacity */
{
  Scierror("Error: function gtk_widget_set_opacity not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_widget_get_opacity(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_opacity(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_widget_get_opacity(Stack stack, int rhs, int opt, int lhs) /* get_opacity */
{
  Scierror("Error: function gtk_widget_get_opacity not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_widget_set_device_enabled(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *device;
  int enabled;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdevice, &device, &enabled) == FAIL) return RET_BUG;
    gtk_widget_set_device_enabled(GTK_WIDGET(self->obj),GDK_DEVICE(device->obj),enabled);
  return 0;
}

static int _wrap_gtk_widget_get_device_enabled(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *device;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdevice, &device) == FAIL) return RET_BUG;
    ret =gtk_widget_get_device_enabled(GTK_WIDGET(self->obj),GDK_DEVICE(device->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 671 "codegen-3.0/gtk.override"
static int _wrap_gtk_widget_get_toplevel(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  GtkWindow *ret;

  ret = (GtkWindow *) gtk_widget_get_toplevel(GTK_WIDGET(self->obj));
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 65370 "gtk.c"


static int _wrap_gtk_widget_get_ancestor(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GType widget_type;
  NspObject *nsp_widget_type = NULL, *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_widget_type) == FAIL) return RET_BUG;
  if ((widget_type = nspg_type_from_object(nsp_widget_type)) == FAIL)
      return RET_BUG;
    ret =gtk_widget_get_ancestor(GTK_WIDGET(self->obj),widget_type);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_visual(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkVisual *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_visual(GTK_WIDGET(self->obj));
  nsp_type_gdkvisual = new_type_gdkvisual(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkvisual))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_set_visual(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *visual;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkvisual, &visual) == FAIL) return RET_BUG;
    gtk_widget_set_visual(GTK_WIDGET(self->obj),GDK_VISUAL(visual->obj));
  return 0;
}

static int _wrap_gtk_widget_get_screen(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkScreen *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_screen(GTK_WIDGET(self->obj));
  nsp_type_gdkscreen = new_type_gdkscreen(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkscreen))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_has_screen(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_has_screen(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_widget_get_scale_factor(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_scale_factor(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_widget_get_scale_factor(Stack stack, int rhs, int opt, int lhs) /* get_scale_factor */
{
  Scierror("Error: function gtk_widget_get_scale_factor not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_widget_get_display(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkDisplay *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_display(GTK_WIDGET(self->obj));
  nsp_type_gdkdisplay = new_type_gdkdisplay(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkdisplay))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,12,0)
int _wrap_gtk_widget_get_root_window(Stack stack, int rhs, int opt, int lhs) /* get_root_window */
{
  Scierror("Error: function gtk_widget_get_root_window is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_widget_get_root_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_root_window(GTK_WIDGET(self->obj));
  nsp_type_gdkwindow = new_type_gdkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#endif
static int _wrap_gtk_widget_get_settings(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkSettings *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_settings(GTK_WIDGET(self->obj));
  nsp_type_gtksettings = new_type_gtksettings(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtksettings))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_clipboard(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkAtom selection;
  NspObject *nsp_selection = NULL, *nsp_ret;
  GtkClipboard *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_selection) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection,&selection)==FAIL) return RET_BUG;
    ret =gtk_widget_get_clipboard(GTK_WIDGET(self->obj),selection);
  nsp_type_gtkclipboard = new_type_gtkclipboard(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkclipboard))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_hexpand(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_hexpand(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_hexpand(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int expand;
  if ( GetArgs(stack,rhs,opt,T,&expand) == FAIL) return RET_BUG;
    gtk_widget_set_hexpand(GTK_WIDGET(self->obj),expand);
  return 0;
}

static int _wrap_gtk_widget_get_hexpand_set(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_hexpand_set(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_hexpand_set(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int set;
  if ( GetArgs(stack,rhs,opt,T,&set) == FAIL) return RET_BUG;
    gtk_widget_set_hexpand_set(GTK_WIDGET(self->obj),set);
  return 0;
}

static int _wrap_gtk_widget_get_vexpand(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_vexpand(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_vexpand(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int expand;
  if ( GetArgs(stack,rhs,opt,T,&expand) == FAIL) return RET_BUG;
    gtk_widget_set_vexpand(GTK_WIDGET(self->obj),expand);
  return 0;
}

static int _wrap_gtk_widget_get_vexpand_set(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_vexpand_set(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_vexpand_set(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int set;
  if ( GetArgs(stack,rhs,opt,T,&set) == FAIL) return RET_BUG;
    gtk_widget_set_vexpand_set(GTK_WIDGET(self->obj),set);
  return 0;
}

static int _wrap_gtk_widget_queue_compute_expand(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_queue_compute_expand(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_compute_expand(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkOrientation orientation;
  NspObject *nsp_orientation = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_orientation) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
    ret =gtk_widget_compute_expand(GTK_WIDGET(self->obj),orientation);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_get_support_multidevice(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_support_multidevice(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_support_multidevice(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int support_multidevice;
  if ( GetArgs(stack,rhs,opt,T,&support_multidevice) == FAIL) return RET_BUG;
    gtk_widget_set_support_multidevice(GTK_WIDGET(self->obj),support_multidevice);
  return 0;
}

static int _wrap_gtk_widget_get_accessible(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  AtkObject *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_accessible(GTK_WIDGET(self->obj));
  nsp_type_atkobject = new_type_atkobject(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_atkobject))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_halign(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_halign(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_halign(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkAlign align;
  NspObject *nsp_align = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_align) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ALIGN, nsp_align, &align)== FAIL)
      return RET_BUG;
    gtk_widget_set_halign(GTK_WIDGET(self->obj),align);
  return 0;
}

static int _wrap_gtk_widget_get_valign(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_valign(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_widget_get_valign_with_baseline(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_valign_with_baseline(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_widget_get_valign_with_baseline(Stack stack, int rhs, int opt, int lhs) /* get_valign_with_baseline */
{
  Scierror("Error: function gtk_widget_get_valign_with_baseline not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_widget_set_valign(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkAlign align;
  NspObject *nsp_align = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_align) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ALIGN, nsp_align, &align)== FAIL)
      return RET_BUG;
    gtk_widget_set_valign(GTK_WIDGET(self->obj),align);
  return 0;
}

#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_widget_get_margin_start(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_margin_start(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_widget_get_margin_start(Stack stack, int rhs, int opt, int lhs) /* get_margin_start */
{
  Scierror("Error: function gtk_widget_get_margin_start not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_widget_set_margin_start(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int margin;
  if ( GetArgs(stack,rhs,opt,T,&margin) == FAIL) return RET_BUG;
    gtk_widget_set_margin_start(GTK_WIDGET(self->obj),margin);
  return 0;
}

#else
int _wrap_gtk_widget_set_margin_start(Stack stack, int rhs, int opt, int lhs) /* set_margin_start */
{
  Scierror("Error: function gtk_widget_set_margin_start not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_widget_get_margin_end(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_margin_end(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_widget_get_margin_end(Stack stack, int rhs, int opt, int lhs) /* get_margin_end */
{
  Scierror("Error: function gtk_widget_get_margin_end not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,12,0)
static int _wrap_gtk_widget_set_margin_end(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int margin;
  if ( GetArgs(stack,rhs,opt,T,&margin) == FAIL) return RET_BUG;
    gtk_widget_set_margin_end(GTK_WIDGET(self->obj),margin);
  return 0;
}

#else
int _wrap_gtk_widget_set_margin_end(Stack stack, int rhs, int opt, int lhs) /* set_margin_end */
{
  Scierror("Error: function gtk_widget_set_margin_end not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_widget_get_margin_top(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_margin_top(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_margin_top(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int margin;
  if ( GetArgs(stack,rhs,opt,T,&margin) == FAIL) return RET_BUG;
    gtk_widget_set_margin_top(GTK_WIDGET(self->obj),margin);
  return 0;
}

static int _wrap_gtk_widget_get_margin_bottom(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_margin_bottom(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_set_margin_bottom(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int margin;
  if ( GetArgs(stack,rhs,opt,T,&margin) == FAIL) return RET_BUG;
    gtk_widget_set_margin_bottom(GTK_WIDGET(self->obj),margin);
  return 0;
}

static int _wrap_gtk_widget_get_events(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_events(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_get_device_events(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *device;
  guint ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdevice, &device) == FAIL) return RET_BUG;
    ret =gtk_widget_get_device_events(GTK_WIDGET(self->obj),GDK_DEVICE(device->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_is_ancestor(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *ancestor;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &ancestor) == FAIL) return RET_BUG;
    ret =gtk_widget_is_ancestor(GTK_WIDGET(self->obj),GTK_WIDGET(ancestor->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 530 "codegen-3.0/gtk.override"
static int
_wrap_gtk_widget_translate_coordinates(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_int,s_int, t_end} ;
  /* static char *kwlist[] = { "dest_widget", "src_x", "src_y", NULL };*/
  NspGObject *nsp_dest_widget;
  int src_x, src_y;
  GtkWidget *dest_widget = NULL;
  int dest_x, dest_y;

  if (GetArgs(stack,rhs,opt,T, &nsp_dest_widget, &src_x, &src_y) == FAIL) return RET_BUG;

  if (nspgobject_check( nsp_dest_widget, (NspTypeBase *) nsp_type_gtkwidget)) {
    dest_widget = GTK_WIDGET(nspgobject_get(nsp_dest_widget));
  } else if ( ! IsNone((NspObject *)nsp_dest_widget)) {
    Scierror("dest_widget must be a GtkWidget or None");
    return RET_BUG;
  }

  if (!gtk_widget_translate_coordinates(GTK_WIDGET(self->obj),dest_widget,src_x,src_y,&dest_x,&dest_y))
    {
      if ( nsp_move_doubles(stack,1,0,0) == FAIL) return RET_BUG;
    }
  else
    {
      if ( nsp_move_doubles(stack,1,1,2,(double) dest_x,(double) dest_y) == FAIL) return RET_BUG;
    }
  return 1;
}
#line 65854 "gtk.c"


static int _wrap_gtk_widget_hide_on_delete(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_hide_on_delete(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,16,0)
int _wrap_gtk_widget_override_color(Stack stack, int rhs, int opt, int lhs) /* override_color */
{
  Scierror("Error: function gtk_widget_override_color is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_widget_override_color(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkStateFlags state;
  NspObject *nsp_state = NULL, *nsp_color = NULL;
  GdkRGBA *color = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_state, &nsp_color) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_STATE_FLAGS, nsp_state, &state)==FAIL)
      return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_RGBA))
      color = nspg_boxed_get(nsp_color, GdkRGBA);
  else {
      Scierror( "Error: color should be a GdkRGBA\n");
      return RET_BUG;
  }
    gtk_widget_override_color(GTK_WIDGET(self->obj),state,color);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,16,0)
int _wrap_gtk_widget_override_background_color(Stack stack, int rhs, int opt, int lhs) /* override_background_color */
{
  Scierror("Error: function gtk_widget_override_background_color is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_widget_override_background_color(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkStateFlags state;
  NspObject *nsp_state = NULL, *nsp_color = NULL;
  GdkRGBA *color = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_state, &nsp_color) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_STATE_FLAGS, nsp_state, &state)==FAIL)
      return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_RGBA))
      color = nspg_boxed_get(nsp_color, GdkRGBA);
  else {
      Scierror( "Error: color should be a GdkRGBA\n");
      return RET_BUG;
  }
    gtk_widget_override_background_color(GTK_WIDGET(self->obj),state,color);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,16,0)
int _wrap_gtk_widget_override_font(Stack stack, int rhs, int opt, int lhs) /* override_font */
{
  Scierror("Error: function gtk_widget_override_font is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_widget_override_font(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  PangoFontDescription *font_desc = NULL;
  NspObject *nsp_font_desc = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_font_desc) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_font_desc, PANGO_TYPE_FONT_DESCRIPTION))
      font_desc = nspg_boxed_get(nsp_font_desc, PangoFontDescription);
  else {
      Scierror( "Error: font_desc should be a PangoFontDescription\n");
      return RET_BUG;
  }
    gtk_widget_override_font(GTK_WIDGET(self->obj),font_desc);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,16,0)
int _wrap_gtk_widget_override_symbolic_color(Stack stack, int rhs, int opt, int lhs) /* override_symbolic_color */
{
  Scierror("Error: function gtk_widget_override_symbolic_color is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_widget_override_symbolic_color(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *name;
  GdkRGBA *color = NULL;
  NspObject *nsp_color = NULL;
  if ( GetArgs(stack,rhs,opt,T,&name, &nsp_color) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_RGBA))
      color = nspg_boxed_get(nsp_color, GdkRGBA);
  else {
      Scierror( "Error: color should be a GdkRGBA\n");
      return RET_BUG;
  }
    gtk_widget_override_symbolic_color(GTK_WIDGET(self->obj),name,color);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,16,0)
int _wrap_gtk_widget_override_cursor(Stack stack, int rhs, int opt, int lhs) /* override_cursor */
{
  Scierror("Error: function gtk_widget_override_cursor is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_widget_override_cursor(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GdkRGBA *cursor = NULL, *secondary_cursor = NULL;
  NspObject *nsp_cursor = NULL, *nsp_secondary_cursor = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_cursor, &nsp_secondary_cursor) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cursor, GDK_TYPE_RGBA))
      cursor = nspg_boxed_get(nsp_cursor, GdkRGBA);
  else {
      Scierror( "Error: cursor should be a GdkRGBA\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_secondary_cursor, GDK_TYPE_RGBA))
      secondary_cursor = nspg_boxed_get(nsp_secondary_cursor, GdkRGBA);
  else {
      Scierror( "Error: secondary_cursor should be a GdkRGBA\n");
      return RET_BUG;
  }
    gtk_widget_override_cursor(GTK_WIDGET(self->obj),cursor,secondary_cursor);
  return 0;
}

#endif
static int _wrap_gtk_widget_reset_style(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_reset_style(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_create_pango_context(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoContext *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_create_pango_context(GTK_WIDGET(self->obj));
  nsp_type_pangocontext = new_type_pangocontext(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangocontext))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_get_pango_context(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  PangoContext *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_pango_context(GTK_WIDGET(self->obj));
  nsp_type_pangocontext = new_type_pangocontext(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangocontext))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_create_pango_layout(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  PangoLayout *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    ret =gtk_widget_create_pango_layout(GTK_WIDGET(self->obj),text);
  nsp_type_pangolayout = new_type_pangolayout(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_pangolayout))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_set_direction(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkTextDirection dir;
  NspObject *nsp_dir = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_dir) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, nsp_dir, &dir)== FAIL)
      return RET_BUG;
    gtk_widget_set_direction(GTK_WIDGET(self->obj),dir);
  return 0;
}

static int _wrap_gtk_widget_get_direction(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_direction(GTK_WIDGET(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_is_composited(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_is_composited(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_shape_combine_region(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  cairo_region_t *region = NULL;
  NspObject *nsp_region = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_region) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_region, CAIRO_GOBJECT_TYPE_REGION))
      region = nspg_boxed_get(nsp_region, cairo_region_t);
  else {
      Scierror( "Error: region should be a cairo_region_t\n");
      return RET_BUG;
  }
    gtk_widget_shape_combine_region(GTK_WIDGET(self->obj),region);
  return 0;
}

static int _wrap_gtk_widget_input_shape_combine_region(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  cairo_region_t *region = NULL;
  NspObject *nsp_region = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_region) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_region, CAIRO_GOBJECT_TYPE_REGION))
      region = nspg_boxed_get(nsp_region, cairo_region_t);
  else {
      Scierror( "Error: region should be a cairo_region_t\n");
      return RET_BUG;
  }
    gtk_widget_input_shape_combine_region(GTK_WIDGET(self->obj),region);
  return 0;
}

static int _wrap_gtk_widget_list_mnemonic_labels(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_widget_list_mnemonic_labels(GTK_WIDGET(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

static int _wrap_gtk_widget_add_mnemonic_label(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *label;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &label) == FAIL) return RET_BUG;
    gtk_widget_add_mnemonic_label(GTK_WIDGET(self->obj),GTK_WIDGET(label->obj));
  return 0;
}

static int _wrap_gtk_widget_remove_mnemonic_label(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *label;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &label) == FAIL) return RET_BUG;
    gtk_widget_remove_mnemonic_label(GTK_WIDGET(self->obj),GTK_WIDGET(label->obj));
  return 0;
}

static int _wrap_gtk_widget_set_tooltip_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *custom_window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &custom_window) == FAIL) return RET_BUG;
    gtk_widget_set_tooltip_window(GTK_WIDGET(self->obj),GTK_WINDOW(custom_window->obj));
  return 0;
}

static int _wrap_gtk_widget_get_tooltip_window(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWindow *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_tooltip_window(GTK_WIDGET(self->obj));
  nsp_type_gtkwindow = new_type_gtkwindow(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwindow))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_widget_trigger_tooltip_query(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_trigger_tooltip_query(GTK_WIDGET(self->obj));
  return 0;
}

static int _wrap_gtk_widget_set_tooltip_text(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    gtk_widget_set_tooltip_text(GTK_WIDGET(self->obj),text);
  return 0;
}

static int _wrap_gtk_widget_get_tooltip_text(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_tooltip_text(GTK_WIDGET(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_widget_set_tooltip_markup(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *markup;
  if ( GetArgs(stack,rhs,opt,T,&markup) == FAIL) return RET_BUG;
    gtk_widget_set_tooltip_markup(GTK_WIDGET(self->obj),markup);
  return 0;
}

static int _wrap_gtk_widget_get_tooltip_markup(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_tooltip_markup(GTK_WIDGET(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_widget_set_has_tooltip(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int has_tooltip;
  if ( GetArgs(stack,rhs,opt,T,&has_tooltip) == FAIL) return RET_BUG;
    gtk_widget_set_has_tooltip(GTK_WIDGET(self->obj),has_tooltip);
  return 0;
}

static int _wrap_gtk_widget_get_has_tooltip(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_has_tooltip(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_in_destruction(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_widget_in_destruction(GTK_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_widget_get_style_context(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkStyleContext *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_style_context(GTK_WIDGET(self->obj));
  nsp_type_gtkstylecontext = new_type_gtkstylecontext(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstylecontext))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_widget_get_modifier_mask(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkModifierIntent intent;
  NspObject *nsp_intent = NULL;
  guint ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_intent) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GDK_TYPE_MODIFIER_INTENT, nsp_intent, &intent)== FAIL)
      return RET_BUG;
    ret =gtk_widget_get_modifier_mask(GTK_WIDGET(self->obj),intent);
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_widget_get_modifier_mask(Stack stack, int rhs, int opt, int lhs) /* get_modifier_mask */
{
  Scierror("Error: function gtk_widget_get_modifier_mask not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_widget_insert_action_group(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj_check, t_end};
  char *name;
  NspGObject *group;
  if ( GetArgs(stack,rhs,opt,T,&name, &nsp_type_gactiongroup, &group) == FAIL) return RET_BUG;
    gtk_widget_insert_action_group(GTK_WIDGET(self->obj),name,G_ACTION_GROUP(group->obj));
  return 0;
}

#else
int _wrap_gtk_widget_insert_action_group(Stack stack, int rhs, int opt, int lhs) /* insert_action_group */
{
  Scierror("Error: function gtk_widget_insert_action_group not available\n");
  return RET_BUG;
}
#endif
#line 8142 "codegen-3.0/gtk.override"

static gboolean nspgtk_add_tick_callback_marshal(GtkWidget *widget, GdkFrameClock *frame_clock, gpointer user_data)
{
  gboolean ret = TRUE;
  NspGtkCustomNotify *cunote = user_data;

  NspObject *args[3], *nsp_ret;
  int nret = 0, nargs = 2;
  
  nspg_block_threads();
  
  args[0] =  (NspObject *) gobject_create("widget",(GObject *) widget,(NspTypeBase *) nsp_type_gtkwidget);
  args[1] =  (NspObject *) gobject_create("fc",(GObject *) frame_clock,(NspTypeBase *) nsp_type_gdkframeclock);
  if ( args[0]== NULL ||args[1]== NULL ) goto end;
  if ( cunote->data != NULL)
    {
      args[2]= cunote->data;
      nargs= 3;
    }
  if ( nsp_gtk_eval_function( (NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL)
    goto end;
  
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    {
      ret =  ((NspBMatrix *) nsp_ret)->B[0];
    }
  nspg_unblock_threads();
  return ret;
 end:
  {
    nspg_unblock_threads();
    return TRUE;
  }
}

static int _wrap_gtk_widget_add_tick_callback(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_func, *nsp_arg = NULL;
  NspGtkCustomNotify *cunote;
  CheckRhs(2,2);
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"request_text")== FAIL)) return RET_BUG;
  if (( nsp_arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
  if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;
  gtk_widget_add_tick_callback(GTK_WIDGET(self->obj),
			       nspgtk_add_tick_callback_marshal,cunote,nspgtk_custom_destroy_notify);
  return 0;
}


#line 66333 "gtk.c"


#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_widget_remove_tick_callback(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int id;
  if ( GetArgs(stack,rhs,opt,T,&id) == FAIL) return RET_BUG;
    gtk_widget_remove_tick_callback(GTK_WIDGET(self->obj),id);
  return 0;
}

#else
int _wrap_gtk_widget_remove_tick_callback(Stack stack, int rhs, int opt, int lhs) /* remove_tick_callback */
{
  Scierror("Error: function gtk_widget_remove_tick_callback not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_widget_init_template(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_widget_init_template(GTK_WIDGET(self->obj));
  return 0;
}

#else
int _wrap_gtk_widget_init_template(Stack stack, int rhs, int opt, int lhs) /* init_template */
{
  Scierror("Error: function gtk_widget_init_template not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_widget_get_template_child(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,string, t_end};
  GType widget_type;
  NspObject *nsp_widget_type = NULL;
  char *name;
  GObject *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_widget_type, &name) == FAIL) return RET_BUG;
  if ((widget_type = nspg_type_from_object(nsp_widget_type)) == FAIL)
      return RET_BUG;
    ret =gtk_widget_get_template_child(GTK_WIDGET(self->obj),widget_type,name);
  if (ret == NULL ) return RET_BUG;
  MoveObj(stack,1,NSP_OBJECT(ret));
  return 1;
}

#else
int _wrap_gtk_widget_get_template_child(Stack stack, int rhs, int opt, int lhs) /* get_template_child */
{
  Scierror("Error: function gtk_widget_get_template_child not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_widget_get_action_group(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *prefix;
  GActionGroup *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&prefix) == FAIL) return RET_BUG;
    ret =gtk_widget_get_action_group(GTK_WIDGET(self->obj),prefix);
  nsp_type_gactiongroup = new_type_gactiongroup(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gactiongroup))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_widget_get_action_group(Stack stack, int rhs, int opt, int lhs) /* get_action_group */
{
  Scierror("Error: function gtk_widget_get_action_group not available\n");
  return RET_BUG;
}
#endif
#line 8006 "codegen-3.0/gtk.override"

#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_widget_list_action_prefixes(NspGtkWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar **ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
  ret = (gchar **) gtk_widget_list_action_prefixes(GTK_WIDGET(self->obj));
  nsp_ret = (NspObject *) nsp_smatrix_create_from_table(ret);
  if ( nsp_ret == NULL) return RET_BUG;
  g_strfreev(ret);
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_widget_list_action_prefixes(Stack stack, int rhs, int opt, int lhs) /* list_action_prefixes */
{
  Scierror("Error: function gtk_widget_list_action_prefixes not available\n");
  return RET_BUG;
}
#endif

#line 66438 "gtk.c"


static NspMethods gtkwidget_methods[] = {
  {"get_allocation",(nsp_method *) _wrap_gtk_widget_get_allocation},
  {"destroy",(nsp_method *) _wrap_gtk_widget_destroy},
  {"unparent",(nsp_method *) _wrap_gtk_widget_unparent},
  {"show",(nsp_method *) _wrap_gtk_widget_show},
  {"hide",(nsp_method *) _wrap_gtk_widget_hide},
  {"show_now",(nsp_method *) _wrap_gtk_widget_show_now},
  {"show_all",(nsp_method *) _wrap_gtk_widget_show_all},
  {"set_no_show_all",(nsp_method *) _wrap_gtk_widget_set_no_show_all},
  {"get_no_show_all",(nsp_method *) _wrap_gtk_widget_get_no_show_all},
  {"map",(nsp_method *) _wrap_gtk_widget_map},
  {"unmap",(nsp_method *) _wrap_gtk_widget_unmap},
  {"realize",(nsp_method *) _wrap_gtk_widget_realize},
  {"unrealize",(nsp_method *) _wrap_gtk_widget_unrealize},
  {"draw",(nsp_method *) _wrap_gtk_widget_draw},
  {"queue_draw",(nsp_method *) _wrap_gtk_widget_queue_draw},
  {"queue_draw_area",(nsp_method *) _wrap_gtk_widget_queue_draw_area},
  {"queue_draw_region",(nsp_method *) _wrap_gtk_widget_queue_draw_region},
  {"queue_resize",(nsp_method *) _wrap_gtk_widget_queue_resize},
  {"queue_resize_no_redraw",(nsp_method *) _wrap_gtk_widget_queue_resize_no_redraw},
  {"get_frame_clock",(nsp_method *) _wrap_gtk_widget_get_frame_clock},
  {"size_allocate",(nsp_method *) _wrap_gtk_widget_size_allocate},
  {"size_allocate_with_baseline",(nsp_method *) _wrap_gtk_widget_size_allocate_with_baseline},
  {"get_request_mode",(nsp_method *) _wrap_gtk_widget_get_request_mode},
  {"get_preferred_width",(nsp_method *) _wrap_gtk_widget_get_preferred_width},
  {"get_preferred_height_for_width",(nsp_method *) _wrap_gtk_widget_get_preferred_height_for_width},
  {"get_preferred_height",(nsp_method *) _wrap_gtk_widget_get_preferred_height},
  {"get_preferred_width_for_height",(nsp_method *) _wrap_gtk_widget_get_preferred_width_for_height},
  {"get_preferred_height_and_baseline_for_width",(nsp_method *) _wrap_gtk_widget_get_preferred_height_and_baseline_for_width},
  {"get_preferred_size",(nsp_method *) _wrap_gtk_widget_get_preferred_size},
  {"add_accelerator",(nsp_method *) _wrap_gtk_widget_add_accelerator},
  {"remove_accelerator",(nsp_method *) _wrap_gtk_widget_remove_accelerator},
  {"set_accel_path",(nsp_method *) _wrap_gtk_widget_set_accel_path},
  {"list_accel_closures",(nsp_method *) _wrap_gtk_widget_list_accel_closures},
  {"can_activate_accel",(nsp_method *) _wrap_gtk_widget_can_activate_accel},
  {"mnemonic_activate",(nsp_method *) _wrap_gtk_widget_mnemonic_activate},
  {"event",(nsp_method *) _wrap_gtk_widget_event},
  {"send_expose",(nsp_method *) _wrap_gtk_widget_send_expose},
  {"send_focus_change",(nsp_method *) _wrap_gtk_widget_send_focus_change},
  {"activate",(nsp_method *) _wrap_gtk_widget_activate},
  {"reparent",(nsp_method *) _wrap_gtk_widget_reparent},
  {"intersect",(nsp_method *) _wrap_gtk_widget_intersect},
  {"region_intersect",(nsp_method *) _wrap_gtk_widget_region_intersect},
  {"freeze_child_notify",(nsp_method *) _wrap_gtk_widget_freeze_child_notify},
  {"child_notify",(nsp_method *) _wrap_gtk_widget_child_notify},
  {"thaw_child_notify",(nsp_method *) _wrap_gtk_widget_thaw_child_notify},
  {"set_can_focus",(nsp_method *) _wrap_gtk_widget_set_can_focus},
  {"get_can_focus",(nsp_method *) _wrap_gtk_widget_get_can_focus},
  {"has_focus",(nsp_method *) _wrap_gtk_widget_has_focus},
  {"is_focus",(nsp_method *) _wrap_gtk_widget_is_focus},
  {"has_visible_focus",(nsp_method *) _wrap_gtk_widget_has_visible_focus},
  {"grab_focus",(nsp_method *) _wrap_gtk_widget_grab_focus},
  {"set_can_default",(nsp_method *) _wrap_gtk_widget_set_can_default},
  {"get_can_default",(nsp_method *) _wrap_gtk_widget_get_can_default},
  {"has_default",(nsp_method *) _wrap_gtk_widget_has_default},
  {"grab_default",(nsp_method *) _wrap_gtk_widget_grab_default},
  {"set_receives_default",(nsp_method *) _wrap_gtk_widget_set_receives_default},
  {"get_receives_default",(nsp_method *) _wrap_gtk_widget_get_receives_default},
  {"has_grab",(nsp_method *) _wrap_gtk_widget_has_grab},
  {"device_is_shadowed",(nsp_method *) _wrap_gtk_widget_device_is_shadowed},
  {"set_name",(nsp_method *) _wrap_gtk_widget_set_name},
  {"get_name",(nsp_method *) _wrap_gtk_widget_get_name},
  {"set_state_flags",(nsp_method *) _wrap_gtk_widget_set_state_flags},
  {"unset_state_flags",(nsp_method *) _wrap_gtk_widget_unset_state_flags},
  {"get_state_flags",(nsp_method *) _wrap_gtk_widget_get_state_flags},
  {"set_sensitive",(nsp_method *) _wrap_gtk_widget_set_sensitive},
  {"get_sensitive",(nsp_method *) _wrap_gtk_widget_get_sensitive},
  {"is_sensitive",(nsp_method *) _wrap_gtk_widget_is_sensitive},
  {"set_visible",(nsp_method *) _wrap_gtk_widget_set_visible},
  {"get_visible",(nsp_method *) _wrap_gtk_widget_get_visible},
  {"is_visible",(nsp_method *) _wrap_gtk_widget_is_visible},
  {"set_has_window",(nsp_method *) _wrap_gtk_widget_set_has_window},
  {"get_has_window",(nsp_method *) _wrap_gtk_widget_get_has_window},
  {"is_toplevel",(nsp_method *) _wrap_gtk_widget_is_toplevel},
  {"is_drawable",(nsp_method *) _wrap_gtk_widget_is_drawable},
  {"set_realized",(nsp_method *) _wrap_gtk_widget_set_realized},
  {"get_realized",(nsp_method *) _wrap_gtk_widget_get_realized},
  {"set_mapped",(nsp_method *) _wrap_gtk_widget_set_mapped},
  {"get_mapped",(nsp_method *) _wrap_gtk_widget_get_mapped},
  {"set_app_paintable",(nsp_method *) _wrap_gtk_widget_set_app_paintable},
  {"get_app_paintable",(nsp_method *) _wrap_gtk_widget_get_app_paintable},
  {"set_double_buffered",(nsp_method *) _wrap_gtk_widget_set_double_buffered},
  {"get_double_buffered",(nsp_method *) _wrap_gtk_widget_get_double_buffered},
  {"set_redraw_on_allocate",(nsp_method *) _wrap_gtk_widget_set_redraw_on_allocate},
  {"set_parent",(nsp_method *) _wrap_gtk_widget_set_parent},
  {"get_parent",(nsp_method *) _wrap_gtk_widget_get_parent},
  {"set_parent_window",(nsp_method *) _wrap_gtk_widget_set_parent_window},
  {"get_parent_window",(nsp_method *) _wrap_gtk_widget_get_parent_window},
  {"set_child_visible",(nsp_method *) _wrap_gtk_widget_set_child_visible},
  {"get_child_visible",(nsp_method *) _wrap_gtk_widget_get_child_visible},
  {"set_window",(nsp_method *) _wrap_gtk_widget_set_window},
  {"get_window",(nsp_method *) _wrap_gtk_widget_get_window},
  {"register_window",(nsp_method *) _wrap_gtk_widget_register_window},
  {"unregister_window",(nsp_method *) _wrap_gtk_widget_unregister_window},
  {"get_allocated_width",(nsp_method *) _wrap_gtk_widget_get_allocated_width},
  {"get_allocated_height",(nsp_method *) _wrap_gtk_widget_get_allocated_height},
  {"get_allocated_baseline",(nsp_method *) _wrap_gtk_widget_get_allocated_baseline},
  {"get_allocation",(nsp_method *) _wrap_gtk_widget_get_allocation},
  {"get_clip",(nsp_method *) _wrap_gtk_widget_get_clip},
  {"child_focus",(nsp_method *) _wrap_gtk_widget_child_focus},
  {"keynav_failed",(nsp_method *) _wrap_gtk_widget_keynav_failed},
  {"error_bell",(nsp_method *) _wrap_gtk_widget_error_bell},
  {"set_size_request",(nsp_method *) _wrap_gtk_widget_set_size_request},
  {"get_size_request",(nsp_method *) _wrap_gtk_widget_get_size_request},
  {"set_events",(nsp_method *) _wrap_gtk_widget_set_events},
  {"add_events",(nsp_method *) _wrap_gtk_widget_add_events},
  {"set_device_events",(nsp_method *) _wrap_gtk_widget_set_device_events},
  {"add_device_events",(nsp_method *) _wrap_gtk_widget_add_device_events},
  {"set_opacity",(nsp_method *) _wrap_gtk_widget_set_opacity},
  {"get_opacity",(nsp_method *) _wrap_gtk_widget_get_opacity},
  {"set_device_enabled",(nsp_method *) _wrap_gtk_widget_set_device_enabled},
  {"get_device_enabled",(nsp_method *) _wrap_gtk_widget_get_device_enabled},
  {"get_toplevel",(nsp_method *) _wrap_gtk_widget_get_toplevel},
  {"get_ancestor",(nsp_method *) _wrap_gtk_widget_get_ancestor},
  {"get_visual",(nsp_method *) _wrap_gtk_widget_get_visual},
  {"set_visual",(nsp_method *) _wrap_gtk_widget_set_visual},
  {"get_screen",(nsp_method *) _wrap_gtk_widget_get_screen},
  {"has_screen",(nsp_method *) _wrap_gtk_widget_has_screen},
  {"get_scale_factor",(nsp_method *) _wrap_gtk_widget_get_scale_factor},
  {"get_display",(nsp_method *) _wrap_gtk_widget_get_display},
  {"get_root_window",(nsp_method *) _wrap_gtk_widget_get_root_window},
  {"get_settings",(nsp_method *) _wrap_gtk_widget_get_settings},
  {"get_clipboard",(nsp_method *) _wrap_gtk_widget_get_clipboard},
  {"get_hexpand",(nsp_method *) _wrap_gtk_widget_get_hexpand},
  {"set_hexpand",(nsp_method *) _wrap_gtk_widget_set_hexpand},
  {"get_hexpand_set",(nsp_method *) _wrap_gtk_widget_get_hexpand_set},
  {"set_hexpand_set",(nsp_method *) _wrap_gtk_widget_set_hexpand_set},
  {"get_vexpand",(nsp_method *) _wrap_gtk_widget_get_vexpand},
  {"set_vexpand",(nsp_method *) _wrap_gtk_widget_set_vexpand},
  {"get_vexpand_set",(nsp_method *) _wrap_gtk_widget_get_vexpand_set},
  {"set_vexpand_set",(nsp_method *) _wrap_gtk_widget_set_vexpand_set},
  {"queue_compute_expand",(nsp_method *) _wrap_gtk_widget_queue_compute_expand},
  {"compute_expand",(nsp_method *) _wrap_gtk_widget_compute_expand},
  {"get_support_multidevice",(nsp_method *) _wrap_gtk_widget_get_support_multidevice},
  {"set_support_multidevice",(nsp_method *) _wrap_gtk_widget_set_support_multidevice},
  {"get_accessible",(nsp_method *) _wrap_gtk_widget_get_accessible},
  {"get_halign",(nsp_method *) _wrap_gtk_widget_get_halign},
  {"set_halign",(nsp_method *) _wrap_gtk_widget_set_halign},
  {"get_valign",(nsp_method *) _wrap_gtk_widget_get_valign},
  {"get_valign_with_baseline",(nsp_method *) _wrap_gtk_widget_get_valign_with_baseline},
  {"set_valign",(nsp_method *) _wrap_gtk_widget_set_valign},
  {"get_margin_start",(nsp_method *) _wrap_gtk_widget_get_margin_start},
  {"set_margin_start",(nsp_method *) _wrap_gtk_widget_set_margin_start},
  {"get_margin_end",(nsp_method *) _wrap_gtk_widget_get_margin_end},
  {"set_margin_end",(nsp_method *) _wrap_gtk_widget_set_margin_end},
  {"get_margin_top",(nsp_method *) _wrap_gtk_widget_get_margin_top},
  {"set_margin_top",(nsp_method *) _wrap_gtk_widget_set_margin_top},
  {"get_margin_bottom",(nsp_method *) _wrap_gtk_widget_get_margin_bottom},
  {"set_margin_bottom",(nsp_method *) _wrap_gtk_widget_set_margin_bottom},
  {"get_events",(nsp_method *) _wrap_gtk_widget_get_events},
  {"get_device_events",(nsp_method *) _wrap_gtk_widget_get_device_events},
  {"is_ancestor",(nsp_method *) _wrap_gtk_widget_is_ancestor},
  {"translate_coordinates",(nsp_method *) _wrap_gtk_widget_translate_coordinates},
  {"hide_on_delete",(nsp_method *) _wrap_gtk_widget_hide_on_delete},
  {"override_color",(nsp_method *) _wrap_gtk_widget_override_color},
  {"override_background_color",(nsp_method *) _wrap_gtk_widget_override_background_color},
  {"override_font",(nsp_method *) _wrap_gtk_widget_override_font},
  {"override_symbolic_color",(nsp_method *) _wrap_gtk_widget_override_symbolic_color},
  {"override_cursor",(nsp_method *) _wrap_gtk_widget_override_cursor},
  {"reset_style",(nsp_method *) _wrap_gtk_widget_reset_style},
  {"create_pango_context",(nsp_method *) _wrap_gtk_widget_create_pango_context},
  {"get_pango_context",(nsp_method *) _wrap_gtk_widget_get_pango_context},
  {"create_pango_layout",(nsp_method *) _wrap_gtk_widget_create_pango_layout},
  {"set_direction",(nsp_method *) _wrap_gtk_widget_set_direction},
  {"get_direction",(nsp_method *) _wrap_gtk_widget_get_direction},
  {"is_composited",(nsp_method *) _wrap_gtk_widget_is_composited},
  {"shape_combine_region",(nsp_method *) _wrap_gtk_widget_shape_combine_region},
  {"input_shape_combine_region",(nsp_method *) _wrap_gtk_widget_input_shape_combine_region},
  {"list_mnemonic_labels",(nsp_method *) _wrap_gtk_widget_list_mnemonic_labels},
  {"add_mnemonic_label",(nsp_method *) _wrap_gtk_widget_add_mnemonic_label},
  {"remove_mnemonic_label",(nsp_method *) _wrap_gtk_widget_remove_mnemonic_label},
  {"set_tooltip_window",(nsp_method *) _wrap_gtk_widget_set_tooltip_window},
  {"get_tooltip_window",(nsp_method *) _wrap_gtk_widget_get_tooltip_window},
  {"trigger_tooltip_query",(nsp_method *) _wrap_gtk_widget_trigger_tooltip_query},
  {"set_tooltip_text",(nsp_method *) _wrap_gtk_widget_set_tooltip_text},
  {"get_tooltip_text",(nsp_method *) _wrap_gtk_widget_get_tooltip_text},
  {"set_tooltip_markup",(nsp_method *) _wrap_gtk_widget_set_tooltip_markup},
  {"get_tooltip_markup",(nsp_method *) _wrap_gtk_widget_get_tooltip_markup},
  {"set_has_tooltip",(nsp_method *) _wrap_gtk_widget_set_has_tooltip},
  {"get_has_tooltip",(nsp_method *) _wrap_gtk_widget_get_has_tooltip},
  {"in_destruction",(nsp_method *) _wrap_gtk_widget_in_destruction},
  {"get_style_context",(nsp_method *) _wrap_gtk_widget_get_style_context},
  {"get_modifier_mask",(nsp_method *) _wrap_gtk_widget_get_modifier_mask},
  {"insert_action_group",(nsp_method *) _wrap_gtk_widget_insert_action_group},
  {"add_tick_callback",(nsp_method *) _wrap_gtk_widget_add_tick_callback},
  {"remove_tick_callback",(nsp_method *) _wrap_gtk_widget_remove_tick_callback},
  {"init_template",(nsp_method *) _wrap_gtk_widget_init_template},
  {"get_template_child",(nsp_method *) _wrap_gtk_widget_get_template_child},
  {"get_action_group",(nsp_method *) _wrap_gtk_widget_get_action_group},
  {"list_action_prefixes",(nsp_method *) _wrap_gtk_widget_list_action_prefixes},
  { NULL, NULL}
};

static NspMethods *gtkwidget_get_methods(void) { return gtkwidget_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkwidget_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkContainer ----------- */


#define  NspGtkContainer_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcontainer.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkContainer inherits from GtkWidget 
 * and implements GtkBuildable
 */

int nsp_type_gtkcontainer_id=0;
NspTypeGtkContainer *nsp_type_gtkcontainer=NULL;

/*
 * Type object for NspGtkContainer 
 * all the instance of NspTypeGtkContainer share the same id. 
 * nsp_type_gtkcontainer: is an instance of NspTypeGtkContainer 
 *    used for objects of NspGtkContainer type (i.e built with new_gtkcontainer) 
 * other instances are used for derived classes 
 */
NspTypeGtkContainer *new_type_gtkcontainer(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkContainer *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcontainer != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcontainer;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcontainer_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcontainer_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcontainer;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcontainer */ 

  top->s_type =  (s_type_func *) nsp_gtkcontainer_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcontainer_type_short_string;
  /* top->create = (create_func*) int_gtkcontainer_create;*/

  /* specific methods for gtkcontainer */

  type->init = (init_func *) init_gtkcontainer;

  /* 
   * NspGtkContainer interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkcontainer_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkContainer called nsp_type_gtkcontainer
       */
      type->id =  nsp_type_gtkcontainer_id = nsp_new_type_id();
      nsp_type_gtkcontainer = type;
      if ( nsp_register_type(nsp_type_gtkcontainer) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcontainer, GTK_TYPE_CONTAINER);
      return ( mode == T_BASE ) ? type : new_type_gtkcontainer(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcontainer_id;
      return type;
    }
}

/*
 * initialize NspGtkContainer instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcontainer(NspGtkContainer *Obj,NspTypeGtkContainer *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkContainer 
 */

NspGtkContainer *new_gtkcontainer() 
{
  NspGtkContainer *loc;
  /* type must exists */
  nsp_type_gtkcontainer = new_type_gtkcontainer(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkContainer)))== NULLGTKCONTAINER) return loc;
  /* initialize object */
  if ( init_gtkcontainer(loc,nsp_type_gtkcontainer) == FAIL) return NULLGTKCONTAINER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkContainer 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcontainer_type_name[]="GtkContainer";
static char gtkcontainer_short_type_name[]="GtkContainer";

static char *nsp_gtkcontainer_type_as_string(void)
{
  return(gtkcontainer_type_name);
}

static char *nsp_gtkcontainer_type_short_string(NspObject *v)
{
  return(gtkcontainer_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkContainer objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkContainer   *nsp_gtkcontainer_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcontainer_id)  == TRUE  ) return ((NspGtkContainer *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcontainer));
  return NULL;
}

int IsGtkContainerObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcontainer_id);
}

int IsGtkContainer(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcontainer_id);
}

NspGtkContainer  *GetGtkContainerCopy(Stack stack, int i)
{
  if (  GetGtkContainer(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkContainer  *GetGtkContainer(Stack stack, int i)
{
  NspGtkContainer *M;
  if (( M = nsp_gtkcontainer_object(NthObj(i))) == NULLGTKCONTAINER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkContainer *gtkcontainer_copy(NspGtkContainer *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcontainer);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcontainer);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkContainer
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_container_set_border_width(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int border_width;
  if ( GetArgs(stack,rhs,opt,T,&border_width) == FAIL) return RET_BUG;
    gtk_container_set_border_width(GTK_CONTAINER(self->obj),border_width);
  return 0;
}

static int _wrap_gtk_container_get_border_width(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_container_get_border_width(GTK_CONTAINER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_container_add(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_container_add(GTK_CONTAINER(self->obj),GTK_WIDGET(widget->obj));
  return 0;
}

static int _wrap_gtk_container_remove(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_container_remove(GTK_CONTAINER(self->obj),GTK_WIDGET(widget->obj));
  return 0;
}

#if GTK_CHECK_VERSION(3,12,0)
int _wrap_gtk_container_set_resize_mode(Stack stack, int rhs, int opt, int lhs) /* set_resize_mode */
{
  Scierror("Error: function gtk_container_set_resize_mode is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_container_set_resize_mode(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkResizeMode resize_mode;
  NspObject *nsp_resize_mode = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_resize_mode) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_RESIZE_MODE, nsp_resize_mode, &resize_mode)== FAIL)
      return RET_BUG;
    gtk_container_set_resize_mode(GTK_CONTAINER(self->obj),resize_mode);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,12,0)
int _wrap_gtk_container_get_resize_mode(Stack stack, int rhs, int opt, int lhs) /* get_resize_mode */
{
  Scierror("Error: function gtk_container_get_resize_mode is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_container_get_resize_mode(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_container_get_resize_mode(GTK_CONTAINER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
static int _wrap_gtk_container_check_resize(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_container_check_resize(GTK_CONTAINER(self->obj));
  return 0;
}

#line 1091 "codegen-3.0/gtk.override"

static void
nspgtk_container_foreach_marshal(GtkWidget *widget, gpointer data)
{
  NspObject *args[2];
  NspGtkCustomNotify *cunote = data;
  NspObject *nsp_ret;
  int nret = 0,nargs = 1;
  nspg_block_threads();

  args[0] = (NspObject *)nspgobject_new("widget",(GObject *)widget);
  if ( args[0]== NULL ) goto end;
  if (cunote->data)
    {
      args[1]= cunote->data;
      nargs= 2;
    }
  if ( nsp_gtk_eval_function((NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL)
    goto end ;
  /*
  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    ret =  ((NspBMatrix *) nsp_ret)->B[0];
  */
  goto end;
 end:
  {
    nspg_unblock_threads();
    return;
  }
}

static int
_wrap_gtk_container_foreach(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify cunote;

  CheckRhs(1,2);
  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /* extra arguments **/
  if ( rhs == 2 )
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }
  cunote.func = func;
  cunote.data = arg;
  gtk_container_foreach(GTK_CONTAINER(self->obj), nspgtk_container_foreach_marshal, &cunote);
  return 0;
}

#line 66970 "gtk.c"


#line 1145 "codegen-3.0/gtk.override"

static int
_wrap_gtk_container_forall(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *func, *arg = NULL;
  NspGtkCustomNotify cunote;
  
  CheckRhs(1,2);
  if (( func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(func,"tree_foreach")== FAIL)) return RET_BUG;
  /* extra arguments **/
  if ( rhs == 2 )
    {
      if (( arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
      if ((nsp_object_set_name(arg,"m")== FAIL)) return RET_BUG;
    }
  cunote.func = func;
  cunote.data = arg;
  gtk_container_forall(GTK_CONTAINER(self->obj), nspgtk_container_foreach_marshal, &cunote);
  return 0;
}

#line 66996 "gtk.c"


#line 773 "codegen-3.0/gtk.override"

static int
_wrap_gtk_container_get_children(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  list = gtk_container_get_children(GTK_CONTAINER(self->obj));
  NSP_LIST_FROM_GLIST(list, nspgobject_new("lel",G_OBJECT(tmp->data)), g_list_free);
}
#line 67009 "gtk.c"


static int _wrap_gtk_container_propagate_draw(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *child;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &nsp_cr) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_container_propagate_draw(GTK_CONTAINER(self->obj),GTK_WIDGET(child->obj),cr);
  return 0;
}

#line 784 "codegen-3.0/gtk.override"
static int
_wrap_gtk_container_set_focus_chain(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list , t_end} ;
  /* static char *kwlist[] = { "focusable_widgets", NULL };*/
  NspList *nsp_focusable_widgets;
  GList *focusable_widgets = NULL;
  Cell *C;

  if (GetArgs(stack,rhs,opt,T,&nsp_focusable_widgets)== FAIL) return RET_BUG;

  C= nsp_focusable_widgets->first;
  while ( C != NULLCELL)
    {
      if ( C->O != NULLOBJ )
	{
	  if (!nspgobject_check((NspGObject *) C->O,nsp_type_gtkwidget))
	    {
	      Scierror("focusable_widgets members must be GtkWidgets");
	      return RET_BUG;
	    }
	  focusable_widgets = g_list_prepend(focusable_widgets,
					     nspgobject_get(C->O));
	}
      C = C->next ;
    }
  focusable_widgets = g_list_reverse(focusable_widgets);
  gtk_container_set_focus_chain(GTK_CONTAINER(self->obj), focusable_widgets);
  g_list_free(focusable_widgets);
  return 0;
}
#line 67061 "gtk.c"


#line 817 "codegen-3.0/gtk.override"
static int
_wrap_gtk_container_get_focus_chain(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  if (! gtk_container_get_focus_chain(GTK_CONTAINER(self->obj), &list)) return 0;
  NSP_LIST_FROM_GLIST(list, nspgobject_new("lel",G_OBJECT(tmp->data)),g_list_free);
}
#line 67073 "gtk.c"


static int _wrap_gtk_container_unset_focus_chain(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_container_unset_focus_chain(GTK_CONTAINER(self->obj));
  return 0;
}

#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_container_set_reallocate_redraws(Stack stack, int rhs, int opt, int lhs) /* set_reallocate_redraws */
{
  Scierror("Error: function gtk_container_set_reallocate_redraws is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_container_set_reallocate_redraws(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int needs_redraws;
  if ( GetArgs(stack,rhs,opt,T,&needs_redraws) == FAIL) return RET_BUG;
    gtk_container_set_reallocate_redraws(GTK_CONTAINER(self->obj),needs_redraws);
  return 0;
}

#endif
static int _wrap_gtk_container_set_focus_child(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_container_set_focus_child(GTK_CONTAINER(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_container_get_focus_child(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_container_get_focus_child(GTK_CONTAINER(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_container_set_focus_vadjustment(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *adjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
    gtk_container_set_focus_vadjustment(GTK_CONTAINER(self->obj),GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_container_get_focus_vadjustment(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAdjustment *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_container_get_focus_vadjustment(GTK_CONTAINER(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_container_set_focus_hadjustment(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *adjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
    gtk_container_set_focus_hadjustment(GTK_CONTAINER(self->obj),GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_container_get_focus_hadjustment(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAdjustment *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_container_get_focus_hadjustment(GTK_CONTAINER(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
int _wrap_gtk_container_resize_children(Stack stack, int rhs, int opt, int lhs) /* resize_children */
{
  Scierror("Error: function gtk_container_resize_children is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_container_resize_children(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_container_resize_children(GTK_CONTAINER(self->obj));
  return 0;
}

#endif
#line 745 "codegen-3.0/gtk.override"
static int _wrap_gtk_container_child_type(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_ret;
  NspTypeBase *type;
  GType ret;
  CheckRhs(0,0);
  ret = gtk_container_child_type(GTK_CONTAINER(self->obj));
  type = nsp_type_from_gtype(ret);
  if ( type == NULL)
    {
      Scierror("get type in gtype failed for gtype %s \n",g_type_name(ret));
      return RET_BUG;
    }
  if ((nsp_ret = (NspObject *) type_create(NVOID,type ,NULL))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 67197 "gtk.c"


#line 1039 "codegen-3.0/gtk.override"
static int
_wrap_gtk_container_add_with_properties(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *nsp_child;
  GtkContainer *container;
  GtkWidget *child;
  GObjectClass *class;
  int i;

  CheckRhs(1,100);
  if ((nsp_child = GetGtkWidget(stack,1)) == NULL) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(nsp_child->obj);

  gtk_widget_freeze_child_notify(child);
  gtk_container_add(container, child);
  class = G_OBJECT_GET_CLASS(self->obj);

  for ( i = 2 ; i <= rhs ; i++)
    {
      const gchar *property_name;
      NspObject *nsp_value;
      GParamSpec *pspec;
      GValue value = { 0 };
      if ( Ocheckname(NthObj(i),NVOID) )
	{
	  Scierror("Error: properties must have names \n");
	  Scierror("\t%s of function %s\n",ArgPosition(rhs),NspFname(stack));
	  return RET_BUG;
	}
      /* A copy of object is entered as an object property */
      /* GetObj takes care of Hobj pointers */
      if (( nsp_value =nsp_get_object(stack,i)) == NULLOBJ ) return RET_BUG;
      property_name = nsp_object_get_name(NthObj(i));
      pspec = gtk_container_class_find_child_property(class, property_name);
      if (!pspec) {
	Scierror("container does not support property `%s'",property_name);
	/* clean .....*/
	return RET_BUG;
      }
      g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
      nspg_value_from_nspobject(&value, (NspObject*)nsp_value);
      gtk_container_child_set_property(container, child, property_name, &value);
      g_value_unset(&value);
    }
  gtk_widget_thaw_child_notify(child);
  return 0;
}

#line 67251 "gtk.c"


#line 920 "codegen-3.0/gtk.override"
static int
_wrap_gtk_container_child_set(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *pychild;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  GObjectClass *class;
  int i;

  CheckRhs(1,1000);
  if ((pychild = GetGtkWidget(stack,1)) == NULL) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("first argument must be a child");
    return RET_BUG;
  }

  class = G_OBJECT_GET_CLASS(self->obj);

  for ( i = 2 ; i <= rhs ; i++)
    {
      const gchar *property_name;
      NspObject *nsp_value;
      GParamSpec *pspec;
      GValue value = { 0 };
      if ( Ocheckname(NthObj(i),NVOID) )
	{
	  Scierror("Error: properties mus have names \n");
	  Scierror("\t%s of function %s\n",ArgPosition(rhs),NspFname(stack));
	  return RET_BUG;
	}
      /* A copy of object is entered as an object property **/
      /* GetObj takes care of Hobj pointers **/
      if (( nsp_value =nsp_get_object(stack,i)) == NULLOBJ ) return RET_BUG;
      property_name = nsp_object_get_name(NthObj(i));
      pspec = gtk_container_class_find_child_property(class, property_name);
      if (!pspec) {
	Scierror("container does not support property `%s'",property_name);
	/* clean .....*/
	return RET_BUG;
      }
      g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));
      nspg_value_from_nspobject(&value, (NspObject*)nsp_value);
      gtk_container_child_set_property(container, child, property_name, &value);
      g_value_unset(&value);
    }
  return 0;
}
#line 67308 "gtk.c"


#line 975 "codegen-3.0/gtk.override"
static int
_wrap_gtk_container_child_get(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspSMatrix *props;
  NspGObject *pychild;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  GObjectClass *class;
  int  i;
  NspList *nsp_list;

  CheckRhs(2,2);
  if ((pychild = GetGtkWidget(stack,1)) == NULL) return RET_BUG;
  if (( props = GetSMat(stack,2)) == NULLSMAT) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("first argument is not a child of given container\n");
    return RET_BUG;
  }

  class = G_OBJECT_GET_CLASS(self->obj);

  if (( nsp_list =nsp_list_create(NVOID) ) == NULLLIST) return RET_BUG;

  for ( i = 0 ; i < props->mn ; i++) {
    gchar *property_name = props->S[i];
    GParamSpec *pspec;
    GValue value = { 0 };
    NspObject *item;
    pspec = gtk_container_class_find_child_property(class, property_name);
    if (!pspec) {
      Scierror("container does not support property `%s'",property_name);
      goto clean;
    }

    g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

    gtk_container_child_get_property(container, child, property_name, &value);

    item = nspg_value_as_nspobject(&value, TRUE);

    if ( nsp_list_end_insert(nsp_list, item) == FAIL )
      {
	g_value_unset(&value);
	goto clean;
      }

    g_value_unset(&value);
  }
  return 1;
 clean:
  {
    nsp_list_destroy(nsp_list);
    return RET_BUG;
  }

}
#line 67374 "gtk.c"


#line 874 "codegen-3.0/gtk.override"
static int
_wrap_gtk_container_child_set_property(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *property_name;
  NspGObject *pychild;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  NspGObject *pyvalue;
  GObjectClass *class;
  GParamSpec *pspec;
  GValue value = { 0, } ;

  int_types T[] = {obj_check,string,obj, t_end} ;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget,&pychild,&property_name,&pyvalue)== FAIL) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("%s: first argument must be a child",NspFname(stack));
    return RET_BUG;
  }

  class = G_OBJECT_GET_CLASS(self->obj);
  pspec = gtk_container_class_find_child_property(class, property_name);

  if (!pspec) {
    Scierror("container does not support property `%s'", property_name);
    return RET_BUG;
  }
  g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

  nspg_value_from_nspobject(&value, (NspObject*)pyvalue);

  gtk_container_child_set_property(container,
				   child,
				   property_name,
				   &value);
  g_value_unset(&value);
  return 0;
}
#line 67422 "gtk.c"


#line 827 "codegen-3.0/gtk.override"
static int
_wrap_gtk_container_child_get_property(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *pychild;
  gchar *property_name;
  GtkContainer *container;
  GtkWidget *child;
  GList *children;
  GObjectClass *class;
  GParamSpec *pspec;
  GValue value = { 0, } ;
  NspObject *ret;

  int_types T[] = {obj_check,string, t_end} ;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &pychild,&property_name)== FAIL) return RET_BUG;

  container = GTK_CONTAINER(self->obj);
  child = GTK_WIDGET(pychild->obj);

  children = gtk_container_get_children(container);
  if (g_list_find(children, child) == NULL) {
    Scierror("%s: first argument must be a child",NspFname(stack));
    return RET_BUG;
  }

  class = G_OBJECT_GET_CLASS(container);
  pspec = gtk_container_class_find_child_property(class, property_name);
  if (!pspec) {
    Scierror("container does not support property `%s'", property_name);
    return RET_BUG;
  }

  g_value_init(&value, G_PARAM_SPEC_VALUE_TYPE(pspec));

  gtk_container_child_get_property(container,
				   child,
				   property_name,
				   &value);

  ret = nspg_value_as_nspobject(&value, TRUE);
  g_value_unset(&value);
  MoveObj(stack,1,ret);
  return 1;
}
#line 67471 "gtk.c"


#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_container_child_notify(NspGtkContainer *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *child;
  char *child_property;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &child_property) == FAIL) return RET_BUG;
    gtk_container_child_notify(GTK_CONTAINER(self->obj),GTK_WIDGET(child->obj),child_property);
  return 0;
}

#else
int _wrap_gtk_container_child_notify(Stack stack, int rhs, int opt, int lhs) /* child_notify */
{
  Scierror("Error: function gtk_container_child_notify not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkcontainer_methods[] = {
  {"set_border_width",(nsp_method *) _wrap_gtk_container_set_border_width},
  {"get_border_width",(nsp_method *) _wrap_gtk_container_get_border_width},
  {"add",(nsp_method *) _wrap_gtk_container_add},
  {"remove",(nsp_method *) _wrap_gtk_container_remove},
  {"set_resize_mode",(nsp_method *) _wrap_gtk_container_set_resize_mode},
  {"get_resize_mode",(nsp_method *) _wrap_gtk_container_get_resize_mode},
  {"check_resize",(nsp_method *) _wrap_gtk_container_check_resize},
  {"foreach",(nsp_method *) _wrap_gtk_container_foreach},
  {"forall",(nsp_method *) _wrap_gtk_container_forall},
  {"get_children",(nsp_method *) _wrap_gtk_container_get_children},
  {"propagate_draw",(nsp_method *) _wrap_gtk_container_propagate_draw},
  {"set_focus_chain",(nsp_method *) _wrap_gtk_container_set_focus_chain},
  {"get_focus_chain",(nsp_method *) _wrap_gtk_container_get_focus_chain},
  {"unset_focus_chain",(nsp_method *) _wrap_gtk_container_unset_focus_chain},
  {"set_reallocate_redraws",(nsp_method *) _wrap_gtk_container_set_reallocate_redraws},
  {"set_focus_child",(nsp_method *) _wrap_gtk_container_set_focus_child},
  {"get_focus_child",(nsp_method *) _wrap_gtk_container_get_focus_child},
  {"set_focus_vadjustment",(nsp_method *) _wrap_gtk_container_set_focus_vadjustment},
  {"get_focus_vadjustment",(nsp_method *) _wrap_gtk_container_get_focus_vadjustment},
  {"set_focus_hadjustment",(nsp_method *) _wrap_gtk_container_set_focus_hadjustment},
  {"get_focus_hadjustment",(nsp_method *) _wrap_gtk_container_get_focus_hadjustment},
  {"resize_children",(nsp_method *) _wrap_gtk_container_resize_children},
  {"child_type",(nsp_method *) _wrap_gtk_container_child_type},
  {"add_with_properties",(nsp_method *) _wrap_gtk_container_add_with_properties},
  {"child_set",(nsp_method *) _wrap_gtk_container_child_set},
  {"child_get",(nsp_method *) _wrap_gtk_container_child_get},
  {"child_set_property",(nsp_method *) _wrap_gtk_container_child_set_property},
  {"child_get_property",(nsp_method *) _wrap_gtk_container_child_get_property},
  {"child_notify",(nsp_method *) _wrap_gtk_container_child_notify},
  { NULL, NULL}
};

static NspMethods *gtkcontainer_get_methods(void) { return gtkcontainer_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcontainer_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkBin ----------- */


#define  NspGtkBin_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkbin.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkBin inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtkbin_id=0;
NspTypeGtkBin *nsp_type_gtkbin=NULL;

/*
 * Type object for NspGtkBin 
 * all the instance of NspTypeGtkBin share the same id. 
 * nsp_type_gtkbin: is an instance of NspTypeGtkBin 
 *    used for objects of NspGtkBin type (i.e built with new_gtkbin) 
 * other instances are used for derived classes 
 */
NspTypeGtkBin *new_type_gtkbin(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkBin *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkbin != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkbin;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkbin_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkbin_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkbin;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkbin */ 

  top->s_type =  (s_type_func *) nsp_gtkbin_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkbin_type_short_string;
  /* top->create = (create_func*) int_gtkbin_create;*/

  /* specific methods for gtkbin */

  type->init = (init_func *) init_gtkbin;

  /* 
   * NspGtkBin interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkbin_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkBin called nsp_type_gtkbin
       */
      type->id =  nsp_type_gtkbin_id = nsp_new_type_id();
      nsp_type_gtkbin = type;
      if ( nsp_register_type(nsp_type_gtkbin) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkbin, GTK_TYPE_BIN);
      return ( mode == T_BASE ) ? type : new_type_gtkbin(mode);
    }
  else 
    {
      type->id = nsp_type_gtkbin_id;
      return type;
    }
}

/*
 * initialize NspGtkBin instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkbin(NspGtkBin *Obj,NspTypeGtkBin *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkBin 
 */

NspGtkBin *new_gtkbin() 
{
  NspGtkBin *loc;
  /* type must exists */
  nsp_type_gtkbin = new_type_gtkbin(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkBin)))== NULLGTKBIN) return loc;
  /* initialize object */
  if ( init_gtkbin(loc,nsp_type_gtkbin) == FAIL) return NULLGTKBIN;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkBin 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkbin_type_name[]="GtkBin";
static char gtkbin_short_type_name[]="GtkBin";

static char *nsp_gtkbin_type_as_string(void)
{
  return(gtkbin_type_name);
}

static char *nsp_gtkbin_type_short_string(NspObject *v)
{
  return(gtkbin_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkBin objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkBin   *nsp_gtkbin_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkbin_id)  == TRUE  ) return ((NspGtkBin *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkbin));
  return NULL;
}

int IsGtkBinObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkbin_id);
}

int IsGtkBin(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkbin_id);
}

NspGtkBin  *GetGtkBinCopy(Stack stack, int i)
{
  if (  GetGtkBin(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkBin  *GetGtkBin(Stack stack, int i)
{
  NspGtkBin *M;
  if (( M = nsp_gtkbin_object(NthObj(i))) == NULLGTKBIN)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkBin *gtkbin_copy(NspGtkBin *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbin);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkbin);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkBin
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_bin_get_child(NspGtkBin *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_bin_get_child(GTK_BIN(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkbin_methods[] = {
  {"get_child",(nsp_method *) _wrap_gtk_bin_get_child},
  { NULL, NULL}
};

static NspMethods *gtkbin_get_methods(void) { return gtkbin_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkbin_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkMenuShell ----------- */


#define  NspGtkMenuShell_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkmenushell.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkMenuShell inherits from GtkContainer 
 * and implements GtkBuildable
 */

int nsp_type_gtkmenushell_id=0;
NspTypeGtkMenuShell *nsp_type_gtkmenushell=NULL;

/*
 * Type object for NspGtkMenuShell 
 * all the instance of NspTypeGtkMenuShell share the same id. 
 * nsp_type_gtkmenushell: is an instance of NspTypeGtkMenuShell 
 *    used for objects of NspGtkMenuShell type (i.e built with new_gtkmenushell) 
 * other instances are used for derived classes 
 */
NspTypeGtkMenuShell *new_type_gtkmenushell(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkMenuShell *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmenushell != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmenushell;
    }
  if (( type =  malloc(sizeof(NspTypeGtkContainer))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkcontainer(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmenushell_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkmenushell_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkmenushell;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkmenushell */ 

  top->s_type =  (s_type_func *) nsp_gtkmenushell_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkmenushell_type_short_string;
  /* top->create = (create_func*) int_gtkmenushell_create;*/

  /* specific methods for gtkmenushell */

  type->init = (init_func *) init_gtkmenushell;

  /* 
   * NspGtkMenuShell interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkmenushell_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMenuShell called nsp_type_gtkmenushell
       */
      type->id =  nsp_type_gtkmenushell_id = nsp_new_type_id();
      nsp_type_gtkmenushell = type;
      if ( nsp_register_type(nsp_type_gtkmenushell) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmenushell, GTK_TYPE_MENU_SHELL);
      return ( mode == T_BASE ) ? type : new_type_gtkmenushell(mode);
    }
  else 
    {
      type->id = nsp_type_gtkmenushell_id;
      return type;
    }
}

/*
 * initialize NspGtkMenuShell instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmenushell(NspGtkMenuShell *Obj,NspTypeGtkMenuShell *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkMenuShell 
 */

NspGtkMenuShell *new_gtkmenushell() 
{
  NspGtkMenuShell *loc;
  /* type must exists */
  nsp_type_gtkmenushell = new_type_gtkmenushell(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMenuShell)))== NULLGTKMENUSHELL) return loc;
  /* initialize object */
  if ( init_gtkmenushell(loc,nsp_type_gtkmenushell) == FAIL) return NULLGTKMENUSHELL;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkMenuShell 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkmenushell_type_name[]="GtkMenuShell";
static char gtkmenushell_short_type_name[]="GtkMenuShell";

static char *nsp_gtkmenushell_type_as_string(void)
{
  return(gtkmenushell_type_name);
}

static char *nsp_gtkmenushell_type_short_string(NspObject *v)
{
  return(gtkmenushell_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkMenuShell objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkMenuShell   *nsp_gtkmenushell_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkmenushell_id)  == TRUE  ) return ((NspGtkMenuShell *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmenushell));
  return NULL;
}

int IsGtkMenuShellObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkmenushell_id);
}

int IsGtkMenuShell(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmenushell_id);
}

NspGtkMenuShell  *GetGtkMenuShellCopy(Stack stack, int i)
{
  if (  GetGtkMenuShell(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMenuShell  *GetGtkMenuShell(Stack stack, int i)
{
  NspGtkMenuShell *M;
  if (( M = nsp_gtkmenushell_object(NthObj(i))) == NULLGTKMENUSHELL)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMenuShell *gtkmenushell_copy(NspGtkMenuShell *self)
{
  /* return gtkcontainer_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenushell);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmenushell);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMenuShell
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_menu_shell_append(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_menu_shell_append(GTK_MENU_SHELL(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_menu_shell_prepend(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *child;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child) == FAIL) return RET_BUG;
    gtk_menu_shell_prepend(GTK_MENU_SHELL(self->obj),GTK_WIDGET(child->obj));
  return 0;
}

static int _wrap_gtk_menu_shell_insert(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *child;
  int position;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &child, &position) == FAIL) return RET_BUG;
    gtk_menu_shell_insert(GTK_MENU_SHELL(self->obj),GTK_WIDGET(child->obj),position);
  return 0;
}

static int _wrap_gtk_menu_shell_deactivate(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_menu_shell_deactivate(GTK_MENU_SHELL(self->obj));
  return 0;
}

static int _wrap_gtk_menu_shell_select_item(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *menu_item;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &menu_item) == FAIL) return RET_BUG;
    gtk_menu_shell_select_item(GTK_MENU_SHELL(self->obj),GTK_WIDGET(menu_item->obj));
  return 0;
}

static int _wrap_gtk_menu_shell_deselect(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_menu_shell_deselect(GTK_MENU_SHELL(self->obj));
  return 0;
}

static int _wrap_gtk_menu_shell_activate_item(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *menu_item;
  int force_deactivate;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &menu_item, &force_deactivate) == FAIL) return RET_BUG;
    gtk_menu_shell_activate_item(GTK_MENU_SHELL(self->obj),GTK_WIDGET(menu_item->obj),force_deactivate);
  return 0;
}

static int _wrap_gtk_menu_shell_select_first(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int search_sensitive;
  if ( GetArgs(stack,rhs,opt,T,&search_sensitive) == FAIL) return RET_BUG;
    gtk_menu_shell_select_first(GTK_MENU_SHELL(self->obj),search_sensitive);
  return 0;
}

static int _wrap_gtk_menu_shell_cancel(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_menu_shell_cancel(GTK_MENU_SHELL(self->obj));
  return 0;
}

static int _wrap_gtk_menu_shell_get_take_focus(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_menu_shell_get_take_focus(GTK_MENU_SHELL(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_menu_shell_set_take_focus(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int take_focus;
  if ( GetArgs(stack,rhs,opt,T,&take_focus) == FAIL) return RET_BUG;
    gtk_menu_shell_set_take_focus(GTK_MENU_SHELL(self->obj),take_focus);
  return 0;
}

static int _wrap_gtk_menu_shell_get_selected_item(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_menu_shell_get_selected_item(GTK_MENU_SHELL(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_menu_shell_get_parent_shell(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_menu_shell_get_parent_shell(GTK_MENU_SHELL(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,6,0)
static int _wrap_gtk_menu_shell_bind_model(NspGtkMenuShell *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,string,s_bool, t_end};
  NspGObject *model;
  char *action_namespace;
  int with_separators;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gmenumodel, &model, &action_namespace, &with_separators) == FAIL) return RET_BUG;
    gtk_menu_shell_bind_model(GTK_MENU_SHELL(self->obj),G_MENU_MODEL(model->obj),action_namespace,with_separators);
  return 0;
}

#else
int _wrap_gtk_menu_shell_bind_model(Stack stack, int rhs, int opt, int lhs) /* bind_model */
{
  Scierror("Error: function gtk_menu_shell_bind_model not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkmenushell_methods[] = {
  {"append",(nsp_method *) _wrap_gtk_menu_shell_append},
  {"prepend",(nsp_method *) _wrap_gtk_menu_shell_prepend},
  {"insert",(nsp_method *) _wrap_gtk_menu_shell_insert},
  {"deactivate",(nsp_method *) _wrap_gtk_menu_shell_deactivate},
  {"select_item",(nsp_method *) _wrap_gtk_menu_shell_select_item},
  {"deselect",(nsp_method *) _wrap_gtk_menu_shell_deselect},
  {"activate_item",(nsp_method *) _wrap_gtk_menu_shell_activate_item},
  {"select_first",(nsp_method *) _wrap_gtk_menu_shell_select_first},
  {"cancel",(nsp_method *) _wrap_gtk_menu_shell_cancel},
  {"get_take_focus",(nsp_method *) _wrap_gtk_menu_shell_get_take_focus},
  {"set_take_focus",(nsp_method *) _wrap_gtk_menu_shell_set_take_focus},
  {"get_selected_item",(nsp_method *) _wrap_gtk_menu_shell_get_selected_item},
  {"get_parent_shell",(nsp_method *) _wrap_gtk_menu_shell_get_parent_shell},
  {"bind_model",(nsp_method *) _wrap_gtk_menu_shell_bind_model},
  { NULL, NULL}
};

static NspMethods *gtkmenushell_get_methods(void) { return gtkmenushell_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmenushell_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRange ----------- */


#define  NspGtkRange_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkrange.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRange inherits from GtkWidget 
 * and implements GtkBuildable
 */

int nsp_type_gtkrange_id=0;
NspTypeGtkRange *nsp_type_gtkrange=NULL;

/*
 * Type object for NspGtkRange 
 * all the instance of NspTypeGtkRange share the same id. 
 * nsp_type_gtkrange: is an instance of NspTypeGtkRange 
 *    used for objects of NspGtkRange type (i.e built with new_gtkrange) 
 * other instances are used for derived classes 
 */
NspTypeGtkRange *new_type_gtkrange(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkRange *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkrange != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkrange;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkrange_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkrange_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkrange;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkrange */ 

  top->s_type =  (s_type_func *) nsp_gtkrange_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkrange_type_short_string;
  /* top->create = (create_func*) int_gtkrange_create;*/

  /* specific methods for gtkrange */

  type->init = (init_func *) init_gtkrange;

  /* 
   * NspGtkRange interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkrange_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRange called nsp_type_gtkrange
       */
      type->id =  nsp_type_gtkrange_id = nsp_new_type_id();
      nsp_type_gtkrange = type;
      if ( nsp_register_type(nsp_type_gtkrange) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkrange, GTK_TYPE_RANGE);
      return ( mode == T_BASE ) ? type : new_type_gtkrange(mode);
    }
  else 
    {
      type->id = nsp_type_gtkrange_id;
      return type;
    }
}

/*
 * initialize NspGtkRange instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkrange(NspGtkRange *Obj,NspTypeGtkRange *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRange 
 */

NspGtkRange *new_gtkrange() 
{
  NspGtkRange *loc;
  /* type must exists */
  nsp_type_gtkrange = new_type_gtkrange(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRange)))== NULLGTKRANGE) return loc;
  /* initialize object */
  if ( init_gtkrange(loc,nsp_type_gtkrange) == FAIL) return NULLGTKRANGE;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRange 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkrange_type_name[]="GtkRange";
static char gtkrange_short_type_name[]="GtkRange";

static char *nsp_gtkrange_type_as_string(void)
{
  return(gtkrange_type_name);
}

static char *nsp_gtkrange_type_short_string(NspObject *v)
{
  return(gtkrange_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRange objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRange   *nsp_gtkrange_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkrange_id)  == TRUE  ) return ((NspGtkRange *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkrange));
  return NULL;
}

int IsGtkRangeObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkrange_id);
}

int IsGtkRange(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkrange_id);
}

NspGtkRange  *GetGtkRangeCopy(Stack stack, int i)
{
  if (  GetGtkRange(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRange  *GetGtkRange(Stack stack, int i)
{
  NspGtkRange *M;
  if (( M = nsp_gtkrange_object(NthObj(i))) == NULLGTKRANGE)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRange *gtkrange_copy(NspGtkRange *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrange);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrange);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRange
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_range_set_adjustment(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *adjustment;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkadjustment, &adjustment) == FAIL) return RET_BUG;
    gtk_range_set_adjustment(GTK_RANGE(self->obj),GTK_ADJUSTMENT(adjustment->obj));
  return 0;
}

static int _wrap_gtk_range_get_adjustment(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAdjustment *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_range_get_adjustment(GTK_RANGE(self->obj));
  nsp_type_gtkadjustment = new_type_gtkadjustment(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkadjustment))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_range_set_inverted(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_range_set_inverted(GTK_RANGE(self->obj),setting);
  return 0;
}

static int _wrap_gtk_range_get_inverted(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_range_get_inverted(GTK_RANGE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_set_flippable(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int flippable;
  if ( GetArgs(stack,rhs,opt,T,&flippable) == FAIL) return RET_BUG;
    gtk_range_set_flippable(GTK_RANGE(self->obj),flippable);
  return 0;
}

static int _wrap_gtk_range_get_flippable(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_range_get_flippable(GTK_RANGE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_set_slider_size_fixed(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int size_fixed;
  if ( GetArgs(stack,rhs,opt,T,&size_fixed) == FAIL) return RET_BUG;
    gtk_range_set_slider_size_fixed(GTK_RANGE(self->obj),size_fixed);
  return 0;
}

static int _wrap_gtk_range_get_slider_size_fixed(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_range_get_slider_size_fixed(GTK_RANGE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_set_min_slider_size(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int min_size;
  if ( GetArgs(stack,rhs,opt,T,&min_size) == FAIL) return RET_BUG;
    gtk_range_set_min_slider_size(GTK_RANGE(self->obj),min_size);
  return 0;
}

static int _wrap_gtk_range_get_min_slider_size(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_range_get_min_slider_size(GTK_RANGE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_get_range_rect(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkRectangle range_rect = { 0, 0, 0, 0 };
  NspObject *nsp_range_rect;
  if ( GetArgs(stack,rhs,opt,T,&nsp_range_rect) == FAIL) return RET_BUG;
  if (!nsp_gdk_rectangle_from_object(nsp_range_rect, &range_rect))
      return RET_BUG;
    gtk_range_get_range_rect(GTK_RANGE(self->obj),&range_rect);
  return 0;
}

static int _wrap_gtk_range_get_slider_range(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int slider_start, slider_end;
  if ( GetArgs(stack,rhs,opt,T,&slider_start, &slider_end) == FAIL) return RET_BUG;
    gtk_range_get_slider_range(GTK_RANGE(self->obj),&slider_start,&slider_end);
  return 0;
}

static int _wrap_gtk_range_set_lower_stepper_sensitivity(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSensitivityType sensitivity;
  NspObject *nsp_sensitivity = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_sensitivity) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SENSITIVITY_TYPE, nsp_sensitivity, &sensitivity)== FAIL)
      return RET_BUG;
    gtk_range_set_lower_stepper_sensitivity(GTK_RANGE(self->obj),sensitivity);
  return 0;
}

static int _wrap_gtk_range_get_lower_stepper_sensitivity(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_range_get_lower_stepper_sensitivity(GTK_RANGE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_set_upper_stepper_sensitivity(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkSensitivityType sensitivity;
  NspObject *nsp_sensitivity = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_sensitivity) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_SENSITIVITY_TYPE, nsp_sensitivity, &sensitivity)== FAIL)
      return RET_BUG;
    gtk_range_set_upper_stepper_sensitivity(GTK_RANGE(self->obj),sensitivity);
  return 0;
}

static int _wrap_gtk_range_get_upper_stepper_sensitivity(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_range_get_upper_stepper_sensitivity(GTK_RANGE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_set_increments(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,s_double, t_end};
  double step, page;
  if ( GetArgs(stack,rhs,opt,T,&step, &page) == FAIL) return RET_BUG;
    gtk_range_set_increments(GTK_RANGE(self->obj),step,page);
  return 0;
}

static int _wrap_gtk_range_set_range(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double,s_double, t_end};
  double min, max;
  if ( GetArgs(stack,rhs,opt,T,&min, &max) == FAIL) return RET_BUG;
    gtk_range_set_range(GTK_RANGE(self->obj),min,max);
  return 0;
}

static int _wrap_gtk_range_set_value(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double value;
  if ( GetArgs(stack,rhs,opt,T,&value) == FAIL) return RET_BUG;
    gtk_range_set_value(GTK_RANGE(self->obj),value);
  return 0;
}

static int _wrap_gtk_range_get_value(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_range_get_value(GTK_RANGE(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_set_show_fill_level(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int show_fill_level;
  if ( GetArgs(stack,rhs,opt,T,&show_fill_level) == FAIL) return RET_BUG;
    gtk_range_set_show_fill_level(GTK_RANGE(self->obj),show_fill_level);
  return 0;
}

static int _wrap_gtk_range_get_show_fill_level(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_range_get_show_fill_level(GTK_RANGE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_set_restrict_to_fill_level(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int restrict_to_fill_level;
  if ( GetArgs(stack,rhs,opt,T,&restrict_to_fill_level) == FAIL) return RET_BUG;
    gtk_range_set_restrict_to_fill_level(GTK_RANGE(self->obj),restrict_to_fill_level);
  return 0;
}

static int _wrap_gtk_range_get_restrict_to_fill_level(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_range_get_restrict_to_fill_level(GTK_RANGE(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_set_fill_level(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_double, t_end};
  double fill_level;
  if ( GetArgs(stack,rhs,opt,T,&fill_level) == FAIL) return RET_BUG;
    gtk_range_set_fill_level(GTK_RANGE(self->obj),fill_level);
  return 0;
}

static int _wrap_gtk_range_get_fill_level(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  double ret;
  CheckRhs(0,0);
    ret =gtk_range_get_fill_level(GTK_RANGE(self->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_range_set_round_digits(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int round_digits;
  if ( GetArgs(stack,rhs,opt,T,&round_digits) == FAIL) return RET_BUG;
    gtk_range_set_round_digits(GTK_RANGE(self->obj),round_digits);
  return 0;
}

static int _wrap_gtk_range_get_round_digits(NspGtkRange *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_range_get_round_digits(GTK_RANGE(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkrange_methods[] = {
  {"set_adjustment",(nsp_method *) _wrap_gtk_range_set_adjustment},
  {"get_adjustment",(nsp_method *) _wrap_gtk_range_get_adjustment},
  {"set_inverted",(nsp_method *) _wrap_gtk_range_set_inverted},
  {"get_inverted",(nsp_method *) _wrap_gtk_range_get_inverted},
  {"set_flippable",(nsp_method *) _wrap_gtk_range_set_flippable},
  {"get_flippable",(nsp_method *) _wrap_gtk_range_get_flippable},
  {"set_slider_size_fixed",(nsp_method *) _wrap_gtk_range_set_slider_size_fixed},
  {"get_slider_size_fixed",(nsp_method *) _wrap_gtk_range_get_slider_size_fixed},
  {"set_min_slider_size",(nsp_method *) _wrap_gtk_range_set_min_slider_size},
  {"get_min_slider_size",(nsp_method *) _wrap_gtk_range_get_min_slider_size},
  {"get_range_rect",(nsp_method *) _wrap_gtk_range_get_range_rect},
  {"get_slider_range",(nsp_method *) _wrap_gtk_range_get_slider_range},
  {"set_lower_stepper_sensitivity",(nsp_method *) _wrap_gtk_range_set_lower_stepper_sensitivity},
  {"get_lower_stepper_sensitivity",(nsp_method *) _wrap_gtk_range_get_lower_stepper_sensitivity},
  {"set_upper_stepper_sensitivity",(nsp_method *) _wrap_gtk_range_set_upper_stepper_sensitivity},
  {"get_upper_stepper_sensitivity",(nsp_method *) _wrap_gtk_range_get_upper_stepper_sensitivity},
  {"set_increments",(nsp_method *) _wrap_gtk_range_set_increments},
  {"set_range",(nsp_method *) _wrap_gtk_range_set_range},
  {"set_value",(nsp_method *) _wrap_gtk_range_set_value},
  {"get_value",(nsp_method *) _wrap_gtk_range_get_value},
  {"set_show_fill_level",(nsp_method *) _wrap_gtk_range_set_show_fill_level},
  {"get_show_fill_level",(nsp_method *) _wrap_gtk_range_get_show_fill_level},
  {"set_restrict_to_fill_level",(nsp_method *) _wrap_gtk_range_set_restrict_to_fill_level},
  {"get_restrict_to_fill_level",(nsp_method *) _wrap_gtk_range_get_restrict_to_fill_level},
  {"set_fill_level",(nsp_method *) _wrap_gtk_range_set_fill_level},
  {"get_fill_level",(nsp_method *) _wrap_gtk_range_get_fill_level},
  {"set_round_digits",(nsp_method *) _wrap_gtk_range_set_round_digits},
  {"get_round_digits",(nsp_method *) _wrap_gtk_range_get_round_digits},
  { NULL, NULL}
};

static NspMethods *gtkrange_get_methods(void) { return gtkrange_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkrange_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkIMContext ----------- */


#define  NspGtkIMContext_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkimcontext.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkIMContext inherits from GObject 
 */

int nsp_type_gtkimcontext_id=0;
NspTypeGtkIMContext *nsp_type_gtkimcontext=NULL;

/*
 * Type object for NspGtkIMContext 
 * all the instance of NspTypeGtkIMContext share the same id. 
 * nsp_type_gtkimcontext: is an instance of NspTypeGtkIMContext 
 *    used for objects of NspGtkIMContext type (i.e built with new_gtkimcontext) 
 * other instances are used for derived classes 
 */
NspTypeGtkIMContext *new_type_gtkimcontext(type_mode mode)
{
  NspTypeGtkIMContext *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkimcontext != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkimcontext;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkimcontext_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkimcontext_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkimcontext;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkimcontext */ 

  top->s_type =  (s_type_func *) nsp_gtkimcontext_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkimcontext_type_short_string;
  /* top->create = (create_func*) int_gtkimcontext_create;*/

  /* specific methods for gtkimcontext */

  type->init = (init_func *) init_gtkimcontext;

  /* 
   * NspGtkIMContext interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkimcontext_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIMContext called nsp_type_gtkimcontext
       */
      type->id =  nsp_type_gtkimcontext_id = nsp_new_type_id();
      nsp_type_gtkimcontext = type;
      if ( nsp_register_type(nsp_type_gtkimcontext) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkimcontext, GTK_TYPE_IM_CONTEXT);
      return ( mode == T_BASE ) ? type : new_type_gtkimcontext(mode);
    }
  else 
    {
      type->id = nsp_type_gtkimcontext_id;
      return type;
    }
}

/*
 * initialize NspGtkIMContext instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkimcontext(NspGtkIMContext *Obj,NspTypeGtkIMContext *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkIMContext 
 */

NspGtkIMContext *new_gtkimcontext() 
{
  NspGtkIMContext *loc;
  /* type must exists */
  nsp_type_gtkimcontext = new_type_gtkimcontext(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIMContext)))== NULLGTKIMCONTEXT) return loc;
  /* initialize object */
  if ( init_gtkimcontext(loc,nsp_type_gtkimcontext) == FAIL) return NULLGTKIMCONTEXT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkIMContext 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkimcontext_type_name[]="GtkIMContext";
static char gtkimcontext_short_type_name[]="GtkIMContext";

static char *nsp_gtkimcontext_type_as_string(void)
{
  return(gtkimcontext_type_name);
}

static char *nsp_gtkimcontext_type_short_string(NspObject *v)
{
  return(gtkimcontext_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkIMContext objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkIMContext   *nsp_gtkimcontext_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkimcontext_id)  == TRUE  ) return ((NspGtkIMContext *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkimcontext));
  return NULL;
}

int IsGtkIMContextObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkimcontext_id);
}

int IsGtkIMContext(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkimcontext_id);
}

NspGtkIMContext  *GetGtkIMContextCopy(Stack stack, int i)
{
  if (  GetGtkIMContext(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIMContext  *GetGtkIMContext(Stack stack, int i)
{
  NspGtkIMContext *M;
  if (( M = nsp_gtkimcontext_object(NthObj(i))) == NULLGTKIMCONTEXT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkIMContext *gtkimcontext_copy(NspGtkIMContext *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimcontext);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimcontext);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIMContext
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_im_context_set_client_window(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window) == FAIL) return RET_BUG;
    gtk_im_context_set_client_window(GTK_IM_CONTEXT(self->obj),GDK_WINDOW(window->obj));
  return 0;
}

#line 6687 "codegen-3.0/gtk.override"
static int
_wrap_gtk_im_context_get_preedit_string(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  /*
  gchar *str;
  PangoAttrList *attrs;
  gint cursor_pos;
  NspObject *ret;

  gtk_im_context_get_preedit_string(GTK_IM_CONTEXT(self->obj),
				    &str, &attrs, &cursor_pos);

  ret = Nsp_BuildValue("(sNi)", str, (NspObject *) gboxed_create(NVOID,PANGO_TYPE_ATTR_LIST, attrs,TRUE,TRUE,NULL),
  cursor_pos);
  g_free(str);

  return ret;
  */
  Scierror(" To be done gtk_im_context_get_preedit_string");
  return 0;
}
#line 68833 "gtk.c"


#line 6710 "codegen-3.0/gtk.override"
static int
_wrap_gtk_im_context_filter_keypress(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "key", NULL };*/
  NspObject *key;
  int ret;

  if (GetArgs(stack,rhs,opt,T,&key)  == FAIL) return RET_BUG;;

  if (!nspg_boxed_check(key, GDK_TYPE_EVENT)) {
    Scierror( "key must be a GdkEvent");
    return RET_BUG;
  }

  ret = gtk_im_context_filter_keypress(GTK_IM_CONTEXT(self->obj),
				       nspg_boxed_get(key, GdkEventKey));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}
#line 68857 "gtk.c"


static int _wrap_gtk_im_context_focus_in(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_im_context_focus_in(GTK_IM_CONTEXT(self->obj));
  return 0;
}

static int _wrap_gtk_im_context_focus_out(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_im_context_focus_out(GTK_IM_CONTEXT(self->obj));
  return 0;
}

static int _wrap_gtk_im_context_reset(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_im_context_reset(GTK_IM_CONTEXT(self->obj));
  return 0;
}

static int _wrap_gtk_im_context_set_use_preedit(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int use_preedit;
  if ( GetArgs(stack,rhs,opt,T,&use_preedit) == FAIL) return RET_BUG;
    gtk_im_context_set_use_preedit(GTK_IM_CONTEXT(self->obj),use_preedit);
  return 0;
}

static int _wrap_gtk_im_context_set_surrounding(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int,s_int, t_end};
  char *text;
  int len, cursor_index;
  if ( GetArgs(stack,rhs,opt,T,&text, &len, &cursor_index) == FAIL) return RET_BUG;
    gtk_im_context_set_surrounding(GTK_IM_CONTEXT(self->obj),text,len,cursor_index);
  return 0;
}

#line 6732 "codegen-3.0/gtk.override"
static int
_wrap_gtk_im_context_get_surrounding(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[]={string,s_int,t_end};
  gchar *text;
  gint cursor_index;
  int rep;
  if ( !gtk_im_context_get_surrounding(GTK_IM_CONTEXT(self->obj), &text, &cursor_index))
    {
      Scierror("%s: cannot get text\n",NspFname(stack));
      return RET_BUG;
    }
  rep = RetArgs(stack,lhs,T, text, cursor_index);
  g_free(text);
  return rep;
}
#line 68917 "gtk.c"


static int _wrap_gtk_im_context_delete_surrounding(NspGtkIMContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,s_int, t_end};
  int offset, n_chars, ret;
  if ( GetArgs(stack,rhs,opt,T,&offset, &n_chars) == FAIL) return RET_BUG;
    ret =gtk_im_context_delete_surrounding(GTK_IM_CONTEXT(self->obj),offset,n_chars);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkimcontext_methods[] = {
  {"set_client_window",(nsp_method *) _wrap_gtk_im_context_set_client_window},
  {"get_preedit_string",(nsp_method *) _wrap_gtk_im_context_get_preedit_string},
  {"filter_keypress",(nsp_method *) _wrap_gtk_im_context_filter_keypress},
  {"focus_in",(nsp_method *) _wrap_gtk_im_context_focus_in},
  {"focus_out",(nsp_method *) _wrap_gtk_im_context_focus_out},
  {"reset",(nsp_method *) _wrap_gtk_im_context_reset},
  {"set_use_preedit",(nsp_method *) _wrap_gtk_im_context_set_use_preedit},
  {"set_surrounding",(nsp_method *) _wrap_gtk_im_context_set_surrounding},
  {"get_surrounding",(nsp_method *) _wrap_gtk_im_context_get_surrounding},
  {"delete_surrounding",(nsp_method *) _wrap_gtk_im_context_delete_surrounding},
  { NULL, NULL}
};

static NspMethods *gtkimcontext_get_methods(void) { return gtkimcontext_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkimcontext_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRecentManager ----------- */


#define  NspGtkRecentManager_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkrecentmanager.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRecentManager inherits from GObject 
 */

int nsp_type_gtkrecentmanager_id=0;
NspTypeGtkRecentManager *nsp_type_gtkrecentmanager=NULL;

/*
 * Type object for NspGtkRecentManager 
 * all the instance of NspTypeGtkRecentManager share the same id. 
 * nsp_type_gtkrecentmanager: is an instance of NspTypeGtkRecentManager 
 *    used for objects of NspGtkRecentManager type (i.e built with new_gtkrecentmanager) 
 * other instances are used for derived classes 
 */
NspTypeGtkRecentManager *new_type_gtkrecentmanager(type_mode mode)
{
  NspTypeGtkRecentManager *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkrecentmanager != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkrecentmanager;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkrecentmanager_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkrecentmanager_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkrecentmanager;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkrecentmanager */ 

  top->s_type =  (s_type_func *) nsp_gtkrecentmanager_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkrecentmanager_type_short_string;
  /* top->create = (create_func*) int_gtkrecentmanager_create;*/

  /* specific methods for gtkrecentmanager */

  type->init = (init_func *) init_gtkrecentmanager;

  /* 
   * NspGtkRecentManager interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkrecentmanager_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRecentManager called nsp_type_gtkrecentmanager
       */
      type->id =  nsp_type_gtkrecentmanager_id = nsp_new_type_id();
      nsp_type_gtkrecentmanager = type;
      if ( nsp_register_type(nsp_type_gtkrecentmanager) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkrecentmanager, GTK_TYPE_RECENT_MANAGER);
      return ( mode == T_BASE ) ? type : new_type_gtkrecentmanager(mode);
    }
  else 
    {
      type->id = nsp_type_gtkrecentmanager_id;
      return type;
    }
}

/*
 * initialize NspGtkRecentManager instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkrecentmanager(NspGtkRecentManager *Obj,NspTypeGtkRecentManager *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRecentManager 
 */

NspGtkRecentManager *new_gtkrecentmanager() 
{
  NspGtkRecentManager *loc;
  /* type must exists */
  nsp_type_gtkrecentmanager = new_type_gtkrecentmanager(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRecentManager)))== NULLGTKRECENTMANAGER) return loc;
  /* initialize object */
  if ( init_gtkrecentmanager(loc,nsp_type_gtkrecentmanager) == FAIL) return NULLGTKRECENTMANAGER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRecentManager 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkrecentmanager_type_name[]="GtkRecentManager";
static char gtkrecentmanager_short_type_name[]="GtkRecentManager";

static char *nsp_gtkrecentmanager_type_as_string(void)
{
  return(gtkrecentmanager_type_name);
}

static char *nsp_gtkrecentmanager_type_short_string(NspObject *v)
{
  return(gtkrecentmanager_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRecentManager objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRecentManager   *nsp_gtkrecentmanager_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkrecentmanager_id)  == TRUE  ) return ((NspGtkRecentManager *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkrecentmanager));
  return NULL;
}

int IsGtkRecentManagerObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkrecentmanager_id);
}

int IsGtkRecentManager(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkrecentmanager_id);
}

NspGtkRecentManager  *GetGtkRecentManagerCopy(Stack stack, int i)
{
  if (  GetGtkRecentManager(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRecentManager  *GetGtkRecentManager(Stack stack, int i)
{
  NspGtkRecentManager *M;
  if (( M = nsp_gtkrecentmanager_object(NthObj(i))) == NULLGTKRECENTMANAGER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRecentManager *gtkrecentmanager_copy(NspGtkRecentManager *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrecentmanager);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrecentmanager);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRecentManager
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_recent_manager_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_recent_manager_new())== NULL) return RET_BUG;

  nsp_type_gtkrecentmanager = new_type_gtkrecentmanager(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkrecentmanager);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_recent_manager_add_item(NspGtkRecentManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    ret =gtk_recent_manager_add_item(GTK_RECENT_MANAGER(self->obj),uri);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_manager_remove_item(NspGtkRecentManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    ret =gtk_recent_manager_remove_item(GTK_RECENT_MANAGER(self->obj),uri,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_manager_has_item(NspGtkRecentManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *uri;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&uri) == FAIL) return RET_BUG;
    ret =gtk_recent_manager_has_item(GTK_RECENT_MANAGER(self->obj),uri);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_manager_move_item(NspGtkRecentManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,string, t_end};
  char *uri, *new_uri;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&uri, &new_uri) == FAIL) return RET_BUG;
    ret =gtk_recent_manager_move_item(GTK_RECENT_MANAGER(self->obj),uri,new_uri,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_manager_get_items(NspGtkRecentManager *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_recent_manager_get_items(GTK_RECENT_MANAGER(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

static int _wrap_gtk_recent_manager_purge_items(NspGtkRecentManager *self,Stack stack,int rhs,int opt,int lhs)
{
  GError *error = NULL;
  int ret;
  CheckRhs(0,0);
    ret =gtk_recent_manager_purge_items(GTK_RECENT_MANAGER(self->obj),&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkrecentmanager_methods[] = {
  {"add_item",(nsp_method *) _wrap_gtk_recent_manager_add_item},
  {"remove_item",(nsp_method *) _wrap_gtk_recent_manager_remove_item},
  {"has_item",(nsp_method *) _wrap_gtk_recent_manager_has_item},
  {"move_item",(nsp_method *) _wrap_gtk_recent_manager_move_item},
  {"get_items",(nsp_method *) _wrap_gtk_recent_manager_get_items},
  {"purge_items",(nsp_method *) _wrap_gtk_recent_manager_purge_items},
  { NULL, NULL}
};

static NspMethods *gtkrecentmanager_get_methods(void) { return gtkrecentmanager_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkrecentmanager_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRecentChooserDialog ----------- */


#define  NspGtkRecentChooserDialog_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkrecentchooserdialog.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRecentChooserDialog inherits from GtkDialog 
 * and implements GtkRecentChooser GtkBuildable
 */

int nsp_type_gtkrecentchooserdialog_id=0;
NspTypeGtkRecentChooserDialog *nsp_type_gtkrecentchooserdialog=NULL;

/*
 * Type object for NspGtkRecentChooserDialog 
 * all the instance of NspTypeGtkRecentChooserDialog share the same id. 
 * nsp_type_gtkrecentchooserdialog: is an instance of NspTypeGtkRecentChooserDialog 
 *    used for objects of NspGtkRecentChooserDialog type (i.e built with new_gtkrecentchooserdialog) 
 * other instances are used for derived classes 
 */
NspTypeGtkRecentChooserDialog *new_type_gtkrecentchooserdialog(type_mode mode)
{
  NspTypeGtkRecentChooser *t_gtkrecentchooser;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkRecentChooserDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkrecentchooserdialog != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkrecentchooserdialog;
    }
  if (( type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkrecentchooserdialog_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkrecentchooserdialog_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkrecentchooserdialog;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkrecentchooserdialog */ 

  top->s_type =  (s_type_func *) nsp_gtkrecentchooserdialog_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkrecentchooserdialog_type_short_string;
  /* top->create = (create_func*) int_gtkrecentchooserdialog_create;*/

  /* specific methods for gtkrecentchooserdialog */

  type->init = (init_func *) init_gtkrecentchooserdialog;

  /* 
   * NspGtkRecentChooserDialog interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkrecentchooser = new_type_gtkrecentchooser(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkrecentchooser;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkrecentchooserdialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRecentChooserDialog called nsp_type_gtkrecentchooserdialog
       */
      type->id =  nsp_type_gtkrecentchooserdialog_id = nsp_new_type_id();
      nsp_type_gtkrecentchooserdialog = type;
      if ( nsp_register_type(nsp_type_gtkrecentchooserdialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkrecentchooserdialog, GTK_TYPE_RECENT_CHOOSER_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkrecentchooserdialog(mode);
    }
  else 
    {
      type->id = nsp_type_gtkrecentchooserdialog_id;
      return type;
    }
}

/*
 * initialize NspGtkRecentChooserDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkrecentchooserdialog(NspGtkRecentChooserDialog *Obj,NspTypeGtkRecentChooserDialog *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRecentChooserDialog 
 */

NspGtkRecentChooserDialog *new_gtkrecentchooserdialog() 
{
  NspGtkRecentChooserDialog *loc;
  /* type must exists */
  nsp_type_gtkrecentchooserdialog = new_type_gtkrecentchooserdialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRecentChooserDialog)))== NULLGTKRECENTCHOOSERDIALOG) return loc;
  /* initialize object */
  if ( init_gtkrecentchooserdialog(loc,nsp_type_gtkrecentchooserdialog) == FAIL) return NULLGTKRECENTCHOOSERDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRecentChooserDialog 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkrecentchooserdialog_type_name[]="GtkRecentChooserDialog";
static char gtkrecentchooserdialog_short_type_name[]="GtkRecentChooserDialog";

static char *nsp_gtkrecentchooserdialog_type_as_string(void)
{
  return(gtkrecentchooserdialog_type_name);
}

static char *nsp_gtkrecentchooserdialog_type_short_string(NspObject *v)
{
  return(gtkrecentchooserdialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRecentChooserDialog objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRecentChooserDialog   *nsp_gtkrecentchooserdialog_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkrecentchooserdialog_id)  == TRUE  ) return ((NspGtkRecentChooserDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkrecentchooserdialog));
  return NULL;
}

int IsGtkRecentChooserDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkrecentchooserdialog_id);
}

int IsGtkRecentChooserDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkrecentchooserdialog_id);
}

NspGtkRecentChooserDialog  *GetGtkRecentChooserDialogCopy(Stack stack, int i)
{
  if (  GetGtkRecentChooserDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRecentChooserDialog  *GetGtkRecentChooserDialog(Stack stack, int i)
{
  NspGtkRecentChooserDialog *M;
  if (( M = nsp_gtkrecentchooserdialog_object(NthObj(i))) == NULLGTKRECENTCHOOSERDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRecentChooserDialog *gtkrecentchooserdialog_copy(NspGtkRecentChooserDialog *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrecentchooserdialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrecentchooserdialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRecentChooserDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 7905 "codegen-3.0/gtk.override"

static int
_wrap_gtk_recent_chooser_dialog_new_for_manager (Stack stack, int rhs, int opt, int lhs)
{
  NspObject *cell;
  int_types T[] = {string,obj_check,obj_check,obj_check,obj, t_end};
  char *title;
  NspGObject *parent, *manager;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&title, &nsp_type_gtkwindow, &parent,
	       &nsp_type_gtkrecentmanager, &manager, &nsp_type_cells,&cell) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_recent_chooser_dialog_new_for_manager(title,GTK_WINDOW(parent->obj),
								  GTK_RECENT_MANAGER(manager->obj),NULL,NULL))== NULL)
    return RET_BUG;
  Scierror("Error: Unfinished use the cell argument to add buttons to the dialog \n");
  return RET_BUG;
  nsp_type_gtkrecentchooserdialog = new_type_gtkrecentchooserdialog(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkrecentchooserdialog );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}


#line 69476 "gtk.c"


#line 7931 "codegen-3.0/gtk.override"

static int
_wrap_gtk_recent_chooser_dialog_new (Stack stack, int rhs, int opt, int lhs)
{
  NspObject *cell;
  int_types T[] = {string,obj_check,obj_check, t_end};
  char *title;
  NspGObject *parent;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&title, &nsp_type_gtkwindow, &parent, &nsp_type_cells,&cell) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_recent_chooser_dialog_new(title,GTK_WINDOW(parent->obj),NULL,NULL))== NULL) return RET_BUG;
  Scierror("Error: Unfinished use the cell argument to add buttons to the dialog \n");
  return RET_BUG;
  nsp_type_gtkrecentchooserdialog = new_type_gtkrecentchooserdialog(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkrecentchooserdialog );
   if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 69499 "gtk.c"


static NspMethods *gtkrecentchooserdialog_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkrecentchooserdialog_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRecentChooserWidget ----------- */


#define  NspGtkRecentChooserWidget_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkrecentchooserwidget.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRecentChooserWidget inherits from GtkBox 
 * and implements GtkRecentChooser GtkBuildable
 */

int nsp_type_gtkrecentchooserwidget_id=0;
NspTypeGtkRecentChooserWidget *nsp_type_gtkrecentchooserwidget=NULL;

/*
 * Type object for NspGtkRecentChooserWidget 
 * all the instance of NspTypeGtkRecentChooserWidget share the same id. 
 * nsp_type_gtkrecentchooserwidget: is an instance of NspTypeGtkRecentChooserWidget 
 *    used for objects of NspGtkRecentChooserWidget type (i.e built with new_gtkrecentchooserwidget) 
 * other instances are used for derived classes 
 */
NspTypeGtkRecentChooserWidget *new_type_gtkrecentchooserwidget(type_mode mode)
{
  NspTypeGtkRecentChooser *t_gtkrecentchooser;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkRecentChooserWidget *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkrecentchooserwidget != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkrecentchooserwidget;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkrecentchooserwidget_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkrecentchooserwidget_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkrecentchooserwidget;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkrecentchooserwidget */ 

  top->s_type =  (s_type_func *) nsp_gtkrecentchooserwidget_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkrecentchooserwidget_type_short_string;
  /* top->create = (create_func*) int_gtkrecentchooserwidget_create;*/

  /* specific methods for gtkrecentchooserwidget */

  type->init = (init_func *) init_gtkrecentchooserwidget;

  /* 
   * NspGtkRecentChooserWidget interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkrecentchooser = new_type_gtkrecentchooser(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkrecentchooser;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkrecentchooserwidget_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRecentChooserWidget called nsp_type_gtkrecentchooserwidget
       */
      type->id =  nsp_type_gtkrecentchooserwidget_id = nsp_new_type_id();
      nsp_type_gtkrecentchooserwidget = type;
      if ( nsp_register_type(nsp_type_gtkrecentchooserwidget) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkrecentchooserwidget, GTK_TYPE_RECENT_CHOOSER_WIDGET);
      return ( mode == T_BASE ) ? type : new_type_gtkrecentchooserwidget(mode);
    }
  else 
    {
      type->id = nsp_type_gtkrecentchooserwidget_id;
      return type;
    }
}

/*
 * initialize NspGtkRecentChooserWidget instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkrecentchooserwidget(NspGtkRecentChooserWidget *Obj,NspTypeGtkRecentChooserWidget *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRecentChooserWidget 
 */

NspGtkRecentChooserWidget *new_gtkrecentchooserwidget() 
{
  NspGtkRecentChooserWidget *loc;
  /* type must exists */
  nsp_type_gtkrecentchooserwidget = new_type_gtkrecentchooserwidget(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRecentChooserWidget)))== NULLGTKRECENTCHOOSERWIDGET) return loc;
  /* initialize object */
  if ( init_gtkrecentchooserwidget(loc,nsp_type_gtkrecentchooserwidget) == FAIL) return NULLGTKRECENTCHOOSERWIDGET;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRecentChooserWidget 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkrecentchooserwidget_type_name[]="GtkRecentChooserWidget";
static char gtkrecentchooserwidget_short_type_name[]="GtkRecentChooserWidget";

static char *nsp_gtkrecentchooserwidget_type_as_string(void)
{
  return(gtkrecentchooserwidget_type_name);
}

static char *nsp_gtkrecentchooserwidget_type_short_string(NspObject *v)
{
  return(gtkrecentchooserwidget_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRecentChooserWidget objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRecentChooserWidget   *nsp_gtkrecentchooserwidget_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkrecentchooserwidget_id)  == TRUE  ) return ((NspGtkRecentChooserWidget *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkrecentchooserwidget));
  return NULL;
}

int IsGtkRecentChooserWidgetObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkrecentchooserwidget_id);
}

int IsGtkRecentChooserWidget(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkrecentchooserwidget_id);
}

NspGtkRecentChooserWidget  *GetGtkRecentChooserWidgetCopy(Stack stack, int i)
{
  if (  GetGtkRecentChooserWidget(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRecentChooserWidget  *GetGtkRecentChooserWidget(Stack stack, int i)
{
  NspGtkRecentChooserWidget *M;
  if (( M = nsp_gtkrecentchooserwidget_object(NthObj(i))) == NULLGTKRECENTCHOOSERWIDGET)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRecentChooserWidget *gtkrecentchooserwidget_copy(NspGtkRecentChooserWidget *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrecentchooserwidget);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrecentchooserwidget);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRecentChooserWidget
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_recent_chooser_widget_new_for_manager (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *manager;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkrecentmanager, &manager) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_recent_chooser_widget_new_for_manager(GTK_RECENT_MANAGER(manager->obj)))== NULL) return RET_BUG;

  nsp_type_gtkrecentchooserwidget = new_type_gtkrecentchooserwidget(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkrecentchooserwidget);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_recent_chooser_widget_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_recent_chooser_widget_new())== NULL) return RET_BUG;

  nsp_type_gtkrecentchooserwidget = new_type_gtkrecentchooserwidget(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkrecentchooserwidget);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods *gtkrecentchooserwidget_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkrecentchooserwidget_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRecentFilter ----------- */


#define  NspGtkRecentFilter_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkrecentfilter.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRecentFilter inherits from GObject 
 * and implements GtkBuildable
 */

int nsp_type_gtkrecentfilter_id=0;
NspTypeGtkRecentFilter *nsp_type_gtkrecentfilter=NULL;

/*
 * Type object for NspGtkRecentFilter 
 * all the instance of NspTypeGtkRecentFilter share the same id. 
 * nsp_type_gtkrecentfilter: is an instance of NspTypeGtkRecentFilter 
 *    used for objects of NspGtkRecentFilter type (i.e built with new_gtkrecentfilter) 
 * other instances are used for derived classes 
 */
NspTypeGtkRecentFilter *new_type_gtkrecentfilter(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkRecentFilter *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkrecentfilter != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkrecentfilter;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkrecentfilter_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkrecentfilter_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkrecentfilter;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkrecentfilter */ 

  top->s_type =  (s_type_func *) nsp_gtkrecentfilter_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkrecentfilter_type_short_string;
  /* top->create = (create_func*) int_gtkrecentfilter_create;*/

  /* specific methods for gtkrecentfilter */

  type->init = (init_func *) init_gtkrecentfilter;

  /* 
   * NspGtkRecentFilter interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkrecentfilter_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRecentFilter called nsp_type_gtkrecentfilter
       */
      type->id =  nsp_type_gtkrecentfilter_id = nsp_new_type_id();
      nsp_type_gtkrecentfilter = type;
      if ( nsp_register_type(nsp_type_gtkrecentfilter) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkrecentfilter, GTK_TYPE_RECENT_FILTER);
      return ( mode == T_BASE ) ? type : new_type_gtkrecentfilter(mode);
    }
  else 
    {
      type->id = nsp_type_gtkrecentfilter_id;
      return type;
    }
}

/*
 * initialize NspGtkRecentFilter instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkrecentfilter(NspGtkRecentFilter *Obj,NspTypeGtkRecentFilter *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRecentFilter 
 */

NspGtkRecentFilter *new_gtkrecentfilter() 
{
  NspGtkRecentFilter *loc;
  /* type must exists */
  nsp_type_gtkrecentfilter = new_type_gtkrecentfilter(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRecentFilter)))== NULLGTKRECENTFILTER) return loc;
  /* initialize object */
  if ( init_gtkrecentfilter(loc,nsp_type_gtkrecentfilter) == FAIL) return NULLGTKRECENTFILTER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRecentFilter 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkrecentfilter_type_name[]="GtkRecentFilter";
static char gtkrecentfilter_short_type_name[]="GtkRecentFilter";

static char *nsp_gtkrecentfilter_type_as_string(void)
{
  return(gtkrecentfilter_type_name);
}

static char *nsp_gtkrecentfilter_type_short_string(NspObject *v)
{
  return(gtkrecentfilter_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRecentFilter objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRecentFilter   *nsp_gtkrecentfilter_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkrecentfilter_id)  == TRUE  ) return ((NspGtkRecentFilter *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkrecentfilter));
  return NULL;
}

int IsGtkRecentFilterObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkrecentfilter_id);
}

int IsGtkRecentFilter(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkrecentfilter_id);
}

NspGtkRecentFilter  *GetGtkRecentFilterCopy(Stack stack, int i)
{
  if (  GetGtkRecentFilter(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRecentFilter  *GetGtkRecentFilter(Stack stack, int i)
{
  NspGtkRecentFilter *M;
  if (( M = nsp_gtkrecentfilter_object(NthObj(i))) == NULLGTKRECENTFILTER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRecentFilter *gtkrecentfilter_copy(NspGtkRecentFilter *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrecentfilter);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkrecentfilter);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRecentFilter
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_recent_filter_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_recent_filter_new())== NULL) return RET_BUG;

  nsp_type_gtkrecentfilter = new_type_gtkrecentfilter(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkrecentfilter);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_recent_filter_set_name(NspGtkRecentFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_recent_filter_set_name(GTK_RECENT_FILTER(self->obj),name);
  return 0;
}

static int _wrap_gtk_recent_filter_get_name(NspGtkRecentFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_recent_filter_get_name(GTK_RECENT_FILTER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_recent_filter_add_mime_type(NspGtkRecentFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *mime_type;
  if ( GetArgs(stack,rhs,opt,T,&mime_type) == FAIL) return RET_BUG;
    gtk_recent_filter_add_mime_type(GTK_RECENT_FILTER(self->obj),mime_type);
  return 0;
}

static int _wrap_gtk_recent_filter_add_pattern(NspGtkRecentFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *pattern;
  if ( GetArgs(stack,rhs,opt,T,&pattern) == FAIL) return RET_BUG;
    gtk_recent_filter_add_pattern(GTK_RECENT_FILTER(self->obj),pattern);
  return 0;
}

static int _wrap_gtk_recent_filter_add_pixbuf_formats(NspGtkRecentFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_recent_filter_add_pixbuf_formats(GTK_RECENT_FILTER(self->obj));
  return 0;
}

static int _wrap_gtk_recent_filter_add_application(NspGtkRecentFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *application;
  if ( GetArgs(stack,rhs,opt,T,&application) == FAIL) return RET_BUG;
    gtk_recent_filter_add_application(GTK_RECENT_FILTER(self->obj),application);
  return 0;
}

static int _wrap_gtk_recent_filter_add_group(NspGtkRecentFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *group;
  if ( GetArgs(stack,rhs,opt,T,&group) == FAIL) return RET_BUG;
    gtk_recent_filter_add_group(GTK_RECENT_FILTER(self->obj),group);
  return 0;
}

static int _wrap_gtk_recent_filter_add_age(NspGtkRecentFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int days;
  if ( GetArgs(stack,rhs,opt,T,&days) == FAIL) return RET_BUG;
    gtk_recent_filter_add_age(GTK_RECENT_FILTER(self->obj),days);
  return 0;
}

static int _wrap_gtk_recent_filter_get_needed(NspGtkRecentFilter *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_recent_filter_get_needed(GTK_RECENT_FILTER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkrecentfilter_methods[] = {
  {"set_name",(nsp_method *) _wrap_gtk_recent_filter_set_name},
  {"get_name",(nsp_method *) _wrap_gtk_recent_filter_get_name},
  {"add_mime_type",(nsp_method *) _wrap_gtk_recent_filter_add_mime_type},
  {"add_pattern",(nsp_method *) _wrap_gtk_recent_filter_add_pattern},
  {"add_pixbuf_formats",(nsp_method *) _wrap_gtk_recent_filter_add_pixbuf_formats},
  {"add_application",(nsp_method *) _wrap_gtk_recent_filter_add_application},
  {"add_group",(nsp_method *) _wrap_gtk_recent_filter_add_group},
  {"add_age",(nsp_method *) _wrap_gtk_recent_filter_add_age},
  {"get_needed",(nsp_method *) _wrap_gtk_recent_filter_get_needed},
  { NULL, NULL}
};

static NspMethods *gtkrecentfilter_get_methods(void) { return gtkrecentfilter_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkrecentfilter_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAppChooserButton ----------- */


#define  NspGtkAppChooserButton_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkappchooserbutton.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAppChooserButton inherits from GtkBox 
 * and implements GtkAppChooser GtkBuildable
 */

int nsp_type_gtkappchooserbutton_id=0;
NspTypeGtkAppChooserButton *nsp_type_gtkappchooserbutton=NULL;

/*
 * Type object for NspGtkAppChooserButton 
 * all the instance of NspTypeGtkAppChooserButton share the same id. 
 * nsp_type_gtkappchooserbutton: is an instance of NspTypeGtkAppChooserButton 
 *    used for objects of NspGtkAppChooserButton type (i.e built with new_gtkappchooserbutton) 
 * other instances are used for derived classes 
 */
NspTypeGtkAppChooserButton *new_type_gtkappchooserbutton(type_mode mode)
{
  NspTypeGtkAppChooser *t_gtkappchooser;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkAppChooserButton *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkappchooserbutton != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkappchooserbutton;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkappchooserbutton_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkappchooserbutton_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkappchooserbutton;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkappchooserbutton */ 

  top->s_type =  (s_type_func *) nsp_gtkappchooserbutton_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkappchooserbutton_type_short_string;
  /* top->create = (create_func*) int_gtkappchooserbutton_create;*/

  /* specific methods for gtkappchooserbutton */

  type->init = (init_func *) init_gtkappchooserbutton;

  /* 
   * NspGtkAppChooserButton interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkappchooser = new_type_gtkappchooser(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkappchooser;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkappchooserbutton_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAppChooserButton called nsp_type_gtkappchooserbutton
       */
      type->id =  nsp_type_gtkappchooserbutton_id = nsp_new_type_id();
      nsp_type_gtkappchooserbutton = type;
      if ( nsp_register_type(nsp_type_gtkappchooserbutton) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkappchooserbutton, GTK_TYPE_APP_CHOOSER_BUTTON);
      return ( mode == T_BASE ) ? type : new_type_gtkappchooserbutton(mode);
    }
  else 
    {
      type->id = nsp_type_gtkappchooserbutton_id;
      return type;
    }
}

/*
 * initialize NspGtkAppChooserButton instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkappchooserbutton(NspGtkAppChooserButton *Obj,NspTypeGtkAppChooserButton *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAppChooserButton 
 */

NspGtkAppChooserButton *new_gtkappchooserbutton() 
{
  NspGtkAppChooserButton *loc;
  /* type must exists */
  nsp_type_gtkappchooserbutton = new_type_gtkappchooserbutton(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAppChooserButton)))== NULLGTKAPPCHOOSERBUTTON) return loc;
  /* initialize object */
  if ( init_gtkappchooserbutton(loc,nsp_type_gtkappchooserbutton) == FAIL) return NULLGTKAPPCHOOSERBUTTON;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAppChooserButton 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkappchooserbutton_type_name[]="GtkAppChooserButton";
static char gtkappchooserbutton_short_type_name[]="GtkAppChooserButton";

static char *nsp_gtkappchooserbutton_type_as_string(void)
{
  return(gtkappchooserbutton_type_name);
}

static char *nsp_gtkappchooserbutton_type_short_string(NspObject *v)
{
  return(gtkappchooserbutton_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAppChooserButton objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAppChooserButton   *nsp_gtkappchooserbutton_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkappchooserbutton_id)  == TRUE  ) return ((NspGtkAppChooserButton *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkappchooserbutton));
  return NULL;
}

int IsGtkAppChooserButtonObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkappchooserbutton_id);
}

int IsGtkAppChooserButton(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkappchooserbutton_id);
}

NspGtkAppChooserButton  *GetGtkAppChooserButtonCopy(Stack stack, int i)
{
  if (  GetGtkAppChooserButton(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAppChooserButton  *GetGtkAppChooserButton(Stack stack, int i)
{
  NspGtkAppChooserButton *M;
  if (( M = nsp_gtkappchooserbutton_object(NthObj(i))) == NULLGTKAPPCHOOSERBUTTON)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAppChooserButton *gtkappchooserbutton_copy(NspGtkAppChooserButton *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkappchooserbutton);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkappchooserbutton);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAppChooserButton
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_app_chooser_button_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *content_type;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&content_type) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_app_chooser_button_new(content_type))== NULL) return RET_BUG;

  nsp_type_gtkappchooserbutton = new_type_gtkappchooserbutton(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkappchooserbutton);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_app_chooser_button_append_separator(NspGtkAppChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_app_chooser_button_append_separator(GTK_APP_CHOOSER_BUTTON(self->obj));
  return 0;
}

static int _wrap_gtk_app_chooser_button_append_custom_item(NspGtkAppChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,string,obj_check, t_end};
  char *name, *label;
  NspGObject *icon;
  if ( GetArgs(stack,rhs,opt,T,&name, &label, &nsp_type_gicon, &icon) == FAIL) return RET_BUG;
    gtk_app_chooser_button_append_custom_item(GTK_APP_CHOOSER_BUTTON(self->obj),name,label,G_ICON(icon->obj));
  return 0;
}

static int _wrap_gtk_app_chooser_button_set_active_custom_item(NspGtkAppChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_app_chooser_button_set_active_custom_item(GTK_APP_CHOOSER_BUTTON(self->obj),name);
  return 0;
}

static int _wrap_gtk_app_chooser_button_set_show_dialog_item(NspGtkAppChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_app_chooser_button_set_show_dialog_item(GTK_APP_CHOOSER_BUTTON(self->obj),setting);
  return 0;
}

static int _wrap_gtk_app_chooser_button_get_show_dialog_item(NspGtkAppChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_button_get_show_dialog_item(GTK_APP_CHOOSER_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_app_chooser_button_set_heading(NspGtkAppChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *heading;
  if ( GetArgs(stack,rhs,opt,T,&heading) == FAIL) return RET_BUG;
    gtk_app_chooser_button_set_heading(GTK_APP_CHOOSER_BUTTON(self->obj),heading);
  return 0;
}

static int _wrap_gtk_app_chooser_button_get_heading(NspGtkAppChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_button_get_heading(GTK_APP_CHOOSER_BUTTON(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_app_chooser_button_set_show_default_item(NspGtkAppChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_app_chooser_button_set_show_default_item(GTK_APP_CHOOSER_BUTTON(self->obj),setting);
  return 0;
}

#else
int _wrap_gtk_app_chooser_button_set_show_default_item(Stack stack, int rhs, int opt, int lhs) /* set_show_default_item */
{
  Scierror("Error: function gtk_app_chooser_button_set_show_default_item not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_app_chooser_button_get_show_default_item(NspGtkAppChooserButton *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_button_get_show_default_item(GTK_APP_CHOOSER_BUTTON(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_app_chooser_button_get_show_default_item(Stack stack, int rhs, int opt, int lhs) /* get_show_default_item */
{
  Scierror("Error: function gtk_app_chooser_button_get_show_default_item not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkappchooserbutton_methods[] = {
  {"append_separator",(nsp_method *) _wrap_gtk_app_chooser_button_append_separator},
  {"append_custom_item",(nsp_method *) _wrap_gtk_app_chooser_button_append_custom_item},
  {"set_active_custom_item",(nsp_method *) _wrap_gtk_app_chooser_button_set_active_custom_item},
  {"set_show_dialog_item",(nsp_method *) _wrap_gtk_app_chooser_button_set_show_dialog_item},
  {"get_show_dialog_item",(nsp_method *) _wrap_gtk_app_chooser_button_get_show_dialog_item},
  {"set_heading",(nsp_method *) _wrap_gtk_app_chooser_button_set_heading},
  {"get_heading",(nsp_method *) _wrap_gtk_app_chooser_button_get_heading},
  {"set_show_default_item",(nsp_method *) _wrap_gtk_app_chooser_button_set_show_default_item},
  {"get_show_default_item",(nsp_method *) _wrap_gtk_app_chooser_button_get_show_default_item},
  { NULL, NULL}
};

static NspMethods *gtkappchooserbutton_get_methods(void) { return gtkappchooserbutton_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkappchooserbutton_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAppChooserDialog ----------- */


#define  NspGtkAppChooserDialog_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkappchooserdialog.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAppChooserDialog inherits from GtkDialog 
 * and implements GtkAppChooser GtkBuildable
 */

int nsp_type_gtkappchooserdialog_id=0;
NspTypeGtkAppChooserDialog *nsp_type_gtkappchooserdialog=NULL;

/*
 * Type object for NspGtkAppChooserDialog 
 * all the instance of NspTypeGtkAppChooserDialog share the same id. 
 * nsp_type_gtkappchooserdialog: is an instance of NspTypeGtkAppChooserDialog 
 *    used for objects of NspGtkAppChooserDialog type (i.e built with new_gtkappchooserdialog) 
 * other instances are used for derived classes 
 */
NspTypeGtkAppChooserDialog *new_type_gtkappchooserdialog(type_mode mode)
{
  NspTypeGtkAppChooser *t_gtkappchooser;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkAppChooserDialog *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkappchooserdialog != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkappchooserdialog;
    }
  if (( type =  malloc(sizeof(NspTypeGtkDialog))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkdialog(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkappchooserdialog_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkappchooserdialog_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkappchooserdialog;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkappchooserdialog */ 

  top->s_type =  (s_type_func *) nsp_gtkappchooserdialog_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkappchooserdialog_type_short_string;
  /* top->create = (create_func*) int_gtkappchooserdialog_create;*/

  /* specific methods for gtkappchooserdialog */

  type->init = (init_func *) init_gtkappchooserdialog;

  /* 
   * NspGtkAppChooserDialog interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkappchooser = new_type_gtkappchooser(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkappchooser;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkappchooserdialog_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAppChooserDialog called nsp_type_gtkappchooserdialog
       */
      type->id =  nsp_type_gtkappchooserdialog_id = nsp_new_type_id();
      nsp_type_gtkappchooserdialog = type;
      if ( nsp_register_type(nsp_type_gtkappchooserdialog) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkappchooserdialog, GTK_TYPE_APP_CHOOSER_DIALOG);
      return ( mode == T_BASE ) ? type : new_type_gtkappchooserdialog(mode);
    }
  else 
    {
      type->id = nsp_type_gtkappchooserdialog_id;
      return type;
    }
}

/*
 * initialize NspGtkAppChooserDialog instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkappchooserdialog(NspGtkAppChooserDialog *Obj,NspTypeGtkAppChooserDialog *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAppChooserDialog 
 */

NspGtkAppChooserDialog *new_gtkappchooserdialog() 
{
  NspGtkAppChooserDialog *loc;
  /* type must exists */
  nsp_type_gtkappchooserdialog = new_type_gtkappchooserdialog(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAppChooserDialog)))== NULLGTKAPPCHOOSERDIALOG) return loc;
  /* initialize object */
  if ( init_gtkappchooserdialog(loc,nsp_type_gtkappchooserdialog) == FAIL) return NULLGTKAPPCHOOSERDIALOG;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAppChooserDialog 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkappchooserdialog_type_name[]="GtkAppChooserDialog";
static char gtkappchooserdialog_short_type_name[]="GtkAppChooserDialog";

static char *nsp_gtkappchooserdialog_type_as_string(void)
{
  return(gtkappchooserdialog_type_name);
}

static char *nsp_gtkappchooserdialog_type_short_string(NspObject *v)
{
  return(gtkappchooserdialog_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAppChooserDialog objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAppChooserDialog   *nsp_gtkappchooserdialog_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkappchooserdialog_id)  == TRUE  ) return ((NspGtkAppChooserDialog *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkappchooserdialog));
  return NULL;
}

int IsGtkAppChooserDialogObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkappchooserdialog_id);
}

int IsGtkAppChooserDialog(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkappchooserdialog_id);
}

NspGtkAppChooserDialog  *GetGtkAppChooserDialogCopy(Stack stack, int i)
{
  if (  GetGtkAppChooserDialog(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAppChooserDialog  *GetGtkAppChooserDialog(Stack stack, int i)
{
  NspGtkAppChooserDialog *M;
  if (( M = nsp_gtkappchooserdialog_object(NthObj(i))) == NULLGTKAPPCHOOSERDIALOG)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAppChooserDialog *gtkappchooserdialog_copy(NspGtkAppChooserDialog *self)
{
  /* return gtkdialog_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkappchooserdialog);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkappchooserdialog);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAppChooserDialog
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_app_chooser_dialog_new_for_content_type (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,obj,string, t_end};
  NspGObject *parent;
  GtkDialogFlags flags;
  NspObject *nsp_flags = NULL;
  char *content_type;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &parent, &nsp_flags, &content_type) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_app_chooser_dialog_new_for_content_type(GTK_WINDOW(parent->obj),flags,content_type))== NULL) return RET_BUG;

  nsp_type_gtkappchooserdialog = new_type_gtkappchooserdialog(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkappchooserdialog);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int
_wrap_gtk_app_chooser_dialog_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {obj_check,obj,obj_check, t_end};
  NspGObject *parent, *file;
  GtkDialogFlags flags;
  NspObject *nsp_flags = NULL;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwindow, &parent, &nsp_flags, &nsp_type_gfile, &file) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
  if ((ret = (GObject *)gtk_app_chooser_dialog_new(GTK_WINDOW(parent->obj),flags,G_FILE(file->obj)))== NULL) return RET_BUG;

  nsp_type_gtkappchooserdialog = new_type_gtkappchooserdialog(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkappchooserdialog);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_app_chooser_dialog_get_widget(NspGtkAppChooserDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_dialog_get_widget(GTK_APP_CHOOSER_DIALOG(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_app_chooser_dialog_set_heading(NspGtkAppChooserDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *heading;
  if ( GetArgs(stack,rhs,opt,T,&heading) == FAIL) return RET_BUG;
    gtk_app_chooser_dialog_set_heading(GTK_APP_CHOOSER_DIALOG(self->obj),heading);
  return 0;
}

static int _wrap_gtk_app_chooser_dialog_get_heading(NspGtkAppChooserDialog *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_dialog_get_heading(GTK_APP_CHOOSER_DIALOG(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkappchooserdialog_methods[] = {
  {"get_widget",(nsp_method *) _wrap_gtk_app_chooser_dialog_get_widget},
  {"set_heading",(nsp_method *) _wrap_gtk_app_chooser_dialog_set_heading},
  {"get_heading",(nsp_method *) _wrap_gtk_app_chooser_dialog_get_heading},
  { NULL, NULL}
};

static NspMethods *gtkappchooserdialog_get_methods(void) { return gtkappchooserdialog_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkappchooserdialog_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAppChooserWidget ----------- */


#define  NspGtkAppChooserWidget_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkappchooserwidget.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAppChooserWidget inherits from GtkBox 
 * and implements GtkAppChooser GtkBuildable
 */

int nsp_type_gtkappchooserwidget_id=0;
NspTypeGtkAppChooserWidget *nsp_type_gtkappchooserwidget=NULL;

/*
 * Type object for NspGtkAppChooserWidget 
 * all the instance of NspTypeGtkAppChooserWidget share the same id. 
 * nsp_type_gtkappchooserwidget: is an instance of NspTypeGtkAppChooserWidget 
 *    used for objects of NspGtkAppChooserWidget type (i.e built with new_gtkappchooserwidget) 
 * other instances are used for derived classes 
 */
NspTypeGtkAppChooserWidget *new_type_gtkappchooserwidget(type_mode mode)
{
  NspTypeGtkAppChooser *t_gtkappchooser;
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkAppChooserWidget *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkappchooserwidget != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkappchooserwidget;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBox))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbox(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkappchooserwidget_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkappchooserwidget_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkappchooserwidget;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkappchooserwidget */ 

  top->s_type =  (s_type_func *) nsp_gtkappchooserwidget_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkappchooserwidget_type_short_string;
  /* top->create = (create_func*) int_gtkappchooserwidget_create;*/

  /* specific methods for gtkappchooserwidget */

  type->init = (init_func *) init_gtkappchooserwidget;

  /* 
   * NspGtkAppChooserWidget interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkappchooser = new_type_gtkappchooser(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkappchooser;
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkappchooserwidget_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAppChooserWidget called nsp_type_gtkappchooserwidget
       */
      type->id =  nsp_type_gtkappchooserwidget_id = nsp_new_type_id();
      nsp_type_gtkappchooserwidget = type;
      if ( nsp_register_type(nsp_type_gtkappchooserwidget) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkappchooserwidget, GTK_TYPE_APP_CHOOSER_WIDGET);
      return ( mode == T_BASE ) ? type : new_type_gtkappchooserwidget(mode);
    }
  else 
    {
      type->id = nsp_type_gtkappchooserwidget_id;
      return type;
    }
}

/*
 * initialize NspGtkAppChooserWidget instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkappchooserwidget(NspGtkAppChooserWidget *Obj,NspTypeGtkAppChooserWidget *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAppChooserWidget 
 */

NspGtkAppChooserWidget *new_gtkappchooserwidget() 
{
  NspGtkAppChooserWidget *loc;
  /* type must exists */
  nsp_type_gtkappchooserwidget = new_type_gtkappchooserwidget(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAppChooserWidget)))== NULLGTKAPPCHOOSERWIDGET) return loc;
  /* initialize object */
  if ( init_gtkappchooserwidget(loc,nsp_type_gtkappchooserwidget) == FAIL) return NULLGTKAPPCHOOSERWIDGET;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAppChooserWidget 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkappchooserwidget_type_name[]="GtkAppChooserWidget";
static char gtkappchooserwidget_short_type_name[]="GtkAppChooserWidget";

static char *nsp_gtkappchooserwidget_type_as_string(void)
{
  return(gtkappchooserwidget_type_name);
}

static char *nsp_gtkappchooserwidget_type_short_string(NspObject *v)
{
  return(gtkappchooserwidget_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAppChooserWidget objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAppChooserWidget   *nsp_gtkappchooserwidget_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkappchooserwidget_id)  == TRUE  ) return ((NspGtkAppChooserWidget *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkappchooserwidget));
  return NULL;
}

int IsGtkAppChooserWidgetObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkappchooserwidget_id);
}

int IsGtkAppChooserWidget(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkappchooserwidget_id);
}

NspGtkAppChooserWidget  *GetGtkAppChooserWidgetCopy(Stack stack, int i)
{
  if (  GetGtkAppChooserWidget(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAppChooserWidget  *GetGtkAppChooserWidget(Stack stack, int i)
{
  NspGtkAppChooserWidget *M;
  if (( M = nsp_gtkappchooserwidget_object(NthObj(i))) == NULLGTKAPPCHOOSERWIDGET)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAppChooserWidget *gtkappchooserwidget_copy(NspGtkAppChooserWidget *self)
{
  /* return gtkbox_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkappchooserwidget);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkappchooserwidget);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAppChooserWidget
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_app_chooser_widget_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *content_type;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&content_type) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_app_chooser_widget_new(content_type))== NULL) return RET_BUG;

  nsp_type_gtkappchooserwidget = new_type_gtkappchooserwidget(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkappchooserwidget);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_app_chooser_widget_set_show_default(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_app_chooser_widget_set_show_default(GTK_APP_CHOOSER_WIDGET(self->obj),setting);
  return 0;
}

static int _wrap_gtk_app_chooser_widget_get_show_default(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_widget_get_show_default(GTK_APP_CHOOSER_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_app_chooser_widget_set_show_recommended(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_app_chooser_widget_set_show_recommended(GTK_APP_CHOOSER_WIDGET(self->obj),setting);
  return 0;
}

static int _wrap_gtk_app_chooser_widget_get_show_recommended(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_widget_get_show_recommended(GTK_APP_CHOOSER_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_app_chooser_widget_set_show_fallback(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_app_chooser_widget_set_show_fallback(GTK_APP_CHOOSER_WIDGET(self->obj),setting);
  return 0;
}

static int _wrap_gtk_app_chooser_widget_get_show_fallback(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_widget_get_show_fallback(GTK_APP_CHOOSER_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_app_chooser_widget_set_show_other(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_app_chooser_widget_set_show_other(GTK_APP_CHOOSER_WIDGET(self->obj),setting);
  return 0;
}

static int _wrap_gtk_app_chooser_widget_get_show_other(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_widget_get_show_other(GTK_APP_CHOOSER_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_app_chooser_widget_set_show_all(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_app_chooser_widget_set_show_all(GTK_APP_CHOOSER_WIDGET(self->obj),setting);
  return 0;
}

static int _wrap_gtk_app_chooser_widget_get_show_all(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_widget_get_show_all(GTK_APP_CHOOSER_WIDGET(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_app_chooser_widget_set_default_text(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *text;
  if ( GetArgs(stack,rhs,opt,T,&text) == FAIL) return RET_BUG;
    gtk_app_chooser_widget_set_default_text(GTK_APP_CHOOSER_WIDGET(self->obj),text);
  return 0;
}

static int _wrap_gtk_app_chooser_widget_get_default_text(NspGtkAppChooserWidget *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_app_chooser_widget_get_default_text(GTK_APP_CHOOSER_WIDGET(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkappchooserwidget_methods[] = {
  {"set_show_default",(nsp_method *) _wrap_gtk_app_chooser_widget_set_show_default},
  {"get_show_default",(nsp_method *) _wrap_gtk_app_chooser_widget_get_show_default},
  {"set_show_recommended",(nsp_method *) _wrap_gtk_app_chooser_widget_set_show_recommended},
  {"get_show_recommended",(nsp_method *) _wrap_gtk_app_chooser_widget_get_show_recommended},
  {"set_show_fallback",(nsp_method *) _wrap_gtk_app_chooser_widget_set_show_fallback},
  {"get_show_fallback",(nsp_method *) _wrap_gtk_app_chooser_widget_get_show_fallback},
  {"set_show_other",(nsp_method *) _wrap_gtk_app_chooser_widget_set_show_other},
  {"get_show_other",(nsp_method *) _wrap_gtk_app_chooser_widget_get_show_other},
  {"set_show_all",(nsp_method *) _wrap_gtk_app_chooser_widget_set_show_all},
  {"get_show_all",(nsp_method *) _wrap_gtk_app_chooser_widget_get_show_all},
  {"set_default_text",(nsp_method *) _wrap_gtk_app_chooser_widget_set_default_text},
  {"get_default_text",(nsp_method *) _wrap_gtk_app_chooser_widget_get_default_text},
  { NULL, NULL}
};

static NspMethods *gtkappchooserwidget_get_methods(void) { return gtkappchooserwidget_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkappchooserwidget_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkSettings ----------- */


#define  NspGtkSettings_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtksettings.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkSettings inherits from GObject 
 */

int nsp_type_gtksettings_id=0;
NspTypeGtkSettings *nsp_type_gtksettings=NULL;

/*
 * Type object for NspGtkSettings 
 * all the instance of NspTypeGtkSettings share the same id. 
 * nsp_type_gtksettings: is an instance of NspTypeGtkSettings 
 *    used for objects of NspGtkSettings type (i.e built with new_gtksettings) 
 * other instances are used for derived classes 
 */
NspTypeGtkSettings *new_type_gtksettings(type_mode mode)
{
  NspTypeGtkSettings *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtksettings != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtksettings;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtksettings_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtksettings_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtksettings;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtksettings */ 

  top->s_type =  (s_type_func *) nsp_gtksettings_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtksettings_type_short_string;
  /* top->create = (create_func*) int_gtksettings_create;*/

  /* specific methods for gtksettings */

  type->init = (init_func *) init_gtksettings;

  /* 
   * NspGtkSettings interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtksettings_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkSettings called nsp_type_gtksettings
       */
      type->id =  nsp_type_gtksettings_id = nsp_new_type_id();
      nsp_type_gtksettings = type;
      if ( nsp_register_type(nsp_type_gtksettings) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtksettings, GTK_TYPE_SETTINGS);
      return ( mode == T_BASE ) ? type : new_type_gtksettings(mode);
    }
  else 
    {
      type->id = nsp_type_gtksettings_id;
      return type;
    }
}

/*
 * initialize NspGtkSettings instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtksettings(NspGtkSettings *Obj,NspTypeGtkSettings *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkSettings 
 */

NspGtkSettings *new_gtksettings() 
{
  NspGtkSettings *loc;
  /* type must exists */
  nsp_type_gtksettings = new_type_gtksettings(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkSettings)))== NULLGTKSETTINGS) return loc;
  /* initialize object */
  if ( init_gtksettings(loc,nsp_type_gtksettings) == FAIL) return NULLGTKSETTINGS;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkSettings 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtksettings_type_name[]="GtkSettings";
static char gtksettings_short_type_name[]="GtkSettings";

static char *nsp_gtksettings_type_as_string(void)
{
  return(gtksettings_type_name);
}

static char *nsp_gtksettings_type_short_string(NspObject *v)
{
  return(gtksettings_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkSettings objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkSettings   *nsp_gtksettings_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtksettings_id)  == TRUE  ) return ((NspGtkSettings *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtksettings));
  return NULL;
}

int IsGtkSettingsObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtksettings_id);
}

int IsGtkSettings(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtksettings_id);
}

NspGtkSettings  *GetGtkSettingsCopy(Stack stack, int i)
{
  if (  GetGtkSettings(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkSettings  *GetGtkSettings(Stack stack, int i)
{
  NspGtkSettings *M;
  if (( M = nsp_gtksettings_object(NthObj(i))) == NULLGTKSETTINGS)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkSettings *gtksettings_copy(NspGtkSettings *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksettings);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtksettings);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkSettings
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#if GTK_CHECK_VERSION(3,16,0)
int _wrap_gtk_settings_set_string_property(Stack stack, int rhs, int opt, int lhs) /* set_string_property */
{
  Scierror("Error: function gtk_settings_set_string_property is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_settings_set_string_property(NspGtkSettings *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,string,string, t_end};
  char *name, *v_string, *origin;
  if ( GetArgs(stack,rhs,opt,T,&name, &v_string, &origin) == FAIL) return RET_BUG;
    gtk_settings_set_string_property(GTK_SETTINGS(self->obj),name,v_string,origin);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,16,0)
int _wrap_gtk_settings_set_long_property(Stack stack, int rhs, int opt, int lhs) /* set_long_property */
{
  Scierror("Error: function gtk_settings_set_long_property is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_settings_set_long_property(NspGtkSettings *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int,string, t_end};
  char *name, *origin;
  int v_long;
  if ( GetArgs(stack,rhs,opt,T,&name, &v_long, &origin) == FAIL) return RET_BUG;
    gtk_settings_set_long_property(GTK_SETTINGS(self->obj),name,v_long,origin);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,16,0)
int _wrap_gtk_settings_set_double_property(Stack stack, int rhs, int opt, int lhs) /* set_double_property */
{
  Scierror("Error: function gtk_settings_set_double_property is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_settings_set_double_property(NspGtkSettings *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_double,string, t_end};
  char *name, *origin;
  double v_double;
  if ( GetArgs(stack,rhs,opt,T,&name, &v_double, &origin) == FAIL) return RET_BUG;
    gtk_settings_set_double_property(GTK_SETTINGS(self->obj),name,v_double,origin);
  return 0;
}

#endif
static NspMethods gtksettings_methods[] = {
  {"set_string_property",(nsp_method *) _wrap_gtk_settings_set_string_property},
  {"set_long_property",(nsp_method *) _wrap_gtk_settings_set_long_property},
  {"set_double_property",(nsp_method *) _wrap_gtk_settings_set_double_property},
  { NULL, NULL}
};

static NspMethods *gtksettings_get_methods(void) { return gtksettings_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtksettings_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkStyleContext ----------- */


#define  NspGtkStyleContext_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkstylecontext.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkStyleContext inherits from GObject 
 */

int nsp_type_gtkstylecontext_id=0;
NspTypeGtkStyleContext *nsp_type_gtkstylecontext=NULL;

/*
 * Type object for NspGtkStyleContext 
 * all the instance of NspTypeGtkStyleContext share the same id. 
 * nsp_type_gtkstylecontext: is an instance of NspTypeGtkStyleContext 
 *    used for objects of NspGtkStyleContext type (i.e built with new_gtkstylecontext) 
 * other instances are used for derived classes 
 */
NspTypeGtkStyleContext *new_type_gtkstylecontext(type_mode mode)
{
  NspTypeGtkStyleContext *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkstylecontext != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkstylecontext;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkstylecontext_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkstylecontext_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkstylecontext;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkstylecontext */ 

  top->s_type =  (s_type_func *) nsp_gtkstylecontext_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkstylecontext_type_short_string;
  /* top->create = (create_func*) int_gtkstylecontext_create;*/

  /* specific methods for gtkstylecontext */

  type->init = (init_func *) init_gtkstylecontext;

  /* 
   * NspGtkStyleContext interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkstylecontext_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkStyleContext called nsp_type_gtkstylecontext
       */
      type->id =  nsp_type_gtkstylecontext_id = nsp_new_type_id();
      nsp_type_gtkstylecontext = type;
      if ( nsp_register_type(nsp_type_gtkstylecontext) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkstylecontext, GTK_TYPE_STYLE_CONTEXT);
      return ( mode == T_BASE ) ? type : new_type_gtkstylecontext(mode);
    }
  else 
    {
      type->id = nsp_type_gtkstylecontext_id;
      return type;
    }
}

/*
 * initialize NspGtkStyleContext instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkstylecontext(NspGtkStyleContext *Obj,NspTypeGtkStyleContext *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkStyleContext 
 */

NspGtkStyleContext *new_gtkstylecontext() 
{
  NspGtkStyleContext *loc;
  /* type must exists */
  nsp_type_gtkstylecontext = new_type_gtkstylecontext(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkStyleContext)))== NULLGTKSTYLECONTEXT) return loc;
  /* initialize object */
  if ( init_gtkstylecontext(loc,nsp_type_gtkstylecontext) == FAIL) return NULLGTKSTYLECONTEXT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkStyleContext 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkstylecontext_type_name[]="GtkStyleContext";
static char gtkstylecontext_short_type_name[]="GtkStyleContext";

static char *nsp_gtkstylecontext_type_as_string(void)
{
  return(gtkstylecontext_type_name);
}

static char *nsp_gtkstylecontext_type_short_string(NspObject *v)
{
  return(gtkstylecontext_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkStyleContext objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkStyleContext   *nsp_gtkstylecontext_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkstylecontext_id)  == TRUE  ) return ((NspGtkStyleContext *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkstylecontext));
  return NULL;
}

int IsGtkStyleContextObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkstylecontext_id);
}

int IsGtkStyleContext(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkstylecontext_id);
}

NspGtkStyleContext  *GetGtkStyleContextCopy(Stack stack, int i)
{
  if (  GetGtkStyleContext(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkStyleContext  *GetGtkStyleContext(Stack stack, int i)
{
  NspGtkStyleContext *M;
  if (( M = nsp_gtkstylecontext_object(NthObj(i))) == NULLGTKSTYLECONTEXT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkStyleContext *gtkstylecontext_copy(NspGtkStyleContext *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstylecontext);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstylecontext);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkStyleContext
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_style_context_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_style_context_new())== NULL) return RET_BUG;

  nsp_type_gtkstylecontext = new_type_gtkstylecontext(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstylecontext);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_style_context_add_provider(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *provider;
  int priority;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstyleprovider, &provider, &priority) == FAIL) return RET_BUG;
    gtk_style_context_add_provider(GTK_STYLE_CONTEXT(self->obj),GTK_STYLE_PROVIDER(provider->obj),priority);
  return 0;
}

static int _wrap_gtk_style_context_remove_provider(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *provider;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstyleprovider, &provider) == FAIL) return RET_BUG;
    gtk_style_context_remove_provider(GTK_STYLE_CONTEXT(self->obj),GTK_STYLE_PROVIDER(provider->obj));
  return 0;
}

static int _wrap_gtk_style_context_save(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_style_context_save(GTK_STYLE_CONTEXT(self->obj));
  return 0;
}

static int _wrap_gtk_style_context_restore(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_style_context_restore(GTK_STYLE_CONTEXT(self->obj));
  return 0;
}

static int _wrap_gtk_style_context_get_section(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *property;
  GtkCssSection *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&property) == FAIL) return RET_BUG;
    ret =gtk_style_context_get_section(GTK_STYLE_CONTEXT(self->obj),property);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_CSS_SECTION, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkcsssection))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 7972 "codegen-3.0/gtk.override"

static int _wrap_gtk_style_context_get_property(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *ret;
  GValue value = { 0, } ;
  int_types T[] = {string,obj, t_end};
  char *property;
  GtkStateFlags state;
  NspObject *nsp_state = NULL;
  if ( GetArgs(stack,rhs,opt,T,&property, &nsp_state) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_STATE_FLAGS, nsp_state, &state)==FAIL)
      return RET_BUG;
  gtk_style_context_get_property(GTK_STYLE_CONTEXT(self->obj),property,state,&value);
  if ((ret = nspg_value_as_nspobject(&value, TRUE))==NULL)
    {
      g_value_unset(&value);
      return RET_BUG;
    }
  g_value_unset(&value);
  MoveObj(stack,1,ret);
  return 1;
}

#line 71552 "gtk.c"


#line 7997 "codegen-3.0/gtk.override"

static int _wrap_gtk_style_context_get(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  Scierror("Error: not implemented, you can insted use method get_property\n");
  return RET_BUG;
}

#line 71563 "gtk.c"


static int _wrap_gtk_style_context_set_state(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkStateFlags flags;
  NspObject *nsp_flags = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_STATE_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    gtk_style_context_set_state(GTK_STYLE_CONTEXT(self->obj),flags);
  return 0;
}

static int _wrap_gtk_style_context_get_state(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_style_context_get_state(GTK_STYLE_CONTEXT(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_style_context_set_scale(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int scale;
  if ( GetArgs(stack,rhs,opt,T,&scale) == FAIL) return RET_BUG;
    gtk_style_context_set_scale(GTK_STYLE_CONTEXT(self->obj),scale);
  return 0;
}

#else
int _wrap_gtk_style_context_set_scale(Stack stack, int rhs, int opt, int lhs) /* set_scale */
{
  Scierror("Error: function gtk_style_context_set_scale not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_style_context_get_scale(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_style_context_get_scale(GTK_STYLE_CONTEXT(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

#else
int _wrap_gtk_style_context_get_scale(Stack stack, int rhs, int opt, int lhs) /* get_scale */
{
  Scierror("Error: function gtk_style_context_get_scale not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,6,0)
int _wrap_gtk_style_context_state_is_running(Stack stack, int rhs, int opt, int lhs) /* state_is_running */
{
  Scierror("Error: function gtk_style_context_state_is_running is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_style_context_state_is_running(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,s_double, t_end};
  GtkStateType state;
  NspObject *nsp_state = NULL;
  double progress;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_state, &progress) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_STATE_TYPE, nsp_state, &state)== FAIL)
      return RET_BUG;
    ret =gtk_style_context_state_is_running(GTK_STYLE_CONTEXT(self->obj),state,&progress);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#endif
#if GTK_CHECK_VERSION(3,4,0)
static int _wrap_gtk_style_context_set_parent(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *parent;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &parent) == FAIL) return RET_BUG;
    gtk_style_context_set_parent(GTK_STYLE_CONTEXT(self->obj),GTK_STYLE_CONTEXT(parent->obj));
  return 0;
}

#else
int _wrap_gtk_style_context_set_parent(Stack stack, int rhs, int opt, int lhs) /* set_parent */
{
  Scierror("Error: function gtk_style_context_set_parent not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_style_context_get_parent(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkStyleContext *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_style_context_get_parent(GTK_STYLE_CONTEXT(self->obj));
  nsp_type_gtkstylecontext = new_type_gtkstylecontext(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkstylecontext))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_style_context_list_classes(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_style_context_list_classes(GTK_STYLE_CONTEXT(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

static int _wrap_gtk_style_context_add_class(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *class_name;
  if ( GetArgs(stack,rhs,opt,T,&class_name) == FAIL) return RET_BUG;
    gtk_style_context_add_class(GTK_STYLE_CONTEXT(self->obj),class_name);
  return 0;
}

static int _wrap_gtk_style_context_remove_class(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *class_name;
  if ( GetArgs(stack,rhs,opt,T,&class_name) == FAIL) return RET_BUG;
    gtk_style_context_remove_class(GTK_STYLE_CONTEXT(self->obj),class_name);
  return 0;
}

static int _wrap_gtk_style_context_has_class(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *class_name;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&class_name) == FAIL) return RET_BUG;
    ret =gtk_style_context_has_class(GTK_STYLE_CONTEXT(self->obj),class_name);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_style_context_list_regions(Stack stack, int rhs, int opt, int lhs) /* list_regions */
{
  Scierror("Error: function gtk_style_context_list_regions is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_style_context_list_regions(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_style_context_list_regions(GTK_STYLE_CONTEXT(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

#endif
#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_style_context_add_region(Stack stack, int rhs, int opt, int lhs) /* add_region */
{
  Scierror("Error: function gtk_style_context_add_region is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_style_context_add_region(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *region_name;
  GtkRegionFlags flags;
  NspObject *nsp_flags = NULL;
  if ( GetArgs(stack,rhs,opt,T,&region_name, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_REGION_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    gtk_style_context_add_region(GTK_STYLE_CONTEXT(self->obj),region_name,flags);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,14,0)
int _wrap_gtk_style_context_remove_region(Stack stack, int rhs, int opt, int lhs) /* remove_region */
{
  Scierror("Error: function gtk_style_context_remove_region is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_style_context_remove_region(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *region_name;
  if ( GetArgs(stack,rhs,opt,T,&region_name) == FAIL) return RET_BUG;
    gtk_style_context_remove_region(GTK_STYLE_CONTEXT(self->obj),region_name);
  return 0;
}

#endif
static int _wrap_gtk_style_context_get_style(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_style_context_get_style(GTK_STYLE_CONTEXT(self->obj));
  return 0;
}

static int _wrap_gtk_style_context_set_screen(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *screen;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen) == FAIL) return RET_BUG;
    gtk_style_context_set_screen(GTK_STYLE_CONTEXT(self->obj),GDK_SCREEN(screen->obj));
  return 0;
}

static int _wrap_gtk_style_context_get_screen(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkScreen *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_style_context_get_screen(GTK_STYLE_CONTEXT(self->obj));
  nsp_type_gdkscreen = new_type_gdkscreen(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkscreen))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_style_context_set_frame_clock(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *frame_clock;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkframeclock, &frame_clock) == FAIL) return RET_BUG;
    gtk_style_context_set_frame_clock(GTK_STYLE_CONTEXT(self->obj),GDK_FRAME_CLOCK(frame_clock->obj));
  return 0;
}

#else
int _wrap_gtk_style_context_set_frame_clock(Stack stack, int rhs, int opt, int lhs) /* set_frame_clock */
{
  Scierror("Error: function gtk_style_context_set_frame_clock not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,8,0)
static int _wrap_gtk_style_context_get_frame_clock(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkFrameClock *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_style_context_get_frame_clock(GTK_STYLE_CONTEXT(self->obj));
  nsp_type_gdkframeclock = new_type_gdkframeclock(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkframeclock))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_style_context_get_frame_clock(Stack stack, int rhs, int opt, int lhs) /* get_frame_clock */
{
  Scierror("Error: function gtk_style_context_get_frame_clock not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_style_context_set_junction_sides(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkJunctionSides sides;
  NspObject *nsp_sides = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_sides) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_JUNCTION_SIDES, nsp_sides, &sides)==FAIL)
      return RET_BUG;
    gtk_style_context_set_junction_sides(GTK_STYLE_CONTEXT(self->obj),sides);
  return 0;
}

static int _wrap_gtk_style_context_get_junction_sides(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_style_context_get_junction_sides(GTK_STYLE_CONTEXT(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_style_context_lookup_color(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,obj, t_end};
  char *color_name;
  GdkRGBA *color = NULL;
  NspObject *nsp_color = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&color_name, &nsp_color) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_RGBA))
      color = nspg_boxed_get(nsp_color, GdkRGBA);
  else {
      Scierror( "Error: color should be a GdkRGBA\n");
      return RET_BUG;
  }
    ret =gtk_style_context_lookup_color(GTK_STYLE_CONTEXT(self->obj),color_name,color);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,6,0)
int _wrap_gtk_style_context_scroll_animations(Stack stack, int rhs, int opt, int lhs) /* scroll_animations */
{
  Scierror("Error: function gtk_style_context_scroll_animations is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_style_context_scroll_animations(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int, t_end};
  NspGObject *window;
  int dx, dy;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window, &dx, &dy) == FAIL) return RET_BUG;
    gtk_style_context_scroll_animations(GTK_STYLE_CONTEXT(self->obj),GDK_WINDOW(window->obj),dx,dy);
  return 0;
}

#endif
#if GTK_CHECK_VERSION(3,6,0)
int _wrap_gtk_style_context_pop_animatable_region(Stack stack, int rhs, int opt, int lhs) /* pop_animatable_region */
{
  Scierror("Error: function gtk_style_context_pop_animatable_region is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_style_context_pop_animatable_region(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_style_context_pop_animatable_region(GTK_STYLE_CONTEXT(self->obj));
  return 0;
}

#endif
static int _wrap_gtk_style_context_get_color(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkStateFlags state;
  NspObject *nsp_state = NULL, *nsp_color = NULL;
  GdkRGBA *color = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_state, &nsp_color) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_STATE_FLAGS, nsp_state, &state)==FAIL)
      return RET_BUG;
  if (nspg_boxed_check(nsp_color, GDK_TYPE_RGBA))
      color = nspg_boxed_get(nsp_color, GdkRGBA);
  else {
      Scierror( "Error: color should be a GdkRGBA\n");
      return RET_BUG;
  }
    gtk_style_context_get_color(GTK_STYLE_CONTEXT(self->obj),state,color);
  return 0;
}

static int _wrap_gtk_style_context_get_border(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkStateFlags state;
  NspObject *nsp_state = NULL, *nsp_border = NULL;
  GtkBorder *border = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_state, &nsp_border) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_STATE_FLAGS, nsp_state, &state)==FAIL)
      return RET_BUG;
  if (nspg_boxed_check(nsp_border, GTK_TYPE_BORDER))
      border = nspg_boxed_get(nsp_border, GtkBorder);
  else {
      Scierror( "Error: border should be a GtkBorder\n");
      return RET_BUG;
  }
    gtk_style_context_get_border(GTK_STYLE_CONTEXT(self->obj),state,border);
  return 0;
}

static int _wrap_gtk_style_context_get_padding(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkStateFlags state;
  NspObject *nsp_state = NULL, *nsp_padding = NULL;
  GtkBorder *padding = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_state, &nsp_padding) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_STATE_FLAGS, nsp_state, &state)==FAIL)
      return RET_BUG;
  if (nspg_boxed_check(nsp_padding, GTK_TYPE_BORDER))
      padding = nspg_boxed_get(nsp_padding, GtkBorder);
  else {
      Scierror( "Error: padding should be a GtkBorder\n");
      return RET_BUG;
  }
    gtk_style_context_get_padding(GTK_STYLE_CONTEXT(self->obj),state,padding);
  return 0;
}

static int _wrap_gtk_style_context_get_margin(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj,obj, t_end};
  GtkStateFlags state;
  NspObject *nsp_state = NULL, *nsp_margin = NULL;
  GtkBorder *margin = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_state, &nsp_margin) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_STATE_FLAGS, nsp_state, &state)==FAIL)
      return RET_BUG;
  if (nspg_boxed_check(nsp_margin, GTK_TYPE_BORDER))
      margin = nspg_boxed_get(nsp_margin, GtkBorder);
  else {
      Scierror( "Error: margin should be a GtkBorder\n");
      return RET_BUG;
  }
    gtk_style_context_get_margin(GTK_STYLE_CONTEXT(self->obj),state,margin);
  return 0;
}

#if GTK_CHECK_VERSION(3,12,0)
int _wrap_gtk_style_context_invalidate(Stack stack, int rhs, int opt, int lhs) /* invalidate */
{
  Scierror("Error: function gtk_style_context_invalidate is deprecated\n");
  return RET_BUG;
}
#else
static int _wrap_gtk_style_context_invalidate(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_style_context_invalidate(GTK_STYLE_CONTEXT(self->obj));
  return 0;
}

#endif
static int _wrap_gtk_style_context_set_background(NspGtkStyleContext *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkwindow, &window) == FAIL) return RET_BUG;
    gtk_style_context_set_background(GTK_STYLE_CONTEXT(self->obj),GDK_WINDOW(window->obj));
  return 0;
}

static NspMethods gtkstylecontext_methods[] = {
  {"add_provider",(nsp_method *) _wrap_gtk_style_context_add_provider},
  {"remove_provider",(nsp_method *) _wrap_gtk_style_context_remove_provider},
  {"save",(nsp_method *) _wrap_gtk_style_context_save},
  {"restore",(nsp_method *) _wrap_gtk_style_context_restore},
  {"get_section",(nsp_method *) _wrap_gtk_style_context_get_section},
  {"get_property",(nsp_method *) _wrap_gtk_style_context_get_property},
  {"get",(nsp_method *) _wrap_gtk_style_context_get},
  {"set_state",(nsp_method *) _wrap_gtk_style_context_set_state},
  {"get_state",(nsp_method *) _wrap_gtk_style_context_get_state},
  {"set_scale",(nsp_method *) _wrap_gtk_style_context_set_scale},
  {"get_scale",(nsp_method *) _wrap_gtk_style_context_get_scale},
  {"state_is_running",(nsp_method *) _wrap_gtk_style_context_state_is_running},
  {"set_parent",(nsp_method *) _wrap_gtk_style_context_set_parent},
  {"get_parent",(nsp_method *) _wrap_gtk_style_context_get_parent},
  {"list_classes",(nsp_method *) _wrap_gtk_style_context_list_classes},
  {"add_class",(nsp_method *) _wrap_gtk_style_context_add_class},
  {"remove_class",(nsp_method *) _wrap_gtk_style_context_remove_class},
  {"has_class",(nsp_method *) _wrap_gtk_style_context_has_class},
  {"list_regions",(nsp_method *) _wrap_gtk_style_context_list_regions},
  {"add_region",(nsp_method *) _wrap_gtk_style_context_add_region},
  {"remove_region",(nsp_method *) _wrap_gtk_style_context_remove_region},
  {"get_style",(nsp_method *) _wrap_gtk_style_context_get_style},
  {"set_screen",(nsp_method *) _wrap_gtk_style_context_set_screen},
  {"get_screen",(nsp_method *) _wrap_gtk_style_context_get_screen},
  {"set_frame_clock",(nsp_method *) _wrap_gtk_style_context_set_frame_clock},
  {"get_frame_clock",(nsp_method *) _wrap_gtk_style_context_get_frame_clock},
  {"set_junction_sides",(nsp_method *) _wrap_gtk_style_context_set_junction_sides},
  {"get_junction_sides",(nsp_method *) _wrap_gtk_style_context_get_junction_sides},
  {"lookup_color",(nsp_method *) _wrap_gtk_style_context_lookup_color},
  {"scroll_animations",(nsp_method *) _wrap_gtk_style_context_scroll_animations},
  {"pop_animatable_region",(nsp_method *) _wrap_gtk_style_context_pop_animatable_region},
  {"get_color",(nsp_method *) _wrap_gtk_style_context_get_color},
  {"get_border",(nsp_method *) _wrap_gtk_style_context_get_border},
  {"get_padding",(nsp_method *) _wrap_gtk_style_context_get_padding},
  {"get_margin",(nsp_method *) _wrap_gtk_style_context_get_margin},
  {"invalidate",(nsp_method *) _wrap_gtk_style_context_invalidate},
  {"set_background",(nsp_method *) _wrap_gtk_style_context_set_background},
  { NULL, NULL}
};

static NspMethods *gtkstylecontext_get_methods(void) { return gtkstylecontext_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkstylecontext_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkUIManager ----------- */


#define  NspGtkUIManager_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkuimanager.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkUIManager inherits from GObject 
 */

int nsp_type_gtkuimanager_id=0;
NspTypeGtkUIManager *nsp_type_gtkuimanager=NULL;

/*
 * Type object for NspGtkUIManager 
 * all the instance of NspTypeGtkUIManager share the same id. 
 * nsp_type_gtkuimanager: is an instance of NspTypeGtkUIManager 
 *    used for objects of NspGtkUIManager type (i.e built with new_gtkuimanager) 
 * other instances are used for derived classes 
 */
NspTypeGtkUIManager *new_type_gtkuimanager(type_mode mode)
{
  NspTypeGtkUIManager *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkuimanager != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkuimanager;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkuimanager_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkuimanager_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkuimanager;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkuimanager */ 

  top->s_type =  (s_type_func *) nsp_gtkuimanager_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkuimanager_type_short_string;
  /* top->create = (create_func*) int_gtkuimanager_create;*/

  /* specific methods for gtkuimanager */

  type->init = (init_func *) init_gtkuimanager;

  /* 
   * NspGtkUIManager interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkuimanager_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkUIManager called nsp_type_gtkuimanager
       */
      type->id =  nsp_type_gtkuimanager_id = nsp_new_type_id();
      nsp_type_gtkuimanager = type;
      if ( nsp_register_type(nsp_type_gtkuimanager) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkuimanager, GTK_TYPE_UI_MANAGER);
      return ( mode == T_BASE ) ? type : new_type_gtkuimanager(mode);
    }
  else 
    {
      type->id = nsp_type_gtkuimanager_id;
      return type;
    }
}

/*
 * initialize NspGtkUIManager instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkuimanager(NspGtkUIManager *Obj,NspTypeGtkUIManager *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkUIManager 
 */

NspGtkUIManager *new_gtkuimanager() 
{
  NspGtkUIManager *loc;
  /* type must exists */
  nsp_type_gtkuimanager = new_type_gtkuimanager(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkUIManager)))== NULLGTKUIMANAGER) return loc;
  /* initialize object */
  if ( init_gtkuimanager(loc,nsp_type_gtkuimanager) == FAIL) return NULLGTKUIMANAGER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkUIManager 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkuimanager_type_name[]="GtkUIManager";
static char gtkuimanager_short_type_name[]="GtkUIManager";

static char *nsp_gtkuimanager_type_as_string(void)
{
  return(gtkuimanager_type_name);
}

static char *nsp_gtkuimanager_type_short_string(NspObject *v)
{
  return(gtkuimanager_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkUIManager objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkUIManager   *nsp_gtkuimanager_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkuimanager_id)  == TRUE  ) return ((NspGtkUIManager *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkuimanager));
  return NULL;
}

int IsGtkUIManagerObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkuimanager_id);
}

int IsGtkUIManager(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkuimanager_id);
}

NspGtkUIManager  *GetGtkUIManagerCopy(Stack stack, int i)
{
  if (  GetGtkUIManager(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkUIManager  *GetGtkUIManager(Stack stack, int i)
{
  NspGtkUIManager *M;
  if (( M = nsp_gtkuimanager_object(NthObj(i))) == NULLGTKUIMANAGER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkUIManager *gtkuimanager_copy(NspGtkUIManager *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkuimanager);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkuimanager);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkUIManager
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_ui_manager_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_ui_manager_new())== NULL) return RET_BUG;

  nsp_type_gtkuimanager = new_type_gtkuimanager(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkuimanager);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_ui_manager_set_add_tearoffs(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int add_tearoffs;
  if ( GetArgs(stack,rhs,opt,T,&add_tearoffs) == FAIL) return RET_BUG;
    gtk_ui_manager_set_add_tearoffs(GTK_UI_MANAGER(self->obj),add_tearoffs);
  return 0;
}

static int _wrap_gtk_ui_manager_get_add_tearoffs(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_ui_manager_get_add_tearoffs(GTK_UI_MANAGER(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_ui_manager_insert_action_group(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int, t_end};
  NspGObject *action_group;
  int pos;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkactiongroup, &action_group, &pos) == FAIL) return RET_BUG;
    gtk_ui_manager_insert_action_group(GTK_UI_MANAGER(self->obj),GTK_ACTION_GROUP(action_group->obj),pos);
  return 0;
}

static int _wrap_gtk_ui_manager_remove_action_group(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *action_group;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkactiongroup, &action_group) == FAIL) return RET_BUG;
    gtk_ui_manager_remove_action_group(GTK_UI_MANAGER(self->obj),GTK_ACTION_GROUP(action_group->obj));
  return 0;
}

static int _wrap_gtk_ui_manager_get_action_groups(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_ui_manager_get_action_groups(GTK_UI_MANAGER(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

static int _wrap_gtk_ui_manager_get_accel_group(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkAccelGroup *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_ui_manager_get_accel_group(GTK_UI_MANAGER(self->obj));
  nsp_type_gtkaccelgroup = new_type_gtkaccelgroup(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkaccelgroup))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_ui_manager_get_widget(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *path;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
    ret =gtk_ui_manager_get_widget(GTK_UI_MANAGER(self->obj),path);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_ui_manager_get_toplevels(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkUIManagerItemType types;
  NspObject *nsp_types = NULL;
  GSList *ret, *tmp;
  NspList *nsp_list;
  if ( GetArgs(stack,rhs,opt,T,&nsp_types) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_UI_MANAGER_ITEM_TYPE, nsp_types, &types)==FAIL)
      return RET_BUG;
    ret =gtk_ui_manager_get_toplevels(GTK_UI_MANAGER(self->obj),types);
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

static int _wrap_gtk_ui_manager_get_action(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *path;
  GtkAction *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
    ret =gtk_ui_manager_get_action(GTK_UI_MANAGER(self->obj),path);
  nsp_type_gtkaction = new_type_gtkaction(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkaction))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_ui_manager_add_ui_from_string(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int, t_end};
  char *buffer;
  int length, ret;
  GError *error = NULL;
  if ( GetArgs(stack,rhs,opt,T,&buffer, &length) == FAIL) return RET_BUG;
    ret =gtk_ui_manager_add_ui_from_string(GTK_UI_MANAGER(self->obj),buffer,length,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_ui_manager_add_ui_from_file(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *filename;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    ret =gtk_ui_manager_add_ui_from_file(GTK_UI_MANAGER(self->obj),filename,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_ui_manager_add_ui(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,string,string,new_opts, t_end};
  nsp_option opts[] = {
	{"action",string,NULLOBJ,-1},
	{"type",obj,NULLOBJ,-1},
	{"top",s_bool,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  int merge_id, top;
  char *path, *name, *action = NULL;
  GtkUIManagerItemType type;
  NspObject *nsp_type = NULL;
  if ( GetArgs(stack,rhs,opt,T,&merge_id, &path, &name, opts, &action, &nsp_type, &top) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_UI_MANAGER_ITEM_TYPE, nsp_type, &type)==FAIL)
      return RET_BUG;
    gtk_ui_manager_add_ui(GTK_UI_MANAGER(self->obj),merge_id,path,name,action,type,top);
  return 0;
}

static int _wrap_gtk_ui_manager_remove_ui(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int, t_end};
  int merge_id;
  if ( GetArgs(stack,rhs,opt,T,&merge_id) == FAIL) return RET_BUG;
    gtk_ui_manager_remove_ui(GTK_UI_MANAGER(self->obj),merge_id);
  return 0;
}

static int _wrap_gtk_ui_manager_get_ui(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_ui_manager_get_ui(GTK_UI_MANAGER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_ui_manager_ensure_update(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_ui_manager_ensure_update(GTK_UI_MANAGER(self->obj));
  return 0;
}

static int _wrap_gtk_ui_manager_new_merge_id(NspGtkUIManager *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_ui_manager_new_merge_id(GTK_UI_MANAGER(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkuimanager_methods[] = {
  {"set_add_tearoffs",(nsp_method *) _wrap_gtk_ui_manager_set_add_tearoffs},
  {"get_add_tearoffs",(nsp_method *) _wrap_gtk_ui_manager_get_add_tearoffs},
  {"insert_action_group",(nsp_method *) _wrap_gtk_ui_manager_insert_action_group},
  {"remove_action_group",(nsp_method *) _wrap_gtk_ui_manager_remove_action_group},
  {"get_action_groups",(nsp_method *) _wrap_gtk_ui_manager_get_action_groups},
  {"get_accel_group",(nsp_method *) _wrap_gtk_ui_manager_get_accel_group},
  {"get_widget",(nsp_method *) _wrap_gtk_ui_manager_get_widget},
  {"get_toplevels",(nsp_method *) _wrap_gtk_ui_manager_get_toplevels},
  {"get_action",(nsp_method *) _wrap_gtk_ui_manager_get_action},
  {"add_ui_from_string",(nsp_method *) _wrap_gtk_ui_manager_add_ui_from_string},
  {"add_ui_from_file",(nsp_method *) _wrap_gtk_ui_manager_add_ui_from_file},
  {"add_ui",(nsp_method *) _wrap_gtk_ui_manager_add_ui},
  {"remove_ui",(nsp_method *) _wrap_gtk_ui_manager_remove_ui},
  {"get_ui",(nsp_method *) _wrap_gtk_ui_manager_get_ui},
  {"ensure_update",(nsp_method *) _wrap_gtk_ui_manager_ensure_update},
  {"new_merge_id",(nsp_method *) _wrap_gtk_ui_manager_new_merge_id},
  { NULL, NULL}
};

static NspMethods *gtkuimanager_get_methods(void) { return gtkuimanager_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkuimanager_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkActionGroup ----------- */


#define  NspGtkActionGroup_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkactiongroup.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkActionGroup inherits from GObject 
 */

int nsp_type_gtkactiongroup_id=0;
NspTypeGtkActionGroup *nsp_type_gtkactiongroup=NULL;

/*
 * Type object for NspGtkActionGroup 
 * all the instance of NspTypeGtkActionGroup share the same id. 
 * nsp_type_gtkactiongroup: is an instance of NspTypeGtkActionGroup 
 *    used for objects of NspGtkActionGroup type (i.e built with new_gtkactiongroup) 
 * other instances are used for derived classes 
 */
NspTypeGtkActionGroup *new_type_gtkactiongroup(type_mode mode)
{
  NspTypeGtkActionGroup *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkactiongroup != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkactiongroup;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkactiongroup_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkactiongroup_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkactiongroup;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkactiongroup */ 

  top->s_type =  (s_type_func *) nsp_gtkactiongroup_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkactiongroup_type_short_string;
  /* top->create = (create_func*) int_gtkactiongroup_create;*/

  /* specific methods for gtkactiongroup */

  type->init = (init_func *) init_gtkactiongroup;

  /* 
   * NspGtkActionGroup interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkactiongroup_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkActionGroup called nsp_type_gtkactiongroup
       */
      type->id =  nsp_type_gtkactiongroup_id = nsp_new_type_id();
      nsp_type_gtkactiongroup = type;
      if ( nsp_register_type(nsp_type_gtkactiongroup) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkactiongroup, GTK_TYPE_ACTION_GROUP);
      return ( mode == T_BASE ) ? type : new_type_gtkactiongroup(mode);
    }
  else 
    {
      type->id = nsp_type_gtkactiongroup_id;
      return type;
    }
}

/*
 * initialize NspGtkActionGroup instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkactiongroup(NspGtkActionGroup *Obj,NspTypeGtkActionGroup *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkActionGroup 
 */

NspGtkActionGroup *new_gtkactiongroup() 
{
  NspGtkActionGroup *loc;
  /* type must exists */
  nsp_type_gtkactiongroup = new_type_gtkactiongroup(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkActionGroup)))== NULLGTKACTIONGROUP) return loc;
  /* initialize object */
  if ( init_gtkactiongroup(loc,nsp_type_gtkactiongroup) == FAIL) return NULLGTKACTIONGROUP;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkActionGroup 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkactiongroup_type_name[]="GtkActionGroup";
static char gtkactiongroup_short_type_name[]="GtkActionGroup";

static char *nsp_gtkactiongroup_type_as_string(void)
{
  return(gtkactiongroup_type_name);
}

static char *nsp_gtkactiongroup_type_short_string(NspObject *v)
{
  return(gtkactiongroup_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkActionGroup objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkActionGroup   *nsp_gtkactiongroup_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkactiongroup_id)  == TRUE  ) return ((NspGtkActionGroup *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkactiongroup));
  return NULL;
}

int IsGtkActionGroupObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkactiongroup_id);
}

int IsGtkActionGroup(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkactiongroup_id);
}

NspGtkActionGroup  *GetGtkActionGroupCopy(Stack stack, int i)
{
  if (  GetGtkActionGroup(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkActionGroup  *GetGtkActionGroup(Stack stack, int i)
{
  NspGtkActionGroup *M;
  if (( M = nsp_gtkactiongroup_object(NthObj(i))) == NULLGTKACTIONGROUP)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkActionGroup *gtkactiongroup_copy(NspGtkActionGroup *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkactiongroup);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkactiongroup);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkActionGroup
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_action_group_new (Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, t_end};
  char *name;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
  if ((ret = (GObject *)gtk_action_group_new(name))== NULL) return RET_BUG;

  nsp_type_gtkactiongroup = new_type_gtkactiongroup(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkactiongroup);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_action_group_get_name(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_action_group_get_name(GTK_ACTION_GROUP(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_action_group_get_sensitive(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_action_group_get_sensitive(GTK_ACTION_GROUP(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_action_group_set_sensitive(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int sensitive;
  if ( GetArgs(stack,rhs,opt,T,&sensitive) == FAIL) return RET_BUG;
    gtk_action_group_set_sensitive(GTK_ACTION_GROUP(self->obj),sensitive);
  return 0;
}

static int _wrap_gtk_action_group_get_visible(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_action_group_get_visible(GTK_ACTION_GROUP(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_action_group_set_visible(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int visible;
  if ( GetArgs(stack,rhs,opt,T,&visible) == FAIL) return RET_BUG;
    gtk_action_group_set_visible(GTK_ACTION_GROUP(self->obj),visible);
  return 0;
}

#line 7403 "codegen-3.0/gtk.override"

static int _wrap_gtk_action_group_get_action(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,t_end};
  char *action_name;
  NspObject *nsp_ret;
  GtkAction *ret;
  if ( GetArgs(stack,rhs,opt,T,&action_name) == FAIL) return RET_BUG;
  ret = gtk_action_group_get_action(GTK_ACTION_GROUP(self->obj), action_name);
  if ( ret != NULL)
    {
      nsp_type_gtkaction = new_type_gtkaction(T_BASE);
      if ((nsp_ret = (NspObject *) gobject_create(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkaction))== NULL)
	return RET_BUG;
    }
  else
    {
      if ((nsp_ret = (NspObject *) nsp_none_create(NVOID,NULL))== NULL)
	return RET_BUG;
    }
  MoveObj(stack,1,nsp_ret);
  return 1;
}


#line 72754 "gtk.c"


#line 7430 "codegen-3.0/gtk.override"

/* we redefine a method */
static int _wrap_gtk_action_group_list_actions(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
  CheckLhs(0,1);
  list = gtk_action_group_list_actions(GTK_ACTION_GROUP(self->obj));
  /* be sure that gtk action is initialized */
  nsp_type_gtkaction = new_type_gtkaction(T_BASE);
  /* create a list of gtkaction objects */
  NSP_LIST_FROM_GLIST(list,gobject_create("lel",(GObject *)tmp->data,(NspTypeBase *) nsp_type_gtkaction), g_list_free);
}

#line 72773 "gtk.c"


static int _wrap_gtk_action_group_add_action(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *action;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaction, &action) == FAIL) return RET_BUG;
    gtk_action_group_add_action(GTK_ACTION_GROUP(self->obj),GTK_ACTION(action->obj));
  return 0;
}

static int _wrap_gtk_action_group_add_action_with_accel(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,new_opts, t_end};
  nsp_option opts[] = {
	{"accelerator",string,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *action;
  char *accelerator = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaction, &action, opts, &accelerator) == FAIL) return RET_BUG;
    gtk_action_group_add_action_with_accel(GTK_ACTION_GROUP(self->obj),GTK_ACTION(action->obj),accelerator);
  return 0;
}

static int _wrap_gtk_action_group_remove_action(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *action;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaction, &action) == FAIL) return RET_BUG;
    gtk_action_group_remove_action(GTK_ACTION_GROUP(self->obj),GTK_ACTION(action->obj));
  return 0;
}

static int _wrap_gtk_action_group_set_translation_domain(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *domain;
  if ( GetArgs(stack,rhs,opt,T,&domain) == FAIL) return RET_BUG;
    gtk_action_group_set_translation_domain(GTK_ACTION_GROUP(self->obj),domain);
  return 0;
}

static int _wrap_gtk_action_group_translate_string(NspGtkActionGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *string;
  const gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&string) == FAIL) return RET_BUG;
    ret =gtk_action_group_translate_string(GTK_ACTION_GROUP(self->obj),string);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkactiongroup_methods[] = {
  {"get_name",(nsp_method *) _wrap_gtk_action_group_get_name},
  {"get_sensitive",(nsp_method *) _wrap_gtk_action_group_get_sensitive},
  {"set_sensitive",(nsp_method *) _wrap_gtk_action_group_set_sensitive},
  {"get_visible",(nsp_method *) _wrap_gtk_action_group_get_visible},
  {"set_visible",(nsp_method *) _wrap_gtk_action_group_set_visible},
  {"get_action",(nsp_method *) _wrap_gtk_action_group_get_action},
  {"list_actions",(nsp_method *) _wrap_gtk_action_group_list_actions},
  {"add_action",(nsp_method *) _wrap_gtk_action_group_add_action},
  {"add_action_with_accel",(nsp_method *) _wrap_gtk_action_group_add_action_with_accel},
  {"remove_action",(nsp_method *) _wrap_gtk_action_group_remove_action},
  {"set_translation_domain",(nsp_method *) _wrap_gtk_action_group_set_translation_domain},
  {"translate_string",(nsp_method *) _wrap_gtk_action_group_translate_string},
  { NULL, NULL}
};

static NspMethods *gtkactiongroup_get_methods(void) { return gtkactiongroup_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkactiongroup_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAction ----------- */


#define  NspGtkAction_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkaction.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAction inherits from GObject 
 */

int nsp_type_gtkaction_id=0;
NspTypeGtkAction *nsp_type_gtkaction=NULL;

/*
 * Type object for NspGtkAction 
 * all the instance of NspTypeGtkAction share the same id. 
 * nsp_type_gtkaction: is an instance of NspTypeGtkAction 
 *    used for objects of NspGtkAction type (i.e built with new_gtkaction) 
 * other instances are used for derived classes 
 */
NspTypeGtkAction *new_type_gtkaction(type_mode mode)
{
  NspTypeGtkAction *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkaction != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkaction;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkaction_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkaction_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkaction;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkaction */ 

  top->s_type =  (s_type_func *) nsp_gtkaction_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkaction_type_short_string;
  /* top->create = (create_func*) int_gtkaction_create;*/

  /* specific methods for gtkaction */

  type->init = (init_func *) init_gtkaction;

  /* 
   * NspGtkAction interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkaction_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAction called nsp_type_gtkaction
       */
      type->id =  nsp_type_gtkaction_id = nsp_new_type_id();
      nsp_type_gtkaction = type;
      if ( nsp_register_type(nsp_type_gtkaction) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkaction, GTK_TYPE_ACTION);
      return ( mode == T_BASE ) ? type : new_type_gtkaction(mode);
    }
  else 
    {
      type->id = nsp_type_gtkaction_id;
      return type;
    }
}

/*
 * initialize NspGtkAction instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkaction(NspGtkAction *Obj,NspTypeGtkAction *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAction 
 */

NspGtkAction *new_gtkaction() 
{
  NspGtkAction *loc;
  /* type must exists */
  nsp_type_gtkaction = new_type_gtkaction(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAction)))== NULLGTKACTION) return loc;
  /* initialize object */
  if ( init_gtkaction(loc,nsp_type_gtkaction) == FAIL) return NULLGTKACTION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAction 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkaction_type_name[]="GtkAction";
static char gtkaction_short_type_name[]="GtkAction";

static char *nsp_gtkaction_type_as_string(void)
{
  return(gtkaction_type_name);
}

static char *nsp_gtkaction_type_short_string(NspObject *v)
{
  return(gtkaction_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAction objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAction   *nsp_gtkaction_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkaction_id)  == TRUE  ) return ((NspGtkAction *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkaction));
  return NULL;
}

int IsGtkActionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkaction_id);
}

int IsGtkAction(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkaction_id);
}

NspGtkAction  *GetGtkActionCopy(Stack stack, int i)
{
  if (  GetGtkAction(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAction  *GetGtkAction(Stack stack, int i)
{
  NspGtkAction *M;
  if (( M = nsp_gtkaction_object(NthObj(i))) == NULLGTKACTION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAction *gtkaction_copy(NspGtkAction *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaction);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaction);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAction
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 7384 "codegen-3.0/gtk.override"

static int
_wrap_gtk_action_new(Stack stack, int rhs, int opt, int lhs)
{
  int_types T[] = {string, string, string, string,t_end};
  char *name, *label, *tooltip, *stock_id;
  GObject *ret; NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&name, &label, &tooltip, &stock_id) == FAIL) return RET_BUG;
  if (strlen(label)==0) label=NULL;
  if ((ret = (GObject *)gtk_action_new(name, label, tooltip, stock_id))== NULL) return RET_BUG;
  nsp_type_gtkaction = new_type_gtkaction(T_BASE);
  nsp_ret = (NspObject *) gobject_create(NVOID,ret,(NspTypeBase *) nsp_type_gtkaction );
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 73060 "gtk.c"


static int _wrap_gtk_action_get_name(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_action_get_name(GTK_ACTION(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_action_is_sensitive(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_action_is_sensitive(GTK_ACTION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_action_get_sensitive(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_action_get_sensitive(GTK_ACTION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_action_is_visible(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_action_is_visible(GTK_ACTION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_action_get_visible(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_action_get_visible(GTK_ACTION(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_action_activate(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_action_activate(GTK_ACTION(self->obj));
  return 0;
}

static int _wrap_gtk_action_create_icon(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GtkIconSize icon_size;
  NspObject *nsp_icon_size = NULL, *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_icon_size) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_icon_size, &icon_size)== FAIL)
      return RET_BUG;
    ret =gtk_action_create_icon(GTK_ACTION(self->obj),icon_size);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_action_create_menu_item(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_action_create_menu_item(GTK_ACTION(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_action_create_tool_item(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_action_create_tool_item(GTK_ACTION(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_action_get_proxies(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  GSList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_action_get_proxies(GTK_ACTION(self->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_slist_free);

}

static int _wrap_gtk_action_connect_accelerator(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_action_connect_accelerator(GTK_ACTION(self->obj));
  return 0;
}

static int _wrap_gtk_action_disconnect_accelerator(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_action_disconnect_accelerator(GTK_ACTION(self->obj));
  return 0;
}

static int _wrap_gtk_action_get_accel_path(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_action_get_accel_path(GTK_ACTION(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_action_set_accel_path(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *accel_path;
  if ( GetArgs(stack,rhs,opt,T,&accel_path) == FAIL) return RET_BUG;
    gtk_action_set_accel_path(GTK_ACTION(self->obj),accel_path);
  return 0;
}

static int _wrap_gtk_action_set_accel_group(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *accel_group;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkaccelgroup, &accel_group) == FAIL) return RET_BUG;
    gtk_action_set_accel_group(GTK_ACTION(self->obj),GTK_ACCEL_GROUP(accel_group->obj));
  return 0;
}

static int _wrap_gtk_action_set_sensitive(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int sensitive;
  if ( GetArgs(stack,rhs,opt,T,&sensitive) == FAIL) return RET_BUG;
    gtk_action_set_sensitive(GTK_ACTION(self->obj),sensitive);
  return 0;
}

static int _wrap_gtk_action_set_visible(NspGtkAction *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_bool, t_end};
  int visible;
  if ( GetArgs(stack,rhs,opt,T,&visible) == FAIL) return RET_BUG;
    gtk_action_set_visible(GTK_ACTION(self->obj),visible);
  return 0;
}

static NspMethods gtkaction_methods[] = {
  {"get_name",(nsp_method *) _wrap_gtk_action_get_name},
  {"is_sensitive",(nsp_method *) _wrap_gtk_action_is_sensitive},
  {"get_sensitive",(nsp_method *) _wrap_gtk_action_get_sensitive},
  {"is_visible",(nsp_method *) _wrap_gtk_action_is_visible},
  {"get_visible",(nsp_method *) _wrap_gtk_action_get_visible},
  {"activate",(nsp_method *) _wrap_gtk_action_activate},
  {"create_icon",(nsp_method *) _wrap_gtk_action_create_icon},
  {"create_menu_item",(nsp_method *) _wrap_gtk_action_create_menu_item},
  {"create_tool_item",(nsp_method *) _wrap_gtk_action_create_tool_item},
  {"get_proxies",(nsp_method *) _wrap_gtk_action_get_proxies},
  {"connect_accelerator",(nsp_method *) _wrap_gtk_action_connect_accelerator},
  {"disconnect_accelerator",(nsp_method *) _wrap_gtk_action_disconnect_accelerator},
  {"get_accel_path",(nsp_method *) _wrap_gtk_action_get_accel_path},
  {"set_accel_path",(nsp_method *) _wrap_gtk_action_set_accel_path},
  {"set_accel_group",(nsp_method *) _wrap_gtk_action_set_accel_group},
  {"set_sensitive",(nsp_method *) _wrap_gtk_action_set_sensitive},
  {"set_visible",(nsp_method *) _wrap_gtk_action_set_visible},
  { NULL, NULL}
};

static NspMethods *gtkaction_get_methods(void) { return gtkaction_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkaction_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkToggleAction ----------- */


#define  NspGtkToggleAction_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtktoggleaction.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkToggleAction inherits from GtkAction 
 */

int nsp_type_gtktoggleaction_id=0;
NspTypeGtkToggleAction *nsp_type_gtktoggleaction=NULL;

/*
 * Type object for NspGtkToggleAction 
 * all the instance of NspTypeGtkToggleAction share the same id. 
 * nsp_type_gtktoggleaction: is an instance of NspTypeGtkToggleAction 
 *    used for objects of NspGtkToggleAction type (i.e built with new_gtktoggleaction) 
 * other instances are used for derived classes 
 */
NspTypeGtkToggleAction *new_type_gtktoggleaction(type_mode mode)
{
  NspTypeGtkToggleAction *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtktoggleaction != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtktoggleaction;
    }
  if (( type =  malloc(sizeof(NspTypeGtkAction))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkaction(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtktoggleaction_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtktoggleaction_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtktoggleaction;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtktoggleaction */ 

  top->s_type =  (s_type_func *) nsp_gtktoggleaction_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtktoggleaction_type_short_string;
  /* top->create = (create_func*) int_gtktoggleaction_create;*/

  /* specific methods for gtktoggleaction */

  type->init = (init_func *) init_gtktoggleaction;

  /* 
   * NspGtkToggleAction interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtktoggleaction_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkToggleAction called nsp_type_gtktoggleaction
       */
      type->id =  nsp_type_gtktoggleaction_id = nsp_new_type_id();
      nsp_type_gtktoggleaction = type;
      if ( nsp_register_type(nsp_type_gtktoggleaction) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtktoggleaction, GTK_TYPE_TOGGLE_ACTION);
      return ( mode == T_BASE ) ? type : new_type_gtktoggleaction(mode);
    }
  else 
    {
      type->id = nsp_type_gtktoggleaction_id;
      return type;
    }
}

/*
 * initialize NspGtkToggleAction instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtktoggleaction(NspGtkToggleAction *Obj,NspTypeGtkToggleAction *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkToggleAction 
 */

NspGtkToggleAction *new_gtktoggleaction() 
{
  NspGtkToggleAction *loc;
  /* type must exists */
  nsp_type_gtktoggleaction = new_type_gtktoggleaction(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkToggleAction)))== NULLGTKTOGGLEACTION) return loc;
  /* initialize object */
  if ( init_gtktoggleaction(loc,nsp_type_gtktoggleaction) == FAIL) return NULLGTKTOGGLEACTION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkToggleAction 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtktoggleaction_type_name[]="GtkToggleAction";
static char gtktoggleaction_short_type_name[]="GtkToggleAction";

static char *nsp_gtktoggleaction_type_as_string(void)
{
  return(gtktoggleaction_type_name);
}

static char *nsp_gtktoggleaction_type_short_string(NspObject *v)
{
  return(gtktoggleaction_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkToggleAction objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkToggleAction   *nsp_gtktoggleaction_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtktoggleaction_id)  == TRUE  ) return ((NspGtkToggleAction *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtktoggleaction));
  return NULL;
}

int IsGtkToggleActionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtktoggleaction_id);
}

int IsGtkToggleAction(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtktoggleaction_id);
}

NspGtkToggleAction  *GetGtkToggleActionCopy(Stack stack, int i)
{
  if (  GetGtkToggleAction(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkToggleAction  *GetGtkToggleAction(Stack stack, int i)
{
  NspGtkToggleAction *M;
  if (( M = nsp_gtktoggleaction_object(NthObj(i))) == NULLGTKTOGGLEACTION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkToggleAction *gtktoggleaction_copy(NspGtkToggleAction *self)
{
  /* return gtkaction_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoggleaction);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtktoggleaction);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkToggleAction
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static NspMethods *gtktoggleaction_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtktoggleaction_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkRadioAction ----------- */


#define  NspGtkRadioAction_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkradioaction.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkRadioAction inherits from GtkToggleAction 
 */

int nsp_type_gtkradioaction_id=0;
NspTypeGtkRadioAction *nsp_type_gtkradioaction=NULL;

/*
 * Type object for NspGtkRadioAction 
 * all the instance of NspTypeGtkRadioAction share the same id. 
 * nsp_type_gtkradioaction: is an instance of NspTypeGtkRadioAction 
 *    used for objects of NspGtkRadioAction type (i.e built with new_gtkradioaction) 
 * other instances are used for derived classes 
 */
NspTypeGtkRadioAction *new_type_gtkradioaction(type_mode mode)
{
  NspTypeGtkRadioAction *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkradioaction != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkradioaction;
    }
  if (( type =  malloc(sizeof(NspTypeGtkToggleAction))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtktoggleaction(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkradioaction_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkradioaction_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkradioaction;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkradioaction */ 

  top->s_type =  (s_type_func *) nsp_gtkradioaction_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkradioaction_type_short_string;
  /* top->create = (create_func*) int_gtkradioaction_create;*/

  /* specific methods for gtkradioaction */

  type->init = (init_func *) init_gtkradioaction;

  /* 
   * NspGtkRadioAction interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkradioaction_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkRadioAction called nsp_type_gtkradioaction
       */
      type->id =  nsp_type_gtkradioaction_id = nsp_new_type_id();
      nsp_type_gtkradioaction = type;
      if ( nsp_register_type(nsp_type_gtkradioaction) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkradioaction, GTK_TYPE_RADIO_ACTION);
      return ( mode == T_BASE ) ? type : new_type_gtkradioaction(mode);
    }
  else 
    {
      type->id = nsp_type_gtkradioaction_id;
      return type;
    }
}

/*
 * initialize NspGtkRadioAction instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkradioaction(NspGtkRadioAction *Obj,NspTypeGtkRadioAction *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkRadioAction 
 */

NspGtkRadioAction *new_gtkradioaction() 
{
  NspGtkRadioAction *loc;
  /* type must exists */
  nsp_type_gtkradioaction = new_type_gtkradioaction(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkRadioAction)))== NULLGTKRADIOACTION) return loc;
  /* initialize object */
  if ( init_gtkradioaction(loc,nsp_type_gtkradioaction) == FAIL) return NULLGTKRADIOACTION;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkRadioAction 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkradioaction_type_name[]="GtkRadioAction";
static char gtkradioaction_short_type_name[]="GtkRadioAction";

static char *nsp_gtkradioaction_type_as_string(void)
{
  return(gtkradioaction_type_name);
}

static char *nsp_gtkradioaction_type_short_string(NspObject *v)
{
  return(gtkradioaction_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkRadioAction objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkRadioAction   *nsp_gtkradioaction_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkradioaction_id)  == TRUE  ) return ((NspGtkRadioAction *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkradioaction));
  return NULL;
}

int IsGtkRadioActionObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkradioaction_id);
}

int IsGtkRadioAction(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkradioaction_id);
}

NspGtkRadioAction  *GetGtkRadioActionCopy(Stack stack, int i)
{
  if (  GetGtkRadioAction(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkRadioAction  *GetGtkRadioAction(Stack stack, int i)
{
  NspGtkRadioAction *M;
  if (( M = nsp_gtkradioaction_object(NthObj(i))) == NULLGTKRADIOACTION)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkRadioAction *gtkradioaction_copy(NspGtkRadioAction *self)
{
  /* return gtktoggleaction_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradioaction);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkradioaction);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkRadioAction
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static NspMethods *gtkradioaction_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkradioaction_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkImageMenuItem ----------- */


#define  NspGtkImageMenuItem_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkimagemenuitem.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkImageMenuItem inherits from GtkMenuItem 
 */

int nsp_type_gtkimagemenuitem_id=0;
NspTypeGtkImageMenuItem *nsp_type_gtkimagemenuitem=NULL;

/*
 * Type object for NspGtkImageMenuItem 
 * all the instance of NspTypeGtkImageMenuItem share the same id. 
 * nsp_type_gtkimagemenuitem: is an instance of NspTypeGtkImageMenuItem 
 *    used for objects of NspGtkImageMenuItem type (i.e built with new_gtkimagemenuitem) 
 * other instances are used for derived classes 
 */
NspTypeGtkImageMenuItem *new_type_gtkimagemenuitem(type_mode mode)
{
  NspTypeGtkImageMenuItem *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkimagemenuitem != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkimagemenuitem;
    }
  if (( type =  malloc(sizeof(NspTypeGtkMenuItem))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkmenuitem(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkimagemenuitem_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkimagemenuitem_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkimagemenuitem;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkimagemenuitem */ 

  top->s_type =  (s_type_func *) nsp_gtkimagemenuitem_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkimagemenuitem_type_short_string;
  /* top->create = (create_func*) int_gtkimagemenuitem_create;*/

  /* specific methods for gtkimagemenuitem */

  type->init = (init_func *) init_gtkimagemenuitem;

  /* 
   * NspGtkImageMenuItem interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkimagemenuitem_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkImageMenuItem called nsp_type_gtkimagemenuitem
       */
      type->id =  nsp_type_gtkimagemenuitem_id = nsp_new_type_id();
      nsp_type_gtkimagemenuitem = type;
      if ( nsp_register_type(nsp_type_gtkimagemenuitem) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkimagemenuitem, GTK_TYPE_IMAGE_MENU_ITEM);
      return ( mode == T_BASE ) ? type : new_type_gtkimagemenuitem(mode);
    }
  else 
    {
      type->id = nsp_type_gtkimagemenuitem_id;
      return type;
    }
}

/*
 * initialize NspGtkImageMenuItem instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkimagemenuitem(NspGtkImageMenuItem *Obj,NspTypeGtkImageMenuItem *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkImageMenuItem 
 */

NspGtkImageMenuItem *new_gtkimagemenuitem() 
{
  NspGtkImageMenuItem *loc;
  /* type must exists */
  nsp_type_gtkimagemenuitem = new_type_gtkimagemenuitem(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkImageMenuItem)))== NULLGTKIMAGEMENUITEM) return loc;
  /* initialize object */
  if ( init_gtkimagemenuitem(loc,nsp_type_gtkimagemenuitem) == FAIL) return NULLGTKIMAGEMENUITEM;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkImageMenuItem 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkimagemenuitem_type_name[]="GtkImageMenuItem";
static char gtkimagemenuitem_short_type_name[]="GtkImageMenuItem";

static char *nsp_gtkimagemenuitem_type_as_string(void)
{
  return(gtkimagemenuitem_type_name);
}

static char *nsp_gtkimagemenuitem_type_short_string(NspObject *v)
{
  return(gtkimagemenuitem_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkImageMenuItem objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkImageMenuItem   *nsp_gtkimagemenuitem_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkimagemenuitem_id)  == TRUE  ) return ((NspGtkImageMenuItem *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkimagemenuitem));
  return NULL;
}

int IsGtkImageMenuItemObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkimagemenuitem_id);
}

int IsGtkImageMenuItem(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkimagemenuitem_id);
}

NspGtkImageMenuItem  *GetGtkImageMenuItemCopy(Stack stack, int i)
{
  if (  GetGtkImageMenuItem(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkImageMenuItem  *GetGtkImageMenuItem(Stack stack, int i)
{
  NspGtkImageMenuItem *M;
  if (( M = nsp_gtkimagemenuitem_object(NthObj(i))) == NULLGTKIMAGEMENUITEM)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkImageMenuItem *gtkimagemenuitem_copy(NspGtkImageMenuItem *self)
{
  /* return gtkmenuitem_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimagemenuitem);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkimagemenuitem);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkImageMenuItem
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
#line 4788 "codegen-3.0/gtk.override"
static int
_wrap_gtk_image_menu_item_new(Stack stack,int rhs,int opt,int lhs)
{
  /* static char *kwlist[] = { "stock_id", "accel_group", NULL };*/
  NspObject *nsp_ret;
  int_types T[] = {new_opts, t_end} ;
  nsp_option opts[] = {
    {"stock_id",string,NULLOBJ,-1},
    {"label",string,NULLOBJ,-1},
    {"mnemonic",string,NULLOBJ,-1},
    {"accel_group",obj_check,NULLOBJ,-1},
    {NULL,t_end,NULLOBJ,-1} };
  GObject *gobj;
  gchar *stock_id = NULL;
  gchar *label = NULL;
  gchar *mnemonic = NULL;
  NspObject *nsp_accel_group = NULL;
  GtkAccelGroup *accel_group= NULL;

  if (GetArgs(stack,rhs,opt,T,&opts,&stock_id,&label,&mnemonic,
	      &nsp_type_gtkaccelgroup, &nsp_accel_group)==FAIL)
    return RET_BUG;

  if (stock_id)
    gobj = (GObject *)gtk_image_menu_item_new_from_stock(stock_id, accel_group);
  else if ( label )
    gobj = (GObject *)gtk_image_menu_item_new_with_label(label) ;
  else if (mnemonic )
    gobj = (GObject *)gtk_image_menu_item_new_with_label(label) ;
  else
    gobj = (GObject *)gtk_image_menu_item_new();
  if (gobj==NULL) {
    Scierror( "could not create GtkImageMenuItem object\n");
    return RET_BUG;
  }
  if ((nsp_ret=(NspObject*) gobject_create(NVOID, gobj,(NspTypeBase *) nsp_type_gtkimagemenuitem))==NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 73883 "gtk.c"


static int _wrap_gtk_image_menu_item_set_image(NspGtkImageMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *image;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &image) == FAIL) return RET_BUG;
    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(self->obj),GTK_WIDGET(image->obj));
  return 0;
}

static int _wrap_gtk_image_menu_item_get_image(NspGtkImageMenuItem *self,Stack stack,int rhs,int opt,int lhs)
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_image_menu_item_get_image(GTK_IMAGE_MENU_ITEM(self->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static NspMethods gtkimagemenuitem_methods[] = {
  {"set_image",(nsp_method *) _wrap_gtk_image_menu_item_set_image},
  {"get_image",(nsp_method *) _wrap_gtk_image_menu_item_get_image},
  { NULL, NULL}
};

static NspMethods *gtkimagemenuitem_get_methods(void) { return gtkimagemenuitem_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkimagemenuitem_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkMisc ----------- */


#define  NspGtkMisc_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkmisc.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkMisc inherits from GtkWidget 
 * and implements GtkBuildable
 */

int nsp_type_gtkmisc_id=0;
NspTypeGtkMisc *nsp_type_gtkmisc=NULL;

/*
 * Type object for NspGtkMisc 
 * all the instance of NspTypeGtkMisc share the same id. 
 * nsp_type_gtkmisc: is an instance of NspTypeGtkMisc 
 *    used for objects of NspGtkMisc type (i.e built with new_gtkmisc) 
 * other instances are used for derived classes 
 */
NspTypeGtkMisc *new_type_gtkmisc(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkMisc *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkmisc != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkmisc;
    }
  if (( type =  malloc(sizeof(NspTypeGtkWidget))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkwidget(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkmisc_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkmisc_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkmisc;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkmisc */ 

  top->s_type =  (s_type_func *) nsp_gtkmisc_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkmisc_type_short_string;
  /* top->create = (create_func*) int_gtkmisc_create;*/

  /* specific methods for gtkmisc */

  type->init = (init_func *) init_gtkmisc;

  /* 
   * NspGtkMisc interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkmisc_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkMisc called nsp_type_gtkmisc
       */
      type->id =  nsp_type_gtkmisc_id = nsp_new_type_id();
      nsp_type_gtkmisc = type;
      if ( nsp_register_type(nsp_type_gtkmisc) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkmisc, GTK_TYPE_MISC);
      return ( mode == T_BASE ) ? type : new_type_gtkmisc(mode);
    }
  else 
    {
      type->id = nsp_type_gtkmisc_id;
      return type;
    }
}

/*
 * initialize NspGtkMisc instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkmisc(NspGtkMisc *Obj,NspTypeGtkMisc *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkMisc 
 */

NspGtkMisc *new_gtkmisc() 
{
  NspGtkMisc *loc;
  /* type must exists */
  nsp_type_gtkmisc = new_type_gtkmisc(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkMisc)))== NULLGTKMISC) return loc;
  /* initialize object */
  if ( init_gtkmisc(loc,nsp_type_gtkmisc) == FAIL) return NULLGTKMISC;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkMisc 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkmisc_type_name[]="GtkMisc";
static char gtkmisc_short_type_name[]="GtkMisc";

static char *nsp_gtkmisc_type_as_string(void)
{
  return(gtkmisc_type_name);
}

static char *nsp_gtkmisc_type_short_string(NspObject *v)
{
  return(gtkmisc_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkMisc objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkMisc   *nsp_gtkmisc_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkmisc_id)  == TRUE  ) return ((NspGtkMisc *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkmisc));
  return NULL;
}

int IsGtkMiscObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkmisc_id);
}

int IsGtkMisc(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkmisc_id);
}

NspGtkMisc  *GetGtkMiscCopy(Stack stack, int i)
{
  if (  GetGtkMisc(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkMisc  *GetGtkMisc(Stack stack, int i)
{
  NspGtkMisc *M;
  if (( M = nsp_gtkmisc_object(NthObj(i))) == NULLGTKMISC)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkMisc *gtkmisc_copy(NspGtkMisc *self)
{
  /* return gtkwidget_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmisc);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkmisc);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkMisc
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static NspMethods *gtkmisc_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkmisc_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAlignment ----------- */


#define  NspGtkAlignment_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkalignment.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAlignment inherits from GtkBin 
 * and implements GtkBuildable
 */

int nsp_type_gtkalignment_id=0;
NspTypeGtkAlignment *nsp_type_gtkalignment=NULL;

/*
 * Type object for NspGtkAlignment 
 * all the instance of NspTypeGtkAlignment share the same id. 
 * nsp_type_gtkalignment: is an instance of NspTypeGtkAlignment 
 *    used for objects of NspGtkAlignment type (i.e built with new_gtkalignment) 
 * other instances are used for derived classes 
 */
NspTypeGtkAlignment *new_type_gtkalignment(type_mode mode)
{
  NspTypeGtkBuildable *t_gtkbuildable;
  NspTypeGtkAlignment *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkalignment != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkalignment;
    }
  if (( type =  malloc(sizeof(NspTypeGtkBin))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gtkbin(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkalignment_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkalignment_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkalignment;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkalignment */ 

  top->s_type =  (s_type_func *) nsp_gtkalignment_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkalignment_type_short_string;
  /* top->create = (create_func*) int_gtkalignment_create;*/

  /* specific methods for gtkalignment */

  type->init = (init_func *) init_gtkalignment;

  /* 
   * NspGtkAlignment interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  t_gtkbuildable = new_type_gtkbuildable(T_DERIVED);
  type->interface = (NspTypeBase * ) t_gtkbuildable;
  if ( nsp_type_gtkalignment_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAlignment called nsp_type_gtkalignment
       */
      type->id =  nsp_type_gtkalignment_id = nsp_new_type_id();
      nsp_type_gtkalignment = type;
      if ( nsp_register_type(nsp_type_gtkalignment) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkalignment, GTK_TYPE_ALIGNMENT);
      return ( mode == T_BASE ) ? type : new_type_gtkalignment(mode);
    }
  else 
    {
      type->id = nsp_type_gtkalignment_id;
      return type;
    }
}

/*
 * initialize NspGtkAlignment instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkalignment(NspGtkAlignment *Obj,NspTypeGtkAlignment *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAlignment 
 */

NspGtkAlignment *new_gtkalignment() 
{
  NspGtkAlignment *loc;
  /* type must exists */
  nsp_type_gtkalignment = new_type_gtkalignment(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAlignment)))== NULLGTKALIGNMENT) return loc;
  /* initialize object */
  if ( init_gtkalignment(loc,nsp_type_gtkalignment) == FAIL) return NULLGTKALIGNMENT;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAlignment 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkalignment_type_name[]="GtkAlignment";
static char gtkalignment_short_type_name[]="GtkAlignment";

static char *nsp_gtkalignment_type_as_string(void)
{
  return(gtkalignment_type_name);
}

static char *nsp_gtkalignment_type_short_string(NspObject *v)
{
  return(gtkalignment_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAlignment objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAlignment   *nsp_gtkalignment_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkalignment_id)  == TRUE  ) return ((NspGtkAlignment *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkalignment));
  return NULL;
}

int IsGtkAlignmentObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkalignment_id);
}

int IsGtkAlignment(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkalignment_id);
}

NspGtkAlignment  *GetGtkAlignmentCopy(Stack stack, int i)
{
  if (  GetGtkAlignment(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAlignment  *GetGtkAlignment(Stack stack, int i)
{
  NspGtkAlignment *M;
  if (( M = nsp_gtkalignment_object(NthObj(i))) == NULLGTKALIGNMENT)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAlignment *gtkalignment_copy(NspGtkAlignment *self)
{
  /* return gtkbin_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkalignment);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkalignment);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAlignment
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static NspMethods *gtkalignment_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkalignment_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkIconTheme ----------- */


#define  NspGtkIconTheme_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkicontheme.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkIconTheme inherits from GObject 
 */

int nsp_type_gtkicontheme_id=0;
NspTypeGtkIconTheme *nsp_type_gtkicontheme=NULL;

/*
 * Type object for NspGtkIconTheme 
 * all the instance of NspTypeGtkIconTheme share the same id. 
 * nsp_type_gtkicontheme: is an instance of NspTypeGtkIconTheme 
 *    used for objects of NspGtkIconTheme type (i.e built with new_gtkicontheme) 
 * other instances are used for derived classes 
 */
NspTypeGtkIconTheme *new_type_gtkicontheme(type_mode mode)
{
  NspTypeGtkIconTheme *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkicontheme != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkicontheme;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkicontheme_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkicontheme_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkicontheme;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkicontheme */ 

  top->s_type =  (s_type_func *) nsp_gtkicontheme_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkicontheme_type_short_string;
  /* top->create = (create_func*) int_gtkicontheme_create;*/

  /* specific methods for gtkicontheme */

  type->init = (init_func *) init_gtkicontheme;

  /* 
   * NspGtkIconTheme interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkicontheme_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkIconTheme called nsp_type_gtkicontheme
       */
      type->id =  nsp_type_gtkicontheme_id = nsp_new_type_id();
      nsp_type_gtkicontheme = type;
      if ( nsp_register_type(nsp_type_gtkicontheme) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkicontheme, GTK_TYPE_ICON_THEME);
      return ( mode == T_BASE ) ? type : new_type_gtkicontheme(mode);
    }
  else 
    {
      type->id = nsp_type_gtkicontheme_id;
      return type;
    }
}

/*
 * initialize NspGtkIconTheme instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkicontheme(NspGtkIconTheme *Obj,NspTypeGtkIconTheme *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkIconTheme 
 */

NspGtkIconTheme *new_gtkicontheme() 
{
  NspGtkIconTheme *loc;
  /* type must exists */
  nsp_type_gtkicontheme = new_type_gtkicontheme(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkIconTheme)))== NULLGTKICONTHEME) return loc;
  /* initialize object */
  if ( init_gtkicontheme(loc,nsp_type_gtkicontheme) == FAIL) return NULLGTKICONTHEME;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkIconTheme 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkicontheme_type_name[]="GtkIconTheme";
static char gtkicontheme_short_type_name[]="GtkIconTheme";

static char *nsp_gtkicontheme_type_as_string(void)
{
  return(gtkicontheme_type_name);
}

static char *nsp_gtkicontheme_type_short_string(NspObject *v)
{
  return(gtkicontheme_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkIconTheme objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkIconTheme   *nsp_gtkicontheme_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkicontheme_id)  == TRUE  ) return ((NspGtkIconTheme *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkicontheme));
  return NULL;
}

int IsGtkIconThemeObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkicontheme_id);
}

int IsGtkIconTheme(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkicontheme_id);
}

NspGtkIconTheme  *GetGtkIconThemeCopy(Stack stack, int i)
{
  if (  GetGtkIconTheme(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkIconTheme  *GetGtkIconTheme(Stack stack, int i)
{
  NspGtkIconTheme *M;
  if (( M = nsp_gtkicontheme_object(NthObj(i))) == NULLGTKICONTHEME)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkIconTheme *gtkicontheme_copy(NspGtkIconTheme *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkicontheme);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkicontheme);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkIconTheme
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_icon_theme_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_icon_theme_new())== NULL) return RET_BUG;

  nsp_type_gtkicontheme = new_type_gtkicontheme(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkicontheme);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_icon_theme_set_screen(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *screen;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen) == FAIL) return RET_BUG;
    gtk_icon_theme_set_screen(GTK_ICON_THEME(self->obj),GDK_SCREEN(screen->obj));
  return 0;
}

static int _wrap_gtk_icon_theme_append_search_path(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *path;
  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
    gtk_icon_theme_append_search_path(GTK_ICON_THEME(self->obj),path);
  return 0;
}

static int _wrap_gtk_icon_theme_prepend_search_path(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *path;
  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
    gtk_icon_theme_prepend_search_path(GTK_ICON_THEME(self->obj),path);
  return 0;
}

#if GTK_CHECK_VERSION(3,14,0)
static int _wrap_gtk_icon_theme_add_resource_path(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *path;
  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
    gtk_icon_theme_add_resource_path(GTK_ICON_THEME(self->obj),path);
  return 0;
}

#else
int _wrap_gtk_icon_theme_add_resource_path(Stack stack, int rhs, int opt, int lhs) /* add_resource_path */
{
  Scierror("Error: function gtk_icon_theme_add_resource_path not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_icon_theme_set_custom_theme(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *theme_name;
  if ( GetArgs(stack,rhs,opt,T,&theme_name) == FAIL) return RET_BUG;
    gtk_icon_theme_set_custom_theme(GTK_ICON_THEME(self->obj),theme_name);
  return 0;
}

static int _wrap_gtk_icon_theme_has_icon(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *icon_name;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&icon_name) == FAIL) return RET_BUG;
    ret =gtk_icon_theme_has_icon(GTK_ICON_THEME(self->obj),icon_name);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_theme_get_icon_sizes(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *icon_name;
  int *ret;
  if ( GetArgs(stack,rhs,opt,T,&icon_name) == FAIL) return RET_BUG;
    ret =gtk_icon_theme_get_icon_sizes(GTK_ICON_THEME(self->obj),icon_name);
  if ( nsp_move_double(stack,1,(double) *ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_icon_theme_lookup_icon(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int,obj, t_end};
  char *icon_name;
  int size;
  GtkIconLookupFlags flags;
  NspObject *nsp_flags = NULL, *nsp_ret;
  GtkIconInfo *ret;
  if ( GetArgs(stack,rhs,opt,T,&icon_name, &size, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    ret =gtk_icon_theme_lookup_icon(GTK_ICON_THEME(self->obj),icon_name,size,flags);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_INFO, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconinfo))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_icon_theme_lookup_icon_for_scale(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int,s_int,obj, t_end};
  char *icon_name;
  int size, scale;
  GtkIconLookupFlags flags;
  NspObject *nsp_flags = NULL, *nsp_ret;
  GtkIconInfo *ret;
  if ( GetArgs(stack,rhs,opt,T,&icon_name, &size, &scale, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    ret =gtk_icon_theme_lookup_icon_for_scale(GTK_ICON_THEME(self->obj),icon_name,size,scale,flags);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_INFO, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconinfo))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_icon_theme_lookup_icon_for_scale(Stack stack, int rhs, int opt, int lhs) /* lookup_icon_for_scale */
{
  Scierror("Error: function gtk_icon_theme_lookup_icon_for_scale not available\n");
  return RET_BUG;
}
#endif
#line 7698 "codegen-3.0/gtk.override"

static int _wrap_gtk_icon_theme_choose_icon(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  NspSMatrix *S=NULL;
  int_types T[] = {smat,s_int,obj, t_end};
  int size;
  GtkIconLookupFlags flags;
  NspObject *nsp_flags = NULL, *nsp_ret;
  GtkIconInfo *ret;
  if ( GetArgs(stack,rhs,opt,T,&S, &size, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
  ret =gtk_icon_theme_choose_icon(GTK_ICON_THEME(self->obj),(const gchar **)S->S,size,flags);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_INFO, ret, FALSE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconinfo))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 74674 "gtk.c"


#line 7720 "codegen-3.0/gtk.override"
static int _wrap_gtk_icon_theme_choose_icon_for_scale(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  NspSMatrix *S=NULL;
  int_types T[] = {smat,s_int,s_int,obj, t_end};
  int size, scale;
  GtkIconLookupFlags flags;
  NspObject *nsp_flags = NULL, *nsp_ret;
  GtkIconInfo *ret;
  if ( GetArgs(stack,rhs,opt,T,S, &size, &scale, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
  ret =gtk_icon_theme_choose_icon_for_scale(GTK_ICON_THEME(self->obj),(const gchar **) S->S,size,scale,flags);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_INFO, ret, FALSE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconinfo))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#line 74697 "gtk.c"


static int _wrap_gtk_icon_theme_load_icon(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int,obj, t_end};
  char *icon_name;
  int size;
  GtkIconLookupFlags flags;
  NspObject *nsp_flags = NULL, *nsp_ret;
  GError *error = NULL;
  GdkPixbuf *ret;
  if ( GetArgs(stack,rhs,opt,T,&icon_name, &size, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    ret =gtk_icon_theme_load_icon(GTK_ICON_THEME(self->obj),icon_name,size,flags,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_icon_theme_load_icon_for_scale(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int,s_int,obj, t_end};
  char *icon_name;
  int size, scale;
  GtkIconLookupFlags flags;
  NspObject *nsp_flags = NULL, *nsp_ret;
  GError *error = NULL;
  GdkPixbuf *ret;
  if ( GetArgs(stack,rhs,opt,T,&icon_name, &size, &scale, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    ret =gtk_icon_theme_load_icon_for_scale(GTK_ICON_THEME(self->obj),icon_name,size,scale,flags,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_icon_theme_load_icon_for_scale(Stack stack, int rhs, int opt, int lhs) /* load_icon_for_scale */
{
  Scierror("Error: function gtk_icon_theme_load_icon_for_scale not available\n");
  return RET_BUG;
}
#endif
#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_icon_theme_load_surface(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int,s_int,obj_check,obj, t_end};
  char *icon_name;
  int size, scale;
  NspGObject *for_window;
  GtkIconLookupFlags flags;
  NspObject *nsp_flags = NULL, *nsp_ret;
  GError *error = NULL;
  cairo_surface_t *ret;
  if ( GetArgs(stack,rhs,opt,T,&icon_name, &size, &scale, &nsp_type_gdkwindow, &for_window, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    ret =gtk_icon_theme_load_surface(GTK_ICON_THEME(self->obj),icon_name,size,scale,GDK_WINDOW(for_window->obj),flags,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,CAIRO_GOBJECT_TYPE_SURFACE, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_cairo_surface_t))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_icon_theme_load_surface(Stack stack, int rhs, int opt, int lhs) /* load_surface */
{
  Scierror("Error: function gtk_icon_theme_load_surface not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_icon_theme_lookup_by_gicon(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,obj, t_end};
  NspGObject *icon;
  int size;
  GtkIconLookupFlags flags;
  NspObject *nsp_flags = NULL, *nsp_ret;
  GtkIconInfo *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gicon, &icon, &size, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    ret =gtk_icon_theme_lookup_by_gicon(GTK_ICON_THEME(self->obj),G_ICON(icon->obj),size,flags);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_INFO, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconinfo))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,10,0)
static int _wrap_gtk_icon_theme_lookup_by_gicon_for_scale(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check,s_int,s_int,obj, t_end};
  NspGObject *icon;
  int size, scale;
  GtkIconLookupFlags flags;
  NspObject *nsp_flags = NULL, *nsp_ret;
  GtkIconInfo *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gicon, &icon, &size, &scale, &nsp_flags) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_ICON_LOOKUP_FLAGS, nsp_flags, &flags)==FAIL)
      return RET_BUG;
    ret =gtk_icon_theme_lookup_by_gicon_for_scale(GTK_ICON_THEME(self->obj),G_ICON(icon->obj),size,scale,flags);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_ICON_INFO, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkiconinfo))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_icon_theme_lookup_by_gicon_for_scale(Stack stack, int rhs, int opt, int lhs) /* lookup_by_gicon_for_scale */
{
  Scierror("Error: function gtk_icon_theme_lookup_by_gicon_for_scale not available\n");
  return RET_BUG;
}
#endif
#line 7741 "codegen-3.0/gtk.override"

static int _wrap_gtk_icon_theme_list_icons(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *context;
  GList *ret, *tmp;
  NspList *nsp_list;
  if ( rhs <= 0 )
    {
      ret =gtk_icon_theme_list_icons(GTK_ICON_THEME(self->obj),NULL);
    }
  else
    {
      if ( GetArgs(stack,rhs,opt,T,&context) == FAIL) return RET_BUG;
      ret =gtk_icon_theme_list_icons(GTK_ICON_THEME(self->obj),context);
    }
  /* objects are strings  */
  NSP_LIST_FROM_GLIST(ret,nsp_new_string_obj("lel",tmp->data,-1),g_list_free);
}


#line 74855 "gtk.c"


#line 7764 "codegen-3.0/gtk.override"

static int _wrap_gtk_icon_theme_list_contexts(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
  CheckLhs(0,1);
  ret =gtk_icon_theme_list_contexts(GTK_ICON_THEME(self->obj));
  /* objects are strings  */
  NSP_LIST_FROM_GLIST(ret,nsp_new_string_obj("lel",tmp->data,-1),g_list_free);
}

#line 74871 "gtk.c"


static int _wrap_gtk_icon_theme_get_example_icon_name(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_icon_theme_get_example_icon_name(GTK_ICON_THEME(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_icon_theme_rescan_if_needed(NspGtkIconTheme *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_icon_theme_rescan_if_needed(GTK_ICON_THEME(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkicontheme_methods[] = {
  {"set_screen",(nsp_method *) _wrap_gtk_icon_theme_set_screen},
  {"append_search_path",(nsp_method *) _wrap_gtk_icon_theme_append_search_path},
  {"prepend_search_path",(nsp_method *) _wrap_gtk_icon_theme_prepend_search_path},
  {"add_resource_path",(nsp_method *) _wrap_gtk_icon_theme_add_resource_path},
  {"set_custom_theme",(nsp_method *) _wrap_gtk_icon_theme_set_custom_theme},
  {"has_icon",(nsp_method *) _wrap_gtk_icon_theme_has_icon},
  {"get_icon_sizes",(nsp_method *) _wrap_gtk_icon_theme_get_icon_sizes},
  {"lookup_icon",(nsp_method *) _wrap_gtk_icon_theme_lookup_icon},
  {"lookup_icon_for_scale",(nsp_method *) _wrap_gtk_icon_theme_lookup_icon_for_scale},
  {"choose_icon",(nsp_method *) _wrap_gtk_icon_theme_choose_icon},
  {"choose_icon_for_scale",(nsp_method *) _wrap_gtk_icon_theme_choose_icon_for_scale},
  {"load_icon",(nsp_method *) _wrap_gtk_icon_theme_load_icon},
  {"load_icon_for_scale",(nsp_method *) _wrap_gtk_icon_theme_load_icon_for_scale},
  {"load_surface",(nsp_method *) _wrap_gtk_icon_theme_load_surface},
  {"lookup_by_gicon",(nsp_method *) _wrap_gtk_icon_theme_lookup_by_gicon},
  {"lookup_by_gicon_for_scale",(nsp_method *) _wrap_gtk_icon_theme_lookup_by_gicon_for_scale},
  {"list_icons",(nsp_method *) _wrap_gtk_icon_theme_list_icons},
  {"list_contexts",(nsp_method *) _wrap_gtk_icon_theme_list_contexts},
  {"get_example_icon_name",(nsp_method *) _wrap_gtk_icon_theme_get_example_icon_name},
  {"rescan_if_needed",(nsp_method *) _wrap_gtk_icon_theme_rescan_if_needed},
  { NULL, NULL}
};

static NspMethods *gtkicontheme_get_methods(void) { return gtkicontheme_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkicontheme_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkAccelGroup ----------- */


#define  NspGtkAccelGroup_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkaccelgroup.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkAccelGroup inherits from GObject 
 */

int nsp_type_gtkaccelgroup_id=0;
NspTypeGtkAccelGroup *nsp_type_gtkaccelgroup=NULL;

/*
 * Type object for NspGtkAccelGroup 
 * all the instance of NspTypeGtkAccelGroup share the same id. 
 * nsp_type_gtkaccelgroup: is an instance of NspTypeGtkAccelGroup 
 *    used for objects of NspGtkAccelGroup type (i.e built with new_gtkaccelgroup) 
 * other instances are used for derived classes 
 */
NspTypeGtkAccelGroup *new_type_gtkaccelgroup(type_mode mode)
{
  NspTypeGtkAccelGroup *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkaccelgroup != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkaccelgroup;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkaccelgroup_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkaccelgroup_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkaccelgroup;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkaccelgroup */ 

  top->s_type =  (s_type_func *) nsp_gtkaccelgroup_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkaccelgroup_type_short_string;
  /* top->create = (create_func*) int_gtkaccelgroup_create;*/

  /* specific methods for gtkaccelgroup */

  type->init = (init_func *) init_gtkaccelgroup;

  /* 
   * NspGtkAccelGroup interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkaccelgroup_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkAccelGroup called nsp_type_gtkaccelgroup
       */
      type->id =  nsp_type_gtkaccelgroup_id = nsp_new_type_id();
      nsp_type_gtkaccelgroup = type;
      if ( nsp_register_type(nsp_type_gtkaccelgroup) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkaccelgroup, GTK_TYPE_ACCEL_GROUP);
      return ( mode == T_BASE ) ? type : new_type_gtkaccelgroup(mode);
    }
  else 
    {
      type->id = nsp_type_gtkaccelgroup_id;
      return type;
    }
}

/*
 * initialize NspGtkAccelGroup instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkaccelgroup(NspGtkAccelGroup *Obj,NspTypeGtkAccelGroup *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkAccelGroup 
 */

NspGtkAccelGroup *new_gtkaccelgroup() 
{
  NspGtkAccelGroup *loc;
  /* type must exists */
  nsp_type_gtkaccelgroup = new_type_gtkaccelgroup(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkAccelGroup)))== NULLGTKACCELGROUP) return loc;
  /* initialize object */
  if ( init_gtkaccelgroup(loc,nsp_type_gtkaccelgroup) == FAIL) return NULLGTKACCELGROUP;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkAccelGroup 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkaccelgroup_type_name[]="GtkAccelGroup";
static char gtkaccelgroup_short_type_name[]="GtkAccelGroup";

static char *nsp_gtkaccelgroup_type_as_string(void)
{
  return(gtkaccelgroup_type_name);
}

static char *nsp_gtkaccelgroup_type_short_string(NspObject *v)
{
  return(gtkaccelgroup_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkAccelGroup objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkAccelGroup   *nsp_gtkaccelgroup_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkaccelgroup_id)  == TRUE  ) return ((NspGtkAccelGroup *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkaccelgroup));
  return NULL;
}

int IsGtkAccelGroupObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkaccelgroup_id);
}

int IsGtkAccelGroup(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkaccelgroup_id);
}

NspGtkAccelGroup  *GetGtkAccelGroupCopy(Stack stack, int i)
{
  if (  GetGtkAccelGroup(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkAccelGroup  *GetGtkAccelGroup(Stack stack, int i)
{
  NspGtkAccelGroup *M;
  if (( M = nsp_gtkaccelgroup_object(NthObj(i))) == NULLGTKACCELGROUP)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkAccelGroup *gtkaccelgroup_copy(NspGtkAccelGroup *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccelgroup);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkaccelgroup);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkAccelGroup
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_accel_group_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_accel_group_new())== NULL) return RET_BUG;

  nsp_type_gtkaccelgroup = new_type_gtkaccelgroup(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkaccelgroup);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_accel_group_get_is_locked(NspGtkAccelGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_accel_group_get_is_locked(GTK_ACCEL_GROUP(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_accel_group_get_modifier_mask(NspGtkAccelGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_accel_group_get_modifier_mask(GTK_ACCEL_GROUP(self->obj));
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_accel_group_lock(NspGtkAccelGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_accel_group_lock(GTK_ACCEL_GROUP(self->obj));
  return 0;
}

static int _wrap_gtk_accel_group_unlock(NspGtkAccelGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_accel_group_unlock(GTK_ACCEL_GROUP(self->obj));
  return 0;
}

static int _wrap_gtk_accel_group_disconnect_key(NspGtkAccelGroup *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {s_int,obj, t_end};
  int accel_key, ret;
  GdkModifierType accel_mods;
  NspObject *nsp_accel_mods = NULL;
  if ( GetArgs(stack,rhs,opt,T,&accel_key, &nsp_accel_mods) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accel_mods, &accel_mods)==FAIL)
      return RET_BUG;
    ret =gtk_accel_group_disconnect_key(GTK_ACCEL_GROUP(self->obj),accel_key,accel_mods);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static NspMethods gtkaccelgroup_methods[] = {
  {"get_is_locked",(nsp_method *) _wrap_gtk_accel_group_get_is_locked},
  {"get_modifier_mask",(nsp_method *) _wrap_gtk_accel_group_get_modifier_mask},
  {"lock",(nsp_method *) _wrap_gtk_accel_group_lock},
  {"unlock",(nsp_method *) _wrap_gtk_accel_group_unlock},
  {"disconnect_key",(nsp_method *) _wrap_gtk_accel_group_disconnect_key},
  { NULL, NULL}
};

static NspMethods *gtkaccelgroup_get_methods(void) { return gtkaccelgroup_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkaccelgroup_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkCssProvider ----------- */


#define  NspGtkCssProvider_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkcssprovider.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkCssProvider inherits from GObject 
 */

int nsp_type_gtkcssprovider_id=0;
NspTypeGtkCssProvider *nsp_type_gtkcssprovider=NULL;

/*
 * Type object for NspGtkCssProvider 
 * all the instance of NspTypeGtkCssProvider share the same id. 
 * nsp_type_gtkcssprovider: is an instance of NspTypeGtkCssProvider 
 *    used for objects of NspGtkCssProvider type (i.e built with new_gtkcssprovider) 
 * other instances are used for derived classes 
 */
NspTypeGtkCssProvider *new_type_gtkcssprovider(type_mode mode)
{
  NspTypeGtkCssProvider *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkcssprovider != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkcssprovider;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkcssprovider_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkcssprovider_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkcssprovider;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkcssprovider */ 

  top->s_type =  (s_type_func *) nsp_gtkcssprovider_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkcssprovider_type_short_string;
  /* top->create = (create_func*) int_gtkcssprovider_create;*/

  /* specific methods for gtkcssprovider */

  type->init = (init_func *) init_gtkcssprovider;

  /* 
   * NspGtkCssProvider interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkcssprovider_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkCssProvider called nsp_type_gtkcssprovider
       */
      type->id =  nsp_type_gtkcssprovider_id = nsp_new_type_id();
      nsp_type_gtkcssprovider = type;
      if ( nsp_register_type(nsp_type_gtkcssprovider) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkcssprovider, GTK_TYPE_CSS_PROVIDER);
      return ( mode == T_BASE ) ? type : new_type_gtkcssprovider(mode);
    }
  else 
    {
      type->id = nsp_type_gtkcssprovider_id;
      return type;
    }
}

/*
 * initialize NspGtkCssProvider instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkcssprovider(NspGtkCssProvider *Obj,NspTypeGtkCssProvider *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkCssProvider 
 */

NspGtkCssProvider *new_gtkcssprovider() 
{
  NspGtkCssProvider *loc;
  /* type must exists */
  nsp_type_gtkcssprovider = new_type_gtkcssprovider(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkCssProvider)))== NULLGTKCSSPROVIDER) return loc;
  /* initialize object */
  if ( init_gtkcssprovider(loc,nsp_type_gtkcssprovider) == FAIL) return NULLGTKCSSPROVIDER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkCssProvider 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkcssprovider_type_name[]="GtkCssProvider";
static char gtkcssprovider_short_type_name[]="GtkCssProvider";

static char *nsp_gtkcssprovider_type_as_string(void)
{
  return(gtkcssprovider_type_name);
}

static char *nsp_gtkcssprovider_type_short_string(NspObject *v)
{
  return(gtkcssprovider_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkCssProvider objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkCssProvider   *nsp_gtkcssprovider_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkcssprovider_id)  == TRUE  ) return ((NspGtkCssProvider *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkcssprovider));
  return NULL;
}

int IsGtkCssProviderObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkcssprovider_id);
}

int IsGtkCssProvider(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkcssprovider_id);
}

NspGtkCssProvider  *GetGtkCssProviderCopy(Stack stack, int i)
{
  if (  GetGtkCssProvider(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkCssProvider  *GetGtkCssProvider(Stack stack, int i)
{
  NspGtkCssProvider *M;
  if (( M = nsp_gtkcssprovider_object(NthObj(i))) == NULLGTKCSSPROVIDER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkCssProvider *gtkcssprovider_copy(NspGtkCssProvider *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcssprovider);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkcssprovider);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkCssProvider
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int
_wrap_gtk_css_provider_new (Stack stack, int rhs, int opt, int lhs)
{
  GObject *ret; NspObject *nsp_ret;
  CheckRhs(0,0);
  if ((ret = (GObject *)gtk_css_provider_new())== NULL) return RET_BUG;

  nsp_type_gtkcssprovider = new_type_gtkcssprovider(T_BASE);
  nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcssprovider);
  if ( nsp_ret == NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,2,0)
static int _wrap_gtk_css_provider_to_string(NspGtkCssProvider *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_css_provider_to_string(GTK_CSS_PROVIDER(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

#else
int _wrap_gtk_css_provider_to_string(Stack stack, int rhs, int opt, int lhs) /* to_string */
{
  Scierror("Error: function gtk_css_provider_to_string not available\n");
  return RET_BUG;
}
#endif
static int _wrap_gtk_css_provider_load_from_data(NspGtkCssProvider *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,s_int, t_end};
  char *data;
  int length, ret;
  GError *error = NULL;
  if ( GetArgs(stack,rhs,opt,T,&data, &length) == FAIL) return RET_BUG;
    ret =gtk_css_provider_load_from_data(GTK_CSS_PROVIDER(self->obj),data,length,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_css_provider_load_from_file(NspGtkCssProvider *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *file;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gfile, &file) == FAIL) return RET_BUG;
    ret =gtk_css_provider_load_from_file(GTK_CSS_PROVIDER(self->obj),G_FILE(file->obj),&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_css_provider_load_from_path(NspGtkCssProvider *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *path;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&path) == FAIL) return RET_BUG;
    ret =gtk_css_provider_load_from_path(GTK_CSS_PROVIDER(self->obj),path,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#if GTK_CHECK_VERSION(3,16,0)
static int _wrap_gtk_css_provider_load_from_resource(NspGtkCssProvider *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string, t_end};
  char *resource_path;
  if ( GetArgs(stack,rhs,opt,T,&resource_path) == FAIL) return RET_BUG;
    gtk_css_provider_load_from_resource(GTK_CSS_PROVIDER(self->obj),resource_path);
  return 0;
}

#else
int _wrap_gtk_css_provider_load_from_resource(Stack stack, int rhs, int opt, int lhs) /* load_from_resource */
{
  Scierror("Error: function gtk_css_provider_load_from_resource not available\n");
  return RET_BUG;
}
#endif
static NspMethods gtkcssprovider_methods[] = {
  {"to_string",(nsp_method *) _wrap_gtk_css_provider_to_string},
  {"load_from_data",(nsp_method *) _wrap_gtk_css_provider_load_from_data},
  {"load_from_file",(nsp_method *) _wrap_gtk_css_provider_load_from_file},
  {"load_from_path",(nsp_method *) _wrap_gtk_css_provider_load_from_path},
  {"load_from_resource",(nsp_method *) _wrap_gtk_css_provider_load_from_resource},
  { NULL, NULL}
};

static NspMethods *gtkcssprovider_get_methods(void) { return gtkcssprovider_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkcssprovider_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkStyleProvider ----------- */


#define  NspGtkStyleProvider_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkstyleprovider.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkStyleProvider inherits from GObject 
 */

int nsp_type_gtkstyleprovider_id=0;
NspTypeGtkStyleProvider *nsp_type_gtkstyleprovider=NULL;

/*
 * Type object for NspGtkStyleProvider 
 * all the instance of NspTypeGtkStyleProvider share the same id. 
 * nsp_type_gtkstyleprovider: is an instance of NspTypeGtkStyleProvider 
 *    used for objects of NspGtkStyleProvider type (i.e built with new_gtkstyleprovider) 
 * other instances are used for derived classes 
 */
NspTypeGtkStyleProvider *new_type_gtkstyleprovider(type_mode mode)
{
  NspTypeGtkStyleProvider *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkstyleprovider != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkstyleprovider;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkstyleprovider_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkstyleprovider_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkstyleprovider;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkstyleprovider */ 

  top->s_type =  (s_type_func *) nsp_gtkstyleprovider_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkstyleprovider_type_short_string;
  /* top->create = (create_func*) int_gtkstyleprovider_create;*/

  /* specific methods for gtkstyleprovider */

  type->init = (init_func *) init_gtkstyleprovider;

  /* 
   * NspGtkStyleProvider interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkstyleprovider_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkStyleProvider called nsp_type_gtkstyleprovider
       */
      type->id =  nsp_type_gtkstyleprovider_id = nsp_new_type_id();
      nsp_type_gtkstyleprovider = type;
      if ( nsp_register_type(nsp_type_gtkstyleprovider) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkstyleprovider, GTK_TYPE_STYLE_PROVIDER);
      return ( mode == T_BASE ) ? type : new_type_gtkstyleprovider(mode);
    }
  else 
    {
      type->id = nsp_type_gtkstyleprovider_id;
      return type;
    }
}

/*
 * initialize NspGtkStyleProvider instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkstyleprovider(NspGtkStyleProvider *Obj,NspTypeGtkStyleProvider *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkStyleProvider 
 */

NspGtkStyleProvider *new_gtkstyleprovider() 
{
  NspGtkStyleProvider *loc;
  /* type must exists */
  nsp_type_gtkstyleprovider = new_type_gtkstyleprovider(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkStyleProvider)))== NULLGTKSTYLEPROVIDER) return loc;
  /* initialize object */
  if ( init_gtkstyleprovider(loc,nsp_type_gtkstyleprovider) == FAIL) return NULLGTKSTYLEPROVIDER;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkStyleProvider 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkstyleprovider_type_name[]="GtkStyleProvider";
static char gtkstyleprovider_short_type_name[]="GtkStyleProvider";

static char *nsp_gtkstyleprovider_type_as_string(void)
{
  return(gtkstyleprovider_type_name);
}

static char *nsp_gtkstyleprovider_type_short_string(NspObject *v)
{
  return(gtkstyleprovider_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkStyleProvider objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkStyleProvider   *nsp_gtkstyleprovider_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkstyleprovider_id)  == TRUE  ) return ((NspGtkStyleProvider *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkstyleprovider));
  return NULL;
}

int IsGtkStyleProviderObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkstyleprovider_id);
}

int IsGtkStyleProvider(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkstyleprovider_id);
}

NspGtkStyleProvider  *GetGtkStyleProviderCopy(Stack stack, int i)
{
  if (  GetGtkStyleProvider(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkStyleProvider  *GetGtkStyleProvider(Stack stack, int i)
{
  NspGtkStyleProvider *M;
  if (( M = nsp_gtkstyleprovider_object(NthObj(i))) == NULLGTKSTYLEPROVIDER)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkStyleProvider *gtkstyleprovider_copy(NspGtkStyleProvider *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstyleprovider);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkstyleprovider);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkStyleProvider
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static NspMethods *gtkstyleprovider_get_methods(void) { return NULL;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkstyleprovider_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;


/* -----------NspGtkClipboard ----------- */


#define  NspGtkClipboard_Private 
#include <nsp/objects.h>
#include <nsp/gtk/gtkclipboard.h>
#include <nsp/interf.h>
#include <nsp/nspthreads.h>

/* 
 * NspGtkClipboard inherits from GObject 
 */

int nsp_type_gtkclipboard_id=0;
NspTypeGtkClipboard *nsp_type_gtkclipboard=NULL;

/*
 * Type object for NspGtkClipboard 
 * all the instance of NspTypeGtkClipboard share the same id. 
 * nsp_type_gtkclipboard: is an instance of NspTypeGtkClipboard 
 *    used for objects of NspGtkClipboard type (i.e built with new_gtkclipboard) 
 * other instances are used for derived classes 
 */
NspTypeGtkClipboard *new_type_gtkclipboard(type_mode mode)
{
  NspTypeGtkClipboard *type= NULL;
  NspTypeObject *top;
  if (  nsp_type_gtkclipboard != 0 && mode == T_BASE )
    {
      /* initialization performed and T_BASE requested */
      return nsp_type_gtkclipboard;
    }
  if (( type =  malloc(sizeof(NspTypeGObject))) == NULL) return NULL;
  type->interface = NULL;
  type->surtype = (NspTypeBase *) new_type_gobject(T_DERIVED);
  if ( type->surtype == NULL) return NULL;
  type->attrs = gtkclipboard_attrs;
  type->get_attrs = (attrs_func *) int_get_attribute;
  type->set_attrs = (attrs_func *) int_set_attribute;
  type->methods = gtkclipboard_get_methods;
  type->gtk_methods = TRUE;
  type->new = (new_func *) new_gtkclipboard;


  top = NSP_TYPE_OBJECT(type->surtype);
  while ( top->surtype != NULL ) top= NSP_TYPE_OBJECT(top->surtype);

  /* object methods redefined for gtkclipboard */ 

  top->s_type =  (s_type_func *) nsp_gtkclipboard_type_as_string;
  top->sh_type = (sh_type_func *) nsp_gtkclipboard_type_short_string;
  /* top->create = (create_func*) int_gtkclipboard_create;*/

  /* specific methods for gtkclipboard */

  type->init = (init_func *) init_gtkclipboard;

  /* 
   * NspGtkClipboard interfaces can be added here 
   * type->interface = (NspTypeBase *) new_type_b();
   * type->interface->interface = (NspTypeBase *) new_type_C()
   * ....
   */
  if ( nsp_type_gtkclipboard_id == 0 ) 
    {
      /* 
       * the first time we get here we initialize the type id and
       * an instance of NspTypeGtkClipboard called nsp_type_gtkclipboard
       */
      type->id =  nsp_type_gtkclipboard_id = nsp_new_type_id();
      nsp_type_gtkclipboard = type;
      if ( nsp_register_type(nsp_type_gtkclipboard) == FALSE) return NULL;
      /* add a ref to nsp_type in the gtype */
      register_nsp_type_in_gtype((NspTypeBase *)nsp_type_gtkclipboard, GTK_TYPE_CLIPBOARD);
      return ( mode == T_BASE ) ? type : new_type_gtkclipboard(mode);
    }
  else 
    {
      type->id = nsp_type_gtkclipboard_id;
      return type;
    }
}

/*
 * initialize NspGtkClipboard instances 
 * locally and by calling initializer on parent class 
 */

static int init_gtkclipboard(NspGtkClipboard *Obj,NspTypeGtkClipboard *type)
{
  /* initialize the surtype */ 
  if ( type->surtype->init(&Obj->father,type->surtype) == FAIL) return FAIL;
  Obj->type = type;
  NSP_OBJECT(Obj)->basetype = (NspTypeBase *)type;
  /* specific */
 return OK;
}

/*
 * new instance of NspGtkClipboard 
 */

NspGtkClipboard *new_gtkclipboard() 
{
  NspGtkClipboard *loc;
  /* type must exists */
  nsp_type_gtkclipboard = new_type_gtkclipboard(T_BASE);
  if ( (loc = malloc(sizeof(NspGtkClipboard)))== NULLGTKCLIPBOARD) return loc;
  /* initialize object */
  if ( init_gtkclipboard(loc,nsp_type_gtkclipboard) == FAIL) return NULLGTKCLIPBOARD;
  return loc;
}

/*----------------------------------------------
 * Object method redefined for NspGtkClipboard 
 *-----------------------------------------------*/
/*
 * type as string 
 */

static char gtkclipboard_type_name[]="GtkClipboard";
static char gtkclipboard_short_type_name[]="GtkClipboard";

static char *nsp_gtkclipboard_type_as_string(void)
{
  return(gtkclipboard_type_name);
}

static char *nsp_gtkclipboard_type_short_string(NspObject *v)
{
  return(gtkclipboard_short_type_name);
}

/*-----------------------------------------------------
 * a set of functions used when writing interfaces 
 * for NspGtkClipboard objects 
 * Note that some of these functions could become MACROS
 *-----------------------------------------------------*/

NspGtkClipboard   *nsp_gtkclipboard_object(NspObject *O)
{
  /* Follow pointer */
  HOBJ_GET_OBJECT(O,NULL);
  /* Check type */
  if ( check_cast (O,nsp_type_gtkclipboard_id)  == TRUE  ) return ((NspGtkClipboard *) O);
  else 
    Scierror("Error:	Argument should be a %s\n",type_get_name(nsp_type_gtkclipboard));
  return NULL;
}

int IsGtkClipboardObj(Stack stack, int i)
{
  return nsp_object_type(NthObj(i),nsp_type_gtkclipboard_id);
}

int IsGtkClipboard(NspObject *O)
{
  return nsp_object_type(O,nsp_type_gtkclipboard_id);
}

NspGtkClipboard  *GetGtkClipboardCopy(Stack stack, int i)
{
  if (  GetGtkClipboard(stack,i) == NULL ) return NULL;
  return MaybeObjCopy(&NthObj(i));
}

NspGtkClipboard  *GetGtkClipboard(Stack stack, int i)
{
  NspGtkClipboard *M;
  if (( M = nsp_gtkclipboard_object(NthObj(i))) == NULLGTKCLIPBOARD)
     ArgMessage(stack,i);
  return M;
}

/*
 * copy for gobject derived class  
 */

NspGtkClipboard *gtkclipboard_copy(NspGtkClipboard *self)
{
  /* return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkclipboard);*/
  return gobject_create(NVOID,((NspGObject *) self)->obj,(NspTypeBase *) nsp_type_gtkclipboard);
}

/*-------------------------------------------------------------------
 * wrappers for the GtkClipboard
 * i.e functions at Nsp level 
 *-------------------------------------------------------------------*/
/*-------------------------------------------
 * Methods
 *-------------------------------------------*/
static int _wrap_gtk_clipboard_get_display(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkDisplay *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_clipboard_get_display(GTK_CLIPBOARD(self->obj));
  nsp_type_gdkdisplay = new_type_gdkdisplay(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkdisplay))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_clipboard_get_owner(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  GObject *ret;
  CheckRhs(0,0);
    ret =gtk_clipboard_get_owner(GTK_CLIPBOARD(self->obj));
  if (ret == NULL ) return RET_BUG;
  MoveObj(stack,1,NSP_OBJECT(ret));
  return 1;
}

static int _wrap_gtk_clipboard_clear(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_clipboard_clear(GTK_CLIPBOARD(self->obj));
  return 0;
}

static int _wrap_gtk_clipboard_set_text(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {string,new_opts, t_end};
  nsp_option opts[] = {
	{"len",s_int,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  char *text;
  int len = -1;
  if ( GetArgs(stack,rhs,opt,T,&text, opts, &len) == FAIL) return RET_BUG;
    gtk_clipboard_set_text(GTK_CLIPBOARD(self->obj),text,len);
  return 0;
}

static int _wrap_gtk_clipboard_set_image(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *pixbuf;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
    gtk_clipboard_set_image(GTK_CLIPBOARD(self->obj),GDK_PIXBUF(pixbuf->obj));
  return 0;
}

#line 8055 "codegen-3.0/gtk.override"

static void
nspgtk_clipboard_request_text_marshal(GtkClipboard *clipboard, const gchar *text, gpointer user_data)
{
  NspGtkCustomNotify *cunote = user_data;

  NspObject *args[3], *nsp_ret;
  int nret = 0, nargs = 2;
  
  nspg_block_threads();
  args[0] =  (NspObject *) gobject_create("clipboard",(GObject *) clipboard,(NspTypeBase *) nsp_type_gtkclipboard);
  args[1] =  (NspObject *) nsp_smatrix_create_from_string("text",text);
  if ( args[0]== NULL ||args[1]== NULL ) goto end;
  if ( cunote->data != NULL)
    {
      args[2]= cunote->data;
      nargs= 3;
    }
  if ( nsp_gtk_eval_function( (NspPList *)cunote->func ,args,nargs,&nsp_ret,&nret)== FAIL)
    goto end;

  if (nret ==1 && IsBMat(nsp_ret) && ((NspBMatrix *) nsp_ret)->mn==1 )
    {
      /* ret =  ((NspBMatrix *) nsp_ret)->B[0]; */
    }
  nspg_unblock_threads();
 end:
  {
    nspg_unblock_threads();
  }
}

static int _wrap_gtk_clipboard_request_text(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  NspObject *nsp_func, *nsp_arg = NULL;
  NspGtkCustomNotify *cunote;
  CheckRhs(2,2);
  if (( nsp_func = (NspObject *) GetNspPListCopy(stack,1)) == NULL) return RET_BUG;
  if ((nsp_object_set_name(nsp_func,"request_text")== FAIL)) return RET_BUG;
  if (( nsp_arg = (NspObject *) GetListCopy(stack,2)) == NULL ) return RET_BUG;
  if ((nsp_object_set_name(nsp_arg,"m")== FAIL)) return RET_BUG;
  cunote = g_new(NspGtkCustomNotify, 1);
  cunote->func = nsp_func;
  cunote->data = nsp_arg;
  gtk_clipboard_request_text(GTK_CLIPBOARD(self->obj),
			     nspgtk_clipboard_request_text_marshal,
			     cunote);
  /* nsp_func and nsp_arg are destroyed when returning since they 
   * are on the stack. We only need to free cunote
   */
  g_free(cunote);
  return 0;
}

#line 75994 "gtk.c"


static int _wrap_gtk_clipboard_wait_for_contents(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkAtom target;
  NspObject *nsp_target = NULL, *nsp_ret;
  GtkSelectionData *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_target) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_target,&target)==FAIL) return RET_BUG;
    ret =gtk_clipboard_wait_for_contents(GTK_CLIPBOARD(self->obj),target);
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GTK_TYPE_SELECTION_DATA, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gtkselectiondata))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_clipboard_wait_for_text(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar *ret;
  CheckRhs(0,0);
    ret =gtk_clipboard_wait_for_text(GTK_CLIPBOARD(self->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

static int _wrap_gtk_clipboard_wait_for_image(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  GdkPixbuf *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_clipboard_wait_for_image(GTK_CLIPBOARD(self->obj));
  nsp_type_gdkpixbuf = new_type_gdkpixbuf(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkpixbuf))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_clipboard_wait_for_uris(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  gchar **ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_clipboard_wait_for_uris(GTK_CLIPBOARD(self->obj));
  nsp_ret = (NspObject *) nsp_smatrix_create_from_table(ret);
  if ( nsp_ret == NULL) return RET_BUG;
  g_strfreev(ret);
  MoveObj(stack,1,nsp_ret);
  return 1;
}

static int _wrap_gtk_clipboard_wait_is_text_available(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_clipboard_wait_is_text_available(GTK_CLIPBOARD(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_clipboard_wait_is_rich_text_available(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj_check, t_end};
  NspGObject *buffer;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtktextbuffer, &buffer) == FAIL) return RET_BUG;
    ret =gtk_clipboard_wait_is_rich_text_available(GTK_CLIPBOARD(self->obj),GTK_TEXT_BUFFER(buffer->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_clipboard_wait_is_image_available(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_clipboard_wait_is_image_available(GTK_CLIPBOARD(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_clipboard_wait_is_uris_available(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_clipboard_wait_is_uris_available(GTK_CLIPBOARD(self->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

static int _wrap_gtk_clipboard_wait_is_target_available(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {obj, t_end};
  GdkAtom target;
  NspObject *nsp_target = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_target) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_target,&target)==FAIL) return RET_BUG;
    ret =gtk_clipboard_wait_is_target_available(GTK_CLIPBOARD(self->obj),target);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 8031 "codegen-3.0/gtk.override"

static GtkTargetEntry * nsp_gtk_target_entry_from_list(Stack stack,NspList *list,int *n_targets) ;

static int _wrap_gtk_clipboard_set_can_store(NspGObject *self,Stack stack,int rhs,int opt,int lhs)
{
  int_types T[] = {list, t_end} ;
  NspList  *nsp_targets;
  GtkTargetEntry *targets;
  gint n_targets;

  if (GetArgs(stack,rhs,opt,T,&nsp_targets) == FAIL) return RET_BUG;;
  targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets);
  if ( targets ==NULL && n_targets != 0)
    {
      Scierror("Error: failed to build target entries\n");
      return RET_BUG;
    }
  gtk_clipboard_set_can_store(GTK_CLIPBOARD(self->obj), targets, n_targets);
  g_free(targets);
  return 0;
}

#line 76122 "gtk.c"


static int _wrap_gtk_clipboard_store(NspGtkClipboard *self,Stack stack,int rhs,int opt,int lhs)
{
  CheckRhs(0,0);
    gtk_clipboard_store(GTK_CLIPBOARD(self->obj));
  return 0;
}

static NspMethods gtkclipboard_methods[] = {
  {"get_display",(nsp_method *) _wrap_gtk_clipboard_get_display},
  {"get_owner",(nsp_method *) _wrap_gtk_clipboard_get_owner},
  {"clear",(nsp_method *) _wrap_gtk_clipboard_clear},
  {"set_text",(nsp_method *) _wrap_gtk_clipboard_set_text},
  {"set_image",(nsp_method *) _wrap_gtk_clipboard_set_image},
  {"request_text",(nsp_method *) _wrap_gtk_clipboard_request_text},
  {"wait_for_contents",(nsp_method *) _wrap_gtk_clipboard_wait_for_contents},
  {"wait_for_text",(nsp_method *) _wrap_gtk_clipboard_wait_for_text},
  {"wait_for_image",(nsp_method *) _wrap_gtk_clipboard_wait_for_image},
  {"wait_for_uris",(nsp_method *) _wrap_gtk_clipboard_wait_for_uris},
  {"wait_is_text_available",(nsp_method *) _wrap_gtk_clipboard_wait_is_text_available},
  {"wait_is_rich_text_available",(nsp_method *) _wrap_gtk_clipboard_wait_is_rich_text_available},
  {"wait_is_image_available",(nsp_method *) _wrap_gtk_clipboard_wait_is_image_available},
  {"wait_is_uris_available",(nsp_method *) _wrap_gtk_clipboard_wait_is_uris_available},
  {"wait_is_target_available",(nsp_method *) _wrap_gtk_clipboard_wait_is_target_available},
  {"set_can_store",(nsp_method *) _wrap_gtk_clipboard_set_can_store},
  {"store",(nsp_method *) _wrap_gtk_clipboard_store},
  { NULL, NULL}
};

static NspMethods *gtkclipboard_get_methods(void) { return gtkclipboard_methods;};
/*-------------------------------------------
 * Attributes
 *-------------------------------------------*/

static AttrTab gtkclipboard_attrs[]={{NULL,NULL,NULL,NULL,NULL}} ;

/*-------------------------------------------
 * functions 
 *-------------------------------------------*/
#line 3474 "codegen-3.0/gtk.override"

#include <nsp/opengl.h>

int _wrap_nsp_graphic_new(Stack stack, int rhs, int opt, int lhs)
{
  int win_id,open_gl=FALSE;
  int_types T[] = {obj_check, obj_check,new_opts,t_end};

  nsp_option opts[] ={{ "dim",mat_int,NULLOBJ,-1},
		      { "opengl", s_bool, NULLOBJ,-1},
		      { "popup_dim",mat_int,NULLOBJ,-1},
		      { "popup_pos",mat_int,NULLOBJ,-1},
		      { "viewport_pos",realmat,NULLOBJ,-1},
		      { "winnum",s_int,NULLOBJ,-1},
		      { NULL,t_end,NULLOBJ,-1}};
  int winnum = -1;
  NspMatrix *wdim = NULL, *wpdim = NULL,*viewport = NULL, *wpos = NULL;
  NspGObject *window, *vbox;

  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &window, &nsp_type_gtkwidget, &vbox,
	       opts,  &wdim,&open_gl, &wpdim, &wpos, &viewport,&winnum) == FAIL) return RET_BUG;
  if (wdim != NULL) { CheckDims(NspFname(stack),3,wdim,1,2);}
  if (wpdim != NULL){ CheckDims(NspFname(stack),3,wpdim,1,2);}
  if (viewport != NULL) {CheckDims(NspFname(stack),3,viewport,1,2);}
  if (wpos != NULL) {CheckDims(NspFname(stack),3,wpos,1,2);}
#ifdef WITH_OPENGL
  if ( open_gl == TRUE )
    win_id= nsp_graphic_new_gl(GTK_WIDGET(window->obj), GTK_WIDGET(vbox->obj), winnum,
			    (wdim) ? (int*) wdim->R: NULL ,
			    (wpdim) ? (int*)wpdim->R: NULL,
			    (viewport) ? viewport->R : NULL,
			    (wpos) ? (int*)wpos->R : NULL);
  else
#endif
    win_id= nsp_graphic_new(GTK_WIDGET(window->obj), GTK_WIDGET(vbox->obj), winnum,
			    (wdim) ? (int*) wdim->R: NULL ,
			    (wpdim) ? (int*)wpdim->R: NULL,
			    (viewport) ? viewport->R : NULL,
			    (wpos) ? (int*)wpos->R : NULL);
  if ( nsp_move_doubles(stack,1,1,1,(double) win_id) == FAIL) return RET_BUG;
  return 1;
}

#line 76207 "gtk.c"


int _wrap_gtk_accelerator_valid(Stack stack, int rhs, int opt, int lhs) /* gtk_accelerator_valid */
{
  int_types T[] = {s_int,obj, t_end};
  int keyval, ret;
  GdkModifierType modifiers;
  NspObject *nsp_modifiers = NULL;
  if ( GetArgs(stack,rhs,opt,T,&keyval, &nsp_modifiers) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_modifiers, &modifiers)==FAIL)
      return RET_BUG;
    ret =gtk_accelerator_valid(keyval,modifiers);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_accelerator_name(Stack stack, int rhs, int opt, int lhs) /* gtk_accelerator_name */
{
  int_types T[] = {s_int,obj, t_end};
  int accelerator_key;
  GdkModifierType accelerator_mods;
  NspObject *nsp_accelerator_mods = NULL;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&accelerator_key, &nsp_accelerator_mods) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accelerator_mods, &accelerator_mods)==FAIL)
      return RET_BUG;
    ret =gtk_accelerator_name(accelerator_key,accelerator_mods);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_accelerator_name_with_keycode(Stack stack, int rhs, int opt, int lhs) /* gtk_accelerator_name_with_keycode */
{
  int_types T[] = {obj_check,s_int,s_int,obj, t_end};
  NspGObject *display;
  int accelerator_key, keycode;
  GdkModifierType accelerator_mods;
  NspObject *nsp_accelerator_mods = NULL;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdisplay, &display, &accelerator_key, &keycode, &nsp_accelerator_mods) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accelerator_mods, &accelerator_mods)==FAIL)
      return RET_BUG;
    ret =gtk_accelerator_name_with_keycode(GDK_DISPLAY(display->obj),accelerator_key,keycode,accelerator_mods);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_accelerator_get_label(Stack stack, int rhs, int opt, int lhs) /* gtk_accelerator_get_label */
{
  int_types T[] = {s_int,obj, t_end};
  int accelerator_key;
  GdkModifierType accelerator_mods;
  NspObject *nsp_accelerator_mods = NULL;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&accelerator_key, &nsp_accelerator_mods) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accelerator_mods, &accelerator_mods)==FAIL)
      return RET_BUG;
    ret =gtk_accelerator_get_label(accelerator_key,accelerator_mods);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_accelerator_get_label_with_keycode(Stack stack, int rhs, int opt, int lhs) /* gtk_accelerator_get_label_with_keycode */
{
  int_types T[] = {obj_check,s_int,s_int,obj, t_end};
  NspGObject *display;
  int accelerator_key, keycode;
  GdkModifierType accelerator_mods;
  NspObject *nsp_accelerator_mods = NULL;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdisplay, &display, &accelerator_key, &keycode, &nsp_accelerator_mods) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accelerator_mods, &accelerator_mods)==FAIL)
      return RET_BUG;
    ret =gtk_accelerator_get_label_with_keycode(GDK_DISPLAY(display->obj),accelerator_key,keycode,accelerator_mods);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_accelerator_set_default_mod_mask(Stack stack, int rhs, int opt, int lhs) /* gtk_accelerator_set_default_mod_mask */
{
  int_types T[] = {obj, t_end};
  GdkModifierType default_mod_mask;
  NspObject *nsp_default_mod_mask = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_default_mod_mask) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_default_mod_mask, &default_mod_mask)==FAIL)
      return RET_BUG;
    gtk_accelerator_set_default_mod_mask(default_mod_mask);
  return 0;
}

int _wrap_gtk_accelerator_get_default_mod_mask(Stack stack, int rhs, int opt, int lhs) /* gtk_accelerator_get_default_mod_mask */
{
  guint ret;
  CheckRhs(0,0);
    ret =gtk_accelerator_get_default_mod_mask();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_accel_map_add_entry(Stack stack, int rhs, int opt, int lhs) /* gtk_accel_map_add_entry */
{
  int_types T[] = {string,s_int,obj, t_end};
  char *accel_path;
  int accel_key;
  GdkModifierType accel_mods;
  NspObject *nsp_accel_mods = NULL;
  if ( GetArgs(stack,rhs,opt,T,&accel_path, &accel_key, &nsp_accel_mods) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accel_mods, &accel_mods)==FAIL)
      return RET_BUG;
    gtk_accel_map_add_entry(accel_path,accel_key,accel_mods);
  return 0;
}

int _wrap_gtk_accel_map_change_entry(Stack stack, int rhs, int opt, int lhs) /* gtk_accel_map_change_entry */
{
  int_types T[] = {string,s_int,obj,s_bool, t_end};
  char *accel_path;
  int accel_key, replace, ret;
  GdkModifierType accel_mods;
  NspObject *nsp_accel_mods = NULL;
  if ( GetArgs(stack,rhs,opt,T,&accel_path, &accel_key, &nsp_accel_mods, &replace) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_accel_mods, &accel_mods)==FAIL)
      return RET_BUG;
    ret =gtk_accel_map_change_entry(accel_path,accel_key,accel_mods,replace);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_accel_map_load(Stack stack, int rhs, int opt, int lhs) /* gtk_accel_map_load */
{
  int_types T[] = {string, t_end};
  char *file_name;
  if ( GetArgs(stack,rhs,opt,T,&file_name) == FAIL) return RET_BUG;
    gtk_accel_map_load(file_name);
  return 0;
}

int _wrap_gtk_accel_map_save(Stack stack, int rhs, int opt, int lhs) /* gtk_accel_map_save */
{
  int_types T[] = {string, t_end};
  char *file_name;
  if ( GetArgs(stack,rhs,opt,T,&file_name) == FAIL) return RET_BUG;
    gtk_accel_map_save(file_name);
  return 0;
}

int _wrap_gtk_accel_map_load_fd(Stack stack, int rhs, int opt, int lhs) /* gtk_accel_map_load_fd */
{
  int_types T[] = {s_int, t_end};
  int fd;
  if ( GetArgs(stack,rhs,opt,T,&fd) == FAIL) return RET_BUG;
    gtk_accel_map_load_fd(fd);
  return 0;
}

int _wrap_gtk_accel_map_save_fd(Stack stack, int rhs, int opt, int lhs) /* gtk_accel_map_save_fd */
{
  int_types T[] = {s_int, t_end};
  int fd;
  if ( GetArgs(stack,rhs,opt,T,&fd) == FAIL) return RET_BUG;
    gtk_accel_map_save_fd(fd);
  return 0;
}

int _wrap_gtk_accel_map_lock_path(Stack stack, int rhs, int opt, int lhs) /* gtk_accel_map_lock_path */
{
  int_types T[] = {string, t_end};
  char *accel_path;
  if ( GetArgs(stack,rhs,opt,T,&accel_path) == FAIL) return RET_BUG;
    gtk_accel_map_lock_path(accel_path);
  return 0;
}

int _wrap_gtk_accel_map_unlock_path(Stack stack, int rhs, int opt, int lhs) /* gtk_accel_map_unlock_path */
{
  int_types T[] = {string, t_end};
  char *accel_path;
  if ( GetArgs(stack,rhs,opt,T,&accel_path) == FAIL) return RET_BUG;
    gtk_accel_map_unlock_path(accel_path);
  return 0;
}

int _wrap_gtk_accel_map_add_filter(Stack stack, int rhs, int opt, int lhs) /* gtk_accel_map_add_filter */
{
  int_types T[] = {string, t_end};
  char *filter_pattern;
  if ( GetArgs(stack,rhs,opt,T,&filter_pattern) == FAIL) return RET_BUG;
    gtk_accel_map_add_filter(filter_pattern);
  return 0;
}

int _wrap_gtk_bindings_activate(Stack stack, int rhs, int opt, int lhs) /* gtk_bindings_activate */
{
  int_types T[] = {obj_check,s_int,obj, t_end};
  NspGObject *object = NULL;
  int keyval, ret;
  GdkModifierType modifiers;
  NspObject *nsp_modifiers = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gobject, &object, &keyval, &nsp_modifiers) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_modifiers, &modifiers)==FAIL)
      return RET_BUG;
    ret =gtk_bindings_activate(G_OBJECT(object->obj),keyval,modifiers);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_bindings_activate_event(Stack stack, int rhs, int opt, int lhs) /* gtk_bindings_activate_event */
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *object = NULL;
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gobject, &object, &nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    ret =gtk_bindings_activate_event(G_OBJECT(object->obj),(GdkEventKey *)event);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 3519 "codegen-3.0/gtk.override"

static int
_wrap_gtk_binding_entry_add_signal(Stack stack,int rhs,int opt,int lhs)
{

  /*
      FIXME: to be done
  NspObject *first;
  gint len, i;
  NspObject *class;
  guint keyval, modifiers;
  gchar *signal_name;
  GType class_type;
  GtkBindingSet *bset = NULL;
  GSList *slist = NULL;
  gchar *errmsg;

  len = NspTuple_Size(args);
  if (len < 4) {
    Scierror( "binding_entry_add_signal requires at least 4 arguments");
    return RET_BUG;
  }
  first = NspSequence_GetSlice(args, 0, 4);
  if (!GetArgs(first, "Oiis:binding_entry_add_signal", &class,
			 &keyval, &modifiers, &signal_name)) {
    Nsp_DECREF(first);
    return RET_BUG;
  }
  Nsp_DECREF(first);

  class_type = nspg_type_from_object(class);
  if (class_type == 0)
    return RET_BUG;

  bset = gtk_binding_set_by_class(gtk_type_class(class_type));

  if ((len-4)%2) {
    Scierror("GtkBindingSet.add_signal requires an even number of parameter pairs following the first four args");
    return RET_BUG;
  }
  for (i=4; i < len; i+=2) {
    NspObject *item;
    GType arg_type;
    GtkBindingArg *arg = NULL;

    item = NspTuple_GET_ITEM(args, i);
    arg_type = nspg_type_from_object(item);
    if (!arg_type) {
      NspErr_Clear();
      Scierror("GtkBindingSet.add_signal parameter types must be int");
      goto arg_error;
    }
    arg = g_new0 (GtkBindingArg, 1);
    slist = g_slist_prepend(slist, arg);

    arg->arg_type = arg_type;
    switch (GTK_FUNDAMENTAL_TYPE(arg->arg_type)) {
    case GTK_TYPE_CHAR:
    case GTK_TYPE_UCHAR:
    case GTK_TYPE_INT:
    case GTK_TYPE_UINT:
    case GTK_TYPE_BOOL:
    case GTK_TYPE_ENUM:
    case GTK_TYPE_FLAGS:
    case GTK_TYPE_LONG:
    case GTK_TYPE_ULONG:
      arg->arg_type = GTK_TYPE_LONG;
      item = NspTuple_GET_ITEM(args, i+1);
      if (!NspInt_Check(item)) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal "
				 "arg[%u] must be int", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      arg->d.long_data = (glong)NspInt_AsLong(item);
      break;
    case GTK_TYPE_FLOAT:
    case GTK_TYPE_DOUBLE:
      arg->arg_type = GTK_TYPE_DOUBLE;
      item = NspTuple_GET_ITEM(args, i+1);
      if (!NspFloat_Check(item)) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal "
				 "arg[%u] must be float", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      arg->d.long_data = (gdouble)NspFloat_AsDouble(item);
      break;
    case GTK_TYPE_STRING:
      arg->arg_type = GTK_TYPE_STRING;
      if (arg->arg_type != GTK_TYPE_IDENTIFIER)
	arg->arg_type = GTK_TYPE_STRING;
      item = NspTuple_GET_ITEM(args, i+1);
      if (!NspString_Check(item)) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
				 "must be non-empty string", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      arg->d.string_data = (gchar*)NspString_AsString(item);
      if (!arg->d.string_data) {
	errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
				 "must be non-empty string", i+1);
	Scierror( errmsg);
	g_free(errmsg);
	goto arg_error;
      }
      break;
    default:
      errmsg = g_strdup_printf("GtkBindingSet.add_signal unsupported "
			       "type %10s for arg[%u]",
			       gtk_type_name(arg->arg_type), i+1);
      Scierror( errmsg);
      g_free(errmsg);
      goto arg_error;
    }
  }

  slist = g_slist_reverse (slist);
  gtk_binding_entry_add_signall (bset, keyval,modifiers, signal_name, slist);

  g_slist_foreach(slist, (GFunc)g_free, NULL);
  g_slist_free(slist);

  return 0;

 arg_error:
  if (slist) {
    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);
  }
  return RET_BUG;
  */
  return RET_BUG;
}

/* -------------- haven't updated stuff below this line -------------- */
#line 76578 "gtk.c"


int _wrap_gtk_clipboard_get(Stack stack, int rhs, int opt, int lhs) /* gtk_clipboard_get */
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"selection",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GdkAtom selection;
  NspObject *nsp_selection = NULL, *nsp_ret;
  GtkClipboard *ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_selection) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection,&selection)==FAIL) return RET_BUG;
    ret =gtk_clipboard_get(selection);
  nsp_type_gtkclipboard = new_type_gtkclipboard(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkclipboard))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#if GTK_CHECK_VERSION(3,16,0)
int _wrap_gtk_clipboard_get_default(Stack stack, int rhs, int opt, int lhs) /* gtk_clipboard_get_default */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *display;
  GtkClipboard *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdisplay, &display) == FAIL) return RET_BUG;
    ret =gtk_clipboard_get_default(GDK_DISPLAY(display->obj));
  nsp_type_gtkclipboard = new_type_gtkclipboard(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkclipboard))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

#else
int _wrap_gtk_clipboard_get_default(Stack stack, int rhs, int opt, int lhs) /* gtk_clipboard_get_default */
{
  Scierror("Error: function gtk_clipboard_get_default not available\n");
  return RET_BUG;
}
#endif
int _wrap_gtk_hsv_to_rgb(Stack stack, int rhs, int opt, int lhs) /* gtk_hsv_to_rgb */
{
  int_types T[] = {s_double,s_double,s_double,s_double,s_double,s_double, t_end};
  double h, s, v, r, g, b;
  if ( GetArgs(stack,rhs,opt,T,&h, &s, &v, &r, &g, &b) == FAIL) return RET_BUG;
    gtk_hsv_to_rgb(h,s,v,&r,&g,&b);
  return 0;
}

int _wrap_gtk_rgb_to_hsv(Stack stack, int rhs, int opt, int lhs) /* gtk_rgb_to_hsv */
{
  int_types T[] = {s_double,s_double,s_double,s_double,s_double,s_double, t_end};
  double r, g, b, h, s, v;
  if ( GetArgs(stack,rhs,opt,T,&r, &g, &b, &h, &s, &v) == FAIL) return RET_BUG;
    gtk_rgb_to_hsv(r,g,b,&h,&s,&v);
  return 0;
}

int _wrap_gtk_css_provider_get_default(Stack stack, int rhs, int opt, int lhs) /* gtk_css_provider_get_default */
{
  GtkCssProvider *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_css_provider_get_default();
  nsp_type_gtkcssprovider = new_type_gtkcssprovider(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcssprovider))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_css_provider_get_named(Stack stack, int rhs, int opt, int lhs) /* gtk_css_provider_get_named */
{
  int_types T[] = {string,string, t_end};
  char *name, *variant;
  GtkCssProvider *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&name, &variant) == FAIL) return RET_BUG;
    ret =gtk_css_provider_get_named(name,variant);
  nsp_type_gtkcssprovider = new_type_gtkcssprovider(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkcssprovider))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_get_debug_flags(Stack stack, int rhs, int opt, int lhs) /* gtk_get_debug_flags */
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_get_debug_flags();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_set_debug_flags(Stack stack, int rhs, int opt, int lhs) /* gtk_set_debug_flags */
{
  int_types T[] = {s_int, t_end};
  int flags;
  if ( GetArgs(stack,rhs,opt,T,&flags) == FAIL) return RET_BUG;
    gtk_set_debug_flags(flags);
  return 0;
}

int _wrap_gtk_alternative_dialog_button_order(Stack stack, int rhs, int opt, int lhs) /* gtk_alternative_dialog_button_order */
{
  int_types T[] = {new_opts, t_end};
  nsp_option opts[] = {
	{"screen",obj,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  GdkScreen *screen = NULL;
  NspGObject *nsp_screen = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,opts, &nsp_screen) == FAIL) return RET_BUG;
  if ( nsp_screen != NULL ) {
    if ( IsGdkScreen((NspObject *)nsp_screen))
      screen = GDK_SCREEN(nsp_screen->obj);
    else if (! IsNone((NspObject *)nsp_screen)) {
         Scierror( "Error: screen should be a GdkScreen or None\n");
         return RET_BUG;
    }
  }
    ret =gtk_alternative_dialog_button_order(screen);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_drag_get_data(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_get_data */
{
  int_types T[] = {obj_check,obj_check,obj,new_opts, t_end};
  nsp_option opts[] = {
	{"time",s_int,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *widget, *context;
  GdkAtom target;
  NspObject *nsp_target = NULL;
  gulong time = GDK_CURRENT_TIME;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_type_gdkdragcontext, &context, &nsp_target, opts, &time) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_target,&target)==FAIL) return RET_BUG;
    gtk_drag_get_data(GTK_WIDGET(widget->obj),GDK_DRAG_CONTEXT(context->obj),target,time);
  return 0;
}

int _wrap_gtk_drag_finish(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_finish */
{
  int_types T[] = {obj_check,s_bool,s_bool,s_int, t_end};
  NspGObject *context;
  int success, del;
  gulong time_;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdragcontext, &context, &success, &del, &time_) == FAIL) return RET_BUG;
    gtk_drag_finish(GDK_DRAG_CONTEXT(context->obj),success,del,time_);
  return 0;
}

int _wrap_gtk_drag_get_source_widget(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_get_source_widget */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *context;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdragcontext, &context) == FAIL) return RET_BUG;
    ret =gtk_drag_get_source_widget(GDK_DRAG_CONTEXT(context->obj));
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_drag_highlight(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_highlight */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_drag_highlight(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_drag_unhighlight(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_unhighlight */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_drag_unhighlight(GTK_WIDGET(widget->obj));
  return 0;
}

#line 5335 "codegen-3.0/gtk.override"

static int
_wrap_gtk_drag_dest_set(Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *widget;
  int_types T[] = {obj_check,obj,list,obj, t_end} ;
  NspObject *nsp_flags, *nsp_actions;
  NspList *nsp_targets;
  GtkDestDefaults flags;
  GtkTargetEntry *targets;
  GdkDragAction actions;
  gint n_targets;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_flags, &nsp_targets, &nsp_actions)   == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, nsp_flags, &flags))
        return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION, nsp_actions, &actions))
    return RET_BUG;

  targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets);
  if ( targets ==NULL && n_targets != 0)
    {
      Scierror("Error: failed to build target entries\n");
      return RET_BUG;
    }

  gtk_drag_dest_set(GTK_WIDGET(widget->obj), flags, targets, n_targets,  actions);
  g_free(targets);
  return 0;
}

#line 76797 "gtk.c"


int _wrap_gtk_drag_dest_set_proxy(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_dest_set_proxy */
{
  int_types T[] = {obj_check,obj_check,obj,s_bool, t_end};
  NspGObject *widget, *proxy_window;
  GdkDragProtocol protocol;
  NspObject *nsp_protocol = NULL;
  int use_coordinates;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_type_gdkwindow, &proxy_window, &nsp_protocol, &use_coordinates) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GDK_TYPE_DRAG_PROTOCOL, nsp_protocol, &protocol)== FAIL)
      return RET_BUG;
    gtk_drag_dest_set_proxy(GTK_WIDGET(widget->obj),GDK_WINDOW(proxy_window->obj),protocol,use_coordinates);
  return 0;
}

int _wrap_gtk_drag_dest_unset(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_dest_unset */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_drag_dest_unset(GTK_WIDGET(widget->obj));
  return 0;
}

#line 5368 "codegen-3.0/gtk.override"

static int
_wrap_gtk_drag_dest_find_target(Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *widget;
  int_types T[] = {obj_check,obj_check,list, t_end} ;
  NspObject *context,*nsp_ret;
  NspList *nsp_target_list;
  GdkAtom atom;
  CheckLhs(0,1);
  if (GetArgs(stack,rhs,opt,T, &nsp_type_gtkwidget,&widget, &nsp_type_gdkdragcontext, &context, &nsp_target_list)  == FAIL)
    return RET_BUG;;
  if ( nsp_list_length(nsp_target_list) == 0 )
    {
      atom = gtk_drag_dest_find_target(GTK_WIDGET(widget->obj),
				       GDK_DRAG_CONTEXT(nspgobject_get(context)),
				       NULL);
    }
  else
    {
      gint  n_targets;
      GtkTargetEntry *targets;
      GtkTargetList *target_list;
      if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_target_list, &n_targets))==NULL) return RET_BUG;
      target_list = gtk_target_list_new(targets, n_targets);
      g_free(targets);
      atom = gtk_drag_dest_find_target(GTK_WIDGET(widget->obj),
				       GDK_DRAG_CONTEXT(nspgobject_get(context)),
				       target_list);
      gtk_target_list_unref(target_list);
    }
  if ((nsp_ret = (NspObject *) gdkatom_create(NVOID,NULL,atom,NULL))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}
#line 76859 "gtk.c"


#line 5405 "codegen-3.0/gtk.override"
static int
_wrap_gtk_drag_dest_get_target_list(Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *widget;
  GtkTargetList *target_list;
  int_types T[] = {obj_check, t_end} ;
  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget)  == FAIL)    return RET_BUG;;

  target_list = gtk_drag_dest_get_target_list(GTK_WIDGET(widget->obj));
  if (!target_list) {
    return RET_BUG;
  }
  /*
  ret = NspList_New(0);
  for (tmp = target_list->list; tmp != NULL; tmp = tmp->next) {
    GtkTargetPair *pair = tmp->data;
    NspObject *item;
    item = Nsp_BuildValue("(Nii)", (NspObject *) gdkatom_create(NVOID,NULL,pair->target,NULL),
			  pair->flags, pair->info);
    NspList_Append(ret, item);
    Nsp_DECREF(item);
  }
  gtk_target_list_unref(target_list);
  return ret;
  */
  Scierror("XXXX To be done gtk_drag_dest_get_target_list");
  return 0;
}
#line 76891 "gtk.c"


#line 5435 "codegen-3.0/gtk.override"

static int
_wrap_gtk_drag_dest_set_target_list(Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *widget;
  int_types T[] = {obj_check, list, t_end} ;
  NspList *nsp_target_list;
  gint  n_targets;
  GtkTargetEntry *targets;
  GtkTargetList *target_list;

  if (GetArgs(stack,rhs,opt,T, &nsp_type_gtkwidget,&widget, &nsp_target_list) == FAIL) return RET_BUG;;

  if ((targets = nsp_gtk_target_entry_from_list(stack,nsp_target_list, &n_targets))==NULL) return RET_BUG;
  target_list = gtk_target_list_new(targets, n_targets);
  g_free(targets);
  gtk_drag_dest_set_target_list(GTK_WIDGET(widget->obj), target_list);
  gtk_target_list_unref(target_list);
  return 0;
}
#line 76915 "gtk.c"


int _wrap_gtk_drag_dest_add_text_targets(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_dest_add_text_targets */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_drag_dest_add_text_targets(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_drag_dest_add_image_targets(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_dest_add_image_targets */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_drag_dest_add_image_targets(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_drag_dest_add_uri_targets(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_dest_add_uri_targets */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_drag_dest_add_uri_targets(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_drag_dest_set_track_motion(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_dest_set_track_motion */
{
  int_types T[] = {obj_check,s_bool, t_end};
  NspGObject *widget;
  int track_motion;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &track_motion) == FAIL) return RET_BUG;
    gtk_drag_dest_set_track_motion(GTK_WIDGET(widget->obj),track_motion);
  return 0;
}

int _wrap_gtk_drag_dest_get_track_motion(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_dest_get_track_motion */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    ret =gtk_drag_dest_get_track_motion(GTK_WIDGET(widget->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 5457 "codegen-3.0/gtk.override"
static int
_wrap_gtk_drag_source_set(Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *widget;
  int_types T[] = {obj_check,obj,list,obj, t_end} ;
  NspList  *nsp_targets;
  NspObject *nsp_sbmask, *nsp_actions;
  GdkModifierType sbmask;
  GtkTargetEntry *targets;
  GdkDragAction actions;
  gint n_targets;

  if (GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget,&widget,&nsp_sbmask, &nsp_targets, &nsp_actions) == FAIL) return RET_BUG;;

  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,  nsp_sbmask,&sbmask))
    return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_DRAG_ACTION,  nsp_actions, &actions))
    return RET_BUG;

  targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets);
  if ( targets ==NULL && n_targets != 0)
    {
      Scierror("Error: failed to build target entries\n");
      return RET_BUG;
    }
  gtk_drag_source_set(GTK_WIDGET(widget->obj), sbmask, targets, n_targets, actions);
  g_free(targets);
  return 0;
}

#line 76997 "gtk.c"


int _wrap_gtk_drag_source_unset(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_source_unset */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_drag_source_unset(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_drag_source_add_text_targets(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_source_add_text_targets */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_drag_source_add_text_targets(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_drag_source_add_image_targets(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_source_add_image_targets */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_drag_source_add_image_targets(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_drag_source_add_uri_targets(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_source_add_uri_targets */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_drag_source_add_uri_targets(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_drag_source_set_icon_pixbuf(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_source_set_icon_pixbuf */
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *widget, *pixbuf;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_type_gdkpixbuf, &pixbuf) == FAIL) return RET_BUG;
    gtk_drag_source_set_icon_pixbuf(GTK_WIDGET(widget->obj),GDK_PIXBUF(pixbuf->obj));
  return 0;
}

int _wrap_gtk_drag_source_set_icon_name(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_source_set_icon_name */
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *widget;
  char *icon_name;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &icon_name) == FAIL) return RET_BUG;
    gtk_drag_source_set_icon_name(GTK_WIDGET(widget->obj),icon_name);
  return 0;
}

int _wrap_gtk_drag_source_set_icon_gicon(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_source_set_icon_gicon */
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *widget, *icon;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_type_gicon, &icon) == FAIL) return RET_BUG;
    gtk_drag_source_set_icon_gicon(GTK_WIDGET(widget->obj),G_ICON(icon->obj));
  return 0;
}

int _wrap_gtk_drag_set_icon_widget(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_set_icon_widget */
{
  int_types T[] = {obj_check,obj_check,s_int,s_int, t_end};
  NspGObject *context, *widget;
  int hot_x, hot_y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdragcontext, &context, &nsp_type_gtkwidget, &widget, &hot_x, &hot_y) == FAIL) return RET_BUG;
    gtk_drag_set_icon_widget(GDK_DRAG_CONTEXT(context->obj),GTK_WIDGET(widget->obj),hot_x,hot_y);
  return 0;
}

int _wrap_gtk_drag_set_icon_pixbuf(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_set_icon_pixbuf */
{
  int_types T[] = {obj_check,obj_check,s_int,s_int, t_end};
  NspGObject *context, *pixbuf;
  int hot_x, hot_y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdragcontext, &context, &nsp_type_gdkpixbuf, &pixbuf, &hot_x, &hot_y) == FAIL) return RET_BUG;
    gtk_drag_set_icon_pixbuf(GDK_DRAG_CONTEXT(context->obj),GDK_PIXBUF(pixbuf->obj),hot_x,hot_y);
  return 0;
}

int _wrap_gtk_drag_set_icon_surface(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_set_icon_surface */
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *context;
  cairo_surface_t *surface = NULL;
  NspObject *nsp_surface = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdragcontext, &context, &nsp_surface) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_surface, CAIRO_GOBJECT_TYPE_SURFACE))
      surface = nspg_boxed_get(nsp_surface, cairo_surface_t);
  else {
      Scierror( "Error: surface should be a cairo_surface_t\n");
      return RET_BUG;
  }
    gtk_drag_set_icon_surface(GDK_DRAG_CONTEXT(context->obj),surface);
  return 0;
}

int _wrap_gtk_drag_set_icon_name(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_set_icon_name */
{
  int_types T[] = {obj_check,string,s_int,s_int, t_end};
  NspGObject *context;
  char *icon_name;
  int hot_x, hot_y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdragcontext, &context, &icon_name, &hot_x, &hot_y) == FAIL) return RET_BUG;
    gtk_drag_set_icon_name(GDK_DRAG_CONTEXT(context->obj),icon_name,hot_x,hot_y);
  return 0;
}

int _wrap_gtk_drag_set_icon_gicon_redef(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_set_icon_gicon */
{
  int_types T[] = {obj_check,obj_check,s_int,s_int, t_end};
  NspGObject *context, *icon;
  int hot_x, hot_y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdragcontext, &context, &nsp_type_gicon, &icon, &hot_x, &hot_y) == FAIL) return RET_BUG;
    gtk_drag_set_icon_gicon_redef(GDK_DRAG_CONTEXT(context->obj),G_ICON(icon->obj),hot_x,hot_y);
  return 0;
}

int _wrap_gtk_drag_set_icon_default(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_set_icon_default */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *context;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdragcontext, &context) == FAIL) return RET_BUG;
    gtk_drag_set_icon_default(GDK_DRAG_CONTEXT(context->obj));
  return 0;
}

int _wrap_gtk_drag_check_threshold(Stack stack, int rhs, int opt, int lhs) /* gtk_drag_check_threshold */
{
  int_types T[] = {obj_check,s_int,s_int,s_int,s_int, t_end};
  NspGObject *widget;
  int start_x, start_y, current_x, current_y, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &start_x, &start_y, &current_x, &current_y) == FAIL) return RET_BUG;
    ret =gtk_drag_check_threshold(GTK_WIDGET(widget->obj),start_x,start_y,current_x,current_y);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_entry_new_with_buffer(Stack stack, int rhs, int opt, int lhs) /* gtk_entry_new_with_buffer */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *buffer;
  GtkEntry *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkentrybuffer, &buffer) == FAIL) return RET_BUG;
  ret =(GtkEntry*) gtk_entry_new_with_buffer(GTK_ENTRY_BUFFER(buffer->obj));
  nsp_type_gtkentry = new_type_gtkentry(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkentry))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_icon_theme_get_default(Stack stack, int rhs, int opt, int lhs) /* gtk_icon_theme_get_default */
{
  GtkIconTheme *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_icon_theme_get_default();
  nsp_type_gtkicontheme = new_type_gtkicontheme(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkicontheme))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_icon_theme_get_for_screen(Stack stack, int rhs, int opt, int lhs) /* gtk_icon_theme_get_for_screen */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *screen;
  GtkIconTheme *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen) == FAIL) return RET_BUG;
    ret =gtk_icon_theme_get_for_screen(GDK_SCREEN(screen->obj));
  nsp_type_gtkicontheme = new_type_gtkicontheme(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkicontheme))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_get_major_version(Stack stack, int rhs, int opt, int lhs) /* gtk_get_major_version */
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_get_major_version();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_get_minor_version(Stack stack, int rhs, int opt, int lhs) /* gtk_get_minor_version */
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_get_minor_version();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_get_micro_version(Stack stack, int rhs, int opt, int lhs) /* gtk_get_micro_version */
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_get_micro_version();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_get_binary_age(Stack stack, int rhs, int opt, int lhs) /* gtk_get_binary_age */
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_get_binary_age();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_get_interface_age(Stack stack, int rhs, int opt, int lhs) /* gtk_get_interface_age */
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_get_interface_age();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_check_version(Stack stack, int rhs, int opt, int lhs) /* gtk_check_version */
{
  int_types T[] = {s_int,s_int,s_int, t_end};
  int required_major, required_minor, required_micro;
  const gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&required_major, &required_minor, &required_micro) == FAIL) return RET_BUG;
    ret =gtk_check_version(required_major,required_minor,required_micro);
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_disable_setlocale(Stack stack, int rhs, int opt, int lhs) /* gtk_disable_setlocale */
{
  CheckRhs(0,0);
    gtk_disable_setlocale();
  return 0;
}

int _wrap_gtk_get_default_language(Stack stack, int rhs, int opt, int lhs) /* gtk_get_default_language */
{
  PangoLanguage *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_get_default_language();
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,PANGO_TYPE_LANGUAGE, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_pangolanguage))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_events_pending(Stack stack, int rhs, int opt, int lhs) /* gtk_events_pending */
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_events_pending();
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_main_do_event(Stack stack, int rhs, int opt, int lhs) /* gtk_main_do_event */
{
  int_types T[] = {obj, t_end};
  GdkEvent *event = NULL;
  NspObject *nsp_event = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_event) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_event, GDK_TYPE_EVENT))
      event = nspg_boxed_get(nsp_event, GdkEvent);
  else {
      Scierror( "Error: event should be a GdkEvent\n");
      return RET_BUG;
  }
    gtk_main_do_event(event);
  return 0;
}

#line 3803 "codegen-3.0/gtk.override"
static int
_wrap_gtk_main(Stack stack,int rhs,int opt,int lhs)
{
  nspg_unblock_threads();
  gtk_main();
  nspg_block_threads();
  return 0;
}
#line 77292 "gtk.c"


int _wrap_gtk_main_level(Stack stack, int rhs, int opt, int lhs) /* gtk_main_level */
{
  int ret;
  CheckRhs(0,0);
    ret =gtk_main_level();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_main_quit(Stack stack, int rhs, int opt, int lhs) /* gtk_main_quit */
{
  CheckRhs(0,0);
    gtk_main_quit();
  return 0;
}

#line 3813 "codegen-3.0/gtk.override"
static int
_wrap_gtk_main_iteration(Stack stack,int rhs,int opt,int lhs)
{
  int block = 1, ret;
  CheckRhs(0,1) ;
  if ( rhs == 1 ) { if (GetScalarInt(stack,1,&block) == FAIL) return RET_BUG; }
  nspg_unblock_threads();
  ret = gtk_main_iteration_do(block);
  nspg_block_threads();
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}
#line 77324 "gtk.c"


#line 3827 "codegen-3.0/gtk.override"
static int
_wrap_gtk_main_iteration_do(Stack stack,int rhs,int opt,int lhs)
{
  int block = 1, ret;
  CheckRhs(0,1) ;
  if ( rhs == 1 ) { if (GetScalarInt(stack,1,&block) == FAIL) return RET_BUG; }
  nspg_unblock_threads();
  ret = gtk_main_iteration_do(block);
  nspg_block_threads();
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}
#line 77340 "gtk.c"


int _wrap_gtk_grab_add(Stack stack, int rhs, int opt, int lhs) /* gtk_grab_add */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_grab_add(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_grab_get_current(Stack stack, int rhs, int opt, int lhs) /* gtk_grab_get_current */
{
  GtkWidget *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_grab_get_current();
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_grab_remove(Stack stack, int rhs, int opt, int lhs) /* gtk_grab_remove */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_grab_remove(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_device_grab_add(Stack stack, int rhs, int opt, int lhs) /* gtk_device_grab_add */
{
  int_types T[] = {obj_check,obj_check,s_bool, t_end};
  NspGObject *widget, *device;
  int block_others;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_type_gdkdevice, &device, &block_others) == FAIL) return RET_BUG;
    gtk_device_grab_add(GTK_WIDGET(widget->obj),GDK_DEVICE(device->obj),block_others);
  return 0;
}

int _wrap_gtk_device_grab_remove(Stack stack, int rhs, int opt, int lhs) /* gtk_device_grab_remove */
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *widget, *device;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_type_gdkdevice, &device) == FAIL) return RET_BUG;
    gtk_device_grab_remove(GTK_WIDGET(widget->obj),GDK_DEVICE(device->obj));
  return 0;
}

int _wrap_gtk_get_current_event(Stack stack, int rhs, int opt, int lhs) /* gtk_get_current_event */
{
  GdkEvent *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_get_current_event();
  if ((nsp_ret = (NspObject *) gboxed_create(NVOID,GDK_TYPE_EVENT, ret, TRUE, TRUE,
                                             (NspTypeBase *) nsp_type_gdkevent))== NULL)
    return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_get_current_event_time(Stack stack, int rhs, int opt, int lhs) /* gtk_get_current_event_time */
{
  gulong ret;
  CheckRhs(0,0);
    ret =gtk_get_current_event_time();
 if (  nsp_move_double(stack,1,(double) ret) == FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_get_current_event_device(Stack stack, int rhs, int opt, int lhs) /* gtk_get_current_event_device */
{
  GdkDevice *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_get_current_event_device();
  nsp_type_gdkdevice = new_type_gdkdevice(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gdkdevice))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_menu_get_for_attach_widget(Stack stack, int rhs, int opt, int lhs) /* gtk_menu_get_for_attach_widget */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  GList *ret, *tmp;
  NspList *nsp_list;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    ret =gtk_menu_get_for_attach_widget(GTK_WIDGET(widget->obj));
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

int _wrap_gtk_paper_size_get_paper_sizes(Stack stack, int rhs, int opt, int lhs) /* gtk_paper_size_get_paper_sizes */
{
  int_types T[] = {s_bool, t_end};
  int include_custom;
  GList *ret, *tmp;
  NspList *nsp_list;
  if ( GetArgs(stack,rhs,opt,T,&include_custom) == FAIL) return RET_BUG;
    ret =gtk_paper_size_get_paper_sizes(include_custom);
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

int _wrap_gtk_paper_size_get_default(Stack stack, int rhs, int opt, int lhs) /* gtk_paper_size_get_default */
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_paper_size_get_default();
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_recent_manager_get_default(Stack stack, int rhs, int opt, int lhs) /* gtk_recent_manager_get_default */
{
  GtkRecentManager *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_recent_manager_get_default();
  nsp_type_gtkrecentmanager = new_type_gtkrecentmanager(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkrecentmanager))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_render_check(Stack stack, int rhs, int opt, int lhs) /* gtk_render_check */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double x, y, width, height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_check(GTK_STYLE_CONTEXT(context->obj),cr,x,y,width,height);
  return 0;
}

int _wrap_gtk_render_option(Stack stack, int rhs, int opt, int lhs) /* gtk_render_option */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double x, y, width, height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_option(GTK_STYLE_CONTEXT(context->obj),cr,x,y,width,height);
  return 0;
}

int _wrap_gtk_render_arrow(Stack stack, int rhs, int opt, int lhs) /* gtk_render_arrow */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double angle, x, y, size;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &angle, &x, &y, &size) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_arrow(GTK_STYLE_CONTEXT(context->obj),cr,angle,x,y,size);
  return 0;
}

int _wrap_gtk_render_background(Stack stack, int rhs, int opt, int lhs) /* gtk_render_background */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double x, y, width, height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_background(GTK_STYLE_CONTEXT(context->obj),cr,x,y,width,height);
  return 0;
}

int _wrap_gtk_render_frame(Stack stack, int rhs, int opt, int lhs) /* gtk_render_frame */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double x, y, width, height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_frame(GTK_STYLE_CONTEXT(context->obj),cr,x,y,width,height);
  return 0;
}

int _wrap_gtk_render_expander(Stack stack, int rhs, int opt, int lhs) /* gtk_render_expander */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double x, y, width, height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_expander(GTK_STYLE_CONTEXT(context->obj),cr,x,y,width,height);
  return 0;
}

int _wrap_gtk_render_focus(Stack stack, int rhs, int opt, int lhs) /* gtk_render_focus */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double x, y, width, height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_focus(GTK_STYLE_CONTEXT(context->obj),cr,x,y,width,height);
  return 0;
}

int _wrap_gtk_render_layout(Stack stack, int rhs, int opt, int lhs) /* gtk_render_layout */
{
  int_types T[] = {obj_check,obj,s_double,s_double,obj_check, t_end};
  NspGObject *context, *layout;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double x, y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &nsp_type_pangolayout, &layout) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_layout(GTK_STYLE_CONTEXT(context->obj),cr,x,y,PANGO_LAYOUT(layout->obj));
  return 0;
}

int _wrap_gtk_render_line(Stack stack, int rhs, int opt, int lhs) /* gtk_render_line */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double x0, y0, x1, y1;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x0, &y0, &x1, &y1) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_line(GTK_STYLE_CONTEXT(context->obj),cr,x0,y0,x1,y1);
  return 0;
}

int _wrap_gtk_render_slider(Stack stack, int rhs, int opt, int lhs) /* gtk_render_slider */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double,obj, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL, *nsp_orientation = NULL;
  double x, y, width, height;
  GtkOrientation orientation;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &width, &height, &nsp_orientation) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_ORIENTATION, nsp_orientation, &orientation)== FAIL)
      return RET_BUG;
    gtk_render_slider(GTK_STYLE_CONTEXT(context->obj),cr,x,y,width,height,orientation);
  return 0;
}

int _wrap_gtk_render_frame_gap(Stack stack, int rhs, int opt, int lhs) /* gtk_render_frame_gap */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double,obj,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL, *nsp_gap_side = NULL;
  double x, y, width, height, xy0_gap, xy1_gap;
  GtkPositionType gap_side;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &width, &height, &nsp_gap_side, &xy0_gap, &xy1_gap) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_gap_side, &gap_side)== FAIL)
      return RET_BUG;
    gtk_render_frame_gap(GTK_STYLE_CONTEXT(context->obj),cr,x,y,width,height,gap_side,xy0_gap,xy1_gap);
  return 0;
}

int _wrap_gtk_render_extension(Stack stack, int rhs, int opt, int lhs) /* gtk_render_extension */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double,obj, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL, *nsp_gap_side = NULL;
  double x, y, width, height;
  GtkPositionType gap_side;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &width, &height, &nsp_gap_side) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
  if (nspg_enum_get_value(GTK_TYPE_POSITION_TYPE, nsp_gap_side, &gap_side)== FAIL)
      return RET_BUG;
    gtk_render_extension(GTK_STYLE_CONTEXT(context->obj),cr,x,y,width,height,gap_side);
  return 0;
}

int _wrap_gtk_render_handle(Stack stack, int rhs, int opt, int lhs) /* gtk_render_handle */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double x, y, width, height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_handle(GTK_STYLE_CONTEXT(context->obj),cr,x,y,width,height);
  return 0;
}

int _wrap_gtk_render_activity(Stack stack, int rhs, int opt, int lhs) /* gtk_render_activity */
{
  int_types T[] = {obj_check,obj,s_double,s_double,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double x, y, width, height;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &width, &height) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_activity(GTK_STYLE_CONTEXT(context->obj),cr,x,y,width,height);
  return 0;
}

int _wrap_gtk_render_icon(Stack stack, int rhs, int opt, int lhs) /* gtk_render_icon */
{
  int_types T[] = {obj_check,obj,obj_check,s_double,s_double, t_end};
  NspGObject *context, *pixbuf;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  double x, y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &nsp_type_gdkpixbuf, &pixbuf, &x, &y) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_render_icon(GTK_STYLE_CONTEXT(context->obj),cr,GDK_PIXBUF(pixbuf->obj),x,y);
  return 0;
}

int _wrap_gtk_render_icon_surface(Stack stack, int rhs, int opt, int lhs) /* gtk_render_icon_surface */
{
  int_types T[] = {obj_check,obj,obj,s_double,s_double, t_end};
  NspGObject *context;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL, *nsp_surface = NULL;
  cairo_surface_t *surface = NULL;
  double x, y;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &nsp_surface, &x, &y) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_surface, CAIRO_GOBJECT_TYPE_SURFACE))
      surface = nspg_boxed_get(nsp_surface, cairo_surface_t);
  else {
      Scierror( "Error: surface should be a cairo_surface_t\n");
      return RET_BUG;
  }
    gtk_render_icon_surface(GTK_STYLE_CONTEXT(context->obj),cr,surface,x,y);
  return 0;
}

int _wrap_gtk_selection_owner_set(Stack stack, int rhs, int opt, int lhs) /* gtk_selection_owner_set */
{
  int_types T[] = {obj_check,obj,new_opts, t_end};
  nsp_option opts[] = {
	{"time_",s_int,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *widget;
  GdkAtom selection;
  NspObject *nsp_selection = NULL;
  gulong time_ = GDK_CURRENT_TIME;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_selection, opts, &time_) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection,&selection)==FAIL) return RET_BUG;
    ret =gtk_selection_owner_set(GTK_WIDGET(widget->obj),selection,time_);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_selection_owner_set_for_display(Stack stack, int rhs, int opt, int lhs) /* gtk_selection_owner_set_for_display */
{
  int_types T[] = {obj_check,new_opts, t_end};
  nsp_option opts[] = {
	{"widget",obj,NULLOBJ,-1},
	{"selection",obj,NULLOBJ,-1},
	{"time_",s_int,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *display, *nsp_widget = NULL;
  GtkWidget *widget = NULL;
  GdkAtom selection;
  NspObject *nsp_selection = NULL;
  gulong time_ = GDK_CURRENT_TIME;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdisplay, &display, opts, &nsp_widget, &nsp_selection, &time_) == FAIL) return RET_BUG;
  if ( nsp_widget != NULL ) {
    if ( IsGtkWidget((NspObject *)nsp_widget))
      widget = GTK_WIDGET(nsp_widget->obj);
    else if (! IsNone((NspObject *)nsp_widget)) {
         Scierror( "Error: widget should be a GtkWidget or None\n");
         return RET_BUG;
    }
  }
  if ( nsp_gdk_atom_from_object(nsp_selection,&selection)==FAIL) return RET_BUG;
    ret =gtk_selection_owner_set_for_display(GDK_DISPLAY(display->obj),widget,selection,time_);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_selection_add_target(Stack stack, int rhs, int opt, int lhs) /* gtk_selection_add_target */
{
  int_types T[] = {obj_check,obj,obj,s_int, t_end};
  NspGObject *widget;
  GdkAtom selection, target;
  NspObject *nsp_selection = NULL, *nsp_target = NULL;
  int info;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_selection, &nsp_target, &info) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection,&selection)==FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_target,&target)==FAIL) return RET_BUG;
    gtk_selection_add_target(GTK_WIDGET(widget->obj),selection,target,info);
  return 0;
}

#line 5524 "codegen-3.0/gtk.override"
static int
_wrap_gtk_selection_add_targets(Stack stack,int rhs,int opt,int lhs)
{
  NspGObject *widget;
  int_types T[] = {obj_check, obj,list, t_end} ;
  NspObject  *nsp_selection;
  NspList *nsp_targets;
  GtkTargetEntry *targets;
  GdkAtom selection;
  int n_targets;

  if (GetArgs(stack,rhs,opt,T, &nsp_type_gtkwidget, &widget, &nsp_selection, &nsp_targets) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection, &selection)  == FAIL) return RET_BUG;;

  targets = nsp_gtk_target_entry_from_list(stack,nsp_targets, &n_targets);
  if ( targets ==NULL && n_targets != 0)
    {
      Scierror("Error: failed to build target entries\n");
      return RET_BUG;
    }

  gtk_selection_add_targets(GTK_WIDGET(widget->obj), selection,  targets, n_targets);
  g_free(targets);
  return 0;
}
#line 77862 "gtk.c"


int _wrap_gtk_selection_clear_targets(Stack stack, int rhs, int opt, int lhs) /* gtk_selection_clear_targets */
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *widget;
  GdkAtom selection;
  NspObject *nsp_selection = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_selection) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection,&selection)==FAIL) return RET_BUG;
    gtk_selection_clear_targets(GTK_WIDGET(widget->obj),selection);
  return 0;
}

int _wrap_gtk_selection_convert(Stack stack, int rhs, int opt, int lhs) /* gtk_selection_convert */
{
  int_types T[] = {obj_check,obj,obj,new_opts, t_end};
  nsp_option opts[] = {
	{"time_",s_int,NULLOBJ,-1},
	{NULL,t_end,NULLOBJ,-1} };
  NspGObject *widget;
  GdkAtom selection, target;
  NspObject *nsp_selection = NULL, *nsp_target = NULL;
  gulong time_ = GDK_CURRENT_TIME;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &nsp_selection, &nsp_target, opts, &time_) == FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_selection,&selection)==FAIL) return RET_BUG;
  if ( nsp_gdk_atom_from_object(nsp_target,&target)==FAIL) return RET_BUG;
    ret =gtk_selection_convert(GTK_WIDGET(widget->obj),selection,target,time_);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_selection_remove_all(Stack stack, int rhs, int opt, int lhs) /* gtk_selection_remove_all */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_selection_remove_all(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_settings_get_default(Stack stack, int rhs, int opt, int lhs) /* gtk_settings_get_default */
{
  GtkSettings *ret;
  NspObject *nsp_ret;
  CheckRhs(0,0);
    ret =gtk_settings_get_default();
  nsp_type_gtksettings = new_type_gtksettings(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtksettings))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_settings_get_for_screen(Stack stack, int rhs, int opt, int lhs) /* gtk_settings_get_for_screen */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *screen;
  GtkSettings *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen) == FAIL) return RET_BUG;
    ret =gtk_settings_get_for_screen(GDK_SCREEN(screen->obj));
  nsp_type_gtksettings = new_type_gtksettings(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtksettings))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_show_uri(Stack stack, int rhs, int opt, int lhs) /* gtk_show_uri */
{
  int_types T[] = {obj_check,string,s_int, t_end};
  NspGObject *screen;
  char *uri;
  gulong timestamp;
  GError *error = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen, &uri, &timestamp) == FAIL) return RET_BUG;
    ret =gtk_show_uri(GDK_SCREEN(screen->obj),uri,timestamp,&error);
  if ( error != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),error->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_style_context_add_provider_for_screen(Stack stack, int rhs, int opt, int lhs) /* gtk_style_context_add_provider_for_screen */
{
  int_types T[] = {obj_check,obj_check,s_int, t_end};
  NspGObject *screen, *provider;
  int priority;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen, &nsp_type_gtkstyleprovider, &provider, &priority) == FAIL) return RET_BUG;
    gtk_style_context_add_provider_for_screen(GDK_SCREEN(screen->obj),GTK_STYLE_PROVIDER(provider->obj),priority);
  return 0;
}

int _wrap_gtk_style_context_remove_provider_for_screen(Stack stack, int rhs, int opt, int lhs) /* gtk_style_context_remove_provider_for_screen */
{
  int_types T[] = {obj_check,obj_check, t_end};
  NspGObject *screen, *provider;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen, &nsp_type_gtkstyleprovider, &provider) == FAIL) return RET_BUG;
    gtk_style_context_remove_provider_for_screen(GDK_SCREEN(screen->obj),GTK_STYLE_PROVIDER(provider->obj));
  return 0;
}

int _wrap_gtk_style_context_reset_widgets(Stack stack, int rhs, int opt, int lhs) /* gtk_style_context_reset_widgets */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *screen;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkscreen, &screen) == FAIL) return RET_BUG;
    gtk_style_context_reset_widgets(GDK_SCREEN(screen->obj));
  return 0;
}

int _wrap_gtk_render_insertion_cursor(Stack stack, int rhs, int opt, int lhs) /* gtk_render_insertion_cursor */
{
  int_types T[] = {obj_check,obj,s_double,s_double,obj_check,s_int,obj, t_end};
  NspGObject *context, *layout;
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL, *nsp_direction = NULL;
  double x, y;
  int index;
  PangoDirection direction;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkstylecontext, &context, &nsp_cr, &x, &y, &nsp_type_pangolayout, &layout, &index, &nsp_direction) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
  if (nspg_enum_get_value(PANGO_TYPE_DIRECTION, nsp_direction, &direction)== FAIL)
      return RET_BUG;
    gtk_render_insertion_cursor(GTK_STYLE_CONTEXT(context->obj),cr,x,y,PANGO_LAYOUT(layout->obj),index,direction);
  return 0;
}

int _wrap_gtk_test_register_all_types(Stack stack, int rhs, int opt, int lhs) /* gtk_test_register_all_types */
{
  CheckRhs(0,0);
    gtk_test_register_all_types();
  return 0;
}

int _wrap_gtk_test_find_widget(Stack stack, int rhs, int opt, int lhs) /* gtk_test_find_widget */
{
  int_types T[] = {obj_check,string,obj, t_end};
  NspGObject *widget;
  char *label_pattern;
  GType widget_type;
  NspObject *nsp_widget_type = NULL, *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &label_pattern, &nsp_widget_type) == FAIL) return RET_BUG;
  if ((widget_type = nspg_type_from_object(nsp_widget_type)) == FAIL)
      return RET_BUG;
    ret =gtk_test_find_widget(GTK_WIDGET(widget->obj),label_pattern,widget_type);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_test_create_widget(Stack stack, int rhs, int opt, int lhs) /* gtk_test_create_widget */
{
  int_types T[] = {obj,string, t_end};
  GType widget_type;
  NspObject *nsp_widget_type = NULL, *nsp_ret;
  char *first_property_name;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_widget_type, &first_property_name) == FAIL) return RET_BUG;
  if ((widget_type = nspg_type_from_object(nsp_widget_type)) == FAIL)
      return RET_BUG;
    ret =gtk_test_create_widget(widget_type,first_property_name);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_test_create_simple_window(Stack stack, int rhs, int opt, int lhs) /* gtk_test_create_simple_window */
{
  int_types T[] = {string,string, t_end};
  char *window_title, *dialog_text;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&window_title, &dialog_text) == FAIL) return RET_BUG;
    ret =gtk_test_create_simple_window(window_title,dialog_text);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_test_display_button_window(Stack stack, int rhs, int opt, int lhs) /* gtk_test_display_button_window */
{
  int_types T[] = {string,string, t_end};
  char *window_title, *dialog_text;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&window_title, &dialog_text) == FAIL) return RET_BUG;
    ret =gtk_test_display_button_window(window_title,dialog_text);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_test_slider_set_perc(Stack stack, int rhs, int opt, int lhs) /* gtk_test_slider_set_perc */
{
  int_types T[] = {obj_check,s_double, t_end};
  NspGObject *widget;
  double percentage;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &percentage) == FAIL) return RET_BUG;
    gtk_test_slider_set_perc(GTK_WIDGET(widget->obj),percentage);
  return 0;
}

int _wrap_gtk_test_slider_get_value(Stack stack, int rhs, int opt, int lhs) /* gtk_test_slider_get_value */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  double ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    ret =gtk_test_slider_get_value(GTK_WIDGET(widget->obj));
  if ( nsp_move_double(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_test_spin_button_click(Stack stack, int rhs, int opt, int lhs) /* gtk_test_spin_button_click */
{
  int_types T[] = {obj_check,s_int,s_bool, t_end};
  NspGObject *spinner;
  int button, upwards, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkspinbutton, &spinner, &button, &upwards) == FAIL) return RET_BUG;
    ret =gtk_test_spin_button_click(GTK_SPIN_BUTTON(spinner->obj),button,upwards);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_test_widget_wait_for_draw(Stack stack, int rhs, int opt, int lhs) /* gtk_test_widget_wait_for_draw */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    gtk_test_widget_wait_for_draw(GTK_WIDGET(widget->obj));
  return 0;
}

int _wrap_gtk_test_widget_click(Stack stack, int rhs, int opt, int lhs) /* gtk_test_widget_click */
{
  int_types T[] = {obj_check,s_int,obj, t_end};
  NspGObject *widget;
  int button, ret;
  GdkModifierType modifiers;
  NspObject *nsp_modifiers = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &button, &nsp_modifiers) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_modifiers, &modifiers)==FAIL)
      return RET_BUG;
    ret =gtk_test_widget_click(GTK_WIDGET(widget->obj),button,modifiers);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_test_widget_send_key(Stack stack, int rhs, int opt, int lhs) /* gtk_test_widget_send_key */
{
  int_types T[] = {obj_check,s_int,obj, t_end};
  NspGObject *widget;
  int keyval, ret;
  GdkModifierType modifiers;
  NspObject *nsp_modifiers = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &keyval, &nsp_modifiers) == FAIL) return RET_BUG;
  if (nspg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, nsp_modifiers, &modifiers)==FAIL)
      return RET_BUG;
    ret =gtk_test_widget_send_key(GTK_WIDGET(widget->obj),keyval,modifiers);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_test_text_set(Stack stack, int rhs, int opt, int lhs) /* gtk_test_text_set */
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *widget;
  char *string;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &string) == FAIL) return RET_BUG;
    gtk_test_text_set(GTK_WIDGET(widget->obj),string);
  return 0;
}

int _wrap_gtk_test_text_get(Stack stack, int rhs, int opt, int lhs) /* gtk_test_text_get */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *widget;
  gchar *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget) == FAIL) return RET_BUG;
    ret =gtk_test_text_get(GTK_WIDGET(widget->obj));
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  g_free(ret);
  return 1;
}

int _wrap_gtk_test_find_sibling(Stack stack, int rhs, int opt, int lhs) /* gtk_test_find_sibling */
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *base_widget;
  GType widget_type;
  NspObject *nsp_widget_type = NULL, *nsp_ret;
  GtkWidget *ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &base_widget, &nsp_widget_type) == FAIL) return RET_BUG;
  if ((widget_type = nspg_type_from_object(nsp_widget_type)) == FAIL)
      return RET_BUG;
    ret =gtk_test_find_sibling(GTK_WIDGET(base_widget->obj),widget_type);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_test_find_label(Stack stack, int rhs, int opt, int lhs) /* gtk_test_find_label */
{
  int_types T[] = {obj_check,string, t_end};
  NspGObject *widget;
  char *label_pattern;
  GtkWidget *ret;
  NspObject *nsp_ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtkwidget, &widget, &label_pattern) == FAIL) return RET_BUG;
    ret =gtk_test_find_label(GTK_WIDGET(widget->obj),label_pattern);
  nsp_type_gtkwidget = new_type_gtkwidget(T_BASE);
  if ((nsp_ret = (NspObject *) nspgobject_new_with_possible_type(NVOID,(GObject *)ret,(NspTypeBase *) nsp_type_gtkwidget))== NULL) return RET_BUG;
  MoveObj(stack,1,nsp_ret);
  return 1;
}

int _wrap_gtk_tooltip_trigger_tooltip_query(Stack stack, int rhs, int opt, int lhs) /* gtk_tooltip_trigger_tooltip_query */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *display;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkdisplay, &display) == FAIL) return RET_BUG;
    gtk_tooltip_trigger_tooltip_query(GDK_DISPLAY(display->obj));
  return 0;
}

int _wrap_gtk_tree_set_row_drag_data(Stack stack, int rhs, int opt, int lhs) /* gtk_tree_set_row_drag_data */
{
  int_types T[] = {obj,obj_check,obj, t_end};
  GtkSelectionData *selection_data = NULL;
  NspObject *nsp_selection_data = NULL, *nsp_path = NULL;
  NspGObject *tree_model;
  GtkTreePath *path = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_selection_data, &nsp_type_gtktreemodel, &tree_model, &nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_selection_data, GTK_TYPE_SELECTION_DATA))
      selection_data = nspg_boxed_get(nsp_selection_data, GtkSelectionData);
  else {
      Scierror( "Error: selection_data should be a GtkSelectionData\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    ret =gtk_tree_set_row_drag_data(selection_data,GTK_TREE_MODEL(tree_model->obj),path);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

#line 480 "codegen-3.0/gtk.override"

static int
_wrap_gtk_tree_get_row_drag_data(Stack stack,int rhs,int opt,int lhs)
{

  int_types T[] = {obj, t_end};
  GtkSelectionData *selection_data = NULL;
  NspObject *nsp_selection_data;

  GtkTreeModel *tree_model;
  GtkTreePath *path;
  int_types Tr[] = {obj,obj, t_end} ;
  NspObject *nsp_model,*nsp_path;

  if ( GetArgs(stack,rhs,opt,T,&nsp_selection_data) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_selection_data, GTK_TYPE_SELECTION_DATA))
    selection_data = nspg_boxed_get(nsp_selection_data, GtkSelectionData);
  else {
      Scierror( "selection_data should be a GtkSelectionData");
      return RET_BUG;
  }

  if (gtk_tree_get_row_drag_data(selection_data, &tree_model, &path))
    {
      nsp_model = (NspObject *)  nspgobject_new(NVOID,(GObject *)tree_model);
      nsp_path =  (NspObject *)  nsp_gtk_tree_path_to_nspobject(path);
      gtk_tree_path_free(path);
      if ( nsp_model == NULL || nsp_path == NULL) return RET_BUG;
    }
  else
    {
      nsp_model= (NspObject *) nsp_none_create(NVOID,NULL);
      nsp_path= (NspObject *) nsp_none_create(NVOID,NULL);
    }
  return RetArgs(stack,lhs,Tr,nsp_model,nsp_path);
}

#line 78267 "gtk.c"


int _wrap_gtk_tree_row_reference_inserted(Stack stack, int rhs, int opt, int lhs) /* gtk_tree_row_reference_inserted */
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *proxy = NULL;
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gobject, &proxy, &nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_tree_row_reference_inserted(G_OBJECT(proxy->obj),path);
  return 0;
}

int _wrap_gtk_tree_row_reference_deleted(Stack stack, int rhs, int opt, int lhs) /* gtk_tree_row_reference_deleted */
{
  int_types T[] = {obj_check,obj, t_end};
  NspGObject *proxy = NULL;
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gobject, &proxy, &nsp_path) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
    gtk_tree_row_reference_deleted(G_OBJECT(proxy->obj),path);
  return 0;
}

int _wrap_gtk_tree_row_reference_reordered(Stack stack, int rhs, int opt, int lhs) /* gtk_tree_row_reference_reordered */
{
  int_types T[] = {obj_check,obj,obj,s_int, t_end};
  NspGObject *proxy = NULL;
  GtkTreePath *path = NULL;
  NspObject *nsp_path = NULL, *nsp_iter = NULL;
  GtkTreeIter *iter = NULL;
  int new_order;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gobject, &proxy, &nsp_path, &nsp_iter, &new_order) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_path, GTK_TYPE_TREE_PATH))
      path = nspg_boxed_get(nsp_path, GtkTreePath);
  else {
      Scierror( "Error: path should be a GtkTreePath\n");
      return RET_BUG;
  }
  if (nspg_boxed_check(nsp_iter, GTK_TYPE_TREE_ITER))
      iter = nspg_boxed_get(nsp_iter, GtkTreeIter);
  else {
      Scierror( "Error: iter should be a GtkTreeIter\n");
      return RET_BUG;
  }
    gtk_tree_row_reference_reordered(G_OBJECT(proxy->obj),path,iter,&new_order);
  return 0;
}

int _wrap_gtk_widget_set_default_direction(Stack stack, int rhs, int opt, int lhs) /* gtk_widget_set_default_direction */
{
  int_types T[] = {obj, t_end};
  GtkTextDirection dir;
  NspObject *nsp_dir = NULL;
  if ( GetArgs(stack,rhs,opt,T,&nsp_dir) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_TEXT_DIRECTION, nsp_dir, &dir)== FAIL)
      return RET_BUG;
    gtk_widget_set_default_direction(dir);
  return 0;
}

int _wrap_gtk_widget_get_default_direction(Stack stack, int rhs, int opt, int lhs) /* gtk_widget_get_default_direction */
{
  gint ret;
  CheckRhs(0,0);
    ret =gtk_widget_get_default_direction();
  if ( nsp_move_double(stack,1,(double) ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_cairo_should_draw_window(Stack stack, int rhs, int opt, int lhs) /* gtk_cairo_should_draw_window */
{
  int_types T[] = {obj,obj_check, t_end};
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  NspGObject *window;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_cr, &nsp_type_gdkwindow, &window) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    ret =gtk_cairo_should_draw_window(cr,GDK_WINDOW(window->obj));
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_cairo_transform_to_window(Stack stack, int rhs, int opt, int lhs) /* gtk_cairo_transform_to_window */
{
  int_types T[] = {obj,obj_check,obj_check, t_end};
  cairo_t *cr = NULL;
  NspObject *nsp_cr = NULL;
  NspGObject *widget, *window;
  if ( GetArgs(stack,rhs,opt,T,&nsp_cr, &nsp_type_gtkwidget, &widget, &nsp_type_gdkwindow, &window) == FAIL) return RET_BUG;
  if (nspg_boxed_check(nsp_cr, CAIRO_GOBJECT_TYPE_CONTEXT))
      cr = nspg_boxed_get(nsp_cr, cairo_t);
  else {
      Scierror( "Error: cr should be a cairo_t\n");
      return RET_BUG;
  }
    gtk_cairo_transform_to_window(cr,GTK_WIDGET(widget->obj),GDK_WINDOW(window->obj));
  return 0;
}

int _wrap_gtk_window_set_default_icon_list(Stack stack, int rhs, int opt, int lhs) /* gtk_window_set_default_icon_list */
{
  int_types T[] = {list, t_end};
  NspList *nsp_list;
  GList *list;
  if ( GetArgs(stack,rhs,opt,T,&nsp_list) == FAIL) return RET_BUG;
  list=nsp_glist_from_nsplist(stack,nsp_list);
  if (list== NULL) return RET_BUG;
    gtk_window_set_default_icon_list(list);
  return 0;
}

int _wrap_gtk_window_get_default_icon_list(Stack stack, int rhs, int opt, int lhs) /* gtk_window_get_default_icon_list */
{
  GList *ret, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
    ret =gtk_window_get_default_icon_list();
  NSP_LIST_FROM_GLIST(ret,nspgobject_new("lel",(GObject *)tmp->data),g_list_free);

}

int _wrap_gtk_window_set_default_icon(Stack stack, int rhs, int opt, int lhs) /* gtk_window_set_default_icon */
{
  int_types T[] = {obj_check, t_end};
  NspGObject *icon;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gdkpixbuf, &icon) == FAIL) return RET_BUG;
    gtk_window_set_default_icon(GDK_PIXBUF(icon->obj));
  return 0;
}

int _wrap_gtk_window_set_default_icon_name(Stack stack, int rhs, int opt, int lhs) /* gtk_window_set_default_icon_name */
{
  int_types T[] = {string, t_end};
  char *name;
  if ( GetArgs(stack,rhs,opt,T,&name) == FAIL) return RET_BUG;
    gtk_window_set_default_icon_name(name);
  return 0;
}

int _wrap_gtk_window_get_default_icon_name(Stack stack, int rhs, int opt, int lhs) /* gtk_window_get_default_icon_name */
{
  const gchar *ret;
  CheckRhs(0,0);
    ret =gtk_window_get_default_icon_name();
  if ( nsp_move_string(stack,1,(ret) ? ret: "",-1)== FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_window_set_default_icon_from_file(Stack stack, int rhs, int opt, int lhs) /* gtk_window_set_default_icon_from_file */
{
  int_types T[] = {string, t_end};
  char *filename;
  GError *err = NULL;
  int ret;
  if ( GetArgs(stack,rhs,opt,T,&filename) == FAIL) return RET_BUG;
    ret =gtk_window_set_default_icon_from_file(filename,&err);
  if ( err != NULL ) {
    Scierror("%s: gtk error\n%s\n",NspFname(stack),err->message);
    return RET_BUG;
  }
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

int _wrap_gtk_window_set_auto_startup_notification(Stack stack, int rhs, int opt, int lhs) /* gtk_window_set_auto_startup_notification */
{
  int_types T[] = {s_bool, t_end};
  int setting;
  if ( GetArgs(stack,rhs,opt,T,&setting) == FAIL) return RET_BUG;
    gtk_window_set_auto_startup_notification(setting);
  return 0;
}

#line 1276 "codegen-3.0/gtk.override"
static int
_wrap_gtk_window_list_toplevels(Stack stack,int rhs,int opt,int lhs)
{
  GList *list, *tmp;
  NspList *nsp_list;
  CheckRhs(0,0);
  list = gtk_window_list_toplevels();
  NSP_LIST_FROM_GLIST(list, nspgobject_new("lel",G_OBJECT(tmp->data)),g_list_free);
}
#line 78470 "gtk.c"


#line 6904 "codegen-3.0/gtk.override"
static int
_wrap_gtk_icon_size_lookup(Stack stack,int rhs,int opt,int lhs)
{
  /* int rep; */
  int_types T[] = {obj, t_end} ;
  /* static char *kwlist[] = { "icon_size", NULL };*/
  NspObject *nsp_icon_size;
  GtkIconSize icon_size;
  gint width=-1, height=-1;

  if (GetArgs(stack,rhs,opt,T, &nsp_icon_size) == FAIL) return RET_BUG;;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_icon_size,  &icon_size)) return RET_BUG;
  gtk_icon_size_lookup(icon_size, &width, &height);
  if ( nsp_move_doubles(stack,1,1,2,(double) width,(double) height) == FAIL) return RET_BUG;
  return 1;
}
#line 78490 "gtk.c"


int _wrap_gtk_icon_size_lookup_for_settings(Stack stack, int rhs, int opt, int lhs) /* icon_size_lookup_for_settings */
{
  int_types T[] = {obj_check,obj,s_int,s_int, t_end};
  NspGObject *settings;
  GtkIconSize size;
  NspObject *nsp_size = NULL;
  int width, height, ret;
  if ( GetArgs(stack,rhs,opt,T,&nsp_type_gtksettings, &settings, &nsp_size, &width, &height) == FAIL) return RET_BUG;
  if (nspg_enum_get_value(GTK_TYPE_ICON_SIZE, nsp_size, &size)== FAIL)
      return RET_BUG;
    ret =gtk_icon_size_lookup_for_settings(GTK_SETTINGS(settings->obj),size,&width,&height);
  if ( nsp_move_boolean(stack,1,ret)==FAIL) return RET_BUG;
  return 1;
}

/*----------------------------------------------------
 * Interface 
 * i.e a set of function which are accessible at nsp level
 *----------------------------------------------------*/

static OpTab gtk_func[]={
  { "gtk_border_new", _wrap_gtk_border_new},
  { "gtkborder_new", _wrap_gtk_border_new},
  { "gtk_icon_info_new_for_pixbuf", _wrap_gtk_icon_info_new_for_pixbuf},
  { "gtk_requisition_new", _wrap_gtk_requisition_new},
  { "gtkrequisition_new", _wrap_gtk_requisition_new},
  { "gtk_text_attributes_new", _wrap_gtk_text_attributes_new},
  { "gtktextattributes_new", _wrap_gtk_text_attributes_new},
  { "gtk_tree_row_reference_new", _wrap_gtk_tree_row_reference_new},
  { "gtktreerowreference_new", _wrap_gtk_tree_row_reference_new},
  { "gtk_tree_row_reference_new_proxy", _wrap_gtk_tree_row_reference_new_proxy},
  { "gtk_tree_path_new", _wrap_gtk_tree_path_new},
  { "gtktreepath_new", _wrap_gtk_tree_path_new},
  { "gtk_tree_path_new_from_indices", _wrap_gtk_tree_path_new_from_indices},
  { "gtk_application_new", _wrap_gtk_application_new},
  { "gtkapplication_new", _wrap_gtk_application_new},
  { "gtk_application_window_new", _wrap_gtk_application_window_new},
  { "gtkapplicationwindow_new", _wrap_gtk_application_window_new},
  { "gtk_builder_new", _wrap_gtk_builder_new},
  { "gtkbuilder_new", _wrap_gtk_builder_new},
  { "gtk_builder_new_from_file", _wrap_gtk_builder_new_from_file},
  { "gtk_builder_new_from_resource", _wrap_gtk_builder_new_from_resource},
  { "gtk_builder_new_from_string", _wrap_gtk_builder_new_from_string},
  { "gtk_window_new", _wrap_gtk_window_new},
  { "gtkwindow_new", _wrap_gtk_window_new},
  { "gtk_dialog_new", _wrap_gtk_dialog_new},
  { "gtkdialog_new", _wrap_gtk_dialog_new},
  { "gtk_message_dialog_new", _wrap_gtk_message_dialog_new},
  { "gtkmessagedialog_new", _wrap_gtk_message_dialog_new},
  { "gtk_about_dialog_new", _wrap_gtk_about_dialog_new},
  { "gtkaboutdialog_new", _wrap_gtk_about_dialog_new},
  { "gtk_assistant_new", _wrap_gtk_assistant_new},
  { "gtkassistant_new", _wrap_gtk_assistant_new},
  { "gtk_invisible_new", _wrap_gtk_invisible_new},
  { "gtkinvisible_new", _wrap_gtk_invisible_new},
  { "gtk_invisible_new_for_screen", _wrap_gtk_invisible_new_for_screen},
  { "gtk_offscreen_window_new", _wrap_gtk_offscreen_window_new},
  { "gtkoffscreenwindow_new", _wrap_gtk_offscreen_window_new},
  { "gtk_window_group_new", _wrap_gtk_window_group_new},
  { "gtkwindowgroup_new", _wrap_gtk_window_group_new},
  { "gtk_box_new", _wrap_gtk_box_new},
  { "gtkbox_new", _wrap_gtk_box_new},
  { "gtk_grid_new", _wrap_gtk_grid_new},
  { "gtkgrid_new", _wrap_gtk_grid_new},
  { "gtk_revealer_new", _wrap_gtk_revealer_new},
  { "gtkrevealer_new", _wrap_gtk_revealer_new},
  { "gtk_list_box_new", _wrap_gtk_list_box_new},
  { "gtklistbox_new", _wrap_gtk_list_box_new},
  { "gtk_flow_box_new", _wrap_gtk_flow_box_new},
  { "gtkflowbox_new", _wrap_gtk_flow_box_new},
  { "gtk_stack_new", _wrap_gtk_stack_new},
  { "gtkstack_new", _wrap_gtk_stack_new},
  { "gtk_stack_switcher_new", _wrap_gtk_stack_switcher_new},
  { "gtkstackswitcher_new", _wrap_gtk_stack_switcher_new},
  { "gtk_stack_sidebar_new", _wrap_gtk_stack_sidebar_new},
  { "gtkstacksidebar_new", _wrap_gtk_stack_sidebar_new},
  { "gtk_action_bar_new", _wrap_gtk_action_bar_new},
  { "gtkactionbar_new", _wrap_gtk_action_bar_new},
  { "gtk_header_bar_new", _wrap_gtk_header_bar_new},
  { "gtkheaderbar_new", _wrap_gtk_header_bar_new},
  { "gtk_overlay_new", _wrap_gtk_overlay_new},
  { "gtkoverlay_new", _wrap_gtk_overlay_new},
  { "gtk_button_box_new", _wrap_gtk_button_box_new},
  { "gtkbuttonbox_new", _wrap_gtk_button_box_new},
  { "gtk_paned_new", _wrap_gtk_paned_new},
  { "gtkpaned_new", _wrap_gtk_paned_new},
  { "gtk_layout_new", _wrap_gtk_layout_new},
  { "gtklayout_new", _wrap_gtk_layout_new},
  { "gtk_notebook_new", _wrap_gtk_notebook_new},
  { "gtknotebook_new", _wrap_gtk_notebook_new},
  { "gtk_expander_new", _wrap_gtk_expander_new},
  { "gtkexpander_new", _wrap_gtk_expander_new},
  { "gtk_expander_new_with_mnemonic", _wrap_gtk_expander_new_with_mnemonic},
  { "gtk_aspect_frame_new", _wrap_gtk_aspect_frame_new},
  { "gtkaspectframe_new", _wrap_gtk_aspect_frame_new},
  { "gtk_fixed_new", _wrap_gtk_fixed_new},
  { "gtkfixed_new", _wrap_gtk_fixed_new},
  { "gtk_label_new", _wrap_gtk_label_new},
  { "gtklabel_new", _wrap_gtk_label_new},
  { "gtk_image_new", _wrap_gtk_image_new},
  { "gtkimage_new", _wrap_gtk_image_new},
  { "gtk_image_new_from_file", _wrap_gtk_image_new_from_file},
  { "gtk_image_new_from_resource", _wrap_gtk_image_new_from_resource},
  { "gtk_image_new_from_pixbuf", _wrap_gtk_image_new_from_pixbuf},
  { "gtk_image_new_from_animation", _wrap_gtk_image_new_from_animation},
  { "gtk_image_new_from_icon_name", _wrap_gtk_image_new_from_icon_name},
  { "gtk_image_new_from_gicon", _wrap_gtk_image_new_from_gicon},
  { "gtk_image_new_from_surface", _wrap_gtk_image_new_from_surface},
  { "gtk_spinner_new", _wrap_gtk_spinner_new},
  { "gtkspinner_new", _wrap_gtk_spinner_new},
  { "gtk_info_bar_new", _wrap_gtk_info_bar_new},
  { "gtkinfobar_new", _wrap_gtk_info_bar_new},
  { "gtk_info_bar_new_with_buttons", _wrap_gtk_info_bar_new_with_buttons},
  { "gtk_progress_bar_new", _wrap_gtk_progress_bar_new},
  { "gtkprogressbar_new", _wrap_gtk_progress_bar_new},
  { "gtk_level_bar_new", _wrap_gtk_level_bar_new},
  { "gtklevelbar_new", _wrap_gtk_level_bar_new},
  { "gtk_level_bar_new_for_interval", _wrap_gtk_level_bar_new_for_interval},
  { "gtk_statusbar_new", _wrap_gtk_statusbar_new},
  { "gtkstatusbar_new", _wrap_gtk_statusbar_new},
  { "gtk_accel_label_new", _wrap_gtk_accel_label_new},
  { "gtkaccellabel_new", _wrap_gtk_accel_label_new},
  { "gtk_button_new", _wrap_gtk_button_new},
  { "gtkbutton_new", _wrap_gtk_button_new},
  { "gtk_button_new_from_icon_name", _wrap_gtk_button_new_from_icon_name},
  { "gtk_check_button_new", _wrap_gtk_check_button_new},
  { "gtkcheckbutton_new", _wrap_gtk_check_button_new},
  { "gtk_radio_button_new", _wrap_gtk_radio_button_new},
  { "gtkradiobutton_new", _wrap_gtk_radio_button_new},
  { "gtk_toggle_button_new", _wrap_gtk_toggle_button_new},
  { "gtktogglebutton_new", _wrap_gtk_toggle_button_new},
  { "gtk_link_button_new", _wrap_gtk_link_button_new},
  { "gtklinkbutton_new", _wrap_gtk_link_button_new},
  { "gtk_link_button_new_with_label", _wrap_gtk_link_button_new_with_label},
  { "gtk_menu_button_new", _wrap_gtk_menu_button_new},
  { "gtkmenubutton_new", _wrap_gtk_menu_button_new},
  { "gtk_switch_new", _wrap_gtk_switch_new},
  { "gtkswitch_new", _wrap_gtk_switch_new},
  { "gtk_scale_button_new", _wrap_gtk_scale_button_new},
  { "gtkscalebutton_new", _wrap_gtk_scale_button_new},
  { "gtk_volume_button_new", _wrap_gtk_volume_button_new},
  { "gtkvolumebutton_new", _wrap_gtk_volume_button_new},
  { "gtk_lock_button_new", _wrap_gtk_lock_button_new},
  { "gtklockbutton_new", _wrap_gtk_lock_button_new},
  { "gtk_model_button_new", _wrap_gtk_model_button_new},
  { "gtkmodelbutton_new", _wrap_gtk_model_button_new},
  { "gtk_entry_new", _wrap_gtk_entry_new},
  { "gtkentry_new", _wrap_gtk_entry_new},
  { "gtk_entry_buffer_new", _wrap_gtk_entry_buffer_new},
  { "gtkentrybuffer_new", _wrap_gtk_entry_buffer_new},
  { "gtk_entry_completion_new", _wrap_gtk_entry_completion_new},
  { "gtkentrycompletion_new", _wrap_gtk_entry_completion_new},
  { "gtk_entry_completion_new_with_area", _wrap_gtk_entry_completion_new_with_area},
  { "gtk_scale_new", _wrap_gtk_scale_new},
  { "gtkscale_new", _wrap_gtk_scale_new},
  { "gtk_scale_new_with_range", _wrap_gtk_scale_new_with_range},
  { "gtk_spin_button_new", _wrap_gtk_spin_button_new},
  { "gtkspinbutton_new", _wrap_gtk_spin_button_new},
  { "gtk_spin_button_new_with_range", _wrap_gtk_spin_button_new_with_range},
  { "gtk_search_entry_new", _wrap_gtk_search_entry_new},
  { "gtksearchentry_new", _wrap_gtk_search_entry_new},
  { "gtk_search_bar_new", _wrap_gtk_search_bar_new},
  { "gtksearchbar_new", _wrap_gtk_search_bar_new},
  { "gtk_text_mark_new", _wrap_gtk_text_mark_new},
  { "gtktextmark_new", _wrap_gtk_text_mark_new},
  { "gtk_text_buffer_new", _wrap_gtk_text_buffer_new},
  { "gtktextbuffer_new", _wrap_gtk_text_buffer_new},
  { "gtk_text_tag_new", _wrap_gtk_text_tag_new},
  { "gtktexttag_new", _wrap_gtk_text_tag_new},
  { "gtk_text_tag_table_new", _wrap_gtk_text_tag_table_new},
  { "gtktexttagtable_new", _wrap_gtk_text_tag_table_new},
  { "gtk_text_view_new", _wrap_gtk_text_view_new},
  { "gtktextview_new", _wrap_gtk_text_view_new},
  { "gtk_text_view_new_with_buffer", _wrap_gtk_text_view_new_with_buffer},
  { "gtk_text_child_anchor_new", _wrap_gtk_text_child_anchor_new},
  { "gtktextchildanchor_new", _wrap_gtk_text_child_anchor_new},
  { "gtk_tree_view_column_new", _wrap_gtk_tree_view_column_new},
  { "gtktreeviewcolumn_new", _wrap_gtk_tree_view_column_new},
  { "gtk_tree_view_column_new_with_area", _wrap_gtk_tree_view_column_new_with_area},
  { "gtk_tree_view_new", _wrap_gtk_tree_view_new},
  { "gtktreeview_new", _wrap_gtk_tree_view_new},
  { "gtk_tree_view_new_with_model", _wrap_gtk_tree_view_new_with_model},
  { "gtk_cell_view_new", _wrap_gtk_cell_view_new},
  { "gtkcellview_new", _wrap_gtk_cell_view_new},
  { "gtk_cell_view_new_with_context", _wrap_gtk_cell_view_new_with_context},
  { "gtk_icon_view_new", _wrap_gtk_icon_view_new},
  { "gtkiconview_new", _wrap_gtk_icon_view_new},
  { "gtk_icon_view_new_with_area", _wrap_gtk_icon_view_new_with_area},
  { "gtk_icon_view_new_with_model", _wrap_gtk_icon_view_new_with_model},
  { "gtk_tree_model_sort_new_with_model", _wrap_gtk_tree_model_sort_new_with_model},
  { "gtk_tree_model_filter_new", _wrap_gtk_tree_model_filter_new},
  { "gtktreemodelfilter_new", _wrap_gtk_tree_model_filter_new},
  { "gtk_cell_area_box_new", _wrap_gtk_cell_area_box_new},
  { "gtkcellareabox_new", _wrap_gtk_cell_area_box_new},
  { "gtk_cell_renderer_accel_new", _wrap_gtk_cell_renderer_accel_new},
  { "gtkcellrendereraccel_new", _wrap_gtk_cell_renderer_accel_new},
  { "gtk_cell_renderer_combo_new", _wrap_gtk_cell_renderer_combo_new},
  { "gtkcellrenderercombo_new", _wrap_gtk_cell_renderer_combo_new},
  { "gtk_cell_renderer_pixbuf_new", _wrap_gtk_cell_renderer_pixbuf_new},
  { "gtkcellrendererpixbuf_new", _wrap_gtk_cell_renderer_pixbuf_new},
  { "gtk_cell_renderer_progress_new", _wrap_gtk_cell_renderer_progress_new},
  { "gtkcellrendererprogress_new", _wrap_gtk_cell_renderer_progress_new},
  { "gtk_cell_renderer_spin_new", _wrap_gtk_cell_renderer_spin_new},
  { "gtkcellrendererspin_new", _wrap_gtk_cell_renderer_spin_new},
  { "gtk_cell_renderer_text_new", _wrap_gtk_cell_renderer_text_new},
  { "gtkcellrenderertext_new", _wrap_gtk_cell_renderer_text_new},
  { "gtk_cell_renderer_toggle_new", _wrap_gtk_cell_renderer_toggle_new},
  { "gtkcellrenderertoggle_new", _wrap_gtk_cell_renderer_toggle_new},
  { "gtk_cell_renderer_spinner_new", _wrap_gtk_cell_renderer_spinner_new},
  { "gtkcellrendererspinner_new", _wrap_gtk_cell_renderer_spinner_new},
  { "gtk_list_store_new", _wrap_gtk_list_store_new},
  { "gtkliststore_new", _wrap_gtk_list_store_new},
  { "gtk_tree_store_new", _wrap_gtk_tree_store_new},
  { "gtktreestore_new", _wrap_gtk_tree_store_new},
  { "gtk_combo_box_new", _wrap_gtk_combo_box_new},
  { "gtkcombobox_new", _wrap_gtk_combo_box_new},
  { "gtk_combo_box_new_with_entry", _wrap_gtk_combo_box_new_with_entry},
  { "gtk_combo_box_text_new", _wrap_gtk_combo_box_text_new},
  { "gtkcomboboxtext_new", _wrap_gtk_combo_box_text_new},
  { "gtk_combo_box_text_new_with_entry", _wrap_gtk_combo_box_text_new_with_entry},
  { "gtk_menu_new", _wrap_gtk_menu_new},
  { "gtkmenu_new", _wrap_gtk_menu_new},
  { "gtk_menu_new_from_model", _wrap_gtk_menu_new_from_model},
  { "gtk_menu_bar_new", _wrap_gtk_menu_bar_new},
  { "gtkmenubar_new", _wrap_gtk_menu_bar_new},
  { "gtk_menu_bar_new_from_model", _wrap_gtk_menu_bar_new_from_model},
  { "gtk_menu_item_new", _wrap_gtk_menu_item_new},
  { "gtkmenuitem_new", _wrap_gtk_menu_item_new},
  { "gtk_radio_menu_item_new", _wrap_gtk_radio_menu_item_new},
  { "gtkradiomenuitem_new", _wrap_gtk_radio_menu_item_new},
  { "gtk_radio_menu_item_new_from_widget", _wrap_gtk_radio_menu_item_new_from_widget},
  { "gtk_radio_menu_item_new_with_mnemonic_from_widget", _wrap_gtk_radio_menu_item_new_with_mnemonic_from_widget},
  { "gtk_radio_menu_item_new_with_label_from_widget", _wrap_gtk_radio_menu_item_new_with_label_from_widget},
  { "gtk_check_menu_item_new", _wrap_gtk_check_menu_item_new},
  { "gtkcheckmenuitem_new", _wrap_gtk_check_menu_item_new},
  { "gtk_separator_menu_item_new", _wrap_gtk_separator_menu_item_new},
  { "gtkseparatormenuitem_new", _wrap_gtk_separator_menu_item_new},
  { "gtk_toolbar_new", _wrap_gtk_toolbar_new},
  { "gtktoolbar_new", _wrap_gtk_toolbar_new},
  { "gtk_tool_item_new", _wrap_gtk_tool_item_new},
  { "gtktoolitem_new", _wrap_gtk_tool_item_new},
  { "gtk_tool_palette_new", _wrap_gtk_tool_palette_new},
  { "gtktoolpalette_new", _wrap_gtk_tool_palette_new},
  { "gtk_tool_item_group_new", _wrap_gtk_tool_item_group_new},
  { "gtktoolitemgroup_new", _wrap_gtk_tool_item_group_new},
  { "gtk_separator_tool_item_new", _wrap_gtk_separator_tool_item_new},
  { "gtkseparatortoolitem_new", _wrap_gtk_separator_tool_item_new},
  { "gtk_tool_button_new", _wrap_gtk_tool_button_new},
  { "gtktoolbutton_new", _wrap_gtk_tool_button_new},
  { "gtk_menu_tool_button_new", _wrap_gtk_menu_tool_button_new},
  { "gtkmenutoolbutton_new", _wrap_gtk_menu_tool_button_new},
  { "gtk_toggle_tool_button_new", _wrap_gtk_toggle_tool_button_new},
  { "gtktoggletoolbutton_new", _wrap_gtk_toggle_tool_button_new},
  { "gtk_radio_tool_button_new", _wrap_gtk_radio_tool_button_new},
  { "gtkradiotoolbutton_new", _wrap_gtk_radio_tool_button_new},
  { "gtk_radio_tool_button_new_from_widget", _wrap_gtk_radio_tool_button_new_from_widget},
  { "gtk_popover_new", _wrap_gtk_popover_new},
  { "gtkpopover_new", _wrap_gtk_popover_new},
  { "gtk_popover_new_from_model", _wrap_gtk_popover_new_from_model},
  { "gtk_popover_menu_new", _wrap_gtk_popover_menu_new},
  { "gtkpopovermenu_new", _wrap_gtk_popover_menu_new},
  { "gtk_color_button_new", _wrap_gtk_color_button_new},
  { "gtkcolorbutton_new", _wrap_gtk_color_button_new},
  { "gtk_color_button_new_with_rgba", _wrap_gtk_color_button_new_with_rgba},
  { "gtk_color_chooser_widget_new", _wrap_gtk_color_chooser_widget_new},
  { "gtkcolorchooserwidget_new", _wrap_gtk_color_chooser_widget_new},
  { "gtk_color_chooser_dialog_new", _wrap_gtk_color_chooser_dialog_new},
  { "gtkcolorchooserdialog_new", _wrap_gtk_color_chooser_dialog_new},
  { "gtk_file_chooser_button_new", _wrap_gtk_file_chooser_button_new},
  { "gtkfilechooserbutton_new", _wrap_gtk_file_chooser_button_new},
  { "gtk_file_chooser_button_new_with_dialog", _wrap_gtk_file_chooser_button_new_with_dialog},
  { "gtk_file_chooser_dialog_new", _wrap_gtk_file_chooser_dialog_new},
  { "gtkfilechooserdialog_new", _wrap_gtk_file_chooser_dialog_new},
  { "gtk_file_chooser_widget_new", _wrap_gtk_file_chooser_widget_new},
  { "gtkfilechooserwidget_new", _wrap_gtk_file_chooser_widget_new},
  { "gtk_file_filter_new", _wrap_gtk_file_filter_new},
  { "gtkfilefilter_new", _wrap_gtk_file_filter_new},
  { "gtk_font_button_new", _wrap_gtk_font_button_new},
  { "gtkfontbutton_new", _wrap_gtk_font_button_new},
  { "gtk_font_button_new_with_font", _wrap_gtk_font_button_new_with_font},
  { "gtk_font_chooser_widget_new", _wrap_gtk_font_chooser_widget_new},
  { "gtkfontchooserwidget_new", _wrap_gtk_font_chooser_widget_new},
  { "gtk_font_chooser_dialog_new", _wrap_gtk_font_chooser_dialog_new},
  { "gtkfontchooserdialog_new", _wrap_gtk_font_chooser_dialog_new},
  { "gtk_places_sidebar_new", _wrap_gtk_places_sidebar_new},
  { "gtkplacessidebar_new", _wrap_gtk_places_sidebar_new},
  { "gtk_frame_new", _wrap_gtk_frame_new},
  { "gtkframe_new", _wrap_gtk_frame_new},
  { "gtk_separator_new", _wrap_gtk_separator_new},
  { "gtkseparator_new", _wrap_gtk_separator_new},
  { "gtk_scrollbar_new", _wrap_gtk_scrollbar_new},
  { "gtkscrollbar_new", _wrap_gtk_scrollbar_new},
  { "gtk_scrolled_window_new", _wrap_gtk_scrolled_window_new},
  { "gtkscrolledwindow_new", _wrap_gtk_scrolled_window_new},
  { "gtk_print_operation_new", _wrap_gtk_print_operation_new},
  { "gtkprintoperation_new", _wrap_gtk_print_operation_new},
  { "gtk_adjustment_new", _wrap_gtk_adjustment_new},
  { "gtkadjustment_new", _wrap_gtk_adjustment_new},
  { "gtk_calendar_new", _wrap_gtk_calendar_new},
  { "gtkcalendar_new", _wrap_gtk_calendar_new},
  { "gtk_drawing_area_new", _wrap_gtk_drawing_area_new},
  { "gtkdrawingarea_new", _wrap_gtk_drawing_area_new},
  { "gtk_event_box_new", _wrap_gtk_event_box_new},
  { "gtkeventbox_new", _wrap_gtk_event_box_new},
  { "gtk_size_group_new", _wrap_gtk_size_group_new},
  { "gtksizegroup_new", _wrap_gtk_size_group_new},
  { "gtk_viewport_new", _wrap_gtk_viewport_new},
  { "gtkviewport_new", _wrap_gtk_viewport_new},
  { "gtk_widget_new", _wrap_gtk_widget_new},
  { "gtkwidget_new", _wrap_gtk_widget_new},
  { "gtk_recent_manager_new", _wrap_gtk_recent_manager_new},
  { "gtkrecentmanager_new", _wrap_gtk_recent_manager_new},
  { "gtk_recent_chooser_dialog_new", _wrap_gtk_recent_chooser_dialog_new},
  { "gtkrecentchooserdialog_new", _wrap_gtk_recent_chooser_dialog_new},
  { "gtk_recent_chooser_dialog_new_for_manager", _wrap_gtk_recent_chooser_dialog_new_for_manager},
  { "gtk_recent_chooser_widget_new", _wrap_gtk_recent_chooser_widget_new},
  { "gtkrecentchooserwidget_new", _wrap_gtk_recent_chooser_widget_new},
  { "gtk_recent_chooser_widget_new_for_manager", _wrap_gtk_recent_chooser_widget_new_for_manager},
  { "gtk_recent_filter_new", _wrap_gtk_recent_filter_new},
  { "gtkrecentfilter_new", _wrap_gtk_recent_filter_new},
  { "gtk_app_chooser_button_new", _wrap_gtk_app_chooser_button_new},
  { "gtkappchooserbutton_new", _wrap_gtk_app_chooser_button_new},
  { "gtk_app_chooser_dialog_new", _wrap_gtk_app_chooser_dialog_new},
  { "gtkappchooserdialog_new", _wrap_gtk_app_chooser_dialog_new},
  { "gtk_app_chooser_dialog_new_for_content_type", _wrap_gtk_app_chooser_dialog_new_for_content_type},
  { "gtk_app_chooser_widget_new", _wrap_gtk_app_chooser_widget_new},
  { "gtkappchooserwidget_new", _wrap_gtk_app_chooser_widget_new},
  { "gtk_style_context_new", _wrap_gtk_style_context_new},
  { "gtkstylecontext_new", _wrap_gtk_style_context_new},
  { "gtk_ui_manager_new", _wrap_gtk_ui_manager_new},
  { "gtkuimanager_new", _wrap_gtk_ui_manager_new},
  { "gtk_action_group_new", _wrap_gtk_action_group_new},
  { "gtkactiongroup_new", _wrap_gtk_action_group_new},
  { "gtk_action_new", _wrap_gtk_action_new},
  { "gtkaction_new", _wrap_gtk_action_new},
  { "gtk_image_menu_item_new", _wrap_gtk_image_menu_item_new},
  { "gtkimagemenuitem_new", _wrap_gtk_image_menu_item_new},
  { "gtk_icon_theme_new", _wrap_gtk_icon_theme_new},
  { "gtkicontheme_new", _wrap_gtk_icon_theme_new},
  { "gtk_accel_group_new", _wrap_gtk_accel_group_new},
  { "gtkaccelgroup_new", _wrap_gtk_accel_group_new},
  { "gtk_css_provider_new", _wrap_gtk_css_provider_new},
  { "gtkcssprovider_new", _wrap_gtk_css_provider_new},
  { "nsp_graphic_new", _wrap_nsp_graphic_new},
  { "gtk_accelerator_valid", _wrap_gtk_accelerator_valid},
  { "gtk_accelerator_name", _wrap_gtk_accelerator_name},
  { "gtk_accelerator_name_with_keycode", _wrap_gtk_accelerator_name_with_keycode},
  { "gtk_accelerator_get_label", _wrap_gtk_accelerator_get_label},
  { "gtk_accelerator_get_label_with_keycode", _wrap_gtk_accelerator_get_label_with_keycode},
  { "gtk_accelerator_set_default_mod_mask", _wrap_gtk_accelerator_set_default_mod_mask},
  { "gtk_accelerator_get_default_mod_mask", _wrap_gtk_accelerator_get_default_mod_mask},
  { "gtk_accel_map_add_entry", _wrap_gtk_accel_map_add_entry},
  { "gtk_accel_map_change_entry", _wrap_gtk_accel_map_change_entry},
  { "gtk_accel_map_load", _wrap_gtk_accel_map_load},
  { "gtk_accel_map_save", _wrap_gtk_accel_map_save},
  { "gtk_accel_map_load_fd", _wrap_gtk_accel_map_load_fd},
  { "gtk_accel_map_save_fd", _wrap_gtk_accel_map_save_fd},
  { "gtk_accel_map_lock_path", _wrap_gtk_accel_map_lock_path},
  { "gtk_accel_map_unlock_path", _wrap_gtk_accel_map_unlock_path},
  { "gtk_accel_map_add_filter", _wrap_gtk_accel_map_add_filter},
  { "gtk_bindings_activate", _wrap_gtk_bindings_activate},
  { "gtk_bindings_activate_event", _wrap_gtk_bindings_activate_event},
  { "gtk_binding_entry_add_signal", _wrap_gtk_binding_entry_add_signal},
  { "gtk_clipboard_get", _wrap_gtk_clipboard_get},
  { "gtk_clipboard_get_default", _wrap_gtk_clipboard_get_default},
  { "gtk_hsv_to_rgb", _wrap_gtk_hsv_to_rgb},
  { "gtk_rgb_to_hsv", _wrap_gtk_rgb_to_hsv},
  { "gtk_css_provider_get_default", _wrap_gtk_css_provider_get_default},
  { "gtk_css_provider_get_named", _wrap_gtk_css_provider_get_named},
  { "gtk_get_debug_flags", _wrap_gtk_get_debug_flags},
  { "gtk_set_debug_flags", _wrap_gtk_set_debug_flags},
  { "gtk_alternative_dialog_button_order", _wrap_gtk_alternative_dialog_button_order},
  { "gtk_drag_get_data", _wrap_gtk_drag_get_data},
  { "gtk_drag_finish", _wrap_gtk_drag_finish},
  { "gtk_drag_get_source_widget", _wrap_gtk_drag_get_source_widget},
  { "gtk_drag_highlight", _wrap_gtk_drag_highlight},
  { "gtk_drag_unhighlight", _wrap_gtk_drag_unhighlight},
  { "gtk_drag_dest_set", _wrap_gtk_drag_dest_set},
  { "gtk_drag_dest_set_proxy", _wrap_gtk_drag_dest_set_proxy},
  { "gtk_drag_dest_unset", _wrap_gtk_drag_dest_unset},
  { "gtk_drag_dest_find_target", _wrap_gtk_drag_dest_find_target},
  { "gtk_drag_dest_get_target_list", _wrap_gtk_drag_dest_get_target_list},
  { "gtk_drag_dest_set_target_list", _wrap_gtk_drag_dest_set_target_list},
  { "gtk_drag_dest_add_text_targets", _wrap_gtk_drag_dest_add_text_targets},
  { "gtk_drag_dest_add_image_targets", _wrap_gtk_drag_dest_add_image_targets},
  { "gtk_drag_dest_add_uri_targets", _wrap_gtk_drag_dest_add_uri_targets},
  { "gtk_drag_dest_set_track_motion", _wrap_gtk_drag_dest_set_track_motion},
  { "gtk_drag_dest_get_track_motion", _wrap_gtk_drag_dest_get_track_motion},
  { "gtk_drag_source_set", _wrap_gtk_drag_source_set},
  { "gtk_drag_source_unset", _wrap_gtk_drag_source_unset},
  { "gtk_drag_source_add_text_targets", _wrap_gtk_drag_source_add_text_targets},
  { "gtk_drag_source_add_image_targets", _wrap_gtk_drag_source_add_image_targets},
  { "gtk_drag_source_add_uri_targets", _wrap_gtk_drag_source_add_uri_targets},
  { "gtk_drag_source_set_icon_pixbuf", _wrap_gtk_drag_source_set_icon_pixbuf},
  { "gtk_drag_source_set_icon_name", _wrap_gtk_drag_source_set_icon_name},
  { "gtk_drag_source_set_icon_gicon", _wrap_gtk_drag_source_set_icon_gicon},
  { "gtk_drag_set_icon_widget", _wrap_gtk_drag_set_icon_widget},
  { "gtk_drag_set_icon_pixbuf", _wrap_gtk_drag_set_icon_pixbuf},
  { "gtk_drag_set_icon_surface", _wrap_gtk_drag_set_icon_surface},
  { "gtk_drag_set_icon_name", _wrap_gtk_drag_set_icon_name},
  { "gtk_drag_set_icon_gicon_redef", _wrap_gtk_drag_set_icon_gicon_redef},
  { "gtk_drag_set_icon_default", _wrap_gtk_drag_set_icon_default},
  { "gtk_drag_check_threshold", _wrap_gtk_drag_check_threshold},
  { "gtk_entry_new_with_buffer", _wrap_gtk_entry_new_with_buffer},
  { "gtk_icon_theme_get_default", _wrap_gtk_icon_theme_get_default},
  { "gtk_icon_theme_get_for_screen", _wrap_gtk_icon_theme_get_for_screen},
  { "gtk_get_major_version", _wrap_gtk_get_major_version},
  { "gtk_get_minor_version", _wrap_gtk_get_minor_version},
  { "gtk_get_micro_version", _wrap_gtk_get_micro_version},
  { "gtk_get_binary_age", _wrap_gtk_get_binary_age},
  { "gtk_get_interface_age", _wrap_gtk_get_interface_age},
  { "gtk_check_version", _wrap_gtk_check_version},
  { "gtk_disable_setlocale", _wrap_gtk_disable_setlocale},
  { "gtk_get_default_language", _wrap_gtk_get_default_language},
  { "gtk_events_pending", _wrap_gtk_events_pending},
  { "gtk_main_do_event", _wrap_gtk_main_do_event},
  { "gtk_main", _wrap_gtk_main},
  { "gtk_main_level", _wrap_gtk_main_level},
  { "gtk_main_quit", _wrap_gtk_main_quit},
  { "gtk_main_iteration", _wrap_gtk_main_iteration},
  { "gtk_main_iteration_do", _wrap_gtk_main_iteration_do},
  { "gtk_grab_add", _wrap_gtk_grab_add},
  { "gtk_grab_get_current", _wrap_gtk_grab_get_current},
  { "gtk_grab_remove", _wrap_gtk_grab_remove},
  { "gtk_device_grab_add", _wrap_gtk_device_grab_add},
  { "gtk_device_grab_remove", _wrap_gtk_device_grab_remove},
  { "gtk_get_current_event", _wrap_gtk_get_current_event},
  { "gtk_get_current_event_time", _wrap_gtk_get_current_event_time},
  { "gtk_get_current_event_device", _wrap_gtk_get_current_event_device},
  { "gtk_menu_get_for_attach_widget", _wrap_gtk_menu_get_for_attach_widget},
  { "gtk_paper_size_get_paper_sizes", _wrap_gtk_paper_size_get_paper_sizes},
  { "gtk_paper_size_get_default", _wrap_gtk_paper_size_get_default},
  { "gtk_recent_manager_get_default", _wrap_gtk_recent_manager_get_default},
  { "gtk_render_check", _wrap_gtk_render_check},
  { "gtk_render_option", _wrap_gtk_render_option},
  { "gtk_render_arrow", _wrap_gtk_render_arrow},
  { "gtk_render_background", _wrap_gtk_render_background},
  { "gtk_render_frame", _wrap_gtk_render_frame},
  { "gtk_render_expander", _wrap_gtk_render_expander},
  { "gtk_render_focus", _wrap_gtk_render_focus},
  { "gtk_render_layout", _wrap_gtk_render_layout},
  { "gtk_render_line", _wrap_gtk_render_line},
  { "gtk_render_slider", _wrap_gtk_render_slider},
  { "gtk_render_frame_gap", _wrap_gtk_render_frame_gap},
  { "gtk_render_extension", _wrap_gtk_render_extension},
  { "gtk_render_handle", _wrap_gtk_render_handle},
  { "gtk_render_activity", _wrap_gtk_render_activity},
  { "gtk_render_icon", _wrap_gtk_render_icon},
  { "gtk_render_icon_surface", _wrap_gtk_render_icon_surface},
  { "gtk_selection_owner_set", _wrap_gtk_selection_owner_set},
  { "gtk_selection_owner_set_for_display", _wrap_gtk_selection_owner_set_for_display},
  { "gtk_selection_add_target", _wrap_gtk_selection_add_target},
  { "gtk_selection_add_targets", _wrap_gtk_selection_add_targets},
  { "gtk_selection_clear_targets", _wrap_gtk_selection_clear_targets},
  { "gtk_selection_convert", _wrap_gtk_selection_convert},
  { "gtk_selection_remove_all", _wrap_gtk_selection_remove_all},
  { "gtk_settings_get_default", _wrap_gtk_settings_get_default},
  { "gtk_settings_get_for_screen", _wrap_gtk_settings_get_for_screen},
  { "gtk_show_uri", _wrap_gtk_show_uri},
  { "gtk_style_context_add_provider_for_screen", _wrap_gtk_style_context_add_provider_for_screen},
  { "gtk_style_context_remove_provider_for_screen", _wrap_gtk_style_context_remove_provider_for_screen},
  { "gtk_style_context_reset_widgets", _wrap_gtk_style_context_reset_widgets},
  { "gtk_render_insertion_cursor", _wrap_gtk_render_insertion_cursor},
  { "gtk_test_register_all_types", _wrap_gtk_test_register_all_types},
  { "gtk_test_find_widget", _wrap_gtk_test_find_widget},
  { "gtk_test_create_widget", _wrap_gtk_test_create_widget},
  { "gtk_test_create_simple_window", _wrap_gtk_test_create_simple_window},
  { "gtk_test_display_button_window", _wrap_gtk_test_display_button_window},
  { "gtk_test_slider_set_perc", _wrap_gtk_test_slider_set_perc},
  { "gtk_test_slider_get_value", _wrap_gtk_test_slider_get_value},
  { "gtk_test_spin_button_click", _wrap_gtk_test_spin_button_click},
  { "gtk_test_widget_wait_for_draw", _wrap_gtk_test_widget_wait_for_draw},
  { "gtk_test_widget_click", _wrap_gtk_test_widget_click},
  { "gtk_test_widget_send_key", _wrap_gtk_test_widget_send_key},
  { "gtk_test_text_set", _wrap_gtk_test_text_set},
  { "gtk_test_text_get", _wrap_gtk_test_text_get},
  { "gtk_test_find_sibling", _wrap_gtk_test_find_sibling},
  { "gtk_test_find_label", _wrap_gtk_test_find_label},
  { "gtk_tooltip_trigger_tooltip_query", _wrap_gtk_tooltip_trigger_tooltip_query},
  { "gtk_tree_set_row_drag_data", _wrap_gtk_tree_set_row_drag_data},
  { "gtk_tree_get_row_drag_data", _wrap_gtk_tree_get_row_drag_data},
  { "gtk_tree_row_reference_inserted", _wrap_gtk_tree_row_reference_inserted},
  { "gtk_tree_row_reference_deleted", _wrap_gtk_tree_row_reference_deleted},
  { "gtk_tree_row_reference_reordered", _wrap_gtk_tree_row_reference_reordered},
  { "gtk_widget_set_default_direction", _wrap_gtk_widget_set_default_direction},
  { "gtk_widget_get_default_direction", _wrap_gtk_widget_get_default_direction},
  { "gtk_cairo_should_draw_window", _wrap_gtk_cairo_should_draw_window},
  { "gtk_cairo_transform_to_window", _wrap_gtk_cairo_transform_to_window},
  { "gtk_window_set_default_icon_list", _wrap_gtk_window_set_default_icon_list},
  { "gtk_window_get_default_icon_list", _wrap_gtk_window_get_default_icon_list},
  { "gtk_window_set_default_icon", _wrap_gtk_window_set_default_icon},
  { "gtk_window_set_default_icon_name", _wrap_gtk_window_set_default_icon_name},
  { "gtk_window_get_default_icon_name", _wrap_gtk_window_get_default_icon_name},
  { "gtk_window_set_default_icon_from_file", _wrap_gtk_window_set_default_icon_from_file},
  { "gtk_window_set_auto_startup_notification", _wrap_gtk_window_set_auto_startup_notification},
  { "gtk_window_list_toplevels", _wrap_gtk_window_list_toplevels},
  { "gtk_icon_size_lookup", _wrap_gtk_icon_size_lookup},
  { "gtk_icon_size_lookup_for_settings", _wrap_gtk_icon_size_lookup_for_settings},
  { NULL, NULL}
};

/* call ith function in the gtk interface */

int gtk_Interf(int i, Stack stack, int rhs, int opt, int lhs)
{
#ifdef NSP_WITH_MAIN_GTK_THREAD
  return nsp_interface_executed_in_main_thread(i,gtk_func[i].fonc,
  					       &stack,rhs,opt,lhs);
#else
  return (*(gtk_func[i].fonc))(stack,rhs,opt,lhs);
#endif
}

/* used to walk through the interface table 
    (for adding or removing functions) */

void gtk_Interf_Info(int i, char **fname, function ( **f))
{
  *fname = gtk_func[i].name;
  *f = gtk_func[i].fonc;
}

/* ----------- enums and flags ----------- */

void
gtk_add_constants(NspObject *module, const gchar *strip_prefix)
{
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_LICENSE, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_ACCEL_FLAGS, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_APPLICATION_INHIBIT_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_ASSISTANT_PAGE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_BUTTON_BOX_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_BUILDER_ERROR, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_CALENDAR_DISPLAY_OPTIONS, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_CELL_RENDERER_STATE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_CELL_RENDERER_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_CELL_RENDERER_ACCEL_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_RESIZE_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_CSS_PROVIDER_ERROR, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_CSS_SECTION_TYPE, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_DEBUG_FLAG, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_DIALOG_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_RESPONSE_TYPE, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_DEST_DEFAULTS, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_TARGET_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_ENTRY_ICON_POSITION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_ALIGN, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_ARROW_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_BASELINE_POSITION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_DELETE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_DIRECTION_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_ICON_SIZE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_SENSITIVITY_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_TEXT_DIRECTION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_JUSTIFICATION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_MENU_DIRECTION_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_MESSAGE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_MOVEMENT_STEP, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_SCROLL_STEP, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_ORIENTATION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PACK_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_POSITION_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_RELIEF_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_SCROLL_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_SELECTION_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_SHADOW_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_STATE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_TOOLBAR_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_WRAP_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_SORT_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_IM_PREEDIT_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_IM_STATUS_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PACK_DIRECTION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PRINT_PAGES, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PAGE_SET, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_NUMBER_UP_LAYOUT, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PAGE_ORIENTATION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PRINT_QUALITY, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PRINT_DUPLEX, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_UNIT, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_TREE_VIEW_GRID_LINES, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_DRAG_RESULT, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_SIZE_GROUP_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_SIZE_REQUEST_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_SCROLLABLE_POLICY, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_STATE_FLAGS, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_REGION_FLAGS, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_JUNCTION_SIDES, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_BORDER_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_LEVEL_BAR_MODE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_INPUT_PURPOSE, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_INPUT_HINTS, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_FILE_CHOOSER_ACTION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_FILE_CHOOSER_CONFIRMATION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_FILE_CHOOSER_ERROR, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_FILE_FILTER_FLAGS, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_ICON_LOOKUP_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_ICON_THEME_ERROR, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_ICON_VIEW_DROP_POSITION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_IMAGE_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_ARROW_PLACEMENT, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_BUTTONS_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_NOTEBOOK_TAB, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_PLACES_OPEN_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PRINT_STATUS, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PRINT_OPERATION_RESULT, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PRINT_OPERATION_ACTION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PRINT_ERROR, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_RECENT_SORT_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_RECENT_CHOOSER_ERROR, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_RECENT_FILTER_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_RECENT_MANAGER_ERROR, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_REVEALER_TRANSITION_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_CORNER_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_POLICY_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_SPIN_BUTTON_UPDATE_POLICY, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_SPIN_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_STACK_TRANSITION_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_TEXT_BUFFER_TARGET_INFO, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_TEXT_SEARCH_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_TEXT_WINDOW_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_TOOLBAR_SPACE_STYLE, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_TOOL_PALETTE_DRAG_TARGETS, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_TREE_MODEL_FLAGS, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_TREE_VIEW_DROP_POSITION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_TREE_VIEW_COLUMN_SIZING, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_WIDGET_HELP_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_WINDOW_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_WINDOW_POSITION, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_EXPANDER_STYLE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PATH_PRIORITY_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_PATH_TYPE, strip_prefix);
  nsp_enum_add_constants((NspHash  * ) module, GTK_TYPE_RC_TOKEN_TYPE, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_ATTACH_OPTIONS, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_RC_FLAGS, strip_prefix);
  nsp_flags_add_constants((NspHash * ) module, GTK_TYPE_UI_MANAGER_ITEM_TYPE, strip_prefix);
}

void nsp_initialize_gtk_types(void)
{
  new_type_gtktextiter(T_BASE);
  new_type_gtkborder(T_BASE);
  new_type_gtkiconinfo(T_BASE);
  new_type_gtkrequisition(T_BASE);
  new_type_gtkselectiondata(T_BASE);
  new_type_gtktextattributes(T_BASE);
  new_type_gtktreeiter(T_BASE);
  new_type_gtktreerowreference(T_BASE);
  new_type_gtktreepath(T_BASE);
  new_type_gtkcsssection(T_BASE);
  new_type_gtkactionable(T_BASE);
  new_type_gtkbuildable(T_BASE);
  new_type_gtkorientable(T_BASE);
  new_type_gtkeditable(T_BASE);
  new_type_gtktreemodel(T_BASE);
  new_type_gtktreesortable(T_BASE);
  new_type_gtkcelllayout(T_BASE);
  new_type_gtkcelleditable(T_BASE);
  new_type_gtktoolshell(T_BASE);
  new_type_gtkcolorchooser(T_BASE);
  new_type_gtkfilechooser(T_BASE);
  new_type_gtkfontchooser(T_BASE);
  new_type_gtkscrollable(T_BASE);
  new_type_gtkrecentchooser(T_BASE);
  new_type_gtkappchooser(T_BASE);
  new_type_gtktreedragdest(T_BASE);
  new_type_gtktreedragsource(T_BASE);
  new_type_gtkapplication(T_BASE);
  new_type_gtkapplicationwindow(T_BASE);
  new_type_gtkbuilder(T_BASE);
  new_type_gtkwindow(T_BASE);
  new_type_gtkdialog(T_BASE);
  new_type_gtkmessagedialog(T_BASE);
  new_type_gtkaboutdialog(T_BASE);
  new_type_gtkassistant(T_BASE);
  new_type_gtkinvisible(T_BASE);
  new_type_gtkoffscreenwindow(T_BASE);
  new_type_gtkwindowgroup(T_BASE);
  new_type_gtkbox(T_BASE);
  new_type_gtkgrid(T_BASE);
  new_type_gtkrevealer(T_BASE);
  new_type_gtklistbox(T_BASE);
#if GTK_CHECK_VERSION(3,12,0) 
  new_type_gtkflowbox(T_BASE);
#endif /* GTK_CHECK_VERSION */
  new_type_gtkstack(T_BASE);
  new_type_gtkstackswitcher(T_BASE);
#if GTK_CHECK_VERSION(3,16,0) 
  new_type_gtkstacksidebar(T_BASE);
#endif /* GTK_CHECK_VERSION */
#if GTK_CHECK_VERSION(3,12,0) 
  new_type_gtkactionbar(T_BASE);
#endif /* GTK_CHECK_VERSION */
  new_type_gtkheaderbar(T_BASE);
  new_type_gtkoverlay(T_BASE);
  new_type_gtkbuttonbox(T_BASE);
  new_type_gtkpaned(T_BASE);
  new_type_gtklayout(T_BASE);
  new_type_gtknotebook(T_BASE);
  new_type_gtkexpander(T_BASE);
  new_type_gtkaspectframe(T_BASE);
  new_type_gtkfixed(T_BASE);
  new_type_gtklabel(T_BASE);
  new_type_gtkimage(T_BASE);
  new_type_gtkspinner(T_BASE);
  new_type_gtkinfobar(T_BASE);
  new_type_gtkprogressbar(T_BASE);
  new_type_gtklevelbar(T_BASE);
  new_type_gtkstatusbar(T_BASE);
  new_type_gtkaccellabel(T_BASE);
  new_type_gtkbutton(T_BASE);
  new_type_gtkcheckbutton(T_BASE);
  new_type_gtkradiobutton(T_BASE);
  new_type_gtktogglebutton(T_BASE);
  new_type_gtklinkbutton(T_BASE);
  new_type_gtkmenubutton(T_BASE);
  new_type_gtkswitch(T_BASE);
  new_type_gtkscalebutton(T_BASE);
  new_type_gtkvolumebutton(T_BASE);
  new_type_gtklockbutton(T_BASE);
#if GTK_CHECK_VERSION(3,16,0) 
  new_type_gtkmodelbutton(T_BASE);
#endif /* GTK_CHECK_VERSION */
  new_type_gtkentry(T_BASE);
  new_type_gtkentrybuffer(T_BASE);
  new_type_gtkentrycompletion(T_BASE);
  new_type_gtkscale(T_BASE);
  new_type_gtkspinbutton(T_BASE);
  new_type_gtksearchentry(T_BASE);
  new_type_gtksearchbar(T_BASE);
  new_type_gtktextmark(T_BASE);
  new_type_gtktextbuffer(T_BASE);
  new_type_gtktexttag(T_BASE);
  new_type_gtktexttagtable(T_BASE);
  new_type_gtktextview(T_BASE);
  new_type_gtktextchildanchor(T_BASE);
  new_type_gtktreeselection(T_BASE);
  new_type_gtktreeviewcolumn(T_BASE);
  new_type_gtktreeview(T_BASE);
  new_type_gtkcellview(T_BASE);
  new_type_gtkiconview(T_BASE);
  new_type_gtktreemodelsort(T_BASE);
  new_type_gtktreemodelfilter(T_BASE);
  new_type_gtkcellarea(T_BASE);
  new_type_gtkcellareabox(T_BASE);
  new_type_gtkcellareacontext(T_BASE);
  new_type_gtkcellrenderer(T_BASE);
  new_type_gtkcellrendereraccel(T_BASE);
  new_type_gtkcellrenderercombo(T_BASE);
  new_type_gtkcellrendererpixbuf(T_BASE);
  new_type_gtkcellrendererprogress(T_BASE);
  new_type_gtkcellrendererspin(T_BASE);
  new_type_gtkcellrenderertext(T_BASE);
  new_type_gtkcellrenderertoggle(T_BASE);
  new_type_gtkcellrendererspinner(T_BASE);
  new_type_gtkliststore(T_BASE);
  new_type_gtktreestore(T_BASE);
  new_type_gtkcombobox(T_BASE);
  new_type_gtkcomboboxtext(T_BASE);
  new_type_gtkmenu(T_BASE);
  new_type_gtkmenubar(T_BASE);
  new_type_gtkmenuitem(T_BASE);
  new_type_gtkradiomenuitem(T_BASE);
  new_type_gtkcheckmenuitem(T_BASE);
  new_type_gtkseparatormenuitem(T_BASE);
  new_type_gtktoolbar(T_BASE);
  new_type_gtktoolitem(T_BASE);
  new_type_gtktoolpalette(T_BASE);
  new_type_gtktoolitemgroup(T_BASE);
  new_type_gtkseparatortoolitem(T_BASE);
  new_type_gtktoolbutton(T_BASE);
  new_type_gtkmenutoolbutton(T_BASE);
  new_type_gtktoggletoolbutton(T_BASE);
  new_type_gtkradiotoolbutton(T_BASE);
#if GTK_CHECK_VERSION(3,12,0) 
  new_type_gtkpopover(T_BASE);
#endif /* GTK_CHECK_VERSION */
#if GTK_CHECK_VERSION(3,16,0) 
  new_type_gtkpopovermenu(T_BASE);
#endif /* GTK_CHECK_VERSION */
  new_type_gtkcolorbutton(T_BASE);
  new_type_gtkcolorchooserwidget(T_BASE);
  new_type_gtkcolorchooserdialog(T_BASE);
  new_type_gtkfilechooserbutton(T_BASE);
  new_type_gtkfilechooserdialog(T_BASE);
  new_type_gtkfilechooserwidget(T_BASE);
  new_type_gtkfilefilter(T_BASE);
  new_type_gtkfontbutton(T_BASE);
  new_type_gtkfontchooserwidget(T_BASE);
  new_type_gtkfontchooserdialog(T_BASE);
  new_type_gtkplacessidebar(T_BASE);
  new_type_gtkframe(T_BASE);
  new_type_gtkseparator(T_BASE);
  new_type_gtkscrollbar(T_BASE);
  new_type_gtkscrolledwindow(T_BASE);
  new_type_gtkprintoperation(T_BASE);
  new_type_gtkprintoperationpreview(T_BASE);
  new_type_gtkprintcontext(T_BASE);
  new_type_gtkadjustment(T_BASE);
  new_type_gtkcalendar(T_BASE);
  new_type_gtkdrawingarea(T_BASE);
  new_type_gtkeventbox(T_BASE);
  new_type_gtkimcontextsimple(T_BASE);
  new_type_gtkimmulticontext(T_BASE);
  new_type_gtksizegroup(T_BASE);
  new_type_gtktooltip(T_BASE);
  new_type_gtkviewport(T_BASE);
  new_type_gtkaccessible(T_BASE);
  new_type_gtkwidget(T_BASE);
  new_type_gtkcontainer(T_BASE);
  new_type_gtkbin(T_BASE);
  new_type_gtkmenushell(T_BASE);
  new_type_gtkrange(T_BASE);
  new_type_gtkimcontext(T_BASE);
  new_type_gtkrecentmanager(T_BASE);
  new_type_gtkrecentchooserdialog(T_BASE);
  new_type_gtkrecentchooserwidget(T_BASE);
  new_type_gtkrecentfilter(T_BASE);
  new_type_gtkappchooserbutton(T_BASE);
  new_type_gtkappchooserdialog(T_BASE);
  new_type_gtkappchooserwidget(T_BASE);
  new_type_gtksettings(T_BASE);
  new_type_gtkstylecontext(T_BASE);
  new_type_gtkuimanager(T_BASE);
  new_type_gtkactiongroup(T_BASE);
  new_type_gtkaction(T_BASE);
  new_type_gtktoggleaction(T_BASE);
  new_type_gtkradioaction(T_BASE);
  new_type_gtkimagemenuitem(T_BASE);
  new_type_gtkmisc(T_BASE);
  new_type_gtkalignment(T_BASE);
  new_type_gtkicontheme(T_BASE);
  new_type_gtkaccelgroup(T_BASE);
  new_type_gtkcssprovider(T_BASE);
  new_type_gtkstyleprovider(T_BASE);
  new_type_gtkclipboard(T_BASE);
}

#line 8197 "codegen-3.0/gtk.override"

static GtkTargetEntry * nsp_gtk_target_entry_from_list(Stack stack,NspList *list,int *n_targets)
{
  int i=0;
  GtkTargetEntry *targets= NULL;
  Cell *cloc = list->first ;

  while ( cloc != NULLCELL) {
    if ( cloc->O != NULLOBJ ) i++;
    cloc = cloc->next;
  }
  *n_targets = i;
  if ( i == 0) return targets;

  if (( targets = g_new(GtkTargetEntry, *n_targets))== NULL) return targets;
  i=0;
  cloc = list->first ;
  while ( cloc != NULLCELL)
    {
      if ( cloc->O != NULLOBJ )
	{
	  if (! IsList(cloc->O) )
	    {
	      Scierror("%s: list item %d is not a list \n",NspFname(stack),i+1);
	      g_free(targets);
	      return NULL;
	    }
	  else
	    {
	      NspList *loc = (NspList *)cloc->O;
	      int_types T[] = { string,s_int,s_int, t_end} ;
	      if ( GetListArgs(loc,i+1,T, &targets[i].target,&targets[i].flags, &targets[i].info)== FAIL)
		{
		  g_free(targets);
		  return NULL;
		}
	    }
	}
      cloc = cloc->next;
      i++;
    }

  return targets;
}

/* detail func for calendar */

/**
 * calendar_detail_func_clean:
 * @obj:  calendar_detail_func_data struct
 * 
 * clean after integration 
 **/
/* 
static void calendar_detail_func_clean(calendar_detail_func_data *obj)
{
  nsp_object_destroy( (NspObject **) &(obj->func));
  nsp_matrix_destroy(obj->ymd);
  free(obj->targs);
}
*/
/**
 * calendar_detail_func:
 * 
 **/

static gchar *calendar_detail_func(GtkCalendar *calendar, guint year, guint month, 
				   guint day, gpointer user_data)
{
  GQuark quark = g_quark_from_string("calendar_detail");
  calendar_detail_func_data *df;
  NspObject *nsp_ret;
  int nret = 1;
  df = g_object_get_qdata(G_OBJECT(calendar), quark);
  
  df->ymd->R[0] = year;
  df->ymd->R[1] = month;
  df->ymd->R[2] = day;
  
  if ( nsp_gtk_eval_function_catch((NspPList *) df->func, df->targs, df->nargs,
				   &nsp_ret,&nret,df->errcatch,df->pausecatch)== FAIL) 
    {
      Scierror("Error: calendar_detail_func: failure in function evaluation\n");
      return NULL;
    }
  
  if (nret ==1 && IsSMat(nsp_ret) && ((NspSMatrix *) nsp_ret)->mn == 1 ) 
    {
      return ((NspSMatrix *) nsp_ret)->S[0];
    }
  else 
    {
      Scierror("Error:  calendar_detail_func : a problem occured in function evaluation:\n");
      if ( nret != 1 )
	Scierror("        function don't return one argument\n");
      else if ( !IsSMat(nsp_ret) )
	Scierror("        function don't return the good type (must be a SMat)\n");
      else if ( ((NspMatrix *) nsp_ret)->mn != 1 )
	Scierror("        function don't return a vector of good length (wait for %d and got %d) \n",
		 1,((NspMatrix *) nsp_ret)->mn);
      nsp_object_destroy((NspObject **) &nsp_ret);
      return NULL;
    }
}


static void gtk_drag_set_icon_gicon_redef (GdkDragContext *context,
					   GIcon          *icon,
					   gint            hot_x,
					   gint            hot_y)
{
#ifndef WITH_GTKOSX 
  gtk_drag_set_icon_gicon  (context,icon,hot_x,hot_y);
#else
  Sciprintf("  gtk_drag_set_icon_gicon not found on gtk+3 (3.22) on macosx\n");
#endif
}


  // gtk_drag_set_icon_gicon(GDK_DRAG_CONTEXT(context->obj),G_ICON(icon->obj),hot_x,hot_y);
void gtk_drag_set_icon_gicon  (GdkDragContext *context,
                               GIcon          *icon,
                               gint            hot_x,
                               gint            hot_y);

#line 79457 "gtk.c"
