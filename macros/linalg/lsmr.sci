function [x, istop, itn, normr, normAr, normA, condA, normx] = lsmr(A, b, lambda=0, atol=1e-6,...
						  btol=1e-6, conlim=1e8, ...
						  itnlim=[], localSize=0, ...
						  show=%f)
   // LSMR   Iterative solver for least-squares problems.
   //   X = LSMR(A,B) solves the system of linear equations A*X=B. If the system
   //   is inconsistent, it solves the least-squares problem min ||b - Ax||_2. 
   //   A is a rectangular matrix of dimension m-by-n, where all cases are
   //   allowed: m=n, m>n, or m<n. B is a vector of length m.
   //   The matrix A may be dense or sparse (usually sparse).
   // 
   //   X = LSMR(AFUN,B) takes a function handle AFUN instead of the matrix A. 
   //   AFUN(X,1) takes a vector X and returns A*X. AFUN(X,2) returns A'*X.
   //   AFUN can be used in all the following syntaxes.
   //   
   //   X = LSMR(A,B,lambda=LAMBDA) solves the regularized least-squares problem
   //      min ||(B) - (   A    )X||  
   //          ||(0)   (LAMBDA*I) ||_2
   //   where LAMBDA is a scalar.  Default value is 0, the system is solved
   //   without regularization. 
   // 
   //   X = LSMR(A,B,atol=ATOL,btol=BTOL) continues iterations until a certain
   //   backward error estimate is smaller than some quantity depending on
   //   ATOL and BTOL.  Let RES = B - A*X be the residual vector for the
   //   current approximate solution X.  If A*X = B seems to be consistent,
   //   LSMR terminates when NORM(RES) <= ATOL*NORM(A)*NORM(X) + BTOL*NORM(B).
   //   Otherwise, LSMR terminates when NORM(A'*RES) <= ATOL*NORM(A)*NORM(RES).
   //   If both tolerances are 1.0e-6 (say), the final NORM(RES) should be
   //   accurate to about 6 digits. (The final X will usually have fewer
   //   correct digits, depending on cond(A) and the size of LAMBDA.)
   //   If ATOL or BTOL are not specified, a default value of 1.0e-6 will be used.
   //   Ideally, they should be estimates of the relative error in the
   //   entries of A and B respectively.  For example, if the entries of A
   //   have 7 correct digits, set atol = 1e-7. This prevents the algorithm
   //   from doing unnecessary work beyond the uncertainty of the input data.
   // 
   //   X = LSMR(A,B,condlim=CONLIM) terminates if an estimate
   //   of cond(A) exceeds CONLIM. For compatible systems Ax = b,
   //   conlim could be as large as 1.0e+12 (say).  For least-squares problems,
   //   conlim should be less than 1.0e+8. If CONLIM is not specified, the default value 
   //   is 1e+8. Maximum precision can be obtained by setting 
   //   atol = 0, btol = 0, conlim=0, but the number of iterations may then be 
   //   excessive.
   //
   //   X = LSMR(A,B,itnlim=ITNLIM) terminates if the 
   //   number of iterations reaches ITNLIM.  The default is ITNLIM = min(m,n).
   //   For ill-conditioned systems, a larger value of ITNLIM may be needed.
   //   
   //   X = LSMR(A,B,localsize=LOCALSIZE) runs LSMR
   //   with rerorthogonalization on the last LOCALSIZE v_k's. (v-vectors
   //   generated by Golub-Kahan bidiagonalization) A LOCALSIZE of 0 or [] runs 
   //   LSMR without reorthogonalization. A LOCALSIZE of Inf performs 
   //   reothogonalization on all v_k's. Reorthgonalizing only u_k or both u_k 
   //   and v_k are not an option here. Details are discussed in the
   //   submitted SIAM paper.
   //
   //   X = LSMR(A,B,show=SHOW) prints an
   //   iteration log if SHOW=%t. The default value is %f
   //  
   //   [X,ISTOP] = LSMR(A,B,...) gives the reason for termination.
   //      ISTOP  = 0 means X=0 is a solution.
   //             = 1 means X is an approximate solution to A*X = B,
   //                 according to ATOL and BTOL.
   //             = 2 means X approximately solves the least-squares problem
   //                 according to ATOL.
   //             = 3 means COND(A) seems to be greater than CONLIM.
   //             = 4 is the same as 1 with ATOL = BTOL = EPS.
   //             = 5 is the same as 2 with ATOL = EPS.
   //             = 6 is the same as 3 with CONLIM = 1/EPS.
   //             = 7 means ITN reached ITNLIM before the other stopping
   //                 conditions were satisfied.
   //
   //   [X,ISTOP,ITN] = LSMR(A,B,...) gives ITN = the number of LSMR iterations.
   //
   //   [X,ISTOP,ITN,NORMR] = LSMR(A,B,...) gives an estimate of the residual
   //   norm: NORMR = norm(B-A*X).
   //
   //   [X,ISTOP,ITN,NORMR,NORMAR] = LSMR(A,B,...) gives an estimate of the
   //   residual for the normal equation: NORMAR = NORM(A'*(B-A*X)).
   //
   //   [X,ISTOP,ITN,NORMR,NORMAR,NORMA] = LSMR(A,B,...) gives an estimate of
   //   the Frobenius norm of A.
   //   
   //   [X,ISTOP,ITN,NORMR,NORMAR,NORMA,CONDA] = LSMR(A,B,...) gives an estimate
   //   of the condition number of A.
   //   
   //   [X,ISTOP,ITN,NORMR,NORMAR,NORMA,CONDA,NORMX] = LSMR(A,B,...) gives an
   //   estimate of NORM(X).

   //   LSMR uses an iterative method.
   //   For further information, see 
   //      D. C.-L. Fong and M. A. Saunders 
   //      LSMR: An iterative algorithm for least-square problems
   //      Draft of 03 Apr 2010, to be submitted to SISC.
   //
   // 08 Dec 2009: First release version of LSMR.
   // 09 Apr 2010: Updated documentation and default parameters.
   // 14 Apr 2010: Updated documentation.
   // 03 Jun 2010: LSMR with local reorthogonalization 
   //              (full reorthogonalization is also implemented)

   // David Chin-lung Fong            clfong@stanford.edu
   // Institute for Computational and Mathematical Engineering
   // Stanford University
   //
   // Michael Saunders                saunders@stanford.edu
   // Systems Optimization Laboratory
   // Dept of MS&E, Stanford University.

   // Copyright (c) 2010, David
   // All rights reserved.
   // 
   // Redistribution and use in source and binary forms, with or without 
   // modification, are permitted provided that the following conditions are 
   // met:
   // 
   //     * Redistributions of source code must retain the above copyright 
   //       notice, this list of conditions and the following disclaimer.
   //     * Redistributions in binary form must reproduce the above copyright 
   //       notice, this list of conditions and the following disclaimer in 
   //       the documentation and/or other materials provided with the distribution
   //       
   // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
   // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
   // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
   // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
   // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
   // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
   // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
   // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
   // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
   // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
   // POSSIBILITY OF SUCH DAMAGE.

   // adapted for nsp by Bruno Pincon:
   //    (i)   adapt comments (% changed in //) and some very few syntax differences
   //    (ii)  2 internal functions are inlined in the main code
   //    (iii) add some tests (A and b should be real, b should be a real column vector)
   //    (iv)  use named optional arguments (avoiding to pass [] for not
   //          specified optional argument placed before those the user wants to set)
   //-----------------------------------------------------------------------

   // Initialize.

   if (is(A,%types.SpColMat) || is(A,%types.Mat)) && isreal(A) then
      explicitA = %t;
   elseif is(A,%types.PList) then
      explicitA = %f;
   else
      error("lsmr: first argument A must be a real full or sparse matrix or a function");
   end

   if ~( is(b,%types.Mat) && size(b,2) == 1 && isreal(b)) then
      error("lsmr: second argument should be a real column vector");
   end

   msg = ["The exact solution is  x = 0                              ";
	  "Ax - b is small enough, given atol, btol                  ";
	  "The least-squares solution is good enough, given atol     ";
	  "The estimate of cond(Abar) has exceeded conlim            ";
	  "Ax - b is small enough for this machine                   ";
	  "The least-squares solution is good enough for this machine";
	  "Cond(Abar) seems to be too large for this machine         ";
	  "The iteration limit has been reached                      "];

   hdg1 = "   itn      x(1)       norm r    norm A''r";
   hdg2 = " compatible   LS      norm A   cond A";
   pfreq  = 20;   // print frequency (for repeating the heading)
   pcount = 0;    // print counter

   // Determine dimensions m and n, and
   // form the first vectors u and v.
   // These satisfy  beta*u = b,  alpha*v = A'u.
   u    = b;
   beta = norm(u);
   if beta > 0 then
      u  = u/beta;
   end

   if explicitA then
      [m, n] = size(A);
      if size(b,1) <> m then
	 error("lsmr: incompatible sizes between first and second argument")
      end
      v = pmult(A,u);
   else  
      v = A(u,2);      // first time we call A: test if v is a real column vector
      [n,dummy] = size(v);
      if ~ (is(v,%types.Mat) && dummy==1 && isreal(v) ) then
	 error("lsmr: when first arg A is a function A(.,2) should return a real vector")
      end
      m = size(b,1);
   end

   // stores the num of singular values
   minDim = min(m,n);

   if isempty(itnlim) then itnlim = minDim; end

   if show then
      printf("\n\nLSMR            Least-squares solution of  Ax = b")
      printf("\nVersion 1.02 (adapted for nsp)          14 Apr 2010")
      printf("\nThe matrix A has %8g rows  and %8g cols", m,n)
      printf("\nlambda = %16.10e", lambda )
      printf("\natol   = %8.2e               conlim = %8.2e", atol,conlim)
      printf("\nbtol   = %8.2e               itnlim = %8g"  , btol,itnlim)
   end

   alpha = norm(v);
   if alpha > 0 then
      v = (1/alpha)*v;
   end

   // Initialization for local reorthogonalization
   localOrtho = %f;
   if localSize>0 then
      localPointer = 1;
      localOrtho = %t;
      localVQueueFull = %f;

      // Preallocate storage for storing the last few v_k. Since with
      // orthogonal v_k's, Krylov subspace method would converge in not 
      // more iterations than the number of singular values, a bigger is
      // space is not necessary. 
      if (localSize > minDim) then localSize = minDim; end
      localV = zeros(n, localSize);
      localV(:,1) = v;
   end

   // Initialize variables for 1st iteration.
   itn      = 0;
   zetabar  = alpha*beta;
   alphabar = alpha;
   rho      = 1;
   rhobar   = 1;
   cbar     = 1;
   sbar     = 0;

   h    = v;
   hbar = zeros(n,1);
   x    = zeros(n,1);

   // Initialize variables for estimation of ||r||.
   betadd      = beta;
   betad       = 0;
   rhodold     = 1;
   tautildeold = 0;
   thetatilde  = 0;
   zeta        = 0;
   d           = 0;

   // Initialize variables for estimation of ||A|| and cond(A)
   normA2  = alpha^2;
   maxrbar = 0;
   minrbar = 1e+100;

   // Items for use in stopping rules.
   normb  = beta;
   istop  = 0;
   ctol   = 0;         if conlim > 0 then ctol = 1/conlim; end
   normr  = beta;

   // Exit if b=0 or A'b = 0.

   normAr = alpha * beta;
   if normAr == 0 then print(msg(1,:)); return, end

   // Heading for iteration log.

   if show then
      test1 = 1;
      test2 = alpha/beta;
      printf("\n\n%s%s"      , hdg1 , hdg2   )
      printf("\n%6g %12.5e"  , itn  , x(1)   )
      printf(" %10.3e %10.3e", normr, normAr )
      printf("  %8.1e %8.1e" , test1, test2  )
   end


   //------------------------------------------------------------------
   //     Main iteration loop.
   //------------------------------------------------------------------
   while itn < itnlim do
      itn = itn + 1;

      // Perform the next step of the bidiagonalization to obtain the
      // next beta, u, alpha, v.  These satisfy the relations
      //      beta*u  =  A*v  - alpha*u,
      //      alpha*v  =  A'*u - beta*v.
      if explicitA then
	 u = A*v    - alpha*u;
      elseif itn == 1 then 
	 // first time we call A(.,1) test if it returns a real column vector with good dimension
	 uu = A(v,1);
	 if ~ (is(uu,%types.Mat) && size(uu,2)==1 && size(uu,1)==n && isreal(uu)) then
	    error("lsmr: when first arg A is a function A(.,1) should return a real vector of same size than b")
	 end
	 u = uu - alpha*u; clear uu;
      else
	 u = A(v,1) - alpha*u; 
      end
      beta = norm(u);
      if beta > 0 then
	 u     = (1/beta)*u;
	 if localOrtho then 
	   // store data for local-reorthogonalization of V
	   if (localPointer < localSize) then 
	     localPointer.add[1];
	   else
	     localPointer = 1;  localVQueueFull = %t;
	   end
	   localV(:,localPointer) = v;
	 end
	 if explicitA then
	    v = pmult(A,u) - beta*v;
	 else
	    v = A(u,2)  - beta*v;
	 end
	 if localOrtho then 
	   // local-reorthogonalization of V
	   if localVQueueFull then
	     localOrthoLimit = localSize
	   else
	     localOrthoLimit = localPointer;
	   end
	   for localOrthoCount = 1:localOrthoLimit do
	     vtemp = localV(:, localOrthoCount);
	     v = v - pmult(v,vtemp)*vtemp;
	   end
	 end
	 alpha  = norm(v);
	 if alpha > 0 then  v = (1/alpha)*v; end
      end
      // At this point, beta = beta_{k+1}, alpha = alpha_{k+1}.
      // Construct rotation Qhat_{k,2k+1}.
      alphahat = norm([alphabar, lambda]);
      chat     = alphabar/alphahat;
      shat     = lambda/alphahat;

      // Use a plane rotation (Q_i) to turn B_i to R_i
      rhoold   = rho;
      rho      = norm([alphahat, beta]);
      c        = alphahat/rho;
      s        = beta/rho;
      thetanew = s*alpha;
      alphabar = c*alpha;

      // Use a plane rotation (Qbar_i) to turn R_i^T to R_i^bar
      rhobarold = rhobar;
      zetaold   = zeta;
      thetabar  = sbar*rho;
      rhotemp   = cbar*rho;
      rhobar    = norm([cbar*rho, thetanew]);
      cbar      = cbar*rho/rhobar;
      sbar      = thetanew/rhobar;
      zeta      =   cbar*zetabar;
      zetabar   = - sbar*zetabar;
      // Update h, h_hat, x.
      hbar      = h - (thetabar*rho/(rhoold*rhobarold))*hbar;
      x         = x + (zeta/(rho*rhobar))*hbar;
      h         = v - (thetanew/rho)*h;
      // Estimate of ||r||.
      // Apply rotation Qhat_{k,2k+1}.
      betaacute =   chat* betadd;
      betacheck = - shat* betadd;
      // Apply rotation Q_{k,k+1}.
      betahat   =   c*betaacute;
      betadd    = - s*betaacute;
      // Apply rotation Qtilde_{k-1}.
      // betad = betad_{k-1} here.
      thetatildeold = thetatilde;
      rhotildeold   = norm([rhodold, thetabar]);
      ctildeold     = rhodold/rhotildeold;
      stildeold     = thetabar/rhotildeold;
      thetatilde    = stildeold* rhobar;
      rhodold       =   ctildeold* rhobar;
      betad         = - stildeold*betad + ctildeold*betahat;
      // betad   = betad_k here.
      // rhodold = rhod_k  here.
      tautildeold   = (zetaold - thetatildeold*tautildeold)/rhotildeold;
      taud          = (zeta - thetatilde*tautildeold)/rhodold;
      d             = d + betacheck^2;
      normr         = sqrt(d + (betad - taud)^2 + betadd^2);
      // Estimate ||A||.
      normA2        = normA2 + beta^2;
      normA         = sqrt(normA2);
      normA2        = normA2 + alpha^2;
      // Estimate cond(A).
      maxrbar       = max(maxrbar,rhobarold);
      if itn>1 then 
	 minrbar    = min(minrbar,rhobarold);
      end
      condA         = max(maxrbar,rhotemp)/min(minrbar,rhotemp);
      // Test for convergence.
      // Compute norms for convergence testing.
      normAr  = abs(zetabar);
      normx   = norm(x);
      // Now use these norms to estimate certain other quantities,
      // some of which will be small near a solution.
      test1   = normr /normb;
      test2   = normAr/(normA*normr);
      test3   =      1/condA;
      t1      =  test1/(1 + normA*normx/normb);
      rtol    = btol + atol*normA*normx/normb;
      // The following tests guard against extremely small values of
      // atol, btol or ctol.  (The user may have set any or all of
      // the parameters atol, btol, conlim  to 0.)
      // The effect is equivalent to the normAl tests using
      // atol = eps,  btol = eps,  conlim = 1/eps.
      if itn >= itnlim then   istop = 7; end
      if 1 + test3  <= 1 then istop = 6; end
      if 1 + test2  <= 1 then istop = 5; end
      if 1 + t1     <= 1 then istop = 4; end
      // Allow for tolerances set by the user.
      if  test3 <= ctol then  istop = 3; end
      if  test2 <= atol then  istop = 2; end
      if  test1 <= rtol then  istop = 1; end
      // See if it is time to print something.
      if show then
	 prnt = 0;
	 if n     <= 40        then prnt = 1; end
	 if itn   <= 10        then prnt = 1; end
	 if itn   >= itnlim-10 then prnt = 1; end
	 if mod(itn,10) == 0   then prnt = 1; end
	 if test3 <= 1.1*ctol  then prnt = 1; end
	 if test2 <= 1.1*atol  then prnt = 1; end
	 if test1 <= 1.1*rtol  then prnt = 1; end
	 if istop <>  0        then prnt = 1; end
	 if prnt then
	    if pcount >= pfreq then
	       pcount = 0;
	       printf("\n\n%s%s"    , hdg1 , hdg2  )
	    end
	    pcount = pcount + 1;
	    printf("\n%6g %12.5e"  , itn  , x(1)  )
	    printf(" %10.3e %10.3e", normr, normAr)
	    printf("  %8.1e %8.1e" , test1, test2 )
	    printf(" %8.1e %8.1e"  , normA, condA )
	 end
      end
      if istop > 0 then break, end
   end // iteration loop
   
   // Print the stopping condition.
   
   if show then
     printf("\n\nLSMR finished")
      printf("\n%s", msg(istop+1,:))
      printf("\nistop =%8g    normr =%8.1e"     , istop, normr )
      printf("    normA =%8.1e    normAr =%8.1e", normA, normAr)
      printf("\nitn   =%8g    condA =%8.1e"     , itn  , condA )
      printf("    normx =%8.1e\n", normx)
   end
   
endfunction
